(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
const core_1 = require('@angular/core');
let AppComponent = class AppComponent {
};
AppComponent = __decorate([
    core_1.Component({
        selector: 'my-app',
        template: '<h1>My First Angular App</h1>'
    }), 
    __metadata('design:paramtypes', [])
], AppComponent);
exports.AppComponent = AppComponent;
},{"@angular/core":6}],2:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
const core_1 = require('@angular/core');
const platform_browser_1 = require('@angular/platform-browser');
const app_component_1 = require('./app.component');
let AppModule = class AppModule {
};
AppModule = __decorate([
    core_1.NgModule({
        imports: [platform_browser_1.BrowserModule],
        declarations: [app_component_1.AppComponent],
        bootstrap: [app_component_1.AppComponent]
    }), 
    __metadata('design:paramtypes', [])
], AppModule);
exports.AppModule = AppModule;
},{"./app.component":1,"@angular/core":6,"@angular/platform-browser":8}],3:[function(require,module,exports){
"use strict";
const platform_browser_dynamic_1 = require('@angular/platform-browser-dynamic');
const app_module_1 = require('./app.module');
const platform = platform_browser_dynamic_1.platformBrowserDynamic();
platform.bootstrapModule(app_module_1.AppModule);
},{"./app.module":2,"@angular/platform-browser-dynamic":7}],4:[function(require,module,exports){
(function (global){
/**
 * @license Angular v2.1.1
 * (c) 2010-2016 Google, Inc. https://angular.io/
 * License: MIT
 */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core')) :
    typeof define === 'function' && define.amd ? define(['exports', '@angular/core'], factory) :
    (factory((global.ng = global.ng || {}, global.ng.common = global.ng.common || {}),global.ng.core));
}(this, function (exports,_angular_core) { 'use strict';

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * This class should not be used directly by an application developer. Instead, use
     * {@link Location}.
     *
     * `PlatformLocation` encapsulates all calls to DOM apis, which allows the Router to be platform
     * agnostic.
     * This means that we can have different implementation of `PlatformLocation` for the different
     * platforms
     * that angular supports. For example, the default `PlatformLocation` is {@link
     * BrowserPlatformLocation},
     * however when you run your app in a WebWorker you use {@link WebWorkerPlatformLocation}.
     *
     * The `PlatformLocation` class is used directly by all implementations of {@link LocationStrategy}
     * when
     * they need to interact with the DOM apis like pushState, popState, etc...
     *
     * {@link LocationStrategy} in turn is used by the {@link Location} service which is used directly
     * by
     * the {@link Router} in order to navigate between routes. Since all interactions between {@link
     * Router} /
     * {@link Location} / {@link LocationStrategy} and DOM apis flow through the `PlatformLocation`
     * class
     * they are all platform independent.
     *
     * @stable
     */
    var PlatformLocation = (function () {
        function PlatformLocation() {
        }
        Object.defineProperty(PlatformLocation.prototype, "pathname", {
            get: function () { return null; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PlatformLocation.prototype, "search", {
            get: function () { return null; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PlatformLocation.prototype, "hash", {
            get: function () { return null; },
            enumerable: true,
            configurable: true
        });
        return PlatformLocation;
    }());

    /**
     * `LocationStrategy` is responsible for representing and reading route state
     * from the browser's URL. Angular provides two strategies:
     * {@link HashLocationStrategy} and {@link PathLocationStrategy} (default).
     *
     * This is used under the hood of the {@link Location} service.
     *
     * Applications should use the {@link Router} or {@link Location} services to
     * interact with application route state.
     *
     * For instance, {@link HashLocationStrategy} produces URLs like
     * `http://example.com#/foo`, and {@link PathLocationStrategy} produces
     * `http://example.com/foo` as an equivalent URL.
     *
     * See these two classes for more.
     *
     * @stable
     */
    var LocationStrategy = (function () {
        function LocationStrategy() {
        }
        return LocationStrategy;
    }());
    /**
     * The `APP_BASE_HREF` token represents the base href to be used with the
     * {@link PathLocationStrategy}.
     *
     * If you're using {@link PathLocationStrategy}, you must provide a provider to a string
     * representing the URL prefix that should be preserved when generating and recognizing
     * URLs.
     *
     * ### Example
     *
     * ```typescript
     * import {Component, NgModule} from '@angular/core';
     * import {APP_BASE_HREF} from '@angular/common';
     *
     * @NgModule({
     *   providers: [{provide: APP_BASE_HREF, useValue: '/my/app'}]
     * })
     * class AppModule {}
     * ```
     *
     * @stable
     */
    var APP_BASE_HREF = new _angular_core.OpaqueToken('appBaseHref');

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var globalScope;
    if (typeof window === 'undefined') {
        if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
            // TODO: Replace any with WorkerGlobalScope from lib.webworker.d.ts #3492
            globalScope = self;
        }
        else {
            globalScope = global;
        }
    }
    else {
        globalScope = window;
    }
    // Need to declare a new variable for global here since TypeScript
    // exports the original value of the symbol.
    var _global = globalScope;
    function getTypeNameForDebugging(type) {
        return type['name'] || typeof type;
    }
    // TODO: remove calls to assert in production environment
    // Note: Can't just export this and import in in other files
    // as `assert` is a reserved keyword in Dart
    _global.assert = function assert(condition) {
        // TODO: to be fixed properly via #2830, noop for now
    };
    function isPresent(obj) {
        return obj !== undefined && obj !== null;
    }
    function isBlank(obj) {
        return obj === undefined || obj === null;
    }
    function isDate(obj) {
        return obj instanceof Date && !isNaN(obj.valueOf());
    }
    function stringify(token) {
        if (typeof token === 'string') {
            return token;
        }
        if (token === undefined || token === null) {
            return '' + token;
        }
        if (token.overriddenName) {
            return token.overriddenName;
        }
        if (token.name) {
            return token.name;
        }
        var res = token.toString();
        var newLineIndex = res.indexOf('\n');
        return newLineIndex === -1 ? res : res.substring(0, newLineIndex);
    }
    var NumberWrapper = (function () {
        function NumberWrapper() {
        }
        NumberWrapper.parseIntAutoRadix = function (text) {
            var result = parseInt(text);
            if (isNaN(result)) {
                throw new Error('Invalid integer literal when parsing ' + text);
            }
            return result;
        };
        NumberWrapper.parseInt = function (text, radix) {
            if (radix == 10) {
                if (/^(\-|\+)?[0-9]+$/.test(text)) {
                    return parseInt(text, radix);
                }
            }
            else if (radix == 16) {
                if (/^(\-|\+)?[0-9ABCDEFabcdef]+$/.test(text)) {
                    return parseInt(text, radix);
                }
            }
            else {
                var result = parseInt(text, radix);
                if (!isNaN(result)) {
                    return result;
                }
            }
            throw new Error('Invalid integer literal when parsing ' + text + ' in base ' + radix);
        };
        NumberWrapper.isNumeric = function (value) { return !isNaN(value - parseFloat(value)); };
        return NumberWrapper;
    }());
    function isJsObject(o) {
        return o !== null && (typeof o === 'function' || typeof o === 'object');
    }
    var _symbolIterator = null;
    function getSymbolIterator() {
        if (isBlank(_symbolIterator)) {
            if (isPresent(globalScope.Symbol) && isPresent(Symbol.iterator)) {
                _symbolIterator = Symbol.iterator;
            }
            else {
                // es6-shim specific logic
                var keys = Object.getOwnPropertyNames(Map.prototype);
                for (var i = 0; i < keys.length; ++i) {
                    var key = keys[i];
                    if (key !== 'entries' && key !== 'size' &&
                        Map.prototype[key] === Map.prototype['entries']) {
                        _symbolIterator = key;
                    }
                }
            }
        }
        return _symbolIterator;
    }

    /**
     * `Location` is a service that applications can use to interact with a browser's URL.
     * Depending on which {@link LocationStrategy} is used, `Location` will either persist
     * to the URL's path or the URL's hash segment.
     *
     * Note: it's better to use {@link Router#navigate} service to trigger route changes. Use
     * `Location` only if you need to interact with or create normalized URLs outside of
     * routing.
     *
     * `Location` is responsible for normalizing the URL against the application's base href.
     * A normalized URL is absolute from the URL host, includes the application's base href, and has no
     * trailing slash:
     * - `/my/app/user/123` is normalized
     * - `my/app/user/123` **is not** normalized
     * - `/my/app/user/123/` **is not** normalized
     *
     * ### Example
     *
     * ```
     * import {Component} from '@angular/core';
     * import {Location} from '@angular/common';
     *
     * @Component({selector: 'app-component'})
     * class AppCmp {
     *   constructor(location: Location) {
     *     location.go('/foo');
     *   }
     * }
     * ```
     *
     * @stable
     */
    var Location = (function () {
        function Location(platformStrategy) {
            var _this = this;
            /** @internal */
            this._subject = new _angular_core.EventEmitter();
            this._platformStrategy = platformStrategy;
            var browserBaseHref = this._platformStrategy.getBaseHref();
            this._baseHref = Location.stripTrailingSlash(_stripIndexHtml(browserBaseHref));
            this._platformStrategy.onPopState(function (ev) {
                _this._subject.emit({
                    'url': _this.path(true),
                    'pop': true,
                    'type': ev.type,
                });
            });
        }
        /**
         * Returns the normalized URL path.
         */
        // TODO: vsavkin. Remove the boolean flag and always include hash once the deprecated router is
        // removed.
        Location.prototype.path = function (includeHash) {
            if (includeHash === void 0) { includeHash = false; }
            return this.normalize(this._platformStrategy.path(includeHash));
        };
        /**
         * Normalizes the given path and compares to the current normalized path.
         */
        Location.prototype.isCurrentPathEqualTo = function (path, query) {
            if (query === void 0) { query = ''; }
            return this.path() == this.normalize(path + Location.normalizeQueryParams(query));
        };
        /**
         * Given a string representing a URL, returns the normalized URL path without leading or
         * trailing slashes.
         */
        Location.prototype.normalize = function (url) {
            return Location.stripTrailingSlash(_stripBaseHref(this._baseHref, _stripIndexHtml(url)));
        };
        /**
         * Given a string representing a URL, returns the platform-specific external URL path.
         * If the given URL doesn't begin with a leading slash (`'/'`), this method adds one
         * before normalizing. This method will also add a hash if `HashLocationStrategy` is
         * used, or the `APP_BASE_HREF` if the `PathLocationStrategy` is in use.
         */
        Location.prototype.prepareExternalUrl = function (url) {
            if (url.length > 0 && !url.startsWith('/')) {
                url = '/' + url;
            }
            return this._platformStrategy.prepareExternalUrl(url);
        };
        // TODO: rename this method to pushState
        /**
         * Changes the browsers URL to the normalized version of the given URL, and pushes a
         * new item onto the platform's history.
         */
        Location.prototype.go = function (path, query) {
            if (query === void 0) { query = ''; }
            this._platformStrategy.pushState(null, '', path, query);
        };
        /**
         * Changes the browsers URL to the normalized version of the given URL, and replaces
         * the top item on the platform's history stack.
         */
        Location.prototype.replaceState = function (path, query) {
            if (query === void 0) { query = ''; }
            this._platformStrategy.replaceState(null, '', path, query);
        };
        /**
         * Navigates forward in the platform's history.
         */
        Location.prototype.forward = function () { this._platformStrategy.forward(); };
        /**
         * Navigates back in the platform's history.
         */
        Location.prototype.back = function () { this._platformStrategy.back(); };
        /**
         * Subscribe to the platform's `popState` events.
         */
        Location.prototype.subscribe = function (onNext, onThrow, onReturn) {
            if (onThrow === void 0) { onThrow = null; }
            if (onReturn === void 0) { onReturn = null; }
            return this._subject.subscribe({ next: onNext, error: onThrow, complete: onReturn });
        };
        /**
         * Given a string of url parameters, prepend with '?' if needed, otherwise return parameters as
         * is.
         */
        Location.normalizeQueryParams = function (params) {
            return (params.length > 0 && params.substring(0, 1) != '?') ? ('?' + params) : params;
        };
        /**
         * Given 2 parts of a url, join them with a slash if needed.
         */
        Location.joinWithSlash = function (start, end) {
            if (start.length == 0) {
                return end;
            }
            if (end.length == 0) {
                return start;
            }
            var slashes = 0;
            if (start.endsWith('/')) {
                slashes++;
            }
            if (end.startsWith('/')) {
                slashes++;
            }
            if (slashes == 2) {
                return start + end.substring(1);
            }
            if (slashes == 1) {
                return start + end;
            }
            return start + '/' + end;
        };
        /**
         * If url has a trailing slash, remove it, otherwise return url as is.
         */
        Location.stripTrailingSlash = function (url) {
            if (/\/$/g.test(url)) {
                url = url.substring(0, url.length - 1);
            }
            return url;
        };
        Location.decorators = [
            { type: _angular_core.Injectable },
        ];
        /** @nocollapse */
        Location.ctorParameters = [
            { type: LocationStrategy, },
        ];
        return Location;
    }());
    function _stripBaseHref(baseHref, url) {
        if (baseHref.length > 0 && url.startsWith(baseHref)) {
            return url.substring(baseHref.length);
        }
        return url;
    }
    function _stripIndexHtml(url) {
        if (/\/index.html$/g.test(url)) {
            // '/index.html'.length == 11
            return url.substring(0, url.length - 11);
        }
        return url;
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    /**
     * `HashLocationStrategy` is a {@link LocationStrategy} used to configure the
     * {@link Location} service to represent its state in the
     * [hash fragment](https://en.wikipedia.org/wiki/Uniform_Resource_Locator#Syntax)
     * of the browser's URL.
     *
     * For instance, if you call `location.go('/foo')`, the browser's URL will become
     * `example.com#/foo`.
     *
     * ### Example
     *
     * ```
     * import {Component, NgModule} from '@angular/core';
     * import {
     *   LocationStrategy,
     *   HashLocationStrategy
     * } from '@angular/common';
     *
     * @NgModule({
     *   providers: [{provide: LocationStrategy, useClass: HashLocationStrategy}]
     * })
     * class AppModule {}
     * ```
     *
     * @stable
     */
    var HashLocationStrategy = (function (_super) {
        __extends(HashLocationStrategy, _super);
        function HashLocationStrategy(_platformLocation, _baseHref) {
            _super.call(this);
            this._platformLocation = _platformLocation;
            this._baseHref = '';
            if (isPresent(_baseHref)) {
                this._baseHref = _baseHref;
            }
        }
        HashLocationStrategy.prototype.onPopState = function (fn) {
            this._platformLocation.onPopState(fn);
            this._platformLocation.onHashChange(fn);
        };
        HashLocationStrategy.prototype.getBaseHref = function () { return this._baseHref; };
        HashLocationStrategy.prototype.path = function (includeHash) {
            if (includeHash === void 0) { includeHash = false; }
            // the hash value is always prefixed with a `#`
            // and if it is empty then it will stay empty
            var path = this._platformLocation.hash;
            if (!isPresent(path))
                path = '#';
            return path.length > 0 ? path.substring(1) : path;
        };
        HashLocationStrategy.prototype.prepareExternalUrl = function (internal) {
            var url = Location.joinWithSlash(this._baseHref, internal);
            return url.length > 0 ? ('#' + url) : url;
        };
        HashLocationStrategy.prototype.pushState = function (state, title, path, queryParams) {
            var url = this.prepareExternalUrl(path + Location.normalizeQueryParams(queryParams));
            if (url.length == 0) {
                url = this._platformLocation.pathname;
            }
            this._platformLocation.pushState(state, title, url);
        };
        HashLocationStrategy.prototype.replaceState = function (state, title, path, queryParams) {
            var url = this.prepareExternalUrl(path + Location.normalizeQueryParams(queryParams));
            if (url.length == 0) {
                url = this._platformLocation.pathname;
            }
            this._platformLocation.replaceState(state, title, url);
        };
        HashLocationStrategy.prototype.forward = function () { this._platformLocation.forward(); };
        HashLocationStrategy.prototype.back = function () { this._platformLocation.back(); };
        HashLocationStrategy.decorators = [
            { type: _angular_core.Injectable },
        ];
        /** @nocollapse */
        HashLocationStrategy.ctorParameters = [
            { type: PlatformLocation, },
            { type: undefined, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Inject, args: [APP_BASE_HREF,] },] },
        ];
        return HashLocationStrategy;
    }(LocationStrategy));

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$1 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    /**
     * `PathLocationStrategy` is a {@link LocationStrategy} used to configure the
     * {@link Location} service to represent its state in the
     * [path](https://en.wikipedia.org/wiki/Uniform_Resource_Locator#Syntax) of the
     * browser's URL.
     *
     * `PathLocationStrategy` is the default binding for {@link LocationStrategy}
     * provided in {@link ROUTER_PROVIDERS}.
     *
     * If you're using `PathLocationStrategy`, you must provide a {@link APP_BASE_HREF}
     * or add a base element to the document. This URL prefix that will be preserved
     * when generating and recognizing URLs.
     *
     * For instance, if you provide an `APP_BASE_HREF` of `'/my/app'` and call
     * `location.go('/foo')`, the browser's URL will become
     * `example.com/my/app/foo`.
     *
     * Similarly, if you add `<base href='/my/app'/>` to the document and call
     * `location.go('/foo')`, the browser's URL will become
     * `example.com/my/app/foo`.
     *
     * @stable
     */
    var PathLocationStrategy = (function (_super) {
        __extends$1(PathLocationStrategy, _super);
        function PathLocationStrategy(_platformLocation, href) {
            _super.call(this);
            this._platformLocation = _platformLocation;
            if (isBlank(href)) {
                href = this._platformLocation.getBaseHrefFromDOM();
            }
            if (isBlank(href)) {
                throw new Error("No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document.");
            }
            this._baseHref = href;
        }
        PathLocationStrategy.prototype.onPopState = function (fn) {
            this._platformLocation.onPopState(fn);
            this._platformLocation.onHashChange(fn);
        };
        PathLocationStrategy.prototype.getBaseHref = function () { return this._baseHref; };
        PathLocationStrategy.prototype.prepareExternalUrl = function (internal) {
            return Location.joinWithSlash(this._baseHref, internal);
        };
        PathLocationStrategy.prototype.path = function (includeHash) {
            if (includeHash === void 0) { includeHash = false; }
            var pathname = this._platformLocation.pathname +
                Location.normalizeQueryParams(this._platformLocation.search);
            var hash = this._platformLocation.hash;
            return hash && includeHash ? "" + pathname + hash : pathname;
        };
        PathLocationStrategy.prototype.pushState = function (state, title, url, queryParams) {
            var externalUrl = this.prepareExternalUrl(url + Location.normalizeQueryParams(queryParams));
            this._platformLocation.pushState(state, title, externalUrl);
        };
        PathLocationStrategy.prototype.replaceState = function (state, title, url, queryParams) {
            var externalUrl = this.prepareExternalUrl(url + Location.normalizeQueryParams(queryParams));
            this._platformLocation.replaceState(state, title, externalUrl);
        };
        PathLocationStrategy.prototype.forward = function () { this._platformLocation.forward(); };
        PathLocationStrategy.prototype.back = function () { this._platformLocation.back(); };
        PathLocationStrategy.decorators = [
            { type: _angular_core.Injectable },
        ];
        /** @nocollapse */
        PathLocationStrategy.ctorParameters = [
            { type: PlatformLocation, },
            { type: undefined, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Inject, args: [APP_BASE_HREF,] },] },
        ];
        return PathLocationStrategy;
    }(LocationStrategy));

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$2 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    /**
     * @experimental
     */
    var NgLocalization = (function () {
        function NgLocalization() {
        }
        return NgLocalization;
    }());
    /**
     * Returns the plural category for a given value.
     * - "=value" when the case exists,
     * - the plural category otherwise
     *
     * @internal
     */
    function getPluralCategory(value, cases, ngLocalization) {
        var nbCase = "=" + value;
        return cases.indexOf(nbCase) > -1 ? nbCase : ngLocalization.getPluralCategory(value);
    }
    /**
     * Returns the plural case based on the locale
     *
     * @experimental
     */
    var NgLocaleLocalization = (function (_super) {
        __extends$2(NgLocaleLocalization, _super);
        function NgLocaleLocalization(_locale) {
            _super.call(this);
            this._locale = _locale;
        }
        NgLocaleLocalization.prototype.getPluralCategory = function (value) {
            var plural = getPluralCase(this._locale, value);
            switch (plural) {
                case Plural.Zero:
                    return 'zero';
                case Plural.One:
                    return 'one';
                case Plural.Two:
                    return 'two';
                case Plural.Few:
                    return 'few';
                case Plural.Many:
                    return 'many';
                default:
                    return 'other';
            }
        };
        NgLocaleLocalization.decorators = [
            { type: _angular_core.Injectable },
        ];
        /** @nocollapse */
        NgLocaleLocalization.ctorParameters = [
            { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_core.LOCALE_ID,] },] },
        ];
        return NgLocaleLocalization;
    }(NgLocalization));
    // This is generated code DO NOT MODIFY
    // see angular2/script/cldr/gen_plural_rules.js
    /** @experimental */
    var Plural;
    (function (Plural) {
        Plural[Plural["Zero"] = 0] = "Zero";
        Plural[Plural["One"] = 1] = "One";
        Plural[Plural["Two"] = 2] = "Two";
        Plural[Plural["Few"] = 3] = "Few";
        Plural[Plural["Many"] = 4] = "Many";
        Plural[Plural["Other"] = 5] = "Other";
    })(Plural || (Plural = {}));
    /**
     * Returns the plural case based on the locale
     *
     * @experimental
     */
    function getPluralCase(locale, nLike) {
        // TODO(vicb): lazy compute
        if (typeof nLike === 'string') {
            nLike = parseInt(nLike, 10);
        }
        var n = nLike;
        var nDecimal = n.toString().replace(/^[^.]*\.?/, '');
        var i = Math.floor(Math.abs(n));
        var v = nDecimal.length;
        var f = parseInt(nDecimal, 10);
        var t = parseInt(n.toString().replace(/^[^.]*\.?|0+$/g, ''), 10) || 0;
        var lang = locale.split('-')[0].toLowerCase();
        switch (lang) {
            case 'af':
            case 'asa':
            case 'az':
            case 'bem':
            case 'bez':
            case 'bg':
            case 'brx':
            case 'ce':
            case 'cgg':
            case 'chr':
            case 'ckb':
            case 'ee':
            case 'el':
            case 'eo':
            case 'es':
            case 'eu':
            case 'fo':
            case 'fur':
            case 'gsw':
            case 'ha':
            case 'haw':
            case 'hu':
            case 'jgo':
            case 'jmc':
            case 'ka':
            case 'kk':
            case 'kkj':
            case 'kl':
            case 'ks':
            case 'ksb':
            case 'ky':
            case 'lb':
            case 'lg':
            case 'mas':
            case 'mgo':
            case 'ml':
            case 'mn':
            case 'nb':
            case 'nd':
            case 'ne':
            case 'nn':
            case 'nnh':
            case 'nyn':
            case 'om':
            case 'or':
            case 'os':
            case 'ps':
            case 'rm':
            case 'rof':
            case 'rwk':
            case 'saq':
            case 'seh':
            case 'sn':
            case 'so':
            case 'sq':
            case 'ta':
            case 'te':
            case 'teo':
            case 'tk':
            case 'tr':
            case 'ug':
            case 'uz':
            case 'vo':
            case 'vun':
            case 'wae':
            case 'xog':
                if (n === 1)
                    return Plural.One;
                return Plural.Other;
            case 'agq':
            case 'bas':
            case 'cu':
            case 'dav':
            case 'dje':
            case 'dua':
            case 'dyo':
            case 'ebu':
            case 'ewo':
            case 'guz':
            case 'kam':
            case 'khq':
            case 'ki':
            case 'kln':
            case 'kok':
            case 'ksf':
            case 'lrc':
            case 'lu':
            case 'luo':
            case 'luy':
            case 'mer':
            case 'mfe':
            case 'mgh':
            case 'mua':
            case 'mzn':
            case 'nmg':
            case 'nus':
            case 'qu':
            case 'rn':
            case 'rw':
            case 'sbp':
            case 'twq':
            case 'vai':
            case 'yav':
            case 'yue':
            case 'zgh':
            case 'ak':
            case 'ln':
            case 'mg':
            case 'pa':
            case 'ti':
                if (n === Math.floor(n) && n >= 0 && n <= 1)
                    return Plural.One;
                return Plural.Other;
            case 'am':
            case 'as':
            case 'bn':
            case 'fa':
            case 'gu':
            case 'hi':
            case 'kn':
            case 'mr':
            case 'zu':
                if (i === 0 || n === 1)
                    return Plural.One;
                return Plural.Other;
            case 'ar':
                if (n === 0)
                    return Plural.Zero;
                if (n === 1)
                    return Plural.One;
                if (n === 2)
                    return Plural.Two;
                if (n % 100 === Math.floor(n % 100) && n % 100 >= 3 && n % 100 <= 10)
                    return Plural.Few;
                if (n % 100 === Math.floor(n % 100) && n % 100 >= 11 && n % 100 <= 99)
                    return Plural.Many;
                return Plural.Other;
            case 'ast':
            case 'ca':
            case 'de':
            case 'en':
            case 'et':
            case 'fi':
            case 'fy':
            case 'gl':
            case 'it':
            case 'nl':
            case 'sv':
            case 'sw':
            case 'ur':
            case 'yi':
                if (i === 1 && v === 0)
                    return Plural.One;
                return Plural.Other;
            case 'be':
                if (n % 10 === 1 && !(n % 100 === 11))
                    return Plural.One;
                if (n % 10 === Math.floor(n % 10) && n % 10 >= 2 && n % 10 <= 4 &&
                    !(n % 100 >= 12 && n % 100 <= 14))
                    return Plural.Few;
                if (n % 10 === 0 || n % 10 === Math.floor(n % 10) && n % 10 >= 5 && n % 10 <= 9 ||
                    n % 100 === Math.floor(n % 100) && n % 100 >= 11 && n % 100 <= 14)
                    return Plural.Many;
                return Plural.Other;
            case 'br':
                if (n % 10 === 1 && !(n % 100 === 11 || n % 100 === 71 || n % 100 === 91))
                    return Plural.One;
                if (n % 10 === 2 && !(n % 100 === 12 || n % 100 === 72 || n % 100 === 92))
                    return Plural.Two;
                if (n % 10 === Math.floor(n % 10) && (n % 10 >= 3 && n % 10 <= 4 || n % 10 === 9) &&
                    !(n % 100 >= 10 && n % 100 <= 19 || n % 100 >= 70 && n % 100 <= 79 ||
                        n % 100 >= 90 && n % 100 <= 99))
                    return Plural.Few;
                if (!(n === 0) && n % 1e6 === 0)
                    return Plural.Many;
                return Plural.Other;
            case 'bs':
            case 'hr':
            case 'sr':
                if (v === 0 && i % 10 === 1 && !(i % 100 === 11) || f % 10 === 1 && !(f % 100 === 11))
                    return Plural.One;
                if (v === 0 && i % 10 === Math.floor(i % 10) && i % 10 >= 2 && i % 10 <= 4 &&
                    !(i % 100 >= 12 && i % 100 <= 14) ||
                    f % 10 === Math.floor(f % 10) && f % 10 >= 2 && f % 10 <= 4 &&
                        !(f % 100 >= 12 && f % 100 <= 14))
                    return Plural.Few;
                return Plural.Other;
            case 'cs':
            case 'sk':
                if (i === 1 && v === 0)
                    return Plural.One;
                if (i === Math.floor(i) && i >= 2 && i <= 4 && v === 0)
                    return Plural.Few;
                if (!(v === 0))
                    return Plural.Many;
                return Plural.Other;
            case 'cy':
                if (n === 0)
                    return Plural.Zero;
                if (n === 1)
                    return Plural.One;
                if (n === 2)
                    return Plural.Two;
                if (n === 3)
                    return Plural.Few;
                if (n === 6)
                    return Plural.Many;
                return Plural.Other;
            case 'da':
                if (n === 1 || !(t === 0) && (i === 0 || i === 1))
                    return Plural.One;
                return Plural.Other;
            case 'dsb':
            case 'hsb':
                if (v === 0 && i % 100 === 1 || f % 100 === 1)
                    return Plural.One;
                if (v === 0 && i % 100 === 2 || f % 100 === 2)
                    return Plural.Two;
                if (v === 0 && i % 100 === Math.floor(i % 100) && i % 100 >= 3 && i % 100 <= 4 ||
                    f % 100 === Math.floor(f % 100) && f % 100 >= 3 && f % 100 <= 4)
                    return Plural.Few;
                return Plural.Other;
            case 'ff':
            case 'fr':
            case 'hy':
            case 'kab':
                if (i === 0 || i === 1)
                    return Plural.One;
                return Plural.Other;
            case 'fil':
                if (v === 0 && (i === 1 || i === 2 || i === 3) ||
                    v === 0 && !(i % 10 === 4 || i % 10 === 6 || i % 10 === 9) ||
                    !(v === 0) && !(f % 10 === 4 || f % 10 === 6 || f % 10 === 9))
                    return Plural.One;
                return Plural.Other;
            case 'ga':
                if (n === 1)
                    return Plural.One;
                if (n === 2)
                    return Plural.Two;
                if (n === Math.floor(n) && n >= 3 && n <= 6)
                    return Plural.Few;
                if (n === Math.floor(n) && n >= 7 && n <= 10)
                    return Plural.Many;
                return Plural.Other;
            case 'gd':
                if (n === 1 || n === 11)
                    return Plural.One;
                if (n === 2 || n === 12)
                    return Plural.Two;
                if (n === Math.floor(n) && (n >= 3 && n <= 10 || n >= 13 && n <= 19))
                    return Plural.Few;
                return Plural.Other;
            case 'gv':
                if (v === 0 && i % 10 === 1)
                    return Plural.One;
                if (v === 0 && i % 10 === 2)
                    return Plural.Two;
                if (v === 0 &&
                    (i % 100 === 0 || i % 100 === 20 || i % 100 === 40 || i % 100 === 60 || i % 100 === 80))
                    return Plural.Few;
                if (!(v === 0))
                    return Plural.Many;
                return Plural.Other;
            case 'he':
                if (i === 1 && v === 0)
                    return Plural.One;
                if (i === 2 && v === 0)
                    return Plural.Two;
                if (v === 0 && !(n >= 0 && n <= 10) && n % 10 === 0)
                    return Plural.Many;
                return Plural.Other;
            case 'is':
                if (t === 0 && i % 10 === 1 && !(i % 100 === 11) || !(t === 0))
                    return Plural.One;
                return Plural.Other;
            case 'ksh':
                if (n === 0)
                    return Plural.Zero;
                if (n === 1)
                    return Plural.One;
                return Plural.Other;
            case 'kw':
            case 'naq':
            case 'se':
            case 'smn':
                if (n === 1)
                    return Plural.One;
                if (n === 2)
                    return Plural.Two;
                return Plural.Other;
            case 'lag':
                if (n === 0)
                    return Plural.Zero;
                if ((i === 0 || i === 1) && !(n === 0))
                    return Plural.One;
                return Plural.Other;
            case 'lt':
                if (n % 10 === 1 && !(n % 100 >= 11 && n % 100 <= 19))
                    return Plural.One;
                if (n % 10 === Math.floor(n % 10) && n % 10 >= 2 && n % 10 <= 9 &&
                    !(n % 100 >= 11 && n % 100 <= 19))
                    return Plural.Few;
                if (!(f === 0))
                    return Plural.Many;
                return Plural.Other;
            case 'lv':
            case 'prg':
                if (n % 10 === 0 || n % 100 === Math.floor(n % 100) && n % 100 >= 11 && n % 100 <= 19 ||
                    v === 2 && f % 100 === Math.floor(f % 100) && f % 100 >= 11 && f % 100 <= 19)
                    return Plural.Zero;
                if (n % 10 === 1 && !(n % 100 === 11) || v === 2 && f % 10 === 1 && !(f % 100 === 11) ||
                    !(v === 2) && f % 10 === 1)
                    return Plural.One;
                return Plural.Other;
            case 'mk':
                if (v === 0 && i % 10 === 1 || f % 10 === 1)
                    return Plural.One;
                return Plural.Other;
            case 'mt':
                if (n === 1)
                    return Plural.One;
                if (n === 0 || n % 100 === Math.floor(n % 100) && n % 100 >= 2 && n % 100 <= 10)
                    return Plural.Few;
                if (n % 100 === Math.floor(n % 100) && n % 100 >= 11 && n % 100 <= 19)
                    return Plural.Many;
                return Plural.Other;
            case 'pl':
                if (i === 1 && v === 0)
                    return Plural.One;
                if (v === 0 && i % 10 === Math.floor(i % 10) && i % 10 >= 2 && i % 10 <= 4 &&
                    !(i % 100 >= 12 && i % 100 <= 14))
                    return Plural.Few;
                if (v === 0 && !(i === 1) && i % 10 === Math.floor(i % 10) && i % 10 >= 0 && i % 10 <= 1 ||
                    v === 0 && i % 10 === Math.floor(i % 10) && i % 10 >= 5 && i % 10 <= 9 ||
                    v === 0 && i % 100 === Math.floor(i % 100) && i % 100 >= 12 && i % 100 <= 14)
                    return Plural.Many;
                return Plural.Other;
            case 'pt':
                if (n === Math.floor(n) && n >= 0 && n <= 2 && !(n === 2))
                    return Plural.One;
                return Plural.Other;
            case 'ro':
                if (i === 1 && v === 0)
                    return Plural.One;
                if (!(v === 0) || n === 0 ||
                    !(n === 1) && n % 100 === Math.floor(n % 100) && n % 100 >= 1 && n % 100 <= 19)
                    return Plural.Few;
                return Plural.Other;
            case 'ru':
            case 'uk':
                if (v === 0 && i % 10 === 1 && !(i % 100 === 11))
                    return Plural.One;
                if (v === 0 && i % 10 === Math.floor(i % 10) && i % 10 >= 2 && i % 10 <= 4 &&
                    !(i % 100 >= 12 && i % 100 <= 14))
                    return Plural.Few;
                if (v === 0 && i % 10 === 0 ||
                    v === 0 && i % 10 === Math.floor(i % 10) && i % 10 >= 5 && i % 10 <= 9 ||
                    v === 0 && i % 100 === Math.floor(i % 100) && i % 100 >= 11 && i % 100 <= 14)
                    return Plural.Many;
                return Plural.Other;
            case 'shi':
                if (i === 0 || n === 1)
                    return Plural.One;
                if (n === Math.floor(n) && n >= 2 && n <= 10)
                    return Plural.Few;
                return Plural.Other;
            case 'si':
                if (n === 0 || n === 1 || i === 0 && f === 1)
                    return Plural.One;
                return Plural.Other;
            case 'sl':
                if (v === 0 && i % 100 === 1)
                    return Plural.One;
                if (v === 0 && i % 100 === 2)
                    return Plural.Two;
                if (v === 0 && i % 100 === Math.floor(i % 100) && i % 100 >= 3 && i % 100 <= 4 || !(v === 0))
                    return Plural.Few;
                return Plural.Other;
            case 'tzm':
                if (n === Math.floor(n) && n >= 0 && n <= 1 || n === Math.floor(n) && n >= 11 && n <= 99)
                    return Plural.One;
                return Plural.Other;
            default:
                return Plural.Other;
        }
    }

    // Safari doesn't implement MapIterator.next(), which is used is Traceur's polyfill of Array.from
    // TODO(mlaval): remove the work around once we have a working polyfill of Array.from
    var _arrayFromMap = (function () {
        try {
            if ((new Map()).values().next) {
                return function createArrayFromMap(m, getValues) {
                    return getValues ? Array.from(m.values()) : Array.from(m.keys());
                };
            }
        }
        catch (e) {
        }
        return function createArrayFromMapWithForeach(m, getValues) {
            var res = new Array(m.size), i = 0;
            m.forEach(function (v, k) {
                res[i] = getValues ? v : k;
                i++;
            });
            return res;
        };
    })();
    var ListWrapper = (function () {
        function ListWrapper() {
        }
        // JS has no way to express a statically fixed size list, but dart does so we
        // keep both methods.
        ListWrapper.createFixedSize = function (size) { return new Array(size); };
        ListWrapper.createGrowableSize = function (size) { return new Array(size); };
        ListWrapper.clone = function (array) { return array.slice(0); };
        ListWrapper.forEachWithIndex = function (array, fn) {
            for (var i = 0; i < array.length; i++) {
                fn(array[i], i);
            }
        };
        ListWrapper.first = function (array) {
            if (!array)
                return null;
            return array[0];
        };
        ListWrapper.last = function (array) {
            if (!array || array.length == 0)
                return null;
            return array[array.length - 1];
        };
        ListWrapper.indexOf = function (array, value, startIndex) {
            if (startIndex === void 0) { startIndex = 0; }
            return array.indexOf(value, startIndex);
        };
        ListWrapper.contains = function (list, el) { return list.indexOf(el) !== -1; };
        ListWrapper.reversed = function (array) {
            var a = ListWrapper.clone(array);
            return a.reverse();
        };
        ListWrapper.concat = function (a, b) { return a.concat(b); };
        ListWrapper.insert = function (list, index, value) { list.splice(index, 0, value); };
        ListWrapper.removeAt = function (list, index) {
            var res = list[index];
            list.splice(index, 1);
            return res;
        };
        ListWrapper.removeAll = function (list, items) {
            for (var i = 0; i < items.length; ++i) {
                var index = list.indexOf(items[i]);
                list.splice(index, 1);
            }
        };
        ListWrapper.remove = function (list, el) {
            var index = list.indexOf(el);
            if (index > -1) {
                list.splice(index, 1);
                return true;
            }
            return false;
        };
        ListWrapper.clear = function (list) { list.length = 0; };
        ListWrapper.isEmpty = function (list) { return list.length == 0; };
        ListWrapper.fill = function (list, value, start, end) {
            if (start === void 0) { start = 0; }
            if (end === void 0) { end = null; }
            list.fill(value, start, end === null ? list.length : end);
        };
        ListWrapper.equals = function (a, b) {
            if (a.length != b.length)
                return false;
            for (var i = 0; i < a.length; ++i) {
                if (a[i] !== b[i])
                    return false;
            }
            return true;
        };
        ListWrapper.slice = function (l, from, to) {
            if (from === void 0) { from = 0; }
            if (to === void 0) { to = null; }
            return l.slice(from, to === null ? undefined : to);
        };
        ListWrapper.splice = function (l, from, length) { return l.splice(from, length); };
        ListWrapper.sort = function (l, compareFn) {
            if (isPresent(compareFn)) {
                l.sort(compareFn);
            }
            else {
                l.sort();
            }
        };
        ListWrapper.toString = function (l) { return l.toString(); };
        ListWrapper.toJSON = function (l) { return JSON.stringify(l); };
        ListWrapper.maximum = function (list, predicate) {
            if (list.length == 0) {
                return null;
            }
            var solution = null;
            var maxValue = -Infinity;
            for (var index = 0; index < list.length; index++) {
                var candidate = list[index];
                if (isBlank(candidate)) {
                    continue;
                }
                var candidateValue = predicate(candidate);
                if (candidateValue > maxValue) {
                    solution = candidate;
                    maxValue = candidateValue;
                }
            }
            return solution;
        };
        ListWrapper.flatten = function (list) {
            var target = [];
            _flattenArray(list, target);
            return target;
        };
        ListWrapper.addAll = function (list, source) {
            for (var i = 0; i < source.length; i++) {
                list.push(source[i]);
            }
        };
        return ListWrapper;
    }());
    function _flattenArray(source, target) {
        if (isPresent(source)) {
            for (var i = 0; i < source.length; i++) {
                var item = source[i];
                if (Array.isArray(item)) {
                    _flattenArray(item, target);
                }
                else {
                    target.push(item);
                }
            }
        }
        return target;
    }
    function isListLikeIterable(obj) {
        if (!isJsObject(obj))
            return false;
        return Array.isArray(obj) ||
            (!(obj instanceof Map) &&
                getSymbolIterator() in obj); // JS Iterable have a Symbol.iterator prop
    }

    /**
     * @ngModule CommonModule
     *
     * @whatItDoes Adds and removes CSS classes on an HTML element.
     *
     * @howToUse
     * ```
     *     <some-element [ngClass]="'first second'">...</some-element>
     *
     *     <some-element [ngClass]="['first', 'second']">...</some-element>
     *
     *     <some-element [ngClass]="{'first': true, 'second': true, 'third': false}">...</some-element>
     *
     *     <some-element [ngClass]="stringExp|arrayExp|objExp">...</some-element>
     * ```
     *
     * @description
     *
     * The CSS classes are updated as follow depending on the type of the expression evaluation:
     * - `string` - the CSS classes listed in a string (space delimited) are added,
     * - `Array` - the CSS classes (Array elements) are added,
     * - `Object` - keys are CSS class names that get added when the expression given in the value
     *              evaluates to a truthy value, otherwise class are removed.
     *
     * @stable
     */
    var NgClass = (function () {
        function NgClass(_iterableDiffers, _keyValueDiffers, _ngEl, _renderer) {
            this._iterableDiffers = _iterableDiffers;
            this._keyValueDiffers = _keyValueDiffers;
            this._ngEl = _ngEl;
            this._renderer = _renderer;
            this._initialClasses = [];
        }
        Object.defineProperty(NgClass.prototype, "klass", {
            set: function (v) {
                this._applyInitialClasses(true);
                this._initialClasses = typeof v === 'string' ? v.split(/\s+/) : [];
                this._applyInitialClasses(false);
                this._applyClasses(this._rawClass, false);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgClass.prototype, "ngClass", {
            set: function (v) {
                this._cleanupClasses(this._rawClass);
                this._iterableDiffer = null;
                this._keyValueDiffer = null;
                this._rawClass = typeof v === 'string' ? v.split(/\s+/) : v;
                if (this._rawClass) {
                    if (isListLikeIterable(this._rawClass)) {
                        this._iterableDiffer = this._iterableDiffers.find(this._rawClass).create(null);
                    }
                    else {
                        this._keyValueDiffer = this._keyValueDiffers.find(this._rawClass).create(null);
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        NgClass.prototype.ngDoCheck = function () {
            if (this._iterableDiffer) {
                var changes = this._iterableDiffer.diff(this._rawClass);
                if (changes) {
                    this._applyIterableChanges(changes);
                }
            }
            else if (this._keyValueDiffer) {
                var changes = this._keyValueDiffer.diff(this._rawClass);
                if (changes) {
                    this._applyKeyValueChanges(changes);
                }
            }
        };
        NgClass.prototype._cleanupClasses = function (rawClassVal) {
            this._applyClasses(rawClassVal, true);
            this._applyInitialClasses(false);
        };
        NgClass.prototype._applyKeyValueChanges = function (changes) {
            var _this = this;
            changes.forEachAddedItem(function (record) { return _this._toggleClass(record.key, record.currentValue); });
            changes.forEachChangedItem(function (record) { return _this._toggleClass(record.key, record.currentValue); });
            changes.forEachRemovedItem(function (record) {
                if (record.previousValue) {
                    _this._toggleClass(record.key, false);
                }
            });
        };
        NgClass.prototype._applyIterableChanges = function (changes) {
            var _this = this;
            changes.forEachAddedItem(function (record) { return _this._toggleClass(record.item, true); });
            changes.forEachRemovedItem(function (record) { return _this._toggleClass(record.item, false); });
        };
        NgClass.prototype._applyInitialClasses = function (isCleanup) {
            var _this = this;
            this._initialClasses.forEach(function (klass) { return _this._toggleClass(klass, !isCleanup); });
        };
        NgClass.prototype._applyClasses = function (rawClassVal, isCleanup) {
            var _this = this;
            if (rawClassVal) {
                if (Array.isArray(rawClassVal) || rawClassVal instanceof Set) {
                    rawClassVal.forEach(function (klass) { return _this._toggleClass(klass, !isCleanup); });
                }
                else {
                    Object.keys(rawClassVal).forEach(function (klass) {
                        if (isPresent(rawClassVal[klass]))
                            _this._toggleClass(klass, !isCleanup);
                    });
                }
            }
        };
        NgClass.prototype._toggleClass = function (klass, enabled) {
            var _this = this;
            klass = klass.trim();
            if (klass) {
                klass.split(/\s+/g).forEach(function (klass) { _this._renderer.setElementClass(_this._ngEl.nativeElement, klass, enabled); });
            }
        };
        NgClass.decorators = [
            { type: _angular_core.Directive, args: [{ selector: '[ngClass]' },] },
        ];
        /** @nocollapse */
        NgClass.ctorParameters = [
            { type: _angular_core.IterableDiffers, },
            { type: _angular_core.KeyValueDiffers, },
            { type: _angular_core.ElementRef, },
            { type: _angular_core.Renderer, },
        ];
        NgClass.propDecorators = {
            'klass': [{ type: _angular_core.Input, args: ['class',] },],
            'ngClass': [{ type: _angular_core.Input },],
        };
        return NgClass;
    }());

    var NgForRow = (function () {
        function NgForRow($implicit, index, count) {
            this.$implicit = $implicit;
            this.index = index;
            this.count = count;
        }
        Object.defineProperty(NgForRow.prototype, "first", {
            get: function () { return this.index === 0; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgForRow.prototype, "last", {
            get: function () { return this.index === this.count - 1; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgForRow.prototype, "even", {
            get: function () { return this.index % 2 === 0; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgForRow.prototype, "odd", {
            get: function () { return !this.even; },
            enumerable: true,
            configurable: true
        });
        return NgForRow;
    }());
    /**
     * The `NgFor` directive instantiates a template once per item from an iterable. The context for
     * each instantiated template inherits from the outer context with the given loop variable set
     * to the current item from the iterable.
     *
     * ### Local Variables
     *
     * `NgFor` provides several exported values that can be aliased to local variables:
     *
     * * `index` will be set to the current loop iteration for each template context.
     * * `first` will be set to a boolean value indicating whether the item is the first one in the
     *   iteration.
     * * `last` will be set to a boolean value indicating whether the item is the last one in the
     *   iteration.
     * * `even` will be set to a boolean value indicating whether this item has an even index.
     * * `odd` will be set to a boolean value indicating whether this item has an odd index.
     *
     * ### Change Propagation
     *
     * When the contents of the iterator changes, `NgFor` makes the corresponding changes to the DOM:
     *
     * * When an item is added, a new instance of the template is added to the DOM.
     * * When an item is removed, its template instance is removed from the DOM.
     * * When items are reordered, their respective templates are reordered in the DOM.
     * * Otherwise, the DOM element for that item will remain the same.
     *
     * Angular uses object identity to track insertions and deletions within the iterator and reproduce
     * those changes in the DOM. This has important implications for animations and any stateful
     * controls
     * (such as `<input>` elements which accept user input) that are present. Inserted rows can be
     * animated in, deleted rows can be animated out, and unchanged rows retain any unsaved state such
     * as user input.
     *
     * It is possible for the identities of elements in the iterator to change while the data does not.
     * This can happen, for example, if the iterator produced from an RPC to the server, and that
     * RPC is re-run. Even if the data hasn't changed, the second response will produce objects with
     * different identities, and Angular will tear down the entire DOM and rebuild it (as if all old
     * elements were deleted and all new elements inserted). This is an expensive operation and should
     * be avoided if possible.
     *
     * To customize the default tracking algorithm, `NgFor` supports `trackBy` option.
     * `trackBy` takes a function which has two arguments: `index` and `item`.
     * If `trackBy` is given, Angular tracks changes by the return value of the function.
     *
     * ### Syntax
     *
     * - `<li *ngFor="let item of items; let i = index; trackBy: trackByFn">...</li>`
     * - `<li template="ngFor let item of items; let i = index; trackBy: trackByFn">...</li>`
     *
     * With `<template>` element:
     *
     * ```
     * <template ngFor let-item [ngForOf]="items" let-i="index" [ngForTrackBy]="trackByFn">
     *   <li>...</li>
     * </template>
     * ```
     *
     * ### Example
     *
     * See a [live demo](http://plnkr.co/edit/KVuXxDp0qinGDyo307QW?p=preview) for a more detailed
     * example.
     *
     * @stable
     */
    var NgFor = (function () {
        function NgFor(_viewContainer, _template, _differs, _cdr) {
            this._viewContainer = _viewContainer;
            this._template = _template;
            this._differs = _differs;
            this._cdr = _cdr;
            this._differ = null;
        }
        Object.defineProperty(NgFor.prototype, "ngForTemplate", {
            set: function (value) {
                if (value) {
                    this._template = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        NgFor.prototype.ngOnChanges = function (changes) {
            if ('ngForOf' in changes) {
                // React on ngForOf changes only once all inputs have been initialized
                var value = changes['ngForOf'].currentValue;
                if (!this._differ && value) {
                    try {
                        this._differ = this._differs.find(value).create(this._cdr, this.ngForTrackBy);
                    }
                    catch (e) {
                        throw new Error("Cannot find a differ supporting object '" + value + "' of type '" + getTypeNameForDebugging(value) + "'. NgFor only supports binding to Iterables such as Arrays.");
                    }
                }
            }
        };
        NgFor.prototype.ngDoCheck = function () {
            if (this._differ) {
                var changes = this._differ.diff(this.ngForOf);
                if (changes)
                    this._applyChanges(changes);
            }
        };
        NgFor.prototype._applyChanges = function (changes) {
            var _this = this;
            var insertTuples = [];
            changes.forEachOperation(function (item, adjustedPreviousIndex, currentIndex) {
                if (item.previousIndex == null) {
                    var view = _this._viewContainer.createEmbeddedView(_this._template, new NgForRow(null, null, null), currentIndex);
                    var tuple = new RecordViewTuple(item, view);
                    insertTuples.push(tuple);
                }
                else if (currentIndex == null) {
                    _this._viewContainer.remove(adjustedPreviousIndex);
                }
                else {
                    var view = _this._viewContainer.get(adjustedPreviousIndex);
                    _this._viewContainer.move(view, currentIndex);
                    var tuple = new RecordViewTuple(item, view);
                    insertTuples.push(tuple);
                }
            });
            for (var i = 0; i < insertTuples.length; i++) {
                this._perViewChange(insertTuples[i].view, insertTuples[i].record);
            }
            for (var i = 0, ilen = this._viewContainer.length; i < ilen; i++) {
                var viewRef = this._viewContainer.get(i);
                viewRef.context.index = i;
                viewRef.context.count = ilen;
            }
            changes.forEachIdentityChange(function (record) {
                var viewRef = _this._viewContainer.get(record.currentIndex);
                viewRef.context.$implicit = record.item;
            });
        };
        NgFor.prototype._perViewChange = function (view, record) {
            view.context.$implicit = record.item;
        };
        NgFor.decorators = [
            { type: _angular_core.Directive, args: [{ selector: '[ngFor][ngForOf]' },] },
        ];
        /** @nocollapse */
        NgFor.ctorParameters = [
            { type: _angular_core.ViewContainerRef, },
            { type: _angular_core.TemplateRef, },
            { type: _angular_core.IterableDiffers, },
            { type: _angular_core.ChangeDetectorRef, },
        ];
        NgFor.propDecorators = {
            'ngForOf': [{ type: _angular_core.Input },],
            'ngForTrackBy': [{ type: _angular_core.Input },],
            'ngForTemplate': [{ type: _angular_core.Input },],
        };
        return NgFor;
    }());
    var RecordViewTuple = (function () {
        function RecordViewTuple(record, view) {
            this.record = record;
            this.view = view;
        }
        return RecordViewTuple;
    }());

    /**
     * Removes or recreates a portion of the DOM tree based on an {expression}.
     *
     * If the expression assigned to `ngIf` evaluates to a falsy value then the element
     * is removed from the DOM, otherwise a clone of the element is reinserted into the DOM.
     *
     * ### Example ([live demo](http://plnkr.co/edit/fe0kgemFBtmQOY31b4tw?p=preview)):
     *
     * ```
     * <div *ngIf="errorCount > 0" class="error">
     *   <!-- Error message displayed when the errorCount property in the current context is greater
     * than 0. -->
     *   {{errorCount}} errors detected
     * </div>
     * ```
     *
     * ### Syntax
     *
     * - `<div *ngIf="condition">...</div>`
     * - `<div template="ngIf condition">...</div>`
     * - `<template [ngIf]="condition"><div>...</div></template>`
     *
     * @stable
     */
    var NgIf = (function () {
        function NgIf(_viewContainer, _template) {
            this._viewContainer = _viewContainer;
            this._template = _template;
            this._hasView = false;
        }
        Object.defineProperty(NgIf.prototype, "ngIf", {
            set: function (condition) {
                if (condition && !this._hasView) {
                    this._hasView = true;
                    this._viewContainer.createEmbeddedView(this._template);
                }
                else if (!condition && this._hasView) {
                    this._hasView = false;
                    this._viewContainer.clear();
                }
            },
            enumerable: true,
            configurable: true
        });
        NgIf.decorators = [
            { type: _angular_core.Directive, args: [{ selector: '[ngIf]' },] },
        ];
        /** @nocollapse */
        NgIf.ctorParameters = [
            { type: _angular_core.ViewContainerRef, },
            { type: _angular_core.TemplateRef, },
        ];
        NgIf.propDecorators = {
            'ngIf': [{ type: _angular_core.Input },],
        };
        return NgIf;
    }());

    var _CASE_DEFAULT = {};
    var SwitchView = (function () {
        function SwitchView(_viewContainerRef, _templateRef) {
            this._viewContainerRef = _viewContainerRef;
            this._templateRef = _templateRef;
        }
        SwitchView.prototype.create = function () { this._viewContainerRef.createEmbeddedView(this._templateRef); };
        SwitchView.prototype.destroy = function () { this._viewContainerRef.clear(); };
        return SwitchView;
    }());
    /**
     * @ngModule CommonModule
     *
     * @whatItDoes Adds / removes DOM sub-trees when the nest match expressions matches the switch
     *             expression.
     *
     * @howToUse
     * ```
     *     <container-element [ngSwitch]="switch_expression">
     *       <some-element *ngSwitchCase="match_expression_1">...</some-element>
     *       <some-element *ngSwitchCase="match_expression_2">...</some-element>
     *       <some-other-element *ngSwitchCase="match_expression_3">...</some-other-element>
     *       <ng-container *ngSwitchCase="match_expression_3">
     *         <!-- use a ng-container to group multiple root nodes -->
     *         <inner-element></inner-element>
     *         <inner-other-element></inner-other-element>
     *       </ng-container>
     *       <some-element *ngSwitchDefault>...</some-element>
     *     </container-element>
     * ```
     * @description
     *
     * `NgSwitch` stamps out nested views when their match expression value matches the value of the
     * switch expression.
     *
     * In other words:
     * - you define a container element (where you place the directive with a switch expression on the
     * `[ngSwitch]="..."` attribute)
     * - you define inner views inside the `NgSwitch` and place a `*ngSwitchCase` attribute on the view
     * root elements.
     *
     * Elements within `NgSwitch` but outside of a `NgSwitchCase` or `NgSwitchDefault` directives will
     * be preserved at the location.
     *
     * The `ngSwitchCase` directive informs the parent `NgSwitch` of which view to display when the
     * expression is evaluated.
     * When no matching expression is found on a `ngSwitchCase` view, the `ngSwitchDefault` view is
     * stamped out.
     *
     * @stable
     */
    var NgSwitch = (function () {
        function NgSwitch() {
            this._useDefault = false;
            this._valueViews = new Map();
            this._activeViews = [];
        }
        Object.defineProperty(NgSwitch.prototype, "ngSwitch", {
            set: function (value) {
                // Set of views to display for this value
                var views = this._valueViews.get(value);
                if (views) {
                    this._useDefault = false;
                }
                else {
                    // No view to display for the current value -> default case
                    // Nothing to do if the default case was already active
                    if (this._useDefault) {
                        return;
                    }
                    this._useDefault = true;
                    views = this._valueViews.get(_CASE_DEFAULT);
                }
                this._emptyAllActiveViews();
                this._activateViews(views);
                this._switchValue = value;
            },
            enumerable: true,
            configurable: true
        });
        /** @internal */
        NgSwitch.prototype._onCaseValueChanged = function (oldCase, newCase, view) {
            this._deregisterView(oldCase, view);
            this._registerView(newCase, view);
            if (oldCase === this._switchValue) {
                view.destroy();
                ListWrapper.remove(this._activeViews, view);
            }
            else if (newCase === this._switchValue) {
                if (this._useDefault) {
                    this._useDefault = false;
                    this._emptyAllActiveViews();
                }
                view.create();
                this._activeViews.push(view);
            }
            // Switch to default when there is no more active ViewContainers
            if (this._activeViews.length === 0 && !this._useDefault) {
                this._useDefault = true;
                this._activateViews(this._valueViews.get(_CASE_DEFAULT));
            }
        };
        NgSwitch.prototype._emptyAllActiveViews = function () {
            var activeContainers = this._activeViews;
            for (var i = 0; i < activeContainers.length; i++) {
                activeContainers[i].destroy();
            }
            this._activeViews = [];
        };
        NgSwitch.prototype._activateViews = function (views) {
            if (views) {
                for (var i = 0; i < views.length; i++) {
                    views[i].create();
                }
                this._activeViews = views;
            }
        };
        /** @internal */
        NgSwitch.prototype._registerView = function (value, view) {
            var views = this._valueViews.get(value);
            if (!views) {
                views = [];
                this._valueViews.set(value, views);
            }
            views.push(view);
        };
        NgSwitch.prototype._deregisterView = function (value, view) {
            // `_CASE_DEFAULT` is used a marker for non-registered cases
            if (value === _CASE_DEFAULT)
                return;
            var views = this._valueViews.get(value);
            if (views.length == 1) {
                this._valueViews.delete(value);
            }
            else {
                ListWrapper.remove(views, view);
            }
        };
        NgSwitch.decorators = [
            { type: _angular_core.Directive, args: [{ selector: '[ngSwitch]' },] },
        ];
        /** @nocollapse */
        NgSwitch.ctorParameters = [];
        NgSwitch.propDecorators = {
            'ngSwitch': [{ type: _angular_core.Input },],
        };
        return NgSwitch;
    }());
    /**
     * @ngModule CommonModule
     *
     * @whatItDoes Creates a view that will be added/removed from the parent {@link NgSwitch} when the
     *             given expression evaluate to respectively the same/different value as the switch
     *             expression.
     *
     * @howToUse
     * ```
     * <container-element [ngSwitch]="switch_expression">
     *   <some-element *ngSwitchCase="match_expression_1">...</some-element>
     * </container-element>
     *```
     * @description
     *
     * Insert the sub-tree when the expression evaluates to the same value as the enclosing switch
     * expression.
     *
     * If multiple match expressions match the switch expression value, all of them are displayed.
     *
     * See {@link NgSwitch} for more details and example.
     *
     * @stable
     */
    var NgSwitchCase = (function () {
        function NgSwitchCase(viewContainer, templateRef, ngSwitch) {
            // `_CASE_DEFAULT` is used as a marker for a not yet initialized value
            this._value = _CASE_DEFAULT;
            this._switch = ngSwitch;
            this._view = new SwitchView(viewContainer, templateRef);
        }
        Object.defineProperty(NgSwitchCase.prototype, "ngSwitchCase", {
            set: function (value) {
                this._switch._onCaseValueChanged(this._value, value, this._view);
                this._value = value;
            },
            enumerable: true,
            configurable: true
        });
        NgSwitchCase.decorators = [
            { type: _angular_core.Directive, args: [{ selector: '[ngSwitchCase]' },] },
        ];
        /** @nocollapse */
        NgSwitchCase.ctorParameters = [
            { type: _angular_core.ViewContainerRef, },
            { type: _angular_core.TemplateRef, },
            { type: NgSwitch, decorators: [{ type: _angular_core.Host },] },
        ];
        NgSwitchCase.propDecorators = {
            'ngSwitchCase': [{ type: _angular_core.Input },],
        };
        return NgSwitchCase;
    }());
    /**
     * @ngModule CommonModule
     * @whatItDoes Creates a view that is added to the parent {@link NgSwitch} when no case expressions
     * match the
     *             switch expression.
     *
     * @howToUse
     * ```
     * <container-element [ngSwitch]="switch_expression">
     *   <some-element *ngSwitchCase="match_expression_1">...</some-element>
     *   <some-other-element *ngSwitchDefault>...</some-other-element>
     * </container-element>
     * ```
     *
     * @description
     *
     * Insert the sub-tree when no case expressions evaluate to the same value as the enclosing switch
     * expression.
     *
     * See {@link NgSwitch} for more details and example.
     *
     * @stable
     */
    var NgSwitchDefault = (function () {
        function NgSwitchDefault(viewContainer, templateRef, sswitch) {
            sswitch._registerView(_CASE_DEFAULT, new SwitchView(viewContainer, templateRef));
        }
        NgSwitchDefault.decorators = [
            { type: _angular_core.Directive, args: [{ selector: '[ngSwitchDefault]' },] },
        ];
        /** @nocollapse */
        NgSwitchDefault.ctorParameters = [
            { type: _angular_core.ViewContainerRef, },
            { type: _angular_core.TemplateRef, },
            { type: NgSwitch, decorators: [{ type: _angular_core.Host },] },
        ];
        return NgSwitchDefault;
    }());

    /**
     * @ngModule CommonModule
     *
     * @whatItDoes Adds / removes DOM sub-trees based on a numeric value. Tailored for pluralization.
     *
     * @howToUse
     * ```
     * <some-element [ngPlural]="value">
     *   <ng-container *ngPluralCase="'=0'">there is nothing</ng-container>
     *   <ng-container *ngPluralCase="'=1'">there is one</ng-container>
     *   <ng-container *ngPluralCase="'few'">there are a few</ng-container>
     *   <ng-container *ngPluralCase="'other'">there are exactly #</ng-container>
     * </some-element>
     * ```
     *
     * @description
     *
     * Displays DOM sub-trees that match the switch expression value, or failing that, DOM sub-trees
     * that match the switch expression's pluralization category.
     *
     * To use this directive you must provide a container element that sets the `[ngPlural]` attribute
     * to a switch expression. Inner elements with a `[ngPluralCase]` will display based on their
     * expression:
     * - if `[ngPluralCase]` is set to a value starting with `=`, it will only display if the value
     *   matches the switch expression exactly,
     * - otherwise, the view will be treated as a "category match", and will only display if exact
     *   value matches aren't found and the value maps to its category for the defined locale.
     *
     * See http://cldr.unicode.org/index/cldr-spec/plural-rules
     *
     * @experimental
     */
    var NgPlural = (function () {
        function NgPlural(_localization) {
            this._localization = _localization;
            this._caseViews = {};
        }
        Object.defineProperty(NgPlural.prototype, "ngPlural", {
            set: function (value) {
                this._switchValue = value;
                this._updateView();
            },
            enumerable: true,
            configurable: true
        });
        NgPlural.prototype.addCase = function (value, switchView) { this._caseViews[value] = switchView; };
        NgPlural.prototype._updateView = function () {
            this._clearViews();
            var cases = Object.keys(this._caseViews);
            var key = getPluralCategory(this._switchValue, cases, this._localization);
            this._activateView(this._caseViews[key]);
        };
        NgPlural.prototype._clearViews = function () {
            if (this._activeView)
                this._activeView.destroy();
        };
        NgPlural.prototype._activateView = function (view) {
            if (view) {
                this._activeView = view;
                this._activeView.create();
            }
        };
        NgPlural.decorators = [
            { type: _angular_core.Directive, args: [{ selector: '[ngPlural]' },] },
        ];
        /** @nocollapse */
        NgPlural.ctorParameters = [
            { type: NgLocalization, },
        ];
        NgPlural.propDecorators = {
            'ngPlural': [{ type: _angular_core.Input },],
        };
        return NgPlural;
    }());
    /**
     * @ngModule CommonModule
     *
     * @whatItDoes Creates a view that will be added/removed from the parent {@link NgPlural} when the
     *             given expression matches the plural expression according to CLDR rules.
     *
     * @howToUse
     * ```
     * <some-element [ngPlural]="value">
     *   <ng-container *ngPluralCase="'=0'">...</ng-container>
     *   <ng-container *ngPluralCase="'other'">...</ng-container>
     * </some-element>
     *```
     *
     * See {@link NgPlural} for more details and example.
     *
     * @experimental
     */
    var NgPluralCase = (function () {
        function NgPluralCase(value, template, viewContainer, ngPlural) {
            this.value = value;
            ngPlural.addCase(value, new SwitchView(viewContainer, template));
        }
        NgPluralCase.decorators = [
            { type: _angular_core.Directive, args: [{ selector: '[ngPluralCase]' },] },
        ];
        /** @nocollapse */
        NgPluralCase.ctorParameters = [
            { type: undefined, decorators: [{ type: _angular_core.Attribute, args: ['ngPluralCase',] },] },
            { type: _angular_core.TemplateRef, },
            { type: _angular_core.ViewContainerRef, },
            { type: NgPlural, decorators: [{ type: _angular_core.Host },] },
        ];
        return NgPluralCase;
    }());

    /**
     * @ngModule CommonModule
     *
     * @whatItDoes Update an HTML element styles.
     *
     * @howToUse
     * ```
     * <some-element [ngStyle]="{'font-style': styleExp}">...</some-element>
     *
     * <some-element [ngStyle]="{'max-width.px': widthExp}">...</some-element>
     *
     * <some-element [ngStyle]="objExp">...</some-element>
     * ```
     *
     * @description
     *
     * The styles are updated according to the value of the expression evaluation:
     * - keys are style names with an option `.<unit>` suffix (ie 'top.px', 'font-style.em'),
     * - values are the values assigned to those properties (expressed in the given unit).
     *
     * @stable
     */
    var NgStyle = (function () {
        function NgStyle(_differs, _ngEl, _renderer) {
            this._differs = _differs;
            this._ngEl = _ngEl;
            this._renderer = _renderer;
        }
        Object.defineProperty(NgStyle.prototype, "ngStyle", {
            set: function (v) {
                this._ngStyle = v;
                if (!this._differ && v) {
                    this._differ = this._differs.find(v).create(null);
                }
            },
            enumerable: true,
            configurable: true
        });
        NgStyle.prototype.ngDoCheck = function () {
            if (this._differ) {
                var changes = this._differ.diff(this._ngStyle);
                if (changes) {
                    this._applyChanges(changes);
                }
            }
        };
        NgStyle.prototype._applyChanges = function (changes) {
            var _this = this;
            changes.forEachRemovedItem(function (record) { return _this._setStyle(record.key, null); });
            changes.forEachAddedItem(function (record) { return _this._setStyle(record.key, record.currentValue); });
            changes.forEachChangedItem(function (record) { return _this._setStyle(record.key, record.currentValue); });
        };
        NgStyle.prototype._setStyle = function (nameAndUnit, value) {
            var _a = nameAndUnit.split('.'), name = _a[0], unit = _a[1];
            value = value && unit ? "" + value + unit : value;
            this._renderer.setElementStyle(this._ngEl.nativeElement, name, value);
        };
        NgStyle.decorators = [
            { type: _angular_core.Directive, args: [{ selector: '[ngStyle]' },] },
        ];
        /** @nocollapse */
        NgStyle.ctorParameters = [
            { type: _angular_core.KeyValueDiffers, },
            { type: _angular_core.ElementRef, },
            { type: _angular_core.Renderer, },
        ];
        NgStyle.propDecorators = {
            'ngStyle': [{ type: _angular_core.Input },],
        };
        return NgStyle;
    }());

    /**
     * @ngModule CommonModule
     *
     * @whatItDoes Inserts an embedded view from a prepared `TemplateRef`
     *
     * @howToUse
     * ```
     * <template [ngTemplateOutlet]="templateRefExpression"
     *           [ngOutletContext]="objectExpression">
     * </template>
     * ```
     *
     * @description
     *
     * You can attach a context object to the `EmbeddedViewRef` by setting `[ngOutletContext]`.
     * `[ngOutletContext]` should be an object, the object's keys will be the local template variables
     * available within the `TemplateRef`.
     *
     * Note: using the key `$implicit` in the context object will set it's value as default.
     *
     * @experimental
     */
    var NgTemplateOutlet = (function () {
        function NgTemplateOutlet(_viewContainerRef) {
            this._viewContainerRef = _viewContainerRef;
        }
        Object.defineProperty(NgTemplateOutlet.prototype, "ngOutletContext", {
            set: function (context) { this._context = context; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgTemplateOutlet.prototype, "ngTemplateOutlet", {
            set: function (templateRef) { this._templateRef = templateRef; },
            enumerable: true,
            configurable: true
        });
        NgTemplateOutlet.prototype.ngOnChanges = function (changes) {
            if (this._viewRef) {
                this._viewContainerRef.remove(this._viewContainerRef.indexOf(this._viewRef));
            }
            if (this._templateRef) {
                this._viewRef = this._viewContainerRef.createEmbeddedView(this._templateRef, this._context);
            }
        };
        NgTemplateOutlet.decorators = [
            { type: _angular_core.Directive, args: [{ selector: '[ngTemplateOutlet]' },] },
        ];
        /** @nocollapse */
        NgTemplateOutlet.ctorParameters = [
            { type: _angular_core.ViewContainerRef, },
        ];
        NgTemplateOutlet.propDecorators = {
            'ngOutletContext': [{ type: _angular_core.Input },],
            'ngTemplateOutlet': [{ type: _angular_core.Input },],
        };
        return NgTemplateOutlet;
    }());

    /**
     * A collection of Angular directives that are likely to be used in each and every Angular
     * application.
     */
    var COMMON_DIRECTIVES = [
        NgClass,
        NgFor,
        NgIf,
        NgTemplateOutlet,
        NgStyle,
        NgSwitch,
        NgSwitchCase,
        NgSwitchDefault,
        NgPlural,
        NgPluralCase,
    ];

    var isPromise = _angular_core.__core_private__.isPromise;

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$4 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    /**
     * @stable
     */
    var BaseError = (function (_super) {
        __extends$4(BaseError, _super);
        function BaseError(message) {
            // Errors don't use current this, instead they create a new instance.
            // We have to do forward all of our api to the nativeInstance.
            var nativeError = _super.call(this, message);
            this._nativeError = nativeError;
        }
        Object.defineProperty(BaseError.prototype, "message", {
            get: function () { return this._nativeError.message; },
            set: function (message) { this._nativeError.message = message; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseError.prototype, "name", {
            get: function () { return this._nativeError.name; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseError.prototype, "stack", {
            get: function () { return this._nativeError.stack; },
            set: function (value) { this._nativeError.stack = value; },
            enumerable: true,
            configurable: true
        });
        BaseError.prototype.toString = function () { return this._nativeError.toString(); };
        return BaseError;
    }(Error));
    /**
     * @stable
     */
    var WrappedError = (function (_super) {
        __extends$4(WrappedError, _super);
        function WrappedError(message, error) {
            _super.call(this, message + " caused by: " + (error instanceof Error ? error.message : error));
            this.originalError = error;
        }
        Object.defineProperty(WrappedError.prototype, "stack", {
            get: function () {
                return (this.originalError instanceof Error ? this.originalError : this._nativeError)
                    .stack;
            },
            enumerable: true,
            configurable: true
        });
        return WrappedError;
    }(BaseError));

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$3 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var InvalidPipeArgumentError = (function (_super) {
        __extends$3(InvalidPipeArgumentError, _super);
        function InvalidPipeArgumentError(type, value) {
            _super.call(this, "Invalid argument '" + value + "' for pipe '" + stringify(type) + "'");
        }
        return InvalidPipeArgumentError;
    }(BaseError));

    var ObservableStrategy = (function () {
        function ObservableStrategy() {
        }
        ObservableStrategy.prototype.createSubscription = function (async, updateLatestValue) {
            return async.subscribe({ next: updateLatestValue, error: function (e) { throw e; } });
        };
        ObservableStrategy.prototype.dispose = function (subscription) { subscription.unsubscribe(); };
        ObservableStrategy.prototype.onDestroy = function (subscription) { subscription.unsubscribe(); };
        return ObservableStrategy;
    }());
    var PromiseStrategy = (function () {
        function PromiseStrategy() {
        }
        PromiseStrategy.prototype.createSubscription = function (async, updateLatestValue) {
            return async.then(updateLatestValue, function (e) { throw e; });
        };
        PromiseStrategy.prototype.dispose = function (subscription) { };
        PromiseStrategy.prototype.onDestroy = function (subscription) { };
        return PromiseStrategy;
    }());
    var _promiseStrategy = new PromiseStrategy();
    var _observableStrategy = new ObservableStrategy();
    /**
     * @ngModule CommonModule
     * @whatItDoes Unwraps a value from an asynchronous primitive.
     * @howToUse `observable_or_promise_expression | async`
     * @description
     * The `async` pipe subscribes to an `Observable` or `Promise` and returns the latest value it has
     * emitted. When a new value is emitted, the `async` pipe marks the component to be checked for
     * changes. When the component gets destroyed, the `async` pipe unsubscribes automatically to avoid
     * potential memory leaks.
     *
     *
     * ## Examples
     *
     * This example binds a `Promise` to the view. Clicking the `Resolve` button resolves the
     * promise.
     *
     * {@example common/pipes/ts/async_pipe.ts region='AsyncPipePromise'}
     *
     * It's also possible to use `async` with Observables. The example below binds the `time` Observable
     * to the view. The Observable continuesly updates the view with the current time.
     *
     * {@example common/pipes/ts/async_pipe.ts region='AsyncPipeObservable'}
     *
     * @stable
     */
    var AsyncPipe = (function () {
        function AsyncPipe(_ref) {
            this._ref = _ref;
            this._latestValue = null;
            this._latestReturnedValue = null;
            this._subscription = null;
            this._obj = null;
            this._strategy = null;
        }
        AsyncPipe.prototype.ngOnDestroy = function () {
            if (this._subscription) {
                this._dispose();
            }
        };
        AsyncPipe.prototype.transform = function (obj) {
            if (!this._obj) {
                if (obj) {
                    this._subscribe(obj);
                }
                this._latestReturnedValue = this._latestValue;
                return this._latestValue;
            }
            if (obj !== this._obj) {
                this._dispose();
                return this.transform(obj);
            }
            if (this._latestValue === this._latestReturnedValue) {
                return this._latestReturnedValue;
            }
            this._latestReturnedValue = this._latestValue;
            return _angular_core.WrappedValue.wrap(this._latestValue);
        };
        AsyncPipe.prototype._subscribe = function (obj) {
            var _this = this;
            this._obj = obj;
            this._strategy = this._selectStrategy(obj);
            this._subscription = this._strategy.createSubscription(obj, function (value) { return _this._updateLatestValue(obj, value); });
        };
        AsyncPipe.prototype._selectStrategy = function (obj) {
            if (isPromise(obj)) {
                return _promiseStrategy;
            }
            if (obj.subscribe) {
                return _observableStrategy;
            }
            throw new InvalidPipeArgumentError(AsyncPipe, obj);
        };
        AsyncPipe.prototype._dispose = function () {
            this._strategy.dispose(this._subscription);
            this._latestValue = null;
            this._latestReturnedValue = null;
            this._subscription = null;
            this._obj = null;
        };
        AsyncPipe.prototype._updateLatestValue = function (async, value) {
            if (async === this._obj) {
                this._latestValue = value;
                this._ref.markForCheck();
            }
        };
        AsyncPipe.decorators = [
            { type: _angular_core.Pipe, args: [{ name: 'async', pure: false },] },
        ];
        /** @nocollapse */
        AsyncPipe.ctorParameters = [
            { type: _angular_core.ChangeDetectorRef, },
        ];
        return AsyncPipe;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var NumberFormatStyle;
    (function (NumberFormatStyle) {
        NumberFormatStyle[NumberFormatStyle["Decimal"] = 0] = "Decimal";
        NumberFormatStyle[NumberFormatStyle["Percent"] = 1] = "Percent";
        NumberFormatStyle[NumberFormatStyle["Currency"] = 2] = "Currency";
    })(NumberFormatStyle || (NumberFormatStyle = {}));
    var NumberFormatter = (function () {
        function NumberFormatter() {
        }
        NumberFormatter.format = function (num, locale, style, _a) {
            var _b = _a === void 0 ? {} : _a, minimumIntegerDigits = _b.minimumIntegerDigits, minimumFractionDigits = _b.minimumFractionDigits, maximumFractionDigits = _b.maximumFractionDigits, currency = _b.currency, _c = _b.currencyAsSymbol, currencyAsSymbol = _c === void 0 ? false : _c;
            var options = {
                minimumIntegerDigits: minimumIntegerDigits,
                minimumFractionDigits: minimumFractionDigits,
                maximumFractionDigits: maximumFractionDigits,
                style: NumberFormatStyle[style].toLowerCase()
            };
            if (style == NumberFormatStyle.Currency) {
                options.currency = currency;
                options.currencyDisplay = currencyAsSymbol ? 'symbol' : 'code';
            }
            return new Intl.NumberFormat(locale, options).format(num);
        };
        return NumberFormatter;
    }());
    var DATE_FORMATS_SPLIT = /((?:[^yMLdHhmsazZEwGjJ']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|L+|d+|H+|h+|J+|j+|m+|s+|a|z|Z|G+|w+))(.*)/;
    var PATTERN_ALIASES = {
        yMMMdjms: datePartGetterFactory(combine([
            digitCondition('year', 1),
            nameCondition('month', 3),
            digitCondition('day', 1),
            digitCondition('hour', 1),
            digitCondition('minute', 1),
            digitCondition('second', 1),
        ])),
        yMdjm: datePartGetterFactory(combine([
            digitCondition('year', 1), digitCondition('month', 1), digitCondition('day', 1),
            digitCondition('hour', 1), digitCondition('minute', 1)
        ])),
        yMMMMEEEEd: datePartGetterFactory(combine([
            digitCondition('year', 1), nameCondition('month', 4), nameCondition('weekday', 4),
            digitCondition('day', 1)
        ])),
        yMMMMd: datePartGetterFactory(combine([digitCondition('year', 1), nameCondition('month', 4), digitCondition('day', 1)])),
        yMMMd: datePartGetterFactory(combine([digitCondition('year', 1), nameCondition('month', 3), digitCondition('day', 1)])),
        yMd: datePartGetterFactory(combine([digitCondition('year', 1), digitCondition('month', 1), digitCondition('day', 1)])),
        jms: datePartGetterFactory(combine([digitCondition('hour', 1), digitCondition('second', 1), digitCondition('minute', 1)])),
        jm: datePartGetterFactory(combine([digitCondition('hour', 1), digitCondition('minute', 1)]))
    };
    var DATE_FORMATS = {
        yyyy: datePartGetterFactory(digitCondition('year', 4)),
        yy: datePartGetterFactory(digitCondition('year', 2)),
        y: datePartGetterFactory(digitCondition('year', 1)),
        MMMM: datePartGetterFactory(nameCondition('month', 4)),
        MMM: datePartGetterFactory(nameCondition('month', 3)),
        MM: datePartGetterFactory(digitCondition('month', 2)),
        M: datePartGetterFactory(digitCondition('month', 1)),
        LLLL: datePartGetterFactory(nameCondition('month', 4)),
        dd: datePartGetterFactory(digitCondition('day', 2)),
        d: datePartGetterFactory(digitCondition('day', 1)),
        HH: digitModifier(hourExtracter(datePartGetterFactory(hour12Modify(digitCondition('hour', 2), false)))),
        H: hourExtracter(datePartGetterFactory(hour12Modify(digitCondition('hour', 1), false))),
        hh: digitModifier(hourExtracter(datePartGetterFactory(hour12Modify(digitCondition('hour', 2), true)))),
        h: hourExtracter(datePartGetterFactory(hour12Modify(digitCondition('hour', 1), true))),
        jj: datePartGetterFactory(digitCondition('hour', 2)),
        j: datePartGetterFactory(digitCondition('hour', 1)),
        mm: digitModifier(datePartGetterFactory(digitCondition('minute', 2))),
        m: datePartGetterFactory(digitCondition('minute', 1)),
        ss: digitModifier(datePartGetterFactory(digitCondition('second', 2))),
        s: datePartGetterFactory(digitCondition('second', 1)),
        // while ISO 8601 requires fractions to be prefixed with `.` or `,`
        // we can be just safely rely on using `sss` since we currently don't support single or two digit
        // fractions
        sss: datePartGetterFactory(digitCondition('second', 3)),
        EEEE: datePartGetterFactory(nameCondition('weekday', 4)),
        EEE: datePartGetterFactory(nameCondition('weekday', 3)),
        EE: datePartGetterFactory(nameCondition('weekday', 2)),
        E: datePartGetterFactory(nameCondition('weekday', 1)),
        a: hourClockExtracter(datePartGetterFactory(hour12Modify(digitCondition('hour', 1), true))),
        Z: timeZoneGetter('short'),
        z: timeZoneGetter('long'),
        ww: datePartGetterFactory({}),
        // first Thursday of the year. not support ?
        w: datePartGetterFactory({}),
        // of the year not support ?
        G: datePartGetterFactory(nameCondition('era', 1)),
        GG: datePartGetterFactory(nameCondition('era', 2)),
        GGG: datePartGetterFactory(nameCondition('era', 3)),
        GGGG: datePartGetterFactory(nameCondition('era', 4))
    };
    function digitModifier(inner) {
        return function (date, locale) {
            var result = inner(date, locale);
            return result.length == 1 ? '0' + result : result;
        };
    }
    function hourClockExtracter(inner) {
        return function (date, locale) {
            var result = inner(date, locale);
            return result.split(' ')[1];
        };
    }
    function hourExtracter(inner) {
        return function (date, locale) {
            var result = inner(date, locale);
            return result.split(' ')[0];
        };
    }
    function intlDateFormat(date, locale, options) {
        return new Intl.DateTimeFormat(locale, options).format(date).replace(/[\u200e\u200f]/g, '');
    }
    function timeZoneGetter(timezone) {
        // To workaround `Intl` API restriction for single timezone let format with 24 hours
        var options = { hour: '2-digit', hour12: false, timeZoneName: timezone };
        return function (date, locale) {
            var result = intlDateFormat(date, locale, options);
            // Then extract first 3 letters that related to hours
            return result ? result.substring(3) : '';
        };
    }
    function hour12Modify(options, value) {
        options.hour12 = value;
        return options;
    }
    function digitCondition(prop, len) {
        var result = {};
        result[prop] = len == 2 ? '2-digit' : 'numeric';
        return result;
    }
    function nameCondition(prop, len) {
        var result = {};
        result[prop] = len < 4 ? 'short' : 'long';
        return result;
    }
    function combine(options) {
        var result = {};
        options.forEach(function (option) { Object.assign(result, option); });
        return result;
    }
    function datePartGetterFactory(ret) {
        return function (date, locale) { return intlDateFormat(date, locale, ret); };
    }
    var datePartsFormatterCache = new Map();
    function dateFormatter(format, date, locale) {
        var text = '';
        var match;
        var fn;
        var parts = [];
        if (PATTERN_ALIASES[format]) {
            return PATTERN_ALIASES[format](date, locale);
        }
        if (datePartsFormatterCache.has(format)) {
            parts = datePartsFormatterCache.get(format);
        }
        else {
            var matches = DATE_FORMATS_SPLIT.exec(format);
            while (format) {
                match = DATE_FORMATS_SPLIT.exec(format);
                if (match) {
                    parts = concat(parts, match, 1);
                    format = parts.pop();
                }
                else {
                    parts.push(format);
                    format = null;
                }
            }
            datePartsFormatterCache.set(format, parts);
        }
        parts.forEach(function (part) {
            fn = DATE_FORMATS[part];
            text += fn ? fn(date, locale) :
                part === '\'\'' ? '\'' : part.replace(/(^'|'$)/g, '').replace(/''/g, '\'');
        });
        return text;
    }
    var slice = [].slice;
    function concat(array1 /** TODO #9100 */, array2 /** TODO #9100 */, index /** TODO #9100 */) {
        return array1.concat(slice.call(array2, index));
    }
    var DateFormatter = (function () {
        function DateFormatter() {
        }
        DateFormatter.format = function (date, locale, pattern) {
            return dateFormatter(pattern, date, locale);
        };
        return DateFormatter;
    }());

    /**
     * @ngModule CommonModule
     * @whatItDoes Formats a date according to locale rules.
     * @howToUse `date_expression | date[:format]`
     * @description
     *
     * Where:
     * - `expression` is a date object or a number (milliseconds since UTC epoch) or an ISO string
     * (https://www.w3.org/TR/NOTE-datetime).
     * - `format` indicates which date/time components to include. The format can be predifined as
     *   shown below or custom as shown in the table.
     *   - `'medium'`: equivalent to `'yMMMdjms'` (e.g. `Sep 3, 2010, 12:05:08 PM` for `en-US`)
     *   - `'short'`: equivalent to `'yMdjm'` (e.g. `9/3/2010, 12:05 PM` for `en-US`)
     *   - `'fullDate'`: equivalent to `'yMMMMEEEEd'` (e.g. `Friday, September 3, 2010` for `en-US`)
     *   - `'longDate'`: equivalent to `'yMMMMd'` (e.g. `September 3, 2010` for `en-US`)
     *   - `'mediumDate'`: equivalent to `'yMMMd'` (e.g. `Sep 3, 2010` for `en-US`)
     *   - `'shortDate'`: equivalent to `'yMd'` (e.g. `9/3/2010` for `en-US`)
     *   - `'mediumTime'`: equivalent to `'jms'` (e.g. `12:05:08 PM` for `en-US`)
     *   - `'shortTime'`: equivalent to `'jm'` (e.g. `12:05 PM` for `en-US`)
     *
     *
     *  | Component | Symbol | Short Form   | Long Form         | Numeric   | 2-digit   |
     *  |-----------|:------:|--------------|-------------------|-----------|-----------|
     *  | era       |   G    | G (AD)       | GGGG (Anno Domini)| -         | -         |
     *  | year      |   y    | -            | -                 | y (2015)  | yy (15)   |
     *  | month     |   M    | MMM (Sep)    | MMMM (September)  | M (9)     | MM (09)   |
     *  | day       |   d    | -            | -                 | d (3)     | dd (03)   |
     *  | weekday   |   E    | EEE (Sun)    | EEEE (Sunday)     | -         | -         |
     *  | hour      |   j    | -            | -                 | j (13)    | jj (13)   |
     *  | hour12    |   h    | -            | -                 | h (1 PM)  | hh (01 PM)|
     *  | hour24    |   H    | -            | -                 | H (13)    | HH (13)   |
     *  | minute    |   m    | -            | -                 | m (5)     | mm (05)   |
     *  | second    |   s    | -            | -                 | s (9)     | ss (09)   |
     *  | timezone  |   z    | -            | z (Pacific Standard Time)| -  | -         |
     *  | timezone  |   Z    | Z (GMT-8:00) | -                 | -         | -         |
     *  | timezone  |   a    | a (PM)       | -                 | -         | -         |
     *
     * In javascript, only the components specified will be respected (not the ordering,
     * punctuations, ...) and details of the formatting will be dependent on the locale.
     *
     * Timezone of the formatted text will be the local system timezone of the end-user's machine.
     *
     * WARNINGS:
     * - this pipe is marked as pure hence it will not be re-evaluated when the input is mutated.
     *   Instead users should treat the date as an immutable object and change the reference when the
     *   pipe needs to re-run (this is to avoid reformatting the date on every change detection run
     *   which would be an expensive operation).
     * - this pipe uses the Internationalization API. Therefore it is only reliable in Chrome and Opera
     *   browsers.
     *
     * ### Examples
     *
     * Assuming `dateObj` is (year: 2015, month: 6, day: 15, hour: 21, minute: 43, second: 11)
     * in the _local_ time and locale is 'en-US':
     *
     * ```
     *     {{ dateObj | date }}               // output is 'Jun 15, 2015'
     *     {{ dateObj | date:'medium' }}      // output is 'Jun 15, 2015, 9:43:11 PM'
     *     {{ dateObj | date:'shortTime' }}   // output is '9:43 PM'
     *     {{ dateObj | date:'mmss' }}        // output is '43:11'
     * ```
     *
     * {@example common/pipes/ts/date_pipe.ts region='DatePipe'}
     *
     * @stable
     */
    var DatePipe = (function () {
        function DatePipe(_locale) {
            this._locale = _locale;
        }
        DatePipe.prototype.transform = function (value, pattern) {
            if (pattern === void 0) { pattern = 'mediumDate'; }
            if (isBlank(value))
                return null;
            if (!this.supports(value)) {
                throw new InvalidPipeArgumentError(DatePipe, value);
            }
            if (NumberWrapper.isNumeric(value)) {
                value = parseFloat(value);
            }
            return DateFormatter.format(new Date(value), this._locale, DatePipe._ALIASES[pattern] || pattern);
        };
        DatePipe.prototype.supports = function (obj) {
            return isDate(obj) || NumberWrapper.isNumeric(obj) ||
                (typeof obj === 'string' && isDate(new Date(obj)));
        };
        /** @internal */
        DatePipe._ALIASES = {
            'medium': 'yMMMdjms',
            'short': 'yMdjm',
            'fullDate': 'yMMMMEEEEd',
            'longDate': 'yMMMMd',
            'mediumDate': 'yMMMd',
            'shortDate': 'yMd',
            'mediumTime': 'jms',
            'shortTime': 'jm'
        };
        DatePipe.decorators = [
            { type: _angular_core.Pipe, args: [{ name: 'date', pure: true },] },
        ];
        /** @nocollapse */
        DatePipe.ctorParameters = [
            { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_core.LOCALE_ID,] },] },
        ];
        return DatePipe;
    }());

    var _INTERPOLATION_REGEXP = /#/g;
    /**
     * @ngModule CommonModule
     * @whatItDoes Maps a value to a string that pluralizes the value according to locale rules.
     * @howToUse `expression | i18nPlural:mapping`
     * @description
     *
     *  Where:
     *  - `expression` is a number.
     *  - `mapping` is an object that mimics the ICU format, see
     *    http://userguide.icu-project.org/formatparse/messages
     *
     *  ## Example
     *
     * {@example common/pipes/ts/i18n_pipe.ts region='I18nPluralPipeComponent'}
     *
     * @experimental
     */
    var I18nPluralPipe = (function () {
        function I18nPluralPipe(_localization) {
            this._localization = _localization;
        }
        I18nPluralPipe.prototype.transform = function (value, pluralMap) {
            if (isBlank(value))
                return '';
            if (typeof pluralMap !== 'object' || pluralMap === null) {
                throw new InvalidPipeArgumentError(I18nPluralPipe, pluralMap);
            }
            var key = getPluralCategory(value, Object.keys(pluralMap), this._localization);
            return pluralMap[key].replace(_INTERPOLATION_REGEXP, value.toString());
        };
        I18nPluralPipe.decorators = [
            { type: _angular_core.Pipe, args: [{ name: 'i18nPlural', pure: true },] },
        ];
        /** @nocollapse */
        I18nPluralPipe.ctorParameters = [
            { type: NgLocalization, },
        ];
        return I18nPluralPipe;
    }());

    /**
     * @ngModule CommonModule
     * @whatItDoes Generic selector that displays the string that matches the current value.
     * @howToUse `expression | i18nSelect:mapping`
     * @description
     *
     *  Where:
     *  - `mapping`: is an object that indicates the text that should be displayed
     *  for different values of the provided `expression`.
     *
     *  ## Example
     *
     * {@example common/pipes/ts/i18n_pipe.ts region='I18nSelectPipeComponent'}
     *
     *  @experimental
     */
    var I18nSelectPipe = (function () {
        function I18nSelectPipe() {
        }
        I18nSelectPipe.prototype.transform = function (value, mapping) {
            if (isBlank(value))
                return '';
            if (typeof mapping !== 'object' || mapping === null) {
                throw new InvalidPipeArgumentError(I18nSelectPipe, mapping);
            }
            return mapping[value] || '';
        };
        I18nSelectPipe.decorators = [
            { type: _angular_core.Pipe, args: [{ name: 'i18nSelect', pure: true },] },
        ];
        /** @nocollapse */
        I18nSelectPipe.ctorParameters = [];
        return I18nSelectPipe;
    }());

    /**
     * @ngModule CommonModule
     * @whatItDoes Converts value into JSON string.
     * @howToUse `expression | json`
     * @description
     *
     * Converts value into string using `JSON.stringify`. Useful for debugging.
     *
     * ### Example
     * {@example common/pipes/ts/json_pipe.ts region='JsonPipe'}
     *
     * @stable
     */
    var JsonPipe = (function () {
        function JsonPipe() {
        }
        JsonPipe.prototype.transform = function (value) { return JSON.stringify(value, null, 2); };
        JsonPipe.decorators = [
            { type: _angular_core.Pipe, args: [{ name: 'json', pure: false },] },
        ];
        /** @nocollapse */
        JsonPipe.ctorParameters = [];
        return JsonPipe;
    }());

    /**
     * @ngModule CommonModule
     * @whatItDoes Transforms string to lowercase.
     * @howToUse `expression | lowercase`
     * @description
     *
     * Converts value into lowercase string using `String.prototype.toLowerCase()`.
     *
     * ### Example
     *
     * {@example common/pipes/ts/lowerupper_pipe.ts region='LowerUpperPipe'}
     *
     * @stable
     */
    var LowerCasePipe = (function () {
        function LowerCasePipe() {
        }
        LowerCasePipe.prototype.transform = function (value) {
            if (isBlank(value))
                return value;
            if (typeof value !== 'string') {
                throw new InvalidPipeArgumentError(LowerCasePipe, value);
            }
            return value.toLowerCase();
        };
        LowerCasePipe.decorators = [
            { type: _angular_core.Pipe, args: [{ name: 'lowercase' },] },
        ];
        /** @nocollapse */
        LowerCasePipe.ctorParameters = [];
        return LowerCasePipe;
    }());

    var _NUMBER_FORMAT_REGEXP = /^(\d+)?\.((\d+)(-(\d+))?)?$/;
    function formatNumber(pipe, locale, value, style, digits, currency, currencyAsSymbol) {
        if (currency === void 0) { currency = null; }
        if (currencyAsSymbol === void 0) { currencyAsSymbol = false; }
        if (isBlank(value))
            return null;
        // Convert strings to numbers
        value = typeof value === 'string' && NumberWrapper.isNumeric(value) ? +value : value;
        if (typeof value !== 'number') {
            throw new InvalidPipeArgumentError(pipe, value);
        }
        var minInt;
        var minFraction;
        var maxFraction;
        if (style !== NumberFormatStyle.Currency) {
            // rely on Intl default for currency
            minInt = 1;
            minFraction = 0;
            maxFraction = 3;
        }
        if (digits) {
            var parts = digits.match(_NUMBER_FORMAT_REGEXP);
            if (parts === null) {
                throw new Error(digits + " is not a valid digit info for number pipes");
            }
            if (isPresent(parts[1])) {
                minInt = NumberWrapper.parseIntAutoRadix(parts[1]);
            }
            if (isPresent(parts[3])) {
                minFraction = NumberWrapper.parseIntAutoRadix(parts[3]);
            }
            if (isPresent(parts[5])) {
                maxFraction = NumberWrapper.parseIntAutoRadix(parts[5]);
            }
        }
        return NumberFormatter.format(value, locale, style, {
            minimumIntegerDigits: minInt,
            minimumFractionDigits: minFraction,
            maximumFractionDigits: maxFraction,
            currency: currency,
            currencyAsSymbol: currencyAsSymbol,
        });
    }
    /**
     * @ngModule CommonModule
     * @whatItDoes Formats a number according to locale rules.
     * @howToUse `number_expression | number[:digitInfo]`
     *
     * Formats a number as text. Group sizing and separator and other locale-specific
     * configurations are based on the active locale.
     *
     * where `expression` is a number:
     *  - `digitInfo` is a `string` which has a following format: <br>
     *     <code>{minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}</code>
     *   - `minIntegerDigits` is the minimum number of integer digits to use. Defaults to `1`.
     *   - `minFractionDigits` is the minimum number of digits after fraction. Defaults to `0`.
     *   - `maxFractionDigits` is the maximum number of digits after fraction. Defaults to `3`.
     *
     * For more information on the acceptable range for each of these numbers and other
     * details see your native internationalization library.
     *
     * WARNING: this pipe uses the Internationalization API which is not yet available in all browsers
     * and may require a polyfill. See {@linkDocs guide/browser-support} for details.
     *
     * ### Example
     *
     * {@example common/pipes/ts/number_pipe.ts region='NumberPipe'}
     *
     * @stable
     */
    var DecimalPipe = (function () {
        function DecimalPipe(_locale) {
            this._locale = _locale;
        }
        DecimalPipe.prototype.transform = function (value, digits) {
            if (digits === void 0) { digits = null; }
            return formatNumber(DecimalPipe, this._locale, value, NumberFormatStyle.Decimal, digits);
        };
        DecimalPipe.decorators = [
            { type: _angular_core.Pipe, args: [{ name: 'number' },] },
        ];
        /** @nocollapse */
        DecimalPipe.ctorParameters = [
            { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_core.LOCALE_ID,] },] },
        ];
        return DecimalPipe;
    }());
    /**
     * @ngModule CommonModule
     * @whatItDoes Formats a number as a percentage according to locale rules.
     * @howToUse `number_expression | percent[:digitInfo]`
     *
     * @description
     *
     * Formats a number as percentage.
     *
     * - `digitInfo` See {@link DecimalPipe} for detailed description.
     *
     * WARNING: this pipe uses the Internationalization API which is not yet available in all browsers
     * and may require a polyfill. See {@linkDocs guide/browser-support} for details.
     *
     * ### Example
     *
     * {@example common/pipes/ts/number_pipe.ts region='PercentPipe'}
     *
     * @stable
     */
    var PercentPipe = (function () {
        function PercentPipe(_locale) {
            this._locale = _locale;
        }
        PercentPipe.prototype.transform = function (value, digits) {
            if (digits === void 0) { digits = null; }
            return formatNumber(PercentPipe, this._locale, value, NumberFormatStyle.Percent, digits);
        };
        PercentPipe.decorators = [
            { type: _angular_core.Pipe, args: [{ name: 'percent' },] },
        ];
        /** @nocollapse */
        PercentPipe.ctorParameters = [
            { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_core.LOCALE_ID,] },] },
        ];
        return PercentPipe;
    }());
    /**
     * @ngModule CommonModule
     * @whatItDoes Formats a number as currency using locale rules.
     * @howToUse `number_expression | currency[:currencyCode[:symbolDisplay[:digitInfo]]]`
     * @description
     *
     * Use `currency` to format a number as currency.
     *
     * - `currencyCode` is the [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code, such
     *    as `USD` for the US dollar and `EUR` for the euro.
     * - `symbolDisplay` is a boolean indicating whether to use the currency symbol or code.
     *   - `true`: use symbol (e.g. `$`).
     *   - `false`(default): use code (e.g. `USD`).
     * - `digitInfo` See {@link DecimalPipe} for detailed description.
     *
     * WARNING: this pipe uses the Internationalization API which is not yet available in all browsers
     * and may require a polyfill. See {@linkDocs guide/browser-support} for details.
     *
     * ### Example
     *
     * {@example common/pipes/ts/number_pipe.ts region='CurrencyPipe'}
     *
     * @stable
     */
    var CurrencyPipe = (function () {
        function CurrencyPipe(_locale) {
            this._locale = _locale;
        }
        CurrencyPipe.prototype.transform = function (value, currencyCode, symbolDisplay, digits) {
            if (currencyCode === void 0) { currencyCode = 'USD'; }
            if (symbolDisplay === void 0) { symbolDisplay = false; }
            if (digits === void 0) { digits = null; }
            return formatNumber(CurrencyPipe, this._locale, value, NumberFormatStyle.Currency, digits, currencyCode, symbolDisplay);
        };
        CurrencyPipe.decorators = [
            { type: _angular_core.Pipe, args: [{ name: 'currency' },] },
        ];
        /** @nocollapse */
        CurrencyPipe.ctorParameters = [
            { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_core.LOCALE_ID,] },] },
        ];
        return CurrencyPipe;
    }());

    /**
     * @ngModule CommonModule
     * @whatItDoes Creates a new List or String containing a subset (slice) of the elements.
     * @howToUse `array_or_string_expression | slice:start[:end]`
     * @description
     *
     * Where the input expression is a `List` or `String`, and:
     * - `start`: The starting index of the subset to return.
     *   - **a positive integer**: return the item at `start` index and all items after
     *     in the list or string expression.
     *   - **a negative integer**: return the item at `start` index from the end and all items after
     *     in the list or string expression.
     *   - **if positive and greater than the size of the expression**: return an empty list or string.
     *   - **if negative and greater than the size of the expression**: return entire list or string.
     * - `end`: The ending index of the subset to return.
     *   - **omitted**: return all items until the end.
     *   - **if positive**: return all items before `end` index of the list or string.
     *   - **if negative**: return all items before `end` index from the end of the list or string.
     *
     * All behavior is based on the expected behavior of the JavaScript API `Array.prototype.slice()`
     * and `String.prototype.slice()`.
     *
     * When operating on a [List], the returned list is always a copy even when all
     * the elements are being returned.
     *
     * When operating on a blank value, the pipe returns the blank value.
     *
     * ## List Example
     *
     * This `ngFor` example:
     *
     * {@example common/pipes/ts/slice_pipe.ts region='SlicePipe_list'}
     *
     * produces the following:
     *
     *     <li>b</li>
     *     <li>c</li>
     *
     * ## String Examples
     *
     * {@example common/pipes/ts/slice_pipe.ts region='SlicePipe_string'}
     *
     * @stable
     */
    var SlicePipe = (function () {
        function SlicePipe() {
        }
        SlicePipe.prototype.transform = function (value, start, end) {
            if (isBlank(value))
                return value;
            if (!this.supports(value)) {
                throw new InvalidPipeArgumentError(SlicePipe, value);
            }
            return value.slice(start, end);
        };
        SlicePipe.prototype.supports = function (obj) { return typeof obj === 'string' || Array.isArray(obj); };
        SlicePipe.decorators = [
            { type: _angular_core.Pipe, args: [{ name: 'slice', pure: false },] },
        ];
        /** @nocollapse */
        SlicePipe.ctorParameters = [];
        return SlicePipe;
    }());

    /**
     * @ngModule CommonModule
     * @whatItDoes Transforms string to uppercase.
     * @howToUse `expression | uppercase`
     * @description
     *
     * Converts value into lowercase string using `String.prototype.toUpperCase()`.
     *
     * ### Example
     *
     * {@example common/pipes/ts/lowerupper_pipe.ts region='LowerUpperPipe'}
     *
     * @stable
     */
    var UpperCasePipe = (function () {
        function UpperCasePipe() {
        }
        UpperCasePipe.prototype.transform = function (value) {
            if (isBlank(value))
                return value;
            if (typeof value !== 'string') {
                throw new InvalidPipeArgumentError(UpperCasePipe, value);
            }
            return value.toUpperCase();
        };
        UpperCasePipe.decorators = [
            { type: _angular_core.Pipe, args: [{ name: 'uppercase' },] },
        ];
        /** @nocollapse */
        UpperCasePipe.ctorParameters = [];
        return UpperCasePipe;
    }());

    /**
     * A collection of Angular pipes that are likely to be used in each and every application.
     */
    var COMMON_PIPES = [
        AsyncPipe,
        UpperCasePipe,
        LowerCasePipe,
        JsonPipe,
        SlicePipe,
        DecimalPipe,
        PercentPipe,
        CurrencyPipe,
        DatePipe,
        I18nPluralPipe,
        I18nSelectPipe,
    ];

    // Note: This does not contain the location providers,
    // as they need some platform specific implementations to work.
    /**
     * The module that includes all the basic Angular directives like {@link NgIf}, {@link NgFor}, ...
     *
     * @stable
     */
    var CommonModule = (function () {
        function CommonModule() {
        }
        CommonModule.decorators = [
            { type: _angular_core.NgModule, args: [{
                        declarations: [COMMON_DIRECTIVES, COMMON_PIPES],
                        exports: [COMMON_DIRECTIVES, COMMON_PIPES],
                        providers: [
                            { provide: NgLocalization, useClass: NgLocaleLocalization },
                        ],
                    },] },
        ];
        /** @nocollapse */
        CommonModule.ctorParameters = [];
        return CommonModule;
    }());

    exports.NgLocalization = NgLocalization;
    exports.CommonModule = CommonModule;
    exports.NgClass = NgClass;
    exports.NgFor = NgFor;
    exports.NgIf = NgIf;
    exports.NgPlural = NgPlural;
    exports.NgPluralCase = NgPluralCase;
    exports.NgStyle = NgStyle;
    exports.NgSwitch = NgSwitch;
    exports.NgSwitchCase = NgSwitchCase;
    exports.NgSwitchDefault = NgSwitchDefault;
    exports.NgTemplateOutlet = NgTemplateOutlet;
    exports.AsyncPipe = AsyncPipe;
    exports.DatePipe = DatePipe;
    exports.I18nPluralPipe = I18nPluralPipe;
    exports.I18nSelectPipe = I18nSelectPipe;
    exports.JsonPipe = JsonPipe;
    exports.LowerCasePipe = LowerCasePipe;
    exports.CurrencyPipe = CurrencyPipe;
    exports.DecimalPipe = DecimalPipe;
    exports.PercentPipe = PercentPipe;
    exports.SlicePipe = SlicePipe;
    exports.UpperCasePipe = UpperCasePipe;
    exports.PlatformLocation = PlatformLocation;
    exports.LocationStrategy = LocationStrategy;
    exports.APP_BASE_HREF = APP_BASE_HREF;
    exports.HashLocationStrategy = HashLocationStrategy;
    exports.PathLocationStrategy = PathLocationStrategy;
    exports.Location = Location;

}));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"@angular/core":6}],5:[function(require,module,exports){
/**
 * @license Angular v2.1.1
 * (c) 2010-2016 Google, Inc. https://angular.io/
 * License: MIT
 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core')) :
  typeof define === 'function' && define.amd ? define(['exports', '@angular/core'], factory) :
  (factory((global.ng = global.ng || {}, global.ng.compiler = global.ng.compiler || {}),global.ng.core));
}(this, function (exports,_angular_core) { 'use strict';

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * A segment of text within the template.
   */
  var TextAst = (function () {
      function TextAst(value, ngContentIndex, sourceSpan) {
          this.value = value;
          this.ngContentIndex = ngContentIndex;
          this.sourceSpan = sourceSpan;
      }
      TextAst.prototype.visit = function (visitor, context) { return visitor.visitText(this, context); };
      return TextAst;
  }());
  /**
   * A bound expression within the text of a template.
   */
  var BoundTextAst = (function () {
      function BoundTextAst(value, ngContentIndex, sourceSpan) {
          this.value = value;
          this.ngContentIndex = ngContentIndex;
          this.sourceSpan = sourceSpan;
      }
      BoundTextAst.prototype.visit = function (visitor, context) {
          return visitor.visitBoundText(this, context);
      };
      return BoundTextAst;
  }());
  /**
   * A plain attribute on an element.
   */
  var AttrAst = (function () {
      function AttrAst(name, value, sourceSpan) {
          this.name = name;
          this.value = value;
          this.sourceSpan = sourceSpan;
      }
      AttrAst.prototype.visit = function (visitor, context) { return visitor.visitAttr(this, context); };
      return AttrAst;
  }());
  /**
   * A binding for an element property (e.g. `[property]="expression"`) or an animation trigger (e.g.
   * `[@trigger]="stateExp"`)
   */
  var BoundElementPropertyAst = (function () {
      function BoundElementPropertyAst(name, type, securityContext, value, unit, sourceSpan) {
          this.name = name;
          this.type = type;
          this.securityContext = securityContext;
          this.value = value;
          this.unit = unit;
          this.sourceSpan = sourceSpan;
      }
      BoundElementPropertyAst.prototype.visit = function (visitor, context) {
          return visitor.visitElementProperty(this, context);
      };
      Object.defineProperty(BoundElementPropertyAst.prototype, "isAnimation", {
          get: function () { return this.type === exports.PropertyBindingType.Animation; },
          enumerable: true,
          configurable: true
      });
      return BoundElementPropertyAst;
  }());
  /**
   * A binding for an element event (e.g. `(event)="handler()"`) or an animation trigger event (e.g.
   * `(@trigger.phase)="callback($event)"`).
   */
  var BoundEventAst = (function () {
      function BoundEventAst(name, target, phase, handler, sourceSpan) {
          this.name = name;
          this.target = target;
          this.phase = phase;
          this.handler = handler;
          this.sourceSpan = sourceSpan;
      }
      BoundEventAst.prototype.visit = function (visitor, context) {
          return visitor.visitEvent(this, context);
      };
      Object.defineProperty(BoundEventAst.prototype, "fullName", {
          get: function () {
              if (this.target) {
                  return this.target + ":" + this.name;
              }
              else {
                  return this.name;
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(BoundEventAst.prototype, "isAnimation", {
          get: function () { return !!this.phase; },
          enumerable: true,
          configurable: true
      });
      return BoundEventAst;
  }());
  /**
   * A reference declaration on an element (e.g. `let someName="expression"`).
   */
  var ReferenceAst = (function () {
      function ReferenceAst(name, value, sourceSpan) {
          this.name = name;
          this.value = value;
          this.sourceSpan = sourceSpan;
      }
      ReferenceAst.prototype.visit = function (visitor, context) {
          return visitor.visitReference(this, context);
      };
      return ReferenceAst;
  }());
  /**
   * A variable declaration on a <template> (e.g. `var-someName="someLocalName"`).
   */
  var VariableAst = (function () {
      function VariableAst(name, value, sourceSpan) {
          this.name = name;
          this.value = value;
          this.sourceSpan = sourceSpan;
      }
      VariableAst.prototype.visit = function (visitor, context) {
          return visitor.visitVariable(this, context);
      };
      return VariableAst;
  }());
  /**
   * An element declaration in a template.
   */
  var ElementAst = (function () {
      function ElementAst(name, attrs, inputs, outputs, references, directives, providers, hasViewContainer, children, ngContentIndex, sourceSpan, endSourceSpan) {
          this.name = name;
          this.attrs = attrs;
          this.inputs = inputs;
          this.outputs = outputs;
          this.references = references;
          this.directives = directives;
          this.providers = providers;
          this.hasViewContainer = hasViewContainer;
          this.children = children;
          this.ngContentIndex = ngContentIndex;
          this.sourceSpan = sourceSpan;
          this.endSourceSpan = endSourceSpan;
      }
      ElementAst.prototype.visit = function (visitor, context) {
          return visitor.visitElement(this, context);
      };
      return ElementAst;
  }());
  /**
   * A `<template>` element included in an Angular template.
   */
  var EmbeddedTemplateAst = (function () {
      function EmbeddedTemplateAst(attrs, outputs, references, variables, directives, providers, hasViewContainer, children, ngContentIndex, sourceSpan) {
          this.attrs = attrs;
          this.outputs = outputs;
          this.references = references;
          this.variables = variables;
          this.directives = directives;
          this.providers = providers;
          this.hasViewContainer = hasViewContainer;
          this.children = children;
          this.ngContentIndex = ngContentIndex;
          this.sourceSpan = sourceSpan;
      }
      EmbeddedTemplateAst.prototype.visit = function (visitor, context) {
          return visitor.visitEmbeddedTemplate(this, context);
      };
      return EmbeddedTemplateAst;
  }());
  /**
   * A directive property with a bound value (e.g. `*ngIf="condition").
   */
  var BoundDirectivePropertyAst = (function () {
      function BoundDirectivePropertyAst(directiveName, templateName, value, sourceSpan) {
          this.directiveName = directiveName;
          this.templateName = templateName;
          this.value = value;
          this.sourceSpan = sourceSpan;
      }
      BoundDirectivePropertyAst.prototype.visit = function (visitor, context) {
          return visitor.visitDirectiveProperty(this, context);
      };
      return BoundDirectivePropertyAst;
  }());
  /**
   * A directive declared on an element.
   */
  var DirectiveAst = (function () {
      function DirectiveAst(directive, inputs, hostProperties, hostEvents, sourceSpan) {
          this.directive = directive;
          this.inputs = inputs;
          this.hostProperties = hostProperties;
          this.hostEvents = hostEvents;
          this.sourceSpan = sourceSpan;
      }
      DirectiveAst.prototype.visit = function (visitor, context) {
          return visitor.visitDirective(this, context);
      };
      return DirectiveAst;
  }());
  /**
   * A provider declared on an element
   */
  var ProviderAst = (function () {
      function ProviderAst(token, multiProvider, eager, providers, providerType, lifecycleHooks, sourceSpan) {
          this.token = token;
          this.multiProvider = multiProvider;
          this.eager = eager;
          this.providers = providers;
          this.providerType = providerType;
          this.lifecycleHooks = lifecycleHooks;
          this.sourceSpan = sourceSpan;
      }
      ProviderAst.prototype.visit = function (visitor, context) {
          // No visit method in the visitor for now...
          return null;
      };
      return ProviderAst;
  }());
  exports.ProviderAstType;
  (function (ProviderAstType) {
      ProviderAstType[ProviderAstType["PublicService"] = 0] = "PublicService";
      ProviderAstType[ProviderAstType["PrivateService"] = 1] = "PrivateService";
      ProviderAstType[ProviderAstType["Component"] = 2] = "Component";
      ProviderAstType[ProviderAstType["Directive"] = 3] = "Directive";
      ProviderAstType[ProviderAstType["Builtin"] = 4] = "Builtin";
  })(exports.ProviderAstType || (exports.ProviderAstType = {}));
  /**
   * Position where content is to be projected (instance of `<ng-content>` in a template).
   */
  var NgContentAst = (function () {
      function NgContentAst(index, ngContentIndex, sourceSpan) {
          this.index = index;
          this.ngContentIndex = ngContentIndex;
          this.sourceSpan = sourceSpan;
      }
      NgContentAst.prototype.visit = function (visitor, context) {
          return visitor.visitNgContent(this, context);
      };
      return NgContentAst;
  }());
  /**
   * Enumeration of types of property bindings.
   */
  exports.PropertyBindingType;
  (function (PropertyBindingType) {
      /**
       * A normal binding to a property (e.g. `[property]="expression"`).
       */
      PropertyBindingType[PropertyBindingType["Property"] = 0] = "Property";
      /**
       * A binding to an element attribute (e.g. `[attr.name]="expression"`).
       */
      PropertyBindingType[PropertyBindingType["Attribute"] = 1] = "Attribute";
      /**
       * A binding to a CSS class (e.g. `[class.name]="condition"`).
       */
      PropertyBindingType[PropertyBindingType["Class"] = 2] = "Class";
      /**
       * A binding to a style rule (e.g. `[style.rule]="expression"`).
       */
      PropertyBindingType[PropertyBindingType["Style"] = 3] = "Style";
      /**
       * A binding to an animation reference (e.g. `[animate.key]="expression"`).
       */
      PropertyBindingType[PropertyBindingType["Animation"] = 4] = "Animation";
  })(exports.PropertyBindingType || (exports.PropertyBindingType = {}));
  /**
   * Visit every node in a list of {@link TemplateAst}s with the given {@link TemplateAstVisitor}.
   */
  function templateVisitAll(visitor, asts, context) {
      if (context === void 0) { context = null; }
      var result = [];
      var visit = visitor.visit ?
          function (ast) { return visitor.visit(ast, context) || ast.visit(visitor, context); } :
          function (ast) { return ast.visit(visitor, context); };
      asts.forEach(function (ast) {
          var astResult = visit(ast);
          if (astResult) {
              result.push(astResult);
          }
      });
      return result;
  }

  function isPresent(obj) {
      return obj !== undefined && obj !== null;
  }
  function isBlank(obj) {
      return obj === undefined || obj === null;
  }
  var STRING_MAP_PROTO = Object.getPrototypeOf({});
  function isStrictStringMap(obj) {
      return typeof obj === 'object' && obj !== null && Object.getPrototypeOf(obj) === STRING_MAP_PROTO;
  }
  function stringify(token) {
      if (typeof token === 'string') {
          return token;
      }
      if (token === undefined || token === null) {
          return '' + token;
      }
      if (token.overriddenName) {
          return token.overriddenName;
      }
      if (token.name) {
          return token.name;
      }
      var res = token.toString();
      var newLineIndex = res.indexOf('\n');
      return newLineIndex === -1 ? res : res.substring(0, newLineIndex);
  }
  var NumberWrapper = (function () {
      function NumberWrapper() {
      }
      NumberWrapper.parseIntAutoRadix = function (text) {
          var result = parseInt(text);
          if (isNaN(result)) {
              throw new Error('Invalid integer literal when parsing ' + text);
          }
          return result;
      };
      NumberWrapper.parseInt = function (text, radix) {
          if (radix == 10) {
              if (/^(\-|\+)?[0-9]+$/.test(text)) {
                  return parseInt(text, radix);
              }
          }
          else if (radix == 16) {
              if (/^(\-|\+)?[0-9ABCDEFabcdef]+$/.test(text)) {
                  return parseInt(text, radix);
              }
          }
          else {
              var result = parseInt(text, radix);
              if (!isNaN(result)) {
                  return result;
              }
          }
          throw new Error('Invalid integer literal when parsing ' + text + ' in base ' + radix);
      };
      NumberWrapper.isNumeric = function (value) { return !isNaN(value - parseFloat(value)); };
      return NumberWrapper;
  }());
  function normalizeBlank(obj) {
      return isBlank(obj) ? null : obj;
  }
  function normalizeBool(obj) {
      return isBlank(obj) ? false : obj;
  }
  function isJsObject(o) {
      return o !== null && (typeof o === 'function' || typeof o === 'object');
  }
  function isPrimitive(obj) {
      return !isJsObject(obj);
  }
  function escapeRegExp(s) {
      return s.replace(/([.*+?^=!:${}()|[\]\/\\])/g, '\\$1');
  }

  // Safari doesn't implement MapIterator.next(), which is used is Traceur's polyfill of Array.from
  // TODO(mlaval): remove the work around once we have a working polyfill of Array.from
  var _arrayFromMap = (function () {
      try {
          if ((new Map()).values().next) {
              return function createArrayFromMap(m, getValues) {
                  return getValues ? Array.from(m.values()) : Array.from(m.keys());
              };
          }
      }
      catch (e) {
      }
      return function createArrayFromMapWithForeach(m, getValues) {
          var res = new Array(m.size), i = 0;
          m.forEach(function (v, k) {
              res[i] = getValues ? v : k;
              i++;
          });
          return res;
      };
  })();
  var MapWrapper = (function () {
      function MapWrapper() {
      }
      MapWrapper.createFromStringMap = function (stringMap) {
          var result = new Map();
          for (var prop in stringMap) {
              result.set(prop, stringMap[prop]);
          }
          return result;
      };
      MapWrapper.keys = function (m) { return _arrayFromMap(m, false); };
      MapWrapper.values = function (m) { return _arrayFromMap(m, true); };
      return MapWrapper;
  }());
  /**
   * Wraps Javascript Objects
   */
  var StringMapWrapper = (function () {
      function StringMapWrapper() {
      }
      StringMapWrapper.merge = function (m1, m2) {
          var m = {};
          for (var _i = 0, _a = Object.keys(m1); _i < _a.length; _i++) {
              var k = _a[_i];
              m[k] = m1[k];
          }
          for (var _b = 0, _c = Object.keys(m2); _b < _c.length; _b++) {
              var k = _c[_b];
              m[k] = m2[k];
          }
          return m;
      };
      StringMapWrapper.equals = function (m1, m2) {
          var k1 = Object.keys(m1);
          var k2 = Object.keys(m2);
          if (k1.length != k2.length) {
              return false;
          }
          for (var i = 0; i < k1.length; i++) {
              var key = k1[i];
              if (m1[key] !== m2[key]) {
                  return false;
              }
          }
          return true;
      };
      return StringMapWrapper;
  }());
  var ListWrapper = (function () {
      function ListWrapper() {
      }
      // JS has no way to express a statically fixed size list, but dart does so we
      // keep both methods.
      ListWrapper.createFixedSize = function (size) { return new Array(size); };
      ListWrapper.createGrowableSize = function (size) { return new Array(size); };
      ListWrapper.clone = function (array) { return array.slice(0); };
      ListWrapper.forEachWithIndex = function (array, fn) {
          for (var i = 0; i < array.length; i++) {
              fn(array[i], i);
          }
      };
      ListWrapper.first = function (array) {
          if (!array)
              return null;
          return array[0];
      };
      ListWrapper.last = function (array) {
          if (!array || array.length == 0)
              return null;
          return array[array.length - 1];
      };
      ListWrapper.indexOf = function (array, value, startIndex) {
          if (startIndex === void 0) { startIndex = 0; }
          return array.indexOf(value, startIndex);
      };
      ListWrapper.contains = function (list, el) { return list.indexOf(el) !== -1; };
      ListWrapper.reversed = function (array) {
          var a = ListWrapper.clone(array);
          return a.reverse();
      };
      ListWrapper.concat = function (a, b) { return a.concat(b); };
      ListWrapper.insert = function (list, index, value) { list.splice(index, 0, value); };
      ListWrapper.removeAt = function (list, index) {
          var res = list[index];
          list.splice(index, 1);
          return res;
      };
      ListWrapper.removeAll = function (list, items) {
          for (var i = 0; i < items.length; ++i) {
              var index = list.indexOf(items[i]);
              list.splice(index, 1);
          }
      };
      ListWrapper.remove = function (list, el) {
          var index = list.indexOf(el);
          if (index > -1) {
              list.splice(index, 1);
              return true;
          }
          return false;
      };
      ListWrapper.clear = function (list) { list.length = 0; };
      ListWrapper.isEmpty = function (list) { return list.length == 0; };
      ListWrapper.fill = function (list, value, start, end) {
          if (start === void 0) { start = 0; }
          if (end === void 0) { end = null; }
          list.fill(value, start, end === null ? list.length : end);
      };
      ListWrapper.equals = function (a, b) {
          if (a.length != b.length)
              return false;
          for (var i = 0; i < a.length; ++i) {
              if (a[i] !== b[i])
                  return false;
          }
          return true;
      };
      ListWrapper.slice = function (l, from, to) {
          if (from === void 0) { from = 0; }
          if (to === void 0) { to = null; }
          return l.slice(from, to === null ? undefined : to);
      };
      ListWrapper.splice = function (l, from, length) { return l.splice(from, length); };
      ListWrapper.sort = function (l, compareFn) {
          if (isPresent(compareFn)) {
              l.sort(compareFn);
          }
          else {
              l.sort();
          }
      };
      ListWrapper.toString = function (l) { return l.toString(); };
      ListWrapper.toJSON = function (l) { return JSON.stringify(l); };
      ListWrapper.maximum = function (list, predicate) {
          if (list.length == 0) {
              return null;
          }
          var solution = null;
          var maxValue = -Infinity;
          for (var index = 0; index < list.length; index++) {
              var candidate = list[index];
              if (isBlank(candidate)) {
                  continue;
              }
              var candidateValue = predicate(candidate);
              if (candidateValue > maxValue) {
                  solution = candidate;
                  maxValue = candidateValue;
              }
          }
          return solution;
      };
      ListWrapper.flatten = function (list) {
          var target = [];
          _flattenArray(list, target);
          return target;
      };
      ListWrapper.addAll = function (list, source) {
          for (var i = 0; i < source.length; i++) {
              list.push(source[i]);
          }
      };
      return ListWrapper;
  }());
  function _flattenArray(source, target) {
      if (isPresent(source)) {
          for (var i = 0; i < source.length; i++) {
              var item = source[i];
              if (Array.isArray(item)) {
                  _flattenArray(item, target);
              }
              else {
                  target.push(item);
              }
          }
      }
      return target;
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var TagContentType;
  (function (TagContentType) {
      TagContentType[TagContentType["RAW_TEXT"] = 0] = "RAW_TEXT";
      TagContentType[TagContentType["ESCAPABLE_RAW_TEXT"] = 1] = "ESCAPABLE_RAW_TEXT";
      TagContentType[TagContentType["PARSABLE_DATA"] = 2] = "PARSABLE_DATA";
  })(TagContentType || (TagContentType = {}));
  function splitNsName(elementName) {
      if (elementName[0] != ':') {
          return [null, elementName];
      }
      var colonIndex = elementName.indexOf(':', 1);
      if (colonIndex == -1) {
          throw new Error("Unsupported format \"" + elementName + "\" expecting \":namespace:name\"");
      }
      return [elementName.slice(1, colonIndex), elementName.slice(colonIndex + 1)];
  }
  function getNsPrefix(fullName) {
      return fullName === null ? null : splitNsName(fullName)[0];
  }
  function mergeNsAndName(prefix, localName) {
      return prefix ? ":" + prefix + ":" + localName : localName;
  }
  // see http://www.w3.org/TR/html51/syntax.html#named-character-references
  // see https://html.spec.whatwg.org/multipage/entities.json
  // This list is not exhaustive to keep the compiler footprint low.
  // The `&#123;` / `&#x1ab;` syntax should be used when the named character reference does not exist.
  var NAMED_ENTITIES = {
      'Aacute': '\u00C1',
      'aacute': '\u00E1',
      'Acirc': '\u00C2',
      'acirc': '\u00E2',
      'acute': '\u00B4',
      'AElig': '\u00C6',
      'aelig': '\u00E6',
      'Agrave': '\u00C0',
      'agrave': '\u00E0',
      'alefsym': '\u2135',
      'Alpha': '\u0391',
      'alpha': '\u03B1',
      'amp': '&',
      'and': '\u2227',
      'ang': '\u2220',
      'apos': '\u0027',
      'Aring': '\u00C5',
      'aring': '\u00E5',
      'asymp': '\u2248',
      'Atilde': '\u00C3',
      'atilde': '\u00E3',
      'Auml': '\u00C4',
      'auml': '\u00E4',
      'bdquo': '\u201E',
      'Beta': '\u0392',
      'beta': '\u03B2',
      'brvbar': '\u00A6',
      'bull': '\u2022',
      'cap': '\u2229',
      'Ccedil': '\u00C7',
      'ccedil': '\u00E7',
      'cedil': '\u00B8',
      'cent': '\u00A2',
      'Chi': '\u03A7',
      'chi': '\u03C7',
      'circ': '\u02C6',
      'clubs': '\u2663',
      'cong': '\u2245',
      'copy': '\u00A9',
      'crarr': '\u21B5',
      'cup': '\u222A',
      'curren': '\u00A4',
      'dagger': '\u2020',
      'Dagger': '\u2021',
      'darr': '\u2193',
      'dArr': '\u21D3',
      'deg': '\u00B0',
      'Delta': '\u0394',
      'delta': '\u03B4',
      'diams': '\u2666',
      'divide': '\u00F7',
      'Eacute': '\u00C9',
      'eacute': '\u00E9',
      'Ecirc': '\u00CA',
      'ecirc': '\u00EA',
      'Egrave': '\u00C8',
      'egrave': '\u00E8',
      'empty': '\u2205',
      'emsp': '\u2003',
      'ensp': '\u2002',
      'Epsilon': '\u0395',
      'epsilon': '\u03B5',
      'equiv': '\u2261',
      'Eta': '\u0397',
      'eta': '\u03B7',
      'ETH': '\u00D0',
      'eth': '\u00F0',
      'Euml': '\u00CB',
      'euml': '\u00EB',
      'euro': '\u20AC',
      'exist': '\u2203',
      'fnof': '\u0192',
      'forall': '\u2200',
      'frac12': '\u00BD',
      'frac14': '\u00BC',
      'frac34': '\u00BE',
      'frasl': '\u2044',
      'Gamma': '\u0393',
      'gamma': '\u03B3',
      'ge': '\u2265',
      'gt': '>',
      'harr': '\u2194',
      'hArr': '\u21D4',
      'hearts': '\u2665',
      'hellip': '\u2026',
      'Iacute': '\u00CD',
      'iacute': '\u00ED',
      'Icirc': '\u00CE',
      'icirc': '\u00EE',
      'iexcl': '\u00A1',
      'Igrave': '\u00CC',
      'igrave': '\u00EC',
      'image': '\u2111',
      'infin': '\u221E',
      'int': '\u222B',
      'Iota': '\u0399',
      'iota': '\u03B9',
      'iquest': '\u00BF',
      'isin': '\u2208',
      'Iuml': '\u00CF',
      'iuml': '\u00EF',
      'Kappa': '\u039A',
      'kappa': '\u03BA',
      'Lambda': '\u039B',
      'lambda': '\u03BB',
      'lang': '\u27E8',
      'laquo': '\u00AB',
      'larr': '\u2190',
      'lArr': '\u21D0',
      'lceil': '\u2308',
      'ldquo': '\u201C',
      'le': '\u2264',
      'lfloor': '\u230A',
      'lowast': '\u2217',
      'loz': '\u25CA',
      'lrm': '\u200E',
      'lsaquo': '\u2039',
      'lsquo': '\u2018',
      'lt': '<',
      'macr': '\u00AF',
      'mdash': '\u2014',
      'micro': '\u00B5',
      'middot': '\u00B7',
      'minus': '\u2212',
      'Mu': '\u039C',
      'mu': '\u03BC',
      'nabla': '\u2207',
      'nbsp': '\u00A0',
      'ndash': '\u2013',
      'ne': '\u2260',
      'ni': '\u220B',
      'not': '\u00AC',
      'notin': '\u2209',
      'nsub': '\u2284',
      'Ntilde': '\u00D1',
      'ntilde': '\u00F1',
      'Nu': '\u039D',
      'nu': '\u03BD',
      'Oacute': '\u00D3',
      'oacute': '\u00F3',
      'Ocirc': '\u00D4',
      'ocirc': '\u00F4',
      'OElig': '\u0152',
      'oelig': '\u0153',
      'Ograve': '\u00D2',
      'ograve': '\u00F2',
      'oline': '\u203E',
      'Omega': '\u03A9',
      'omega': '\u03C9',
      'Omicron': '\u039F',
      'omicron': '\u03BF',
      'oplus': '\u2295',
      'or': '\u2228',
      'ordf': '\u00AA',
      'ordm': '\u00BA',
      'Oslash': '\u00D8',
      'oslash': '\u00F8',
      'Otilde': '\u00D5',
      'otilde': '\u00F5',
      'otimes': '\u2297',
      'Ouml': '\u00D6',
      'ouml': '\u00F6',
      'para': '\u00B6',
      'permil': '\u2030',
      'perp': '\u22A5',
      'Phi': '\u03A6',
      'phi': '\u03C6',
      'Pi': '\u03A0',
      'pi': '\u03C0',
      'piv': '\u03D6',
      'plusmn': '\u00B1',
      'pound': '\u00A3',
      'prime': '\u2032',
      'Prime': '\u2033',
      'prod': '\u220F',
      'prop': '\u221D',
      'Psi': '\u03A8',
      'psi': '\u03C8',
      'quot': '\u0022',
      'radic': '\u221A',
      'rang': '\u27E9',
      'raquo': '\u00BB',
      'rarr': '\u2192',
      'rArr': '\u21D2',
      'rceil': '\u2309',
      'rdquo': '\u201D',
      'real': '\u211C',
      'reg': '\u00AE',
      'rfloor': '\u230B',
      'Rho': '\u03A1',
      'rho': '\u03C1',
      'rlm': '\u200F',
      'rsaquo': '\u203A',
      'rsquo': '\u2019',
      'sbquo': '\u201A',
      'Scaron': '\u0160',
      'scaron': '\u0161',
      'sdot': '\u22C5',
      'sect': '\u00A7',
      'shy': '\u00AD',
      'Sigma': '\u03A3',
      'sigma': '\u03C3',
      'sigmaf': '\u03C2',
      'sim': '\u223C',
      'spades': '\u2660',
      'sub': '\u2282',
      'sube': '\u2286',
      'sum': '\u2211',
      'sup': '\u2283',
      'sup1': '\u00B9',
      'sup2': '\u00B2',
      'sup3': '\u00B3',
      'supe': '\u2287',
      'szlig': '\u00DF',
      'Tau': '\u03A4',
      'tau': '\u03C4',
      'there4': '\u2234',
      'Theta': '\u0398',
      'theta': '\u03B8',
      'thetasym': '\u03D1',
      'thinsp': '\u2009',
      'THORN': '\u00DE',
      'thorn': '\u00FE',
      'tilde': '\u02DC',
      'times': '\u00D7',
      'trade': '\u2122',
      'Uacute': '\u00DA',
      'uacute': '\u00FA',
      'uarr': '\u2191',
      'uArr': '\u21D1',
      'Ucirc': '\u00DB',
      'ucirc': '\u00FB',
      'Ugrave': '\u00D9',
      'ugrave': '\u00F9',
      'uml': '\u00A8',
      'upsih': '\u03D2',
      'Upsilon': '\u03A5',
      'upsilon': '\u03C5',
      'Uuml': '\u00DC',
      'uuml': '\u00FC',
      'weierp': '\u2118',
      'Xi': '\u039E',
      'xi': '\u03BE',
      'Yacute': '\u00DD',
      'yacute': '\u00FD',
      'yen': '\u00A5',
      'yuml': '\u00FF',
      'Yuml': '\u0178',
      'Zeta': '\u0396',
      'zeta': '\u03B6',
      'zwj': '\u200D',
      'zwnj': '\u200C',
  };

  var HtmlTagDefinition = (function () {
      function HtmlTagDefinition(_a) {
          var _this = this;
          var _b = _a === void 0 ? {} : _a, closedByChildren = _b.closedByChildren, requiredParents = _b.requiredParents, implicitNamespacePrefix = _b.implicitNamespacePrefix, _c = _b.contentType, contentType = _c === void 0 ? TagContentType.PARSABLE_DATA : _c, _d = _b.closedByParent, closedByParent = _d === void 0 ? false : _d, _e = _b.isVoid, isVoid = _e === void 0 ? false : _e, _f = _b.ignoreFirstLf, ignoreFirstLf = _f === void 0 ? false : _f;
          this.closedByChildren = {};
          this.closedByParent = false;
          this.canSelfClose = false;
          if (closedByChildren && closedByChildren.length > 0) {
              closedByChildren.forEach(function (tagName) { return _this.closedByChildren[tagName] = true; });
          }
          this.isVoid = isVoid;
          this.closedByParent = closedByParent || isVoid;
          if (requiredParents && requiredParents.length > 0) {
              this.requiredParents = {};
              // The first parent is the list is automatically when none of the listed parents are present
              this.parentToAdd = requiredParents[0];
              requiredParents.forEach(function (tagName) { return _this.requiredParents[tagName] = true; });
          }
          this.implicitNamespacePrefix = implicitNamespacePrefix;
          this.contentType = contentType;
          this.ignoreFirstLf = ignoreFirstLf;
      }
      HtmlTagDefinition.prototype.requireExtraParent = function (currentParent) {
          if (!this.requiredParents) {
              return false;
          }
          if (!currentParent) {
              return true;
          }
          var lcParent = currentParent.toLowerCase();
          return this.requiredParents[lcParent] != true && lcParent != 'template';
      };
      HtmlTagDefinition.prototype.isClosedByChild = function (name) {
          return this.isVoid || name.toLowerCase() in this.closedByChildren;
      };
      return HtmlTagDefinition;
  }());
  // see http://www.w3.org/TR/html51/syntax.html#optional-tags
  // This implementation does not fully conform to the HTML5 spec.
  var TAG_DEFINITIONS = {
      'base': new HtmlTagDefinition({ isVoid: true }),
      'meta': new HtmlTagDefinition({ isVoid: true }),
      'area': new HtmlTagDefinition({ isVoid: true }),
      'embed': new HtmlTagDefinition({ isVoid: true }),
      'link': new HtmlTagDefinition({ isVoid: true }),
      'img': new HtmlTagDefinition({ isVoid: true }),
      'input': new HtmlTagDefinition({ isVoid: true }),
      'param': new HtmlTagDefinition({ isVoid: true }),
      'hr': new HtmlTagDefinition({ isVoid: true }),
      'br': new HtmlTagDefinition({ isVoid: true }),
      'source': new HtmlTagDefinition({ isVoid: true }),
      'track': new HtmlTagDefinition({ isVoid: true }),
      'wbr': new HtmlTagDefinition({ isVoid: true }),
      'p': new HtmlTagDefinition({
          closedByChildren: [
              'address', 'article', 'aside', 'blockquote', 'div', 'dl', 'fieldset', 'footer', 'form',
              'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'hgroup', 'hr',
              'main', 'nav', 'ol', 'p', 'pre', 'section', 'table', 'ul'
          ],
          closedByParent: true
      }),
      'thead': new HtmlTagDefinition({ closedByChildren: ['tbody', 'tfoot'] }),
      'tbody': new HtmlTagDefinition({ closedByChildren: ['tbody', 'tfoot'], closedByParent: true }),
      'tfoot': new HtmlTagDefinition({ closedByChildren: ['tbody'], closedByParent: true }),
      'tr': new HtmlTagDefinition({
          closedByChildren: ['tr'],
          requiredParents: ['tbody', 'tfoot', 'thead'],
          closedByParent: true
      }),
      'td': new HtmlTagDefinition({ closedByChildren: ['td', 'th'], closedByParent: true }),
      'th': new HtmlTagDefinition({ closedByChildren: ['td', 'th'], closedByParent: true }),
      'col': new HtmlTagDefinition({ requiredParents: ['colgroup'], isVoid: true }),
      'svg': new HtmlTagDefinition({ implicitNamespacePrefix: 'svg' }),
      'math': new HtmlTagDefinition({ implicitNamespacePrefix: 'math' }),
      'li': new HtmlTagDefinition({ closedByChildren: ['li'], closedByParent: true }),
      'dt': new HtmlTagDefinition({ closedByChildren: ['dt', 'dd'] }),
      'dd': new HtmlTagDefinition({ closedByChildren: ['dt', 'dd'], closedByParent: true }),
      'rb': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),
      'rt': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),
      'rtc': new HtmlTagDefinition({ closedByChildren: ['rb', 'rtc', 'rp'], closedByParent: true }),
      'rp': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),
      'optgroup': new HtmlTagDefinition({ closedByChildren: ['optgroup'], closedByParent: true }),
      'option': new HtmlTagDefinition({ closedByChildren: ['option', 'optgroup'], closedByParent: true }),
      'pre': new HtmlTagDefinition({ ignoreFirstLf: true }),
      'listing': new HtmlTagDefinition({ ignoreFirstLf: true }),
      'style': new HtmlTagDefinition({ contentType: TagContentType.RAW_TEXT }),
      'script': new HtmlTagDefinition({ contentType: TagContentType.RAW_TEXT }),
      'title': new HtmlTagDefinition({ contentType: TagContentType.ESCAPABLE_RAW_TEXT }),
      'textarea': new HtmlTagDefinition({ contentType: TagContentType.ESCAPABLE_RAW_TEXT, ignoreFirstLf: true }),
  };
  var _DEFAULT_TAG_DEFINITION = new HtmlTagDefinition();
  function getHtmlTagDefinition(tagName) {
      return TAG_DEFINITIONS[tagName.toLowerCase()] || _DEFAULT_TAG_DEFINITION;
  }

  var _SELECTOR_REGEXP = new RegExp('(\\:not\\()|' +
      '([-\\w]+)|' +
      '(?:\\.([-\\w]+))|' +
      '(?:\\[([-\\w*]+)(?:=([^\\]]*))?\\])|' +
      '(\\))|' +
      '(\\s*,\\s*)', // ","
  'g');
  /**
   * A css selector contains an element name,
   * css classes and attribute/value pairs with the purpose
   * of selecting subsets out of them.
   */
  var CssSelector = (function () {
      function CssSelector() {
          this.element = null;
          this.classNames = [];
          this.attrs = [];
          this.notSelectors = [];
      }
      CssSelector.parse = function (selector) {
          var results = [];
          var _addResult = function (res, cssSel) {
              if (cssSel.notSelectors.length > 0 && !cssSel.element && cssSel.classNames.length == 0 &&
                  cssSel.attrs.length == 0) {
                  cssSel.element = '*';
              }
              res.push(cssSel);
          };
          var cssSelector = new CssSelector();
          var match;
          var current = cssSelector;
          var inNot = false;
          _SELECTOR_REGEXP.lastIndex = 0;
          while (match = _SELECTOR_REGEXP.exec(selector)) {
              if (match[1]) {
                  if (inNot) {
                      throw new Error('Nesting :not is not allowed in a selector');
                  }
                  inNot = true;
                  current = new CssSelector();
                  cssSelector.notSelectors.push(current);
              }
              if (match[2]) {
                  current.setElement(match[2]);
              }
              if (match[3]) {
                  current.addClassName(match[3]);
              }
              if (match[4]) {
                  current.addAttribute(match[4], match[5]);
              }
              if (match[6]) {
                  inNot = false;
                  current = cssSelector;
              }
              if (match[7]) {
                  if (inNot) {
                      throw new Error('Multiple selectors in :not are not supported');
                  }
                  _addResult(results, cssSelector);
                  cssSelector = current = new CssSelector();
              }
          }
          _addResult(results, cssSelector);
          return results;
      };
      CssSelector.prototype.isElementSelector = function () {
          return this.hasElementSelector() && this.classNames.length == 0 && this.attrs.length == 0 &&
              this.notSelectors.length === 0;
      };
      CssSelector.prototype.hasElementSelector = function () { return !!this.element; };
      CssSelector.prototype.setElement = function (element) {
          if (element === void 0) { element = null; }
          this.element = element;
      };
      /** Gets a template string for an element that matches the selector. */
      CssSelector.prototype.getMatchingElementTemplate = function () {
          var tagName = this.element || 'div';
          var classAttr = this.classNames.length > 0 ? " class=\"" + this.classNames.join(' ') + "\"" : '';
          var attrs = '';
          for (var i = 0; i < this.attrs.length; i += 2) {
              var attrName = this.attrs[i];
              var attrValue = this.attrs[i + 1] !== '' ? "=\"" + this.attrs[i + 1] + "\"" : '';
              attrs += " " + attrName + attrValue;
          }
          return getHtmlTagDefinition(tagName).isVoid ? "<" + tagName + classAttr + attrs + "/>" :
              "<" + tagName + classAttr + attrs + "></" + tagName + ">";
      };
      CssSelector.prototype.addAttribute = function (name, value) {
          if (value === void 0) { value = ''; }
          this.attrs.push(name, value && value.toLowerCase() || '');
      };
      CssSelector.prototype.addClassName = function (name) { this.classNames.push(name.toLowerCase()); };
      CssSelector.prototype.toString = function () {
          var res = this.element || '';
          if (this.classNames) {
              this.classNames.forEach(function (klass) { return res += "." + klass; });
          }
          if (this.attrs) {
              for (var i = 0; i < this.attrs.length; i += 2) {
                  var name_1 = this.attrs[i];
                  var value = this.attrs[i + 1];
                  res += "[" + name_1 + (value ? '=' + value : '') + "]";
              }
          }
          this.notSelectors.forEach(function (notSelector) { return res += ":not(" + notSelector + ")"; });
          return res;
      };
      return CssSelector;
  }());
  /**
   * Reads a list of CssSelectors and allows to calculate which ones
   * are contained in a given CssSelector.
   */
  var SelectorMatcher = (function () {
      function SelectorMatcher() {
          this._elementMap = {};
          this._elementPartialMap = {};
          this._classMap = {};
          this._classPartialMap = {};
          this._attrValueMap = {};
          this._attrValuePartialMap = {};
          this._listContexts = [];
      }
      SelectorMatcher.createNotMatcher = function (notSelectors) {
          var notMatcher = new SelectorMatcher();
          notMatcher.addSelectables(notSelectors, null);
          return notMatcher;
      };
      SelectorMatcher.prototype.addSelectables = function (cssSelectors, callbackCtxt) {
          var listContext = null;
          if (cssSelectors.length > 1) {
              listContext = new SelectorListContext(cssSelectors);
              this._listContexts.push(listContext);
          }
          for (var i = 0; i < cssSelectors.length; i++) {
              this._addSelectable(cssSelectors[i], callbackCtxt, listContext);
          }
      };
      /**
       * Add an object that can be found later on by calling `match`.
       * @param cssSelector A css selector
       * @param callbackCtxt An opaque object that will be given to the callback of the `match` function
       */
      SelectorMatcher.prototype._addSelectable = function (cssSelector, callbackCtxt, listContext) {
          var matcher = this;
          var element = cssSelector.element;
          var classNames = cssSelector.classNames;
          var attrs = cssSelector.attrs;
          var selectable = new SelectorContext(cssSelector, callbackCtxt, listContext);
          if (element) {
              var isTerminal = attrs.length === 0 && classNames.length === 0;
              if (isTerminal) {
                  this._addTerminal(matcher._elementMap, element, selectable);
              }
              else {
                  matcher = this._addPartial(matcher._elementPartialMap, element);
              }
          }
          if (classNames) {
              for (var i = 0; i < classNames.length; i++) {
                  var isTerminal = attrs.length === 0 && i === classNames.length - 1;
                  var className = classNames[i];
                  if (isTerminal) {
                      this._addTerminal(matcher._classMap, className, selectable);
                  }
                  else {
                      matcher = this._addPartial(matcher._classPartialMap, className);
                  }
              }
          }
          if (attrs) {
              for (var i = 0; i < attrs.length; i += 2) {
                  var isTerminal = i === attrs.length - 2;
                  var name_2 = attrs[i];
                  var value = attrs[i + 1];
                  if (isTerminal) {
                      var terminalMap = matcher._attrValueMap;
                      var terminalValuesMap = terminalMap[name_2];
                      if (!terminalValuesMap) {
                          terminalValuesMap = {};
                          terminalMap[name_2] = terminalValuesMap;
                      }
                      this._addTerminal(terminalValuesMap, value, selectable);
                  }
                  else {
                      var partialMap = matcher._attrValuePartialMap;
                      var partialValuesMap = partialMap[name_2];
                      if (!partialValuesMap) {
                          partialValuesMap = {};
                          partialMap[name_2] = partialValuesMap;
                      }
                      matcher = this._addPartial(partialValuesMap, value);
                  }
              }
          }
      };
      SelectorMatcher.prototype._addTerminal = function (map, name, selectable) {
          var terminalList = map[name];
          if (!terminalList) {
              terminalList = [];
              map[name] = terminalList;
          }
          terminalList.push(selectable);
      };
      SelectorMatcher.prototype._addPartial = function (map, name) {
          var matcher = map[name];
          if (!matcher) {
              matcher = new SelectorMatcher();
              map[name] = matcher;
          }
          return matcher;
      };
      /**
       * Find the objects that have been added via `addSelectable`
       * whose css selector is contained in the given css selector.
       * @param cssSelector A css selector
       * @param matchedCallback This callback will be called with the object handed into `addSelectable`
       * @return boolean true if a match was found
      */
      SelectorMatcher.prototype.match = function (cssSelector, matchedCallback) {
          var result = false;
          var element = cssSelector.element;
          var classNames = cssSelector.classNames;
          var attrs = cssSelector.attrs;
          for (var i = 0; i < this._listContexts.length; i++) {
              this._listContexts[i].alreadyMatched = false;
          }
          result = this._matchTerminal(this._elementMap, element, cssSelector, matchedCallback) || result;
          result = this._matchPartial(this._elementPartialMap, element, cssSelector, matchedCallback) ||
              result;
          if (classNames) {
              for (var i = 0; i < classNames.length; i++) {
                  var className = classNames[i];
                  result =
                      this._matchTerminal(this._classMap, className, cssSelector, matchedCallback) || result;
                  result =
                      this._matchPartial(this._classPartialMap, className, cssSelector, matchedCallback) ||
                          result;
              }
          }
          if (attrs) {
              for (var i = 0; i < attrs.length; i += 2) {
                  var name_3 = attrs[i];
                  var value = attrs[i + 1];
                  var terminalValuesMap = this._attrValueMap[name_3];
                  if (value) {
                      result =
                          this._matchTerminal(terminalValuesMap, '', cssSelector, matchedCallback) || result;
                  }
                  result =
                      this._matchTerminal(terminalValuesMap, value, cssSelector, matchedCallback) || result;
                  var partialValuesMap = this._attrValuePartialMap[name_3];
                  if (value) {
                      result = this._matchPartial(partialValuesMap, '', cssSelector, matchedCallback) || result;
                  }
                  result =
                      this._matchPartial(partialValuesMap, value, cssSelector, matchedCallback) || result;
              }
          }
          return result;
      };
      /** @internal */
      SelectorMatcher.prototype._matchTerminal = function (map, name, cssSelector, matchedCallback) {
          if (!map || typeof name !== 'string') {
              return false;
          }
          var selectables = map[name];
          var starSelectables = map['*'];
          if (starSelectables) {
              selectables = selectables.concat(starSelectables);
          }
          if (!selectables) {
              return false;
          }
          var selectable;
          var result = false;
          for (var i = 0; i < selectables.length; i++) {
              selectable = selectables[i];
              result = selectable.finalize(cssSelector, matchedCallback) || result;
          }
          return result;
      };
      /** @internal */
      SelectorMatcher.prototype._matchPartial = function (map, name, cssSelector, matchedCallback) {
          if (!map || typeof name !== 'string') {
              return false;
          }
          var nestedSelector = map[name];
          if (!nestedSelector) {
              return false;
          }
          // TODO(perf): get rid of recursion and measure again
          // TODO(perf): don't pass the whole selector into the recursion,
          // but only the not processed parts
          return nestedSelector.match(cssSelector, matchedCallback);
      };
      return SelectorMatcher;
  }());
  var SelectorListContext = (function () {
      function SelectorListContext(selectors) {
          this.selectors = selectors;
          this.alreadyMatched = false;
      }
      return SelectorListContext;
  }());
  // Store context to pass back selector and context when a selector is matched
  var SelectorContext = (function () {
      function SelectorContext(selector, cbContext, listContext) {
          this.selector = selector;
          this.cbContext = cbContext;
          this.listContext = listContext;
          this.notSelectors = selector.notSelectors;
      }
      SelectorContext.prototype.finalize = function (cssSelector, callback) {
          var result = true;
          if (this.notSelectors.length > 0 && (!this.listContext || !this.listContext.alreadyMatched)) {
              var notMatcher = SelectorMatcher.createNotMatcher(this.notSelectors);
              result = !notMatcher.match(cssSelector, null);
          }
          if (result && callback && (!this.listContext || !this.listContext.alreadyMatched)) {
              if (this.listContext) {
                  this.listContext.alreadyMatched = true;
              }
              callback(this.selector, this.cbContext);
          }
          return result;
      };
      return SelectorContext;
  }());

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var __extends$2 = (this && this.__extends) || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  //// Types
  var TypeModifier;
  (function (TypeModifier) {
      TypeModifier[TypeModifier["Const"] = 0] = "Const";
  })(TypeModifier || (TypeModifier = {}));
  var Type$1 = (function () {
      function Type(modifiers) {
          if (modifiers === void 0) { modifiers = null; }
          this.modifiers = modifiers;
          if (!modifiers) {
              this.modifiers = [];
          }
      }
      Type.prototype.hasModifier = function (modifier) { return this.modifiers.indexOf(modifier) !== -1; };
      return Type;
  }());
  var BuiltinTypeName;
  (function (BuiltinTypeName) {
      BuiltinTypeName[BuiltinTypeName["Dynamic"] = 0] = "Dynamic";
      BuiltinTypeName[BuiltinTypeName["Bool"] = 1] = "Bool";
      BuiltinTypeName[BuiltinTypeName["String"] = 2] = "String";
      BuiltinTypeName[BuiltinTypeName["Int"] = 3] = "Int";
      BuiltinTypeName[BuiltinTypeName["Number"] = 4] = "Number";
      BuiltinTypeName[BuiltinTypeName["Function"] = 5] = "Function";
  })(BuiltinTypeName || (BuiltinTypeName = {}));
  var BuiltinType = (function (_super) {
      __extends$2(BuiltinType, _super);
      function BuiltinType(name, modifiers) {
          if (modifiers === void 0) { modifiers = null; }
          _super.call(this, modifiers);
          this.name = name;
      }
      BuiltinType.prototype.visitType = function (visitor, context) {
          return visitor.visitBuiltintType(this, context);
      };
      return BuiltinType;
  }(Type$1));
  var ExternalType = (function (_super) {
      __extends$2(ExternalType, _super);
      function ExternalType(value, typeParams, modifiers) {
          if (typeParams === void 0) { typeParams = null; }
          if (modifiers === void 0) { modifiers = null; }
          _super.call(this, modifiers);
          this.value = value;
          this.typeParams = typeParams;
      }
      ExternalType.prototype.visitType = function (visitor, context) {
          return visitor.visitExternalType(this, context);
      };
      return ExternalType;
  }(Type$1));
  var ArrayType = (function (_super) {
      __extends$2(ArrayType, _super);
      function ArrayType(of, modifiers) {
          if (modifiers === void 0) { modifiers = null; }
          _super.call(this, modifiers);
          this.of = of;
      }
      ArrayType.prototype.visitType = function (visitor, context) {
          return visitor.visitArrayType(this, context);
      };
      return ArrayType;
  }(Type$1));
  var MapType = (function (_super) {
      __extends$2(MapType, _super);
      function MapType(valueType, modifiers) {
          if (modifiers === void 0) { modifiers = null; }
          _super.call(this, modifiers);
          this.valueType = valueType;
      }
      MapType.prototype.visitType = function (visitor, context) { return visitor.visitMapType(this, context); };
      return MapType;
  }(Type$1));
  var DYNAMIC_TYPE = new BuiltinType(BuiltinTypeName.Dynamic);
  var BOOL_TYPE = new BuiltinType(BuiltinTypeName.Bool);
  var INT_TYPE = new BuiltinType(BuiltinTypeName.Int);
  var NUMBER_TYPE = new BuiltinType(BuiltinTypeName.Number);
  var STRING_TYPE = new BuiltinType(BuiltinTypeName.String);
  var FUNCTION_TYPE = new BuiltinType(BuiltinTypeName.Function);
  ///// Expressions
  var BinaryOperator;
  (function (BinaryOperator) {
      BinaryOperator[BinaryOperator["Equals"] = 0] = "Equals";
      BinaryOperator[BinaryOperator["NotEquals"] = 1] = "NotEquals";
      BinaryOperator[BinaryOperator["Identical"] = 2] = "Identical";
      BinaryOperator[BinaryOperator["NotIdentical"] = 3] = "NotIdentical";
      BinaryOperator[BinaryOperator["Minus"] = 4] = "Minus";
      BinaryOperator[BinaryOperator["Plus"] = 5] = "Plus";
      BinaryOperator[BinaryOperator["Divide"] = 6] = "Divide";
      BinaryOperator[BinaryOperator["Multiply"] = 7] = "Multiply";
      BinaryOperator[BinaryOperator["Modulo"] = 8] = "Modulo";
      BinaryOperator[BinaryOperator["And"] = 9] = "And";
      BinaryOperator[BinaryOperator["Or"] = 10] = "Or";
      BinaryOperator[BinaryOperator["Lower"] = 11] = "Lower";
      BinaryOperator[BinaryOperator["LowerEquals"] = 12] = "LowerEquals";
      BinaryOperator[BinaryOperator["Bigger"] = 13] = "Bigger";
      BinaryOperator[BinaryOperator["BiggerEquals"] = 14] = "BiggerEquals";
  })(BinaryOperator || (BinaryOperator = {}));
  var Expression = (function () {
      function Expression(type) {
          this.type = type;
      }
      Expression.prototype.prop = function (name) { return new ReadPropExpr(this, name); };
      Expression.prototype.key = function (index, type) {
          if (type === void 0) { type = null; }
          return new ReadKeyExpr(this, index, type);
      };
      Expression.prototype.callMethod = function (name, params) {
          return new InvokeMethodExpr(this, name, params);
      };
      Expression.prototype.callFn = function (params) { return new InvokeFunctionExpr(this, params); };
      Expression.prototype.instantiate = function (params, type) {
          if (type === void 0) { type = null; }
          return new InstantiateExpr(this, params, type);
      };
      Expression.prototype.conditional = function (trueCase, falseCase) {
          if (falseCase === void 0) { falseCase = null; }
          return new ConditionalExpr(this, trueCase, falseCase);
      };
      Expression.prototype.equals = function (rhs) {
          return new BinaryOperatorExpr(BinaryOperator.Equals, this, rhs);
      };
      Expression.prototype.notEquals = function (rhs) {
          return new BinaryOperatorExpr(BinaryOperator.NotEquals, this, rhs);
      };
      Expression.prototype.identical = function (rhs) {
          return new BinaryOperatorExpr(BinaryOperator.Identical, this, rhs);
      };
      Expression.prototype.notIdentical = function (rhs) {
          return new BinaryOperatorExpr(BinaryOperator.NotIdentical, this, rhs);
      };
      Expression.prototype.minus = function (rhs) {
          return new BinaryOperatorExpr(BinaryOperator.Minus, this, rhs);
      };
      Expression.prototype.plus = function (rhs) {
          return new BinaryOperatorExpr(BinaryOperator.Plus, this, rhs);
      };
      Expression.prototype.divide = function (rhs) {
          return new BinaryOperatorExpr(BinaryOperator.Divide, this, rhs);
      };
      Expression.prototype.multiply = function (rhs) {
          return new BinaryOperatorExpr(BinaryOperator.Multiply, this, rhs);
      };
      Expression.prototype.modulo = function (rhs) {
          return new BinaryOperatorExpr(BinaryOperator.Modulo, this, rhs);
      };
      Expression.prototype.and = function (rhs) {
          return new BinaryOperatorExpr(BinaryOperator.And, this, rhs);
      };
      Expression.prototype.or = function (rhs) {
          return new BinaryOperatorExpr(BinaryOperator.Or, this, rhs);
      };
      Expression.prototype.lower = function (rhs) {
          return new BinaryOperatorExpr(BinaryOperator.Lower, this, rhs);
      };
      Expression.prototype.lowerEquals = function (rhs) {
          return new BinaryOperatorExpr(BinaryOperator.LowerEquals, this, rhs);
      };
      Expression.prototype.bigger = function (rhs) {
          return new BinaryOperatorExpr(BinaryOperator.Bigger, this, rhs);
      };
      Expression.prototype.biggerEquals = function (rhs) {
          return new BinaryOperatorExpr(BinaryOperator.BiggerEquals, this, rhs);
      };
      Expression.prototype.isBlank = function () {
          // Note: We use equals by purpose here to compare to null and undefined in JS.
          return this.equals(NULL_EXPR);
      };
      Expression.prototype.cast = function (type) { return new CastExpr(this, type); };
      Expression.prototype.toStmt = function () { return new ExpressionStatement(this); };
      return Expression;
  }());
  var BuiltinVar;
  (function (BuiltinVar) {
      BuiltinVar[BuiltinVar["This"] = 0] = "This";
      BuiltinVar[BuiltinVar["Super"] = 1] = "Super";
      BuiltinVar[BuiltinVar["CatchError"] = 2] = "CatchError";
      BuiltinVar[BuiltinVar["CatchStack"] = 3] = "CatchStack";
  })(BuiltinVar || (BuiltinVar = {}));
  var ReadVarExpr = (function (_super) {
      __extends$2(ReadVarExpr, _super);
      function ReadVarExpr(name, type) {
          if (type === void 0) { type = null; }
          _super.call(this, type);
          if (typeof name === 'string') {
              this.name = name;
              this.builtin = null;
          }
          else {
              this.name = null;
              this.builtin = name;
          }
      }
      ReadVarExpr.prototype.visitExpression = function (visitor, context) {
          return visitor.visitReadVarExpr(this, context);
      };
      ReadVarExpr.prototype.set = function (value) { return new WriteVarExpr(this.name, value); };
      return ReadVarExpr;
  }(Expression));
  var WriteVarExpr = (function (_super) {
      __extends$2(WriteVarExpr, _super);
      function WriteVarExpr(name, value, type) {
          if (type === void 0) { type = null; }
          _super.call(this, type || value.type);
          this.name = name;
          this.value = value;
      }
      WriteVarExpr.prototype.visitExpression = function (visitor, context) {
          return visitor.visitWriteVarExpr(this, context);
      };
      WriteVarExpr.prototype.toDeclStmt = function (type, modifiers) {
          if (type === void 0) { type = null; }
          if (modifiers === void 0) { modifiers = null; }
          return new DeclareVarStmt(this.name, this.value, type, modifiers);
      };
      return WriteVarExpr;
  }(Expression));
  var WriteKeyExpr = (function (_super) {
      __extends$2(WriteKeyExpr, _super);
      function WriteKeyExpr(receiver, index, value, type) {
          if (type === void 0) { type = null; }
          _super.call(this, type || value.type);
          this.receiver = receiver;
          this.index = index;
          this.value = value;
      }
      WriteKeyExpr.prototype.visitExpression = function (visitor, context) {
          return visitor.visitWriteKeyExpr(this, context);
      };
      return WriteKeyExpr;
  }(Expression));
  var WritePropExpr = (function (_super) {
      __extends$2(WritePropExpr, _super);
      function WritePropExpr(receiver, name, value, type) {
          if (type === void 0) { type = null; }
          _super.call(this, type || value.type);
          this.receiver = receiver;
          this.name = name;
          this.value = value;
      }
      WritePropExpr.prototype.visitExpression = function (visitor, context) {
          return visitor.visitWritePropExpr(this, context);
      };
      return WritePropExpr;
  }(Expression));
  var BuiltinMethod;
  (function (BuiltinMethod) {
      BuiltinMethod[BuiltinMethod["ConcatArray"] = 0] = "ConcatArray";
      BuiltinMethod[BuiltinMethod["SubscribeObservable"] = 1] = "SubscribeObservable";
      BuiltinMethod[BuiltinMethod["Bind"] = 2] = "Bind";
  })(BuiltinMethod || (BuiltinMethod = {}));
  var InvokeMethodExpr = (function (_super) {
      __extends$2(InvokeMethodExpr, _super);
      function InvokeMethodExpr(receiver, method, args, type) {
          if (type === void 0) { type = null; }
          _super.call(this, type);
          this.receiver = receiver;
          this.args = args;
          if (typeof method === 'string') {
              this.name = method;
              this.builtin = null;
          }
          else {
              this.name = null;
              this.builtin = method;
          }
      }
      InvokeMethodExpr.prototype.visitExpression = function (visitor, context) {
          return visitor.visitInvokeMethodExpr(this, context);
      };
      return InvokeMethodExpr;
  }(Expression));
  var InvokeFunctionExpr = (function (_super) {
      __extends$2(InvokeFunctionExpr, _super);
      function InvokeFunctionExpr(fn, args, type) {
          if (type === void 0) { type = null; }
          _super.call(this, type);
          this.fn = fn;
          this.args = args;
      }
      InvokeFunctionExpr.prototype.visitExpression = function (visitor, context) {
          return visitor.visitInvokeFunctionExpr(this, context);
      };
      return InvokeFunctionExpr;
  }(Expression));
  var InstantiateExpr = (function (_super) {
      __extends$2(InstantiateExpr, _super);
      function InstantiateExpr(classExpr, args, type) {
          _super.call(this, type);
          this.classExpr = classExpr;
          this.args = args;
      }
      InstantiateExpr.prototype.visitExpression = function (visitor, context) {
          return visitor.visitInstantiateExpr(this, context);
      };
      return InstantiateExpr;
  }(Expression));
  var LiteralExpr = (function (_super) {
      __extends$2(LiteralExpr, _super);
      function LiteralExpr(value, type) {
          if (type === void 0) { type = null; }
          _super.call(this, type);
          this.value = value;
      }
      LiteralExpr.prototype.visitExpression = function (visitor, context) {
          return visitor.visitLiteralExpr(this, context);
      };
      return LiteralExpr;
  }(Expression));
  var ExternalExpr = (function (_super) {
      __extends$2(ExternalExpr, _super);
      function ExternalExpr(value, type, typeParams) {
          if (type === void 0) { type = null; }
          if (typeParams === void 0) { typeParams = null; }
          _super.call(this, type);
          this.value = value;
          this.typeParams = typeParams;
      }
      ExternalExpr.prototype.visitExpression = function (visitor, context) {
          return visitor.visitExternalExpr(this, context);
      };
      return ExternalExpr;
  }(Expression));
  var ConditionalExpr = (function (_super) {
      __extends$2(ConditionalExpr, _super);
      function ConditionalExpr(condition, trueCase, falseCase, type) {
          if (falseCase === void 0) { falseCase = null; }
          if (type === void 0) { type = null; }
          _super.call(this, type || trueCase.type);
          this.condition = condition;
          this.falseCase = falseCase;
          this.trueCase = trueCase;
      }
      ConditionalExpr.prototype.visitExpression = function (visitor, context) {
          return visitor.visitConditionalExpr(this, context);
      };
      return ConditionalExpr;
  }(Expression));
  var NotExpr = (function (_super) {
      __extends$2(NotExpr, _super);
      function NotExpr(condition) {
          _super.call(this, BOOL_TYPE);
          this.condition = condition;
      }
      NotExpr.prototype.visitExpression = function (visitor, context) {
          return visitor.visitNotExpr(this, context);
      };
      return NotExpr;
  }(Expression));
  var CastExpr = (function (_super) {
      __extends$2(CastExpr, _super);
      function CastExpr(value, type) {
          _super.call(this, type);
          this.value = value;
      }
      CastExpr.prototype.visitExpression = function (visitor, context) {
          return visitor.visitCastExpr(this, context);
      };
      return CastExpr;
  }(Expression));
  var FnParam = (function () {
      function FnParam(name, type) {
          if (type === void 0) { type = null; }
          this.name = name;
          this.type = type;
      }
      return FnParam;
  }());
  var FunctionExpr = (function (_super) {
      __extends$2(FunctionExpr, _super);
      function FunctionExpr(params, statements, type) {
          if (type === void 0) { type = null; }
          _super.call(this, type);
          this.params = params;
          this.statements = statements;
      }
      FunctionExpr.prototype.visitExpression = function (visitor, context) {
          return visitor.visitFunctionExpr(this, context);
      };
      FunctionExpr.prototype.toDeclStmt = function (name, modifiers) {
          if (modifiers === void 0) { modifiers = null; }
          return new DeclareFunctionStmt(name, this.params, this.statements, this.type, modifiers);
      };
      return FunctionExpr;
  }(Expression));
  var BinaryOperatorExpr = (function (_super) {
      __extends$2(BinaryOperatorExpr, _super);
      function BinaryOperatorExpr(operator, lhs, rhs, type) {
          if (type === void 0) { type = null; }
          _super.call(this, type || lhs.type);
          this.operator = operator;
          this.rhs = rhs;
          this.lhs = lhs;
      }
      BinaryOperatorExpr.prototype.visitExpression = function (visitor, context) {
          return visitor.visitBinaryOperatorExpr(this, context);
      };
      return BinaryOperatorExpr;
  }(Expression));
  var ReadPropExpr = (function (_super) {
      __extends$2(ReadPropExpr, _super);
      function ReadPropExpr(receiver, name, type) {
          if (type === void 0) { type = null; }
          _super.call(this, type);
          this.receiver = receiver;
          this.name = name;
      }
      ReadPropExpr.prototype.visitExpression = function (visitor, context) {
          return visitor.visitReadPropExpr(this, context);
      };
      ReadPropExpr.prototype.set = function (value) {
          return new WritePropExpr(this.receiver, this.name, value);
      };
      return ReadPropExpr;
  }(Expression));
  var ReadKeyExpr = (function (_super) {
      __extends$2(ReadKeyExpr, _super);
      function ReadKeyExpr(receiver, index, type) {
          if (type === void 0) { type = null; }
          _super.call(this, type);
          this.receiver = receiver;
          this.index = index;
      }
      ReadKeyExpr.prototype.visitExpression = function (visitor, context) {
          return visitor.visitReadKeyExpr(this, context);
      };
      ReadKeyExpr.prototype.set = function (value) {
          return new WriteKeyExpr(this.receiver, this.index, value);
      };
      return ReadKeyExpr;
  }(Expression));
  var LiteralArrayExpr = (function (_super) {
      __extends$2(LiteralArrayExpr, _super);
      function LiteralArrayExpr(entries, type) {
          if (type === void 0) { type = null; }
          _super.call(this, type);
          this.entries = entries;
      }
      LiteralArrayExpr.prototype.visitExpression = function (visitor, context) {
          return visitor.visitLiteralArrayExpr(this, context);
      };
      return LiteralArrayExpr;
  }(Expression));
  var LiteralMapExpr = (function (_super) {
      __extends$2(LiteralMapExpr, _super);
      function LiteralMapExpr(entries, type) {
          if (type === void 0) { type = null; }
          _super.call(this, type);
          this.entries = entries;
          this.valueType = null;
          if (isPresent(type)) {
              this.valueType = type.valueType;
          }
      }
      LiteralMapExpr.prototype.visitExpression = function (visitor, context) {
          return visitor.visitLiteralMapExpr(this, context);
      };
      return LiteralMapExpr;
  }(Expression));
  var THIS_EXPR = new ReadVarExpr(BuiltinVar.This);
  var SUPER_EXPR = new ReadVarExpr(BuiltinVar.Super);
  var CATCH_ERROR_VAR = new ReadVarExpr(BuiltinVar.CatchError);
  var CATCH_STACK_VAR = new ReadVarExpr(BuiltinVar.CatchStack);
  var NULL_EXPR = new LiteralExpr(null, null);
  //// Statements
  var StmtModifier;
  (function (StmtModifier) {
      StmtModifier[StmtModifier["Final"] = 0] = "Final";
      StmtModifier[StmtModifier["Private"] = 1] = "Private";
  })(StmtModifier || (StmtModifier = {}));
  var Statement = (function () {
      function Statement(modifiers) {
          if (modifiers === void 0) { modifiers = null; }
          this.modifiers = modifiers;
          if (!modifiers) {
              this.modifiers = [];
          }
      }
      Statement.prototype.hasModifier = function (modifier) { return this.modifiers.indexOf(modifier) !== -1; };
      return Statement;
  }());
  var DeclareVarStmt = (function (_super) {
      __extends$2(DeclareVarStmt, _super);
      function DeclareVarStmt(name, value, type, modifiers) {
          if (type === void 0) { type = null; }
          if (modifiers === void 0) { modifiers = null; }
          _super.call(this, modifiers);
          this.name = name;
          this.value = value;
          this.type = type || value.type;
      }
      DeclareVarStmt.prototype.visitStatement = function (visitor, context) {
          return visitor.visitDeclareVarStmt(this, context);
      };
      return DeclareVarStmt;
  }(Statement));
  var DeclareFunctionStmt = (function (_super) {
      __extends$2(DeclareFunctionStmt, _super);
      function DeclareFunctionStmt(name, params, statements, type, modifiers) {
          if (type === void 0) { type = null; }
          if (modifiers === void 0) { modifiers = null; }
          _super.call(this, modifiers);
          this.name = name;
          this.params = params;
          this.statements = statements;
          this.type = type;
      }
      DeclareFunctionStmt.prototype.visitStatement = function (visitor, context) {
          return visitor.visitDeclareFunctionStmt(this, context);
      };
      return DeclareFunctionStmt;
  }(Statement));
  var ExpressionStatement = (function (_super) {
      __extends$2(ExpressionStatement, _super);
      function ExpressionStatement(expr) {
          _super.call(this);
          this.expr = expr;
      }
      ExpressionStatement.prototype.visitStatement = function (visitor, context) {
          return visitor.visitExpressionStmt(this, context);
      };
      return ExpressionStatement;
  }(Statement));
  var ReturnStatement = (function (_super) {
      __extends$2(ReturnStatement, _super);
      function ReturnStatement(value) {
          _super.call(this);
          this.value = value;
      }
      ReturnStatement.prototype.visitStatement = function (visitor, context) {
          return visitor.visitReturnStmt(this, context);
      };
      return ReturnStatement;
  }(Statement));
  var AbstractClassPart = (function () {
      function AbstractClassPart(type, modifiers) {
          if (type === void 0) { type = null; }
          this.type = type;
          this.modifiers = modifiers;
          if (!modifiers) {
              this.modifiers = [];
          }
      }
      AbstractClassPart.prototype.hasModifier = function (modifier) { return this.modifiers.indexOf(modifier) !== -1; };
      return AbstractClassPart;
  }());
  var ClassField = (function (_super) {
      __extends$2(ClassField, _super);
      function ClassField(name, type, modifiers) {
          if (type === void 0) { type = null; }
          if (modifiers === void 0) { modifiers = null; }
          _super.call(this, type, modifiers);
          this.name = name;
      }
      return ClassField;
  }(AbstractClassPart));
  var ClassMethod = (function (_super) {
      __extends$2(ClassMethod, _super);
      function ClassMethod(name, params, body, type, modifiers) {
          if (type === void 0) { type = null; }
          if (modifiers === void 0) { modifiers = null; }
          _super.call(this, type, modifiers);
          this.name = name;
          this.params = params;
          this.body = body;
      }
      return ClassMethod;
  }(AbstractClassPart));
  var ClassGetter = (function (_super) {
      __extends$2(ClassGetter, _super);
      function ClassGetter(name, body, type, modifiers) {
          if (type === void 0) { type = null; }
          if (modifiers === void 0) { modifiers = null; }
          _super.call(this, type, modifiers);
          this.name = name;
          this.body = body;
      }
      return ClassGetter;
  }(AbstractClassPart));
  var ClassStmt = (function (_super) {
      __extends$2(ClassStmt, _super);
      function ClassStmt(name, parent, fields, getters, constructorMethod, methods, modifiers) {
          if (modifiers === void 0) { modifiers = null; }
          _super.call(this, modifiers);
          this.name = name;
          this.parent = parent;
          this.fields = fields;
          this.getters = getters;
          this.constructorMethod = constructorMethod;
          this.methods = methods;
      }
      ClassStmt.prototype.visitStatement = function (visitor, context) {
          return visitor.visitDeclareClassStmt(this, context);
      };
      return ClassStmt;
  }(Statement));
  var IfStmt = (function (_super) {
      __extends$2(IfStmt, _super);
      function IfStmt(condition, trueCase, falseCase) {
          if (falseCase === void 0) { falseCase = []; }
          _super.call(this);
          this.condition = condition;
          this.trueCase = trueCase;
          this.falseCase = falseCase;
      }
      IfStmt.prototype.visitStatement = function (visitor, context) {
          return visitor.visitIfStmt(this, context);
      };
      return IfStmt;
  }(Statement));
  var CommentStmt = (function (_super) {
      __extends$2(CommentStmt, _super);
      function CommentStmt(comment) {
          _super.call(this);
          this.comment = comment;
      }
      CommentStmt.prototype.visitStatement = function (visitor, context) {
          return visitor.visitCommentStmt(this, context);
      };
      return CommentStmt;
  }(Statement));
  var TryCatchStmt = (function (_super) {
      __extends$2(TryCatchStmt, _super);
      function TryCatchStmt(bodyStmts, catchStmts) {
          _super.call(this);
          this.bodyStmts = bodyStmts;
          this.catchStmts = catchStmts;
      }
      TryCatchStmt.prototype.visitStatement = function (visitor, context) {
          return visitor.visitTryCatchStmt(this, context);
      };
      return TryCatchStmt;
  }(Statement));
  var ThrowStmt = (function (_super) {
      __extends$2(ThrowStmt, _super);
      function ThrowStmt(error) {
          _super.call(this);
          this.error = error;
      }
      ThrowStmt.prototype.visitStatement = function (visitor, context) {
          return visitor.visitThrowStmt(this, context);
      };
      return ThrowStmt;
  }(Statement));
  var ExpressionTransformer = (function () {
      function ExpressionTransformer() {
      }
      ExpressionTransformer.prototype.visitReadVarExpr = function (ast, context) { return ast; };
      ExpressionTransformer.prototype.visitWriteVarExpr = function (expr, context) {
          return new WriteVarExpr(expr.name, expr.value.visitExpression(this, context));
      };
      ExpressionTransformer.prototype.visitWriteKeyExpr = function (expr, context) {
          return new WriteKeyExpr(expr.receiver.visitExpression(this, context), expr.index.visitExpression(this, context), expr.value.visitExpression(this, context));
      };
      ExpressionTransformer.prototype.visitWritePropExpr = function (expr, context) {
          return new WritePropExpr(expr.receiver.visitExpression(this, context), expr.name, expr.value.visitExpression(this, context));
      };
      ExpressionTransformer.prototype.visitInvokeMethodExpr = function (ast, context) {
          var method = ast.builtin || ast.name;
          return new InvokeMethodExpr(ast.receiver.visitExpression(this, context), method, this.visitAllExpressions(ast.args, context), ast.type);
      };
      ExpressionTransformer.prototype.visitInvokeFunctionExpr = function (ast, context) {
          return new InvokeFunctionExpr(ast.fn.visitExpression(this, context), this.visitAllExpressions(ast.args, context), ast.type);
      };
      ExpressionTransformer.prototype.visitInstantiateExpr = function (ast, context) {
          return new InstantiateExpr(ast.classExpr.visitExpression(this, context), this.visitAllExpressions(ast.args, context), ast.type);
      };
      ExpressionTransformer.prototype.visitLiteralExpr = function (ast, context) { return ast; };
      ExpressionTransformer.prototype.visitExternalExpr = function (ast, context) { return ast; };
      ExpressionTransformer.prototype.visitConditionalExpr = function (ast, context) {
          return new ConditionalExpr(ast.condition.visitExpression(this, context), ast.trueCase.visitExpression(this, context), ast.falseCase.visitExpression(this, context));
      };
      ExpressionTransformer.prototype.visitNotExpr = function (ast, context) {
          return new NotExpr(ast.condition.visitExpression(this, context));
      };
      ExpressionTransformer.prototype.visitCastExpr = function (ast, context) {
          return new CastExpr(ast.value.visitExpression(this, context), context);
      };
      ExpressionTransformer.prototype.visitFunctionExpr = function (ast, context) {
          // Don't descend into nested functions
          return ast;
      };
      ExpressionTransformer.prototype.visitBinaryOperatorExpr = function (ast, context) {
          return new BinaryOperatorExpr(ast.operator, ast.lhs.visitExpression(this, context), ast.rhs.visitExpression(this, context), ast.type);
      };
      ExpressionTransformer.prototype.visitReadPropExpr = function (ast, context) {
          return new ReadPropExpr(ast.receiver.visitExpression(this, context), ast.name, ast.type);
      };
      ExpressionTransformer.prototype.visitReadKeyExpr = function (ast, context) {
          return new ReadKeyExpr(ast.receiver.visitExpression(this, context), ast.index.visitExpression(this, context), ast.type);
      };
      ExpressionTransformer.prototype.visitLiteralArrayExpr = function (ast, context) {
          return new LiteralArrayExpr(this.visitAllExpressions(ast.entries, context));
      };
      ExpressionTransformer.prototype.visitLiteralMapExpr = function (ast, context) {
          var _this = this;
          var entries = ast.entries.map(function (entry) { return [entry[0], entry[1].visitExpression(_this, context),]; });
          return new LiteralMapExpr(entries);
      };
      ExpressionTransformer.prototype.visitAllExpressions = function (exprs, context) {
          var _this = this;
          return exprs.map(function (expr) { return expr.visitExpression(_this, context); });
      };
      ExpressionTransformer.prototype.visitDeclareVarStmt = function (stmt, context) {
          return new DeclareVarStmt(stmt.name, stmt.value.visitExpression(this, context), stmt.type, stmt.modifiers);
      };
      ExpressionTransformer.prototype.visitDeclareFunctionStmt = function (stmt, context) {
          // Don't descend into nested functions
          return stmt;
      };
      ExpressionTransformer.prototype.visitExpressionStmt = function (stmt, context) {
          return new ExpressionStatement(stmt.expr.visitExpression(this, context));
      };
      ExpressionTransformer.prototype.visitReturnStmt = function (stmt, context) {
          return new ReturnStatement(stmt.value.visitExpression(this, context));
      };
      ExpressionTransformer.prototype.visitDeclareClassStmt = function (stmt, context) {
          // Don't descend into nested functions
          return stmt;
      };
      ExpressionTransformer.prototype.visitIfStmt = function (stmt, context) {
          return new IfStmt(stmt.condition.visitExpression(this, context), this.visitAllStatements(stmt.trueCase, context), this.visitAllStatements(stmt.falseCase, context));
      };
      ExpressionTransformer.prototype.visitTryCatchStmt = function (stmt, context) {
          return new TryCatchStmt(this.visitAllStatements(stmt.bodyStmts, context), this.visitAllStatements(stmt.catchStmts, context));
      };
      ExpressionTransformer.prototype.visitThrowStmt = function (stmt, context) {
          return new ThrowStmt(stmt.error.visitExpression(this, context));
      };
      ExpressionTransformer.prototype.visitCommentStmt = function (stmt, context) { return stmt; };
      ExpressionTransformer.prototype.visitAllStatements = function (stmts, context) {
          var _this = this;
          return stmts.map(function (stmt) { return stmt.visitStatement(_this, context); });
      };
      return ExpressionTransformer;
  }());
  var RecursiveExpressionVisitor = (function () {
      function RecursiveExpressionVisitor() {
      }
      RecursiveExpressionVisitor.prototype.visitReadVarExpr = function (ast, context) { return ast; };
      RecursiveExpressionVisitor.prototype.visitWriteVarExpr = function (expr, context) {
          expr.value.visitExpression(this, context);
          return expr;
      };
      RecursiveExpressionVisitor.prototype.visitWriteKeyExpr = function (expr, context) {
          expr.receiver.visitExpression(this, context);
          expr.index.visitExpression(this, context);
          expr.value.visitExpression(this, context);
          return expr;
      };
      RecursiveExpressionVisitor.prototype.visitWritePropExpr = function (expr, context) {
          expr.receiver.visitExpression(this, context);
          expr.value.visitExpression(this, context);
          return expr;
      };
      RecursiveExpressionVisitor.prototype.visitInvokeMethodExpr = function (ast, context) {
          ast.receiver.visitExpression(this, context);
          this.visitAllExpressions(ast.args, context);
          return ast;
      };
      RecursiveExpressionVisitor.prototype.visitInvokeFunctionExpr = function (ast, context) {
          ast.fn.visitExpression(this, context);
          this.visitAllExpressions(ast.args, context);
          return ast;
      };
      RecursiveExpressionVisitor.prototype.visitInstantiateExpr = function (ast, context) {
          ast.classExpr.visitExpression(this, context);
          this.visitAllExpressions(ast.args, context);
          return ast;
      };
      RecursiveExpressionVisitor.prototype.visitLiteralExpr = function (ast, context) { return ast; };
      RecursiveExpressionVisitor.prototype.visitExternalExpr = function (ast, context) { return ast; };
      RecursiveExpressionVisitor.prototype.visitConditionalExpr = function (ast, context) {
          ast.condition.visitExpression(this, context);
          ast.trueCase.visitExpression(this, context);
          ast.falseCase.visitExpression(this, context);
          return ast;
      };
      RecursiveExpressionVisitor.prototype.visitNotExpr = function (ast, context) {
          ast.condition.visitExpression(this, context);
          return ast;
      };
      RecursiveExpressionVisitor.prototype.visitCastExpr = function (ast, context) {
          ast.value.visitExpression(this, context);
          return ast;
      };
      RecursiveExpressionVisitor.prototype.visitFunctionExpr = function (ast, context) { return ast; };
      RecursiveExpressionVisitor.prototype.visitBinaryOperatorExpr = function (ast, context) {
          ast.lhs.visitExpression(this, context);
          ast.rhs.visitExpression(this, context);
          return ast;
      };
      RecursiveExpressionVisitor.prototype.visitReadPropExpr = function (ast, context) {
          ast.receiver.visitExpression(this, context);
          return ast;
      };
      RecursiveExpressionVisitor.prototype.visitReadKeyExpr = function (ast, context) {
          ast.receiver.visitExpression(this, context);
          ast.index.visitExpression(this, context);
          return ast;
      };
      RecursiveExpressionVisitor.prototype.visitLiteralArrayExpr = function (ast, context) {
          this.visitAllExpressions(ast.entries, context);
          return ast;
      };
      RecursiveExpressionVisitor.prototype.visitLiteralMapExpr = function (ast, context) {
          var _this = this;
          ast.entries.forEach(function (entry) { return entry[1].visitExpression(_this, context); });
          return ast;
      };
      RecursiveExpressionVisitor.prototype.visitAllExpressions = function (exprs, context) {
          var _this = this;
          exprs.forEach(function (expr) { return expr.visitExpression(_this, context); });
      };
      RecursiveExpressionVisitor.prototype.visitDeclareVarStmt = function (stmt, context) {
          stmt.value.visitExpression(this, context);
          return stmt;
      };
      RecursiveExpressionVisitor.prototype.visitDeclareFunctionStmt = function (stmt, context) {
          // Don't descend into nested functions
          return stmt;
      };
      RecursiveExpressionVisitor.prototype.visitExpressionStmt = function (stmt, context) {
          stmt.expr.visitExpression(this, context);
          return stmt;
      };
      RecursiveExpressionVisitor.prototype.visitReturnStmt = function (stmt, context) {
          stmt.value.visitExpression(this, context);
          return stmt;
      };
      RecursiveExpressionVisitor.prototype.visitDeclareClassStmt = function (stmt, context) {
          // Don't descend into nested functions
          return stmt;
      };
      RecursiveExpressionVisitor.prototype.visitIfStmt = function (stmt, context) {
          stmt.condition.visitExpression(this, context);
          this.visitAllStatements(stmt.trueCase, context);
          this.visitAllStatements(stmt.falseCase, context);
          return stmt;
      };
      RecursiveExpressionVisitor.prototype.visitTryCatchStmt = function (stmt, context) {
          this.visitAllStatements(stmt.bodyStmts, context);
          this.visitAllStatements(stmt.catchStmts, context);
          return stmt;
      };
      RecursiveExpressionVisitor.prototype.visitThrowStmt = function (stmt, context) {
          stmt.error.visitExpression(this, context);
          return stmt;
      };
      RecursiveExpressionVisitor.prototype.visitCommentStmt = function (stmt, context) { return stmt; };
      RecursiveExpressionVisitor.prototype.visitAllStatements = function (stmts, context) {
          var _this = this;
          stmts.forEach(function (stmt) { return stmt.visitStatement(_this, context); });
      };
      return RecursiveExpressionVisitor;
  }());
  function replaceVarInExpression(varName, newValue, expression) {
      var transformer = new _ReplaceVariableTransformer(varName, newValue);
      return expression.visitExpression(transformer, null);
  }
  var _ReplaceVariableTransformer = (function (_super) {
      __extends$2(_ReplaceVariableTransformer, _super);
      function _ReplaceVariableTransformer(_varName, _newValue) {
          _super.call(this);
          this._varName = _varName;
          this._newValue = _newValue;
      }
      _ReplaceVariableTransformer.prototype.visitReadVarExpr = function (ast, context) {
          return ast.name == this._varName ? this._newValue : ast;
      };
      return _ReplaceVariableTransformer;
  }(ExpressionTransformer));
  function findReadVarNames(stmts) {
      var finder = new _VariableFinder();
      finder.visitAllStatements(stmts, null);
      return finder.varNames;
  }
  var _VariableFinder = (function (_super) {
      __extends$2(_VariableFinder, _super);
      function _VariableFinder() {
          _super.apply(this, arguments);
          this.varNames = new Set();
      }
      _VariableFinder.prototype.visitReadVarExpr = function (ast, context) {
          this.varNames.add(ast.name);
          return null;
      };
      return _VariableFinder;
  }(RecursiveExpressionVisitor));
  function variable(name, type) {
      if (type === void 0) { type = null; }
      return new ReadVarExpr(name, type);
  }
  function importExpr(id, typeParams) {
      if (typeParams === void 0) { typeParams = null; }
      return new ExternalExpr(id, null, typeParams);
  }
  function importType(id, typeParams, typeModifiers) {
      if (typeParams === void 0) { typeParams = null; }
      if (typeModifiers === void 0) { typeModifiers = null; }
      return isPresent(id) ? new ExternalType(id, typeParams, typeModifiers) : null;
  }
  function literalArr(values, type) {
      if (type === void 0) { type = null; }
      return new LiteralArrayExpr(values, type);
  }
  function literalMap(values, type) {
      if (type === void 0) { type = null; }
      return new LiteralMapExpr(values, type);
  }
  function not(expr) {
      return new NotExpr(expr);
  }
  function fn(params, body, type) {
      if (type === void 0) { type = null; }
      return new FunctionExpr(params, body, type);
  }
  function literal(value, type) {
      if (type === void 0) { type = null; }
      return new LiteralExpr(value, type);
  }

  var MODULE_SUFFIX = '';
  function splitAtColon(input, defaultValues) {
      return _splitAt(input, ':', defaultValues);
  }
  function splitAtPeriod(input, defaultValues) {
      return _splitAt(input, '.', defaultValues);
  }
  function _splitAt(input, character, defaultValues) {
      var characterIndex = input.indexOf(character);
      if (characterIndex == -1)
          return defaultValues;
      return [input.slice(0, characterIndex).trim(), input.slice(characterIndex + 1).trim()];
  }
  function sanitizeIdentifier(name) {
      return name.replace(/\W/g, '_');
  }
  function visitValue(value, visitor, context) {
      if (Array.isArray(value)) {
          return visitor.visitArray(value, context);
      }
      if (isStrictStringMap(value)) {
          return visitor.visitStringMap(value, context);
      }
      if (isBlank(value) || isPrimitive(value)) {
          return visitor.visitPrimitive(value, context);
      }
      return visitor.visitOther(value, context);
  }
  var ValueTransformer = (function () {
      function ValueTransformer() {
      }
      ValueTransformer.prototype.visitArray = function (arr, context) {
          var _this = this;
          return arr.map(function (value) { return visitValue(value, _this, context); });
      };
      ValueTransformer.prototype.visitStringMap = function (map, context) {
          var _this = this;
          var result = {};
          Object.keys(map).forEach(function (key) { result[key] = visitValue(map[key], _this, context); });
          return result;
      };
      ValueTransformer.prototype.visitPrimitive = function (value, context) { return value; };
      ValueTransformer.prototype.visitOther = function (value, context) { return value; };
      return ValueTransformer;
  }());
  function assetUrl(pkg, path, type) {
      if (path === void 0) { path = null; }
      if (type === void 0) { type = 'src'; }
      if (path == null) {
          return "asset:@angular/lib/" + pkg + "/index";
      }
      else {
          return "asset:@angular/lib/" + pkg + "/src/" + path;
      }
  }
  function createDiTokenExpression(token) {
      if (isPresent(token.value)) {
          return literal(token.value);
      }
      else if (token.identifierIsInstance) {
          return importExpr(token.identifier)
              .instantiate([], importType(token.identifier, [], [TypeModifier.Const]));
      }
      else {
          return importExpr(token.identifier);
      }
  }
  var SyncAsyncResult = (function () {
      function SyncAsyncResult(syncResult, asyncResult) {
          if (asyncResult === void 0) { asyncResult = null; }
          this.syncResult = syncResult;
          this.asyncResult = asyncResult;
          if (!asyncResult) {
              this.asyncResult = Promise.resolve(syncResult);
          }
      }
      return SyncAsyncResult;
  }());

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var __extends$1 = (this && this.__extends) || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  function unimplemented() {
      throw new Error('unimplemented');
  }
  // group 0: "[prop] or (event) or @trigger"
  // group 1: "prop" from "[prop]"
  // group 2: "event" from "(event)"
  // group 3: "@trigger" from "@trigger"
  var HOST_REG_EXP = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))|(\@[-\w]+)$/;
  var CompileMetadataWithIdentifier = (function () {
      function CompileMetadataWithIdentifier() {
      }
      Object.defineProperty(CompileMetadataWithIdentifier.prototype, "identifier", {
          get: function () { return unimplemented(); },
          enumerable: true,
          configurable: true
      });
      return CompileMetadataWithIdentifier;
  }());
  var CompileAnimationEntryMetadata = (function () {
      function CompileAnimationEntryMetadata(name, definitions) {
          if (name === void 0) { name = null; }
          if (definitions === void 0) { definitions = null; }
          this.name = name;
          this.definitions = definitions;
      }
      return CompileAnimationEntryMetadata;
  }());
  var CompileAnimationStateMetadata = (function () {
      function CompileAnimationStateMetadata() {
      }
      return CompileAnimationStateMetadata;
  }());
  var CompileAnimationStateDeclarationMetadata = (function (_super) {
      __extends$1(CompileAnimationStateDeclarationMetadata, _super);
      function CompileAnimationStateDeclarationMetadata(stateNameExpr, styles) {
          _super.call(this);
          this.stateNameExpr = stateNameExpr;
          this.styles = styles;
      }
      return CompileAnimationStateDeclarationMetadata;
  }(CompileAnimationStateMetadata));
  var CompileAnimationStateTransitionMetadata = (function (_super) {
      __extends$1(CompileAnimationStateTransitionMetadata, _super);
      function CompileAnimationStateTransitionMetadata(stateChangeExpr, steps) {
          _super.call(this);
          this.stateChangeExpr = stateChangeExpr;
          this.steps = steps;
      }
      return CompileAnimationStateTransitionMetadata;
  }(CompileAnimationStateMetadata));
  var CompileAnimationMetadata = (function () {
      function CompileAnimationMetadata() {
      }
      return CompileAnimationMetadata;
  }());
  var CompileAnimationKeyframesSequenceMetadata = (function (_super) {
      __extends$1(CompileAnimationKeyframesSequenceMetadata, _super);
      function CompileAnimationKeyframesSequenceMetadata(steps) {
          if (steps === void 0) { steps = []; }
          _super.call(this);
          this.steps = steps;
      }
      return CompileAnimationKeyframesSequenceMetadata;
  }(CompileAnimationMetadata));
  var CompileAnimationStyleMetadata = (function (_super) {
      __extends$1(CompileAnimationStyleMetadata, _super);
      function CompileAnimationStyleMetadata(offset, styles) {
          if (styles === void 0) { styles = null; }
          _super.call(this);
          this.offset = offset;
          this.styles = styles;
      }
      return CompileAnimationStyleMetadata;
  }(CompileAnimationMetadata));
  var CompileAnimationAnimateMetadata = (function (_super) {
      __extends$1(CompileAnimationAnimateMetadata, _super);
      function CompileAnimationAnimateMetadata(timings, styles) {
          if (timings === void 0) { timings = 0; }
          if (styles === void 0) { styles = null; }
          _super.call(this);
          this.timings = timings;
          this.styles = styles;
      }
      return CompileAnimationAnimateMetadata;
  }(CompileAnimationMetadata));
  var CompileAnimationWithStepsMetadata = (function (_super) {
      __extends$1(CompileAnimationWithStepsMetadata, _super);
      function CompileAnimationWithStepsMetadata(steps) {
          if (steps === void 0) { steps = null; }
          _super.call(this);
          this.steps = steps;
      }
      return CompileAnimationWithStepsMetadata;
  }(CompileAnimationMetadata));
  var CompileAnimationSequenceMetadata = (function (_super) {
      __extends$1(CompileAnimationSequenceMetadata, _super);
      function CompileAnimationSequenceMetadata(steps) {
          if (steps === void 0) { steps = null; }
          _super.call(this, steps);
      }
      return CompileAnimationSequenceMetadata;
  }(CompileAnimationWithStepsMetadata));
  var CompileAnimationGroupMetadata = (function (_super) {
      __extends$1(CompileAnimationGroupMetadata, _super);
      function CompileAnimationGroupMetadata(steps) {
          if (steps === void 0) { steps = null; }
          _super.call(this, steps);
      }
      return CompileAnimationGroupMetadata;
  }(CompileAnimationWithStepsMetadata));
  var CompileIdentifierMetadata = (function () {
      function CompileIdentifierMetadata(_a) {
          var _b = _a === void 0 ? {} : _a, reference = _b.reference, name = _b.name, moduleUrl = _b.moduleUrl, prefix = _b.prefix, value = _b.value;
          this.reference = reference;
          this.name = name;
          this.prefix = prefix;
          this.moduleUrl = moduleUrl;
          this.value = value;
      }
      Object.defineProperty(CompileIdentifierMetadata.prototype, "identifier", {
          get: function () { return this; },
          enumerable: true,
          configurable: true
      });
      return CompileIdentifierMetadata;
  }());
  var CompileDiDependencyMetadata = (function () {
      function CompileDiDependencyMetadata(_a) {
          var _b = _a === void 0 ? {} : _a, isAttribute = _b.isAttribute, isSelf = _b.isSelf, isHost = _b.isHost, isSkipSelf = _b.isSkipSelf, isOptional = _b.isOptional, isValue = _b.isValue, query = _b.query, viewQuery = _b.viewQuery, token = _b.token, value = _b.value;
          this.isAttribute = normalizeBool(isAttribute);
          this.isSelf = normalizeBool(isSelf);
          this.isHost = normalizeBool(isHost);
          this.isSkipSelf = normalizeBool(isSkipSelf);
          this.isOptional = normalizeBool(isOptional);
          this.isValue = normalizeBool(isValue);
          this.query = query;
          this.viewQuery = viewQuery;
          this.token = token;
          this.value = value;
      }
      return CompileDiDependencyMetadata;
  }());
  var CompileProviderMetadata = (function () {
      function CompileProviderMetadata(_a) {
          var token = _a.token, useClass = _a.useClass, useValue = _a.useValue, useExisting = _a.useExisting, useFactory = _a.useFactory, deps = _a.deps, multi = _a.multi;
          this.token = token;
          this.useClass = useClass;
          this.useValue = useValue;
          this.useExisting = useExisting;
          this.useFactory = useFactory;
          this.deps = normalizeBlank(deps);
          this.multi = normalizeBool(multi);
      }
      return CompileProviderMetadata;
  }());
  var CompileFactoryMetadata = (function (_super) {
      __extends$1(CompileFactoryMetadata, _super);
      function CompileFactoryMetadata(_a) {
          var reference = _a.reference, name = _a.name, moduleUrl = _a.moduleUrl, prefix = _a.prefix, diDeps = _a.diDeps, value = _a.value;
          _super.call(this, { reference: reference, name: name, prefix: prefix, moduleUrl: moduleUrl, value: value });
          this.diDeps = _normalizeArray(diDeps);
      }
      return CompileFactoryMetadata;
  }(CompileIdentifierMetadata));
  var CompileTokenMetadata = (function () {
      function CompileTokenMetadata(_a) {
          var value = _a.value, identifier = _a.identifier, identifierIsInstance = _a.identifierIsInstance;
          this.value = value;
          this.identifier = identifier;
          this.identifierIsInstance = normalizeBool(identifierIsInstance);
      }
      Object.defineProperty(CompileTokenMetadata.prototype, "reference", {
          get: function () {
              if (isPresent(this.identifier)) {
                  return this.identifier.reference;
              }
              else {
                  return this.value;
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(CompileTokenMetadata.prototype, "name", {
          get: function () {
              return isPresent(this.value) ? sanitizeIdentifier(this.value) : this.identifier.name;
          },
          enumerable: true,
          configurable: true
      });
      return CompileTokenMetadata;
  }());
  /**
   * Metadata regarding compilation of a type.
   */
  var CompileTypeMetadata = (function (_super) {
      __extends$1(CompileTypeMetadata, _super);
      function CompileTypeMetadata(_a) {
          var _b = _a === void 0 ? {} : _a, reference = _b.reference, name = _b.name, moduleUrl = _b.moduleUrl, prefix = _b.prefix, isHost = _b.isHost, value = _b.value, diDeps = _b.diDeps, lifecycleHooks = _b.lifecycleHooks;
          _super.call(this, { reference: reference, name: name, moduleUrl: moduleUrl, prefix: prefix, value: value });
          this.isHost = normalizeBool(isHost);
          this.diDeps = _normalizeArray(diDeps);
          this.lifecycleHooks = _normalizeArray(lifecycleHooks);
      }
      return CompileTypeMetadata;
  }(CompileIdentifierMetadata));
  var CompileQueryMetadata = (function () {
      function CompileQueryMetadata(_a) {
          var _b = _a === void 0 ? {} : _a, selectors = _b.selectors, descendants = _b.descendants, first = _b.first, propertyName = _b.propertyName, read = _b.read;
          this.selectors = selectors;
          this.descendants = normalizeBool(descendants);
          this.first = normalizeBool(first);
          this.propertyName = propertyName;
          this.read = read;
      }
      return CompileQueryMetadata;
  }());
  /**
   * Metadata about a stylesheet
   */
  var CompileStylesheetMetadata = (function () {
      function CompileStylesheetMetadata(_a) {
          var _b = _a === void 0 ? {} : _a, moduleUrl = _b.moduleUrl, styles = _b.styles, styleUrls = _b.styleUrls;
          this.moduleUrl = moduleUrl;
          this.styles = _normalizeArray(styles);
          this.styleUrls = _normalizeArray(styleUrls);
      }
      return CompileStylesheetMetadata;
  }());
  /**
   * Metadata regarding compilation of a template.
   */
  var CompileTemplateMetadata = (function () {
      function CompileTemplateMetadata(_a) {
          var _b = _a === void 0 ? {} : _a, encapsulation = _b.encapsulation, template = _b.template, templateUrl = _b.templateUrl, styles = _b.styles, styleUrls = _b.styleUrls, externalStylesheets = _b.externalStylesheets, animations = _b.animations, ngContentSelectors = _b.ngContentSelectors, interpolation = _b.interpolation;
          this.encapsulation = encapsulation;
          this.template = template;
          this.templateUrl = templateUrl;
          this.styles = _normalizeArray(styles);
          this.styleUrls = _normalizeArray(styleUrls);
          this.externalStylesheets = _normalizeArray(externalStylesheets);
          this.animations = isPresent(animations) ? ListWrapper.flatten(animations) : [];
          this.ngContentSelectors = ngContentSelectors || [];
          if (isPresent(interpolation) && interpolation.length != 2) {
              throw new Error("'interpolation' should have a start and an end symbol.");
          }
          this.interpolation = interpolation;
      }
      return CompileTemplateMetadata;
  }());
  /**
   * Metadata regarding compilation of a directive.
   */
  var CompileDirectiveMetadata = (function () {
      function CompileDirectiveMetadata(_a) {
          var _b = _a === void 0 ? {} : _a, type = _b.type, isComponent = _b.isComponent, selector = _b.selector, exportAs = _b.exportAs, changeDetection = _b.changeDetection, inputs = _b.inputs, outputs = _b.outputs, hostListeners = _b.hostListeners, hostProperties = _b.hostProperties, hostAttributes = _b.hostAttributes, providers = _b.providers, viewProviders = _b.viewProviders, queries = _b.queries, viewQueries = _b.viewQueries, entryComponents = _b.entryComponents, template = _b.template;
          this.type = type;
          this.isComponent = isComponent;
          this.selector = selector;
          this.exportAs = exportAs;
          this.changeDetection = changeDetection;
          this.inputs = inputs;
          this.outputs = outputs;
          this.hostListeners = hostListeners;
          this.hostProperties = hostProperties;
          this.hostAttributes = hostAttributes;
          this.providers = _normalizeArray(providers);
          this.viewProviders = _normalizeArray(viewProviders);
          this.queries = _normalizeArray(queries);
          this.viewQueries = _normalizeArray(viewQueries);
          this.entryComponents = _normalizeArray(entryComponents);
          this.template = template;
      }
      CompileDirectiveMetadata.create = function (_a) {
          var _b = _a === void 0 ? {} : _a, type = _b.type, isComponent = _b.isComponent, selector = _b.selector, exportAs = _b.exportAs, changeDetection = _b.changeDetection, inputs = _b.inputs, outputs = _b.outputs, host = _b.host, providers = _b.providers, viewProviders = _b.viewProviders, queries = _b.queries, viewQueries = _b.viewQueries, entryComponents = _b.entryComponents, template = _b.template;
          var hostListeners = {};
          var hostProperties = {};
          var hostAttributes = {};
          if (isPresent(host)) {
              Object.keys(host).forEach(function (key) {
                  var value = host[key];
                  var matches = key.match(HOST_REG_EXP);
                  if (matches === null) {
                      hostAttributes[key] = value;
                  }
                  else if (isPresent(matches[1])) {
                      hostProperties[matches[1]] = value;
                  }
                  else if (isPresent(matches[2])) {
                      hostListeners[matches[2]] = value;
                  }
              });
          }
          var inputsMap = {};
          if (isPresent(inputs)) {
              inputs.forEach(function (bindConfig) {
                  // canonical syntax: `dirProp: elProp`
                  // if there is no `:`, use dirProp = elProp
                  var parts = splitAtColon(bindConfig, [bindConfig, bindConfig]);
                  inputsMap[parts[0]] = parts[1];
              });
          }
          var outputsMap = {};
          if (isPresent(outputs)) {
              outputs.forEach(function (bindConfig) {
                  // canonical syntax: `dirProp: elProp`
                  // if there is no `:`, use dirProp = elProp
                  var parts = splitAtColon(bindConfig, [bindConfig, bindConfig]);
                  outputsMap[parts[0]] = parts[1];
              });
          }
          return new CompileDirectiveMetadata({
              type: type,
              isComponent: normalizeBool(isComponent), selector: selector, exportAs: exportAs, changeDetection: changeDetection,
              inputs: inputsMap,
              outputs: outputsMap,
              hostListeners: hostListeners,
              hostProperties: hostProperties,
              hostAttributes: hostAttributes,
              providers: providers,
              viewProviders: viewProviders,
              queries: queries,
              viewQueries: viewQueries,
              entryComponents: entryComponents,
              template: template,
          });
      };
      Object.defineProperty(CompileDirectiveMetadata.prototype, "identifier", {
          get: function () { return this.type; },
          enumerable: true,
          configurable: true
      });
      return CompileDirectiveMetadata;
  }());
  /**
   * Construct {@link CompileDirectiveMetadata} from {@link ComponentTypeMetadata} and a selector.
   */
  function createHostComponentMeta(compMeta) {
      var template = CssSelector.parse(compMeta.selector)[0].getMatchingElementTemplate();
      return CompileDirectiveMetadata.create({
          type: new CompileTypeMetadata({
              reference: Object,
              name: compMeta.type.name + "_Host",
              moduleUrl: compMeta.type.moduleUrl,
              isHost: true
          }),
          template: new CompileTemplateMetadata({
              encapsulation: _angular_core.ViewEncapsulation.None,
              template: template,
              templateUrl: '',
              styles: [],
              styleUrls: [],
              ngContentSelectors: [],
              animations: []
          }),
          changeDetection: _angular_core.ChangeDetectionStrategy.Default,
          inputs: [],
          outputs: [],
          host: {},
          isComponent: true,
          selector: '*',
          providers: [],
          viewProviders: [],
          queries: [],
          viewQueries: []
      });
  }
  var CompilePipeMetadata = (function () {
      function CompilePipeMetadata(_a) {
          var _b = _a === void 0 ? {} : _a, type = _b.type, name = _b.name, pure = _b.pure;
          this.type = type;
          this.name = name;
          this.pure = normalizeBool(pure);
      }
      Object.defineProperty(CompilePipeMetadata.prototype, "identifier", {
          get: function () { return this.type; },
          enumerable: true,
          configurable: true
      });
      return CompilePipeMetadata;
  }());
  /**
   * Metadata regarding compilation of a directive.
   */
  var CompileNgModuleMetadata = (function () {
      function CompileNgModuleMetadata(_a) {
          var _b = _a === void 0 ? {} : _a, type = _b.type, providers = _b.providers, declaredDirectives = _b.declaredDirectives, exportedDirectives = _b.exportedDirectives, declaredPipes = _b.declaredPipes, exportedPipes = _b.exportedPipes, entryComponents = _b.entryComponents, bootstrapComponents = _b.bootstrapComponents, importedModules = _b.importedModules, exportedModules = _b.exportedModules, schemas = _b.schemas, transitiveModule = _b.transitiveModule, id = _b.id;
          this.type = type;
          this.declaredDirectives = _normalizeArray(declaredDirectives);
          this.exportedDirectives = _normalizeArray(exportedDirectives);
          this.declaredPipes = _normalizeArray(declaredPipes);
          this.exportedPipes = _normalizeArray(exportedPipes);
          this.providers = _normalizeArray(providers);
          this.entryComponents = _normalizeArray(entryComponents);
          this.bootstrapComponents = _normalizeArray(bootstrapComponents);
          this.importedModules = _normalizeArray(importedModules);
          this.exportedModules = _normalizeArray(exportedModules);
          this.schemas = _normalizeArray(schemas);
          this.id = id;
          this.transitiveModule = transitiveModule;
      }
      Object.defineProperty(CompileNgModuleMetadata.prototype, "identifier", {
          get: function () { return this.type; },
          enumerable: true,
          configurable: true
      });
      return CompileNgModuleMetadata;
  }());
  var TransitiveCompileNgModuleMetadata = (function () {
      function TransitiveCompileNgModuleMetadata(modules, providers, entryComponents, directives, pipes) {
          var _this = this;
          this.modules = modules;
          this.providers = providers;
          this.entryComponents = entryComponents;
          this.directives = directives;
          this.pipes = pipes;
          this.directivesSet = new Set();
          this.pipesSet = new Set();
          directives.forEach(function (dir) { return _this.directivesSet.add(dir.type.reference); });
          pipes.forEach(function (pipe) { return _this.pipesSet.add(pipe.type.reference); });
      }
      return TransitiveCompileNgModuleMetadata;
  }());
  function removeIdentifierDuplicates(items) {
      var map = new Map();
      items.forEach(function (item) {
          if (!map.get(item.identifier.reference)) {
              map.set(item.identifier.reference, item);
          }
      });
      return MapWrapper.values(map);
  }
  function _normalizeArray(obj) {
      return obj || [];
  }
  function isStaticSymbol(value) {
      return typeof value === 'object' && value !== null && value['name'] && value['filePath'];
  }
  var ProviderMeta = (function () {
      function ProviderMeta(token, _a) {
          var useClass = _a.useClass, useValue = _a.useValue, useExisting = _a.useExisting, useFactory = _a.useFactory, deps = _a.deps, multi = _a.multi;
          this.token = token;
          this.useClass = useClass;
          this.useValue = useValue;
          this.useExisting = useExisting;
          this.useFactory = useFactory;
          this.dependencies = deps;
          this.multi = !!multi;
      }
      return ProviderMeta;
  }());

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var __extends$3 = (this && this.__extends) || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var ParserError = (function () {
      function ParserError(message, input, errLocation, ctxLocation) {
          this.input = input;
          this.errLocation = errLocation;
          this.ctxLocation = ctxLocation;
          this.message = "Parser Error: " + message + " " + errLocation + " [" + input + "] in " + ctxLocation;
      }
      return ParserError;
  }());
  var ParseSpan = (function () {
      function ParseSpan(start, end) {
          this.start = start;
          this.end = end;
      }
      return ParseSpan;
  }());
  var AST = (function () {
      function AST(span) {
          this.span = span;
      }
      AST.prototype.visit = function (visitor, context) {
          if (context === void 0) { context = null; }
          return null;
      };
      AST.prototype.toString = function () { return 'AST'; };
      return AST;
  }());
  /**
   * Represents a quoted expression of the form:
   *
   * quote = prefix `:` uninterpretedExpression
   * prefix = identifier
   * uninterpretedExpression = arbitrary string
   *
   * A quoted expression is meant to be pre-processed by an AST transformer that
   * converts it into another AST that no longer contains quoted expressions.
   * It is meant to allow third-party developers to extend Angular template
   * expression language. The `uninterpretedExpression` part of the quote is
   * therefore not interpreted by the Angular's own expression parser.
   */
  var Quote = (function (_super) {
      __extends$3(Quote, _super);
      function Quote(span, prefix, uninterpretedExpression, location) {
          _super.call(this, span);
          this.prefix = prefix;
          this.uninterpretedExpression = uninterpretedExpression;
          this.location = location;
      }
      Quote.prototype.visit = function (visitor, context) {
          if (context === void 0) { context = null; }
          return visitor.visitQuote(this, context);
      };
      Quote.prototype.toString = function () { return 'Quote'; };
      return Quote;
  }(AST));
  var EmptyExpr = (function (_super) {
      __extends$3(EmptyExpr, _super);
      function EmptyExpr() {
          _super.apply(this, arguments);
      }
      EmptyExpr.prototype.visit = function (visitor, context) {
          if (context === void 0) { context = null; }
          // do nothing
      };
      return EmptyExpr;
  }(AST));
  var ImplicitReceiver = (function (_super) {
      __extends$3(ImplicitReceiver, _super);
      function ImplicitReceiver() {
          _super.apply(this, arguments);
      }
      ImplicitReceiver.prototype.visit = function (visitor, context) {
          if (context === void 0) { context = null; }
          return visitor.visitImplicitReceiver(this, context);
      };
      return ImplicitReceiver;
  }(AST));
  /**
   * Multiple expressions separated by a semicolon.
   */
  var Chain = (function (_super) {
      __extends$3(Chain, _super);
      function Chain(span, expressions) {
          _super.call(this, span);
          this.expressions = expressions;
      }
      Chain.prototype.visit = function (visitor, context) {
          if (context === void 0) { context = null; }
          return visitor.visitChain(this, context);
      };
      return Chain;
  }(AST));
  var Conditional = (function (_super) {
      __extends$3(Conditional, _super);
      function Conditional(span, condition, trueExp, falseExp) {
          _super.call(this, span);
          this.condition = condition;
          this.trueExp = trueExp;
          this.falseExp = falseExp;
      }
      Conditional.prototype.visit = function (visitor, context) {
          if (context === void 0) { context = null; }
          return visitor.visitConditional(this, context);
      };
      return Conditional;
  }(AST));
  var PropertyRead = (function (_super) {
      __extends$3(PropertyRead, _super);
      function PropertyRead(span, receiver, name) {
          _super.call(this, span);
          this.receiver = receiver;
          this.name = name;
      }
      PropertyRead.prototype.visit = function (visitor, context) {
          if (context === void 0) { context = null; }
          return visitor.visitPropertyRead(this, context);
      };
      return PropertyRead;
  }(AST));
  var PropertyWrite = (function (_super) {
      __extends$3(PropertyWrite, _super);
      function PropertyWrite(span, receiver, name, value) {
          _super.call(this, span);
          this.receiver = receiver;
          this.name = name;
          this.value = value;
      }
      PropertyWrite.prototype.visit = function (visitor, context) {
          if (context === void 0) { context = null; }
          return visitor.visitPropertyWrite(this, context);
      };
      return PropertyWrite;
  }(AST));
  var SafePropertyRead = (function (_super) {
      __extends$3(SafePropertyRead, _super);
      function SafePropertyRead(span, receiver, name) {
          _super.call(this, span);
          this.receiver = receiver;
          this.name = name;
      }
      SafePropertyRead.prototype.visit = function (visitor, context) {
          if (context === void 0) { context = null; }
          return visitor.visitSafePropertyRead(this, context);
      };
      return SafePropertyRead;
  }(AST));
  var KeyedRead = (function (_super) {
      __extends$3(KeyedRead, _super);
      function KeyedRead(span, obj, key) {
          _super.call(this, span);
          this.obj = obj;
          this.key = key;
      }
      KeyedRead.prototype.visit = function (visitor, context) {
          if (context === void 0) { context = null; }
          return visitor.visitKeyedRead(this, context);
      };
      return KeyedRead;
  }(AST));
  var KeyedWrite = (function (_super) {
      __extends$3(KeyedWrite, _super);
      function KeyedWrite(span, obj, key, value) {
          _super.call(this, span);
          this.obj = obj;
          this.key = key;
          this.value = value;
      }
      KeyedWrite.prototype.visit = function (visitor, context) {
          if (context === void 0) { context = null; }
          return visitor.visitKeyedWrite(this, context);
      };
      return KeyedWrite;
  }(AST));
  var BindingPipe = (function (_super) {
      __extends$3(BindingPipe, _super);
      function BindingPipe(span, exp, name, args) {
          _super.call(this, span);
          this.exp = exp;
          this.name = name;
          this.args = args;
      }
      BindingPipe.prototype.visit = function (visitor, context) {
          if (context === void 0) { context = null; }
          return visitor.visitPipe(this, context);
      };
      return BindingPipe;
  }(AST));
  var LiteralPrimitive = (function (_super) {
      __extends$3(LiteralPrimitive, _super);
      function LiteralPrimitive(span, value) {
          _super.call(this, span);
          this.value = value;
      }
      LiteralPrimitive.prototype.visit = function (visitor, context) {
          if (context === void 0) { context = null; }
          return visitor.visitLiteralPrimitive(this, context);
      };
      return LiteralPrimitive;
  }(AST));
  var LiteralArray = (function (_super) {
      __extends$3(LiteralArray, _super);
      function LiteralArray(span, expressions) {
          _super.call(this, span);
          this.expressions = expressions;
      }
      LiteralArray.prototype.visit = function (visitor, context) {
          if (context === void 0) { context = null; }
          return visitor.visitLiteralArray(this, context);
      };
      return LiteralArray;
  }(AST));
  var LiteralMap = (function (_super) {
      __extends$3(LiteralMap, _super);
      function LiteralMap(span, keys, values) {
          _super.call(this, span);
          this.keys = keys;
          this.values = values;
      }
      LiteralMap.prototype.visit = function (visitor, context) {
          if (context === void 0) { context = null; }
          return visitor.visitLiteralMap(this, context);
      };
      return LiteralMap;
  }(AST));
  var Interpolation = (function (_super) {
      __extends$3(Interpolation, _super);
      function Interpolation(span, strings, expressions) {
          _super.call(this, span);
          this.strings = strings;
          this.expressions = expressions;
      }
      Interpolation.prototype.visit = function (visitor, context) {
          if (context === void 0) { context = null; }
          return visitor.visitInterpolation(this, context);
      };
      return Interpolation;
  }(AST));
  var Binary = (function (_super) {
      __extends$3(Binary, _super);
      function Binary(span, operation, left, right) {
          _super.call(this, span);
          this.operation = operation;
          this.left = left;
          this.right = right;
      }
      Binary.prototype.visit = function (visitor, context) {
          if (context === void 0) { context = null; }
          return visitor.visitBinary(this, context);
      };
      return Binary;
  }(AST));
  var PrefixNot = (function (_super) {
      __extends$3(PrefixNot, _super);
      function PrefixNot(span, expression) {
          _super.call(this, span);
          this.expression = expression;
      }
      PrefixNot.prototype.visit = function (visitor, context) {
          if (context === void 0) { context = null; }
          return visitor.visitPrefixNot(this, context);
      };
      return PrefixNot;
  }(AST));
  var MethodCall = (function (_super) {
      __extends$3(MethodCall, _super);
      function MethodCall(span, receiver, name, args) {
          _super.call(this, span);
          this.receiver = receiver;
          this.name = name;
          this.args = args;
      }
      MethodCall.prototype.visit = function (visitor, context) {
          if (context === void 0) { context = null; }
          return visitor.visitMethodCall(this, context);
      };
      return MethodCall;
  }(AST));
  var SafeMethodCall = (function (_super) {
      __extends$3(SafeMethodCall, _super);
      function SafeMethodCall(span, receiver, name, args) {
          _super.call(this, span);
          this.receiver = receiver;
          this.name = name;
          this.args = args;
      }
      SafeMethodCall.prototype.visit = function (visitor, context) {
          if (context === void 0) { context = null; }
          return visitor.visitSafeMethodCall(this, context);
      };
      return SafeMethodCall;
  }(AST));
  var FunctionCall = (function (_super) {
      __extends$3(FunctionCall, _super);
      function FunctionCall(span, target, args) {
          _super.call(this, span);
          this.target = target;
          this.args = args;
      }
      FunctionCall.prototype.visit = function (visitor, context) {
          if (context === void 0) { context = null; }
          return visitor.visitFunctionCall(this, context);
      };
      return FunctionCall;
  }(AST));
  var ASTWithSource = (function (_super) {
      __extends$3(ASTWithSource, _super);
      function ASTWithSource(ast, source, location, errors) {
          _super.call(this, new ParseSpan(0, isBlank(source) ? 0 : source.length));
          this.ast = ast;
          this.source = source;
          this.location = location;
          this.errors = errors;
      }
      ASTWithSource.prototype.visit = function (visitor, context) {
          if (context === void 0) { context = null; }
          return this.ast.visit(visitor, context);
      };
      ASTWithSource.prototype.toString = function () { return this.source + " in " + this.location; };
      return ASTWithSource;
  }(AST));
  var TemplateBinding = (function () {
      function TemplateBinding(key, keyIsVar, name, expression) {
          this.key = key;
          this.keyIsVar = keyIsVar;
          this.name = name;
          this.expression = expression;
      }
      return TemplateBinding;
  }());
  var RecursiveAstVisitor = (function () {
      function RecursiveAstVisitor() {
      }
      RecursiveAstVisitor.prototype.visitBinary = function (ast, context) {
          ast.left.visit(this);
          ast.right.visit(this);
          return null;
      };
      RecursiveAstVisitor.prototype.visitChain = function (ast, context) { return this.visitAll(ast.expressions, context); };
      RecursiveAstVisitor.prototype.visitConditional = function (ast, context) {
          ast.condition.visit(this);
          ast.trueExp.visit(this);
          ast.falseExp.visit(this);
          return null;
      };
      RecursiveAstVisitor.prototype.visitPipe = function (ast, context) {
          ast.exp.visit(this);
          this.visitAll(ast.args, context);
          return null;
      };
      RecursiveAstVisitor.prototype.visitFunctionCall = function (ast, context) {
          ast.target.visit(this);
          this.visitAll(ast.args, context);
          return null;
      };
      RecursiveAstVisitor.prototype.visitImplicitReceiver = function (ast, context) { return null; };
      RecursiveAstVisitor.prototype.visitInterpolation = function (ast, context) {
          return this.visitAll(ast.expressions, context);
      };
      RecursiveAstVisitor.prototype.visitKeyedRead = function (ast, context) {
          ast.obj.visit(this);
          ast.key.visit(this);
          return null;
      };
      RecursiveAstVisitor.prototype.visitKeyedWrite = function (ast, context) {
          ast.obj.visit(this);
          ast.key.visit(this);
          ast.value.visit(this);
          return null;
      };
      RecursiveAstVisitor.prototype.visitLiteralArray = function (ast, context) {
          return this.visitAll(ast.expressions, context);
      };
      RecursiveAstVisitor.prototype.visitLiteralMap = function (ast, context) { return this.visitAll(ast.values, context); };
      RecursiveAstVisitor.prototype.visitLiteralPrimitive = function (ast, context) { return null; };
      RecursiveAstVisitor.prototype.visitMethodCall = function (ast, context) {
          ast.receiver.visit(this);
          return this.visitAll(ast.args, context);
      };
      RecursiveAstVisitor.prototype.visitPrefixNot = function (ast, context) {
          ast.expression.visit(this);
          return null;
      };
      RecursiveAstVisitor.prototype.visitPropertyRead = function (ast, context) {
          ast.receiver.visit(this);
          return null;
      };
      RecursiveAstVisitor.prototype.visitPropertyWrite = function (ast, context) {
          ast.receiver.visit(this);
          ast.value.visit(this);
          return null;
      };
      RecursiveAstVisitor.prototype.visitSafePropertyRead = function (ast, context) {
          ast.receiver.visit(this);
          return null;
      };
      RecursiveAstVisitor.prototype.visitSafeMethodCall = function (ast, context) {
          ast.receiver.visit(this);
          return this.visitAll(ast.args, context);
      };
      RecursiveAstVisitor.prototype.visitAll = function (asts, context) {
          var _this = this;
          asts.forEach(function (ast) { return ast.visit(_this, context); });
          return null;
      };
      RecursiveAstVisitor.prototype.visitQuote = function (ast, context) { return null; };
      return RecursiveAstVisitor;
  }());

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var $EOF = 0;
  var $TAB = 9;
  var $LF = 10;
  var $VTAB = 11;
  var $FF = 12;
  var $CR = 13;
  var $SPACE = 32;
  var $BANG = 33;
  var $DQ = 34;
  var $HASH = 35;
  var $$ = 36;
  var $PERCENT = 37;
  var $AMPERSAND = 38;
  var $SQ = 39;
  var $LPAREN = 40;
  var $RPAREN = 41;
  var $STAR = 42;
  var $PLUS = 43;
  var $COMMA = 44;
  var $MINUS = 45;
  var $PERIOD = 46;
  var $SLASH = 47;
  var $COLON = 58;
  var $SEMICOLON = 59;
  var $LT = 60;
  var $EQ = 61;
  var $GT = 62;
  var $QUESTION = 63;
  var $0 = 48;
  var $9 = 57;
  var $A = 65;
  var $E = 69;
  var $F = 70;
  var $X = 88;
  var $Z = 90;
  var $LBRACKET = 91;
  var $BACKSLASH = 92;
  var $RBRACKET = 93;
  var $CARET = 94;
  var $_ = 95;
  var $a = 97;
  var $e = 101;
  var $f = 102;
  var $n = 110;
  var $r = 114;
  var $t = 116;
  var $u = 117;
  var $v = 118;
  var $x = 120;
  var $z = 122;
  var $LBRACE = 123;
  var $BAR = 124;
  var $RBRACE = 125;
  var $NBSP = 160;
  var $BT = 96;
  function isWhitespace(code) {
      return (code >= $TAB && code <= $SPACE) || (code == $NBSP);
  }
  function isDigit(code) {
      return $0 <= code && code <= $9;
  }
  function isAsciiLetter(code) {
      return code >= $a && code <= $z || code >= $A && code <= $Z;
  }
  function isAsciiHexDigit(code) {
      return code >= $a && code <= $f || code >= $A && code <= $F || isDigit(code);
  }

  function assertArrayOfStrings(identifier, value) {
      if (!_angular_core.isDevMode() || isBlank(value)) {
          return;
      }
      if (!Array.isArray(value)) {
          throw new Error("Expected '" + identifier + "' to be an array of strings.");
      }
      for (var i = 0; i < value.length; i += 1) {
          if (typeof value[i] !== 'string') {
              throw new Error("Expected '" + identifier + "' to be an array of strings.");
          }
      }
  }
  var INTERPOLATION_BLACKLIST_REGEXPS = [
      /^\s*$/,
      /[<>]/,
      /^[{}]$/,
      /&(#|[a-z])/i,
      /^\/\//,
  ];
  function assertInterpolationSymbols(identifier, value) {
      if (isPresent(value) && !(Array.isArray(value) && value.length == 2)) {
          throw new Error("Expected '" + identifier + "' to be an array, [start, end].");
      }
      else if (_angular_core.isDevMode() && !isBlank(value)) {
          var start_1 = value[0];
          var end_1 = value[1];
          // black list checking
          INTERPOLATION_BLACKLIST_REGEXPS.forEach(function (regexp) {
              if (regexp.test(start_1) || regexp.test(end_1)) {
                  throw new Error("['" + start_1 + "', '" + end_1 + "'] contains unusable interpolation symbol.");
              }
          });
      }
  }

  var InterpolationConfig = (function () {
      function InterpolationConfig(start, end) {
          this.start = start;
          this.end = end;
      }
      InterpolationConfig.fromArray = function (markers) {
          if (!markers) {
              return DEFAULT_INTERPOLATION_CONFIG;
          }
          assertInterpolationSymbols('interpolation', markers);
          return new InterpolationConfig(markers[0], markers[1]);
      };
      ;
      return InterpolationConfig;
  }());
  var DEFAULT_INTERPOLATION_CONFIG = new InterpolationConfig('{{', '}}');

  exports.TokenType;
  (function (TokenType) {
      TokenType[TokenType["Character"] = 0] = "Character";
      TokenType[TokenType["Identifier"] = 1] = "Identifier";
      TokenType[TokenType["Keyword"] = 2] = "Keyword";
      TokenType[TokenType["String"] = 3] = "String";
      TokenType[TokenType["Operator"] = 4] = "Operator";
      TokenType[TokenType["Number"] = 5] = "Number";
      TokenType[TokenType["Error"] = 6] = "Error";
  })(exports.TokenType || (exports.TokenType = {}));
  var KEYWORDS = ['var', 'let', 'null', 'undefined', 'true', 'false', 'if', 'else', 'this'];
  var Lexer = (function () {
      function Lexer() {
      }
      Lexer.prototype.tokenize = function (text) {
          var scanner = new _Scanner(text);
          var tokens = [];
          var token = scanner.scanToken();
          while (token != null) {
              tokens.push(token);
              token = scanner.scanToken();
          }
          return tokens;
      };
      Lexer.decorators = [
          { type: _angular_core.Injectable },
      ];
      /** @nocollapse */
      Lexer.ctorParameters = [];
      return Lexer;
  }());
  var Token = (function () {
      function Token(index, type, numValue, strValue) {
          this.index = index;
          this.type = type;
          this.numValue = numValue;
          this.strValue = strValue;
      }
      Token.prototype.isCharacter = function (code) {
          return this.type == exports.TokenType.Character && this.numValue == code;
      };
      Token.prototype.isNumber = function () { return this.type == exports.TokenType.Number; };
      Token.prototype.isString = function () { return this.type == exports.TokenType.String; };
      Token.prototype.isOperator = function (operater) {
          return this.type == exports.TokenType.Operator && this.strValue == operater;
      };
      Token.prototype.isIdentifier = function () { return this.type == exports.TokenType.Identifier; };
      Token.prototype.isKeyword = function () { return this.type == exports.TokenType.Keyword; };
      Token.prototype.isKeywordLet = function () { return this.type == exports.TokenType.Keyword && this.strValue == 'let'; };
      Token.prototype.isKeywordNull = function () { return this.type == exports.TokenType.Keyword && this.strValue == 'null'; };
      Token.prototype.isKeywordUndefined = function () {
          return this.type == exports.TokenType.Keyword && this.strValue == 'undefined';
      };
      Token.prototype.isKeywordTrue = function () { return this.type == exports.TokenType.Keyword && this.strValue == 'true'; };
      Token.prototype.isKeywordFalse = function () { return this.type == exports.TokenType.Keyword && this.strValue == 'false'; };
      Token.prototype.isKeywordThis = function () { return this.type == exports.TokenType.Keyword && this.strValue == 'this'; };
      Token.prototype.isError = function () { return this.type == exports.TokenType.Error; };
      Token.prototype.toNumber = function () { return this.type == exports.TokenType.Number ? this.numValue : -1; };
      Token.prototype.toString = function () {
          switch (this.type) {
              case exports.TokenType.Character:
              case exports.TokenType.Identifier:
              case exports.TokenType.Keyword:
              case exports.TokenType.Operator:
              case exports.TokenType.String:
              case exports.TokenType.Error:
                  return this.strValue;
              case exports.TokenType.Number:
                  return this.numValue.toString();
              default:
                  return null;
          }
      };
      return Token;
  }());
  function newCharacterToken(index, code) {
      return new Token(index, exports.TokenType.Character, code, String.fromCharCode(code));
  }
  function newIdentifierToken(index, text) {
      return new Token(index, exports.TokenType.Identifier, 0, text);
  }
  function newKeywordToken(index, text) {
      return new Token(index, exports.TokenType.Keyword, 0, text);
  }
  function newOperatorToken(index, text) {
      return new Token(index, exports.TokenType.Operator, 0, text);
  }
  function newStringToken(index, text) {
      return new Token(index, exports.TokenType.String, 0, text);
  }
  function newNumberToken(index, n) {
      return new Token(index, exports.TokenType.Number, n, '');
  }
  function newErrorToken(index, message) {
      return new Token(index, exports.TokenType.Error, 0, message);
  }
  var EOF = new Token(-1, exports.TokenType.Character, 0, '');
  var _Scanner = (function () {
      function _Scanner(input) {
          this.input = input;
          this.peek = 0;
          this.index = -1;
          this.length = input.length;
          this.advance();
      }
      _Scanner.prototype.advance = function () {
          this.peek = ++this.index >= this.length ? $EOF : this.input.charCodeAt(this.index);
      };
      _Scanner.prototype.scanToken = function () {
          var input = this.input, length = this.length, peek = this.peek, index = this.index;
          // Skip whitespace.
          while (peek <= $SPACE) {
              if (++index >= length) {
                  peek = $EOF;
                  break;
              }
              else {
                  peek = input.charCodeAt(index);
              }
          }
          this.peek = peek;
          this.index = index;
          if (index >= length) {
              return null;
          }
          // Handle identifiers and numbers.
          if (isIdentifierStart(peek))
              return this.scanIdentifier();
          if (isDigit(peek))
              return this.scanNumber(index);
          var start = index;
          switch (peek) {
              case $PERIOD:
                  this.advance();
                  return isDigit(this.peek) ? this.scanNumber(start) :
                      newCharacterToken(start, $PERIOD);
              case $LPAREN:
              case $RPAREN:
              case $LBRACE:
              case $RBRACE:
              case $LBRACKET:
              case $RBRACKET:
              case $COMMA:
              case $COLON:
              case $SEMICOLON:
                  return this.scanCharacter(start, peek);
              case $SQ:
              case $DQ:
                  return this.scanString();
              case $HASH:
              case $PLUS:
              case $MINUS:
              case $STAR:
              case $SLASH:
              case $PERCENT:
              case $CARET:
                  return this.scanOperator(start, String.fromCharCode(peek));
              case $QUESTION:
                  return this.scanComplexOperator(start, '?', $PERIOD, '.');
              case $LT:
              case $GT:
                  return this.scanComplexOperator(start, String.fromCharCode(peek), $EQ, '=');
              case $BANG:
              case $EQ:
                  return this.scanComplexOperator(start, String.fromCharCode(peek), $EQ, '=', $EQ, '=');
              case $AMPERSAND:
                  return this.scanComplexOperator(start, '&', $AMPERSAND, '&');
              case $BAR:
                  return this.scanComplexOperator(start, '|', $BAR, '|');
              case $NBSP:
                  while (isWhitespace(this.peek))
                      this.advance();
                  return this.scanToken();
          }
          this.advance();
          return this.error("Unexpected character [" + String.fromCharCode(peek) + "]", 0);
      };
      _Scanner.prototype.scanCharacter = function (start, code) {
          this.advance();
          return newCharacterToken(start, code);
      };
      _Scanner.prototype.scanOperator = function (start, str) {
          this.advance();
          return newOperatorToken(start, str);
      };
      /**
       * Tokenize a 2/3 char long operator
       *
       * @param start start index in the expression
       * @param one first symbol (always part of the operator)
       * @param twoCode code point for the second symbol
       * @param two second symbol (part of the operator when the second code point matches)
       * @param threeCode code point for the third symbol
       * @param three third symbol (part of the operator when provided and matches source expression)
       * @returns {Token}
       */
      _Scanner.prototype.scanComplexOperator = function (start, one, twoCode, two, threeCode, three) {
          this.advance();
          var str = one;
          if (this.peek == twoCode) {
              this.advance();
              str += two;
          }
          if (isPresent(threeCode) && this.peek == threeCode) {
              this.advance();
              str += three;
          }
          return newOperatorToken(start, str);
      };
      _Scanner.prototype.scanIdentifier = function () {
          var start = this.index;
          this.advance();
          while (isIdentifierPart(this.peek))
              this.advance();
          var str = this.input.substring(start, this.index);
          return KEYWORDS.indexOf(str) > -1 ? newKeywordToken(start, str) :
              newIdentifierToken(start, str);
      };
      _Scanner.prototype.scanNumber = function (start) {
          var simple = (this.index === start);
          this.advance(); // Skip initial digit.
          while (true) {
              if (isDigit(this.peek)) {
              }
              else if (this.peek == $PERIOD) {
                  simple = false;
              }
              else if (isExponentStart(this.peek)) {
                  this.advance();
                  if (isExponentSign(this.peek))
                      this.advance();
                  if (!isDigit(this.peek))
                      return this.error('Invalid exponent', -1);
                  simple = false;
              }
              else {
                  break;
              }
              this.advance();
          }
          var str = this.input.substring(start, this.index);
          var value = simple ? NumberWrapper.parseIntAutoRadix(str) : parseFloat(str);
          return newNumberToken(start, value);
      };
      _Scanner.prototype.scanString = function () {
          var start = this.index;
          var quote = this.peek;
          this.advance(); // Skip initial quote.
          var buffer = '';
          var marker = this.index;
          var input = this.input;
          while (this.peek != quote) {
              if (this.peek == $BACKSLASH) {
                  buffer += input.substring(marker, this.index);
                  this.advance();
                  var unescapedCode = void 0;
                  if (this.peek == $u) {
                      // 4 character hex code for unicode character.
                      var hex = input.substring(this.index + 1, this.index + 5);
                      try {
                          unescapedCode = NumberWrapper.parseInt(hex, 16);
                      }
                      catch (e) {
                          return this.error("Invalid unicode escape [\\u" + hex + "]", 0);
                      }
                      for (var i = 0; i < 5; i++) {
                          this.advance();
                      }
                  }
                  else {
                      unescapedCode = unescape(this.peek);
                      this.advance();
                  }
                  buffer += String.fromCharCode(unescapedCode);
                  marker = this.index;
              }
              else if (this.peek == $EOF) {
                  return this.error('Unterminated quote', 0);
              }
              else {
                  this.advance();
              }
          }
          var last = input.substring(marker, this.index);
          this.advance(); // Skip terminating quote.
          return newStringToken(start, buffer + last);
      };
      _Scanner.prototype.error = function (message, offset) {
          var position = this.index + offset;
          return newErrorToken(position, "Lexer Error: " + message + " at column " + position + " in expression [" + this.input + "]");
      };
      return _Scanner;
  }());
  function isIdentifierStart(code) {
      return ($a <= code && code <= $z) || ($A <= code && code <= $Z) ||
          (code == $_) || (code == $$);
  }
  function isIdentifier(input) {
      if (input.length == 0)
          return false;
      var scanner = new _Scanner(input);
      if (!isIdentifierStart(scanner.peek))
          return false;
      scanner.advance();
      while (scanner.peek !== $EOF) {
          if (!isIdentifierPart(scanner.peek))
              return false;
          scanner.advance();
      }
      return true;
  }
  function isIdentifierPart(code) {
      return isAsciiLetter(code) || isDigit(code) || (code == $_) ||
          (code == $$);
  }
  function isExponentStart(code) {
      return code == $e || code == $E;
  }
  function isExponentSign(code) {
      return code == $MINUS || code == $PLUS;
  }
  function isQuote(code) {
      return code === $SQ || code === $DQ || code === $BT;
  }
  function unescape(code) {
      switch (code) {
          case $n:
              return $LF;
          case $f:
              return $FF;
          case $r:
              return $CR;
          case $t:
              return $TAB;
          case $v:
              return $VTAB;
          default:
              return code;
      }
  }

  var SplitInterpolation = (function () {
      function SplitInterpolation(strings, expressions, offsets) {
          this.strings = strings;
          this.expressions = expressions;
          this.offsets = offsets;
      }
      return SplitInterpolation;
  }());
  var TemplateBindingParseResult = (function () {
      function TemplateBindingParseResult(templateBindings, warnings, errors) {
          this.templateBindings = templateBindings;
          this.warnings = warnings;
          this.errors = errors;
      }
      return TemplateBindingParseResult;
  }());
  function _createInterpolateRegExp(config) {
      var pattern = escapeRegExp(config.start) + '([\\s\\S]*?)' + escapeRegExp(config.end);
      return new RegExp(pattern, 'g');
  }
  var Parser = (function () {
      function Parser(_lexer) {
          this._lexer = _lexer;
          this.errors = [];
      }
      Parser.prototype.parseAction = function (input, location, interpolationConfig) {
          if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }
          this._checkNoInterpolation(input, location, interpolationConfig);
          var sourceToLex = this._stripComments(input);
          var tokens = this._lexer.tokenize(this._stripComments(input));
          var ast = new _ParseAST(input, location, tokens, sourceToLex.length, true, this.errors, input.length - sourceToLex.length)
              .parseChain();
          return new ASTWithSource(ast, input, location, this.errors);
      };
      Parser.prototype.parseBinding = function (input, location, interpolationConfig) {
          if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }
          var ast = this._parseBindingAst(input, location, interpolationConfig);
          return new ASTWithSource(ast, input, location, this.errors);
      };
      Parser.prototype.parseSimpleBinding = function (input, location, interpolationConfig) {
          if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }
          var ast = this._parseBindingAst(input, location, interpolationConfig);
          if (!SimpleExpressionChecker.check(ast)) {
              this._reportError('Host binding expression can only contain field access and constants', input, location);
          }
          return new ASTWithSource(ast, input, location, this.errors);
      };
      Parser.prototype._reportError = function (message, input, errLocation, ctxLocation) {
          this.errors.push(new ParserError(message, input, errLocation, ctxLocation));
      };
      Parser.prototype._parseBindingAst = function (input, location, interpolationConfig) {
          // Quotes expressions use 3rd-party expression language. We don't want to use
          // our lexer or parser for that, so we check for that ahead of time.
          var quote = this._parseQuote(input, location);
          if (isPresent(quote)) {
              return quote;
          }
          this._checkNoInterpolation(input, location, interpolationConfig);
          var sourceToLex = this._stripComments(input);
          var tokens = this._lexer.tokenize(sourceToLex);
          return new _ParseAST(input, location, tokens, sourceToLex.length, false, this.errors, input.length - sourceToLex.length)
              .parseChain();
      };
      Parser.prototype._parseQuote = function (input, location) {
          if (isBlank(input))
              return null;
          var prefixSeparatorIndex = input.indexOf(':');
          if (prefixSeparatorIndex == -1)
              return null;
          var prefix = input.substring(0, prefixSeparatorIndex).trim();
          if (!isIdentifier(prefix))
              return null;
          var uninterpretedExpression = input.substring(prefixSeparatorIndex + 1);
          return new Quote(new ParseSpan(0, input.length), prefix, uninterpretedExpression, location);
      };
      Parser.prototype.parseTemplateBindings = function (input, location) {
          var tokens = this._lexer.tokenize(input);
          return new _ParseAST(input, location, tokens, input.length, false, this.errors, 0)
              .parseTemplateBindings();
      };
      Parser.prototype.parseInterpolation = function (input, location, interpolationConfig) {
          if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }
          var split = this.splitInterpolation(input, location, interpolationConfig);
          if (split == null)
              return null;
          var expressions = [];
          for (var i = 0; i < split.expressions.length; ++i) {
              var expressionText = split.expressions[i];
              var sourceToLex = this._stripComments(expressionText);
              var tokens = this._lexer.tokenize(this._stripComments(split.expressions[i]));
              var ast = new _ParseAST(input, location, tokens, sourceToLex.length, false, this.errors, split.offsets[i] + (expressionText.length - sourceToLex.length))
                  .parseChain();
              expressions.push(ast);
          }
          return new ASTWithSource(new Interpolation(new ParseSpan(0, isBlank(input) ? 0 : input.length), split.strings, expressions), input, location, this.errors);
      };
      Parser.prototype.splitInterpolation = function (input, location, interpolationConfig) {
          if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }
          var regexp = _createInterpolateRegExp(interpolationConfig);
          var parts = input.split(regexp);
          if (parts.length <= 1) {
              return null;
          }
          var strings = [];
          var expressions = [];
          var offsets = [];
          var offset = 0;
          for (var i = 0; i < parts.length; i++) {
              var part = parts[i];
              if (i % 2 === 0) {
                  // fixed string
                  strings.push(part);
                  offset += part.length;
              }
              else if (part.trim().length > 0) {
                  offset += interpolationConfig.start.length;
                  expressions.push(part);
                  offsets.push(offset);
                  offset += part.length + interpolationConfig.end.length;
              }
              else {
                  this._reportError('Blank expressions are not allowed in interpolated strings', input, "at column " + this._findInterpolationErrorColumn(parts, i, interpolationConfig) + " in", location);
              }
          }
          return new SplitInterpolation(strings, expressions, offsets);
      };
      Parser.prototype.wrapLiteralPrimitive = function (input, location) {
          return new ASTWithSource(new LiteralPrimitive(new ParseSpan(0, isBlank(input) ? 0 : input.length), input), input, location, this.errors);
      };
      Parser.prototype._stripComments = function (input) {
          var i = this._commentStart(input);
          return isPresent(i) ? input.substring(0, i).trim() : input;
      };
      Parser.prototype._commentStart = function (input) {
          var outerQuote = null;
          for (var i = 0; i < input.length - 1; i++) {
              var char = input.charCodeAt(i);
              var nextChar = input.charCodeAt(i + 1);
              if (char === $SLASH && nextChar == $SLASH && isBlank(outerQuote))
                  return i;
              if (outerQuote === char) {
                  outerQuote = null;
              }
              else if (isBlank(outerQuote) && isQuote(char)) {
                  outerQuote = char;
              }
          }
          return null;
      };
      Parser.prototype._checkNoInterpolation = function (input, location, interpolationConfig) {
          var regexp = _createInterpolateRegExp(interpolationConfig);
          var parts = input.split(regexp);
          if (parts.length > 1) {
              this._reportError("Got interpolation (" + interpolationConfig.start + interpolationConfig.end + ") where expression was expected", input, "at column " + this._findInterpolationErrorColumn(parts, 1, interpolationConfig) + " in", location);
          }
      };
      Parser.prototype._findInterpolationErrorColumn = function (parts, partInErrIdx, interpolationConfig) {
          var errLocation = '';
          for (var j = 0; j < partInErrIdx; j++) {
              errLocation += j % 2 === 0 ?
                  parts[j] :
                  "" + interpolationConfig.start + parts[j] + interpolationConfig.end;
          }
          return errLocation.length;
      };
      Parser.decorators = [
          { type: _angular_core.Injectable },
      ];
      /** @nocollapse */
      Parser.ctorParameters = [
          { type: Lexer, },
      ];
      return Parser;
  }());
  var _ParseAST = (function () {
      function _ParseAST(input, location, tokens, inputLength, parseAction, errors, offset) {
          this.input = input;
          this.location = location;
          this.tokens = tokens;
          this.inputLength = inputLength;
          this.parseAction = parseAction;
          this.errors = errors;
          this.offset = offset;
          this.rparensExpected = 0;
          this.rbracketsExpected = 0;
          this.rbracesExpected = 0;
          this.index = 0;
      }
      _ParseAST.prototype.peek = function (offset) {
          var i = this.index + offset;
          return i < this.tokens.length ? this.tokens[i] : EOF;
      };
      Object.defineProperty(_ParseAST.prototype, "next", {
          get: function () { return this.peek(0); },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(_ParseAST.prototype, "inputIndex", {
          get: function () {
              return (this.index < this.tokens.length) ? this.next.index + this.offset :
                  this.inputLength + this.offset;
          },
          enumerable: true,
          configurable: true
      });
      _ParseAST.prototype.span = function (start) { return new ParseSpan(start, this.inputIndex); };
      _ParseAST.prototype.advance = function () { this.index++; };
      _ParseAST.prototype.optionalCharacter = function (code) {
          if (this.next.isCharacter(code)) {
              this.advance();
              return true;
          }
          else {
              return false;
          }
      };
      _ParseAST.prototype.peekKeywordLet = function () { return this.next.isKeywordLet(); };
      _ParseAST.prototype.expectCharacter = function (code) {
          if (this.optionalCharacter(code))
              return;
          this.error("Missing expected " + String.fromCharCode(code));
      };
      _ParseAST.prototype.optionalOperator = function (op) {
          if (this.next.isOperator(op)) {
              this.advance();
              return true;
          }
          else {
              return false;
          }
      };
      _ParseAST.prototype.expectOperator = function (operator) {
          if (this.optionalOperator(operator))
              return;
          this.error("Missing expected operator " + operator);
      };
      _ParseAST.prototype.expectIdentifierOrKeyword = function () {
          var n = this.next;
          if (!n.isIdentifier() && !n.isKeyword()) {
              this.error("Unexpected token " + n + ", expected identifier or keyword");
              return '';
          }
          this.advance();
          return n.toString();
      };
      _ParseAST.prototype.expectIdentifierOrKeywordOrString = function () {
          var n = this.next;
          if (!n.isIdentifier() && !n.isKeyword() && !n.isString()) {
              this.error("Unexpected token " + n + ", expected identifier, keyword, or string");
              return '';
          }
          this.advance();
          return n.toString();
      };
      _ParseAST.prototype.parseChain = function () {
          var exprs = [];
          var start = this.inputIndex;
          while (this.index < this.tokens.length) {
              var expr = this.parsePipe();
              exprs.push(expr);
              if (this.optionalCharacter($SEMICOLON)) {
                  if (!this.parseAction) {
                      this.error('Binding expression cannot contain chained expression');
                  }
                  while (this.optionalCharacter($SEMICOLON)) {
                  } // read all semicolons
              }
              else if (this.index < this.tokens.length) {
                  this.error("Unexpected token '" + this.next + "'");
              }
          }
          if (exprs.length == 0)
              return new EmptyExpr(this.span(start));
          if (exprs.length == 1)
              return exprs[0];
          return new Chain(this.span(start), exprs);
      };
      _ParseAST.prototype.parsePipe = function () {
          var result = this.parseExpression();
          if (this.optionalOperator('|')) {
              if (this.parseAction) {
                  this.error('Cannot have a pipe in an action expression');
              }
              do {
                  var name = this.expectIdentifierOrKeyword();
                  var args = [];
                  while (this.optionalCharacter($COLON)) {
                      args.push(this.parseExpression());
                  }
                  result = new BindingPipe(this.span(result.span.start - this.offset), result, name, args);
              } while (this.optionalOperator('|'));
          }
          return result;
      };
      _ParseAST.prototype.parseExpression = function () { return this.parseConditional(); };
      _ParseAST.prototype.parseConditional = function () {
          var start = this.inputIndex;
          var result = this.parseLogicalOr();
          if (this.optionalOperator('?')) {
              var yes = this.parsePipe();
              var no = void 0;
              if (!this.optionalCharacter($COLON)) {
                  var end = this.inputIndex;
                  var expression = this.input.substring(start, end);
                  this.error("Conditional expression " + expression + " requires all 3 expressions");
                  no = new EmptyExpr(this.span(start));
              }
              else {
                  no = this.parsePipe();
              }
              return new Conditional(this.span(start), result, yes, no);
          }
          else {
              return result;
          }
      };
      _ParseAST.prototype.parseLogicalOr = function () {
          // '||'
          var result = this.parseLogicalAnd();
          while (this.optionalOperator('||')) {
              var right = this.parseLogicalAnd();
              result = new Binary(this.span(result.span.start), '||', result, right);
          }
          return result;
      };
      _ParseAST.prototype.parseLogicalAnd = function () {
          // '&&'
          var result = this.parseEquality();
          while (this.optionalOperator('&&')) {
              var right = this.parseEquality();
              result = new Binary(this.span(result.span.start), '&&', result, right);
          }
          return result;
      };
      _ParseAST.prototype.parseEquality = function () {
          // '==','!=','===','!=='
          var result = this.parseRelational();
          while (this.next.type == exports.TokenType.Operator) {
              var operator = this.next.strValue;
              switch (operator) {
                  case '==':
                  case '===':
                  case '!=':
                  case '!==':
                      this.advance();
                      var right = this.parseRelational();
                      result = new Binary(this.span(result.span.start), operator, result, right);
                      continue;
              }
              break;
          }
          return result;
      };
      _ParseAST.prototype.parseRelational = function () {
          // '<', '>', '<=', '>='
          var result = this.parseAdditive();
          while (this.next.type == exports.TokenType.Operator) {
              var operator = this.next.strValue;
              switch (operator) {
                  case '<':
                  case '>':
                  case '<=':
                  case '>=':
                      this.advance();
                      var right = this.parseAdditive();
                      result = new Binary(this.span(result.span.start), operator, result, right);
                      continue;
              }
              break;
          }
          return result;
      };
      _ParseAST.prototype.parseAdditive = function () {
          // '+', '-'
          var result = this.parseMultiplicative();
          while (this.next.type == exports.TokenType.Operator) {
              var operator = this.next.strValue;
              switch (operator) {
                  case '+':
                  case '-':
                      this.advance();
                      var right = this.parseMultiplicative();
                      result = new Binary(this.span(result.span.start), operator, result, right);
                      continue;
              }
              break;
          }
          return result;
      };
      _ParseAST.prototype.parseMultiplicative = function () {
          // '*', '%', '/'
          var result = this.parsePrefix();
          while (this.next.type == exports.TokenType.Operator) {
              var operator = this.next.strValue;
              switch (operator) {
                  case '*':
                  case '%':
                  case '/':
                      this.advance();
                      var right = this.parsePrefix();
                      result = new Binary(this.span(result.span.start), operator, result, right);
                      continue;
              }
              break;
          }
          return result;
      };
      _ParseAST.prototype.parsePrefix = function () {
          if (this.next.type == exports.TokenType.Operator) {
              var start = this.inputIndex;
              var operator = this.next.strValue;
              var result = void 0;
              switch (operator) {
                  case '+':
                      this.advance();
                      return this.parsePrefix();
                  case '-':
                      this.advance();
                      result = this.parsePrefix();
                      return new Binary(this.span(start), operator, new LiteralPrimitive(new ParseSpan(start, start), 0), result);
                  case '!':
                      this.advance();
                      result = this.parsePrefix();
                      return new PrefixNot(this.span(start), result);
              }
          }
          return this.parseCallChain();
      };
      _ParseAST.prototype.parseCallChain = function () {
          var result = this.parsePrimary();
          while (true) {
              if (this.optionalCharacter($PERIOD)) {
                  result = this.parseAccessMemberOrMethodCall(result, false);
              }
              else if (this.optionalOperator('?.')) {
                  result = this.parseAccessMemberOrMethodCall(result, true);
              }
              else if (this.optionalCharacter($LBRACKET)) {
                  this.rbracketsExpected++;
                  var key = this.parsePipe();
                  this.rbracketsExpected--;
                  this.expectCharacter($RBRACKET);
                  if (this.optionalOperator('=')) {
                      var value = this.parseConditional();
                      result = new KeyedWrite(this.span(result.span.start), result, key, value);
                  }
                  else {
                      result = new KeyedRead(this.span(result.span.start), result, key);
                  }
              }
              else if (this.optionalCharacter($LPAREN)) {
                  this.rparensExpected++;
                  var args = this.parseCallArguments();
                  this.rparensExpected--;
                  this.expectCharacter($RPAREN);
                  result = new FunctionCall(this.span(result.span.start), result, args);
              }
              else {
                  return result;
              }
          }
      };
      _ParseAST.prototype.parsePrimary = function () {
          var start = this.inputIndex;
          if (this.optionalCharacter($LPAREN)) {
              this.rparensExpected++;
              var result = this.parsePipe();
              this.rparensExpected--;
              this.expectCharacter($RPAREN);
              return result;
          }
          else if (this.next.isKeywordNull()) {
              this.advance();
              return new LiteralPrimitive(this.span(start), null);
          }
          else if (this.next.isKeywordUndefined()) {
              this.advance();
              return new LiteralPrimitive(this.span(start), void 0);
          }
          else if (this.next.isKeywordTrue()) {
              this.advance();
              return new LiteralPrimitive(this.span(start), true);
          }
          else if (this.next.isKeywordFalse()) {
              this.advance();
              return new LiteralPrimitive(this.span(start), false);
          }
          else if (this.next.isKeywordThis()) {
              this.advance();
              return new ImplicitReceiver(this.span(start));
          }
          else if (this.optionalCharacter($LBRACKET)) {
              this.rbracketsExpected++;
              var elements = this.parseExpressionList($RBRACKET);
              this.rbracketsExpected--;
              this.expectCharacter($RBRACKET);
              return new LiteralArray(this.span(start), elements);
          }
          else if (this.next.isCharacter($LBRACE)) {
              return this.parseLiteralMap();
          }
          else if (this.next.isIdentifier()) {
              return this.parseAccessMemberOrMethodCall(new ImplicitReceiver(this.span(start)), false);
          }
          else if (this.next.isNumber()) {
              var value = this.next.toNumber();
              this.advance();
              return new LiteralPrimitive(this.span(start), value);
          }
          else if (this.next.isString()) {
              var literalValue = this.next.toString();
              this.advance();
              return new LiteralPrimitive(this.span(start), literalValue);
          }
          else if (this.index >= this.tokens.length) {
              this.error("Unexpected end of expression: " + this.input);
              return new EmptyExpr(this.span(start));
          }
          else {
              this.error("Unexpected token " + this.next);
              return new EmptyExpr(this.span(start));
          }
      };
      _ParseAST.prototype.parseExpressionList = function (terminator) {
          var result = [];
          if (!this.next.isCharacter(terminator)) {
              do {
                  result.push(this.parsePipe());
              } while (this.optionalCharacter($COMMA));
          }
          return result;
      };
      _ParseAST.prototype.parseLiteralMap = function () {
          var keys = [];
          var values = [];
          var start = this.inputIndex;
          this.expectCharacter($LBRACE);
          if (!this.optionalCharacter($RBRACE)) {
              this.rbracesExpected++;
              do {
                  var key = this.expectIdentifierOrKeywordOrString();
                  keys.push(key);
                  this.expectCharacter($COLON);
                  values.push(this.parsePipe());
              } while (this.optionalCharacter($COMMA));
              this.rbracesExpected--;
              this.expectCharacter($RBRACE);
          }
          return new LiteralMap(this.span(start), keys, values);
      };
      _ParseAST.prototype.parseAccessMemberOrMethodCall = function (receiver, isSafe) {
          if (isSafe === void 0) { isSafe = false; }
          var start = receiver.span.start;
          var id = this.expectIdentifierOrKeyword();
          if (this.optionalCharacter($LPAREN)) {
              this.rparensExpected++;
              var args = this.parseCallArguments();
              this.expectCharacter($RPAREN);
              this.rparensExpected--;
              var span = this.span(start);
              return isSafe ? new SafeMethodCall(span, receiver, id, args) :
                  new MethodCall(span, receiver, id, args);
          }
          else {
              if (isSafe) {
                  if (this.optionalOperator('=')) {
                      this.error('The \'?.\' operator cannot be used in the assignment');
                      return new EmptyExpr(this.span(start));
                  }
                  else {
                      return new SafePropertyRead(this.span(start), receiver, id);
                  }
              }
              else {
                  if (this.optionalOperator('=')) {
                      if (!this.parseAction) {
                          this.error('Bindings cannot contain assignments');
                          return new EmptyExpr(this.span(start));
                      }
                      var value = this.parseConditional();
                      return new PropertyWrite(this.span(start), receiver, id, value);
                  }
                  else {
                      return new PropertyRead(this.span(start), receiver, id);
                  }
              }
          }
      };
      _ParseAST.prototype.parseCallArguments = function () {
          if (this.next.isCharacter($RPAREN))
              return [];
          var positionals = [];
          do {
              positionals.push(this.parsePipe());
          } while (this.optionalCharacter($COMMA));
          return positionals;
      };
      /**
       * An identifier, a keyword, a string with an optional `-` inbetween.
       */
      _ParseAST.prototype.expectTemplateBindingKey = function () {
          var result = '';
          var operatorFound = false;
          do {
              result += this.expectIdentifierOrKeywordOrString();
              operatorFound = this.optionalOperator('-');
              if (operatorFound) {
                  result += '-';
              }
          } while (operatorFound);
          return result.toString();
      };
      _ParseAST.prototype.parseTemplateBindings = function () {
          var bindings = [];
          var prefix = null;
          var warnings = [];
          while (this.index < this.tokens.length) {
              var keyIsVar = this.peekKeywordLet();
              if (keyIsVar) {
                  this.advance();
              }
              var key = this.expectTemplateBindingKey();
              if (!keyIsVar) {
                  if (prefix == null) {
                      prefix = key;
                  }
                  else {
                      key = prefix + key[0].toUpperCase() + key.substring(1);
                  }
              }
              this.optionalCharacter($COLON);
              var name = null;
              var expression = null;
              if (keyIsVar) {
                  if (this.optionalOperator('=')) {
                      name = this.expectTemplateBindingKey();
                  }
                  else {
                      name = '\$implicit';
                  }
              }
              else if (this.next !== EOF && !this.peekKeywordLet()) {
                  var start = this.inputIndex;
                  var ast = this.parsePipe();
                  var source = this.input.substring(start, this.inputIndex);
                  expression = new ASTWithSource(ast, source, this.location, this.errors);
              }
              bindings.push(new TemplateBinding(key, keyIsVar, name, expression));
              if (!this.optionalCharacter($SEMICOLON)) {
                  this.optionalCharacter($COMMA);
              }
          }
          return new TemplateBindingParseResult(bindings, warnings, this.errors);
      };
      _ParseAST.prototype.error = function (message, index) {
          if (index === void 0) { index = null; }
          this.errors.push(new ParserError(message, this.input, this.locationText(index), this.location));
          this.skip();
      };
      _ParseAST.prototype.locationText = function (index) {
          if (index === void 0) { index = null; }
          if (isBlank(index))
              index = this.index;
          return (index < this.tokens.length) ? "at column " + (this.tokens[index].index + 1) + " in" :
              "at the end of the expression";
      };
      // Error recovery should skip tokens until it encounters a recovery point. skip() treats
      // the end of input and a ';' as unconditionally a recovery point. It also treats ')',
      // '}' and ']' as conditional recovery points if one of calling productions is expecting
      // one of these symbols. This allows skip() to recover from errors such as '(a.) + 1' allowing
      // more of the AST to be retained (it doesn't skip any tokens as the ')' is retained because
      // of the '(' begins an '(' <expr> ')' production). The recovery points of grouping symbols
      // must be conditional as they must be skipped if none of the calling productions are not
      // expecting the closing token else we will never make progress in the case of an
      // extraneous group closing symbol (such as a stray ')'). This is not the case for ';' because
      // parseChain() is always the root production and it expects a ';'.
      // If a production expects one of these token it increments the corresponding nesting count,
      // and then decrements it just prior to checking if the token is in the input.
      _ParseAST.prototype.skip = function () {
          var n = this.next;
          while (this.index < this.tokens.length && !n.isCharacter($SEMICOLON) &&
              (this.rparensExpected <= 0 || !n.isCharacter($RPAREN)) &&
              (this.rbracesExpected <= 0 || !n.isCharacter($RBRACE)) &&
              (this.rbracketsExpected <= 0 || !n.isCharacter($RBRACKET))) {
              if (this.next.isError()) {
                  this.errors.push(new ParserError(this.next.toString(), this.input, this.locationText(), this.location));
              }
              this.advance();
              n = this.next;
          }
      };
      return _ParseAST;
  }());
  var SimpleExpressionChecker = (function () {
      function SimpleExpressionChecker() {
          this.simple = true;
      }
      SimpleExpressionChecker.check = function (ast) {
          var s = new SimpleExpressionChecker();
          ast.visit(s);
          return s.simple;
      };
      SimpleExpressionChecker.prototype.visitImplicitReceiver = function (ast, context) { };
      SimpleExpressionChecker.prototype.visitInterpolation = function (ast, context) { this.simple = false; };
      SimpleExpressionChecker.prototype.visitLiteralPrimitive = function (ast, context) { };
      SimpleExpressionChecker.prototype.visitPropertyRead = function (ast, context) { };
      SimpleExpressionChecker.prototype.visitPropertyWrite = function (ast, context) { this.simple = false; };
      SimpleExpressionChecker.prototype.visitSafePropertyRead = function (ast, context) { this.simple = false; };
      SimpleExpressionChecker.prototype.visitMethodCall = function (ast, context) { this.simple = false; };
      SimpleExpressionChecker.prototype.visitSafeMethodCall = function (ast, context) { this.simple = false; };
      SimpleExpressionChecker.prototype.visitFunctionCall = function (ast, context) { this.simple = false; };
      SimpleExpressionChecker.prototype.visitLiteralArray = function (ast, context) { this.visitAll(ast.expressions); };
      SimpleExpressionChecker.prototype.visitLiteralMap = function (ast, context) { this.visitAll(ast.values); };
      SimpleExpressionChecker.prototype.visitBinary = function (ast, context) { this.simple = false; };
      SimpleExpressionChecker.prototype.visitPrefixNot = function (ast, context) { this.simple = false; };
      SimpleExpressionChecker.prototype.visitConditional = function (ast, context) { this.simple = false; };
      SimpleExpressionChecker.prototype.visitPipe = function (ast, context) { this.simple = false; };
      SimpleExpressionChecker.prototype.visitKeyedRead = function (ast, context) { this.simple = false; };
      SimpleExpressionChecker.prototype.visitKeyedWrite = function (ast, context) { this.simple = false; };
      SimpleExpressionChecker.prototype.visitAll = function (asts) {
          var _this = this;
          return asts.map(function (node) { return node.visit(_this); });
      };
      SimpleExpressionChecker.prototype.visitChain = function (ast, context) { this.simple = false; };
      SimpleExpressionChecker.prototype.visitQuote = function (ast, context) { this.simple = false; };
      return SimpleExpressionChecker;
  }());

  var ParseLocation = (function () {
      function ParseLocation(file, offset, line, col) {
          this.file = file;
          this.offset = offset;
          this.line = line;
          this.col = col;
      }
      ParseLocation.prototype.toString = function () {
          return isPresent(this.offset) ? this.file.url + "@" + this.line + ":" + this.col : this.file.url;
      };
      return ParseLocation;
  }());
  var ParseSourceFile = (function () {
      function ParseSourceFile(content, url) {
          this.content = content;
          this.url = url;
      }
      return ParseSourceFile;
  }());
  var ParseSourceSpan = (function () {
      function ParseSourceSpan(start, end, details) {
          if (details === void 0) { details = null; }
          this.start = start;
          this.end = end;
          this.details = details;
      }
      ParseSourceSpan.prototype.toString = function () {
          return this.start.file.content.substring(this.start.offset, this.end.offset);
      };
      return ParseSourceSpan;
  }());
  exports.ParseErrorLevel;
  (function (ParseErrorLevel) {
      ParseErrorLevel[ParseErrorLevel["WARNING"] = 0] = "WARNING";
      ParseErrorLevel[ParseErrorLevel["FATAL"] = 1] = "FATAL";
  })(exports.ParseErrorLevel || (exports.ParseErrorLevel = {}));
  var ParseError = (function () {
      function ParseError(span, msg, level) {
          if (level === void 0) { level = exports.ParseErrorLevel.FATAL; }
          this.span = span;
          this.msg = msg;
          this.level = level;
      }
      ParseError.prototype.toString = function () {
          var source = this.span.start.file.content;
          var ctxStart = this.span.start.offset;
          var contextStr = '';
          var details = '';
          if (isPresent(ctxStart)) {
              if (ctxStart > source.length - 1) {
                  ctxStart = source.length - 1;
              }
              var ctxEnd = ctxStart;
              var ctxLen = 0;
              var ctxLines = 0;
              while (ctxLen < 100 && ctxStart > 0) {
                  ctxStart--;
                  ctxLen++;
                  if (source[ctxStart] == '\n') {
                      if (++ctxLines == 3) {
                          break;
                      }
                  }
              }
              ctxLen = 0;
              ctxLines = 0;
              while (ctxLen < 100 && ctxEnd < source.length - 1) {
                  ctxEnd++;
                  ctxLen++;
                  if (source[ctxEnd] == '\n') {
                      if (++ctxLines == 3) {
                          break;
                      }
                  }
              }
              var context = source.substring(ctxStart, this.span.start.offset) + '[ERROR ->]' +
                  source.substring(this.span.start.offset, ctxEnd + 1);
              contextStr = " (\"" + context + "\")";
          }
          if (this.span.details) {
              details = ", " + this.span.details;
          }
          return "" + this.msg + contextStr + ": " + this.span.start + details;
      };
      return ParseError;
  }());

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var Text = (function () {
      function Text(value, sourceSpan) {
          this.value = value;
          this.sourceSpan = sourceSpan;
      }
      Text.prototype.visit = function (visitor, context) { return visitor.visitText(this, context); };
      return Text;
  }());
  var Expansion = (function () {
      function Expansion(switchValue, type, cases, sourceSpan, switchValueSourceSpan) {
          this.switchValue = switchValue;
          this.type = type;
          this.cases = cases;
          this.sourceSpan = sourceSpan;
          this.switchValueSourceSpan = switchValueSourceSpan;
      }
      Expansion.prototype.visit = function (visitor, context) { return visitor.visitExpansion(this, context); };
      return Expansion;
  }());
  var ExpansionCase = (function () {
      function ExpansionCase(value, expression, sourceSpan, valueSourceSpan, expSourceSpan) {
          this.value = value;
          this.expression = expression;
          this.sourceSpan = sourceSpan;
          this.valueSourceSpan = valueSourceSpan;
          this.expSourceSpan = expSourceSpan;
      }
      ExpansionCase.prototype.visit = function (visitor, context) { return visitor.visitExpansionCase(this, context); };
      return ExpansionCase;
  }());
  var Attribute$1 = (function () {
      function Attribute(name, value, sourceSpan, valueSpan) {
          this.name = name;
          this.value = value;
          this.sourceSpan = sourceSpan;
          this.valueSpan = valueSpan;
      }
      Attribute.prototype.visit = function (visitor, context) { return visitor.visitAttribute(this, context); };
      return Attribute;
  }());
  var Element = (function () {
      function Element(name, attrs, children, sourceSpan, startSourceSpan, endSourceSpan) {
          this.name = name;
          this.attrs = attrs;
          this.children = children;
          this.sourceSpan = sourceSpan;
          this.startSourceSpan = startSourceSpan;
          this.endSourceSpan = endSourceSpan;
      }
      Element.prototype.visit = function (visitor, context) { return visitor.visitElement(this, context); };
      return Element;
  }());
  var Comment = (function () {
      function Comment(value, sourceSpan) {
          this.value = value;
          this.sourceSpan = sourceSpan;
      }
      Comment.prototype.visit = function (visitor, context) { return visitor.visitComment(this, context); };
      return Comment;
  }());
  function visitAll(visitor, nodes, context) {
      if (context === void 0) { context = null; }
      var result = [];
      var visit = visitor.visit ?
          function (ast) { return visitor.visit(ast, context) || ast.visit(visitor, context); } :
          function (ast) { return ast.visit(visitor, context); };
      nodes.forEach(function (ast) {
          var astResult = visit(ast);
          if (astResult) {
              result.push(astResult);
          }
      });
      return result;
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var __extends$5 = (this && this.__extends) || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var TokenType$1;
  (function (TokenType) {
      TokenType[TokenType["TAG_OPEN_START"] = 0] = "TAG_OPEN_START";
      TokenType[TokenType["TAG_OPEN_END"] = 1] = "TAG_OPEN_END";
      TokenType[TokenType["TAG_OPEN_END_VOID"] = 2] = "TAG_OPEN_END_VOID";
      TokenType[TokenType["TAG_CLOSE"] = 3] = "TAG_CLOSE";
      TokenType[TokenType["TEXT"] = 4] = "TEXT";
      TokenType[TokenType["ESCAPABLE_RAW_TEXT"] = 5] = "ESCAPABLE_RAW_TEXT";
      TokenType[TokenType["RAW_TEXT"] = 6] = "RAW_TEXT";
      TokenType[TokenType["COMMENT_START"] = 7] = "COMMENT_START";
      TokenType[TokenType["COMMENT_END"] = 8] = "COMMENT_END";
      TokenType[TokenType["CDATA_START"] = 9] = "CDATA_START";
      TokenType[TokenType["CDATA_END"] = 10] = "CDATA_END";
      TokenType[TokenType["ATTR_NAME"] = 11] = "ATTR_NAME";
      TokenType[TokenType["ATTR_VALUE"] = 12] = "ATTR_VALUE";
      TokenType[TokenType["DOC_TYPE"] = 13] = "DOC_TYPE";
      TokenType[TokenType["EXPANSION_FORM_START"] = 14] = "EXPANSION_FORM_START";
      TokenType[TokenType["EXPANSION_CASE_VALUE"] = 15] = "EXPANSION_CASE_VALUE";
      TokenType[TokenType["EXPANSION_CASE_EXP_START"] = 16] = "EXPANSION_CASE_EXP_START";
      TokenType[TokenType["EXPANSION_CASE_EXP_END"] = 17] = "EXPANSION_CASE_EXP_END";
      TokenType[TokenType["EXPANSION_FORM_END"] = 18] = "EXPANSION_FORM_END";
      TokenType[TokenType["EOF"] = 19] = "EOF";
  })(TokenType$1 || (TokenType$1 = {}));
  var Token$1 = (function () {
      function Token(type, parts, sourceSpan) {
          this.type = type;
          this.parts = parts;
          this.sourceSpan = sourceSpan;
      }
      return Token;
  }());
  var TokenError = (function (_super) {
      __extends$5(TokenError, _super);
      function TokenError(errorMsg, tokenType, span) {
          _super.call(this, span, errorMsg);
          this.tokenType = tokenType;
      }
      return TokenError;
  }(ParseError));
  var TokenizeResult = (function () {
      function TokenizeResult(tokens, errors) {
          this.tokens = tokens;
          this.errors = errors;
      }
      return TokenizeResult;
  }());
  function tokenize(source, url, getTagDefinition, tokenizeExpansionForms, interpolationConfig) {
      if (tokenizeExpansionForms === void 0) { tokenizeExpansionForms = false; }
      if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }
      return new _Tokenizer(new ParseSourceFile(source, url), getTagDefinition, tokenizeExpansionForms, interpolationConfig)
          .tokenize();
  }
  var _CR_OR_CRLF_REGEXP = /\r\n?/g;
  function _unexpectedCharacterErrorMsg(charCode) {
      var char = charCode === $EOF ? 'EOF' : String.fromCharCode(charCode);
      return "Unexpected character \"" + char + "\"";
  }
  function _unknownEntityErrorMsg(entitySrc) {
      return "Unknown entity \"" + entitySrc + "\" - use the \"&#<decimal>;\" or  \"&#x<hex>;\" syntax";
  }
  var _ControlFlowError = (function () {
      function _ControlFlowError(error) {
          this.error = error;
      }
      return _ControlFlowError;
  }());
  // See http://www.w3.org/TR/html51/syntax.html#writing
  var _Tokenizer = (function () {
      /**
       * @param _file The html source
       * @param _getTagDefinition
       * @param _tokenizeIcu Whether to tokenize ICU messages (considered as text nodes when false)
       * @param _interpolationConfig
       */
      function _Tokenizer(_file, _getTagDefinition, _tokenizeIcu, _interpolationConfig) {
          if (_interpolationConfig === void 0) { _interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }
          this._file = _file;
          this._getTagDefinition = _getTagDefinition;
          this._tokenizeIcu = _tokenizeIcu;
          this._interpolationConfig = _interpolationConfig;
          // Note: this is always lowercase!
          this._peek = -1;
          this._nextPeek = -1;
          this._index = -1;
          this._line = 0;
          this._column = -1;
          this._expansionCaseStack = [];
          this._inInterpolation = false;
          this.tokens = [];
          this.errors = [];
          this._input = _file.content;
          this._length = _file.content.length;
          this._advance();
      }
      _Tokenizer.prototype._processCarriageReturns = function (content) {
          // http://www.w3.org/TR/html5/syntax.html#preprocessing-the-input-stream
          // In order to keep the original position in the source, we can not
          // pre-process it.
          // Instead CRs are processed right before instantiating the tokens.
          return content.replace(_CR_OR_CRLF_REGEXP, '\n');
      };
      _Tokenizer.prototype.tokenize = function () {
          while (this._peek !== $EOF) {
              var start = this._getLocation();
              try {
                  if (this._attemptCharCode($LT)) {
                      if (this._attemptCharCode($BANG)) {
                          if (this._attemptCharCode($LBRACKET)) {
                              this._consumeCdata(start);
                          }
                          else if (this._attemptCharCode($MINUS)) {
                              this._consumeComment(start);
                          }
                          else {
                              this._consumeDocType(start);
                          }
                      }
                      else if (this._attemptCharCode($SLASH)) {
                          this._consumeTagClose(start);
                      }
                      else {
                          this._consumeTagOpen(start);
                      }
                  }
                  else if (!this._tokenizeIcu || !this._tokenizeExpansionForm()) {
                      this._consumeText();
                  }
              }
              catch (e) {
                  if (e instanceof _ControlFlowError) {
                      this.errors.push(e.error);
                  }
                  else {
                      throw e;
                  }
              }
          }
          this._beginToken(TokenType$1.EOF);
          this._endToken([]);
          return new TokenizeResult(mergeTextTokens(this.tokens), this.errors);
      };
      /**
       * @returns {boolean} whether an ICU token has been created
       * @internal
       */
      _Tokenizer.prototype._tokenizeExpansionForm = function () {
          if (isExpansionFormStart(this._input, this._index, this._interpolationConfig)) {
              this._consumeExpansionFormStart();
              return true;
          }
          if (isExpansionCaseStart(this._peek) && this._isInExpansionForm()) {
              this._consumeExpansionCaseStart();
              return true;
          }
          if (this._peek === $RBRACE) {
              if (this._isInExpansionCase()) {
                  this._consumeExpansionCaseEnd();
                  return true;
              }
              if (this._isInExpansionForm()) {
                  this._consumeExpansionFormEnd();
                  return true;
              }
          }
          return false;
      };
      _Tokenizer.prototype._getLocation = function () {
          return new ParseLocation(this._file, this._index, this._line, this._column);
      };
      _Tokenizer.prototype._getSpan = function (start, end) {
          if (start === void 0) { start = this._getLocation(); }
          if (end === void 0) { end = this._getLocation(); }
          return new ParseSourceSpan(start, end);
      };
      _Tokenizer.prototype._beginToken = function (type, start) {
          if (start === void 0) { start = this._getLocation(); }
          this._currentTokenStart = start;
          this._currentTokenType = type;
      };
      _Tokenizer.prototype._endToken = function (parts, end) {
          if (end === void 0) { end = this._getLocation(); }
          var token = new Token$1(this._currentTokenType, parts, new ParseSourceSpan(this._currentTokenStart, end));
          this.tokens.push(token);
          this._currentTokenStart = null;
          this._currentTokenType = null;
          return token;
      };
      _Tokenizer.prototype._createError = function (msg, span) {
          if (this._isInExpansionForm()) {
              msg += " (Do you have an unescaped \"{\" in your template? Use \"{{ '{' }}\") to escape it.)";
          }
          var error = new TokenError(msg, this._currentTokenType, span);
          this._currentTokenStart = null;
          this._currentTokenType = null;
          return new _ControlFlowError(error);
      };
      _Tokenizer.prototype._advance = function () {
          if (this._index >= this._length) {
              throw this._createError(_unexpectedCharacterErrorMsg($EOF), this._getSpan());
          }
          if (this._peek === $LF) {
              this._line++;
              this._column = 0;
          }
          else if (this._peek !== $LF && this._peek !== $CR) {
              this._column++;
          }
          this._index++;
          this._peek = this._index >= this._length ? $EOF : this._input.charCodeAt(this._index);
          this._nextPeek =
              this._index + 1 >= this._length ? $EOF : this._input.charCodeAt(this._index + 1);
      };
      _Tokenizer.prototype._attemptCharCode = function (charCode) {
          if (this._peek === charCode) {
              this._advance();
              return true;
          }
          return false;
      };
      _Tokenizer.prototype._attemptCharCodeCaseInsensitive = function (charCode) {
          if (compareCharCodeCaseInsensitive(this._peek, charCode)) {
              this._advance();
              return true;
          }
          return false;
      };
      _Tokenizer.prototype._requireCharCode = function (charCode) {
          var location = this._getLocation();
          if (!this._attemptCharCode(charCode)) {
              throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan(location, location));
          }
      };
      _Tokenizer.prototype._attemptStr = function (chars) {
          var len = chars.length;
          if (this._index + len > this._length) {
              return false;
          }
          var initialPosition = this._savePosition();
          for (var i = 0; i < len; i++) {
              if (!this._attemptCharCode(chars.charCodeAt(i))) {
                  // If attempting to parse the string fails, we want to reset the parser
                  // to where it was before the attempt
                  this._restorePosition(initialPosition);
                  return false;
              }
          }
          return true;
      };
      _Tokenizer.prototype._attemptStrCaseInsensitive = function (chars) {
          for (var i = 0; i < chars.length; i++) {
              if (!this._attemptCharCodeCaseInsensitive(chars.charCodeAt(i))) {
                  return false;
              }
          }
          return true;
      };
      _Tokenizer.prototype._requireStr = function (chars) {
          var location = this._getLocation();
          if (!this._attemptStr(chars)) {
              throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan(location));
          }
      };
      _Tokenizer.prototype._attemptCharCodeUntilFn = function (predicate) {
          while (!predicate(this._peek)) {
              this._advance();
          }
      };
      _Tokenizer.prototype._requireCharCodeUntilFn = function (predicate, len) {
          var start = this._getLocation();
          this._attemptCharCodeUntilFn(predicate);
          if (this._index - start.offset < len) {
              throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan(start, start));
          }
      };
      _Tokenizer.prototype._attemptUntilChar = function (char) {
          while (this._peek !== char) {
              this._advance();
          }
      };
      _Tokenizer.prototype._readChar = function (decodeEntities) {
          if (decodeEntities && this._peek === $AMPERSAND) {
              return this._decodeEntity();
          }
          else {
              var index = this._index;
              this._advance();
              return this._input[index];
          }
      };
      _Tokenizer.prototype._decodeEntity = function () {
          var start = this._getLocation();
          this._advance();
          if (this._attemptCharCode($HASH)) {
              var isHex = this._attemptCharCode($x) || this._attemptCharCode($X);
              var numberStart = this._getLocation().offset;
              this._attemptCharCodeUntilFn(isDigitEntityEnd);
              if (this._peek != $SEMICOLON) {
                  throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan());
              }
              this._advance();
              var strNum = this._input.substring(numberStart, this._index - 1);
              try {
                  var charCode = parseInt(strNum, isHex ? 16 : 10);
                  return String.fromCharCode(charCode);
              }
              catch (e) {
                  var entity = this._input.substring(start.offset + 1, this._index - 1);
                  throw this._createError(_unknownEntityErrorMsg(entity), this._getSpan(start));
              }
          }
          else {
              var startPosition = this._savePosition();
              this._attemptCharCodeUntilFn(isNamedEntityEnd);
              if (this._peek != $SEMICOLON) {
                  this._restorePosition(startPosition);
                  return '&';
              }
              this._advance();
              var name_1 = this._input.substring(start.offset + 1, this._index - 1);
              var char = NAMED_ENTITIES[name_1];
              if (!char) {
                  throw this._createError(_unknownEntityErrorMsg(name_1), this._getSpan(start));
              }
              return char;
          }
      };
      _Tokenizer.prototype._consumeRawText = function (decodeEntities, firstCharOfEnd, attemptEndRest) {
          var tagCloseStart;
          var textStart = this._getLocation();
          this._beginToken(decodeEntities ? TokenType$1.ESCAPABLE_RAW_TEXT : TokenType$1.RAW_TEXT, textStart);
          var parts = [];
          while (true) {
              tagCloseStart = this._getLocation();
              if (this._attemptCharCode(firstCharOfEnd) && attemptEndRest()) {
                  break;
              }
              if (this._index > tagCloseStart.offset) {
                  // add the characters consumed by the previous if statement to the output
                  parts.push(this._input.substring(tagCloseStart.offset, this._index));
              }
              while (this._peek !== firstCharOfEnd) {
                  parts.push(this._readChar(decodeEntities));
              }
          }
          return this._endToken([this._processCarriageReturns(parts.join(''))], tagCloseStart);
      };
      _Tokenizer.prototype._consumeComment = function (start) {
          var _this = this;
          this._beginToken(TokenType$1.COMMENT_START, start);
          this._requireCharCode($MINUS);
          this._endToken([]);
          var textToken = this._consumeRawText(false, $MINUS, function () { return _this._attemptStr('->'); });
          this._beginToken(TokenType$1.COMMENT_END, textToken.sourceSpan.end);
          this._endToken([]);
      };
      _Tokenizer.prototype._consumeCdata = function (start) {
          var _this = this;
          this._beginToken(TokenType$1.CDATA_START, start);
          this._requireStr('CDATA[');
          this._endToken([]);
          var textToken = this._consumeRawText(false, $RBRACKET, function () { return _this._attemptStr(']>'); });
          this._beginToken(TokenType$1.CDATA_END, textToken.sourceSpan.end);
          this._endToken([]);
      };
      _Tokenizer.prototype._consumeDocType = function (start) {
          this._beginToken(TokenType$1.DOC_TYPE, start);
          this._attemptUntilChar($GT);
          this._advance();
          this._endToken([this._input.substring(start.offset + 2, this._index - 1)]);
      };
      _Tokenizer.prototype._consumePrefixAndName = function () {
          var nameOrPrefixStart = this._index;
          var prefix = null;
          while (this._peek !== $COLON && !isPrefixEnd(this._peek)) {
              this._advance();
          }
          var nameStart;
          if (this._peek === $COLON) {
              this._advance();
              prefix = this._input.substring(nameOrPrefixStart, this._index - 1);
              nameStart = this._index;
          }
          else {
              nameStart = nameOrPrefixStart;
          }
          this._requireCharCodeUntilFn(isNameEnd, this._index === nameStart ? 1 : 0);
          var name = this._input.substring(nameStart, this._index);
          return [prefix, name];
      };
      _Tokenizer.prototype._consumeTagOpen = function (start) {
          var savedPos = this._savePosition();
          var tagName;
          var lowercaseTagName;
          try {
              if (!isAsciiLetter(this._peek)) {
                  throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan());
              }
              var nameStart = this._index;
              this._consumeTagOpenStart(start);
              tagName = this._input.substring(nameStart, this._index);
              lowercaseTagName = tagName.toLowerCase();
              this._attemptCharCodeUntilFn(isNotWhitespace);
              while (this._peek !== $SLASH && this._peek !== $GT) {
                  this._consumeAttributeName();
                  this._attemptCharCodeUntilFn(isNotWhitespace);
                  if (this._attemptCharCode($EQ)) {
                      this._attemptCharCodeUntilFn(isNotWhitespace);
                      this._consumeAttributeValue();
                  }
                  this._attemptCharCodeUntilFn(isNotWhitespace);
              }
              this._consumeTagOpenEnd();
          }
          catch (e) {
              if (e instanceof _ControlFlowError) {
                  // When the start tag is invalid, assume we want a "<"
                  this._restorePosition(savedPos);
                  // Back to back text tokens are merged at the end
                  this._beginToken(TokenType$1.TEXT, start);
                  this._endToken(['<']);
                  return;
              }
              throw e;
          }
          var contentTokenType = this._getTagDefinition(tagName).contentType;
          if (contentTokenType === TagContentType.RAW_TEXT) {
              this._consumeRawTextWithTagClose(lowercaseTagName, false);
          }
          else if (contentTokenType === TagContentType.ESCAPABLE_RAW_TEXT) {
              this._consumeRawTextWithTagClose(lowercaseTagName, true);
          }
      };
      _Tokenizer.prototype._consumeRawTextWithTagClose = function (lowercaseTagName, decodeEntities) {
          var _this = this;
          var textToken = this._consumeRawText(decodeEntities, $LT, function () {
              if (!_this._attemptCharCode($SLASH))
                  return false;
              _this._attemptCharCodeUntilFn(isNotWhitespace);
              if (!_this._attemptStrCaseInsensitive(lowercaseTagName))
                  return false;
              _this._attemptCharCodeUntilFn(isNotWhitespace);
              return _this._attemptCharCode($GT);
          });
          this._beginToken(TokenType$1.TAG_CLOSE, textToken.sourceSpan.end);
          this._endToken([null, lowercaseTagName]);
      };
      _Tokenizer.prototype._consumeTagOpenStart = function (start) {
          this._beginToken(TokenType$1.TAG_OPEN_START, start);
          var parts = this._consumePrefixAndName();
          this._endToken(parts);
      };
      _Tokenizer.prototype._consumeAttributeName = function () {
          this._beginToken(TokenType$1.ATTR_NAME);
          var prefixAndName = this._consumePrefixAndName();
          this._endToken(prefixAndName);
      };
      _Tokenizer.prototype._consumeAttributeValue = function () {
          this._beginToken(TokenType$1.ATTR_VALUE);
          var value;
          if (this._peek === $SQ || this._peek === $DQ) {
              var quoteChar = this._peek;
              this._advance();
              var parts = [];
              while (this._peek !== quoteChar) {
                  parts.push(this._readChar(true));
              }
              value = parts.join('');
              this._advance();
          }
          else {
              var valueStart = this._index;
              this._requireCharCodeUntilFn(isNameEnd, 1);
              value = this._input.substring(valueStart, this._index);
          }
          this._endToken([this._processCarriageReturns(value)]);
      };
      _Tokenizer.prototype._consumeTagOpenEnd = function () {
          var tokenType = this._attemptCharCode($SLASH) ? TokenType$1.TAG_OPEN_END_VOID : TokenType$1.TAG_OPEN_END;
          this._beginToken(tokenType);
          this._requireCharCode($GT);
          this._endToken([]);
      };
      _Tokenizer.prototype._consumeTagClose = function (start) {
          this._beginToken(TokenType$1.TAG_CLOSE, start);
          this._attemptCharCodeUntilFn(isNotWhitespace);
          var prefixAndName = this._consumePrefixAndName();
          this._attemptCharCodeUntilFn(isNotWhitespace);
          this._requireCharCode($GT);
          this._endToken(prefixAndName);
      };
      _Tokenizer.prototype._consumeExpansionFormStart = function () {
          this._beginToken(TokenType$1.EXPANSION_FORM_START, this._getLocation());
          this._requireCharCode($LBRACE);
          this._endToken([]);
          this._expansionCaseStack.push(TokenType$1.EXPANSION_FORM_START);
          this._beginToken(TokenType$1.RAW_TEXT, this._getLocation());
          var condition = this._readUntil($COMMA);
          this._endToken([condition], this._getLocation());
          this._requireCharCode($COMMA);
          this._attemptCharCodeUntilFn(isNotWhitespace);
          this._beginToken(TokenType$1.RAW_TEXT, this._getLocation());
          var type = this._readUntil($COMMA);
          this._endToken([type], this._getLocation());
          this._requireCharCode($COMMA);
          this._attemptCharCodeUntilFn(isNotWhitespace);
      };
      _Tokenizer.prototype._consumeExpansionCaseStart = function () {
          this._beginToken(TokenType$1.EXPANSION_CASE_VALUE, this._getLocation());
          var value = this._readUntil($LBRACE).trim();
          this._endToken([value], this._getLocation());
          this._attemptCharCodeUntilFn(isNotWhitespace);
          this._beginToken(TokenType$1.EXPANSION_CASE_EXP_START, this._getLocation());
          this._requireCharCode($LBRACE);
          this._endToken([], this._getLocation());
          this._attemptCharCodeUntilFn(isNotWhitespace);
          this._expansionCaseStack.push(TokenType$1.EXPANSION_CASE_EXP_START);
      };
      _Tokenizer.prototype._consumeExpansionCaseEnd = function () {
          this._beginToken(TokenType$1.EXPANSION_CASE_EXP_END, this._getLocation());
          this._requireCharCode($RBRACE);
          this._endToken([], this._getLocation());
          this._attemptCharCodeUntilFn(isNotWhitespace);
          this._expansionCaseStack.pop();
      };
      _Tokenizer.prototype._consumeExpansionFormEnd = function () {
          this._beginToken(TokenType$1.EXPANSION_FORM_END, this._getLocation());
          this._requireCharCode($RBRACE);
          this._endToken([]);
          this._expansionCaseStack.pop();
      };
      _Tokenizer.prototype._consumeText = function () {
          var start = this._getLocation();
          this._beginToken(TokenType$1.TEXT, start);
          var parts = [];
          do {
              if (this._interpolationConfig && this._attemptStr(this._interpolationConfig.start)) {
                  parts.push(this._interpolationConfig.start);
                  this._inInterpolation = true;
              }
              else if (this._interpolationConfig && this._attemptStr(this._interpolationConfig.end) &&
                  this._inInterpolation) {
                  parts.push(this._interpolationConfig.end);
                  this._inInterpolation = false;
              }
              else {
                  parts.push(this._readChar(true));
              }
          } while (!this._isTextEnd());
          this._endToken([this._processCarriageReturns(parts.join(''))]);
      };
      _Tokenizer.prototype._isTextEnd = function () {
          if (this._peek === $LT || this._peek === $EOF) {
              return true;
          }
          if (this._tokenizeIcu && !this._inInterpolation) {
              if (isExpansionFormStart(this._input, this._index, this._interpolationConfig)) {
                  // start of an expansion form
                  return true;
              }
              if (this._peek === $RBRACE && this._isInExpansionCase()) {
                  // end of and expansion case
                  return true;
              }
          }
          return false;
      };
      _Tokenizer.prototype._savePosition = function () {
          return [this._peek, this._index, this._column, this._line, this.tokens.length];
      };
      _Tokenizer.prototype._readUntil = function (char) {
          var start = this._index;
          this._attemptUntilChar(char);
          return this._input.substring(start, this._index);
      };
      _Tokenizer.prototype._restorePosition = function (position) {
          this._peek = position[0];
          this._index = position[1];
          this._column = position[2];
          this._line = position[3];
          var nbTokens = position[4];
          if (nbTokens < this.tokens.length) {
              // remove any extra tokens
              this.tokens = this.tokens.slice(0, nbTokens);
          }
      };
      _Tokenizer.prototype._isInExpansionCase = function () {
          return this._expansionCaseStack.length > 0 &&
              this._expansionCaseStack[this._expansionCaseStack.length - 1] ===
                  TokenType$1.EXPANSION_CASE_EXP_START;
      };
      _Tokenizer.prototype._isInExpansionForm = function () {
          return this._expansionCaseStack.length > 0 &&
              this._expansionCaseStack[this._expansionCaseStack.length - 1] ===
                  TokenType$1.EXPANSION_FORM_START;
      };
      return _Tokenizer;
  }());
  function isNotWhitespace(code) {
      return !isWhitespace(code) || code === $EOF;
  }
  function isNameEnd(code) {
      return isWhitespace(code) || code === $GT || code === $SLASH ||
          code === $SQ || code === $DQ || code === $EQ;
  }
  function isPrefixEnd(code) {
      return (code < $a || $z < code) && (code < $A || $Z < code) &&
          (code < $0 || code > $9);
  }
  function isDigitEntityEnd(code) {
      return code == $SEMICOLON || code == $EOF || !isAsciiHexDigit(code);
  }
  function isNamedEntityEnd(code) {
      return code == $SEMICOLON || code == $EOF || !isAsciiLetter(code);
  }
  function isExpansionFormStart(input, offset, interpolationConfig) {
      var isInterpolationStart = interpolationConfig ? input.indexOf(interpolationConfig.start, offset) == offset : false;
      return input.charCodeAt(offset) == $LBRACE && !isInterpolationStart;
  }
  function isExpansionCaseStart(peek) {
      return peek === $EQ || isAsciiLetter(peek);
  }
  function compareCharCodeCaseInsensitive(code1, code2) {
      return toUpperCaseCharCode(code1) == toUpperCaseCharCode(code2);
  }
  function toUpperCaseCharCode(code) {
      return code >= $a && code <= $z ? code - $a + $A : code;
  }
  function mergeTextTokens(srcTokens) {
      var dstTokens = [];
      var lastDstToken;
      for (var i = 0; i < srcTokens.length; i++) {
          var token = srcTokens[i];
          if (lastDstToken && lastDstToken.type == TokenType$1.TEXT && token.type == TokenType$1.TEXT) {
              lastDstToken.parts[0] += token.parts[0];
              lastDstToken.sourceSpan.end = token.sourceSpan.end;
          }
          else {
              lastDstToken = token;
              dstTokens.push(lastDstToken);
          }
      }
      return dstTokens;
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var __extends$4 = (this && this.__extends) || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var TreeError = (function (_super) {
      __extends$4(TreeError, _super);
      function TreeError(elementName, span, msg) {
          _super.call(this, span, msg);
          this.elementName = elementName;
      }
      TreeError.create = function (elementName, span, msg) {
          return new TreeError(elementName, span, msg);
      };
      return TreeError;
  }(ParseError));
  var ParseTreeResult = (function () {
      function ParseTreeResult(rootNodes, errors) {
          this.rootNodes = rootNodes;
          this.errors = errors;
      }
      return ParseTreeResult;
  }());
  var Parser$1 = (function () {
      function Parser(getTagDefinition) {
          this.getTagDefinition = getTagDefinition;
      }
      Parser.prototype.parse = function (source, url, parseExpansionForms, interpolationConfig) {
          if (parseExpansionForms === void 0) { parseExpansionForms = false; }
          if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }
          var tokensAndErrors = tokenize(source, url, this.getTagDefinition, parseExpansionForms, interpolationConfig);
          var treeAndErrors = new _TreeBuilder(tokensAndErrors.tokens, this.getTagDefinition).build();
          return new ParseTreeResult(treeAndErrors.rootNodes, tokensAndErrors.errors.concat(treeAndErrors.errors));
      };
      return Parser;
  }());
  var _TreeBuilder = (function () {
      function _TreeBuilder(tokens, getTagDefinition) {
          this.tokens = tokens;
          this.getTagDefinition = getTagDefinition;
          this._index = -1;
          this._rootNodes = [];
          this._errors = [];
          this._elementStack = [];
          this._advance();
      }
      _TreeBuilder.prototype.build = function () {
          while (this._peek.type !== TokenType$1.EOF) {
              if (this._peek.type === TokenType$1.TAG_OPEN_START) {
                  this._consumeStartTag(this._advance());
              }
              else if (this._peek.type === TokenType$1.TAG_CLOSE) {
                  this._consumeEndTag(this._advance());
              }
              else if (this._peek.type === TokenType$1.CDATA_START) {
                  this._closeVoidElement();
                  this._consumeCdata(this._advance());
              }
              else if (this._peek.type === TokenType$1.COMMENT_START) {
                  this._closeVoidElement();
                  this._consumeComment(this._advance());
              }
              else if (this._peek.type === TokenType$1.TEXT || this._peek.type === TokenType$1.RAW_TEXT ||
                  this._peek.type === TokenType$1.ESCAPABLE_RAW_TEXT) {
                  this._closeVoidElement();
                  this._consumeText(this._advance());
              }
              else if (this._peek.type === TokenType$1.EXPANSION_FORM_START) {
                  this._consumeExpansion(this._advance());
              }
              else {
                  // Skip all other tokens...
                  this._advance();
              }
          }
          return new ParseTreeResult(this._rootNodes, this._errors);
      };
      _TreeBuilder.prototype._advance = function () {
          var prev = this._peek;
          if (this._index < this.tokens.length - 1) {
              // Note: there is always an EOF token at the end
              this._index++;
          }
          this._peek = this.tokens[this._index];
          return prev;
      };
      _TreeBuilder.prototype._advanceIf = function (type) {
          if (this._peek.type === type) {
              return this._advance();
          }
          return null;
      };
      _TreeBuilder.prototype._consumeCdata = function (startToken) {
          this._consumeText(this._advance());
          this._advanceIf(TokenType$1.CDATA_END);
      };
      _TreeBuilder.prototype._consumeComment = function (token) {
          var text = this._advanceIf(TokenType$1.RAW_TEXT);
          this._advanceIf(TokenType$1.COMMENT_END);
          var value = isPresent(text) ? text.parts[0].trim() : null;
          this._addToParent(new Comment(value, token.sourceSpan));
      };
      _TreeBuilder.prototype._consumeExpansion = function (token) {
          var switchValue = this._advance();
          var type = this._advance();
          var cases = [];
          // read =
          while (this._peek.type === TokenType$1.EXPANSION_CASE_VALUE) {
              var expCase = this._parseExpansionCase();
              if (!expCase)
                  return; // error
              cases.push(expCase);
          }
          // read the final }
          if (this._peek.type !== TokenType$1.EXPANSION_FORM_END) {
              this._errors.push(TreeError.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '}'."));
              return;
          }
          var sourceSpan = new ParseSourceSpan(token.sourceSpan.start, this._peek.sourceSpan.end);
          this._addToParent(new Expansion(switchValue.parts[0], type.parts[0], cases, sourceSpan, switchValue.sourceSpan));
          this._advance();
      };
      _TreeBuilder.prototype._parseExpansionCase = function () {
          var value = this._advance();
          // read {
          if (this._peek.type !== TokenType$1.EXPANSION_CASE_EXP_START) {
              this._errors.push(TreeError.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '{'."));
              return null;
          }
          // read until }
          var start = this._advance();
          var exp = this._collectExpansionExpTokens(start);
          if (!exp)
              return null;
          var end = this._advance();
          exp.push(new Token$1(TokenType$1.EOF, [], end.sourceSpan));
          // parse everything in between { and }
          var parsedExp = new _TreeBuilder(exp, this.getTagDefinition).build();
          if (parsedExp.errors.length > 0) {
              this._errors = this._errors.concat(parsedExp.errors);
              return null;
          }
          var sourceSpan = new ParseSourceSpan(value.sourceSpan.start, end.sourceSpan.end);
          var expSourceSpan = new ParseSourceSpan(start.sourceSpan.start, end.sourceSpan.end);
          return new ExpansionCase(value.parts[0], parsedExp.rootNodes, sourceSpan, value.sourceSpan, expSourceSpan);
      };
      _TreeBuilder.prototype._collectExpansionExpTokens = function (start) {
          var exp = [];
          var expansionFormStack = [TokenType$1.EXPANSION_CASE_EXP_START];
          while (true) {
              if (this._peek.type === TokenType$1.EXPANSION_FORM_START ||
                  this._peek.type === TokenType$1.EXPANSION_CASE_EXP_START) {
                  expansionFormStack.push(this._peek.type);
              }
              if (this._peek.type === TokenType$1.EXPANSION_CASE_EXP_END) {
                  if (lastOnStack(expansionFormStack, TokenType$1.EXPANSION_CASE_EXP_START)) {
                      expansionFormStack.pop();
                      if (expansionFormStack.length == 0)
                          return exp;
                  }
                  else {
                      this._errors.push(TreeError.create(null, start.sourceSpan, "Invalid ICU message. Missing '}'."));
                      return null;
                  }
              }
              if (this._peek.type === TokenType$1.EXPANSION_FORM_END) {
                  if (lastOnStack(expansionFormStack, TokenType$1.EXPANSION_FORM_START)) {
                      expansionFormStack.pop();
                  }
                  else {
                      this._errors.push(TreeError.create(null, start.sourceSpan, "Invalid ICU message. Missing '}'."));
                      return null;
                  }
              }
              if (this._peek.type === TokenType$1.EOF) {
                  this._errors.push(TreeError.create(null, start.sourceSpan, "Invalid ICU message. Missing '}'."));
                  return null;
              }
              exp.push(this._advance());
          }
      };
      _TreeBuilder.prototype._consumeText = function (token) {
          var text = token.parts[0];
          if (text.length > 0 && text[0] == '\n') {
              var parent_1 = this._getParentElement();
              if (isPresent(parent_1) && parent_1.children.length == 0 &&
                  this.getTagDefinition(parent_1.name).ignoreFirstLf) {
                  text = text.substring(1);
              }
          }
          if (text.length > 0) {
              this._addToParent(new Text(text, token.sourceSpan));
          }
      };
      _TreeBuilder.prototype._closeVoidElement = function () {
          if (this._elementStack.length > 0) {
              var el = ListWrapper.last(this._elementStack);
              if (this.getTagDefinition(el.name).isVoid) {
                  this._elementStack.pop();
              }
          }
      };
      _TreeBuilder.prototype._consumeStartTag = function (startTagToken) {
          var prefix = startTagToken.parts[0];
          var name = startTagToken.parts[1];
          var attrs = [];
          while (this._peek.type === TokenType$1.ATTR_NAME) {
              attrs.push(this._consumeAttr(this._advance()));
          }
          var fullName = this._getElementFullName(prefix, name, this._getParentElement());
          var selfClosing = false;
          // Note: There could have been a tokenizer error
          // so that we don't get a token for the end tag...
          if (this._peek.type === TokenType$1.TAG_OPEN_END_VOID) {
              this._advance();
              selfClosing = true;
              var tagDef = this.getTagDefinition(fullName);
              if (!(tagDef.canSelfClose || getNsPrefix(fullName) !== null || tagDef.isVoid)) {
                  this._errors.push(TreeError.create(fullName, startTagToken.sourceSpan, "Only void and foreign elements can be self closed \"" + startTagToken.parts[1] + "\""));
              }
          }
          else if (this._peek.type === TokenType$1.TAG_OPEN_END) {
              this._advance();
              selfClosing = false;
          }
          var end = this._peek.sourceSpan.start;
          var span = new ParseSourceSpan(startTagToken.sourceSpan.start, end);
          var el = new Element(fullName, attrs, [], span, span, null);
          this._pushElement(el);
          if (selfClosing) {
              this._popElement(fullName);
              el.endSourceSpan = span;
          }
      };
      _TreeBuilder.prototype._pushElement = function (el) {
          if (this._elementStack.length > 0) {
              var parentEl = ListWrapper.last(this._elementStack);
              if (this.getTagDefinition(parentEl.name).isClosedByChild(el.name)) {
                  this._elementStack.pop();
              }
          }
          var tagDef = this.getTagDefinition(el.name);
          var _a = this._getParentElementSkippingContainers(), parent = _a.parent, container = _a.container;
          if (isPresent(parent) && tagDef.requireExtraParent(parent.name)) {
              var newParent = new Element(tagDef.parentToAdd, [], [], el.sourceSpan, el.startSourceSpan, el.endSourceSpan);
              this._insertBeforeContainer(parent, container, newParent);
          }
          this._addToParent(el);
          this._elementStack.push(el);
      };
      _TreeBuilder.prototype._consumeEndTag = function (endTagToken) {
          var fullName = this._getElementFullName(endTagToken.parts[0], endTagToken.parts[1], this._getParentElement());
          if (this._getParentElement()) {
              this._getParentElement().endSourceSpan = endTagToken.sourceSpan;
          }
          if (this.getTagDefinition(fullName).isVoid) {
              this._errors.push(TreeError.create(fullName, endTagToken.sourceSpan, "Void elements do not have end tags \"" + endTagToken.parts[1] + "\""));
          }
          else if (!this._popElement(fullName)) {
              this._errors.push(TreeError.create(fullName, endTagToken.sourceSpan, "Unexpected closing tag \"" + endTagToken.parts[1] + "\""));
          }
      };
      _TreeBuilder.prototype._popElement = function (fullName) {
          for (var stackIndex = this._elementStack.length - 1; stackIndex >= 0; stackIndex--) {
              var el = this._elementStack[stackIndex];
              if (el.name == fullName) {
                  ListWrapper.splice(this._elementStack, stackIndex, this._elementStack.length - stackIndex);
                  return true;
              }
              if (!this.getTagDefinition(el.name).closedByParent) {
                  return false;
              }
          }
          return false;
      };
      _TreeBuilder.prototype._consumeAttr = function (attrName) {
          var fullName = mergeNsAndName(attrName.parts[0], attrName.parts[1]);
          var end = attrName.sourceSpan.end;
          var value = '';
          var valueSpan;
          if (this._peek.type === TokenType$1.ATTR_VALUE) {
              var valueToken = this._advance();
              value = valueToken.parts[0];
              end = valueToken.sourceSpan.end;
              valueSpan = valueToken.sourceSpan;
          }
          return new Attribute$1(fullName, value, new ParseSourceSpan(attrName.sourceSpan.start, end), valueSpan);
      };
      _TreeBuilder.prototype._getParentElement = function () {
          return this._elementStack.length > 0 ? ListWrapper.last(this._elementStack) : null;
      };
      /**
       * Returns the parent in the DOM and the container.
       *
       * `<ng-container>` elements are skipped as they are not rendered as DOM element.
       */
      _TreeBuilder.prototype._getParentElementSkippingContainers = function () {
          var container = null;
          for (var i = this._elementStack.length - 1; i >= 0; i--) {
              if (this._elementStack[i].name !== 'ng-container') {
                  return { parent: this._elementStack[i], container: container };
              }
              container = this._elementStack[i];
          }
          return { parent: ListWrapper.last(this._elementStack), container: container };
      };
      _TreeBuilder.prototype._addToParent = function (node) {
          var parent = this._getParentElement();
          if (isPresent(parent)) {
              parent.children.push(node);
          }
          else {
              this._rootNodes.push(node);
          }
      };
      /**
       * Insert a node between the parent and the container.
       * When no container is given, the node is appended as a child of the parent.
       * Also updates the element stack accordingly.
       *
       * @internal
       */
      _TreeBuilder.prototype._insertBeforeContainer = function (parent, container, node) {
          if (!container) {
              this._addToParent(node);
              this._elementStack.push(node);
          }
          else {
              if (parent) {
                  // replace the container with the new node in the children
                  var index = parent.children.indexOf(container);
                  parent.children[index] = node;
              }
              else {
                  this._rootNodes.push(node);
              }
              node.children.push(container);
              this._elementStack.splice(this._elementStack.indexOf(container), 0, node);
          }
      };
      _TreeBuilder.prototype._getElementFullName = function (prefix, localName, parentElement) {
          if (isBlank(prefix)) {
              prefix = this.getTagDefinition(localName).implicitNamespacePrefix;
              if (isBlank(prefix) && isPresent(parentElement)) {
                  prefix = getNsPrefix(parentElement.name);
              }
          }
          return mergeNsAndName(prefix, localName);
      };
      return _TreeBuilder;
  }());
  function lastOnStack(stack, element) {
      return stack.length > 0 && stack[stack.length - 1] === element;
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function digestMessage(message) {
      return sha1(serializeNodes(message.nodes).join('') + ("[" + message.meaning + "]"));
  }
  /**
   * Serialize the i18n ast to something xml-like in order to generate an UID.
   *
   * The visitor is also used in the i18n parser tests
   *
   * @internal
   */
  var _SerializerVisitor = (function () {
      function _SerializerVisitor() {
      }
      _SerializerVisitor.prototype.visitText = function (text, context) { return text.value; };
      _SerializerVisitor.prototype.visitContainer = function (container, context) {
          var _this = this;
          return "[" + container.children.map(function (child) { return child.visit(_this); }).join(', ') + "]";
      };
      _SerializerVisitor.prototype.visitIcu = function (icu, context) {
          var _this = this;
          var strCases = Object.keys(icu.cases).map(function (k) { return (k + " {" + icu.cases[k].visit(_this) + "}"); });
          return "{" + icu.expression + ", " + icu.type + ", " + strCases.join(', ') + "}";
      };
      _SerializerVisitor.prototype.visitTagPlaceholder = function (ph, context) {
          var _this = this;
          return ph.isVoid ?
              "<ph tag name=\"" + ph.startName + "\"/>" :
              "<ph tag name=\"" + ph.startName + "\">" + ph.children.map(function (child) { return child.visit(_this); }).join(', ') + "</ph name=\"" + ph.closeName + "\">";
      };
      _SerializerVisitor.prototype.visitPlaceholder = function (ph, context) {
          return "<ph name=\"" + ph.name + "\">" + ph.value + "</ph>";
      };
      _SerializerVisitor.prototype.visitIcuPlaceholder = function (ph, context) {
          return "<ph icu name=\"" + ph.name + "\">" + ph.value.visit(this) + "</ph>";
      };
      return _SerializerVisitor;
  }());
  var serializerVisitor = new _SerializerVisitor();
  function serializeNodes(nodes) {
      return nodes.map(function (a) { return a.visit(serializerVisitor, null); });
  }
  /**
   * Compute the SHA1 of the given string
   *
   * see http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf
   *
   * WARNING: this function has not been designed not tested with security in mind.
   *          DO NOT USE IT IN A SECURITY SENSITIVE CONTEXT.
   */
  function sha1(str) {
      var utf8 = utf8Encode(str);
      var words32 = stringToWords32(utf8);
      var len = utf8.length * 8;
      var w = new Array(80);
      var _a = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0], a = _a[0], b = _a[1], c = _a[2], d = _a[3], e = _a[4];
      words32[len >> 5] |= 0x80 << (24 - len % 32);
      words32[((len + 64 >> 9) << 4) + 15] = len;
      for (var i = 0; i < words32.length; i += 16) {
          var _b = [a, b, c, d, e], h0 = _b[0], h1 = _b[1], h2 = _b[2], h3 = _b[3], h4 = _b[4];
          for (var j = 0; j < 80; j++) {
              if (j < 16) {
                  w[j] = words32[i + j];
              }
              else {
                  w[j] = rol32(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);
              }
              var _c = fk(j, b, c, d), f = _c[0], k = _c[1];
              var temp = [rol32(a, 5), f, e, k, w[j]].reduce(add32);
              _d = [d, c, rol32(b, 30), a, temp], e = _d[0], d = _d[1], c = _d[2], b = _d[3], a = _d[4];
          }
          _e = [add32(a, h0), add32(b, h1), add32(c, h2), add32(d, h3), add32(e, h4)], a = _e[0], b = _e[1], c = _e[2], d = _e[3], e = _e[4];
      }
      var sha1 = words32ToString([a, b, c, d, e]);
      var hex = '';
      for (var i = 0; i < sha1.length; i++) {
          var b_1 = sha1.charCodeAt(i);
          hex += (b_1 >>> 4 & 0x0f).toString(16) + (b_1 & 0x0f).toString(16);
      }
      return hex.toLowerCase();
      var _d, _e;
  }
  function utf8Encode(str) {
      var encoded = '';
      for (var index = 0; index < str.length; index++) {
          var codePoint = decodeSurrogatePairs(str, index);
          if (codePoint <= 0x7f) {
              encoded += String.fromCharCode(codePoint);
          }
          else if (codePoint <= 0x7ff) {
              encoded += String.fromCharCode(0xc0 | codePoint >>> 6, 0x80 | codePoint & 0x3f);
          }
          else if (codePoint <= 0xffff) {
              encoded += String.fromCharCode(0xe0 | codePoint >>> 12, 0x80 | codePoint >>> 6 & 0x3f, 0x80 | codePoint & 0x3f);
          }
          else if (codePoint <= 0x1fffff) {
              encoded += String.fromCharCode(0xf0 | codePoint >>> 18, 0x80 | codePoint >>> 12 & 0x3f, 0x80 | codePoint >>> 6 & 0x3f, 0x80 | codePoint & 0x3f);
          }
      }
      return encoded;
  }
  // see https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
  function decodeSurrogatePairs(str, index) {
      if (index < 0 || index >= str.length) {
          throw new Error("index=" + index + " is out of range in \"" + str + "\"");
      }
      var high = str.charCodeAt(index);
      var low;
      if (high >= 0xd800 && high <= 0xdfff && str.length > index + 1) {
          low = str.charCodeAt(index + 1);
          if (low >= 0xdc00 && low <= 0xdfff) {
              return (high - 0xd800) * 0x400 + low - 0xdc00 + 0x10000;
          }
      }
      return high;
  }
  function stringToWords32(str) {
      var words32 = Array(str.length >>> 2);
      for (var i = 0; i < words32.length; i++) {
          words32[i] = 0;
      }
      for (var i = 0; i < str.length; i++) {
          words32[i >>> 2] |= (str.charCodeAt(i) & 0xff) << 8 * (3 - i & 0x3);
      }
      return words32;
  }
  function words32ToString(words32) {
      var str = '';
      for (var i = 0; i < words32.length * 4; i++) {
          str += String.fromCharCode((words32[i >>> 2] >>> 8 * (3 - i & 0x3)) & 0xff);
      }
      return str;
  }
  function fk(index, b, c, d) {
      if (index < 20) {
          return [(b & c) | (~b & d), 0x5a827999];
      }
      if (index < 40) {
          return [b ^ c ^ d, 0x6ed9eba1];
      }
      if (index < 60) {
          return [(b & c) | (b & d) | (c & d), 0x8f1bbcdc];
      }
      return [b ^ c ^ d, 0xca62c1d6];
  }
  function add32(a, b) {
      var low = (a & 0xffff) + (b & 0xffff);
      var high = (a >> 16) + (b >> 16) + (low >> 16);
      return (high << 16) | (low & 0xffff);
  }
  function rol32(a, count) {
      return (a << count) | (a >>> (32 - count));
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var Message = (function () {
      /**
       * @param nodes message AST
       * @param placeholders maps placeholder names to static content
       * @param placeholderToMsgIds maps placeholder names to translatable message IDs (used for ICU
       *                            messages)
       * @param meaning
       * @param description
       */
      function Message(nodes, placeholders, placeholderToMsgIds, meaning, description) {
          this.nodes = nodes;
          this.placeholders = placeholders;
          this.placeholderToMsgIds = placeholderToMsgIds;
          this.meaning = meaning;
          this.description = description;
      }
      return Message;
  }());
  var Text$1 = (function () {
      function Text(value, sourceSpan) {
          this.value = value;
          this.sourceSpan = sourceSpan;
      }
      Text.prototype.visit = function (visitor, context) { return visitor.visitText(this, context); };
      return Text;
  }());
  var Container = (function () {
      function Container(children, sourceSpan) {
          this.children = children;
          this.sourceSpan = sourceSpan;
      }
      Container.prototype.visit = function (visitor, context) { return visitor.visitContainer(this, context); };
      return Container;
  }());
  var Icu = (function () {
      function Icu(expression, type, cases, sourceSpan) {
          this.expression = expression;
          this.type = type;
          this.cases = cases;
          this.sourceSpan = sourceSpan;
      }
      Icu.prototype.visit = function (visitor, context) { return visitor.visitIcu(this, context); };
      return Icu;
  }());
  var TagPlaceholder = (function () {
      function TagPlaceholder(tag, attrs, startName, closeName, children, isVoid, sourceSpan) {
          this.tag = tag;
          this.attrs = attrs;
          this.startName = startName;
          this.closeName = closeName;
          this.children = children;
          this.isVoid = isVoid;
          this.sourceSpan = sourceSpan;
      }
      TagPlaceholder.prototype.visit = function (visitor, context) { return visitor.visitTagPlaceholder(this, context); };
      return TagPlaceholder;
  }());
  var Placeholder = (function () {
      function Placeholder(value, name, sourceSpan) {
          if (name === void 0) { name = ''; }
          this.value = value;
          this.name = name;
          this.sourceSpan = sourceSpan;
      }
      Placeholder.prototype.visit = function (visitor, context) { return visitor.visitPlaceholder(this, context); };
      return Placeholder;
  }());
  var IcuPlaceholder = (function () {
      function IcuPlaceholder(value, name, sourceSpan) {
          if (name === void 0) { name = ''; }
          this.value = value;
          this.name = name;
          this.sourceSpan = sourceSpan;
      }
      IcuPlaceholder.prototype.visit = function (visitor, context) { return visitor.visitIcuPlaceholder(this, context); };
      return IcuPlaceholder;
  }());

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var TAG_TO_PLACEHOLDER_NAMES = {
      'A': 'LINK',
      'B': 'BOLD_TEXT',
      'BR': 'LINE_BREAK',
      'EM': 'EMPHASISED_TEXT',
      'H1': 'HEADING_LEVEL1',
      'H2': 'HEADING_LEVEL2',
      'H3': 'HEADING_LEVEL3',
      'H4': 'HEADING_LEVEL4',
      'H5': 'HEADING_LEVEL5',
      'H6': 'HEADING_LEVEL6',
      'HR': 'HORIZONTAL_RULE',
      'I': 'ITALIC_TEXT',
      'LI': 'LIST_ITEM',
      'LINK': 'MEDIA_LINK',
      'OL': 'ORDERED_LIST',
      'P': 'PARAGRAPH',
      'Q': 'QUOTATION',
      'S': 'STRIKETHROUGH_TEXT',
      'SMALL': 'SMALL_TEXT',
      'SUB': 'SUBSTRIPT',
      'SUP': 'SUPERSCRIPT',
      'TBODY': 'TABLE_BODY',
      'TD': 'TABLE_CELL',
      'TFOOT': 'TABLE_FOOTER',
      'TH': 'TABLE_HEADER_CELL',
      'THEAD': 'TABLE_HEADER',
      'TR': 'TABLE_ROW',
      'TT': 'MONOSPACED_TEXT',
      'U': 'UNDERLINED_TEXT',
      'UL': 'UNORDERED_LIST',
  };
  /**
   * Creates unique names for placeholder with different content
   *
   * @internal
   */
  var PlaceholderRegistry = (function () {
      function PlaceholderRegistry() {
          // Count the occurrence of the base name top generate a unique name
          this._placeHolderNameCounts = {};
          // Maps signature to placeholder names
          this._signatureToName = {};
      }
      PlaceholderRegistry.prototype.getStartTagPlaceholderName = function (tag, attrs, isVoid) {
          var signature = this._hashTag(tag, attrs, isVoid);
          if (this._signatureToName[signature]) {
              return this._signatureToName[signature];
          }
          var upperTag = tag.toUpperCase();
          var baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || "TAG_" + upperTag;
          var name = this._generateUniqueName(isVoid ? baseName : "START_" + baseName);
          this._signatureToName[signature] = name;
          return name;
      };
      PlaceholderRegistry.prototype.getCloseTagPlaceholderName = function (tag) {
          var signature = this._hashClosingTag(tag);
          if (this._signatureToName[signature]) {
              return this._signatureToName[signature];
          }
          var upperTag = tag.toUpperCase();
          var baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || "TAG_" + upperTag;
          var name = this._generateUniqueName("CLOSE_" + baseName);
          this._signatureToName[signature] = name;
          return name;
      };
      PlaceholderRegistry.prototype.getPlaceholderName = function (name, content) {
          var upperName = name.toUpperCase();
          var signature = "PH: " + upperName + "=" + content;
          if (this._signatureToName[signature]) {
              return this._signatureToName[signature];
          }
          var uniqueName = this._generateUniqueName(upperName);
          this._signatureToName[signature] = uniqueName;
          return uniqueName;
      };
      // Generate a hash for a tag - does not take attribute order into account
      PlaceholderRegistry.prototype._hashTag = function (tag, attrs, isVoid) {
          var start = "<" + tag;
          var strAttrs = Object.keys(attrs).sort().map(function (name) { return (" " + name + "=" + attrs[name]); }).join('');
          var end = isVoid ? '/>' : "></" + tag + ">";
          return start + strAttrs + end;
      };
      PlaceholderRegistry.prototype._hashClosingTag = function (tag) { return this._hashTag("/" + tag, {}, false); };
      PlaceholderRegistry.prototype._generateUniqueName = function (base) {
          var name = base;
          var next = this._placeHolderNameCounts[name];
          if (!next) {
              next = 1;
          }
          else {
              name += "_" + next;
              next++;
          }
          this._placeHolderNameCounts[base] = next;
          return name;
      };
      return PlaceholderRegistry;
  }());

  var _expParser = new Parser(new Lexer());
  /**
   * Returns a function converting html nodes to an i18n Message given an interpolationConfig
   */
  function createI18nMessageFactory(interpolationConfig) {
      var visitor = new _I18nVisitor(_expParser, interpolationConfig);
      return function (nodes, meaning, description) {
          return visitor.toI18nMessage(nodes, meaning, description);
      };
  }
  var _I18nVisitor = (function () {
      function _I18nVisitor(_expressionParser, _interpolationConfig) {
          this._expressionParser = _expressionParser;
          this._interpolationConfig = _interpolationConfig;
      }
      _I18nVisitor.prototype.toI18nMessage = function (nodes, meaning, description) {
          this._isIcu = nodes.length == 1 && nodes[0] instanceof Expansion;
          this._icuDepth = 0;
          this._placeholderRegistry = new PlaceholderRegistry();
          this._placeholderToContent = {};
          this._placeholderToIds = {};
          var i18nodes = visitAll(this, nodes, {});
          return new Message(i18nodes, this._placeholderToContent, this._placeholderToIds, meaning, description);
      };
      _I18nVisitor.prototype.visitElement = function (el, context) {
          var children = visitAll(this, el.children);
          var attrs = {};
          el.attrs.forEach(function (attr) {
              // Do not visit the attributes, translatable ones are top-level ASTs
              attrs[attr.name] = attr.value;
          });
          var isVoid = getHtmlTagDefinition(el.name).isVoid;
          var startPhName = this._placeholderRegistry.getStartTagPlaceholderName(el.name, attrs, isVoid);
          this._placeholderToContent[startPhName] = el.sourceSpan.toString();
          var closePhName = '';
          if (!isVoid) {
              closePhName = this._placeholderRegistry.getCloseTagPlaceholderName(el.name);
              this._placeholderToContent[closePhName] = "</" + el.name + ">";
          }
          return new TagPlaceholder(el.name, attrs, startPhName, closePhName, children, isVoid, el.sourceSpan);
      };
      _I18nVisitor.prototype.visitAttribute = function (attribute, context) {
          return this._visitTextWithInterpolation(attribute.value, attribute.sourceSpan);
      };
      _I18nVisitor.prototype.visitText = function (text, context) {
          return this._visitTextWithInterpolation(text.value, text.sourceSpan);
      };
      _I18nVisitor.prototype.visitComment = function (comment, context) { return null; };
      _I18nVisitor.prototype.visitExpansion = function (icu, context) {
          var _this = this;
          this._icuDepth++;
          var i18nIcuCases = {};
          var i18nIcu = new Icu(icu.switchValue, icu.type, i18nIcuCases, icu.sourceSpan);
          icu.cases.forEach(function (caze) {
              i18nIcuCases[caze.value] = new Container(caze.expression.map(function (node) { return node.visit(_this, {}); }), caze.expSourceSpan);
          });
          this._icuDepth--;
          if (this._isIcu || this._icuDepth > 0) {
              // If the message (vs a part of the message) is an ICU message returns it
              return i18nIcu;
          }
          // Else returns a placeholder
          // ICU placeholders should not be replaced with their original content but with the their
          // translations. We need to create a new visitor (they are not re-entrant) to compute the
          // message id.
          // TODO(vicb): add a html.Node -> i18n.Message cache to avoid having to re-create the msg
          var phName = this._placeholderRegistry.getPlaceholderName('ICU', icu.sourceSpan.toString());
          var visitor = new _I18nVisitor(this._expressionParser, this._interpolationConfig);
          this._placeholderToIds[phName] = digestMessage(visitor.toI18nMessage([icu], '', ''));
          return new IcuPlaceholder(i18nIcu, phName, icu.sourceSpan);
      };
      _I18nVisitor.prototype.visitExpansionCase = function (icuCase, context) {
          throw new Error('Unreachable code');
      };
      _I18nVisitor.prototype._visitTextWithInterpolation = function (text, sourceSpan) {
          var splitInterpolation = this._expressionParser.splitInterpolation(text, sourceSpan.start.toString(), this._interpolationConfig);
          if (!splitInterpolation) {
              // No expression, return a single text
              return new Text$1(text, sourceSpan);
          }
          // Return a group of text + expressions
          var nodes = [];
          var container = new Container(nodes, sourceSpan);
          var _a = this._interpolationConfig, sDelimiter = _a.start, eDelimiter = _a.end;
          for (var i = 0; i < splitInterpolation.strings.length - 1; i++) {
              var expression = splitInterpolation.expressions[i];
              var baseName = _extractPlaceholderName(expression) || 'INTERPOLATION';
              var phName = this._placeholderRegistry.getPlaceholderName(baseName, expression);
              if (splitInterpolation.strings[i].length) {
                  // No need to add empty strings
                  nodes.push(new Text$1(splitInterpolation.strings[i], sourceSpan));
              }
              nodes.push(new Placeholder(expression, phName, sourceSpan));
              this._placeholderToContent[phName] = sDelimiter + expression + eDelimiter;
          }
          // The last index contains no expression
          var lastStringIdx = splitInterpolation.strings.length - 1;
          if (splitInterpolation.strings[lastStringIdx].length) {
              nodes.push(new Text$1(splitInterpolation.strings[lastStringIdx], sourceSpan));
          }
          return container;
      };
      return _I18nVisitor;
  }());
  var _CUSTOM_PH_EXP = /\/\/[\s\S]*i18n[\s\S]*\([\s\S]*ph[\s\S]*=[\s\S]*"([\s\S]*?)"[\s\S]*\)/g;
  function _extractPlaceholderName(input) {
      return input.split(_CUSTOM_PH_EXP)[1];
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var __extends$6 = (this && this.__extends) || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  /**
   * An i18n error.
   */
  var I18nError = (function (_super) {
      __extends$6(I18nError, _super);
      function I18nError(span, msg) {
          _super.call(this, span, msg);
      }
      return I18nError;
  }(ParseError));

  var _I18N_ATTR = 'i18n';
  var _I18N_ATTR_PREFIX = 'i18n-';
  var _I18N_COMMENT_PREFIX_REGEXP = /^i18n:?/;
  /**
   * Extract translatable messages from an html AST
   */
  function extractMessages(nodes, interpolationConfig, implicitTags, implicitAttrs) {
      var visitor = new _Visitor(implicitTags, implicitAttrs);
      return visitor.extract(nodes, interpolationConfig);
  }
  function mergeTranslations(nodes, translations, interpolationConfig, implicitTags, implicitAttrs) {
      var visitor = new _Visitor(implicitTags, implicitAttrs);
      return visitor.merge(nodes, translations, interpolationConfig);
  }
  var ExtractionResult = (function () {
      function ExtractionResult(messages, errors) {
          this.messages = messages;
          this.errors = errors;
      }
      return ExtractionResult;
  }());
  var _VisitorMode;
  (function (_VisitorMode) {
      _VisitorMode[_VisitorMode["Extract"] = 0] = "Extract";
      _VisitorMode[_VisitorMode["Merge"] = 1] = "Merge";
  })(_VisitorMode || (_VisitorMode = {}));
  /**
   * This Visitor is used:
   * 1. to extract all the translatable strings from an html AST (see `extract()`),
   * 2. to replace the translatable strings with the actual translations (see `merge()`)
   *
   * @internal
   */
  var _Visitor = (function () {
      function _Visitor(_implicitTags, _implicitAttrs) {
          this._implicitTags = _implicitTags;
          this._implicitAttrs = _implicitAttrs;
      }
      /**
       * Extracts the messages from the tree
       */
      _Visitor.prototype.extract = function (nodes, interpolationConfig) {
          var _this = this;
          this._init(_VisitorMode.Extract, interpolationConfig);
          nodes.forEach(function (node) { return node.visit(_this, null); });
          if (this._inI18nBlock) {
              this._reportError(nodes[nodes.length - 1], 'Unclosed block');
          }
          return new ExtractionResult(this._messages, this._errors);
      };
      /**
       * Returns a tree where all translatable nodes are translated
       */
      _Visitor.prototype.merge = function (nodes, translations, interpolationConfig) {
          this._init(_VisitorMode.Merge, interpolationConfig);
          this._translations = translations;
          // Construct a single fake root element
          var wrapper = new Element('wrapper', [], nodes, null, null, null);
          var translatedNode = wrapper.visit(this, null);
          if (this._inI18nBlock) {
              this._reportError(nodes[nodes.length - 1], 'Unclosed block');
          }
          return new ParseTreeResult(translatedNode.children, this._errors);
      };
      _Visitor.prototype.visitExpansionCase = function (icuCase, context) {
          // Parse cases for translatable html attributes
          var expression = visitAll(this, icuCase.expression, context);
          if (this._mode === _VisitorMode.Merge) {
              return new ExpansionCase(icuCase.value, expression, icuCase.sourceSpan, icuCase.valueSourceSpan, icuCase.expSourceSpan);
          }
      };
      _Visitor.prototype.visitExpansion = function (icu, context) {
          this._mayBeAddBlockChildren(icu);
          var wasInIcu = this._inIcu;
          if (!this._inIcu) {
              // nested ICU messages should not be extracted but top-level translated as a whole
              if (this._isInTranslatableSection) {
                  this._addMessage([icu]);
              }
              this._inIcu = true;
          }
          var cases = visitAll(this, icu.cases, context);
          if (this._mode === _VisitorMode.Merge) {
              icu = new Expansion(icu.switchValue, icu.type, cases, icu.sourceSpan, icu.switchValueSourceSpan);
          }
          this._inIcu = wasInIcu;
          return icu;
      };
      _Visitor.prototype.visitComment = function (comment, context) {
          var isOpening = _isOpeningComment(comment);
          if (isOpening && this._isInTranslatableSection) {
              this._reportError(comment, 'Could not start a block inside a translatable section');
              return;
          }
          var isClosing = _isClosingComment(comment);
          if (isClosing && !this._inI18nBlock) {
              this._reportError(comment, 'Trying to close an unopened block');
              return;
          }
          if (!this._inI18nNode && !this._inIcu) {
              if (!this._inI18nBlock) {
                  if (isOpening) {
                      this._inI18nBlock = true;
                      this._blockStartDepth = this._depth;
                      this._blockChildren = [];
                      this._blockMeaningAndDesc = comment.value.replace(_I18N_COMMENT_PREFIX_REGEXP, '').trim();
                      this._openTranslatableSection(comment);
                  }
              }
              else {
                  if (isClosing) {
                      if (this._depth == this._blockStartDepth) {
                          this._closeTranslatableSection(comment, this._blockChildren);
                          this._inI18nBlock = false;
                          var message = this._addMessage(this._blockChildren, this._blockMeaningAndDesc);
                          // merge attributes in sections
                          var nodes = this._translateMessage(comment, message);
                          return visitAll(this, nodes);
                      }
                      else {
                          this._reportError(comment, 'I18N blocks should not cross element boundaries');
                          return;
                      }
                  }
              }
          }
      };
      _Visitor.prototype.visitText = function (text, context) {
          if (this._isInTranslatableSection) {
              this._mayBeAddBlockChildren(text);
          }
          return text;
      };
      _Visitor.prototype.visitElement = function (el, context) {
          var _this = this;
          this._mayBeAddBlockChildren(el);
          this._depth++;
          var wasInI18nNode = this._inI18nNode;
          var wasInImplicitNode = this._inImplicitNode;
          var childNodes;
          // Extract only top level nodes with the (implicit) "i18n" attribute if not in a block or an ICU
          // message
          var i18nAttr = _getI18nAttr(el);
          var isImplicit = this._implicitTags.some(function (tag) { return el.name === tag; }) &&
              !this._inIcu && !this._isInTranslatableSection;
          var isTopLevelImplicit = !wasInImplicitNode && isImplicit;
          this._inImplicitNode = this._inImplicitNode || isImplicit;
          if (!this._isInTranslatableSection && !this._inIcu) {
              if (i18nAttr) {
                  // explicit translation
                  this._inI18nNode = true;
                  var message = this._addMessage(el.children, i18nAttr.value);
                  childNodes = this._translateMessage(el, message);
              }
              else if (isTopLevelImplicit) {
                  // implicit translation
                  this._inI18nNode = true;
                  var message = this._addMessage(el.children);
                  childNodes = this._translateMessage(el, message);
              }
              if (this._mode == _VisitorMode.Extract) {
                  var isTranslatable = i18nAttr || isTopLevelImplicit;
                  if (isTranslatable) {
                      this._openTranslatableSection(el);
                  }
                  visitAll(this, el.children);
                  if (isTranslatable) {
                      this._closeTranslatableSection(el, el.children);
                  }
              }
              if (this._mode === _VisitorMode.Merge && !i18nAttr && !isTopLevelImplicit) {
                  childNodes = [];
                  el.children.forEach(function (child) {
                      var visited = child.visit(_this, context);
                      if (visited && !_this._isInTranslatableSection) {
                          // Do not add the children from translatable sections (= i18n blocks here)
                          // They will be added when the section is close (i.e. on `<!-- /i18n -->`)
                          childNodes = childNodes.concat(visited);
                      }
                  });
              }
          }
          else {
              if (i18nAttr || isTopLevelImplicit) {
                  this._reportError(el, 'Could not mark an element as translatable inside a translatable section');
              }
              if (this._mode == _VisitorMode.Extract) {
                  // Descend into child nodes for extraction
                  visitAll(this, el.children);
              }
              if (this._mode == _VisitorMode.Merge) {
                  // Translate attributes in ICU messages
                  childNodes = [];
                  el.children.forEach(function (child) {
                      var visited = child.visit(_this, context);
                      if (visited && !_this._isInTranslatableSection) {
                          // Do not add the children from translatable sections (= i18n blocks here)
                          // They will be added when the section is close (i.e. on `<!-- /i18n -->`)
                          childNodes = childNodes.concat(visited);
                      }
                  });
              }
          }
          this._visitAttributesOf(el);
          this._depth--;
          this._inI18nNode = wasInI18nNode;
          this._inImplicitNode = wasInImplicitNode;
          if (this._mode === _VisitorMode.Merge) {
              // There are no childNodes in translatable sections - those nodes will be replace anyway
              var translatedAttrs = this._translateAttributes(el);
              return new Element(el.name, translatedAttrs, childNodes, el.sourceSpan, el.startSourceSpan, el.endSourceSpan);
          }
      };
      _Visitor.prototype.visitAttribute = function (attribute, context) {
          throw new Error('unreachable code');
      };
      _Visitor.prototype._init = function (mode, interpolationConfig) {
          this._mode = mode;
          this._inI18nBlock = false;
          this._inI18nNode = false;
          this._depth = 0;
          this._inIcu = false;
          this._msgCountAtSectionStart = void 0;
          this._errors = [];
          this._messages = [];
          this._inImplicitNode = false;
          this._createI18nMessage = createI18nMessageFactory(interpolationConfig);
      };
      // looks for translatable attributes
      _Visitor.prototype._visitAttributesOf = function (el) {
          var _this = this;
          var explicitAttrNameToValue = {};
          var implicitAttrNames = this._implicitAttrs[el.name] || [];
          el.attrs.filter(function (attr) { return attr.name.startsWith(_I18N_ATTR_PREFIX); })
              .forEach(function (attr) { return explicitAttrNameToValue[attr.name.slice(_I18N_ATTR_PREFIX.length)] =
              attr.value; });
          el.attrs.forEach(function (attr) {
              if (attr.name in explicitAttrNameToValue) {
                  _this._addMessage([attr], explicitAttrNameToValue[attr.name]);
              }
              else if (implicitAttrNames.some(function (name) { return attr.name === name; })) {
                  _this._addMessage([attr]);
              }
          });
      };
      // add a translatable message
      _Visitor.prototype._addMessage = function (ast, meaningAndDesc) {
          if (ast.length == 0 ||
              ast.length == 1 && ast[0] instanceof Attribute$1 && !ast[0].value) {
              // Do not create empty messages
              return;
          }
          var _a = _splitMeaningAndDesc(meaningAndDesc), meaning = _a[0], description = _a[1];
          var message = this._createI18nMessage(ast, meaning, description);
          this._messages.push(message);
          return message;
      };
      // Translates the given message given the `TranslationBundle`
      // no-op when called in extraction mode (returns [])
      _Visitor.prototype._translateMessage = function (el, message) {
          if (message && this._mode === _VisitorMode.Merge) {
              var id = digestMessage(message);
              var nodes = this._translations.get(id);
              if (nodes) {
                  return nodes;
              }
              this._reportError(el, "Translation unavailable for message id=\"" + id + "\"");
          }
          return [];
      };
      // translate the attributes of an element and remove i18n specific attributes
      _Visitor.prototype._translateAttributes = function (el) {
          var _this = this;
          var attributes = el.attrs;
          var i18nAttributeMeanings = {};
          attributes.forEach(function (attr) {
              if (attr.name.startsWith(_I18N_ATTR_PREFIX)) {
                  i18nAttributeMeanings[attr.name.slice(_I18N_ATTR_PREFIX.length)] =
                      _splitMeaningAndDesc(attr.value)[0];
              }
          });
          var translatedAttributes = [];
          attributes.forEach(function (attr) {
              if (attr.name === _I18N_ATTR || attr.name.startsWith(_I18N_ATTR_PREFIX)) {
                  // strip i18n specific attributes
                  return;
              }
              if (attr.value && attr.value != '' && i18nAttributeMeanings.hasOwnProperty(attr.name)) {
                  var meaning = i18nAttributeMeanings[attr.name];
                  var message = _this._createI18nMessage([attr], meaning, '');
                  var id = digestMessage(message);
                  var nodes = _this._translations.get(id);
                  if (nodes) {
                      if (nodes[0] instanceof Text) {
                          var value = nodes[0].value;
                          translatedAttributes.push(new Attribute$1(attr.name, value, attr.sourceSpan));
                      }
                      else {
                          _this._reportError(el, "Unexpected translation for attribute \"" + attr.name + "\" (id=\"" + id + "\")");
                      }
                  }
                  else {
                      _this._reportError(el, "Translation unavailable for attribute \"" + attr.name + "\" (id=\"" + id + "\")");
                  }
              }
              else {
                  translatedAttributes.push(attr);
              }
          });
          return translatedAttributes;
      };
      /**
       * Add the node as a child of the block when:
       * - we are in a block,
       * - we are not inside a ICU message (those are handled separately),
       * - the node is a "direct child" of the block
       */
      _Visitor.prototype._mayBeAddBlockChildren = function (node) {
          if (this._inI18nBlock && !this._inIcu && this._depth == this._blockStartDepth) {
              this._blockChildren.push(node);
          }
      };
      /**
       * Marks the start of a section, see `_endSection`
       */
      _Visitor.prototype._openTranslatableSection = function (node) {
          if (this._isInTranslatableSection) {
              this._reportError(node, 'Unexpected section start');
          }
          else {
              this._msgCountAtSectionStart = this._messages.length;
          }
      };
      Object.defineProperty(_Visitor.prototype, "_isInTranslatableSection", {
          /**
           * A translatable section could be:
           * - a translatable element,
           * - nodes between `<!-- i18n -->` and `<!-- /i18n -->` comments
           */
          get: function () {
              return this._msgCountAtSectionStart !== void 0;
          },
          enumerable: true,
          configurable: true
      });
      /**
       * Terminates a section.
       *
       * If a section has only one significant children (comments not significant) then we should not
       * keep the message from this children:
       *
       * `<p i18n="meaning|description">{ICU message}</p>` would produce two messages:
       * - one for the <p> content with meaning and description,
       * - another one for the ICU message.
       *
       * In this case the last message is discarded as it contains less information (the AST is
       * otherwise identical).
       *
       * Note that we should still keep messages extracted from attributes inside the section (ie in the
       * ICU message here)
       */
      _Visitor.prototype._closeTranslatableSection = function (node, directChildren) {
          if (!this._isInTranslatableSection) {
              this._reportError(node, 'Unexpected section end');
              return;
          }
          var startIndex = this._msgCountAtSectionStart;
          var significantChildren = directChildren.reduce(function (count, node) { return count + (node instanceof Comment ? 0 : 1); }, 0);
          if (significantChildren == 1) {
              for (var i = this._messages.length - 1; i >= startIndex; i--) {
                  var ast = this._messages[i].nodes;
                  if (!(ast.length == 1 && ast[0] instanceof Text$1)) {
                      this._messages.splice(i, 1);
                      break;
                  }
              }
          }
          this._msgCountAtSectionStart = void 0;
      };
      _Visitor.prototype._reportError = function (node, msg) {
          this._errors.push(new I18nError(node.sourceSpan, msg));
      };
      return _Visitor;
  }());
  function _isOpeningComment(n) {
      return n instanceof Comment && n.value && n.value.startsWith('i18n');
  }
  function _isClosingComment(n) {
      return n instanceof Comment && n.value && n.value === '/i18n';
  }
  function _getI18nAttr(p) {
      return p.attrs.find(function (attr) { return attr.name === _I18N_ATTR; }) || null;
  }
  function _splitMeaningAndDesc(i18n) {
      if (!i18n)
          return ['', ''];
      var pipeIndex = i18n.indexOf('|');
      return pipeIndex == -1 ? ['', i18n] : [i18n.slice(0, pipeIndex), i18n.slice(pipeIndex + 1)];
  }

  /**
   * A container for message extracted from the templates.
   */
  var MessageBundle = (function () {
      function MessageBundle(_htmlParser, _implicitTags, _implicitAttrs) {
          this._htmlParser = _htmlParser;
          this._implicitTags = _implicitTags;
          this._implicitAttrs = _implicitAttrs;
          this._messageMap = {};
      }
      MessageBundle.prototype.updateFromTemplate = function (html, url, interpolationConfig) {
          var _this = this;
          var htmlParserResult = this._htmlParser.parse(html, url, true, interpolationConfig);
          if (htmlParserResult.errors.length) {
              return htmlParserResult.errors;
          }
          var i18nParserResult = extractMessages(htmlParserResult.rootNodes, interpolationConfig, this._implicitTags, this._implicitAttrs);
          if (i18nParserResult.errors.length) {
              return i18nParserResult.errors;
          }
          i18nParserResult.messages.forEach(function (message) { _this._messageMap[digestMessage(message)] = message; });
      };
      MessageBundle.prototype.getMessageMap = function () { return this._messageMap; };
      MessageBundle.prototype.write = function (serializer) { return serializer.write(this._messageMap); };
      return MessageBundle;
  }());

  var XmlTagDefinition = (function () {
      function XmlTagDefinition() {
          this.closedByParent = false;
          this.contentType = TagContentType.PARSABLE_DATA;
          this.isVoid = false;
          this.ignoreFirstLf = false;
          this.canSelfClose = true;
      }
      XmlTagDefinition.prototype.requireExtraParent = function (currentParent) { return false; };
      XmlTagDefinition.prototype.isClosedByChild = function (name) { return false; };
      return XmlTagDefinition;
  }());
  var _TAG_DEFINITION = new XmlTagDefinition();
  function getXmlTagDefinition(tagName) {
      return _TAG_DEFINITION;
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var __extends$7 = (this && this.__extends) || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var XmlParser = (function (_super) {
      __extends$7(XmlParser, _super);
      function XmlParser() {
          _super.call(this, getXmlTagDefinition);
      }
      XmlParser.prototype.parse = function (source, url, parseExpansionForms) {
          if (parseExpansionForms === void 0) { parseExpansionForms = false; }
          return _super.prototype.parse.call(this, source, url, parseExpansionForms, null);
      };
      return XmlParser;
  }(Parser$1));

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  // Generate a map of placeholder to content indexed by message ids
  function extractPlaceholders(messageBundle) {
      var messageMap = messageBundle.getMessageMap();
      var placeholders = {};
      Object.keys(messageMap).forEach(function (msgId) {
          placeholders[msgId] = messageMap[msgId].placeholders;
      });
      return placeholders;
  }
  // Generate a map of placeholder to message ids indexed by message ids
  function extractPlaceholderToIds(messageBundle) {
      var messageMap = messageBundle.getMessageMap();
      var placeholderToIds = {};
      Object.keys(messageMap).forEach(function (msgId) {
          placeholderToIds[msgId] = messageMap[msgId].placeholderToMsgIds;
      });
      return placeholderToIds;
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var __extends$8 = (this && this.__extends) || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var _Visitor$1 = (function () {
      function _Visitor() {
      }
      _Visitor.prototype.visitTag = function (tag) {
          var _this = this;
          var strAttrs = this._serializeAttributes(tag.attrs);
          if (tag.children.length == 0) {
              return "<" + tag.name + strAttrs + "/>";
          }
          var strChildren = tag.children.map(function (node) { return node.visit(_this); });
          return "<" + tag.name + strAttrs + ">" + strChildren.join('') + "</" + tag.name + ">";
      };
      _Visitor.prototype.visitText = function (text) { return text.value; };
      _Visitor.prototype.visitDeclaration = function (decl) {
          return "<?xml" + this._serializeAttributes(decl.attrs) + " ?>";
      };
      _Visitor.prototype._serializeAttributes = function (attrs) {
          var strAttrs = Object.keys(attrs).map(function (name) { return (name + "=\"" + attrs[name] + "\""); }).join(' ');
          return strAttrs.length > 0 ? ' ' + strAttrs : '';
      };
      _Visitor.prototype.visitDoctype = function (doctype) {
          return "<!DOCTYPE " + doctype.rootTag + " [\n" + doctype.dtd + "\n]>";
      };
      return _Visitor;
  }());
  var _visitor = new _Visitor$1();
  function serialize(nodes) {
      return nodes.map(function (node) { return node.visit(_visitor); }).join('');
  }
  var Declaration = (function () {
      function Declaration(unescapedAttrs) {
          var _this = this;
          this.attrs = {};
          Object.keys(unescapedAttrs).forEach(function (k) {
              _this.attrs[k] = _escapeXml(unescapedAttrs[k]);
          });
      }
      Declaration.prototype.visit = function (visitor) { return visitor.visitDeclaration(this); };
      return Declaration;
  }());
  var Doctype = (function () {
      function Doctype(rootTag, dtd) {
          this.rootTag = rootTag;
          this.dtd = dtd;
      }
      ;
      Doctype.prototype.visit = function (visitor) { return visitor.visitDoctype(this); };
      return Doctype;
  }());
  var Tag = (function () {
      function Tag(name, unescapedAttrs, children) {
          var _this = this;
          if (unescapedAttrs === void 0) { unescapedAttrs = {}; }
          if (children === void 0) { children = []; }
          this.name = name;
          this.children = children;
          this.attrs = {};
          Object.keys(unescapedAttrs).forEach(function (k) {
              _this.attrs[k] = _escapeXml(unescapedAttrs[k]);
          });
      }
      Tag.prototype.visit = function (visitor) { return visitor.visitTag(this); };
      return Tag;
  }());
  var Text$2 = (function () {
      function Text(unescapedValue) {
          this.value = _escapeXml(unescapedValue);
      }
      ;
      Text.prototype.visit = function (visitor) { return visitor.visitText(this); };
      return Text;
  }());
  var CR = (function (_super) {
      __extends$8(CR, _super);
      function CR(ws) {
          if (ws === void 0) { ws = 0; }
          _super.call(this, "\n" + new Array(ws + 1).join(' '));
      }
      return CR;
  }(Text$2));
  var _ESCAPED_CHARS = [
      [/&/g, '&amp;'],
      [/"/g, '&quot;'],
      [/'/g, '&apos;'],
      [/</g, '&lt;'],
      [/>/g, '&gt;'],
  ];
  function _escapeXml(text) {
      return _ESCAPED_CHARS.reduce(function (text, entry) { return text.replace(entry[0], entry[1]); }, text);
  }

  var _VERSION = '1.2';
  var _XMLNS = 'urn:oasis:names:tc:xliff:document:1.2';
  // TODO(vicb): make this a param (s/_/-/)
  var _SOURCE_LANG = 'en';
  var _PLACEHOLDER_TAG = 'x';
  var _SOURCE_TAG = 'source';
  var _TARGET_TAG = 'target';
  var _UNIT_TAG = 'trans-unit';
  // http://docs.oasis-open.org/xliff/v1.2/os/xliff-core.html
  // http://docs.oasis-open.org/xliff/v1.2/xliff-profile-html/xliff-profile-html-1.2.html
  var Xliff = (function () {
      function Xliff(_htmlParser, _interpolationConfig) {
          this._htmlParser = _htmlParser;
          this._interpolationConfig = _interpolationConfig;
      }
      Xliff.prototype.write = function (messageMap) {
          var visitor = new _WriteVisitor();
          var transUnits = [];
          Object.keys(messageMap).forEach(function (id) {
              var message = messageMap[id];
              var transUnit = new Tag(_UNIT_TAG, { id: id, datatype: 'html' });
              transUnit.children.push(new CR(8), new Tag(_SOURCE_TAG, {}, visitor.serialize(message.nodes)), new CR(8), new Tag(_TARGET_TAG));
              if (message.description) {
                  transUnit.children.push(new CR(8), new Tag('note', { priority: '1', from: 'description' }, [new Text$2(message.description)]));
              }
              if (message.meaning) {
                  transUnit.children.push(new CR(8), new Tag('note', { priority: '1', from: 'meaning' }, [new Text$2(message.meaning)]));
              }
              transUnit.children.push(new CR(6));
              transUnits.push(new CR(6), transUnit);
          });
          var body = new Tag('body', {}, transUnits.concat([new CR(4)]));
          var file = new Tag('file', { 'source-language': _SOURCE_LANG, datatype: 'plaintext', original: 'ng2.template' }, [new CR(4), body, new CR(2)]);
          var xliff = new Tag('xliff', { version: _VERSION, xmlns: _XMLNS }, [new CR(2), file, new CR()]);
          return serialize([
              new Declaration({ version: '1.0', encoding: 'UTF-8' }), new CR(), xliff, new CR()
          ]);
      };
      Xliff.prototype.load = function (content, url, messageBundle) {
          var _this = this;
          // Parse the xtb file into xml nodes
          var result = new XmlParser().parse(content, url);
          if (result.errors.length) {
              throw new Error("xtb parse errors:\n" + result.errors.join('\n'));
          }
          // Replace the placeholders, messages are now string
          var _a = new _LoadVisitor().parse(result.rootNodes, messageBundle), messages = _a.messages, errors = _a.errors;
          if (errors.length) {
              throw new Error("xtb parse errors:\n" + errors.join('\n'));
          }
          // Convert the string messages to html ast
          // TODO(vicb): map error message back to the original message in xtb
          var messageMap = {};
          var parseErrors = [];
          Object.keys(messages).forEach(function (id) {
              var res = _this._htmlParser.parse(messages[id], url, true, _this._interpolationConfig);
              parseErrors.push.apply(parseErrors, res.errors);
              messageMap[id] = res.rootNodes;
          });
          if (parseErrors.length) {
              throw new Error("xtb parse errors:\n" + parseErrors.join('\n'));
          }
          return messageMap;
      };
      return Xliff;
  }());
  var _WriteVisitor = (function () {
      function _WriteVisitor() {
      }
      _WriteVisitor.prototype.visitText = function (text, context) { return [new Text$2(text.value)]; };
      _WriteVisitor.prototype.visitContainer = function (container, context) {
          var _this = this;
          var nodes = [];
          container.children.forEach(function (node) { return nodes.push.apply(nodes, node.visit(_this)); });
          return nodes;
      };
      _WriteVisitor.prototype.visitIcu = function (icu, context) {
          if (this._isInIcu) {
              // nested ICU is not supported
              throw new Error('xliff does not support nested ICU messages');
          }
          this._isInIcu = true;
          // TODO(vicb): support ICU messages
          // https://lists.oasis-open.org/archives/xliff/201201/msg00028.html
          // http://docs.oasis-open.org/xliff/v1.2/xliff-profile-po/xliff-profile-po-1.2-cd02.html
          var nodes = [];
          this._isInIcu = false;
          return nodes;
      };
      _WriteVisitor.prototype.visitTagPlaceholder = function (ph, context) {
          var ctype = getCtypeForTag(ph.tag);
          var startTagPh = new Tag(_PLACEHOLDER_TAG, { id: ph.startName, ctype: ctype });
          if (ph.isVoid) {
              // void tags have no children nor closing tags
              return [startTagPh];
          }
          var closeTagPh = new Tag(_PLACEHOLDER_TAG, { id: ph.closeName, ctype: ctype });
          return [startTagPh].concat(this.serialize(ph.children), [closeTagPh]);
      };
      _WriteVisitor.prototype.visitPlaceholder = function (ph, context) {
          return [new Tag(_PLACEHOLDER_TAG, { id: ph.name })];
      };
      _WriteVisitor.prototype.visitIcuPlaceholder = function (ph, context) {
          return [new Tag(_PLACEHOLDER_TAG, { id: ph.name })];
      };
      _WriteVisitor.prototype.serialize = function (nodes) {
          var _this = this;
          this._isInIcu = false;
          return ListWrapper.flatten(nodes.map(function (node) { return node.visit(_this); }));
      };
      return _WriteVisitor;
  }());
  // TODO(vicb): add error management (structure)
  // TODO(vicb): factorize (xtb) ?
  var _LoadVisitor = (function () {
      function _LoadVisitor() {
      }
      _LoadVisitor.prototype.parse = function (nodes, messageBundle) {
          var _this = this;
          this._messageNodes = [];
          this._translatedMessages = {};
          this._msgId = '';
          this._target = [];
          this._errors = [];
          // Find all messages
          visitAll(this, nodes, null);
          var messageMap = messageBundle.getMessageMap();
          var placeholders = extractPlaceholders(messageBundle);
          var placeholderToIds = extractPlaceholderToIds(messageBundle);
          this._messageNodes
              .filter(function (message) {
              // Remove any messages that is not present in the source message bundle.
              return messageMap.hasOwnProperty(message[0]);
          })
              .sort(function (a, b) {
              // Because there could be no ICU placeholders inside an ICU message,
              // we do not need to take into account the `placeholderToMsgIds` of the referenced
              // messages, those would always be empty
              // TODO(vicb): overkill - create 2 buckets and [...woDeps, ...wDeps].process()
              if (Object.keys(messageMap[a[0]].placeholderToMsgIds).length == 0) {
                  return -1;
              }
              if (Object.keys(messageMap[b[0]].placeholderToMsgIds).length == 0) {
                  return 1;
              }
              return 0;
          })
              .forEach(function (message) {
              var id = message[0];
              _this._placeholders = placeholders[id] || {};
              _this._placeholderToIds = placeholderToIds[id] || {};
              // TODO(vicb): make sure there is no `_TRANSLATIONS_TAG` nor `_TRANSLATION_TAG`
              _this._translatedMessages[id] = visitAll(_this, message[1]).join('');
          });
          return { messages: this._translatedMessages, errors: this._errors };
      };
      _LoadVisitor.prototype.visitElement = function (element, context) {
          switch (element.name) {
              case _UNIT_TAG:
                  this._target = null;
                  var msgId = element.attrs.find(function (attr) { return attr.name === 'id'; });
                  if (!msgId) {
                      this._addError(element, "<" + _UNIT_TAG + "> misses the \"id\" attribute");
                  }
                  else {
                      this._msgId = msgId.value;
                  }
                  visitAll(this, element.children, null);
                  if (this._msgId !== null) {
                      this._messageNodes.push([this._msgId, this._target]);
                  }
                  break;
              case _SOURCE_TAG:
                  // ignore source message
                  break;
              case _TARGET_TAG:
                  this._target = element.children;
                  break;
              case _PLACEHOLDER_TAG:
                  var idAttr = element.attrs.find(function (attr) { return attr.name === 'id'; });
                  if (!idAttr) {
                      this._addError(element, "<" + _PLACEHOLDER_TAG + "> misses the \"id\" attribute");
                  }
                  else {
                      var id = idAttr.value;
                      if (this._placeholders.hasOwnProperty(id)) {
                          return this._placeholders[id];
                      }
                      if (this._placeholderToIds.hasOwnProperty(id) &&
                          this._translatedMessages.hasOwnProperty(this._placeholderToIds[id])) {
                          return this._translatedMessages[this._placeholderToIds[id]];
                      }
                      // TODO(vicb): better error message for when
                      // !this._translatedMessages.hasOwnProperty(this._placeholderToIds[id])
                      this._addError(element, "The placeholder \"" + id + "\" does not exists in the source message");
                  }
                  break;
              default:
                  visitAll(this, element.children, null);
          }
      };
      _LoadVisitor.prototype.visitAttribute = function (attribute, context) {
          throw new Error('unreachable code');
      };
      _LoadVisitor.prototype.visitText = function (text, context) { return text.value; };
      _LoadVisitor.prototype.visitComment = function (comment, context) { return ''; };
      _LoadVisitor.prototype.visitExpansion = function (expansion, context) {
          throw new Error('unreachable code');
      };
      _LoadVisitor.prototype.visitExpansionCase = function (expansionCase, context) {
          throw new Error('unreachable code');
      };
      _LoadVisitor.prototype._addError = function (node, message) {
          this._errors.push(new I18nError(node.sourceSpan, message));
      };
      return _LoadVisitor;
  }());
  function getCtypeForTag(tag) {
      switch (tag.toLowerCase()) {
          case 'br':
              return 'lb';
          case 'img':
              return 'image';
          default:
              return "x-" + tag;
      }
  }

  var _MESSAGES_TAG = 'messagebundle';
  var _MESSAGE_TAG = 'msg';
  var _PLACEHOLDER_TAG$1 = 'ph';
  var _EXEMPLE_TAG = 'ex';
  var _DOCTYPE = "<!ELEMENT messagebundle (msg)*>\n<!ATTLIST messagebundle class CDATA #IMPLIED>\n\n<!ELEMENT msg (#PCDATA|ph|source)*>\n<!ATTLIST msg id CDATA #IMPLIED>\n<!ATTLIST msg seq CDATA #IMPLIED>\n<!ATTLIST msg name CDATA #IMPLIED>\n<!ATTLIST msg desc CDATA #IMPLIED>\n<!ATTLIST msg meaning CDATA #IMPLIED>\n<!ATTLIST msg obsolete (obsolete) #IMPLIED>\n<!ATTLIST msg xml:space (default|preserve) \"default\">\n<!ATTLIST msg is_hidden CDATA #IMPLIED>\n\n<!ELEMENT source (#PCDATA)>\n\n<!ELEMENT ph (#PCDATA|ex)*>\n<!ATTLIST ph name CDATA #REQUIRED>\n\n<!ELEMENT ex (#PCDATA)>";
  var Xmb = (function () {
      function Xmb() {
      }
      Xmb.prototype.write = function (messageMap) {
          var visitor = new _Visitor$2();
          var rootNode = new Tag(_MESSAGES_TAG);
          Object.keys(messageMap).forEach(function (id) {
              var message = messageMap[id];
              var attrs = { id: id };
              if (message.description) {
                  attrs['desc'] = message.description;
              }
              if (message.meaning) {
                  attrs['meaning'] = message.meaning;
              }
              rootNode.children.push(new CR(2), new Tag(_MESSAGE_TAG, attrs, visitor.serialize(message.nodes)));
          });
          rootNode.children.push(new CR());
          return serialize([
              new Declaration({ version: '1.0', encoding: 'UTF-8' }),
              new CR(),
              new Doctype(_MESSAGES_TAG, _DOCTYPE),
              new CR(),
              rootNode,
              new CR(),
          ]);
      };
      Xmb.prototype.load = function (content, url, messageBundle) {
          throw new Error('Unsupported');
      };
      return Xmb;
  }());
  var _Visitor$2 = (function () {
      function _Visitor() {
      }
      _Visitor.prototype.visitText = function (text, context) { return [new Text$2(text.value)]; };
      _Visitor.prototype.visitContainer = function (container, context) {
          var _this = this;
          var nodes = [];
          container.children.forEach(function (node) { return nodes.push.apply(nodes, node.visit(_this)); });
          return nodes;
      };
      _Visitor.prototype.visitIcu = function (icu, context) {
          var _this = this;
          var nodes = [new Text$2("{" + icu.expression + ", " + icu.type + ", ")];
          Object.keys(icu.cases).forEach(function (c) {
              nodes.push.apply(nodes, [new Text$2(c + " {")].concat(icu.cases[c].visit(_this), [new Text$2("} ")]));
          });
          nodes.push(new Text$2("}"));
          return nodes;
      };
      _Visitor.prototype.visitTagPlaceholder = function (ph, context) {
          var startEx = new Tag(_EXEMPLE_TAG, {}, [new Text$2("<" + ph.tag + ">")]);
          var startTagPh = new Tag(_PLACEHOLDER_TAG$1, { name: ph.startName }, [startEx]);
          if (ph.isVoid) {
              // void tags have no children nor closing tags
              return [startTagPh];
          }
          var closeEx = new Tag(_EXEMPLE_TAG, {}, [new Text$2("</" + ph.tag + ">")]);
          var closeTagPh = new Tag(_PLACEHOLDER_TAG$1, { name: ph.closeName }, [closeEx]);
          return [startTagPh].concat(this.serialize(ph.children), [closeTagPh]);
      };
      _Visitor.prototype.visitPlaceholder = function (ph, context) {
          return [new Tag(_PLACEHOLDER_TAG$1, { name: ph.name })];
      };
      _Visitor.prototype.visitIcuPlaceholder = function (ph, context) {
          return [new Tag(_PLACEHOLDER_TAG$1, { name: ph.name })];
      };
      _Visitor.prototype.serialize = function (nodes) {
          var _this = this;
          return ListWrapper.flatten(nodes.map(function (node) { return node.visit(_this); }));
      };
      return _Visitor;
  }());

  var _TRANSLATIONS_TAG = 'translationbundle';
  var _TRANSLATION_TAG = 'translation';
  var _PLACEHOLDER_TAG$2 = 'ph';
  var Xtb = (function () {
      function Xtb(_htmlParser, _interpolationConfig) {
          this._htmlParser = _htmlParser;
          this._interpolationConfig = _interpolationConfig;
      }
      Xtb.prototype.write = function (messageMap) { throw new Error('Unsupported'); };
      Xtb.prototype.load = function (content, url, messageBundle) {
          var _this = this;
          // Parse the xtb file into xml nodes
          var result = new XmlParser().parse(content, url);
          if (result.errors.length) {
              throw new Error("xtb parse errors:\n" + result.errors.join('\n'));
          }
          // Replace the placeholders, messages are now string
          var _a = new _Visitor$3().parse(result.rootNodes, messageBundle), messages = _a.messages, errors = _a.errors;
          if (errors.length) {
              throw new Error("xtb parse errors:\n" + errors.join('\n'));
          }
          // Convert the string messages to html ast
          // TODO(vicb): map error message back to the original message in xtb
          var messageMap = {};
          var parseErrors = [];
          Object.keys(messages).forEach(function (id) {
              var res = _this._htmlParser.parse(messages[id], url, true, _this._interpolationConfig);
              parseErrors.push.apply(parseErrors, res.errors);
              messageMap[id] = res.rootNodes;
          });
          if (parseErrors.length) {
              throw new Error("xtb parse errors:\n" + parseErrors.join('\n'));
          }
          return messageMap;
      };
      return Xtb;
  }());
  var _Visitor$3 = (function () {
      function _Visitor() {
      }
      _Visitor.prototype.parse = function (nodes, messageBundle) {
          var _this = this;
          this._messageNodes = [];
          this._translatedMessages = {};
          this._bundleDepth = 0;
          this._translationDepth = 0;
          this._errors = [];
          // Find all messages
          visitAll(this, nodes, null);
          var messageMap = messageBundle.getMessageMap();
          var placeholders = extractPlaceholders(messageBundle);
          var placeholderToIds = extractPlaceholderToIds(messageBundle);
          this._messageNodes
              .filter(function (message) {
              // Remove any messages that is not present in the source message bundle.
              return messageMap.hasOwnProperty(message[0]);
          })
              .sort(function (a, b) {
              // Because there could be no ICU placeholders inside an ICU message,
              // we do not need to take into account the `placeholderToMsgIds` of the referenced
              // messages, those would always be empty
              // TODO(vicb): overkill - create 2 buckets and [...woDeps, ...wDeps].process()
              if (Object.keys(messageMap[a[0]].placeholderToMsgIds).length == 0) {
                  return -1;
              }
              if (Object.keys(messageMap[b[0]].placeholderToMsgIds).length == 0) {
                  return 1;
              }
              return 0;
          })
              .forEach(function (message) {
              var id = message[0];
              _this._placeholders = placeholders[id] || {};
              _this._placeholderToIds = placeholderToIds[id] || {};
              // TODO(vicb): make sure there is no `_TRANSLATIONS_TAG` nor `_TRANSLATION_TAG`
              _this._translatedMessages[id] = visitAll(_this, message[1]).join('');
          });
          return { messages: this._translatedMessages, errors: this._errors };
      };
      _Visitor.prototype.visitElement = function (element, context) {
          switch (element.name) {
              case _TRANSLATIONS_TAG:
                  this._bundleDepth++;
                  if (this._bundleDepth > 1) {
                      this._addError(element, "<" + _TRANSLATIONS_TAG + "> elements can not be nested");
                  }
                  visitAll(this, element.children, null);
                  this._bundleDepth--;
                  break;
              case _TRANSLATION_TAG:
                  this._translationDepth++;
                  if (this._translationDepth > 1) {
                      this._addError(element, "<" + _TRANSLATION_TAG + "> elements can not be nested");
                  }
                  var idAttr = element.attrs.find(function (attr) { return attr.name === 'id'; });
                  if (!idAttr) {
                      this._addError(element, "<" + _TRANSLATION_TAG + "> misses the \"id\" attribute");
                  }
                  else {
                      // ICU placeholders are reference to other messages.
                      // The referenced message might not have been decoded yet.
                      // We need to have all messages available to make sure deps are decoded first.
                      // TODO(vicb): report an error on duplicate id
                      this._messageNodes.push([idAttr.value, element.children]);
                  }
                  this._translationDepth--;
                  break;
              case _PLACEHOLDER_TAG$2:
                  var nameAttr = element.attrs.find(function (attr) { return attr.name === 'name'; });
                  if (!nameAttr) {
                      this._addError(element, "<" + _PLACEHOLDER_TAG$2 + "> misses the \"name\" attribute");
                  }
                  else {
                      var name_1 = nameAttr.value;
                      if (this._placeholders.hasOwnProperty(name_1)) {
                          return this._placeholders[name_1];
                      }
                      if (this._placeholderToIds.hasOwnProperty(name_1) &&
                          this._translatedMessages.hasOwnProperty(this._placeholderToIds[name_1])) {
                          return this._translatedMessages[this._placeholderToIds[name_1]];
                      }
                      // TODO(vicb): better error message for when
                      // !this._translatedMessages.hasOwnProperty(this._placeholderToIds[name])
                      this._addError(element, "The placeholder \"" + name_1 + "\" does not exists in the source message");
                  }
                  break;
              default:
                  this._addError(element, 'Unexpected tag');
          }
      };
      _Visitor.prototype.visitAttribute = function (attribute, context) {
          throw new Error('unreachable code');
      };
      _Visitor.prototype.visitText = function (text, context) { return text.value; };
      _Visitor.prototype.visitComment = function (comment, context) { return ''; };
      _Visitor.prototype.visitExpansion = function (expansion, context) {
          var _this = this;
          var strCases = expansion.cases.map(function (c) { return c.visit(_this, null); });
          return "{" + expansion.switchValue + ", " + expansion.type + ", strCases.join(' ')}";
      };
      _Visitor.prototype.visitExpansionCase = function (expansionCase, context) {
          return expansionCase.value + " {" + visitAll(this, expansionCase.expression, null) + "}";
      };
      _Visitor.prototype._addError = function (node, message) {
          this._errors.push(new I18nError(node.sourceSpan, message));
      };
      return _Visitor;
  }());

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * A container for translated messages
   */
  var TranslationBundle = (function () {
      function TranslationBundle(_messageMap) {
          if (_messageMap === void 0) { _messageMap = {}; }
          this._messageMap = _messageMap;
      }
      TranslationBundle.load = function (content, url, messageBundle, serializer) {
          return new TranslationBundle(serializer.load(content, url, messageBundle));
      };
      TranslationBundle.prototype.get = function (id) { return this._messageMap[id]; };
      TranslationBundle.prototype.has = function (id) { return id in this._messageMap; };
      return TranslationBundle;
  }());

  var I18NHtmlParser = (function () {
      // TODO(vicb): transB.load() should not need a msgB & add transB.resolve(msgB,
      // interpolationConfig)
      // TODO(vicb): remove the interpolationConfig from the Xtb serializer
      function I18NHtmlParser(_htmlParser, _translations, _translationsFormat) {
          this._htmlParser = _htmlParser;
          this._translations = _translations;
          this._translationsFormat = _translationsFormat;
      }
      I18NHtmlParser.prototype.parse = function (source, url, parseExpansionForms, interpolationConfig) {
          if (parseExpansionForms === void 0) { parseExpansionForms = false; }
          if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }
          var parseResult = this._htmlParser.parse(source, url, parseExpansionForms, interpolationConfig);
          if (!this._translations || this._translations === '') {
              // Do not enable i18n when no translation bundle is provided
              return parseResult;
          }
          // TODO(vicb): add support for implicit tags / attributes
          var messageBundle = new MessageBundle(this._htmlParser, [], {});
          var errors = messageBundle.updateFromTemplate(source, url, interpolationConfig);
          if (errors && errors.length) {
              return new ParseTreeResult(parseResult.rootNodes, parseResult.errors.concat(errors));
          }
          var serializer = this._createSerializer(interpolationConfig);
          var translationBundle = TranslationBundle.load(this._translations, url, messageBundle, serializer);
          return mergeTranslations(parseResult.rootNodes, translationBundle, interpolationConfig, [], {});
      };
      I18NHtmlParser.prototype._createSerializer = function (interpolationConfig) {
          var format = (this._translationsFormat || 'xlf').toLowerCase();
          switch (format) {
              case 'xmb':
                  return new Xmb();
              case 'xtb':
                  return new Xtb(this._htmlParser, interpolationConfig);
              case 'xliff':
              case 'xlf':
              default:
                  return new Xliff(this._htmlParser, interpolationConfig);
          }
      };
      return I18NHtmlParser;
  }());

  var isDefaultChangeDetectionStrategy = _angular_core.__core_private__.isDefaultChangeDetectionStrategy;
  var ChangeDetectorStatus = _angular_core.__core_private__.ChangeDetectorStatus;
  var LifecycleHooks = _angular_core.__core_private__.LifecycleHooks;
  var LIFECYCLE_HOOKS_VALUES = _angular_core.__core_private__.LIFECYCLE_HOOKS_VALUES;
  var ReflectorReader = _angular_core.__core_private__.ReflectorReader;
  var AppElement = _angular_core.__core_private__.AppElement;
  var CodegenComponentFactoryResolver = _angular_core.__core_private__.CodegenComponentFactoryResolver;
  var AppView = _angular_core.__core_private__.AppView;
  var DebugAppView = _angular_core.__core_private__.DebugAppView;
  var NgModuleInjector = _angular_core.__core_private__.NgModuleInjector;
  var registerModuleFactory = _angular_core.__core_private__.registerModuleFactory;
  var ViewType = _angular_core.__core_private__.ViewType;
  var view_utils = _angular_core.__core_private__.view_utils;
  var DebugContext = _angular_core.__core_private__.DebugContext;
  var StaticNodeDebugInfo = _angular_core.__core_private__.StaticNodeDebugInfo;
  var devModeEqual = _angular_core.__core_private__.devModeEqual;
  var UNINITIALIZED = _angular_core.__core_private__.UNINITIALIZED;
  var ValueUnwrapper = _angular_core.__core_private__.ValueUnwrapper;
  var TemplateRef_ = _angular_core.__core_private__.TemplateRef_;
  var Console = _angular_core.__core_private__.Console;
  var reflector = _angular_core.__core_private__.reflector;
  var Reflector = _angular_core.__core_private__.Reflector;
  var ReflectionCapabilities = _angular_core.__core_private__.ReflectionCapabilities;
  var NoOpAnimationPlayer = _angular_core.__core_private__.NoOpAnimationPlayer;
  var AnimationSequencePlayer = _angular_core.__core_private__.AnimationSequencePlayer;
  var AnimationGroupPlayer = _angular_core.__core_private__.AnimationGroupPlayer;
  var AnimationKeyframe = _angular_core.__core_private__.AnimationKeyframe;
  var AnimationStyles = _angular_core.__core_private__.AnimationStyles;
  var ANY_STATE = _angular_core.__core_private__.ANY_STATE;
  var DEFAULT_STATE = _angular_core.__core_private__.DEFAULT_STATE;
  var EMPTY_ANIMATION_STATE = _angular_core.__core_private__.EMPTY_STATE;
  var FILL_STYLE_FLAG = _angular_core.__core_private__.FILL_STYLE_FLAG;
  var prepareFinalAnimationStyles = _angular_core.__core_private__.prepareFinalAnimationStyles;
  var balanceAnimationKeyframes = _angular_core.__core_private__.balanceAnimationKeyframes;
  var clearStyles = _angular_core.__core_private__.clearStyles;
  var collectAndResolveStyles = _angular_core.__core_private__.collectAndResolveStyles;
  var renderStyles = _angular_core.__core_private__.renderStyles;
  var ComponentStillLoadingError = _angular_core.__core_private__.ComponentStillLoadingError;
  var AnimationTransition = _angular_core.__core_private__.AnimationTransition;

  var APP_VIEW_MODULE_URL = assetUrl('core', 'linker/view');
  var VIEW_UTILS_MODULE_URL = assetUrl('core', 'linker/view_utils');
  var CD_MODULE_URL = assetUrl('core', 'change_detection/change_detection');
  var ANIMATION_STYLE_UTIL_ASSET_URL = assetUrl('core', 'animation/animation_style_util');
  var Identifiers = (function () {
      function Identifiers() {
      }
      Identifiers.ANALYZE_FOR_ENTRY_COMPONENTS = {
          name: 'ANALYZE_FOR_ENTRY_COMPONENTS',
          moduleUrl: assetUrl('core', 'metadata/di'),
          runtime: _angular_core.ANALYZE_FOR_ENTRY_COMPONENTS
      };
      Identifiers.ViewUtils = {
          name: 'ViewUtils',
          moduleUrl: assetUrl('core', 'linker/view_utils'),
          runtime: view_utils.ViewUtils
      };
      Identifiers.AppView = { name: 'AppView', moduleUrl: APP_VIEW_MODULE_URL, runtime: AppView };
      Identifiers.DebugAppView = {
          name: 'DebugAppView',
          moduleUrl: APP_VIEW_MODULE_URL,
          runtime: DebugAppView
      };
      Identifiers.AppElement = {
          name: 'AppElement',
          moduleUrl: assetUrl('core', 'linker/element'),
          runtime: AppElement
      };
      Identifiers.ElementRef = {
          name: 'ElementRef',
          moduleUrl: assetUrl('core', 'linker/element_ref'),
          runtime: _angular_core.ElementRef
      };
      Identifiers.ViewContainerRef = {
          name: 'ViewContainerRef',
          moduleUrl: assetUrl('core', 'linker/view_container_ref'),
          runtime: _angular_core.ViewContainerRef
      };
      Identifiers.ChangeDetectorRef = {
          name: 'ChangeDetectorRef',
          moduleUrl: assetUrl('core', 'change_detection/change_detector_ref'),
          runtime: _angular_core.ChangeDetectorRef
      };
      Identifiers.RenderComponentType = {
          name: 'RenderComponentType',
          moduleUrl: assetUrl('core', 'render/api'),
          runtime: _angular_core.RenderComponentType
      };
      Identifiers.QueryList = {
          name: 'QueryList',
          moduleUrl: assetUrl('core', 'linker/query_list'),
          runtime: _angular_core.QueryList
      };
      Identifiers.TemplateRef = {
          name: 'TemplateRef',
          moduleUrl: assetUrl('core', 'linker/template_ref'),
          runtime: _angular_core.TemplateRef
      };
      Identifiers.TemplateRef_ = {
          name: 'TemplateRef_',
          moduleUrl: assetUrl('core', 'linker/template_ref'),
          runtime: TemplateRef_
      };
      Identifiers.CodegenComponentFactoryResolver = {
          name: 'CodegenComponentFactoryResolver',
          moduleUrl: assetUrl('core', 'linker/component_factory_resolver'),
          runtime: CodegenComponentFactoryResolver
      };
      Identifiers.ComponentFactoryResolver = {
          name: 'ComponentFactoryResolver',
          moduleUrl: assetUrl('core', 'linker/component_factory_resolver'),
          runtime: _angular_core.ComponentFactoryResolver
      };
      Identifiers.ComponentFactory = {
          name: 'ComponentFactory',
          runtime: _angular_core.ComponentFactory,
          moduleUrl: assetUrl('core', 'linker/component_factory')
      };
      Identifiers.NgModuleFactory = {
          name: 'NgModuleFactory',
          runtime: _angular_core.NgModuleFactory,
          moduleUrl: assetUrl('core', 'linker/ng_module_factory')
      };
      Identifiers.NgModuleInjector = {
          name: 'NgModuleInjector',
          runtime: NgModuleInjector,
          moduleUrl: assetUrl('core', 'linker/ng_module_factory')
      };
      Identifiers.RegisterModuleFactoryFn = {
          name: 'registerModuleFactory',
          runtime: registerModuleFactory,
          moduleUrl: assetUrl('core', 'linker/ng_module_factory_loader')
      };
      Identifiers.ValueUnwrapper = { name: 'ValueUnwrapper', moduleUrl: CD_MODULE_URL, runtime: ValueUnwrapper };
      Identifiers.Injector = {
          name: 'Injector',
          moduleUrl: assetUrl('core', 'di/injector'),
          runtime: _angular_core.Injector
      };
      Identifiers.ViewEncapsulation = {
          name: 'ViewEncapsulation',
          moduleUrl: assetUrl('core', 'metadata/view'),
          runtime: _angular_core.ViewEncapsulation
      };
      Identifiers.ViewType = {
          name: 'ViewType',
          moduleUrl: assetUrl('core', 'linker/view_type'),
          runtime: ViewType
      };
      Identifiers.ChangeDetectionStrategy = {
          name: 'ChangeDetectionStrategy',
          moduleUrl: CD_MODULE_URL,
          runtime: _angular_core.ChangeDetectionStrategy
      };
      Identifiers.StaticNodeDebugInfo = {
          name: 'StaticNodeDebugInfo',
          moduleUrl: assetUrl('core', 'linker/debug_context'),
          runtime: StaticNodeDebugInfo
      };
      Identifiers.DebugContext = {
          name: 'DebugContext',
          moduleUrl: assetUrl('core', 'linker/debug_context'),
          runtime: DebugContext
      };
      Identifiers.Renderer = {
          name: 'Renderer',
          moduleUrl: assetUrl('core', 'render/api'),
          runtime: _angular_core.Renderer
      };
      Identifiers.SimpleChange = { name: 'SimpleChange', moduleUrl: CD_MODULE_URL, runtime: _angular_core.SimpleChange };
      Identifiers.UNINITIALIZED = { name: 'UNINITIALIZED', moduleUrl: CD_MODULE_URL, runtime: UNINITIALIZED };
      Identifiers.ChangeDetectorStatus = {
          name: 'ChangeDetectorStatus',
          moduleUrl: CD_MODULE_URL,
          runtime: ChangeDetectorStatus
      };
      Identifiers.checkBinding = {
          name: 'checkBinding',
          moduleUrl: VIEW_UTILS_MODULE_URL,
          runtime: view_utils.checkBinding
      };
      Identifiers.flattenNestedViewRenderNodes = {
          name: 'flattenNestedViewRenderNodes',
          moduleUrl: VIEW_UTILS_MODULE_URL,
          runtime: view_utils.flattenNestedViewRenderNodes
      };
      Identifiers.devModeEqual = { name: 'devModeEqual', moduleUrl: CD_MODULE_URL, runtime: devModeEqual };
      Identifiers.interpolate = {
          name: 'interpolate',
          moduleUrl: VIEW_UTILS_MODULE_URL,
          runtime: view_utils.interpolate
      };
      Identifiers.castByValue = {
          name: 'castByValue',
          moduleUrl: VIEW_UTILS_MODULE_URL,
          runtime: view_utils.castByValue
      };
      Identifiers.EMPTY_ARRAY = {
          name: 'EMPTY_ARRAY',
          moduleUrl: VIEW_UTILS_MODULE_URL,
          runtime: view_utils.EMPTY_ARRAY
      };
      Identifiers.EMPTY_MAP = {
          name: 'EMPTY_MAP',
          moduleUrl: VIEW_UTILS_MODULE_URL,
          runtime: view_utils.EMPTY_MAP
      };
      Identifiers.pureProxies = [
          null,
          { name: 'pureProxy1', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: view_utils.pureProxy1 },
          { name: 'pureProxy2', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: view_utils.pureProxy2 },
          { name: 'pureProxy3', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: view_utils.pureProxy3 },
          { name: 'pureProxy4', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: view_utils.pureProxy4 },
          { name: 'pureProxy5', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: view_utils.pureProxy5 },
          { name: 'pureProxy6', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: view_utils.pureProxy6 },
          { name: 'pureProxy7', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: view_utils.pureProxy7 },
          { name: 'pureProxy8', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: view_utils.pureProxy8 },
          { name: 'pureProxy9', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: view_utils.pureProxy9 },
          { name: 'pureProxy10', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: view_utils.pureProxy10 },
      ];
      Identifiers.SecurityContext = {
          name: 'SecurityContext',
          moduleUrl: assetUrl('core', 'security'),
          runtime: _angular_core.SecurityContext,
      };
      Identifiers.AnimationKeyframe = {
          name: 'AnimationKeyframe',
          moduleUrl: assetUrl('core', 'animation/animation_keyframe'),
          runtime: AnimationKeyframe
      };
      Identifiers.AnimationStyles = {
          name: 'AnimationStyles',
          moduleUrl: assetUrl('core', 'animation/animation_styles'),
          runtime: AnimationStyles
      };
      Identifiers.NoOpAnimationPlayer = {
          name: 'NoOpAnimationPlayer',
          moduleUrl: assetUrl('core', 'animation/animation_player'),
          runtime: NoOpAnimationPlayer
      };
      Identifiers.AnimationGroupPlayer = {
          name: 'AnimationGroupPlayer',
          moduleUrl: assetUrl('core', 'animation/animation_group_player'),
          runtime: AnimationGroupPlayer
      };
      Identifiers.AnimationSequencePlayer = {
          name: 'AnimationSequencePlayer',
          moduleUrl: assetUrl('core', 'animation/animation_sequence_player'),
          runtime: AnimationSequencePlayer
      };
      Identifiers.prepareFinalAnimationStyles = {
          name: 'prepareFinalAnimationStyles',
          moduleUrl: ANIMATION_STYLE_UTIL_ASSET_URL,
          runtime: prepareFinalAnimationStyles
      };
      Identifiers.balanceAnimationKeyframes = {
          name: 'balanceAnimationKeyframes',
          moduleUrl: ANIMATION_STYLE_UTIL_ASSET_URL,
          runtime: balanceAnimationKeyframes
      };
      Identifiers.clearStyles = {
          name: 'clearStyles',
          moduleUrl: ANIMATION_STYLE_UTIL_ASSET_URL,
          runtime: clearStyles
      };
      Identifiers.renderStyles = {
          name: 'renderStyles',
          moduleUrl: ANIMATION_STYLE_UTIL_ASSET_URL,
          runtime: renderStyles
      };
      Identifiers.collectAndResolveStyles = {
          name: 'collectAndResolveStyles',
          moduleUrl: ANIMATION_STYLE_UTIL_ASSET_URL,
          runtime: collectAndResolveStyles
      };
      Identifiers.LOCALE_ID = {
          name: 'LOCALE_ID',
          moduleUrl: assetUrl('core', 'i18n/tokens'),
          runtime: _angular_core.LOCALE_ID
      };
      Identifiers.TRANSLATIONS_FORMAT = {
          name: 'TRANSLATIONS_FORMAT',
          moduleUrl: assetUrl('core', 'i18n/tokens'),
          runtime: _angular_core.TRANSLATIONS_FORMAT
      };
      Identifiers.setBindingDebugInfo = {
          name: 'setBindingDebugInfo',
          moduleUrl: VIEW_UTILS_MODULE_URL,
          runtime: view_utils.setBindingDebugInfo
      };
      Identifiers.setBindingDebugInfoForChanges = {
          name: 'setBindingDebugInfoForChanges',
          moduleUrl: VIEW_UTILS_MODULE_URL,
          runtime: view_utils.setBindingDebugInfoForChanges
      };
      Identifiers.AnimationTransition = {
          name: 'AnimationTransition',
          moduleUrl: assetUrl('core', 'animation/animation_transition'),
          runtime: AnimationTransition
      };
      return Identifiers;
  }());
  function resolveIdentifier(identifier) {
      return new CompileIdentifierMetadata({
          name: identifier.name,
          moduleUrl: identifier.moduleUrl,
          reference: reflector.resolveIdentifier(identifier.name, identifier.moduleUrl, identifier.runtime)
      });
  }
  function identifierToken(identifier) {
      return new CompileTokenMetadata({ identifier: identifier });
  }
  function resolveIdentifierToken(identifier) {
      return identifierToken(resolveIdentifier(identifier));
  }
  function resolveEnumIdentifier(enumType, name) {
      var resolvedEnum = reflector.resolveEnum(enumType.reference, name);
      return new CompileIdentifierMetadata({ name: enumType.name + "." + name, moduleUrl: enumType.moduleUrl, reference: resolvedEnum });
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var __extends$9 = (this && this.__extends) || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var HtmlParser = (function (_super) {
      __extends$9(HtmlParser, _super);
      function HtmlParser() {
          _super.call(this, getHtmlTagDefinition);
      }
      HtmlParser.prototype.parse = function (source, url, parseExpansionForms, interpolationConfig) {
          if (parseExpansionForms === void 0) { parseExpansionForms = false; }
          if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }
          return _super.prototype.parse.call(this, source, url, parseExpansionForms, interpolationConfig);
      };
      HtmlParser.decorators = [
          { type: _angular_core.Injectable },
      ];
      /** @nocollapse */
      HtmlParser.ctorParameters = [];
      return HtmlParser;
  }(Parser$1));

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var __extends$10 = (this && this.__extends) || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  // http://cldr.unicode.org/index/cldr-spec/plural-rules
  var PLURAL_CASES = ['zero', 'one', 'two', 'few', 'many', 'other'];
  /**
   * Expands special forms into elements.
   *
   * For example,
   *
   * ```
   * { messages.length, plural,
   *   =0 {zero}
   *   =1 {one}
   *   other {more than one}
   * }
   * ```
   *
   * will be expanded into
   *
   * ```
   * <ng-container [ngPlural]="messages.length">
   *   <template ngPluralCase="=0">zero</ng-container>
   *   <template ngPluralCase="=1">one</ng-container>
   *   <template ngPluralCase="other">more than one</ng-container>
   * </ng-container>
   * ```
   */
  function expandNodes(nodes) {
      var expander = new _Expander();
      return new ExpansionResult(visitAll(expander, nodes), expander.isExpanded, expander.errors);
  }
  var ExpansionResult = (function () {
      function ExpansionResult(nodes, expanded, errors) {
          this.nodes = nodes;
          this.expanded = expanded;
          this.errors = errors;
      }
      return ExpansionResult;
  }());
  var ExpansionError = (function (_super) {
      __extends$10(ExpansionError, _super);
      function ExpansionError(span, errorMsg) {
          _super.call(this, span, errorMsg);
      }
      return ExpansionError;
  }(ParseError));
  /**
   * Expand expansion forms (plural, select) to directives
   *
   * @internal
   */
  var _Expander = (function () {
      function _Expander() {
          this.isExpanded = false;
          this.errors = [];
      }
      _Expander.prototype.visitElement = function (element, context) {
          return new Element(element.name, element.attrs, visitAll(this, element.children), element.sourceSpan, element.startSourceSpan, element.endSourceSpan);
      };
      _Expander.prototype.visitAttribute = function (attribute, context) { return attribute; };
      _Expander.prototype.visitText = function (text, context) { return text; };
      _Expander.prototype.visitComment = function (comment, context) { return comment; };
      _Expander.prototype.visitExpansion = function (icu, context) {
          this.isExpanded = true;
          return icu.type == 'plural' ? _expandPluralForm(icu, this.errors) :
              _expandDefaultForm(icu, this.errors);
      };
      _Expander.prototype.visitExpansionCase = function (icuCase, context) {
          throw new Error('Should not be reached');
      };
      return _Expander;
  }());
  function _expandPluralForm(ast, errors) {
      var children = ast.cases.map(function (c) {
          if (PLURAL_CASES.indexOf(c.value) == -1 && !c.value.match(/^=\d+$/)) {
              errors.push(new ExpansionError(c.valueSourceSpan, "Plural cases should be \"=<number>\" or one of " + PLURAL_CASES.join(", ")));
          }
          var expansionResult = expandNodes(c.expression);
          errors.push.apply(errors, expansionResult.errors);
          return new Element("template", [new Attribute$1('ngPluralCase', "" + c.value, c.valueSourceSpan)], expansionResult.nodes, c.sourceSpan, c.sourceSpan, c.sourceSpan);
      });
      var switchAttr = new Attribute$1('[ngPlural]', ast.switchValue, ast.switchValueSourceSpan);
      return new Element('ng-container', [switchAttr], children, ast.sourceSpan, ast.sourceSpan, ast.sourceSpan);
  }
  function _expandDefaultForm(ast, errors) {
      var children = ast.cases.map(function (c) {
          var expansionResult = expandNodes(c.expression);
          errors.push.apply(errors, expansionResult.errors);
          return new Element("template", [new Attribute$1('ngSwitchCase', "" + c.value, c.valueSourceSpan)], expansionResult.nodes, c.sourceSpan, c.sourceSpan, c.sourceSpan);
      });
      var switchAttr = new Attribute$1('[ngSwitch]', ast.switchValue, ast.switchValueSourceSpan);
      return new Element('ng-container', [switchAttr], children, ast.sourceSpan, ast.sourceSpan, ast.sourceSpan);
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var __extends$11 = (this && this.__extends) || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var ProviderError = (function (_super) {
      __extends$11(ProviderError, _super);
      function ProviderError(message, span) {
          _super.call(this, span, message);
      }
      return ProviderError;
  }(ParseError));
  var ProviderViewContext = (function () {
      function ProviderViewContext(component, sourceSpan) {
          var _this = this;
          this.component = component;
          this.sourceSpan = sourceSpan;
          this.errors = [];
          this.viewQueries = _getViewQueries(component);
          this.viewProviders = new Map();
          _normalizeProviders(component.viewProviders, sourceSpan, this.errors).forEach(function (provider) {
              if (isBlank(_this.viewProviders.get(provider.token.reference))) {
                  _this.viewProviders.set(provider.token.reference, true);
              }
          });
      }
      return ProviderViewContext;
  }());
  var ProviderElementContext = (function () {
      function ProviderElementContext(viewContext, _parent, _isViewRoot, _directiveAsts, attrs, refs, _sourceSpan) {
          var _this = this;
          this.viewContext = viewContext;
          this._parent = _parent;
          this._isViewRoot = _isViewRoot;
          this._directiveAsts = _directiveAsts;
          this._sourceSpan = _sourceSpan;
          this._transformedProviders = new Map();
          this._seenProviders = new Map();
          this._hasViewContainer = false;
          this._attrs = {};
          attrs.forEach(function (attrAst) { return _this._attrs[attrAst.name] = attrAst.value; });
          var directivesMeta = _directiveAsts.map(function (directiveAst) { return directiveAst.directive; });
          this._allProviders =
              _resolveProvidersFromDirectives(directivesMeta, _sourceSpan, viewContext.errors);
          this._contentQueries = _getContentQueries(directivesMeta);
          var queriedTokens = new Map();
          MapWrapper.values(this._allProviders).forEach(function (provider) {
              _this._addQueryReadsTo(provider.token, queriedTokens);
          });
          refs.forEach(function (refAst) {
              _this._addQueryReadsTo(new CompileTokenMetadata({ value: refAst.name }), queriedTokens);
          });
          if (isPresent(queriedTokens.get(resolveIdentifierToken(Identifiers.ViewContainerRef).reference))) {
              this._hasViewContainer = true;
          }
          // create the providers that we know are eager first
          MapWrapper.values(this._allProviders).forEach(function (provider) {
              var eager = provider.eager || isPresent(queriedTokens.get(provider.token.reference));
              if (eager) {
                  _this._getOrCreateLocalProvider(provider.providerType, provider.token, true);
              }
          });
      }
      ProviderElementContext.prototype.afterElement = function () {
          var _this = this;
          // collect lazy providers
          MapWrapper.values(this._allProviders).forEach(function (provider) {
              _this._getOrCreateLocalProvider(provider.providerType, provider.token, false);
          });
      };
      Object.defineProperty(ProviderElementContext.prototype, "transformProviders", {
          get: function () { return MapWrapper.values(this._transformedProviders); },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(ProviderElementContext.prototype, "transformedDirectiveAsts", {
          get: function () {
              var sortedProviderTypes = this.transformProviders.map(function (provider) { return provider.token.identifier; });
              var sortedDirectives = ListWrapper.clone(this._directiveAsts);
              ListWrapper.sort(sortedDirectives, function (dir1, dir2) { return sortedProviderTypes.indexOf(dir1.directive.type) -
                  sortedProviderTypes.indexOf(dir2.directive.type); });
              return sortedDirectives;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(ProviderElementContext.prototype, "transformedHasViewContainer", {
          get: function () { return this._hasViewContainer; },
          enumerable: true,
          configurable: true
      });
      ProviderElementContext.prototype._addQueryReadsTo = function (token, queryReadTokens) {
          this._getQueriesFor(token).forEach(function (query) {
              var queryReadToken = query.read || token;
              if (isBlank(queryReadTokens.get(queryReadToken.reference))) {
                  queryReadTokens.set(queryReadToken.reference, true);
              }
          });
      };
      ProviderElementContext.prototype._getQueriesFor = function (token) {
          var result = [];
          var currentEl = this;
          var distance = 0;
          var queries;
          while (currentEl !== null) {
              queries = currentEl._contentQueries.get(token.reference);
              if (isPresent(queries)) {
                  ListWrapper.addAll(result, queries.filter(function (query) { return query.descendants || distance <= 1; }));
              }
              if (currentEl._directiveAsts.length > 0) {
                  distance++;
              }
              currentEl = currentEl._parent;
          }
          queries = this.viewContext.viewQueries.get(token.reference);
          if (isPresent(queries)) {
              ListWrapper.addAll(result, queries);
          }
          return result;
      };
      ProviderElementContext.prototype._getOrCreateLocalProvider = function (requestingProviderType, token, eager) {
          var _this = this;
          var resolvedProvider = this._allProviders.get(token.reference);
          if (!resolvedProvider || ((requestingProviderType === exports.ProviderAstType.Directive ||
              requestingProviderType === exports.ProviderAstType.PublicService) &&
              resolvedProvider.providerType === exports.ProviderAstType.PrivateService) ||
              ((requestingProviderType === exports.ProviderAstType.PrivateService ||
                  requestingProviderType === exports.ProviderAstType.PublicService) &&
                  resolvedProvider.providerType === exports.ProviderAstType.Builtin)) {
              return null;
          }
          var transformedProviderAst = this._transformedProviders.get(token.reference);
          if (isPresent(transformedProviderAst)) {
              return transformedProviderAst;
          }
          if (isPresent(this._seenProviders.get(token.reference))) {
              this.viewContext.errors.push(new ProviderError("Cannot instantiate cyclic dependency! " + token.name, this._sourceSpan));
              return null;
          }
          this._seenProviders.set(token.reference, true);
          var transformedProviders = resolvedProvider.providers.map(function (provider) {
              var transformedUseValue = provider.useValue;
              var transformedUseExisting = provider.useExisting;
              var transformedDeps;
              if (isPresent(provider.useExisting)) {
                  var existingDiDep = _this._getDependency(resolvedProvider.providerType, new CompileDiDependencyMetadata({ token: provider.useExisting }), eager);
                  if (isPresent(existingDiDep.token)) {
                      transformedUseExisting = existingDiDep.token;
                  }
                  else {
                      transformedUseExisting = null;
                      transformedUseValue = existingDiDep.value;
                  }
              }
              else if (isPresent(provider.useFactory)) {
                  var deps = provider.deps || provider.useFactory.diDeps;
                  transformedDeps =
                      deps.map(function (dep) { return _this._getDependency(resolvedProvider.providerType, dep, eager); });
              }
              else if (isPresent(provider.useClass)) {
                  var deps = provider.deps || provider.useClass.diDeps;
                  transformedDeps =
                      deps.map(function (dep) { return _this._getDependency(resolvedProvider.providerType, dep, eager); });
              }
              return _transformProvider(provider, {
                  useExisting: transformedUseExisting,
                  useValue: transformedUseValue,
                  deps: transformedDeps
              });
          });
          transformedProviderAst =
              _transformProviderAst(resolvedProvider, { eager: eager, providers: transformedProviders });
          this._transformedProviders.set(token.reference, transformedProviderAst);
          return transformedProviderAst;
      };
      ProviderElementContext.prototype._getLocalDependency = function (requestingProviderType, dep, eager) {
          if (eager === void 0) { eager = null; }
          if (dep.isAttribute) {
              var attrValue = this._attrs[dep.token.value];
              return new CompileDiDependencyMetadata({ isValue: true, value: normalizeBlank(attrValue) });
          }
          if (isPresent(dep.query) || isPresent(dep.viewQuery)) {
              return dep;
          }
          if (isPresent(dep.token)) {
              // access builtints
              if ((requestingProviderType === exports.ProviderAstType.Directive ||
                  requestingProviderType === exports.ProviderAstType.Component)) {
                  if (dep.token.reference === resolveIdentifierToken(Identifiers.Renderer).reference ||
                      dep.token.reference === resolveIdentifierToken(Identifiers.ElementRef).reference ||
                      dep.token.reference ===
                          resolveIdentifierToken(Identifiers.ChangeDetectorRef).reference ||
                      dep.token.reference === resolveIdentifierToken(Identifiers.TemplateRef).reference) {
                      return dep;
                  }
                  if (dep.token.reference ===
                      resolveIdentifierToken(Identifiers.ViewContainerRef).reference) {
                      this._hasViewContainer = true;
                  }
              }
              // access the injector
              if (dep.token.reference === resolveIdentifierToken(Identifiers.Injector).reference) {
                  return dep;
              }
              // access providers
              if (isPresent(this._getOrCreateLocalProvider(requestingProviderType, dep.token, eager))) {
                  return dep;
              }
          }
          return null;
      };
      ProviderElementContext.prototype._getDependency = function (requestingProviderType, dep, eager) {
          if (eager === void 0) { eager = null; }
          var currElement = this;
          var currEager = eager;
          var result = null;
          if (!dep.isSkipSelf) {
              result = this._getLocalDependency(requestingProviderType, dep, eager);
          }
          if (dep.isSelf) {
              if (!result && dep.isOptional) {
                  result = new CompileDiDependencyMetadata({ isValue: true, value: null });
              }
          }
          else {
              // check parent elements
              while (!result && isPresent(currElement._parent)) {
                  var prevElement = currElement;
                  currElement = currElement._parent;
                  if (prevElement._isViewRoot) {
                      currEager = false;
                  }
                  result = currElement._getLocalDependency(exports.ProviderAstType.PublicService, dep, currEager);
              }
              // check @Host restriction
              if (!result) {
                  if (!dep.isHost || this.viewContext.component.type.isHost ||
                      this.viewContext.component.type.reference === dep.token.reference ||
                      isPresent(this.viewContext.viewProviders.get(dep.token.reference))) {
                      result = dep;
                  }
                  else {
                      result = dep.isOptional ?
                          result = new CompileDiDependencyMetadata({ isValue: true, value: null }) :
                          null;
                  }
              }
          }
          if (!result) {
              this.viewContext.errors.push(new ProviderError("No provider for " + dep.token.name, this._sourceSpan));
          }
          return result;
      };
      return ProviderElementContext;
  }());
  var NgModuleProviderAnalyzer = (function () {
      function NgModuleProviderAnalyzer(ngModule, extraProviders, sourceSpan) {
          var _this = this;
          this._transformedProviders = new Map();
          this._seenProviders = new Map();
          this._errors = [];
          this._allProviders = new Map();
          var ngModuleTypes = ngModule.transitiveModule.modules.map(function (moduleMeta) { return moduleMeta.type; });
          ngModuleTypes.forEach(function (ngModuleType) {
              var ngModuleProvider = new CompileProviderMetadata({ token: new CompileTokenMetadata({ identifier: ngModuleType }), useClass: ngModuleType });
              _resolveProviders([ngModuleProvider], exports.ProviderAstType.PublicService, true, sourceSpan, _this._errors, _this._allProviders);
          });
          _resolveProviders(_normalizeProviders(ngModule.transitiveModule.providers.concat(extraProviders), sourceSpan, this._errors), exports.ProviderAstType.PublicService, false, sourceSpan, this._errors, this._allProviders);
      }
      NgModuleProviderAnalyzer.prototype.parse = function () {
          var _this = this;
          MapWrapper.values(this._allProviders).forEach(function (provider) {
              _this._getOrCreateLocalProvider(provider.token, provider.eager);
          });
          if (this._errors.length > 0) {
              var errorString = this._errors.join('\n');
              throw new Error("Provider parse errors:\n" + errorString);
          }
          return MapWrapper.values(this._transformedProviders);
      };
      NgModuleProviderAnalyzer.prototype._getOrCreateLocalProvider = function (token, eager) {
          var _this = this;
          var resolvedProvider = this._allProviders.get(token.reference);
          if (!resolvedProvider) {
              return null;
          }
          var transformedProviderAst = this._transformedProviders.get(token.reference);
          if (isPresent(transformedProviderAst)) {
              return transformedProviderAst;
          }
          if (isPresent(this._seenProviders.get(token.reference))) {
              this._errors.push(new ProviderError("Cannot instantiate cyclic dependency! " + token.name, resolvedProvider.sourceSpan));
              return null;
          }
          this._seenProviders.set(token.reference, true);
          var transformedProviders = resolvedProvider.providers.map(function (provider) {
              var transformedUseValue = provider.useValue;
              var transformedUseExisting = provider.useExisting;
              var transformedDeps;
              if (isPresent(provider.useExisting)) {
                  var existingDiDep = _this._getDependency(new CompileDiDependencyMetadata({ token: provider.useExisting }), eager, resolvedProvider.sourceSpan);
                  if (isPresent(existingDiDep.token)) {
                      transformedUseExisting = existingDiDep.token;
                  }
                  else {
                      transformedUseExisting = null;
                      transformedUseValue = existingDiDep.value;
                  }
              }
              else if (isPresent(provider.useFactory)) {
                  var deps = provider.deps || provider.useFactory.diDeps;
                  transformedDeps =
                      deps.map(function (dep) { return _this._getDependency(dep, eager, resolvedProvider.sourceSpan); });
              }
              else if (isPresent(provider.useClass)) {
                  var deps = provider.deps || provider.useClass.diDeps;
                  transformedDeps =
                      deps.map(function (dep) { return _this._getDependency(dep, eager, resolvedProvider.sourceSpan); });
              }
              return _transformProvider(provider, {
                  useExisting: transformedUseExisting,
                  useValue: transformedUseValue,
                  deps: transformedDeps
              });
          });
          transformedProviderAst =
              _transformProviderAst(resolvedProvider, { eager: eager, providers: transformedProviders });
          this._transformedProviders.set(token.reference, transformedProviderAst);
          return transformedProviderAst;
      };
      NgModuleProviderAnalyzer.prototype._getDependency = function (dep, eager, requestorSourceSpan) {
          if (eager === void 0) { eager = null; }
          var foundLocal = false;
          if (!dep.isSkipSelf && isPresent(dep.token)) {
              // access the injector
              if (dep.token.reference === resolveIdentifierToken(Identifiers.Injector).reference ||
                  dep.token.reference ===
                      resolveIdentifierToken(Identifiers.ComponentFactoryResolver).reference) {
                  foundLocal = true;
              }
              else if (isPresent(this._getOrCreateLocalProvider(dep.token, eager))) {
                  foundLocal = true;
              }
          }
          var result = dep;
          if (dep.isSelf && !foundLocal) {
              if (dep.isOptional) {
                  result = new CompileDiDependencyMetadata({ isValue: true, value: null });
              }
              else {
                  this._errors.push(new ProviderError("No provider for " + dep.token.name, requestorSourceSpan));
              }
          }
          return result;
      };
      return NgModuleProviderAnalyzer;
  }());
  function _transformProvider(provider, _a) {
      var useExisting = _a.useExisting, useValue = _a.useValue, deps = _a.deps;
      return new CompileProviderMetadata({
          token: provider.token,
          useClass: provider.useClass,
          useExisting: useExisting,
          useFactory: provider.useFactory,
          useValue: useValue,
          deps: deps,
          multi: provider.multi
      });
  }
  function _transformProviderAst(provider, _a) {
      var eager = _a.eager, providers = _a.providers;
      return new ProviderAst(provider.token, provider.multiProvider, provider.eager || eager, providers, provider.providerType, provider.lifecycleHooks, provider.sourceSpan);
  }
  function _normalizeProviders(providers, sourceSpan, targetErrors, targetProviders) {
      if (targetProviders === void 0) { targetProviders = null; }
      if (!targetProviders) {
          targetProviders = [];
      }
      if (isPresent(providers)) {
          providers.forEach(function (provider) {
              if (Array.isArray(provider)) {
                  _normalizeProviders(provider, sourceSpan, targetErrors, targetProviders);
              }
              else {
                  var normalizeProvider = void 0;
                  if (provider instanceof CompileProviderMetadata) {
                      normalizeProvider = provider;
                  }
                  else if (provider instanceof CompileTypeMetadata) {
                      normalizeProvider = new CompileProviderMetadata({ token: new CompileTokenMetadata({ identifier: provider }), useClass: provider });
                  }
                  else {
                      targetErrors.push(new ProviderError("Unknown provider type " + provider, sourceSpan));
                  }
                  if (isPresent(normalizeProvider)) {
                      targetProviders.push(normalizeProvider);
                  }
              }
          });
      }
      return targetProviders;
  }
  function _resolveProvidersFromDirectives(directives, sourceSpan, targetErrors) {
      var providersByToken = new Map();
      directives.forEach(function (directive) {
          var dirProvider = new CompileProviderMetadata({ token: new CompileTokenMetadata({ identifier: directive.type }), useClass: directive.type });
          _resolveProviders([dirProvider], directive.isComponent ? exports.ProviderAstType.Component : exports.ProviderAstType.Directive, true, sourceSpan, targetErrors, providersByToken);
      });
      // Note: directives need to be able to overwrite providers of a component!
      var directivesWithComponentFirst = directives.filter(function (dir) { return dir.isComponent; }).concat(directives.filter(function (dir) { return !dir.isComponent; }));
      directivesWithComponentFirst.forEach(function (directive) {
          _resolveProviders(_normalizeProviders(directive.providers, sourceSpan, targetErrors), exports.ProviderAstType.PublicService, false, sourceSpan, targetErrors, providersByToken);
          _resolveProviders(_normalizeProviders(directive.viewProviders, sourceSpan, targetErrors), exports.ProviderAstType.PrivateService, false, sourceSpan, targetErrors, providersByToken);
      });
      return providersByToken;
  }
  function _resolveProviders(providers, providerType, eager, sourceSpan, targetErrors, targetProvidersByToken) {
      providers.forEach(function (provider) {
          var resolvedProvider = targetProvidersByToken.get(provider.token.reference);
          if (isPresent(resolvedProvider) && resolvedProvider.multiProvider !== provider.multi) {
              targetErrors.push(new ProviderError("Mixing multi and non multi provider is not possible for token " + resolvedProvider.token.name, sourceSpan));
          }
          if (!resolvedProvider) {
              var lifecycleHooks = provider.token.identifier && provider.token.identifier instanceof CompileTypeMetadata ?
                  provider.token.identifier.lifecycleHooks :
                  [];
              resolvedProvider = new ProviderAst(provider.token, provider.multi, eager || lifecycleHooks.length > 0, [provider], providerType, lifecycleHooks, sourceSpan);
              targetProvidersByToken.set(provider.token.reference, resolvedProvider);
          }
          else {
              if (!provider.multi) {
                  ListWrapper.clear(resolvedProvider.providers);
              }
              resolvedProvider.providers.push(provider);
          }
      });
  }
  function _getViewQueries(component) {
      var viewQueries = new Map();
      if (isPresent(component.viewQueries)) {
          component.viewQueries.forEach(function (query) { return _addQueryToTokenMap(viewQueries, query); });
      }
      component.type.diDeps.forEach(function (dep) {
          if (isPresent(dep.viewQuery)) {
              _addQueryToTokenMap(viewQueries, dep.viewQuery);
          }
      });
      return viewQueries;
  }
  function _getContentQueries(directives) {
      var contentQueries = new Map();
      directives.forEach(function (directive) {
          if (isPresent(directive.queries)) {
              directive.queries.forEach(function (query) { return _addQueryToTokenMap(contentQueries, query); });
          }
          directive.type.diDeps.forEach(function (dep) {
              if (isPresent(dep.query)) {
                  _addQueryToTokenMap(contentQueries, dep.query);
              }
          });
      });
      return contentQueries;
  }
  function _addQueryToTokenMap(map, query) {
      query.selectors.forEach(function (token) {
          var entry = map.get(token.reference);
          if (!entry) {
              entry = [];
              map.set(token.reference, entry);
          }
          entry.push(query);
      });
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var ElementSchemaRegistry = (function () {
      function ElementSchemaRegistry() {
      }
      return ElementSchemaRegistry;
  }());

  var StyleWithImports = (function () {
      function StyleWithImports(style, styleUrls) {
          this.style = style;
          this.styleUrls = styleUrls;
      }
      return StyleWithImports;
  }());
  function isStyleUrlResolvable(url) {
      if (isBlank(url) || url.length === 0 || url[0] == '/')
          return false;
      var schemeMatch = url.match(_urlWithSchemaRe);
      return schemeMatch === null || schemeMatch[1] == 'package' || schemeMatch[1] == 'asset';
  }
  /**
   * Rewrites stylesheets by resolving and removing the @import urls that
   * are either relative or don't have a `package:` scheme
   */
  function extractStyleUrls(resolver, baseUrl, cssText) {
      var foundUrls = [];
      var modifiedCssText = cssText.replace(_cssImportRe, function () {
          var m = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              m[_i - 0] = arguments[_i];
          }
          var url = m[1] || m[2];
          if (!isStyleUrlResolvable(url)) {
              // Do not attempt to resolve non-package absolute URLs with URI scheme
              return m[0];
          }
          foundUrls.push(resolver.resolve(baseUrl, url));
          return '';
      });
      return new StyleWithImports(modifiedCssText, foundUrls);
  }
  var _cssImportRe = /@import\s+(?:url\()?\s*(?:(?:['"]([^'"]*))|([^;\)\s]*))[^;]*;?/g;
  var _urlWithSchemaRe = /^([^:/?#]+):/;

  var NG_CONTENT_SELECT_ATTR = 'select';
  var NG_CONTENT_ELEMENT = 'ng-content';
  var LINK_ELEMENT = 'link';
  var LINK_STYLE_REL_ATTR = 'rel';
  var LINK_STYLE_HREF_ATTR = 'href';
  var LINK_STYLE_REL_VALUE = 'stylesheet';
  var STYLE_ELEMENT = 'style';
  var SCRIPT_ELEMENT = 'script';
  var NG_NON_BINDABLE_ATTR = 'ngNonBindable';
  var NG_PROJECT_AS = 'ngProjectAs';
  function preparseElement(ast) {
      var selectAttr = null;
      var hrefAttr = null;
      var relAttr = null;
      var nonBindable = false;
      var projectAs = null;
      ast.attrs.forEach(function (attr) {
          var lcAttrName = attr.name.toLowerCase();
          if (lcAttrName == NG_CONTENT_SELECT_ATTR) {
              selectAttr = attr.value;
          }
          else if (lcAttrName == LINK_STYLE_HREF_ATTR) {
              hrefAttr = attr.value;
          }
          else if (lcAttrName == LINK_STYLE_REL_ATTR) {
              relAttr = attr.value;
          }
          else if (attr.name == NG_NON_BINDABLE_ATTR) {
              nonBindable = true;
          }
          else if (attr.name == NG_PROJECT_AS) {
              if (attr.value.length > 0) {
                  projectAs = attr.value;
              }
          }
      });
      selectAttr = normalizeNgContentSelect(selectAttr);
      var nodeName = ast.name.toLowerCase();
      var type = PreparsedElementType.OTHER;
      if (splitNsName(nodeName)[1] == NG_CONTENT_ELEMENT) {
          type = PreparsedElementType.NG_CONTENT;
      }
      else if (nodeName == STYLE_ELEMENT) {
          type = PreparsedElementType.STYLE;
      }
      else if (nodeName == SCRIPT_ELEMENT) {
          type = PreparsedElementType.SCRIPT;
      }
      else if (nodeName == LINK_ELEMENT && relAttr == LINK_STYLE_REL_VALUE) {
          type = PreparsedElementType.STYLESHEET;
      }
      return new PreparsedElement(type, selectAttr, hrefAttr, nonBindable, projectAs);
  }
  var PreparsedElementType;
  (function (PreparsedElementType) {
      PreparsedElementType[PreparsedElementType["NG_CONTENT"] = 0] = "NG_CONTENT";
      PreparsedElementType[PreparsedElementType["STYLE"] = 1] = "STYLE";
      PreparsedElementType[PreparsedElementType["STYLESHEET"] = 2] = "STYLESHEET";
      PreparsedElementType[PreparsedElementType["SCRIPT"] = 3] = "SCRIPT";
      PreparsedElementType[PreparsedElementType["OTHER"] = 4] = "OTHER";
  })(PreparsedElementType || (PreparsedElementType = {}));
  var PreparsedElement = (function () {
      function PreparsedElement(type, selectAttr, hrefAttr, nonBindable, projectAs) {
          this.type = type;
          this.selectAttr = selectAttr;
          this.hrefAttr = hrefAttr;
          this.nonBindable = nonBindable;
          this.projectAs = projectAs;
      }
      return PreparsedElement;
  }());
  function normalizeNgContentSelect(selectAttr) {
      if (selectAttr === null || selectAttr.length === 0) {
          return '*';
      }
      return selectAttr;
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var __extends = (this && this.__extends) || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  // Group 1 = "bind-"
  // Group 2 = "let-"
  // Group 3 = "ref-/#"
  // Group 4 = "on-"
  // Group 5 = "bindon-"
  // Group 6 = "@"
  // Group 7 = the identifier after "bind-", "let-", "ref-/#", "on-", "bindon-" or "@"
  // Group 8 = identifier inside [()]
  // Group 9 = identifier inside []
  // Group 10 = identifier inside ()
  var BIND_NAME_REGEXP = /^(?:(?:(?:(bind-)|(let-)|(ref-|#)|(on-)|(bindon-)|(@))(.+))|\[\(([^\)]+)\)\]|\[([^\]]+)\]|\(([^\)]+)\))$/;
  var KW_BIND_IDX = 1;
  var KW_LET_IDX = 2;
  var KW_REF_IDX = 3;
  var KW_ON_IDX = 4;
  var KW_BINDON_IDX = 5;
  var KW_AT_IDX = 6;
  var IDENT_KW_IDX = 7;
  var IDENT_BANANA_BOX_IDX = 8;
  var IDENT_PROPERTY_IDX = 9;
  var IDENT_EVENT_IDX = 10;
  var ANIMATE_PROP_PREFIX = 'animate-';
  var TEMPLATE_ELEMENT = 'template';
  var TEMPLATE_ATTR = 'template';
  var TEMPLATE_ATTR_PREFIX = '*';
  var CLASS_ATTR = 'class';
  var PROPERTY_PARTS_SEPARATOR = '.';
  var ATTRIBUTE_PREFIX = 'attr';
  var CLASS_PREFIX = 'class';
  var STYLE_PREFIX = 'style';
  var TEXT_CSS_SELECTOR = CssSelector.parse('*')[0];
  /**
   * Provides an array of {@link TemplateAstVisitor}s which will be used to transform
   * parsed templates before compilation is invoked, allowing custom expression syntax
   * and other advanced transformations.
   *
   * This is currently an internal-only feature and not meant for general use.
   */
  var TEMPLATE_TRANSFORMS = new _angular_core.OpaqueToken('TemplateTransforms');
  var TemplateParseError = (function (_super) {
      __extends(TemplateParseError, _super);
      function TemplateParseError(message, span, level) {
          _super.call(this, span, message, level);
      }
      return TemplateParseError;
  }(ParseError));
  var TemplateParseResult = (function () {
      function TemplateParseResult(templateAst, errors) {
          this.templateAst = templateAst;
          this.errors = errors;
      }
      return TemplateParseResult;
  }());
  var TemplateParser = (function () {
      function TemplateParser(_exprParser, _schemaRegistry, _htmlParser, _console, transforms) {
          this._exprParser = _exprParser;
          this._schemaRegistry = _schemaRegistry;
          this._htmlParser = _htmlParser;
          this._console = _console;
          this.transforms = transforms;
      }
      TemplateParser.prototype.parse = function (component, template, directives, pipes, schemas, templateUrl) {
          var result = this.tryParse(component, template, directives, pipes, schemas, templateUrl);
          var warnings = result.errors.filter(function (error) { return error.level === exports.ParseErrorLevel.WARNING; });
          var errors = result.errors.filter(function (error) { return error.level === exports.ParseErrorLevel.FATAL; });
          if (warnings.length > 0) {
              this._console.warn("Template parse warnings:\n" + warnings.join('\n'));
          }
          if (errors.length > 0) {
              var errorString = errors.join('\n');
              throw new Error("Template parse errors:\n" + errorString);
          }
          return result.templateAst;
      };
      TemplateParser.prototype.tryParse = function (component, template, directives, pipes, schemas, templateUrl) {
          return this.tryParseHtml(this.expandHtml(this._htmlParser.parse(template, templateUrl, true, this.getInterpolationConfig(component))), component, template, directives, pipes, schemas, templateUrl);
      };
      TemplateParser.prototype.tryParseHtml = function (htmlAstWithErrors, component, template, directives, pipes, schemas, templateUrl) {
          var result;
          var errors = htmlAstWithErrors.errors;
          if (htmlAstWithErrors.rootNodes.length > 0) {
              var uniqDirectives = removeIdentifierDuplicates(directives);
              var uniqPipes = removeIdentifierDuplicates(pipes);
              var providerViewContext = new ProviderViewContext(component, htmlAstWithErrors.rootNodes[0].sourceSpan);
              var parseVisitor = new TemplateParseVisitor(providerViewContext, uniqDirectives, uniqPipes, schemas, this._exprParser, this._schemaRegistry);
              result = visitAll(parseVisitor, htmlAstWithErrors.rootNodes, EMPTY_ELEMENT_CONTEXT);
              errors.push.apply(errors, parseVisitor.errors.concat(providerViewContext.errors));
          }
          else {
              result = [];
          }
          this._assertNoReferenceDuplicationOnTemplate(result, errors);
          if (errors.length > 0) {
              return new TemplateParseResult(result, errors);
          }
          if (isPresent(this.transforms)) {
              this.transforms.forEach(function (transform) { result = templateVisitAll(transform, result); });
          }
          return new TemplateParseResult(result, errors);
      };
      TemplateParser.prototype.expandHtml = function (htmlAstWithErrors, forced) {
          if (forced === void 0) { forced = false; }
          var errors = htmlAstWithErrors.errors;
          if (errors.length == 0 || forced) {
              // Transform ICU messages to angular directives
              var expandedHtmlAst = expandNodes(htmlAstWithErrors.rootNodes);
              errors.push.apply(errors, expandedHtmlAst.errors);
              htmlAstWithErrors = new ParseTreeResult(expandedHtmlAst.nodes, errors);
          }
          return htmlAstWithErrors;
      };
      TemplateParser.prototype.getInterpolationConfig = function (component) {
          if (component.template) {
              return InterpolationConfig.fromArray(component.template.interpolation);
          }
      };
      /** @internal */
      TemplateParser.prototype._assertNoReferenceDuplicationOnTemplate = function (result, errors) {
          var existingReferences = [];
          result.filter(function (element) { return !!element.references; })
              .forEach(function (element) { return element.references.forEach(function (reference) {
              var name = reference.name;
              if (existingReferences.indexOf(name) < 0) {
                  existingReferences.push(name);
              }
              else {
                  var error = new TemplateParseError("Reference \"#" + name + "\" is defined several times", reference.sourceSpan, exports.ParseErrorLevel.FATAL);
                  errors.push(error);
              }
          }); });
      };
      TemplateParser.decorators = [
          { type: _angular_core.Injectable },
      ];
      /** @nocollapse */
      TemplateParser.ctorParameters = [
          { type: Parser, },
          { type: ElementSchemaRegistry, },
          { type: I18NHtmlParser, },
          { type: Console, },
          { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Inject, args: [TEMPLATE_TRANSFORMS,] },] },
      ];
      return TemplateParser;
  }());
  var TemplateParseVisitor = (function () {
      function TemplateParseVisitor(providerViewContext, directives, pipes, _schemas, _exprParser, _schemaRegistry) {
          var _this = this;
          this.providerViewContext = providerViewContext;
          this._schemas = _schemas;
          this._exprParser = _exprParser;
          this._schemaRegistry = _schemaRegistry;
          this.selectorMatcher = new SelectorMatcher();
          this.errors = [];
          this.directivesIndex = new Map();
          this.ngContentCount = 0;
          this.pipesByName = new Map();
          var tempMeta = providerViewContext.component.template;
          if (tempMeta && tempMeta.interpolation) {
              this._interpolationConfig = {
                  start: tempMeta.interpolation[0],
                  end: tempMeta.interpolation[1]
              };
          }
          directives.forEach(function (directive, index) {
              var selector = CssSelector.parse(directive.selector);
              _this.selectorMatcher.addSelectables(selector, directive);
              _this.directivesIndex.set(directive, index);
          });
          pipes.forEach(function (pipe) { return _this.pipesByName.set(pipe.name, pipe); });
      }
      TemplateParseVisitor.prototype._reportError = function (message, sourceSpan, level) {
          if (level === void 0) { level = exports.ParseErrorLevel.FATAL; }
          this.errors.push(new TemplateParseError(message, sourceSpan, level));
      };
      TemplateParseVisitor.prototype._reportParserErrors = function (errors, sourceSpan) {
          for (var _i = 0, errors_1 = errors; _i < errors_1.length; _i++) {
              var error = errors_1[_i];
              this._reportError(error.message, sourceSpan);
          }
      };
      TemplateParseVisitor.prototype._parseInterpolation = function (value, sourceSpan) {
          var sourceInfo = sourceSpan.start.toString();
          try {
              var ast = this._exprParser.parseInterpolation(value, sourceInfo, this._interpolationConfig);
              if (ast)
                  this._reportParserErrors(ast.errors, sourceSpan);
              this._checkPipes(ast, sourceSpan);
              if (isPresent(ast) &&
                  ast.ast.expressions.length > view_utils.MAX_INTERPOLATION_VALUES) {
                  throw new Error("Only support at most " + view_utils.MAX_INTERPOLATION_VALUES + " interpolation values!");
              }
              return ast;
          }
          catch (e) {
              this._reportError("" + e, sourceSpan);
              return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);
          }
      };
      TemplateParseVisitor.prototype._parseAction = function (value, sourceSpan) {
          var sourceInfo = sourceSpan.start.toString();
          try {
              var ast = this._exprParser.parseAction(value, sourceInfo, this._interpolationConfig);
              if (ast) {
                  this._reportParserErrors(ast.errors, sourceSpan);
              }
              if (!ast || ast.ast instanceof EmptyExpr) {
                  this._reportError("Empty expressions are not allowed", sourceSpan);
                  return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);
              }
              this._checkPipes(ast, sourceSpan);
              return ast;
          }
          catch (e) {
              this._reportError("" + e, sourceSpan);
              return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);
          }
      };
      TemplateParseVisitor.prototype._parseBinding = function (value, sourceSpan) {
          var sourceInfo = sourceSpan.start.toString();
          try {
              var ast = this._exprParser.parseBinding(value, sourceInfo, this._interpolationConfig);
              if (ast)
                  this._reportParserErrors(ast.errors, sourceSpan);
              this._checkPipes(ast, sourceSpan);
              return ast;
          }
          catch (e) {
              this._reportError("" + e, sourceSpan);
              return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);
          }
      };
      TemplateParseVisitor.prototype._parseTemplateBindings = function (value, sourceSpan) {
          var _this = this;
          var sourceInfo = sourceSpan.start.toString();
          try {
              var bindingsResult = this._exprParser.parseTemplateBindings(value, sourceInfo);
              this._reportParserErrors(bindingsResult.errors, sourceSpan);
              bindingsResult.templateBindings.forEach(function (binding) {
                  if (isPresent(binding.expression)) {
                      _this._checkPipes(binding.expression, sourceSpan);
                  }
              });
              bindingsResult.warnings.forEach(function (warning) { _this._reportError(warning, sourceSpan, exports.ParseErrorLevel.WARNING); });
              return bindingsResult.templateBindings;
          }
          catch (e) {
              this._reportError("" + e, sourceSpan);
              return [];
          }
      };
      TemplateParseVisitor.prototype._checkPipes = function (ast, sourceSpan) {
          var _this = this;
          if (isPresent(ast)) {
              var collector = new PipeCollector();
              ast.visit(collector);
              collector.pipes.forEach(function (pipeName) {
                  if (!_this.pipesByName.has(pipeName)) {
                      _this._reportError("The pipe '" + pipeName + "' could not be found", sourceSpan);
                  }
              });
          }
      };
      TemplateParseVisitor.prototype.visitExpansion = function (expansion, context) { return null; };
      TemplateParseVisitor.prototype.visitExpansionCase = function (expansionCase, context) { return null; };
      TemplateParseVisitor.prototype.visitText = function (text, parent) {
          var ngContentIndex = parent.findNgContentIndex(TEXT_CSS_SELECTOR);
          var expr = this._parseInterpolation(text.value, text.sourceSpan);
          if (isPresent(expr)) {
              return new BoundTextAst(expr, ngContentIndex, text.sourceSpan);
          }
          else {
              return new TextAst(text.value, ngContentIndex, text.sourceSpan);
          }
      };
      TemplateParseVisitor.prototype.visitAttribute = function (attribute, context) {
          return new AttrAst(attribute.name, attribute.value, attribute.sourceSpan);
      };
      TemplateParseVisitor.prototype.visitComment = function (comment, context) { return null; };
      TemplateParseVisitor.prototype.visitElement = function (element, parent) {
          var _this = this;
          var nodeName = element.name;
          var preparsedElement = preparseElement(element);
          if (preparsedElement.type === PreparsedElementType.SCRIPT ||
              preparsedElement.type === PreparsedElementType.STYLE) {
              // Skipping <script> for security reasons
              // Skipping <style> as we already processed them
              // in the StyleCompiler
              return null;
          }
          if (preparsedElement.type === PreparsedElementType.STYLESHEET &&
              isStyleUrlResolvable(preparsedElement.hrefAttr)) {
              // Skipping stylesheets with either relative urls or package scheme as we already processed
              // them in the StyleCompiler
              return null;
          }
          var matchableAttrs = [];
          var elementOrDirectiveProps = [];
          var elementOrDirectiveRefs = [];
          var elementVars = [];
          var animationProps = [];
          var events = [];
          var templateElementOrDirectiveProps = [];
          var templateMatchableAttrs = [];
          var templateElementVars = [];
          var hasInlineTemplates = false;
          var attrs = [];
          var lcElName = splitNsName(nodeName.toLowerCase())[1];
          var isTemplateElement = lcElName == TEMPLATE_ELEMENT;
          element.attrs.forEach(function (attr) {
              var hasBinding = _this._parseAttr(isTemplateElement, attr, matchableAttrs, elementOrDirectiveProps, animationProps, events, elementOrDirectiveRefs, elementVars);
              var hasTemplateBinding = _this._parseInlineTemplateBinding(attr, templateMatchableAttrs, templateElementOrDirectiveProps, templateElementVars);
              if (hasTemplateBinding && hasInlineTemplates) {
                  _this._reportError("Can't have multiple template bindings on one element. Use only one attribute named 'template' or prefixed with *", attr.sourceSpan);
              }
              if (!hasBinding && !hasTemplateBinding) {
                  // don't include the bindings as attributes as well in the AST
                  attrs.push(_this.visitAttribute(attr, null));
                  matchableAttrs.push([attr.name, attr.value]);
              }
              if (hasTemplateBinding) {
                  hasInlineTemplates = true;
              }
          });
          var elementCssSelector = createElementCssSelector(nodeName, matchableAttrs);
          var _a = this._parseDirectives(this.selectorMatcher, elementCssSelector), directiveMetas = _a.directives, matchElement = _a.matchElement;
          var references = [];
          var directiveAsts = this._createDirectiveAsts(isTemplateElement, element.name, directiveMetas, elementOrDirectiveProps, elementOrDirectiveRefs, element.sourceSpan, references);
          var elementProps = this._createElementPropertyAsts(element.name, elementOrDirectiveProps, directiveAsts)
              .concat(animationProps);
          var isViewRoot = parent.isTemplateElement || hasInlineTemplates;
          var providerContext = new ProviderElementContext(this.providerViewContext, parent.providerContext, isViewRoot, directiveAsts, attrs, references, element.sourceSpan);
          var children = visitAll(preparsedElement.nonBindable ? NON_BINDABLE_VISITOR : this, element.children, ElementContext.create(isTemplateElement, directiveAsts, isTemplateElement ? parent.providerContext : providerContext));
          providerContext.afterElement();
          // Override the actual selector when the `ngProjectAs` attribute is provided
          var projectionSelector = isPresent(preparsedElement.projectAs) ?
              CssSelector.parse(preparsedElement.projectAs)[0] :
              elementCssSelector;
          var ngContentIndex = parent.findNgContentIndex(projectionSelector);
          var parsedElement;
          if (preparsedElement.type === PreparsedElementType.NG_CONTENT) {
              if (element.children && !element.children.every(_isEmptyTextNode)) {
                  this._reportError("<ng-content> element cannot have content.", element.sourceSpan);
              }
              parsedElement = new NgContentAst(this.ngContentCount++, hasInlineTemplates ? null : ngContentIndex, element.sourceSpan);
          }
          else if (isTemplateElement) {
              this._assertAllEventsPublishedByDirectives(directiveAsts, events);
              this._assertNoComponentsNorElementBindingsOnTemplate(directiveAsts, elementProps, element.sourceSpan);
              parsedElement = new EmbeddedTemplateAst(attrs, events, references, elementVars, providerContext.transformedDirectiveAsts, providerContext.transformProviders, providerContext.transformedHasViewContainer, children, hasInlineTemplates ? null : ngContentIndex, element.sourceSpan);
          }
          else {
              this._assertElementExists(matchElement, element);
              this._assertOnlyOneComponent(directiveAsts, element.sourceSpan);
              var ngContentIndex_1 = hasInlineTemplates ? null : parent.findNgContentIndex(projectionSelector);
              parsedElement = new ElementAst(nodeName, attrs, elementProps, events, references, providerContext.transformedDirectiveAsts, providerContext.transformProviders, providerContext.transformedHasViewContainer, children, hasInlineTemplates ? null : ngContentIndex_1, element.sourceSpan, element.endSourceSpan);
              this._findComponentDirectives(directiveAsts)
                  .forEach(function (componentDirectiveAst) { return _this._validateElementAnimationInputOutputs(componentDirectiveAst.hostProperties, componentDirectiveAst.hostEvents, componentDirectiveAst.directive.template); });
              var componentTemplate = providerContext.viewContext.component.template;
              this._validateElementAnimationInputOutputs(elementProps, events, componentTemplate);
          }
          if (hasInlineTemplates) {
              var templateCssSelector = createElementCssSelector(TEMPLATE_ELEMENT, templateMatchableAttrs);
              var templateDirectiveMetas = this._parseDirectives(this.selectorMatcher, templateCssSelector).directives;
              var templateDirectiveAsts = this._createDirectiveAsts(true, element.name, templateDirectiveMetas, templateElementOrDirectiveProps, [], element.sourceSpan, []);
              var templateElementProps = this._createElementPropertyAsts(element.name, templateElementOrDirectiveProps, templateDirectiveAsts);
              this._assertNoComponentsNorElementBindingsOnTemplate(templateDirectiveAsts, templateElementProps, element.sourceSpan);
              var templateProviderContext = new ProviderElementContext(this.providerViewContext, parent.providerContext, parent.isTemplateElement, templateDirectiveAsts, [], [], element.sourceSpan);
              templateProviderContext.afterElement();
              parsedElement = new EmbeddedTemplateAst([], [], [], templateElementVars, templateProviderContext.transformedDirectiveAsts, templateProviderContext.transformProviders, templateProviderContext.transformedHasViewContainer, [parsedElement], ngContentIndex, element.sourceSpan);
          }
          return parsedElement;
      };
      TemplateParseVisitor.prototype._validateElementAnimationInputOutputs = function (inputs, outputs, template) {
          var _this = this;
          var triggerLookup = new Set();
          template.animations.forEach(function (entry) { triggerLookup.add(entry.name); });
          var animationInputs = inputs.filter(function (input) { return input.isAnimation; });
          animationInputs.forEach(function (input) {
              var name = input.name;
              if (!triggerLookup.has(name)) {
                  _this._reportError("Couldn't find an animation entry for \"" + name + "\"", input.sourceSpan);
              }
          });
          outputs.forEach(function (output) {
              if (output.isAnimation) {
                  var found = animationInputs.find(function (input) { return input.name == output.name; });
                  if (!found) {
                      _this._reportError("Unable to listen on (@" + output.name + "." + output.phase + ") because the animation trigger [@" + output.name + "] isn't being used on the same element", output.sourceSpan);
                  }
              }
          });
      };
      TemplateParseVisitor.prototype._parseInlineTemplateBinding = function (attr, targetMatchableAttrs, targetProps, targetVars) {
          var templateBindingsSource = null;
          if (this._normalizeAttributeName(attr.name) == TEMPLATE_ATTR) {
              templateBindingsSource = attr.value;
          }
          else if (attr.name.startsWith(TEMPLATE_ATTR_PREFIX)) {
              var key = attr.name.substring(TEMPLATE_ATTR_PREFIX.length); // remove the star
              templateBindingsSource = (attr.value.length == 0) ? key : key + ' ' + attr.value;
          }
          if (isPresent(templateBindingsSource)) {
              var bindings = this._parseTemplateBindings(templateBindingsSource, attr.sourceSpan);
              for (var i = 0; i < bindings.length; i++) {
                  var binding = bindings[i];
                  if (binding.keyIsVar) {
                      targetVars.push(new VariableAst(binding.key, binding.name, attr.sourceSpan));
                  }
                  else if (isPresent(binding.expression)) {
                      this._parsePropertyAst(binding.key, binding.expression, attr.sourceSpan, targetMatchableAttrs, targetProps);
                  }
                  else {
                      targetMatchableAttrs.push([binding.key, '']);
                      this._parseLiteralAttr(binding.key, null, attr.sourceSpan, targetProps);
                  }
              }
              return true;
          }
          return false;
      };
      TemplateParseVisitor.prototype._parseAttr = function (isTemplateElement, attr, targetMatchableAttrs, targetProps, targetAnimationProps, targetEvents, targetRefs, targetVars) {
          var name = this._normalizeAttributeName(attr.name);
          var value = attr.value;
          var srcSpan = attr.sourceSpan;
          var bindParts = name.match(BIND_NAME_REGEXP);
          var hasBinding = false;
          if (bindParts !== null) {
              hasBinding = true;
              if (isPresent(bindParts[KW_BIND_IDX])) {
                  this._parsePropertyOrAnimation(bindParts[IDENT_KW_IDX], value, srcSpan, targetMatchableAttrs, targetProps, targetAnimationProps);
              }
              else if (bindParts[KW_LET_IDX]) {
                  if (isTemplateElement) {
                      var identifier = bindParts[IDENT_KW_IDX];
                      this._parseVariable(identifier, value, srcSpan, targetVars);
                  }
                  else {
                      this._reportError("\"let-\" is only supported on template elements.", srcSpan);
                  }
              }
              else if (bindParts[KW_REF_IDX]) {
                  var identifier = bindParts[IDENT_KW_IDX];
                  this._parseReference(identifier, value, srcSpan, targetRefs);
              }
              else if (bindParts[KW_ON_IDX]) {
                  this._parseEventOrAnimationEvent(bindParts[IDENT_KW_IDX], value, srcSpan, targetMatchableAttrs, targetEvents);
              }
              else if (bindParts[KW_BINDON_IDX]) {
                  this._parsePropertyOrAnimation(bindParts[IDENT_KW_IDX], value, srcSpan, targetMatchableAttrs, targetProps, targetAnimationProps);
                  this._parseAssignmentEvent(bindParts[IDENT_KW_IDX], value, srcSpan, targetMatchableAttrs, targetEvents);
              }
              else if (bindParts[KW_AT_IDX]) {
                  if (_isAnimationLabel(name) && isPresent(value) && value.length > 0) {
                      this._reportError("Assigning animation triggers via @prop=\"exp\" attributes with an expression is invalid." +
                          " Use property bindings (e.g. [@prop]=\"exp\") or use an attribute without a value (e.g. @prop) instead.", srcSpan, exports.ParseErrorLevel.FATAL);
                  }
                  this._parseAnimation(bindParts[IDENT_KW_IDX], value, srcSpan, targetMatchableAttrs, targetAnimationProps);
              }
              else if (bindParts[IDENT_BANANA_BOX_IDX]) {
                  this._parsePropertyOrAnimation(bindParts[IDENT_BANANA_BOX_IDX], value, srcSpan, targetMatchableAttrs, targetProps, targetAnimationProps);
                  this._parseAssignmentEvent(bindParts[IDENT_BANANA_BOX_IDX], value, srcSpan, targetMatchableAttrs, targetEvents);
              }
              else if (bindParts[IDENT_PROPERTY_IDX]) {
                  this._parsePropertyOrAnimation(bindParts[IDENT_PROPERTY_IDX], value, srcSpan, targetMatchableAttrs, targetProps, targetAnimationProps);
              }
              else if (bindParts[IDENT_EVENT_IDX]) {
                  this._parseEventOrAnimationEvent(bindParts[IDENT_EVENT_IDX], value, srcSpan, targetMatchableAttrs, targetEvents);
              }
          }
          else {
              hasBinding =
                  this._parsePropertyInterpolation(name, value, srcSpan, targetMatchableAttrs, targetProps);
          }
          if (!hasBinding) {
              this._parseLiteralAttr(name, value, srcSpan, targetProps);
          }
          return hasBinding;
      };
      TemplateParseVisitor.prototype._normalizeAttributeName = function (attrName) {
          return /^data-/i.test(attrName) ? attrName.substring(5) : attrName;
      };
      TemplateParseVisitor.prototype._parseVariable = function (identifier, value, sourceSpan, targetVars) {
          if (identifier.indexOf('-') > -1) {
              this._reportError("\"-\" is not allowed in variable names", sourceSpan);
          }
          targetVars.push(new VariableAst(identifier, value, sourceSpan));
      };
      TemplateParseVisitor.prototype._parseReference = function (identifier, value, sourceSpan, targetRefs) {
          if (identifier.indexOf('-') > -1) {
              this._reportError("\"-\" is not allowed in reference names", sourceSpan);
          }
          targetRefs.push(new ElementOrDirectiveRef(identifier, value, sourceSpan));
      };
      TemplateParseVisitor.prototype._parsePropertyOrAnimation = function (name, expression, sourceSpan, targetMatchableAttrs, targetProps, targetAnimationProps) {
          var animatePropLength = ANIMATE_PROP_PREFIX.length;
          var isAnimationProp = _isAnimationLabel(name);
          var animationPrefixLength = 1;
          if (name.substring(0, animatePropLength) == ANIMATE_PROP_PREFIX) {
              isAnimationProp = true;
              animationPrefixLength = animatePropLength;
          }
          if (isAnimationProp) {
              this._parseAnimation(name.substr(animationPrefixLength), expression, sourceSpan, targetMatchableAttrs, targetAnimationProps);
          }
          else {
              this._parsePropertyAst(name, this._parseBinding(expression, sourceSpan), sourceSpan, targetMatchableAttrs, targetProps);
          }
      };
      TemplateParseVisitor.prototype._parseAnimation = function (name, expression, sourceSpan, targetMatchableAttrs, targetAnimationProps) {
          // This will occur when a @trigger is not paired with an expression.
          // For animations it is valid to not have an expression since */void
          // states will be applied by angular when the element is attached/detached
          if (!isPresent(expression) || expression.length == 0) {
              expression = 'null';
          }
          var ast = this._parseBinding(expression, sourceSpan);
          targetMatchableAttrs.push([name, ast.source]);
          targetAnimationProps.push(new BoundElementPropertyAst(name, exports.PropertyBindingType.Animation, _angular_core.SecurityContext.NONE, ast, null, sourceSpan));
      };
      TemplateParseVisitor.prototype._parsePropertyInterpolation = function (name, value, sourceSpan, targetMatchableAttrs, targetProps) {
          var expr = this._parseInterpolation(value, sourceSpan);
          if (isPresent(expr)) {
              this._parsePropertyAst(name, expr, sourceSpan, targetMatchableAttrs, targetProps);
              return true;
          }
          return false;
      };
      TemplateParseVisitor.prototype._parsePropertyAst = function (name, ast, sourceSpan, targetMatchableAttrs, targetProps) {
          targetMatchableAttrs.push([name, ast.source]);
          targetProps.push(new BoundElementOrDirectiveProperty(name, ast, false, sourceSpan));
      };
      TemplateParseVisitor.prototype._parseAssignmentEvent = function (name, expression, sourceSpan, targetMatchableAttrs, targetEvents) {
          this._parseEventOrAnimationEvent(name + "Change", expression + "=$event", sourceSpan, targetMatchableAttrs, targetEvents);
      };
      TemplateParseVisitor.prototype._parseEventOrAnimationEvent = function (name, expression, sourceSpan, targetMatchableAttrs, targetEvents) {
          if (_isAnimationLabel(name)) {
              name = name.substr(1);
              this._parseAnimationEvent(name, expression, sourceSpan, targetEvents);
          }
          else {
              this._parseEvent(name, expression, sourceSpan, targetMatchableAttrs, targetEvents);
          }
      };
      TemplateParseVisitor.prototype._parseAnimationEvent = function (name, expression, sourceSpan, targetEvents) {
          var matches = splitAtPeriod(name, [name, '']);
          var eventName = matches[0];
          var phase = matches[1].toLowerCase();
          if (phase) {
              switch (phase) {
                  case 'start':
                  case 'done':
                      var ast = this._parseAction(expression, sourceSpan);
                      targetEvents.push(new BoundEventAst(eventName, null, phase, ast, sourceSpan));
                      break;
                  default:
                      this._reportError("The provided animation output phase value \"" + phase + "\" for \"@" + eventName + "\" is not supported (use start or done)", sourceSpan);
                      break;
              }
          }
          else {
              this._reportError("The animation trigger output event (@" + eventName + ") is missing its phase value name (start or done are currently supported)", sourceSpan);
          }
      };
      TemplateParseVisitor.prototype._parseEvent = function (name, expression, sourceSpan, targetMatchableAttrs, targetEvents) {
          // long format: 'target: eventName'
          var _a = splitAtColon(name, [null, name]), target = _a[0], eventName = _a[1];
          var ast = this._parseAction(expression, sourceSpan);
          targetMatchableAttrs.push([name, ast.source]);
          targetEvents.push(new BoundEventAst(eventName, target, null, ast, sourceSpan));
          // Don't detect directives for event names for now,
          // so don't add the event name to the matchableAttrs
      };
      TemplateParseVisitor.prototype._parseLiteralAttr = function (name, value, sourceSpan, targetProps) {
          targetProps.push(new BoundElementOrDirectiveProperty(name, this._exprParser.wrapLiteralPrimitive(value, ''), true, sourceSpan));
      };
      TemplateParseVisitor.prototype._parseDirectives = function (selectorMatcher, elementCssSelector) {
          var _this = this;
          // Need to sort the directives so that we get consistent results throughout,
          // as selectorMatcher uses Maps inside.
          // Also deduplicate directives as they might match more than one time!
          var directives = new Array(this.directivesIndex.size);
          // Whether any directive selector matches on the element name
          var matchElement = false;
          selectorMatcher.match(elementCssSelector, function (selector, directive) {
              directives[_this.directivesIndex.get(directive)] = directive;
              matchElement = matchElement || selector.hasElementSelector();
          });
          return {
              directives: directives.filter(function (dir) { return !!dir; }),
              matchElement: matchElement,
          };
      };
      TemplateParseVisitor.prototype._createDirectiveAsts = function (isTemplateElement, elementName, directives, props, elementOrDirectiveRefs, elementSourceSpan, targetReferences) {
          var _this = this;
          var matchedReferences = new Set();
          var component = null;
          var directiveAsts = directives.map(function (directive) {
              var sourceSpan = new ParseSourceSpan(elementSourceSpan.start, elementSourceSpan.end, "Directive " + directive.type.name);
              if (directive.isComponent) {
                  component = directive;
              }
              var hostProperties = [];
              var hostEvents = [];
              var directiveProperties = [];
              _this._createDirectiveHostPropertyAsts(elementName, directive.hostProperties, sourceSpan, hostProperties);
              _this._createDirectiveHostEventAsts(directive.hostListeners, sourceSpan, hostEvents);
              _this._createDirectivePropertyAsts(directive.inputs, props, directiveProperties);
              elementOrDirectiveRefs.forEach(function (elOrDirRef) {
                  if ((elOrDirRef.value.length === 0 && directive.isComponent) ||
                      (directive.exportAs == elOrDirRef.value)) {
                      targetReferences.push(new ReferenceAst(elOrDirRef.name, identifierToken(directive.type), elOrDirRef.sourceSpan));
                      matchedReferences.add(elOrDirRef.name);
                  }
              });
              return new DirectiveAst(directive, directiveProperties, hostProperties, hostEvents, sourceSpan);
          });
          elementOrDirectiveRefs.forEach(function (elOrDirRef) {
              if (elOrDirRef.value.length > 0) {
                  if (!matchedReferences.has(elOrDirRef.name)) {
                      _this._reportError("There is no directive with \"exportAs\" set to \"" + elOrDirRef.value + "\"", elOrDirRef.sourceSpan);
                  }
              }
              else if (!component) {
                  var refToken = null;
                  if (isTemplateElement) {
                      refToken = resolveIdentifierToken(Identifiers.TemplateRef);
                  }
                  targetReferences.push(new ReferenceAst(elOrDirRef.name, refToken, elOrDirRef.sourceSpan));
              }
          }); // fix syntax highlighting issue: `
          return directiveAsts;
      };
      TemplateParseVisitor.prototype._createDirectiveHostPropertyAsts = function (elementName, hostProps, sourceSpan, targetPropertyAsts) {
          var _this = this;
          if (hostProps) {
              Object.keys(hostProps).forEach(function (propName) {
                  var expression = hostProps[propName];
                  if (typeof expression === 'string') {
                      var exprAst = _this._parseBinding(expression, sourceSpan);
                      targetPropertyAsts.push(_this._createElementPropertyAst(elementName, propName, exprAst, sourceSpan));
                  }
                  else {
                      _this._reportError("Value of the host property binding \"" + propName + "\" needs to be a string representing an expression but got \"" + expression + "\" (" + typeof expression + ")", sourceSpan);
                  }
              });
          }
      };
      TemplateParseVisitor.prototype._createDirectiveHostEventAsts = function (hostListeners, sourceSpan, targetEventAsts) {
          var _this = this;
          if (hostListeners) {
              Object.keys(hostListeners).forEach(function (propName) {
                  var expression = hostListeners[propName];
                  if (typeof expression === 'string') {
                      _this._parseEventOrAnimationEvent(propName, expression, sourceSpan, [], targetEventAsts);
                  }
                  else {
                      _this._reportError("Value of the host listener \"" + propName + "\" needs to be a string representing an expression but got \"" + expression + "\" (" + typeof expression + ")", sourceSpan);
                  }
              });
          }
      };
      TemplateParseVisitor.prototype._createDirectivePropertyAsts = function (directiveProperties, boundProps, targetBoundDirectiveProps) {
          if (directiveProperties) {
              var boundPropsByName_1 = new Map();
              boundProps.forEach(function (boundProp) {
                  var prevValue = boundPropsByName_1.get(boundProp.name);
                  if (!prevValue || prevValue.isLiteral) {
                      // give [a]="b" a higher precedence than a="b" on the same element
                      boundPropsByName_1.set(boundProp.name, boundProp);
                  }
              });
              Object.keys(directiveProperties).forEach(function (dirProp) {
                  var elProp = directiveProperties[dirProp];
                  var boundProp = boundPropsByName_1.get(elProp);
                  // Bindings are optional, so this binding only needs to be set up if an expression is given.
                  if (boundProp) {
                      targetBoundDirectiveProps.push(new BoundDirectivePropertyAst(dirProp, boundProp.name, boundProp.expression, boundProp.sourceSpan));
                  }
              });
          }
      };
      TemplateParseVisitor.prototype._createElementPropertyAsts = function (elementName, props, directives) {
          var _this = this;
          var boundElementProps = [];
          var boundDirectivePropsIndex = new Map();
          directives.forEach(function (directive) {
              directive.inputs.forEach(function (prop) {
                  boundDirectivePropsIndex.set(prop.templateName, prop);
              });
          });
          props.forEach(function (prop) {
              if (!prop.isLiteral && !boundDirectivePropsIndex.get(prop.name)) {
                  boundElementProps.push(_this._createElementPropertyAst(elementName, prop.name, prop.expression, prop.sourceSpan));
              }
          });
          return boundElementProps;
      };
      TemplateParseVisitor.prototype._createElementPropertyAst = function (elementName, name, ast, sourceSpan) {
          var unit = null;
          var bindingType;
          var boundPropertyName;
          var parts = name.split(PROPERTY_PARTS_SEPARATOR);
          var securityContext;
          if (parts.length === 1) {
              var partValue = parts[0];
              if (_isAnimationLabel(partValue)) {
                  boundPropertyName = partValue.substr(1);
                  bindingType = exports.PropertyBindingType.Animation;
                  securityContext = _angular_core.SecurityContext.NONE;
              }
              else {
                  boundPropertyName = this._schemaRegistry.getMappedPropName(partValue);
                  securityContext = this._schemaRegistry.securityContext(elementName, boundPropertyName);
                  bindingType = exports.PropertyBindingType.Property;
                  this._validatePropertyOrAttributeName(boundPropertyName, sourceSpan, false);
                  if (!this._schemaRegistry.hasProperty(elementName, boundPropertyName, this._schemas)) {
                      var errorMsg = "Can't bind to '" + boundPropertyName + "' since it isn't a known property of '" + elementName + "'.";
                      if (elementName.indexOf('-') > -1) {
                          errorMsg +=
                              ("\n1. If '" + elementName + "' is an Angular component and it has '" + boundPropertyName + "' input, then verify that it is part of this module.") +
                                  ("\n2. If '" + elementName + "' is a Web Component then add \"CUSTOM_ELEMENTS_SCHEMA\" to the '@NgModule.schemas' of this component to suppress this message.\n");
                      }
                      this._reportError(errorMsg, sourceSpan);
                  }
              }
          }
          else {
              if (parts[0] == ATTRIBUTE_PREFIX) {
                  boundPropertyName = parts[1];
                  this._validatePropertyOrAttributeName(boundPropertyName, sourceSpan, true);
                  // NB: For security purposes, use the mapped property name, not the attribute name.
                  var mapPropName = this._schemaRegistry.getMappedPropName(boundPropertyName);
                  securityContext = this._schemaRegistry.securityContext(elementName, mapPropName);
                  var nsSeparatorIdx = boundPropertyName.indexOf(':');
                  if (nsSeparatorIdx > -1) {
                      var ns = boundPropertyName.substring(0, nsSeparatorIdx);
                      var name_1 = boundPropertyName.substring(nsSeparatorIdx + 1);
                      boundPropertyName = mergeNsAndName(ns, name_1);
                  }
                  bindingType = exports.PropertyBindingType.Attribute;
              }
              else if (parts[0] == CLASS_PREFIX) {
                  boundPropertyName = parts[1];
                  bindingType = exports.PropertyBindingType.Class;
                  securityContext = _angular_core.SecurityContext.NONE;
              }
              else if (parts[0] == STYLE_PREFIX) {
                  unit = parts.length > 2 ? parts[2] : null;
                  boundPropertyName = parts[1];
                  bindingType = exports.PropertyBindingType.Style;
                  securityContext = _angular_core.SecurityContext.STYLE;
              }
              else {
                  this._reportError("Invalid property name '" + name + "'", sourceSpan);
                  bindingType = null;
                  securityContext = null;
              }
          }
          return new BoundElementPropertyAst(boundPropertyName, bindingType, securityContext, ast, unit, sourceSpan);
      };
      /**
       * @param propName the name of the property / attribute
       * @param sourceSpan
       * @param isAttr true when binding to an attribute
       * @private
       */
      TemplateParseVisitor.prototype._validatePropertyOrAttributeName = function (propName, sourceSpan, isAttr) {
          var report = isAttr ? this._schemaRegistry.validateAttribute(propName) :
              this._schemaRegistry.validateProperty(propName);
          if (report.error) {
              this._reportError(report.msg, sourceSpan, exports.ParseErrorLevel.FATAL);
          }
      };
      TemplateParseVisitor.prototype._findComponentDirectives = function (directives) {
          return directives.filter(function (directive) { return directive.directive.isComponent; });
      };
      TemplateParseVisitor.prototype._findComponentDirectiveNames = function (directives) {
          return this._findComponentDirectives(directives)
              .map(function (directive) { return directive.directive.type.name; });
      };
      TemplateParseVisitor.prototype._assertOnlyOneComponent = function (directives, sourceSpan) {
          var componentTypeNames = this._findComponentDirectiveNames(directives);
          if (componentTypeNames.length > 1) {
              this._reportError("More than one component: " + componentTypeNames.join(','), sourceSpan);
          }
      };
      /**
       * Make sure that non-angular tags conform to the schemas.
       *
       * Note: An element is considered an angular tag when at least one directive selector matches the
       * tag name.
       *
       * @param matchElement Whether any directive has matched on the tag name
       * @param element the html element
       */
      TemplateParseVisitor.prototype._assertElementExists = function (matchElement, element) {
          var elName = element.name.replace(/^:xhtml:/, '');
          if (!matchElement && !this._schemaRegistry.hasElement(elName, this._schemas)) {
              var errorMsg = ("'" + elName + "' is not a known element:\n") +
                  ("1. If '" + elName + "' is an Angular component, then verify that it is part of this module.\n") +
                  ("2. If '" + elName + "' is a Web Component then add \"CUSTOM_ELEMENTS_SCHEMA\" to the '@NgModule.schemas' of this component to suppress this message.");
              this._reportError(errorMsg, element.sourceSpan);
          }
      };
      TemplateParseVisitor.prototype._assertNoComponentsNorElementBindingsOnTemplate = function (directives, elementProps, sourceSpan) {
          var _this = this;
          var componentTypeNames = this._findComponentDirectiveNames(directives);
          if (componentTypeNames.length > 0) {
              this._reportError("Components on an embedded template: " + componentTypeNames.join(','), sourceSpan);
          }
          elementProps.forEach(function (prop) {
              _this._reportError("Property binding " + prop.name + " not used by any directive on an embedded template. Make sure that the property name is spelled correctly and all directives are listed in the \"directives\" section.", sourceSpan);
          });
      };
      TemplateParseVisitor.prototype._assertAllEventsPublishedByDirectives = function (directives, events) {
          var _this = this;
          var allDirectiveEvents = new Set();
          directives.forEach(function (directive) {
              Object.keys(directive.directive.outputs).forEach(function (k) {
                  var eventName = directive.directive.outputs[k];
                  allDirectiveEvents.add(eventName);
              });
          });
          events.forEach(function (event) {
              if (isPresent(event.target) || !allDirectiveEvents.has(event.name)) {
                  _this._reportError("Event binding " + event.fullName + " not emitted by any directive on an embedded template. Make sure that the event name is spelled correctly and all directives are listed in the \"directives\" section.", event.sourceSpan);
              }
          });
      };
      return TemplateParseVisitor;
  }());
  var NonBindableVisitor = (function () {
      function NonBindableVisitor() {
      }
      NonBindableVisitor.prototype.visitElement = function (ast, parent) {
          var preparsedElement = preparseElement(ast);
          if (preparsedElement.type === PreparsedElementType.SCRIPT ||
              preparsedElement.type === PreparsedElementType.STYLE ||
              preparsedElement.type === PreparsedElementType.STYLESHEET) {
              // Skipping <script> for security reasons
              // Skipping <style> and stylesheets as we already processed them
              // in the StyleCompiler
              return null;
          }
          var attrNameAndValues = ast.attrs.map(function (attrAst) { return [attrAst.name, attrAst.value]; });
          var selector = createElementCssSelector(ast.name, attrNameAndValues);
          var ngContentIndex = parent.findNgContentIndex(selector);
          var children = visitAll(this, ast.children, EMPTY_ELEMENT_CONTEXT);
          return new ElementAst(ast.name, visitAll(this, ast.attrs), [], [], [], [], [], false, children, ngContentIndex, ast.sourceSpan, ast.endSourceSpan);
      };
      NonBindableVisitor.prototype.visitComment = function (comment, context) { return null; };
      NonBindableVisitor.prototype.visitAttribute = function (attribute, context) {
          return new AttrAst(attribute.name, attribute.value, attribute.sourceSpan);
      };
      NonBindableVisitor.prototype.visitText = function (text, parent) {
          var ngContentIndex = parent.findNgContentIndex(TEXT_CSS_SELECTOR);
          return new TextAst(text.value, ngContentIndex, text.sourceSpan);
      };
      NonBindableVisitor.prototype.visitExpansion = function (expansion, context) { return expansion; };
      NonBindableVisitor.prototype.visitExpansionCase = function (expansionCase, context) { return expansionCase; };
      return NonBindableVisitor;
  }());
  var BoundElementOrDirectiveProperty = (function () {
      function BoundElementOrDirectiveProperty(name, expression, isLiteral, sourceSpan) {
          this.name = name;
          this.expression = expression;
          this.isLiteral = isLiteral;
          this.sourceSpan = sourceSpan;
      }
      return BoundElementOrDirectiveProperty;
  }());
  var ElementOrDirectiveRef = (function () {
      function ElementOrDirectiveRef(name, value, sourceSpan) {
          this.name = name;
          this.value = value;
          this.sourceSpan = sourceSpan;
      }
      return ElementOrDirectiveRef;
  }());
  function splitClasses(classAttrValue) {
      return classAttrValue.trim().split(/\s+/g);
  }
  var ElementContext = (function () {
      function ElementContext(isTemplateElement, _ngContentIndexMatcher, _wildcardNgContentIndex, providerContext) {
          this.isTemplateElement = isTemplateElement;
          this._ngContentIndexMatcher = _ngContentIndexMatcher;
          this._wildcardNgContentIndex = _wildcardNgContentIndex;
          this.providerContext = providerContext;
      }
      ElementContext.create = function (isTemplateElement, directives, providerContext) {
          var matcher = new SelectorMatcher();
          var wildcardNgContentIndex = null;
          var component = directives.find(function (directive) { return directive.directive.isComponent; });
          if (component) {
              var ngContentSelectors = component.directive.template.ngContentSelectors;
              for (var i = 0; i < ngContentSelectors.length; i++) {
                  var selector = ngContentSelectors[i];
                  if (selector === '*') {
                      wildcardNgContentIndex = i;
                  }
                  else {
                      matcher.addSelectables(CssSelector.parse(ngContentSelectors[i]), i);
                  }
              }
          }
          return new ElementContext(isTemplateElement, matcher, wildcardNgContentIndex, providerContext);
      };
      ElementContext.prototype.findNgContentIndex = function (selector) {
          var ngContentIndices = [];
          this._ngContentIndexMatcher.match(selector, function (selector, ngContentIndex) { ngContentIndices.push(ngContentIndex); });
          ngContentIndices.sort();
          if (isPresent(this._wildcardNgContentIndex)) {
              ngContentIndices.push(this._wildcardNgContentIndex);
          }
          return ngContentIndices.length > 0 ? ngContentIndices[0] : null;
      };
      return ElementContext;
  }());
  function createElementCssSelector(elementName, matchableAttrs) {
      var cssSelector = new CssSelector();
      var elNameNoNs = splitNsName(elementName)[1];
      cssSelector.setElement(elNameNoNs);
      for (var i = 0; i < matchableAttrs.length; i++) {
          var attrName = matchableAttrs[i][0];
          var attrNameNoNs = splitNsName(attrName)[1];
          var attrValue = matchableAttrs[i][1];
          cssSelector.addAttribute(attrNameNoNs, attrValue);
          if (attrName.toLowerCase() == CLASS_ATTR) {
              var classes = splitClasses(attrValue);
              classes.forEach(function (className) { return cssSelector.addClassName(className); });
          }
      }
      return cssSelector;
  }
  var EMPTY_ELEMENT_CONTEXT = new ElementContext(true, new SelectorMatcher(), null, null);
  var NON_BINDABLE_VISITOR = new NonBindableVisitor();
  var PipeCollector = (function (_super) {
      __extends(PipeCollector, _super);
      function PipeCollector() {
          _super.apply(this, arguments);
          this.pipes = new Set();
      }
      PipeCollector.prototype.visitPipe = function (ast, context) {
          this.pipes.add(ast.name);
          ast.exp.visit(this);
          this.visitAll(ast.args, context);
          return null;
      };
      return PipeCollector;
  }(RecursiveAstVisitor));
  function _isAnimationLabel(name) {
      return name[0] == '@';
  }
  function _isEmptyTextNode(node) {
      return node instanceof Text && node.value.trim().length == 0;
  }

  function unimplemented$1() {
      throw new Error('unimplemented');
  }
  var CompilerConfig = (function () {
      function CompilerConfig(_a) {
          var _b = _a === void 0 ? {} : _a, _c = _b.renderTypes, renderTypes = _c === void 0 ? new DefaultRenderTypes() : _c, _d = _b.defaultEncapsulation, defaultEncapsulation = _d === void 0 ? _angular_core.ViewEncapsulation.Emulated : _d, genDebugInfo = _b.genDebugInfo, logBindingUpdate = _b.logBindingUpdate, _e = _b.useJit, useJit = _e === void 0 ? true : _e;
          this.renderTypes = renderTypes;
          this.defaultEncapsulation = defaultEncapsulation;
          this._genDebugInfo = genDebugInfo;
          this._logBindingUpdate = logBindingUpdate;
          this.useJit = useJit;
      }
      Object.defineProperty(CompilerConfig.prototype, "genDebugInfo", {
          get: function () {
              return this._genDebugInfo === void 0 ? _angular_core.isDevMode() : this._genDebugInfo;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(CompilerConfig.prototype, "logBindingUpdate", {
          get: function () {
              return this._logBindingUpdate === void 0 ? _angular_core.isDevMode() : this._logBindingUpdate;
          },
          enumerable: true,
          configurable: true
      });
      return CompilerConfig;
  }());
  /**
   * Types used for the renderer.
   * Can be replaced to specialize the generated output to a specific renderer
   * to help tree shaking.
   */
  var RenderTypes = (function () {
      function RenderTypes() {
      }
      Object.defineProperty(RenderTypes.prototype, "renderer", {
          get: function () { return unimplemented$1(); },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(RenderTypes.prototype, "renderText", {
          get: function () { return unimplemented$1(); },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(RenderTypes.prototype, "renderElement", {
          get: function () { return unimplemented$1(); },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(RenderTypes.prototype, "renderComment", {
          get: function () { return unimplemented$1(); },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(RenderTypes.prototype, "renderNode", {
          get: function () { return unimplemented$1(); },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(RenderTypes.prototype, "renderEvent", {
          get: function () { return unimplemented$1(); },
          enumerable: true,
          configurable: true
      });
      return RenderTypes;
  }());
  var DefaultRenderTypes = (function () {
      function DefaultRenderTypes() {
          this.renderText = null;
          this.renderElement = null;
          this.renderComment = null;
          this.renderNode = null;
          this.renderEvent = null;
      }
      Object.defineProperty(DefaultRenderTypes.prototype, "renderer", {
          get: function () { return resolveIdentifier(Identifiers.Renderer); },
          enumerable: true,
          configurable: true
      });
      ;
      return DefaultRenderTypes;
  }());

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var __extends$12 = (this && this.__extends) || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var AnimationAst = (function () {
      function AnimationAst() {
          this.startTime = 0;
          this.playTime = 0;
      }
      return AnimationAst;
  }());
  var AnimationStateAst = (function (_super) {
      __extends$12(AnimationStateAst, _super);
      function AnimationStateAst() {
          _super.apply(this, arguments);
      }
      return AnimationStateAst;
  }(AnimationAst));
  var AnimationEntryAst = (function (_super) {
      __extends$12(AnimationEntryAst, _super);
      function AnimationEntryAst(name, stateDeclarations, stateTransitions) {
          _super.call(this);
          this.name = name;
          this.stateDeclarations = stateDeclarations;
          this.stateTransitions = stateTransitions;
      }
      AnimationEntryAst.prototype.visit = function (visitor, context) {
          return visitor.visitAnimationEntry(this, context);
      };
      return AnimationEntryAst;
  }(AnimationAst));
  var AnimationStateDeclarationAst = (function (_super) {
      __extends$12(AnimationStateDeclarationAst, _super);
      function AnimationStateDeclarationAst(stateName, styles) {
          _super.call(this);
          this.stateName = stateName;
          this.styles = styles;
      }
      AnimationStateDeclarationAst.prototype.visit = function (visitor, context) {
          return visitor.visitAnimationStateDeclaration(this, context);
      };
      return AnimationStateDeclarationAst;
  }(AnimationStateAst));
  var AnimationStateTransitionExpression = (function () {
      function AnimationStateTransitionExpression(fromState, toState) {
          this.fromState = fromState;
          this.toState = toState;
      }
      return AnimationStateTransitionExpression;
  }());
  var AnimationStateTransitionAst = (function (_super) {
      __extends$12(AnimationStateTransitionAst, _super);
      function AnimationStateTransitionAst(stateChanges, animation) {
          _super.call(this);
          this.stateChanges = stateChanges;
          this.animation = animation;
      }
      AnimationStateTransitionAst.prototype.visit = function (visitor, context) {
          return visitor.visitAnimationStateTransition(this, context);
      };
      return AnimationStateTransitionAst;
  }(AnimationStateAst));
  var AnimationStepAst = (function (_super) {
      __extends$12(AnimationStepAst, _super);
      function AnimationStepAst(startingStyles, keyframes, duration, delay, easing) {
          _super.call(this);
          this.startingStyles = startingStyles;
          this.keyframes = keyframes;
          this.duration = duration;
          this.delay = delay;
          this.easing = easing;
      }
      AnimationStepAst.prototype.visit = function (visitor, context) {
          return visitor.visitAnimationStep(this, context);
      };
      return AnimationStepAst;
  }(AnimationAst));
  var AnimationStylesAst = (function (_super) {
      __extends$12(AnimationStylesAst, _super);
      function AnimationStylesAst(styles) {
          _super.call(this);
          this.styles = styles;
      }
      AnimationStylesAst.prototype.visit = function (visitor, context) {
          return visitor.visitAnimationStyles(this, context);
      };
      return AnimationStylesAst;
  }(AnimationAst));
  var AnimationKeyframeAst = (function (_super) {
      __extends$12(AnimationKeyframeAst, _super);
      function AnimationKeyframeAst(offset, styles) {
          _super.call(this);
          this.offset = offset;
          this.styles = styles;
      }
      AnimationKeyframeAst.prototype.visit = function (visitor, context) {
          return visitor.visitAnimationKeyframe(this, context);
      };
      return AnimationKeyframeAst;
  }(AnimationAst));
  var AnimationWithStepsAst = (function (_super) {
      __extends$12(AnimationWithStepsAst, _super);
      function AnimationWithStepsAst(steps) {
          _super.call(this);
          this.steps = steps;
      }
      return AnimationWithStepsAst;
  }(AnimationAst));
  var AnimationGroupAst = (function (_super) {
      __extends$12(AnimationGroupAst, _super);
      function AnimationGroupAst(steps) {
          _super.call(this, steps);
      }
      AnimationGroupAst.prototype.visit = function (visitor, context) {
          return visitor.visitAnimationGroup(this, context);
      };
      return AnimationGroupAst;
  }(AnimationWithStepsAst));
  var AnimationSequenceAst = (function (_super) {
      __extends$12(AnimationSequenceAst, _super);
      function AnimationSequenceAst(steps) {
          _super.call(this, steps);
      }
      AnimationSequenceAst.prototype.visit = function (visitor, context) {
          return visitor.visitAnimationSequence(this, context);
      };
      return AnimationSequenceAst;
  }(AnimationWithStepsAst));

  var AnimationEntryCompileResult = (function () {
      function AnimationEntryCompileResult(name, statements, fnExp) {
          this.name = name;
          this.statements = statements;
          this.fnExp = fnExp;
      }
      return AnimationEntryCompileResult;
  }());
  var AnimationCompiler = (function () {
      function AnimationCompiler() {
      }
      AnimationCompiler.prototype.compile = function (factoryNamePrefix, parsedAnimations) {
          return parsedAnimations.map(function (entry) {
              var factoryName = factoryNamePrefix + "_" + entry.name;
              var visitor = new _AnimationBuilder(entry.name, factoryName);
              return visitor.build(entry);
          });
      };
      return AnimationCompiler;
  }());
  var _ANIMATION_FACTORY_ELEMENT_VAR = variable('element');
  var _ANIMATION_DEFAULT_STATE_VAR = variable('defaultStateStyles');
  var _ANIMATION_FACTORY_VIEW_VAR = variable('view');
  var _ANIMATION_FACTORY_VIEW_CONTEXT = _ANIMATION_FACTORY_VIEW_VAR.prop('animationContext');
  var _ANIMATION_FACTORY_RENDERER_VAR = _ANIMATION_FACTORY_VIEW_VAR.prop('renderer');
  var _ANIMATION_CURRENT_STATE_VAR = variable('currentState');
  var _ANIMATION_NEXT_STATE_VAR = variable('nextState');
  var _ANIMATION_PLAYER_VAR = variable('player');
  var _ANIMATION_TIME_VAR = variable('totalTime');
  var _ANIMATION_START_STATE_STYLES_VAR = variable('startStateStyles');
  var _ANIMATION_END_STATE_STYLES_VAR = variable('endStateStyles');
  var _ANIMATION_COLLECTED_STYLES = variable('collectedStyles');
  var EMPTY_MAP = literalMap([]);
  var _AnimationBuilder = (function () {
      function _AnimationBuilder(animationName, factoryName) {
          this.animationName = animationName;
          this._fnVarName = factoryName + '_factory';
          this._statesMapVarName = factoryName + '_states';
          this._statesMapVar = variable(this._statesMapVarName);
      }
      _AnimationBuilder.prototype.visitAnimationStyles = function (ast, context) {
          var stylesArr = [];
          if (context.isExpectingFirstStyleStep) {
              stylesArr.push(_ANIMATION_START_STATE_STYLES_VAR);
              context.isExpectingFirstStyleStep = false;
          }
          ast.styles.forEach(function (entry) {
              var entries = Object.keys(entry).map(function (key) { return [key, literal(entry[key])]; });
              stylesArr.push(literalMap(entries));
          });
          return importExpr(resolveIdentifier(Identifiers.AnimationStyles)).instantiate([
              importExpr(resolveIdentifier(Identifiers.collectAndResolveStyles)).callFn([
                  _ANIMATION_COLLECTED_STYLES, literalArr(stylesArr)
              ])
          ]);
      };
      _AnimationBuilder.prototype.visitAnimationKeyframe = function (ast, context) {
          return importExpr(resolveIdentifier(Identifiers.AnimationKeyframe)).instantiate([
              literal(ast.offset), ast.styles.visit(this, context)
          ]);
      };
      _AnimationBuilder.prototype.visitAnimationStep = function (ast, context) {
          var _this = this;
          if (context.endStateAnimateStep === ast) {
              return this._visitEndStateAnimation(ast, context);
          }
          var startingStylesExpr = ast.startingStyles.visit(this, context);
          var keyframeExpressions = ast.keyframes.map(function (keyframeEntry) { return keyframeEntry.visit(_this, context); });
          return this._callAnimateMethod(ast, startingStylesExpr, literalArr(keyframeExpressions), context);
      };
      /** @internal */
      _AnimationBuilder.prototype._visitEndStateAnimation = function (ast, context) {
          var _this = this;
          var startingStylesExpr = ast.startingStyles.visit(this, context);
          var keyframeExpressions = ast.keyframes.map(function (keyframe) { return keyframe.visit(_this, context); });
          var keyframesExpr = importExpr(resolveIdentifier(Identifiers.balanceAnimationKeyframes)).callFn([
              _ANIMATION_COLLECTED_STYLES, _ANIMATION_END_STATE_STYLES_VAR,
              literalArr(keyframeExpressions)
          ]);
          return this._callAnimateMethod(ast, startingStylesExpr, keyframesExpr, context);
      };
      /** @internal */
      _AnimationBuilder.prototype._callAnimateMethod = function (ast, startingStylesExpr, keyframesExpr, context) {
          context.totalTransitionTime += ast.duration + ast.delay;
          return _ANIMATION_FACTORY_RENDERER_VAR.callMethod('animate', [
              _ANIMATION_FACTORY_ELEMENT_VAR, startingStylesExpr, keyframesExpr, literal(ast.duration),
              literal(ast.delay), literal(ast.easing)
          ]);
      };
      _AnimationBuilder.prototype.visitAnimationSequence = function (ast, context) {
          var _this = this;
          var playerExprs = ast.steps.map(function (step) { return step.visit(_this, context); });
          return importExpr(resolveIdentifier(Identifiers.AnimationSequencePlayer)).instantiate([
              literalArr(playerExprs)
          ]);
      };
      _AnimationBuilder.prototype.visitAnimationGroup = function (ast, context) {
          var _this = this;
          var playerExprs = ast.steps.map(function (step) { return step.visit(_this, context); });
          return importExpr(resolveIdentifier(Identifiers.AnimationGroupPlayer)).instantiate([
              literalArr(playerExprs)
          ]);
      };
      _AnimationBuilder.prototype.visitAnimationStateDeclaration = function (ast, context) {
          var flatStyles = {};
          _getStylesArray(ast).forEach(function (entry) { Object.keys(entry).forEach(function (key) { flatStyles[key] = entry[key]; }); });
          context.stateMap.registerState(ast.stateName, flatStyles);
      };
      _AnimationBuilder.prototype.visitAnimationStateTransition = function (ast, context) {
          var steps = ast.animation.steps;
          var lastStep = steps[steps.length - 1];
          if (_isEndStateAnimateStep(lastStep)) {
              context.endStateAnimateStep = lastStep;
          }
          context.totalTransitionTime = 0;
          context.isExpectingFirstStyleStep = true;
          var stateChangePreconditions = [];
          ast.stateChanges.forEach(function (stateChange) {
              stateChangePreconditions.push(_compareToAnimationStateExpr(_ANIMATION_CURRENT_STATE_VAR, stateChange.fromState)
                  .and(_compareToAnimationStateExpr(_ANIMATION_NEXT_STATE_VAR, stateChange.toState)));
              if (stateChange.fromState != ANY_STATE) {
                  context.stateMap.registerState(stateChange.fromState);
              }
              if (stateChange.toState != ANY_STATE) {
                  context.stateMap.registerState(stateChange.toState);
              }
          });
          var animationPlayerExpr = ast.animation.visit(this, context);
          var reducedStateChangesPrecondition = stateChangePreconditions.reduce(function (a, b) { return a.or(b); });
          var precondition = _ANIMATION_PLAYER_VAR.equals(NULL_EXPR).and(reducedStateChangesPrecondition);
          var animationStmt = _ANIMATION_PLAYER_VAR.set(animationPlayerExpr).toStmt();
          var totalTimeStmt = _ANIMATION_TIME_VAR.set(literal(context.totalTransitionTime)).toStmt();
          return new IfStmt(precondition, [animationStmt, totalTimeStmt]);
      };
      _AnimationBuilder.prototype.visitAnimationEntry = function (ast, context) {
          var _this = this;
          // visit each of the declarations first to build the context state map
          ast.stateDeclarations.forEach(function (def) { return def.visit(_this, context); });
          // this should always be defined even if the user overrides it
          context.stateMap.registerState(DEFAULT_STATE, {});
          var statements = [];
          statements.push(_ANIMATION_FACTORY_VIEW_CONTEXT
              .callMethod('cancelActiveAnimation', [
              _ANIMATION_FACTORY_ELEMENT_VAR, literal(this.animationName),
              _ANIMATION_NEXT_STATE_VAR.equals(literal(EMPTY_ANIMATION_STATE))
          ])
              .toStmt());
          statements.push(_ANIMATION_COLLECTED_STYLES.set(EMPTY_MAP).toDeclStmt());
          statements.push(_ANIMATION_PLAYER_VAR.set(NULL_EXPR).toDeclStmt());
          statements.push(_ANIMATION_TIME_VAR.set(literal(0)).toDeclStmt());
          statements.push(_ANIMATION_DEFAULT_STATE_VAR.set(this._statesMapVar.key(literal(DEFAULT_STATE)))
              .toDeclStmt());
          statements.push(_ANIMATION_START_STATE_STYLES_VAR.set(this._statesMapVar.key(_ANIMATION_CURRENT_STATE_VAR))
              .toDeclStmt());
          statements.push(new IfStmt(_ANIMATION_START_STATE_STYLES_VAR.equals(NULL_EXPR), [_ANIMATION_START_STATE_STYLES_VAR.set(_ANIMATION_DEFAULT_STATE_VAR).toStmt()]));
          statements.push(_ANIMATION_END_STATE_STYLES_VAR.set(this._statesMapVar.key(_ANIMATION_NEXT_STATE_VAR))
              .toDeclStmt());
          statements.push(new IfStmt(_ANIMATION_END_STATE_STYLES_VAR.equals(NULL_EXPR), [_ANIMATION_END_STATE_STYLES_VAR.set(_ANIMATION_DEFAULT_STATE_VAR).toStmt()]));
          var RENDER_STYLES_FN = importExpr(resolveIdentifier(Identifiers.renderStyles));
          // before we start any animation we want to clear out the starting
          // styles from the element's style property (since they were placed
          // there at the end of the last animation
          statements.push(RENDER_STYLES_FN
              .callFn([
              _ANIMATION_FACTORY_ELEMENT_VAR, _ANIMATION_FACTORY_RENDERER_VAR,
              importExpr(resolveIdentifier(Identifiers.clearStyles))
                  .callFn([_ANIMATION_START_STATE_STYLES_VAR])
          ])
              .toStmt());
          ast.stateTransitions.forEach(function (transAst) { return statements.push(transAst.visit(_this, context)); });
          // this check ensures that the animation factory always returns a player
          // so that the onDone callback can be used for tracking
          statements.push(new IfStmt(_ANIMATION_PLAYER_VAR.equals(NULL_EXPR), [_ANIMATION_PLAYER_VAR
                  .set(importExpr(resolveIdentifier(Identifiers.NoOpAnimationPlayer)).instantiate([]))
                  .toStmt()]));
          // once complete we want to apply the styles on the element
          // since the destination state's values should persist once
          // the animation sequence has completed.
          statements.push(_ANIMATION_PLAYER_VAR
              .callMethod('onDone', [fn([], [RENDER_STYLES_FN
                      .callFn([
                      _ANIMATION_FACTORY_ELEMENT_VAR, _ANIMATION_FACTORY_RENDERER_VAR,
                      importExpr(resolveIdentifier(Identifiers.prepareFinalAnimationStyles))
                          .callFn([
                          _ANIMATION_START_STATE_STYLES_VAR, _ANIMATION_END_STATE_STYLES_VAR
                      ])
                  ])
                      .toStmt()])])
              .toStmt());
          statements.push(_ANIMATION_FACTORY_VIEW_CONTEXT
              .callMethod('queueAnimation', [
              _ANIMATION_FACTORY_ELEMENT_VAR, literal(this.animationName),
              _ANIMATION_PLAYER_VAR
          ])
              .toStmt());
          statements.push(new ReturnStatement(importExpr(resolveIdentifier(Identifiers.AnimationTransition)).instantiate([
              _ANIMATION_PLAYER_VAR, _ANIMATION_CURRENT_STATE_VAR, _ANIMATION_NEXT_STATE_VAR,
              _ANIMATION_TIME_VAR
          ])));
          return fn([
              new FnParam(_ANIMATION_FACTORY_VIEW_VAR.name, importType(resolveIdentifier(Identifiers.AppView), [DYNAMIC_TYPE])),
              new FnParam(_ANIMATION_FACTORY_ELEMENT_VAR.name, DYNAMIC_TYPE),
              new FnParam(_ANIMATION_CURRENT_STATE_VAR.name, DYNAMIC_TYPE),
              new FnParam(_ANIMATION_NEXT_STATE_VAR.name, DYNAMIC_TYPE)
          ], statements, importType(resolveIdentifier(Identifiers.AnimationTransition)));
      };
      _AnimationBuilder.prototype.build = function (ast) {
          var context = new _AnimationBuilderContext();
          var fnStatement = ast.visit(this, context).toDeclStmt(this._fnVarName);
          var fnVariable = variable(this._fnVarName);
          var lookupMap = [];
          Object.keys(context.stateMap.states).forEach(function (stateName) {
              var value = context.stateMap.states[stateName];
              var variableValue = EMPTY_MAP;
              if (isPresent(value)) {
                  var styleMap_1 = [];
                  Object.keys(value).forEach(function (key) { styleMap_1.push([key, literal(value[key])]); });
                  variableValue = literalMap(styleMap_1);
              }
              lookupMap.push([stateName, variableValue]);
          });
          var compiledStatesMapStmt = this._statesMapVar.set(literalMap(lookupMap)).toDeclStmt();
          var statements = [compiledStatesMapStmt, fnStatement];
          return new AnimationEntryCompileResult(this.animationName, statements, fnVariable);
      };
      return _AnimationBuilder;
  }());
  var _AnimationBuilderContext = (function () {
      function _AnimationBuilderContext() {
          this.stateMap = new _AnimationBuilderStateMap();
          this.endStateAnimateStep = null;
          this.isExpectingFirstStyleStep = false;
          this.totalTransitionTime = 0;
      }
      return _AnimationBuilderContext;
  }());
  var _AnimationBuilderStateMap = (function () {
      function _AnimationBuilderStateMap() {
          this._states = {};
      }
      Object.defineProperty(_AnimationBuilderStateMap.prototype, "states", {
          get: function () { return this._states; },
          enumerable: true,
          configurable: true
      });
      _AnimationBuilderStateMap.prototype.registerState = function (name, value) {
          if (value === void 0) { value = null; }
          var existingEntry = this._states[name];
          if (!existingEntry) {
              this._states[name] = value;
          }
      };
      return _AnimationBuilderStateMap;
  }());
  function _compareToAnimationStateExpr(value, animationState) {
      var emptyStateLiteral = literal(EMPTY_ANIMATION_STATE);
      switch (animationState) {
          case EMPTY_ANIMATION_STATE:
              return value.equals(emptyStateLiteral);
          case ANY_STATE:
              return literal(true);
          default:
              return value.equals(literal(animationState));
      }
  }
  function _isEndStateAnimateStep(step) {
      // the final animation step is characterized by having only TWO
      // keyframe values and it must have zero styles for both keyframes
      if (step instanceof AnimationStepAst && step.duration > 0 && step.keyframes.length == 2) {
          var styles1 = _getStylesArray(step.keyframes[0])[0];
          var styles2 = _getStylesArray(step.keyframes[1])[0];
          return Object.keys(styles1).length === 0 && Object.keys(styles2).length === 0;
      }
      return false;
  }
  function _getStylesArray(obj) {
      return obj.styles.styles;
  }

  var StylesCollectionEntry = (function () {
      function StylesCollectionEntry(time, value) {
          this.time = time;
          this.value = value;
      }
      StylesCollectionEntry.prototype.matches = function (time, value) {
          return time == this.time && value == this.value;
      };
      return StylesCollectionEntry;
  }());
  var StylesCollection = (function () {
      function StylesCollection() {
          this.styles = {};
      }
      StylesCollection.prototype.insertAtTime = function (property, time, value) {
          var tuple = new StylesCollectionEntry(time, value);
          var entries = this.styles[property];
          if (!isPresent(entries)) {
              entries = this.styles[property] = [];
          }
          // insert this at the right stop in the array
          // this way we can keep it sorted
          var insertionIndex = 0;
          for (var i = entries.length - 1; i >= 0; i--) {
              if (entries[i].time <= time) {
                  insertionIndex = i + 1;
                  break;
              }
          }
          ListWrapper.insert(entries, insertionIndex, tuple);
      };
      StylesCollection.prototype.getByIndex = function (property, index) {
          var items = this.styles[property];
          if (isPresent(items)) {
              return index >= items.length ? null : items[index];
          }
          return null;
      };
      StylesCollection.prototype.indexOfAtOrBeforeTime = function (property, time) {
          var entries = this.styles[property];
          if (isPresent(entries)) {
              for (var i = entries.length - 1; i >= 0; i--) {
                  if (entries[i].time <= time)
                      return i;
              }
          }
          return null;
      };
      return StylesCollection;
  }());

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var __extends$13 = (this && this.__extends) || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var _INITIAL_KEYFRAME = 0;
  var _TERMINAL_KEYFRAME = 1;
  var _ONE_SECOND = 1000;
  var AnimationParseError = (function (_super) {
      __extends$13(AnimationParseError, _super);
      function AnimationParseError(message) {
          _super.call(this, null, message);
      }
      AnimationParseError.prototype.toString = function () { return "" + this.msg; };
      return AnimationParseError;
  }(ParseError));
  var AnimationEntryParseResult = (function () {
      function AnimationEntryParseResult(ast, errors) {
          this.ast = ast;
          this.errors = errors;
      }
      return AnimationEntryParseResult;
  }());
  var AnimationParser = (function () {
      function AnimationParser() {
      }
      AnimationParser.prototype.parseComponent = function (component) {
          var _this = this;
          var errors = [];
          var componentName = component.type.name;
          var animationTriggerNames = new Set();
          var asts = component.template.animations.map(function (entry) {
              var result = _this.parseEntry(entry);
              var ast = result.ast;
              var triggerName = ast.name;
              if (animationTriggerNames.has(triggerName)) {
                  result.errors.push(new AnimationParseError("The animation trigger \"" + triggerName + "\" has already been registered for the " + componentName + " component"));
              }
              else {
                  animationTriggerNames.add(triggerName);
              }
              if (result.errors.length > 0) {
                  var errorMessage_1 = "- Unable to parse the animation sequence for \"" + triggerName + "\" on the " + componentName + " component due to the following errors:";
                  result.errors.forEach(function (error) { errorMessage_1 += '\n-- ' + error.msg; });
                  errors.push(errorMessage_1);
              }
              return ast;
          });
          if (errors.length > 0) {
              var errorString = errors.join('\n');
              throw new Error("Animation parse errors:\n" + errorString);
          }
          return asts;
      };
      AnimationParser.prototype.parseEntry = function (entry) {
          var errors = [];
          var stateStyles = {};
          var transitions = [];
          var stateDeclarationAsts = [];
          entry.definitions.forEach(function (def) {
              if (def instanceof CompileAnimationStateDeclarationMetadata) {
                  _parseAnimationDeclarationStates(def, errors).forEach(function (ast) {
                      stateDeclarationAsts.push(ast);
                      stateStyles[ast.stateName] = ast.styles;
                  });
              }
              else {
                  transitions.push(def);
              }
          });
          var stateTransitionAsts = transitions.map(function (transDef) { return _parseAnimationStateTransition(transDef, stateStyles, errors); });
          var ast = new AnimationEntryAst(entry.name, stateDeclarationAsts, stateTransitionAsts);
          return new AnimationEntryParseResult(ast, errors);
      };
      return AnimationParser;
  }());
  function _parseAnimationDeclarationStates(stateMetadata, errors) {
      var styleValues = [];
      stateMetadata.styles.styles.forEach(function (stylesEntry) {
          // TODO (matsko): change this when we get CSS class integration support
          if (typeof stylesEntry === 'object' && stylesEntry !== null) {
              styleValues.push(stylesEntry);
          }
          else {
              errors.push(new AnimationParseError("State based animations cannot contain references to other states"));
          }
      });
      var defStyles = new AnimationStylesAst(styleValues);
      var states = stateMetadata.stateNameExpr.split(/\s*,\s*/);
      return states.map(function (state) { return new AnimationStateDeclarationAst(state, defStyles); });
  }
  function _parseAnimationStateTransition(transitionStateMetadata, stateStyles, errors) {
      var styles = new StylesCollection();
      var transitionExprs = [];
      var transitionStates = transitionStateMetadata.stateChangeExpr.split(/\s*,\s*/);
      transitionStates.forEach(function (expr) { transitionExprs.push.apply(transitionExprs, _parseAnimationTransitionExpr(expr, errors)); });
      var entry = _normalizeAnimationEntry(transitionStateMetadata.steps);
      var animation = _normalizeStyleSteps(entry, stateStyles, errors);
      var animationAst = _parseTransitionAnimation(animation, 0, styles, stateStyles, errors);
      if (errors.length == 0) {
          _fillAnimationAstStartingKeyframes(animationAst, styles, errors);
      }
      var stepsAst = (animationAst instanceof AnimationWithStepsAst) ?
          animationAst :
          new AnimationSequenceAst([animationAst]);
      return new AnimationStateTransitionAst(transitionExprs, stepsAst);
  }
  function _parseAnimationAlias(alias, errors) {
      switch (alias) {
          case ':enter':
              return 'void => *';
          case ':leave':
              return '* => void';
          default:
              errors.push(new AnimationParseError("the transition alias value \"" + alias + "\" is not supported"));
              return '* => *';
      }
  }
  function _parseAnimationTransitionExpr(eventStr, errors) {
      var expressions = [];
      if (eventStr[0] == ':') {
          eventStr = _parseAnimationAlias(eventStr, errors);
      }
      var match = eventStr.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/);
      if (!isPresent(match) || match.length < 4) {
          errors.push(new AnimationParseError("the provided " + eventStr + " is not of a supported format"));
          return expressions;
      }
      var fromState = match[1];
      var separator = match[2];
      var toState = match[3];
      expressions.push(new AnimationStateTransitionExpression(fromState, toState));
      var isFullAnyStateExpr = fromState == ANY_STATE && toState == ANY_STATE;
      if (separator[0] == '<' && !isFullAnyStateExpr) {
          expressions.push(new AnimationStateTransitionExpression(toState, fromState));
      }
      return expressions;
  }
  function _normalizeAnimationEntry(entry) {
      return Array.isArray(entry) ? new CompileAnimationSequenceMetadata(entry) : entry;
  }
  function _normalizeStyleMetadata(entry, stateStyles, errors) {
      var normalizedStyles = [];
      entry.styles.forEach(function (styleEntry) {
          if (typeof styleEntry === 'string') {
              ListWrapper.addAll(normalizedStyles, _resolveStylesFromState(styleEntry, stateStyles, errors));
          }
          else {
              normalizedStyles.push(styleEntry);
          }
      });
      return normalizedStyles;
  }
  function _normalizeStyleSteps(entry, stateStyles, errors) {
      var steps = _normalizeStyleStepEntry(entry, stateStyles, errors);
      return (entry instanceof CompileAnimationGroupMetadata) ?
          new CompileAnimationGroupMetadata(steps) :
          new CompileAnimationSequenceMetadata(steps);
  }
  function _mergeAnimationStyles(stylesList, newItem) {
      if (typeof newItem === 'object' && newItem !== null && stylesList.length > 0) {
          var lastIndex = stylesList.length - 1;
          var lastItem = stylesList[lastIndex];
          if (typeof lastItem === 'object' && lastItem !== null) {
              stylesList[lastIndex] = StringMapWrapper.merge(lastItem, newItem);
              return;
          }
      }
      stylesList.push(newItem);
  }
  function _normalizeStyleStepEntry(entry, stateStyles, errors) {
      var steps;
      if (entry instanceof CompileAnimationWithStepsMetadata) {
          steps = entry.steps;
      }
      else {
          return [entry];
      }
      var newSteps = [];
      var combinedStyles;
      steps.forEach(function (step) {
          if (step instanceof CompileAnimationStyleMetadata) {
              // this occurs when a style step is followed by a previous style step
              // or when the first style step is run. We want to concatenate all subsequent
              // style steps together into a single style step such that we have the correct
              // starting keyframe data to pass into the animation player.
              if (!isPresent(combinedStyles)) {
                  combinedStyles = [];
              }
              _normalizeStyleMetadata(step, stateStyles, errors)
                  .forEach(function (entry) { _mergeAnimationStyles(combinedStyles, entry); });
          }
          else {
              // it is important that we create a metadata entry of the combined styles
              // before we go on an process the animate, sequence or group metadata steps.
              // This will ensure that the AST will have the previous styles painted on
              // screen before any further animations that use the styles take place.
              if (isPresent(combinedStyles)) {
                  newSteps.push(new CompileAnimationStyleMetadata(0, combinedStyles));
                  combinedStyles = null;
              }
              if (step instanceof CompileAnimationAnimateMetadata) {
                  // we do not recurse into CompileAnimationAnimateMetadata since
                  // those style steps are not going to be squashed
                  var animateStyleValue = step.styles;
                  if (animateStyleValue instanceof CompileAnimationStyleMetadata) {
                      animateStyleValue.styles =
                          _normalizeStyleMetadata(animateStyleValue, stateStyles, errors);
                  }
                  else if (animateStyleValue instanceof CompileAnimationKeyframesSequenceMetadata) {
                      animateStyleValue.steps.forEach(function (step) { step.styles = _normalizeStyleMetadata(step, stateStyles, errors); });
                  }
              }
              else if (step instanceof CompileAnimationWithStepsMetadata) {
                  var innerSteps = _normalizeStyleStepEntry(step, stateStyles, errors);
                  step = step instanceof CompileAnimationGroupMetadata ?
                      new CompileAnimationGroupMetadata(innerSteps) :
                      new CompileAnimationSequenceMetadata(innerSteps);
              }
              newSteps.push(step);
          }
      });
      // this happens when only styles were animated within the sequence
      if (isPresent(combinedStyles)) {
          newSteps.push(new CompileAnimationStyleMetadata(0, combinedStyles));
      }
      return newSteps;
  }
  function _resolveStylesFromState(stateName, stateStyles, errors) {
      var styles = [];
      if (stateName[0] != ':') {
          errors.push(new AnimationParseError("Animation states via styles must be prefixed with a \":\""));
      }
      else {
          var normalizedStateName = stateName.substring(1);
          var value = stateStyles[normalizedStateName];
          if (!isPresent(value)) {
              errors.push(new AnimationParseError("Unable to apply styles due to missing a state: \"" + normalizedStateName + "\""));
          }
          else {
              value.styles.forEach(function (stylesEntry) {
                  if (typeof stylesEntry === 'object' && stylesEntry !== null) {
                      styles.push(stylesEntry);
                  }
              });
          }
      }
      return styles;
  }
  var _AnimationTimings = (function () {
      function _AnimationTimings(duration, delay, easing) {
          this.duration = duration;
          this.delay = delay;
          this.easing = easing;
      }
      return _AnimationTimings;
  }());
  function _parseAnimationKeyframes(keyframeSequence, currentTime, collectedStyles, stateStyles, errors) {
      var totalEntries = keyframeSequence.steps.length;
      var totalOffsets = 0;
      keyframeSequence.steps.forEach(function (step) { return totalOffsets += (isPresent(step.offset) ? 1 : 0); });
      if (totalOffsets > 0 && totalOffsets < totalEntries) {
          errors.push(new AnimationParseError("Not all style() entries contain an offset for the provided keyframe()"));
          totalOffsets = totalEntries;
      }
      var limit = totalEntries - 1;
      var margin = totalOffsets == 0 ? (1 / limit) : 0;
      var rawKeyframes = [];
      var index = 0;
      var doSortKeyframes = false;
      var lastOffset = 0;
      keyframeSequence.steps.forEach(function (styleMetadata) {
          var offset = styleMetadata.offset;
          var keyframeStyles = {};
          styleMetadata.styles.forEach(function (entry) {
              Object.keys(entry).forEach(function (prop) {
                  if (prop != 'offset') {
                      keyframeStyles[prop] = entry[prop];
                  }
              });
          });
          if (isPresent(offset)) {
              doSortKeyframes = doSortKeyframes || (offset < lastOffset);
          }
          else {
              offset = index == limit ? _TERMINAL_KEYFRAME : (margin * index);
          }
          rawKeyframes.push([offset, keyframeStyles]);
          lastOffset = offset;
          index++;
      });
      if (doSortKeyframes) {
          ListWrapper.sort(rawKeyframes, function (a, b) { return a[0] <= b[0] ? -1 : 1; });
      }
      var firstKeyframe = rawKeyframes[0];
      if (firstKeyframe[0] != _INITIAL_KEYFRAME) {
          ListWrapper.insert(rawKeyframes, 0, firstKeyframe = [_INITIAL_KEYFRAME, {}]);
      }
      var firstKeyframeStyles = firstKeyframe[1];
      limit = rawKeyframes.length - 1;
      var lastKeyframe = rawKeyframes[limit];
      if (lastKeyframe[0] != _TERMINAL_KEYFRAME) {
          rawKeyframes.push(lastKeyframe = [_TERMINAL_KEYFRAME, {}]);
          limit++;
      }
      var lastKeyframeStyles = lastKeyframe[1];
      for (var i = 1; i <= limit; i++) {
          var entry = rawKeyframes[i];
          var styles = entry[1];
          Object.keys(styles).forEach(function (prop) {
              if (!isPresent(firstKeyframeStyles[prop])) {
                  firstKeyframeStyles[prop] = FILL_STYLE_FLAG;
              }
          });
      }
      var _loop_1 = function(i) {
          var entry = rawKeyframes[i];
          var styles = entry[1];
          Object.keys(styles).forEach(function (prop) {
              if (!isPresent(lastKeyframeStyles[prop])) {
                  lastKeyframeStyles[prop] = styles[prop];
              }
          });
      };
      for (var i = limit - 1; i >= 0; i--) {
          _loop_1(i);
      }
      return rawKeyframes.map(function (entry) { return new AnimationKeyframeAst(entry[0], new AnimationStylesAst([entry[1]])); });
  }
  function _parseTransitionAnimation(entry, currentTime, collectedStyles, stateStyles, errors) {
      var ast;
      var playTime = 0;
      var startingTime = currentTime;
      if (entry instanceof CompileAnimationWithStepsMetadata) {
          var maxDuration = 0;
          var steps = [];
          var isGroup = entry instanceof CompileAnimationGroupMetadata;
          var previousStyles;
          entry.steps.forEach(function (entry) {
              // these will get picked up by the next step...
              var time = isGroup ? startingTime : currentTime;
              if (entry instanceof CompileAnimationStyleMetadata) {
                  entry.styles.forEach(function (stylesEntry) {
                      // by this point we know that we only have stringmap values
                      var map = stylesEntry;
                      Object.keys(map).forEach(function (prop) { collectedStyles.insertAtTime(prop, time, map[prop]); });
                  });
                  previousStyles = entry.styles;
                  return;
              }
              var innerAst = _parseTransitionAnimation(entry, time, collectedStyles, stateStyles, errors);
              if (isPresent(previousStyles)) {
                  if (entry instanceof CompileAnimationWithStepsMetadata) {
                      var startingStyles = new AnimationStylesAst(previousStyles);
                      steps.push(new AnimationStepAst(startingStyles, [], 0, 0, ''));
                  }
                  else {
                      var innerStep = innerAst;
                      ListWrapper.addAll(innerStep.startingStyles.styles, previousStyles);
                  }
                  previousStyles = null;
              }
              var astDuration = innerAst.playTime;
              currentTime += astDuration;
              playTime += astDuration;
              maxDuration = Math.max(astDuration, maxDuration);
              steps.push(innerAst);
          });
          if (isPresent(previousStyles)) {
              var startingStyles = new AnimationStylesAst(previousStyles);
              steps.push(new AnimationStepAst(startingStyles, [], 0, 0, ''));
          }
          if (isGroup) {
              ast = new AnimationGroupAst(steps);
              playTime = maxDuration;
              currentTime = startingTime + playTime;
          }
          else {
              ast = new AnimationSequenceAst(steps);
          }
      }
      else if (entry instanceof CompileAnimationAnimateMetadata) {
          var timings = _parseTimeExpression(entry.timings, errors);
          var styles = entry.styles;
          var keyframes;
          if (styles instanceof CompileAnimationKeyframesSequenceMetadata) {
              keyframes =
                  _parseAnimationKeyframes(styles, currentTime, collectedStyles, stateStyles, errors);
          }
          else {
              var styleData = styles;
              var offset = _TERMINAL_KEYFRAME;
              var styleAst = new AnimationStylesAst(styleData.styles);
              var keyframe = new AnimationKeyframeAst(offset, styleAst);
              keyframes = [keyframe];
          }
          ast = new AnimationStepAst(new AnimationStylesAst([]), keyframes, timings.duration, timings.delay, timings.easing);
          playTime = timings.duration + timings.delay;
          currentTime += playTime;
          keyframes.forEach(function (keyframe /** TODO #9100 */) { return keyframe.styles.styles.forEach(function (entry /** TODO #9100 */) { return Object.keys(entry).forEach(function (prop) { collectedStyles.insertAtTime(prop, currentTime, entry[prop]); }); }); });
      }
      else {
          // if the code reaches this stage then an error
          // has already been populated within the _normalizeStyleSteps()
          // operation...
          ast = new AnimationStepAst(null, [], 0, 0, '');
      }
      ast.playTime = playTime;
      ast.startTime = startingTime;
      return ast;
  }
  function _fillAnimationAstStartingKeyframes(ast, collectedStyles, errors) {
      // steps that only contain style will not be filled
      if ((ast instanceof AnimationStepAst) && ast.keyframes.length > 0) {
          var keyframes = ast.keyframes;
          if (keyframes.length == 1) {
              var endKeyframe = keyframes[0];
              var startKeyframe = _createStartKeyframeFromEndKeyframe(endKeyframe, ast.startTime, ast.playTime, collectedStyles, errors);
              ast.keyframes = [startKeyframe, endKeyframe];
          }
      }
      else if (ast instanceof AnimationWithStepsAst) {
          ast.steps.forEach(function (entry) { return _fillAnimationAstStartingKeyframes(entry, collectedStyles, errors); });
      }
  }
  function _parseTimeExpression(exp, errors) {
      var regex = /^([\.\d]+)(m?s)(?:\s+([\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?/i;
      var duration;
      var delay = 0;
      var easing = null;
      if (typeof exp === 'string') {
          var matches = exp.match(regex);
          if (matches === null) {
              errors.push(new AnimationParseError("The provided timing value \"" + exp + "\" is invalid."));
              return new _AnimationTimings(0, 0, null);
          }
          var durationMatch = parseFloat(matches[1]);
          var durationUnit = matches[2];
          if (durationUnit == 's') {
              durationMatch *= _ONE_SECOND;
          }
          duration = Math.floor(durationMatch);
          var delayMatch = matches[3];
          var delayUnit = matches[4];
          if (isPresent(delayMatch)) {
              var delayVal = parseFloat(delayMatch);
              if (isPresent(delayUnit) && delayUnit == 's') {
                  delayVal *= _ONE_SECOND;
              }
              delay = Math.floor(delayVal);
          }
          var easingVal = matches[5];
          if (!isBlank(easingVal)) {
              easing = easingVal;
          }
      }
      else {
          duration = exp;
      }
      return new _AnimationTimings(duration, delay, easing);
  }
  function _createStartKeyframeFromEndKeyframe(endKeyframe, startTime, duration, collectedStyles, errors) {
      var values = {};
      var endTime = startTime + duration;
      endKeyframe.styles.styles.forEach(function (styleData) {
          Object.keys(styleData).forEach(function (prop) {
              var val = styleData[prop];
              if (prop == 'offset')
                  return;
              var resultIndex = collectedStyles.indexOfAtOrBeforeTime(prop, startTime);
              var resultEntry /** TODO #9100 */, nextEntry /** TODO #9100 */, value;
              if (isPresent(resultIndex)) {
                  resultEntry = collectedStyles.getByIndex(prop, resultIndex);
                  value = resultEntry.value;
                  nextEntry = collectedStyles.getByIndex(prop, resultIndex + 1);
              }
              else {
                  // this is a flag that the runtime code uses to pass
                  // in a value either from the state declaration styles
                  // or using the AUTO_STYLE value (e.g. getComputedStyle)
                  value = FILL_STYLE_FLAG;
              }
              if (isPresent(nextEntry) && !nextEntry.matches(endTime, val)) {
                  errors.push(new AnimationParseError("The animated CSS property \"" + prop + "\" unexpectedly changes between steps \"" + resultEntry.time + "ms\" and \"" + endTime + "ms\" at \"" + nextEntry.time + "ms\""));
              }
              values[prop] = value;
          });
      });
      return new AnimationKeyframeAst(_INITIAL_KEYFRAME, new AnimationStylesAst([values]));
  }

  var DirectiveWrapperCompileResult = (function () {
      function DirectiveWrapperCompileResult(statements, dirWrapperClassVar) {
          this.statements = statements;
          this.dirWrapperClassVar = dirWrapperClassVar;
      }
      return DirectiveWrapperCompileResult;
  }());
  var CONTEXT_FIELD_NAME = 'context';
  var CHANGES_FIELD_NAME = 'changes';
  var CHANGED_FIELD_NAME = 'changed';
  var CURR_VALUE_VAR = variable('currValue');
  var THROW_ON_CHANGE_VAR = variable('throwOnChange');
  var FORCE_UPDATE_VAR = variable('forceUpdate');
  var VIEW_VAR = variable('view');
  var RENDER_EL_VAR = variable('el');
  var RESET_CHANGES_STMT = THIS_EXPR.prop(CHANGES_FIELD_NAME).set(literalMap([])).toStmt();
  /**
   * We generate directive wrappers to prevent code bloat when a directive is used.
   * A directive wrapper encapsulates
   * the dirty checking for `@Input`, the handling of `@HostListener` / `@HostBinding`
   * and calling the lifecyclehooks `ngOnInit`, `ngOnChanges`, `ngDoCheck`.
   *
   * So far, only `@Input` and the lifecycle hooks have been implemented.
   */
  var DirectiveWrapperCompiler = (function () {
      function DirectiveWrapperCompiler(compilerConfig) {
          this.compilerConfig = compilerConfig;
      }
      DirectiveWrapperCompiler.dirWrapperClassName = function (id) { return "Wrapper_" + id.name; };
      DirectiveWrapperCompiler.prototype.compile = function (dirMeta) {
          var dirDepParamNames = [];
          for (var i = 0; i < dirMeta.type.diDeps.length; i++) {
              dirDepParamNames.push("p" + i);
          }
          var dirLifecycleHooks = dirMeta.type.lifecycleHooks;
          var lifecycleHooks = {
              genChanges: dirLifecycleHooks.indexOf(LifecycleHooks.OnChanges) !== -1 ||
                  this.compilerConfig.logBindingUpdate,
              ngOnChanges: dirLifecycleHooks.indexOf(LifecycleHooks.OnChanges) !== -1,
              ngOnInit: dirLifecycleHooks.indexOf(LifecycleHooks.OnInit) !== -1,
              ngDoCheck: dirLifecycleHooks.indexOf(LifecycleHooks.DoCheck) !== -1
          };
          var fields = [
              new ClassField(CONTEXT_FIELD_NAME, importType(dirMeta.type)),
              new ClassField(CHANGED_FIELD_NAME, BOOL_TYPE),
          ];
          var ctorStmts = [THIS_EXPR.prop(CHANGED_FIELD_NAME).set(literal(false)).toStmt()];
          if (lifecycleHooks.genChanges) {
              fields.push(new ClassField(CHANGES_FIELD_NAME, new MapType(DYNAMIC_TYPE)));
              ctorStmts.push(RESET_CHANGES_STMT);
          }
          var methods = [];
          Object.keys(dirMeta.inputs).forEach(function (inputFieldName, idx) {
              var fieldName = "_" + inputFieldName;
              // private is fine here as no child view will reference the cached value...
              fields.push(new ClassField(fieldName, null, [StmtModifier.Private]));
              ctorStmts.push(THIS_EXPR.prop(fieldName)
                  .set(importExpr(resolveIdentifier(Identifiers.UNINITIALIZED)))
                  .toStmt());
              methods.push(checkInputMethod(inputFieldName, THIS_EXPR.prop(fieldName), lifecycleHooks));
          });
          methods.push(detectChangesInternalMethod(lifecycleHooks, this.compilerConfig.genDebugInfo));
          ctorStmts.push(THIS_EXPR.prop(CONTEXT_FIELD_NAME)
              .set(importExpr(dirMeta.type)
              .instantiate(dirDepParamNames.map(function (paramName) { return variable(paramName); })))
              .toStmt());
          var ctor = new ClassMethod(null, dirDepParamNames.map(function (paramName) { return new FnParam(paramName, DYNAMIC_TYPE); }), ctorStmts);
          var wrapperClassName = DirectiveWrapperCompiler.dirWrapperClassName(dirMeta.type);
          var classStmt = new ClassStmt(wrapperClassName, null, fields, [], ctor, methods);
          return new DirectiveWrapperCompileResult([classStmt], wrapperClassName);
      };
      DirectiveWrapperCompiler.decorators = [
          { type: _angular_core.Injectable },
      ];
      /** @nocollapse */
      DirectiveWrapperCompiler.ctorParameters = [
          { type: CompilerConfig, },
      ];
      return DirectiveWrapperCompiler;
  }());
  function detectChangesInternalMethod(lifecycleHooks, logBindingUpdate) {
      var changedVar = variable('changed');
      var stmts = [
          changedVar.set(THIS_EXPR.prop(CHANGED_FIELD_NAME)).toDeclStmt(),
          THIS_EXPR.prop(CHANGED_FIELD_NAME).set(literal(false)).toStmt(),
      ];
      var lifecycleStmts = [];
      if (lifecycleHooks.genChanges) {
          var onChangesStmts = [];
          if (lifecycleHooks.ngOnChanges) {
              onChangesStmts.push(THIS_EXPR.prop(CONTEXT_FIELD_NAME)
                  .callMethod('ngOnChanges', [THIS_EXPR.prop(CHANGES_FIELD_NAME)])
                  .toStmt());
          }
          if (logBindingUpdate) {
              onChangesStmts.push(importExpr(resolveIdentifier(Identifiers.setBindingDebugInfoForChanges))
                  .callFn([VIEW_VAR.prop('renderer'), RENDER_EL_VAR, THIS_EXPR.prop(CHANGES_FIELD_NAME)])
                  .toStmt());
          }
          onChangesStmts.push(RESET_CHANGES_STMT);
          lifecycleStmts.push(new IfStmt(changedVar, onChangesStmts));
      }
      if (lifecycleHooks.ngOnInit) {
          lifecycleStmts.push(new IfStmt(VIEW_VAR.prop('numberOfChecks').identical(new LiteralExpr(0)), [THIS_EXPR.prop(CONTEXT_FIELD_NAME).callMethod('ngOnInit', []).toStmt()]));
      }
      if (lifecycleHooks.ngDoCheck) {
          lifecycleStmts.push(THIS_EXPR.prop(CONTEXT_FIELD_NAME).callMethod('ngDoCheck', []).toStmt());
      }
      if (lifecycleStmts.length > 0) {
          stmts.push(new IfStmt(not(THROW_ON_CHANGE_VAR), lifecycleStmts));
      }
      stmts.push(new ReturnStatement(changedVar));
      return new ClassMethod('detectChangesInternal', [
          new FnParam(VIEW_VAR.name, importType(resolveIdentifier(Identifiers.AppView), [DYNAMIC_TYPE])),
          new FnParam(RENDER_EL_VAR.name, DYNAMIC_TYPE),
          new FnParam(THROW_ON_CHANGE_VAR.name, BOOL_TYPE),
      ], stmts, BOOL_TYPE);
  }
  function checkInputMethod(input, fieldExpr, lifecycleHooks) {
      var onChangeStatements = [
          THIS_EXPR.prop(CHANGED_FIELD_NAME).set(literal(true)).toStmt(),
          THIS_EXPR.prop(CONTEXT_FIELD_NAME).prop(input).set(CURR_VALUE_VAR).toStmt(),
      ];
      if (lifecycleHooks.genChanges) {
          onChangeStatements.push(THIS_EXPR.prop(CHANGES_FIELD_NAME)
              .key(literal(input))
              .set(importExpr(resolveIdentifier(Identifiers.SimpleChange))
              .instantiate([fieldExpr, CURR_VALUE_VAR]))
              .toStmt());
      }
      onChangeStatements.push(fieldExpr.set(CURR_VALUE_VAR).toStmt());
      var methodBody = [
          new IfStmt(FORCE_UPDATE_VAR.or(importExpr(resolveIdentifier(Identifiers.checkBinding))
              .callFn([THROW_ON_CHANGE_VAR, fieldExpr, CURR_VALUE_VAR])), onChangeStatements),
      ];
      return new ClassMethod("check_" + input, [
          new FnParam(CURR_VALUE_VAR.name, DYNAMIC_TYPE),
          new FnParam(THROW_ON_CHANGE_VAR.name, BOOL_TYPE),
          new FnParam(FORCE_UPDATE_VAR.name, BOOL_TYPE),
      ], methodBody);
  }

  function convertValueToOutputAst(value, type) {
      if (type === void 0) { type = null; }
      return visitValue(value, new _ValueOutputAstTransformer(), type);
  }
  var _ValueOutputAstTransformer = (function () {
      function _ValueOutputAstTransformer() {
      }
      _ValueOutputAstTransformer.prototype.visitArray = function (arr, type) {
          var _this = this;
          return literalArr(arr.map(function (value) { return visitValue(value, _this, null); }), type);
      };
      _ValueOutputAstTransformer.prototype.visitStringMap = function (map, type) {
          var _this = this;
          var entries = [];
          Object.keys(map).forEach(function (key) { entries.push([key, visitValue(map[key], _this, null)]); });
          return literalMap(entries, type);
      };
      _ValueOutputAstTransformer.prototype.visitPrimitive = function (value, type) { return literal(value, type); };
      _ValueOutputAstTransformer.prototype.visitOther = function (value, type) {
          if (value instanceof CompileIdentifierMetadata) {
              return importExpr(value);
          }
          else if (value instanceof Expression) {
              return value;
          }
          else {
              throw new Error("Illegal state: Don't now how to compile value " + value);
          }
      };
      return _ValueOutputAstTransformer;
  }());

  var _DebugState = (function () {
      function _DebugState(nodeIndex, sourceAst) {
          this.nodeIndex = nodeIndex;
          this.sourceAst = sourceAst;
      }
      return _DebugState;
  }());
  var NULL_DEBUG_STATE = new _DebugState(null, null);
  var CompileMethod = (function () {
      function CompileMethod(_view) {
          this._view = _view;
          this._newState = NULL_DEBUG_STATE;
          this._currState = NULL_DEBUG_STATE;
          this._bodyStatements = [];
          this._debugEnabled = this._view.genConfig.genDebugInfo;
      }
      CompileMethod.prototype._updateDebugContextIfNeeded = function () {
          if (this._newState.nodeIndex !== this._currState.nodeIndex ||
              this._newState.sourceAst !== this._currState.sourceAst) {
              var expr = this._updateDebugContext(this._newState);
              if (isPresent(expr)) {
                  this._bodyStatements.push(expr.toStmt());
              }
          }
      };
      CompileMethod.prototype._updateDebugContext = function (newState) {
          this._currState = this._newState = newState;
          if (this._debugEnabled) {
              var sourceLocation = isPresent(newState.sourceAst) ? newState.sourceAst.sourceSpan.start : null;
              return THIS_EXPR.callMethod('debug', [
                  literal(newState.nodeIndex),
                  isPresent(sourceLocation) ? literal(sourceLocation.line) : NULL_EXPR,
                  isPresent(sourceLocation) ? literal(sourceLocation.col) : NULL_EXPR
              ]);
          }
          else {
              return null;
          }
      };
      CompileMethod.prototype.resetDebugInfoExpr = function (nodeIndex, templateAst) {
          var res = this._updateDebugContext(new _DebugState(nodeIndex, templateAst));
          return res || NULL_EXPR;
      };
      CompileMethod.prototype.resetDebugInfo = function (nodeIndex, templateAst) {
          this._newState = new _DebugState(nodeIndex, templateAst);
      };
      CompileMethod.prototype.addStmt = function (stmt) {
          this._updateDebugContextIfNeeded();
          this._bodyStatements.push(stmt);
      };
      CompileMethod.prototype.addStmts = function (stmts) {
          this._updateDebugContextIfNeeded();
          ListWrapper.addAll(this._bodyStatements, stmts);
      };
      CompileMethod.prototype.finish = function () { return this._bodyStatements; };
      CompileMethod.prototype.isEmpty = function () { return this._bodyStatements.length === 0; };
      return CompileMethod;
  }());

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var __extends$15 = (this && this.__extends) || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  function getPropertyInView(property, callingView, definedView) {
      if (callingView === definedView) {
          return property;
      }
      else {
          var viewProp = THIS_EXPR;
          var currView = callingView;
          while (currView !== definedView && isPresent(currView.declarationElement.view)) {
              currView = currView.declarationElement.view;
              viewProp = viewProp.prop('parent');
          }
          if (currView !== definedView) {
              throw new Error("Internal error: Could not calculate a property in a parent view: " + property);
          }
          return property.visitExpression(new _ReplaceViewTransformer(viewProp, definedView), null);
      }
  }
  var _ReplaceViewTransformer = (function (_super) {
      __extends$15(_ReplaceViewTransformer, _super);
      function _ReplaceViewTransformer(_viewExpr, _view) {
          _super.call(this);
          this._viewExpr = _viewExpr;
          this._view = _view;
      }
      _ReplaceViewTransformer.prototype._isThis = function (expr) {
          return expr instanceof ReadVarExpr && expr.builtin === BuiltinVar.This;
      };
      _ReplaceViewTransformer.prototype.visitReadVarExpr = function (ast, context) {
          return this._isThis(ast) ? this._viewExpr : ast;
      };
      _ReplaceViewTransformer.prototype.visitReadPropExpr = function (ast, context) {
          if (this._isThis(ast.receiver)) {
              // Note: Don't cast for members of the AppView base class...
              if (this._view.fields.some(function (field) { return field.name == ast.name; }) ||
                  this._view.getters.some(function (field) { return field.name == ast.name; })) {
                  return this._viewExpr.cast(this._view.classType).prop(ast.name);
              }
          }
          return _super.prototype.visitReadPropExpr.call(this, ast, context);
      };
      return _ReplaceViewTransformer;
  }(ExpressionTransformer));
  function injectFromViewParentInjector(token, optional) {
      var args = [createDiTokenExpression(token)];
      if (optional) {
          args.push(NULL_EXPR);
      }
      return THIS_EXPR.prop('parentInjector').callMethod('get', args);
  }
  function getViewFactoryName(component, embeddedTemplateIndex) {
      return "viewFactory_" + component.type.name + embeddedTemplateIndex;
  }
  function createFlatArray(expressions) {
      var lastNonArrayExpressions = [];
      var result = literalArr([]);
      for (var i = 0; i < expressions.length; i++) {
          var expr = expressions[i];
          if (expr.type instanceof ArrayType) {
              if (lastNonArrayExpressions.length > 0) {
                  result =
                      result.callMethod(BuiltinMethod.ConcatArray, [literalArr(lastNonArrayExpressions)]);
                  lastNonArrayExpressions = [];
              }
              result = result.callMethod(BuiltinMethod.ConcatArray, [expr]);
          }
          else {
              lastNonArrayExpressions.push(expr);
          }
      }
      if (lastNonArrayExpressions.length > 0) {
          result =
              result.callMethod(BuiltinMethod.ConcatArray, [literalArr(lastNonArrayExpressions)]);
      }
      return result;
  }
  function createPureProxy(fn, argCount, pureProxyProp, view) {
      view.fields.push(new ClassField(pureProxyProp.name, null));
      var pureProxyId = argCount < Identifiers.pureProxies.length ? Identifiers.pureProxies[argCount] : null;
      if (!pureProxyId) {
          throw new Error("Unsupported number of argument for pure functions: " + argCount);
      }
      view.createMethod.addStmt(THIS_EXPR.prop(pureProxyProp.name)
          .set(importExpr(resolveIdentifier(pureProxyId)).callFn([fn]))
          .toStmt());
  }

  var ViewQueryValues = (function () {
      function ViewQueryValues(view, values) {
          this.view = view;
          this.values = values;
      }
      return ViewQueryValues;
  }());
  var CompileQuery = (function () {
      function CompileQuery(meta, queryList, ownerDirectiveExpression, view) {
          this.meta = meta;
          this.queryList = queryList;
          this.ownerDirectiveExpression = ownerDirectiveExpression;
          this.view = view;
          this._values = new ViewQueryValues(view, []);
      }
      CompileQuery.prototype.addValue = function (value, view) {
          var currentView = view;
          var elPath = [];
          while (isPresent(currentView) && currentView !== this.view) {
              var parentEl = currentView.declarationElement;
              elPath.unshift(parentEl);
              currentView = parentEl.view;
          }
          var queryListForDirtyExpr = getPropertyInView(this.queryList, view, this.view);
          var viewValues = this._values;
          elPath.forEach(function (el) {
              var last = viewValues.values.length > 0 ? viewValues.values[viewValues.values.length - 1] : null;
              if (last instanceof ViewQueryValues && last.view === el.embeddedView) {
                  viewValues = last;
              }
              else {
                  var newViewValues = new ViewQueryValues(el.embeddedView, []);
                  viewValues.values.push(newViewValues);
                  viewValues = newViewValues;
              }
          });
          viewValues.values.push(value);
          if (elPath.length > 0) {
              view.dirtyParentQueriesMethod.addStmt(queryListForDirtyExpr.callMethod('setDirty', []).toStmt());
          }
      };
      CompileQuery.prototype._isStatic = function () {
          return !this._values.values.some(function (value) { return value instanceof ViewQueryValues; });
      };
      CompileQuery.prototype.afterChildren = function (targetStaticMethod, targetDynamicMethod) {
          var values = createQueryValues(this._values);
          var updateStmts = [this.queryList.callMethod('reset', [literalArr(values)]).toStmt()];
          if (isPresent(this.ownerDirectiveExpression)) {
              var valueExpr = this.meta.first ? this.queryList.prop('first') : this.queryList;
              updateStmts.push(this.ownerDirectiveExpression.prop(this.meta.propertyName).set(valueExpr).toStmt());
          }
          if (!this.meta.first) {
              updateStmts.push(this.queryList.callMethod('notifyOnChanges', []).toStmt());
          }
          if (this.meta.first && this._isStatic()) {
              // for queries that don't change and the user asked for a single element,
              // set it immediately. That is e.g. needed for querying for ViewContainerRefs, ...
              // we don't do this for QueryLists for now as this would break the timing when
              // we call QueryList listeners...
              targetStaticMethod.addStmts(updateStmts);
          }
          else {
              targetDynamicMethod.addStmt(new IfStmt(this.queryList.prop('dirty'), updateStmts));
          }
      };
      return CompileQuery;
  }());
  function createQueryValues(viewValues) {
      return ListWrapper.flatten(viewValues.values.map(function (entry) {
          if (entry instanceof ViewQueryValues) {
              return mapNestedViews(entry.view.declarationElement.appElement, entry.view, createQueryValues(entry));
          }
          else {
              return entry;
          }
      }));
  }
  function mapNestedViews(declarationAppElement, view, expressions) {
      var adjustedExpressions = expressions.map(function (expr) { return replaceVarInExpression(THIS_EXPR.name, variable('nestedView'), expr); });
      return declarationAppElement.callMethod('mapNestedViews', [
          variable(view.className),
          fn([new FnParam('nestedView', view.classType)], [new ReturnStatement(literalArr(adjustedExpressions))], DYNAMIC_TYPE)
      ]);
  }
  function createQueryList(query, directiveInstance, propertyName, compileView) {
      compileView.fields.push(new ClassField(propertyName, importType(resolveIdentifier(Identifiers.QueryList), [DYNAMIC_TYPE])));
      var expr = THIS_EXPR.prop(propertyName);
      compileView.createMethod.addStmt(THIS_EXPR.prop(propertyName)
          .set(importExpr(resolveIdentifier(Identifiers.QueryList), [DYNAMIC_TYPE])
          .instantiate([]))
          .toStmt());
      return expr;
  }
  function addQueryToTokenMap(map, query) {
      query.meta.selectors.forEach(function (selector) {
          var entry = map.get(selector.reference);
          if (!entry) {
              entry = [];
              map.set(selector.reference, entry);
          }
          entry.push(query);
      });
  }

  function _enumExpression(classIdentifier, name) {
      return importExpr(resolveEnumIdentifier(classIdentifier, name));
  }
  var ViewTypeEnum = (function () {
      function ViewTypeEnum() {
      }
      ViewTypeEnum.fromValue = function (value) {
          var viewType = resolveIdentifier(Identifiers.ViewType);
          switch (value) {
              case ViewType.HOST:
                  return _enumExpression(viewType, 'HOST');
              case ViewType.COMPONENT:
                  return _enumExpression(viewType, 'COMPONENT');
              case ViewType.EMBEDDED:
                  return _enumExpression(viewType, 'EMBEDDED');
              default:
                  throw Error("Inavlid ViewType value: " + value);
          }
      };
      return ViewTypeEnum;
  }());
  var ViewEncapsulationEnum = (function () {
      function ViewEncapsulationEnum() {
      }
      ViewEncapsulationEnum.fromValue = function (value) {
          var viewEncapsulation = resolveIdentifier(Identifiers.ViewEncapsulation);
          switch (value) {
              case _angular_core.ViewEncapsulation.Emulated:
                  return _enumExpression(viewEncapsulation, 'Emulated');
              case _angular_core.ViewEncapsulation.Native:
                  return _enumExpression(viewEncapsulation, 'Native');
              case _angular_core.ViewEncapsulation.None:
                  return _enumExpression(viewEncapsulation, 'None');
              default:
                  throw Error("Inavlid ViewEncapsulation value: " + value);
          }
      };
      return ViewEncapsulationEnum;
  }());
  var ChangeDetectorStatusEnum = (function () {
      function ChangeDetectorStatusEnum() {
      }
      ChangeDetectorStatusEnum.fromValue = function (value) {
          var changeDetectorStatus = resolveIdentifier(Identifiers.ChangeDetectorStatus);
          switch (value) {
              case ChangeDetectorStatus.CheckOnce:
                  return _enumExpression(changeDetectorStatus, 'CheckOnce');
              case ChangeDetectorStatus.Checked:
                  return _enumExpression(changeDetectorStatus, 'Checked');
              case ChangeDetectorStatus.CheckAlways:
                  return _enumExpression(changeDetectorStatus, 'CheckAlways');
              case ChangeDetectorStatus.Detached:
                  return _enumExpression(changeDetectorStatus, 'Detached');
              case ChangeDetectorStatus.Errored:
                  return _enumExpression(changeDetectorStatus, 'Errored');
              case ChangeDetectorStatus.Destroyed:
                  return _enumExpression(changeDetectorStatus, 'Destroyed');
              default:
                  throw Error("Inavlid ChangeDetectorStatus value: " + value);
          }
      };
      return ChangeDetectorStatusEnum;
  }());
  var ViewConstructorVars = (function () {
      function ViewConstructorVars() {
      }
      ViewConstructorVars.viewUtils = variable('viewUtils');
      ViewConstructorVars.parentInjector = variable('parentInjector');
      ViewConstructorVars.declarationEl = variable('declarationEl');
      return ViewConstructorVars;
  }());
  var ViewProperties = (function () {
      function ViewProperties() {
      }
      ViewProperties.renderer = THIS_EXPR.prop('renderer');
      ViewProperties.projectableNodes = THIS_EXPR.prop('projectableNodes');
      ViewProperties.viewUtils = THIS_EXPR.prop('viewUtils');
      return ViewProperties;
  }());
  var EventHandlerVars = (function () {
      function EventHandlerVars() {
      }
      EventHandlerVars.event = variable('$event');
      return EventHandlerVars;
  }());
  var InjectMethodVars = (function () {
      function InjectMethodVars() {
      }
      InjectMethodVars.token = variable('token');
      InjectMethodVars.requestNodeIndex = variable('requestNodeIndex');
      InjectMethodVars.notFoundResult = variable('notFoundResult');
      return InjectMethodVars;
  }());
  var DetectChangesVars = (function () {
      function DetectChangesVars() {
      }
      DetectChangesVars.throwOnChange = variable("throwOnChange");
      DetectChangesVars.changes = variable("changes");
      DetectChangesVars.changed = variable("changed");
      DetectChangesVars.valUnwrapper = variable("valUnwrapper");
      return DetectChangesVars;
  }());

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var ViewFactoryDependency = (function () {
      function ViewFactoryDependency(comp, placeholder) {
          this.comp = comp;
          this.placeholder = placeholder;
      }
      return ViewFactoryDependency;
  }());
  var ComponentFactoryDependency = (function () {
      function ComponentFactoryDependency(comp, placeholder) {
          this.comp = comp;
          this.placeholder = placeholder;
      }
      return ComponentFactoryDependency;
  }());
  var DirectiveWrapperDependency = (function () {
      function DirectiveWrapperDependency(dir, placeholder) {
          this.dir = dir;
          this.placeholder = placeholder;
      }
      return DirectiveWrapperDependency;
  }());

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var __extends$14 = (this && this.__extends) || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var CompileNode = (function () {
      function CompileNode(parent, view, nodeIndex, renderNode, sourceAst) {
          this.parent = parent;
          this.view = view;
          this.nodeIndex = nodeIndex;
          this.renderNode = renderNode;
          this.sourceAst = sourceAst;
      }
      CompileNode.prototype.isNull = function () { return !this.renderNode; };
      CompileNode.prototype.isRootElement = function () { return this.view != this.parent.view; };
      return CompileNode;
  }());
  var CompileElement = (function (_super) {
      __extends$14(CompileElement, _super);
      function CompileElement(parent, view, nodeIndex, renderNode, sourceAst, component, _directives, _resolvedProvidersArray, hasViewContainer, hasEmbeddedView, references, _targetDependencies) {
          var _this = this;
          _super.call(this, parent, view, nodeIndex, renderNode, sourceAst);
          this.component = component;
          this._directives = _directives;
          this._resolvedProvidersArray = _resolvedProvidersArray;
          this.hasViewContainer = hasViewContainer;
          this.hasEmbeddedView = hasEmbeddedView;
          this._targetDependencies = _targetDependencies;
          this._compViewExpr = null;
          this.instances = new Map();
          this.directiveWrapperInstance = new Map();
          this._queryCount = 0;
          this._queries = new Map();
          this._componentConstructorViewQueryLists = [];
          this.contentNodesByNgContentIndex = null;
          this.referenceTokens = {};
          references.forEach(function (ref) { return _this.referenceTokens[ref.name] = ref.value; });
          this.elementRef =
              importExpr(resolveIdentifier(Identifiers.ElementRef)).instantiate([this.renderNode]);
          this.instances.set(resolveIdentifierToken(Identifiers.ElementRef).reference, this.elementRef);
          this.injector = THIS_EXPR.callMethod('injector', [literal(this.nodeIndex)]);
          this.instances.set(resolveIdentifierToken(Identifiers.Injector).reference, this.injector);
          this.instances.set(resolveIdentifierToken(Identifiers.Renderer).reference, THIS_EXPR.prop('renderer'));
          if (this.hasViewContainer || this.hasEmbeddedView || isPresent(this.component)) {
              this._createAppElement();
          }
          if (this.component) {
              this._createComponentFactoryResolver();
          }
      }
      CompileElement.createNull = function () {
          return new CompileElement(null, null, null, null, null, null, [], [], false, false, [], []);
      };
      CompileElement.prototype._createAppElement = function () {
          var fieldName = "_appEl_" + this.nodeIndex;
          var parentNodeIndex = this.isRootElement() ? null : this.parent.nodeIndex;
          // private is fine here as no child view will reference an AppElement
          this.view.fields.push(new ClassField(fieldName, importType(resolveIdentifier(Identifiers.AppElement)), [StmtModifier.Private]));
          var statement = THIS_EXPR.prop(fieldName)
              .set(importExpr(resolveIdentifier(Identifiers.AppElement)).instantiate([
              literal(this.nodeIndex), literal(parentNodeIndex), THIS_EXPR, this.renderNode
          ]))
              .toStmt();
          this.view.createMethod.addStmt(statement);
          this.appElement = THIS_EXPR.prop(fieldName);
          this.instances.set(resolveIdentifierToken(Identifiers.AppElement).reference, this.appElement);
      };
      CompileElement.prototype._createComponentFactoryResolver = function () {
          var _this = this;
          var entryComponents = this.component.entryComponents.map(function (entryComponent) {
              var id = new CompileIdentifierMetadata({ name: entryComponent.name });
              _this._targetDependencies.push(new ComponentFactoryDependency(entryComponent, id));
              return id;
          });
          if (!entryComponents || entryComponents.length === 0) {
              return;
          }
          var createComponentFactoryResolverExpr = importExpr(resolveIdentifier(Identifiers.CodegenComponentFactoryResolver)).instantiate([
              literalArr(entryComponents.map(function (entryComponent) { return importExpr(entryComponent); })),
              injectFromViewParentInjector(resolveIdentifierToken(Identifiers.ComponentFactoryResolver), false)
          ]);
          var provider = new CompileProviderMetadata({
              token: resolveIdentifierToken(Identifiers.ComponentFactoryResolver),
              useValue: createComponentFactoryResolverExpr
          });
          // Add ComponentFactoryResolver as first provider as it does not have deps on other providers
          // ProviderAstType.PrivateService as only the component and its view can see it,
          // but nobody else
          this._resolvedProvidersArray.unshift(new ProviderAst(provider.token, false, true, [provider], exports.ProviderAstType.PrivateService, [], this.sourceAst.sourceSpan));
      };
      CompileElement.prototype.setComponentView = function (compViewExpr) {
          this._compViewExpr = compViewExpr;
          this.contentNodesByNgContentIndex =
              new Array(this.component.template.ngContentSelectors.length);
          for (var i = 0; i < this.contentNodesByNgContentIndex.length; i++) {
              this.contentNodesByNgContentIndex[i] = [];
          }
      };
      CompileElement.prototype.setEmbeddedView = function (embeddedView) {
          this.embeddedView = embeddedView;
          if (isPresent(embeddedView)) {
              var createTemplateRefExpr = importExpr(resolveIdentifier(Identifiers.TemplateRef_)).instantiate([
                  this.appElement, this.embeddedView.viewFactory
              ]);
              var provider = new CompileProviderMetadata({
                  token: resolveIdentifierToken(Identifiers.TemplateRef),
                  useValue: createTemplateRefExpr
              });
              // Add TemplateRef as first provider as it does not have deps on other providers
              this._resolvedProvidersArray.unshift(new ProviderAst(provider.token, false, true, [provider], exports.ProviderAstType.Builtin, [], this.sourceAst.sourceSpan));
          }
      };
      CompileElement.prototype.beforeChildren = function () {
          var _this = this;
          if (this.hasViewContainer) {
              this.instances.set(resolveIdentifierToken(Identifiers.ViewContainerRef).reference, this.appElement.prop('vcRef'));
          }
          this._resolvedProviders = new Map();
          this._resolvedProvidersArray.forEach(function (provider) { return _this._resolvedProviders.set(provider.token.reference, provider); });
          // create all the provider instances, some in the view constructor,
          // some as getters. We rely on the fact that they are already sorted topologically.
          MapWrapper.values(this._resolvedProviders).forEach(function (resolvedProvider) {
              var isDirectiveWrapper = resolvedProvider.providerType === exports.ProviderAstType.Component ||
                  resolvedProvider.providerType === exports.ProviderAstType.Directive;
              var providerValueExpressions = resolvedProvider.providers.map(function (provider) {
                  if (isPresent(provider.useExisting)) {
                      return _this._getDependency(resolvedProvider.providerType, new CompileDiDependencyMetadata({ token: provider.useExisting }));
                  }
                  else if (isPresent(provider.useFactory)) {
                      var deps = provider.deps || provider.useFactory.diDeps;
                      var depsExpr = deps.map(function (dep) { return _this._getDependency(resolvedProvider.providerType, dep); });
                      return importExpr(provider.useFactory).callFn(depsExpr);
                  }
                  else if (isPresent(provider.useClass)) {
                      var deps = provider.deps || provider.useClass.diDeps;
                      var depsExpr = deps.map(function (dep) { return _this._getDependency(resolvedProvider.providerType, dep); });
                      if (isDirectiveWrapper) {
                          var directiveWrapperIdentifier = new CompileIdentifierMetadata({ name: DirectiveWrapperCompiler.dirWrapperClassName(provider.useClass) });
                          _this._targetDependencies.push(new DirectiveWrapperDependency(provider.useClass, directiveWrapperIdentifier));
                          return importExpr(directiveWrapperIdentifier)
                              .instantiate(depsExpr, importType(directiveWrapperIdentifier));
                      }
                      else {
                          return importExpr(provider.useClass)
                              .instantiate(depsExpr, importType(provider.useClass));
                      }
                  }
                  else {
                      return convertValueToOutputAst(provider.useValue);
                  }
              });
              var propName = "_" + resolvedProvider.token.name + "_" + _this.nodeIndex + "_" + _this.instances.size;
              var instance = createProviderProperty(propName, resolvedProvider, providerValueExpressions, resolvedProvider.multiProvider, resolvedProvider.eager, _this);
              if (isDirectiveWrapper) {
                  _this.directiveWrapperInstance.set(resolvedProvider.token.reference, instance);
                  _this.instances.set(resolvedProvider.token.reference, instance.prop('context'));
              }
              else {
                  _this.instances.set(resolvedProvider.token.reference, instance);
              }
          });
          for (var i = 0; i < this._directives.length; i++) {
              var directive = this._directives[i];
              var directiveInstance = this.instances.get(identifierToken(directive.type).reference);
              directive.queries.forEach(function (queryMeta) { _this._addQuery(queryMeta, directiveInstance); });
          }
          var queriesWithReads = [];
          MapWrapper.values(this._resolvedProviders).forEach(function (resolvedProvider) {
              var queriesForProvider = _this._getQueriesFor(resolvedProvider.token);
              ListWrapper.addAll(queriesWithReads, queriesForProvider.map(function (query) { return new _QueryWithRead(query, resolvedProvider.token); }));
          });
          Object.keys(this.referenceTokens).forEach(function (varName) {
              var token = _this.referenceTokens[varName];
              var varValue;
              if (isPresent(token)) {
                  varValue = _this.instances.get(token.reference);
              }
              else {
                  varValue = _this.renderNode;
              }
              _this.view.locals.set(varName, varValue);
              var varToken = new CompileTokenMetadata({ value: varName });
              ListWrapper.addAll(queriesWithReads, _this._getQueriesFor(varToken).map(function (query) { return new _QueryWithRead(query, varToken); }));
          });
          queriesWithReads.forEach(function (queryWithRead) {
              var value;
              if (isPresent(queryWithRead.read.identifier)) {
                  // query for an identifier
                  value = _this.instances.get(queryWithRead.read.reference);
              }
              else {
                  // query for a reference
                  var token = _this.referenceTokens[queryWithRead.read.value];
                  if (isPresent(token)) {
                      value = _this.instances.get(token.reference);
                  }
                  else {
                      value = _this.elementRef;
                  }
              }
              if (isPresent(value)) {
                  queryWithRead.query.addValue(value, _this.view);
              }
          });
          if (isPresent(this.component)) {
              var componentConstructorViewQueryList = isPresent(this.component) ?
                  literalArr(this._componentConstructorViewQueryLists) :
                  NULL_EXPR;
              var compExpr = isPresent(this.getComponent()) ? this.getComponent() : NULL_EXPR;
              this.view.createMethod.addStmt(this.appElement
                  .callMethod('initComponent', [compExpr, componentConstructorViewQueryList, this._compViewExpr])
                  .toStmt());
          }
      };
      CompileElement.prototype.afterChildren = function (childNodeCount) {
          var _this = this;
          MapWrapper.values(this._resolvedProviders).forEach(function (resolvedProvider) {
              // Note: afterChildren is called after recursing into children.
              // This is good so that an injector match in an element that is closer to a requesting element
              // matches first.
              var providerExpr = _this.instances.get(resolvedProvider.token.reference);
              // Note: view providers are only visible on the injector of that element.
              // This is not fully correct as the rules during codegen don't allow a directive
              // to get hold of a view provdier on the same element. We still do this semantic
              // as it simplifies our model to having only one runtime injector per element.
              var providerChildNodeCount = resolvedProvider.providerType === exports.ProviderAstType.PrivateService ? 0 : childNodeCount;
              _this.view.injectorGetMethod.addStmt(createInjectInternalCondition(_this.nodeIndex, providerChildNodeCount, resolvedProvider, providerExpr));
          });
          MapWrapper.values(this._queries)
              .forEach(function (queries) { return queries.forEach(function (query) { return query.afterChildren(_this.view.createMethod, _this.view.updateContentQueriesMethod); }); });
      };
      CompileElement.prototype.addContentNode = function (ngContentIndex, nodeExpr) {
          this.contentNodesByNgContentIndex[ngContentIndex].push(nodeExpr);
      };
      CompileElement.prototype.getComponent = function () {
          return isPresent(this.component) ?
              this.instances.get(identifierToken(this.component.type).reference) :
              null;
      };
      CompileElement.prototype.getProviderTokens = function () {
          return MapWrapper.values(this._resolvedProviders)
              .map(function (resolvedProvider) { return createDiTokenExpression(resolvedProvider.token); });
      };
      CompileElement.prototype._getQueriesFor = function (token) {
          var result = [];
          var currentEl = this;
          var distance = 0;
          var queries;
          while (!currentEl.isNull()) {
              queries = currentEl._queries.get(token.reference);
              if (isPresent(queries)) {
                  ListWrapper.addAll(result, queries.filter(function (query) { return query.meta.descendants || distance <= 1; }));
              }
              if (currentEl._directives.length > 0) {
                  distance++;
              }
              currentEl = currentEl.parent;
          }
          queries = this.view.componentView.viewQueries.get(token.reference);
          if (isPresent(queries)) {
              ListWrapper.addAll(result, queries);
          }
          return result;
      };
      CompileElement.prototype._addQuery = function (queryMeta, directiveInstance) {
          var propName = "_query_" + queryMeta.selectors[0].name + "_" + this.nodeIndex + "_" + this._queryCount++;
          var queryList = createQueryList(queryMeta, directiveInstance, propName, this.view);
          var query = new CompileQuery(queryMeta, queryList, directiveInstance, this.view);
          addQueryToTokenMap(this._queries, query);
          return query;
      };
      CompileElement.prototype._getLocalDependency = function (requestingProviderType, dep) {
          var result = null;
          // constructor content query
          if (!result && isPresent(dep.query)) {
              result = this._addQuery(dep.query, null).queryList;
          }
          // constructor view query
          if (!result && isPresent(dep.viewQuery)) {
              result = createQueryList(dep.viewQuery, null, "_viewQuery_" + dep.viewQuery.selectors[0].name + "_" + this.nodeIndex + "_" + this._componentConstructorViewQueryLists.length, this.view);
              this._componentConstructorViewQueryLists.push(result);
          }
          if (isPresent(dep.token)) {
              // access builtins with special visibility
              if (!result) {
                  if (dep.token.reference ===
                      resolveIdentifierToken(Identifiers.ChangeDetectorRef).reference) {
                      if (requestingProviderType === exports.ProviderAstType.Component) {
                          return this._compViewExpr.prop('ref');
                      }
                      else {
                          return getPropertyInView(THIS_EXPR.prop('ref'), this.view, this.view.componentView);
                      }
                  }
              }
              // access regular providers on the element
              if (!result) {
                  var resolvedProvider = this._resolvedProviders.get(dep.token.reference);
                  // don't allow directives / public services to access private services.
                  // only components and private services can access private services.
                  if (resolvedProvider && (requestingProviderType === exports.ProviderAstType.Directive ||
                      requestingProviderType === exports.ProviderAstType.PublicService) &&
                      resolvedProvider.providerType === exports.ProviderAstType.PrivateService) {
                      return null;
                  }
                  result = this.instances.get(dep.token.reference);
              }
          }
          return result;
      };
      CompileElement.prototype._getDependency = function (requestingProviderType, dep) {
          var currElement = this;
          var result = null;
          if (dep.isValue) {
              result = literal(dep.value);
          }
          if (!result && !dep.isSkipSelf) {
              result = this._getLocalDependency(requestingProviderType, dep);
          }
          // check parent elements
          while (!result && !currElement.parent.isNull()) {
              currElement = currElement.parent;
              result = currElement._getLocalDependency(exports.ProviderAstType.PublicService, new CompileDiDependencyMetadata({ token: dep.token }));
          }
          if (!result) {
              result = injectFromViewParentInjector(dep.token, dep.isOptional);
          }
          if (!result) {
              result = NULL_EXPR;
          }
          return getPropertyInView(result, this.view, currElement.view);
      };
      return CompileElement;
  }(CompileNode));
  function createInjectInternalCondition(nodeIndex, childNodeCount, provider, providerExpr) {
      var indexCondition;
      if (childNodeCount > 0) {
          indexCondition = literal(nodeIndex)
              .lowerEquals(InjectMethodVars.requestNodeIndex)
              .and(InjectMethodVars.requestNodeIndex.lowerEquals(literal(nodeIndex + childNodeCount)));
      }
      else {
          indexCondition = literal(nodeIndex).identical(InjectMethodVars.requestNodeIndex);
      }
      return new IfStmt(InjectMethodVars.token.identical(createDiTokenExpression(provider.token)).and(indexCondition), [new ReturnStatement(providerExpr)]);
  }
  function createProviderProperty(propName, provider, providerValueExpressions, isMulti, isEager, compileElement) {
      var view = compileElement.view;
      var resolvedProviderValueExpr;
      var type;
      if (isMulti) {
          resolvedProviderValueExpr = literalArr(providerValueExpressions);
          type = new ArrayType(DYNAMIC_TYPE);
      }
      else {
          resolvedProviderValueExpr = providerValueExpressions[0];
          type = providerValueExpressions[0].type;
      }
      if (!type) {
          type = DYNAMIC_TYPE;
      }
      if (isEager) {
          view.fields.push(new ClassField(propName, type));
          view.createMethod.addStmt(THIS_EXPR.prop(propName).set(resolvedProviderValueExpr).toStmt());
      }
      else {
          var internalField = "_" + propName;
          view.fields.push(new ClassField(internalField, type));
          var getter = new CompileMethod(view);
          getter.resetDebugInfo(compileElement.nodeIndex, compileElement.sourceAst);
          // Note: Equals is important for JS so that it also checks the undefined case!
          getter.addStmt(new IfStmt(THIS_EXPR.prop(internalField).isBlank(), [THIS_EXPR.prop(internalField).set(resolvedProviderValueExpr).toStmt()]));
          getter.addStmt(new ReturnStatement(THIS_EXPR.prop(internalField)));
          view.getters.push(new ClassGetter(propName, getter.finish(), type));
      }
      return THIS_EXPR.prop(propName);
  }
  var _QueryWithRead = (function () {
      function _QueryWithRead(query, match) {
          this.query = query;
          this.read = query.meta.read || match;
      }
      return _QueryWithRead;
  }());

  var CompilePipe = (function () {
      function CompilePipe(view, meta) {
          var _this = this;
          this.view = view;
          this.meta = meta;
          this._purePipeProxyCount = 0;
          this.instance = THIS_EXPR.prop("_pipe_" + meta.name + "_" + view.pipeCount++);
          var deps = this.meta.type.diDeps.map(function (diDep) {
              if (diDep.token.reference ===
                  resolveIdentifierToken(Identifiers.ChangeDetectorRef).reference) {
                  return getPropertyInView(THIS_EXPR.prop('ref'), _this.view, _this.view.componentView);
              }
              return injectFromViewParentInjector(diDep.token, false);
          });
          this.view.fields.push(new ClassField(this.instance.name, importType(this.meta.type)));
          this.view.createMethod.resetDebugInfo(null, null);
          this.view.createMethod.addStmt(THIS_EXPR.prop(this.instance.name)
              .set(importExpr(this.meta.type).instantiate(deps))
              .toStmt());
      }
      CompilePipe.call = function (view, name, args) {
          var compView = view.componentView;
          var meta = _findPipeMeta(compView, name);
          var pipe;
          if (meta.pure) {
              // pure pipes live on the component view
              pipe = compView.purePipes.get(name);
              if (!pipe) {
                  pipe = new CompilePipe(compView, meta);
                  compView.purePipes.set(name, pipe);
                  compView.pipes.push(pipe);
              }
          }
          else {
              // Non pure pipes live on the view that called it
              pipe = new CompilePipe(view, meta);
              view.pipes.push(pipe);
          }
          return pipe._call(view, args);
      };
      Object.defineProperty(CompilePipe.prototype, "pure", {
          get: function () { return this.meta.pure; },
          enumerable: true,
          configurable: true
      });
      CompilePipe.prototype._call = function (callingView, args) {
          if (this.meta.pure) {
              // PurePipeProxies live on the view that called them.
              var purePipeProxyInstance = THIS_EXPR.prop(this.instance.name + "_" + this._purePipeProxyCount++);
              var pipeInstanceSeenFromPureProxy = getPropertyInView(this.instance, callingView, this.view);
              createPureProxy(pipeInstanceSeenFromPureProxy.prop('transform')
                  .callMethod(BuiltinMethod.Bind, [pipeInstanceSeenFromPureProxy]), args.length, purePipeProxyInstance, callingView);
              return importExpr(resolveIdentifier(Identifiers.castByValue))
                  .callFn([purePipeProxyInstance, pipeInstanceSeenFromPureProxy.prop('transform')])
                  .callFn(args);
          }
          else {
              return getPropertyInView(this.instance, callingView, this.view).callMethod('transform', args);
          }
      };
      return CompilePipe;
  }());
  function _findPipeMeta(view, name) {
      var pipeMeta = null;
      for (var i = view.pipeMetas.length - 1; i >= 0; i--) {
          var localPipeMeta = view.pipeMetas[i];
          if (localPipeMeta.name == name) {
              pipeMeta = localPipeMeta;
              break;
          }
      }
      if (!pipeMeta) {
          throw new Error("Illegal state: Could not find pipe " + name + " although the parser should have detected this error!");
      }
      return pipeMeta;
  }

  var CompileView = (function () {
      function CompileView(component, genConfig, pipeMetas, styles, animations, viewIndex, declarationElement, templateVariableBindings) {
          var _this = this;
          this.component = component;
          this.genConfig = genConfig;
          this.pipeMetas = pipeMetas;
          this.styles = styles;
          this.animations = animations;
          this.viewIndex = viewIndex;
          this.declarationElement = declarationElement;
          this.templateVariableBindings = templateVariableBindings;
          this.nodes = [];
          // root nodes or AppElements for ViewContainers
          this.rootNodesOrAppElements = [];
          this.bindings = [];
          this.classStatements = [];
          this.eventHandlerMethods = [];
          this.fields = [];
          this.getters = [];
          this.disposables = [];
          this.subscriptions = [];
          this.purePipes = new Map();
          this.pipes = [];
          this.locals = new Map();
          this.literalArrayCount = 0;
          this.literalMapCount = 0;
          this.pipeCount = 0;
          this.createMethod = new CompileMethod(this);
          this.animationBindingsMethod = new CompileMethod(this);
          this.injectorGetMethod = new CompileMethod(this);
          this.updateContentQueriesMethod = new CompileMethod(this);
          this.dirtyParentQueriesMethod = new CompileMethod(this);
          this.updateViewQueriesMethod = new CompileMethod(this);
          this.detectChangesInInputsMethod = new CompileMethod(this);
          this.detectChangesRenderPropertiesMethod = new CompileMethod(this);
          this.afterContentLifecycleCallbacksMethod = new CompileMethod(this);
          this.afterViewLifecycleCallbacksMethod = new CompileMethod(this);
          this.destroyMethod = new CompileMethod(this);
          this.detachMethod = new CompileMethod(this);
          this.viewType = getViewType(component, viewIndex);
          this.className = "_View_" + component.type.name + viewIndex;
          this.classType = importType(new CompileIdentifierMetadata({ name: this.className }));
          this.viewFactory = variable(getViewFactoryName(component, viewIndex));
          if (this.viewType === ViewType.COMPONENT || this.viewType === ViewType.HOST) {
              this.componentView = this;
          }
          else {
              this.componentView = this.declarationElement.view.componentView;
          }
          this.componentContext =
              getPropertyInView(THIS_EXPR.prop('context'), this, this.componentView);
          var viewQueries = new Map();
          if (this.viewType === ViewType.COMPONENT) {
              var directiveInstance = THIS_EXPR.prop('context');
              ListWrapper.forEachWithIndex(this.component.viewQueries, function (queryMeta, queryIndex) {
                  var propName = "_viewQuery_" + queryMeta.selectors[0].name + "_" + queryIndex;
                  var queryList = createQueryList(queryMeta, directiveInstance, propName, _this);
                  var query = new CompileQuery(queryMeta, queryList, directiveInstance, _this);
                  addQueryToTokenMap(viewQueries, query);
              });
              var constructorViewQueryCount = 0;
              this.component.type.diDeps.forEach(function (dep) {
                  if (isPresent(dep.viewQuery)) {
                      var queryList = THIS_EXPR.prop('declarationAppElement')
                          .prop('componentConstructorViewQueries')
                          .key(literal(constructorViewQueryCount++));
                      var query = new CompileQuery(dep.viewQuery, queryList, null, _this);
                      addQueryToTokenMap(viewQueries, query);
                  }
              });
          }
          this.viewQueries = viewQueries;
          templateVariableBindings.forEach(function (entry) { _this.locals.set(entry[1], THIS_EXPR.prop('context').prop(entry[0])); });
          if (!this.declarationElement.isNull()) {
              this.declarationElement.setEmbeddedView(this);
          }
      }
      CompileView.prototype.callPipe = function (name, input, args) {
          return CompilePipe.call(this, name, [input].concat(args));
      };
      CompileView.prototype.getLocal = function (name) {
          if (name == EventHandlerVars.event.name) {
              return EventHandlerVars.event;
          }
          var currView = this;
          var result = currView.locals.get(name);
          while (!result && isPresent(currView.declarationElement.view)) {
              currView = currView.declarationElement.view;
              result = currView.locals.get(name);
          }
          if (isPresent(result)) {
              return getPropertyInView(result, this, currView);
          }
          else {
              return null;
          }
      };
      CompileView.prototype.createLiteralArray = function (values) {
          if (values.length === 0) {
              return importExpr(resolveIdentifier(Identifiers.EMPTY_ARRAY));
          }
          var proxyExpr = THIS_EXPR.prop("_arr_" + this.literalArrayCount++);
          var proxyParams = [];
          var proxyReturnEntries = [];
          for (var i = 0; i < values.length; i++) {
              var paramName = "p" + i;
              proxyParams.push(new FnParam(paramName));
              proxyReturnEntries.push(variable(paramName));
          }
          createPureProxy(fn(proxyParams, [new ReturnStatement(literalArr(proxyReturnEntries))], new ArrayType(DYNAMIC_TYPE)), values.length, proxyExpr, this);
          return proxyExpr.callFn(values);
      };
      CompileView.prototype.createLiteralMap = function (entries) {
          if (entries.length === 0) {
              return importExpr(resolveIdentifier(Identifiers.EMPTY_MAP));
          }
          var proxyExpr = THIS_EXPR.prop("_map_" + this.literalMapCount++);
          var proxyParams = [];
          var proxyReturnEntries = [];
          var values = [];
          for (var i = 0; i < entries.length; i++) {
              var paramName = "p" + i;
              proxyParams.push(new FnParam(paramName));
              proxyReturnEntries.push([entries[i][0], variable(paramName)]);
              values.push(entries[i][1]);
          }
          createPureProxy(fn(proxyParams, [new ReturnStatement(literalMap(proxyReturnEntries))], new MapType(DYNAMIC_TYPE)), entries.length, proxyExpr, this);
          return proxyExpr.callFn(values);
      };
      CompileView.prototype.afterNodes = function () {
          var _this = this;
          MapWrapper.values(this.viewQueries)
              .forEach(function (queries) { return queries.forEach(function (query) { return query.afterChildren(_this.createMethod, _this.updateViewQueriesMethod); }); });
      };
      return CompileView;
  }());
  function getViewType(component, embeddedTemplateIndex) {
      if (embeddedTemplateIndex > 0) {
          return ViewType.EMBEDDED;
      }
      else if (component.type.isHost) {
          return ViewType.HOST;
      }
      else {
          return ViewType.COMPONENT;
      }
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var CompileBinding = (function () {
      function CompileBinding(node, sourceAst) {
          this.node = node;
          this.sourceAst = sourceAst;
      }
      return CompileBinding;
  }());

  var ExpressionWithWrappedValueInfo = (function () {
      function ExpressionWithWrappedValueInfo(expression, needsValueUnwrapper, temporaryCount) {
          this.expression = expression;
          this.needsValueUnwrapper = needsValueUnwrapper;
          this.temporaryCount = temporaryCount;
      }
      return ExpressionWithWrappedValueInfo;
  }());
  function convertCdExpressionToIr(nameResolver, implicitReceiver, expression, valueUnwrapper, bindingIndex) {
      var visitor = new _AstToIrVisitor(nameResolver, implicitReceiver, valueUnwrapper, bindingIndex);
      var irAst = expression.visit(visitor, _Mode.Expression);
      return new ExpressionWithWrappedValueInfo(irAst, visitor.needsValueUnwrapper, visitor.temporaryCount);
  }
  function convertCdStatementToIr(nameResolver, implicitReceiver, stmt, bindingIndex) {
      var visitor = new _AstToIrVisitor(nameResolver, implicitReceiver, null, bindingIndex);
      var statements = [];
      flattenStatements(stmt.visit(visitor, _Mode.Statement), statements);
      prependTemporaryDecls(visitor.temporaryCount, bindingIndex, statements);
      return statements;
  }
  function temporaryName(bindingIndex, temporaryNumber) {
      return "tmp_" + bindingIndex + "_" + temporaryNumber;
  }
  function temporaryDeclaration(bindingIndex, temporaryNumber) {
      return new DeclareVarStmt(temporaryName(bindingIndex, temporaryNumber), NULL_EXPR);
  }
  function prependTemporaryDecls(temporaryCount, bindingIndex, statements) {
      for (var i = temporaryCount - 1; i >= 0; i--) {
          statements.unshift(temporaryDeclaration(bindingIndex, i));
      }
  }
  var _Mode;
  (function (_Mode) {
      _Mode[_Mode["Statement"] = 0] = "Statement";
      _Mode[_Mode["Expression"] = 1] = "Expression";
  })(_Mode || (_Mode = {}));
  function ensureStatementMode(mode, ast) {
      if (mode !== _Mode.Statement) {
          throw new Error("Expected a statement, but saw " + ast);
      }
  }
  function ensureExpressionMode(mode, ast) {
      if (mode !== _Mode.Expression) {
          throw new Error("Expected an expression, but saw " + ast);
      }
  }
  function convertToStatementIfNeeded(mode, expr) {
      if (mode === _Mode.Statement) {
          return expr.toStmt();
      }
      else {
          return expr;
      }
  }
  var _AstToIrVisitor = (function () {
      function _AstToIrVisitor(_nameResolver, _implicitReceiver, _valueUnwrapper, bindingIndex) {
          this._nameResolver = _nameResolver;
          this._implicitReceiver = _implicitReceiver;
          this._valueUnwrapper = _valueUnwrapper;
          this.bindingIndex = bindingIndex;
          this._nodeMap = new Map();
          this._resultMap = new Map();
          this._currentTemporary = 0;
          this.needsValueUnwrapper = false;
          this.temporaryCount = 0;
      }
      _AstToIrVisitor.prototype.visitBinary = function (ast, mode) {
          var op;
          switch (ast.operation) {
              case '+':
                  op = BinaryOperator.Plus;
                  break;
              case '-':
                  op = BinaryOperator.Minus;
                  break;
              case '*':
                  op = BinaryOperator.Multiply;
                  break;
              case '/':
                  op = BinaryOperator.Divide;
                  break;
              case '%':
                  op = BinaryOperator.Modulo;
                  break;
              case '&&':
                  op = BinaryOperator.And;
                  break;
              case '||':
                  op = BinaryOperator.Or;
                  break;
              case '==':
                  op = BinaryOperator.Equals;
                  break;
              case '!=':
                  op = BinaryOperator.NotEquals;
                  break;
              case '===':
                  op = BinaryOperator.Identical;
                  break;
              case '!==':
                  op = BinaryOperator.NotIdentical;
                  break;
              case '<':
                  op = BinaryOperator.Lower;
                  break;
              case '>':
                  op = BinaryOperator.Bigger;
                  break;
              case '<=':
                  op = BinaryOperator.LowerEquals;
                  break;
              case '>=':
                  op = BinaryOperator.BiggerEquals;
                  break;
              default:
                  throw new Error("Unsupported operation " + ast.operation);
          }
          return convertToStatementIfNeeded(mode, new BinaryOperatorExpr(op, this.visit(ast.left, _Mode.Expression), this.visit(ast.right, _Mode.Expression)));
      };
      _AstToIrVisitor.prototype.visitChain = function (ast, mode) {
          ensureStatementMode(mode, ast);
          return this.visitAll(ast.expressions, mode);
      };
      _AstToIrVisitor.prototype.visitConditional = function (ast, mode) {
          var value = this.visit(ast.condition, _Mode.Expression);
          return convertToStatementIfNeeded(mode, value.conditional(this.visit(ast.trueExp, _Mode.Expression), this.visit(ast.falseExp, _Mode.Expression)));
      };
      _AstToIrVisitor.prototype.visitPipe = function (ast, mode) {
          var input = this.visit(ast.exp, _Mode.Expression);
          var args = this.visitAll(ast.args, _Mode.Expression);
          var value = this._nameResolver.callPipe(ast.name, input, args);
          this.needsValueUnwrapper = true;
          return convertToStatementIfNeeded(mode, this._valueUnwrapper.callMethod('unwrap', [value]));
      };
      _AstToIrVisitor.prototype.visitFunctionCall = function (ast, mode) {
          return convertToStatementIfNeeded(mode, this.visit(ast.target, _Mode.Expression).callFn(this.visitAll(ast.args, _Mode.Expression)));
      };
      _AstToIrVisitor.prototype.visitImplicitReceiver = function (ast, mode) {
          ensureExpressionMode(mode, ast);
          return this._implicitReceiver;
      };
      _AstToIrVisitor.prototype.visitInterpolation = function (ast, mode) {
          ensureExpressionMode(mode, ast);
          var args = [literal(ast.expressions.length)];
          for (var i = 0; i < ast.strings.length - 1; i++) {
              args.push(literal(ast.strings[i]));
              args.push(this.visit(ast.expressions[i], _Mode.Expression));
          }
          args.push(literal(ast.strings[ast.strings.length - 1]));
          return importExpr(resolveIdentifier(Identifiers.interpolate)).callFn(args);
      };
      _AstToIrVisitor.prototype.visitKeyedRead = function (ast, mode) {
          return convertToStatementIfNeeded(mode, this.visit(ast.obj, _Mode.Expression).key(this.visit(ast.key, _Mode.Expression)));
      };
      _AstToIrVisitor.prototype.visitKeyedWrite = function (ast, mode) {
          var obj = this.visit(ast.obj, _Mode.Expression);
          var key = this.visit(ast.key, _Mode.Expression);
          var value = this.visit(ast.value, _Mode.Expression);
          return convertToStatementIfNeeded(mode, obj.key(key).set(value));
      };
      _AstToIrVisitor.prototype.visitLiteralArray = function (ast, mode) {
          return convertToStatementIfNeeded(mode, this._nameResolver.createLiteralArray(this.visitAll(ast.expressions, mode)));
      };
      _AstToIrVisitor.prototype.visitLiteralMap = function (ast, mode) {
          var parts = [];
          for (var i = 0; i < ast.keys.length; i++) {
              parts.push([ast.keys[i], this.visit(ast.values[i], _Mode.Expression)]);
          }
          return convertToStatementIfNeeded(mode, this._nameResolver.createLiteralMap(parts));
      };
      _AstToIrVisitor.prototype.visitLiteralPrimitive = function (ast, mode) {
          return convertToStatementIfNeeded(mode, literal(ast.value));
      };
      _AstToIrVisitor.prototype.visitMethodCall = function (ast, mode) {
          var leftMostSafe = this.leftMostSafeNode(ast);
          if (leftMostSafe) {
              return this.convertSafeAccess(ast, leftMostSafe, mode);
          }
          else {
              var args = this.visitAll(ast.args, _Mode.Expression);
              var result = null;
              var receiver = this.visit(ast.receiver, _Mode.Expression);
              if (receiver === this._implicitReceiver) {
                  var varExpr = this._nameResolver.getLocal(ast.name);
                  if (isPresent(varExpr)) {
                      result = varExpr.callFn(args);
                  }
              }
              if (isBlank(result)) {
                  result = receiver.callMethod(ast.name, args);
              }
              return convertToStatementIfNeeded(mode, result);
          }
      };
      _AstToIrVisitor.prototype.visitPrefixNot = function (ast, mode) {
          return convertToStatementIfNeeded(mode, not(this.visit(ast.expression, _Mode.Expression)));
      };
      _AstToIrVisitor.prototype.visitPropertyRead = function (ast, mode) {
          var leftMostSafe = this.leftMostSafeNode(ast);
          if (leftMostSafe) {
              return this.convertSafeAccess(ast, leftMostSafe, mode);
          }
          else {
              var result = null;
              var receiver = this.visit(ast.receiver, _Mode.Expression);
              if (receiver === this._implicitReceiver) {
                  result = this._nameResolver.getLocal(ast.name);
              }
              if (isBlank(result)) {
                  result = receiver.prop(ast.name);
              }
              return convertToStatementIfNeeded(mode, result);
          }
      };
      _AstToIrVisitor.prototype.visitPropertyWrite = function (ast, mode) {
          var receiver = this.visit(ast.receiver, _Mode.Expression);
          if (receiver === this._implicitReceiver) {
              var varExpr = this._nameResolver.getLocal(ast.name);
              if (isPresent(varExpr)) {
                  throw new Error('Cannot assign to a reference or variable!');
              }
          }
          return convertToStatementIfNeeded(mode, receiver.prop(ast.name).set(this.visit(ast.value, _Mode.Expression)));
      };
      _AstToIrVisitor.prototype.visitSafePropertyRead = function (ast, mode) {
          return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);
      };
      _AstToIrVisitor.prototype.visitSafeMethodCall = function (ast, mode) {
          return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);
      };
      _AstToIrVisitor.prototype.visitAll = function (asts, mode) {
          var _this = this;
          return asts.map(function (ast) { return _this.visit(ast, mode); });
      };
      _AstToIrVisitor.prototype.visitQuote = function (ast, mode) {
          throw new Error('Quotes are not supported for evaluation!');
      };
      _AstToIrVisitor.prototype.visit = function (ast, mode) {
          var result = this._resultMap.get(ast);
          if (result)
              return result;
          return (this._nodeMap.get(ast) || ast).visit(this, mode);
      };
      _AstToIrVisitor.prototype.convertSafeAccess = function (ast, leftMostSafe, mode) {
          // If the expression contains a safe access node on the left it needs to be converted to
          // an expression that guards the access to the member by checking the receiver for blank. As
          // execution proceeds from left to right, the left most part of the expression must be guarded
          // first but, because member access is left associative, the right side of the expression is at
          // the top of the AST. The desired result requires lifting a copy of the the left part of the
          // expression up to test it for blank before generating the unguarded version.
          // Consider, for example the following expression: a?.b.c?.d.e
          // This results in the ast:
          //         .
          //        / \
          //       ?.   e
          //      /  \
          //     .    d
          //    / \
          //   ?.  c
          //  /  \
          // a    b
          // The following tree should be generated:
          //
          //        /---- ? ----\
          //       /      |      \
          //     a   /--- ? ---\  null
          //        /     |     \
          //       .      .     null
          //      / \    / \
          //     .  c   .   e
          //    / \    / \
          //   a   b  ,   d
          //         / \
          //        .   c
          //       / \
          //      a   b
          //
          // Notice that the first guard condition is the left hand of the left most safe access node
          // which comes in as leftMostSafe to this routine.
          var guardedExpression = this.visit(leftMostSafe.receiver, _Mode.Expression);
          var temporary;
          if (this.needsTemporary(leftMostSafe.receiver)) {
              // If the expression has method calls or pipes then we need to save the result into a
              // temporary variable to avoid calling stateful or impure code more than once.
              temporary = this.allocateTemporary();
              // Preserve the result in the temporary variable
              guardedExpression = temporary.set(guardedExpression);
              // Ensure all further references to the guarded expression refer to the temporary instead.
              this._resultMap.set(leftMostSafe.receiver, temporary);
          }
          var condition = guardedExpression.isBlank();
          // Convert the ast to an unguarded access to the receiver's member. The map will substitute
          // leftMostNode with its unguarded version in the call to `this.visit()`.
          if (leftMostSafe instanceof SafeMethodCall) {
              this._nodeMap.set(leftMostSafe, new MethodCall(leftMostSafe.span, leftMostSafe.receiver, leftMostSafe.name, leftMostSafe.args));
          }
          else {
              this._nodeMap.set(leftMostSafe, new PropertyRead(leftMostSafe.span, leftMostSafe.receiver, leftMostSafe.name));
          }
          // Recursively convert the node now without the guarded member access.
          var access = this.visit(ast, _Mode.Expression);
          // Remove the mapping. This is not strictly required as the converter only traverses each node
          // once but is safer if the conversion is changed to traverse the nodes more than once.
          this._nodeMap.delete(leftMostSafe);
          // If we allcoated a temporary, release it.
          if (temporary) {
              this.releaseTemporary(temporary);
          }
          // Produce the conditional
          return convertToStatementIfNeeded(mode, condition.conditional(literal(null), access));
      };
      // Given a expression of the form a?.b.c?.d.e the the left most safe node is
      // the (a?.b). The . and ?. are left associative thus can be rewritten as:
      // ((((a?.c).b).c)?.d).e. This returns the most deeply nested safe read or
      // safe method call as this needs be transform initially to:
      //   a == null ? null : a.c.b.c?.d.e
      // then to:
      //   a == null ? null : a.b.c == null ? null : a.b.c.d.e
      _AstToIrVisitor.prototype.leftMostSafeNode = function (ast) {
          var _this = this;
          var visit = function (visitor, ast) {
              return (_this._nodeMap.get(ast) || ast).visit(visitor);
          };
          return ast.visit({
              visitBinary: function (ast) { return null; },
              visitChain: function (ast) { return null; },
              visitConditional: function (ast) { return null; },
              visitFunctionCall: function (ast) { return null; },
              visitImplicitReceiver: function (ast) { return null; },
              visitInterpolation: function (ast) { return null; },
              visitKeyedRead: function (ast) { return visit(this, ast.obj); },
              visitKeyedWrite: function (ast) { return null; },
              visitLiteralArray: function (ast) { return null; },
              visitLiteralMap: function (ast) { return null; },
              visitLiteralPrimitive: function (ast) { return null; },
              visitMethodCall: function (ast) { return visit(this, ast.receiver); },
              visitPipe: function (ast) { return null; },
              visitPrefixNot: function (ast) { return null; },
              visitPropertyRead: function (ast) { return visit(this, ast.receiver); },
              visitPropertyWrite: function (ast) { return null; },
              visitQuote: function (ast) { return null; },
              visitSafeMethodCall: function (ast) { return visit(this, ast.receiver) || ast; },
              visitSafePropertyRead: function (ast) {
                  return visit(this, ast.receiver) || ast;
              }
          });
      };
      // Returns true of the AST includes a method or a pipe indicating that, if the
      // expression is used as the target of a safe property or method access then
      // the expression should be stored into a temporary variable.
      _AstToIrVisitor.prototype.needsTemporary = function (ast) {
          var _this = this;
          var visit = function (visitor, ast) {
              return ast && (_this._nodeMap.get(ast) || ast).visit(visitor);
          };
          var visitSome = function (visitor, ast) {
              return ast.some(function (ast) { return visit(visitor, ast); });
          };
          return ast.visit({
              visitBinary: function (ast) { return visit(this, ast.left) || visit(this, ast.right); },
              visitChain: function (ast) { return false; },
              visitConditional: function (ast) {
                  return visit(this, ast.condition) || visit(this, ast.trueExp) ||
                      visit(this, ast.falseExp);
              },
              visitFunctionCall: function (ast) { return true; },
              visitImplicitReceiver: function (ast) { return false; },
              visitInterpolation: function (ast) { return visitSome(this, ast.expressions); },
              visitKeyedRead: function (ast) { return false; },
              visitKeyedWrite: function (ast) { return false; },
              visitLiteralArray: function (ast) { return true; },
              visitLiteralMap: function (ast) { return true; },
              visitLiteralPrimitive: function (ast) { return false; },
              visitMethodCall: function (ast) { return true; },
              visitPipe: function (ast) { return true; },
              visitPrefixNot: function (ast) { return visit(this, ast.expression); },
              visitPropertyRead: function (ast) { return false; },
              visitPropertyWrite: function (ast) { return false; },
              visitQuote: function (ast) { return false; },
              visitSafeMethodCall: function (ast) { return true; },
              visitSafePropertyRead: function (ast) { return false; }
          });
      };
      _AstToIrVisitor.prototype.allocateTemporary = function () {
          var tempNumber = this._currentTemporary++;
          this.temporaryCount = Math.max(this._currentTemporary, this.temporaryCount);
          return new ReadVarExpr(temporaryName(this.bindingIndex, tempNumber));
      };
      _AstToIrVisitor.prototype.releaseTemporary = function (temporary) {
          this._currentTemporary--;
          if (temporary.name != temporaryName(this.bindingIndex, this._currentTemporary)) {
              throw new Error("Temporary " + temporary.name + " released out of order");
          }
      };
      return _AstToIrVisitor;
  }());
  function flattenStatements(arg, output) {
      if (Array.isArray(arg)) {
          arg.forEach(function (entry) { return flattenStatements(entry, output); });
      }
      else {
          output.push(arg);
      }
  }

  var CompileEventListener = (function () {
      function CompileEventListener(compileElement, eventTarget, eventName, eventPhase, listenerIndex) {
          this.compileElement = compileElement;
          this.eventTarget = eventTarget;
          this.eventName = eventName;
          this.eventPhase = eventPhase;
          this._hasComponentHostListener = false;
          this._actionResultExprs = [];
          this._method = new CompileMethod(compileElement.view);
          this._methodName =
              "_handle_" + sanitizeEventName(eventName) + "_" + compileElement.nodeIndex + "_" + listenerIndex;
          this._eventParam = new FnParam(EventHandlerVars.event.name, importType(this.compileElement.view.genConfig.renderTypes.renderEvent));
      }
      CompileEventListener.getOrCreate = function (compileElement, eventTarget, eventName, eventPhase, targetEventListeners) {
          var listener = targetEventListeners.find(function (listener) { return listener.eventTarget == eventTarget && listener.eventName == eventName &&
              listener.eventPhase == eventPhase; });
          if (!listener) {
              listener = new CompileEventListener(compileElement, eventTarget, eventName, eventPhase, targetEventListeners.length);
              targetEventListeners.push(listener);
          }
          return listener;
      };
      Object.defineProperty(CompileEventListener.prototype, "methodName", {
          get: function () { return this._methodName; },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(CompileEventListener.prototype, "isAnimation", {
          get: function () { return !!this.eventPhase; },
          enumerable: true,
          configurable: true
      });
      CompileEventListener.prototype.addAction = function (hostEvent, directive, directiveInstance) {
          if (isPresent(directive) && directive.isComponent) {
              this._hasComponentHostListener = true;
          }
          this._method.resetDebugInfo(this.compileElement.nodeIndex, hostEvent);
          var context = directiveInstance || this.compileElement.view.componentContext;
          var actionStmts = convertCdStatementToIr(this.compileElement.view, context, hostEvent.handler, this.compileElement.nodeIndex);
          var lastIndex = actionStmts.length - 1;
          if (lastIndex >= 0) {
              var lastStatement = actionStmts[lastIndex];
              var returnExpr = convertStmtIntoExpression(lastStatement);
              var preventDefaultVar = variable("pd_" + this._actionResultExprs.length);
              this._actionResultExprs.push(preventDefaultVar);
              if (isPresent(returnExpr)) {
                  // Note: We need to cast the result of the method call to dynamic,
                  // as it might be a void method!
                  actionStmts[lastIndex] =
                      preventDefaultVar.set(returnExpr.cast(DYNAMIC_TYPE).notIdentical(literal(false)))
                          .toDeclStmt(null, [StmtModifier.Final]);
              }
          }
          this._method.addStmts(actionStmts);
      };
      CompileEventListener.prototype.finishMethod = function () {
          var markPathToRootStart = this._hasComponentHostListener ?
              this.compileElement.appElement.prop('componentView') :
              THIS_EXPR;
          var resultExpr = literal(true);
          this._actionResultExprs.forEach(function (expr) { resultExpr = resultExpr.and(expr); });
          var stmts = [markPathToRootStart.callMethod('markPathToRootAsCheckOnce', []).toStmt()]
              .concat(this._method.finish())
              .concat([new ReturnStatement(resultExpr)]);
          // private is fine here as no child view will reference the event handler...
          this.compileElement.view.eventHandlerMethods.push(new ClassMethod(this._methodName, [this._eventParam], stmts, BOOL_TYPE, [StmtModifier.Private]));
      };
      CompileEventListener.prototype.listenToRenderer = function () {
          var listenExpr;
          var eventListener = THIS_EXPR.callMethod('eventHandler', [THIS_EXPR.prop(this._methodName).callMethod(BuiltinMethod.Bind, [THIS_EXPR])]);
          if (isPresent(this.eventTarget)) {
              listenExpr = ViewProperties.renderer.callMethod('listenGlobal', [literal(this.eventTarget), literal(this.eventName), eventListener]);
          }
          else {
              listenExpr = ViewProperties.renderer.callMethod('listen', [this.compileElement.renderNode, literal(this.eventName), eventListener]);
          }
          var disposable = variable("disposable_" + this.compileElement.view.disposables.length);
          this.compileElement.view.disposables.push(disposable);
          // private is fine here as no child view will reference the event handler...
          this.compileElement.view.createMethod.addStmt(disposable.set(listenExpr).toDeclStmt(FUNCTION_TYPE, [StmtModifier.Private]));
      };
      CompileEventListener.prototype.listenToAnimation = function (animationTransitionVar) {
          var callbackMethod = this.eventPhase == 'start' ? 'onStart' : 'onDone';
          return animationTransitionVar
              .callMethod(callbackMethod, [THIS_EXPR.prop(this.methodName).callMethod(BuiltinMethod.Bind, [THIS_EXPR])])
              .toStmt();
      };
      CompileEventListener.prototype.listenToDirective = function (directiveInstance, observablePropName) {
          var subscription = variable("subscription_" + this.compileElement.view.subscriptions.length);
          this.compileElement.view.subscriptions.push(subscription);
          var eventListener = THIS_EXPR.callMethod('eventHandler', [THIS_EXPR.prop(this._methodName).callMethod(BuiltinMethod.Bind, [THIS_EXPR])]);
          this.compileElement.view.createMethod.addStmt(subscription
              .set(directiveInstance.prop(observablePropName)
              .callMethod(BuiltinMethod.SubscribeObservable, [eventListener]))
              .toDeclStmt(null, [StmtModifier.Final]));
      };
      return CompileEventListener;
  }());
  function collectEventListeners(hostEvents, dirs, compileElement) {
      var eventListeners = [];
      hostEvents.forEach(function (hostEvent) {
          compileElement.view.bindings.push(new CompileBinding(compileElement, hostEvent));
          var listener = CompileEventListener.getOrCreate(compileElement, hostEvent.target, hostEvent.name, hostEvent.phase, eventListeners);
          listener.addAction(hostEvent, null, null);
      });
      dirs.forEach(function (directiveAst) {
          var directiveInstance = compileElement.instances.get(identifierToken(directiveAst.directive.type).reference);
          directiveAst.hostEvents.forEach(function (hostEvent) {
              compileElement.view.bindings.push(new CompileBinding(compileElement, hostEvent));
              var listener = CompileEventListener.getOrCreate(compileElement, hostEvent.target, hostEvent.name, hostEvent.phase, eventListeners);
              listener.addAction(hostEvent, directiveAst.directive, directiveInstance);
          });
      });
      eventListeners.forEach(function (listener) { return listener.finishMethod(); });
      return eventListeners;
  }
  function bindDirectiveOutputs(directiveAst, directiveInstance, eventListeners) {
      Object.keys(directiveAst.directive.outputs).forEach(function (observablePropName) {
          var eventName = directiveAst.directive.outputs[observablePropName];
          eventListeners.filter(function (listener) { return listener.eventName == eventName; }).forEach(function (listener) {
              listener.listenToDirective(directiveInstance, observablePropName);
          });
      });
  }
  function bindRenderOutputs(eventListeners) {
      eventListeners.forEach(function (listener) {
          // the animation listeners are handled within property_binder.ts to
          // allow them to be placed next to the animation factory statements
          if (!listener.isAnimation) {
              listener.listenToRenderer();
          }
      });
  }
  function convertStmtIntoExpression(stmt) {
      if (stmt instanceof ExpressionStatement) {
          return stmt.expr;
      }
      else if (stmt instanceof ReturnStatement) {
          return stmt.value;
      }
      return null;
  }
  function sanitizeEventName(name) {
      return name.replace(/[^a-zA-Z_]/g, '_');
  }

  var STATE_IS_NEVER_CHECKED = THIS_EXPR.prop('numberOfChecks').identical(new LiteralExpr(0));
  var NOT_THROW_ON_CHANGES = not(DetectChangesVars.throwOnChange);
  function bindDirectiveAfterContentLifecycleCallbacks(directiveMeta, directiveInstance, compileElement) {
      var view = compileElement.view;
      var lifecycleHooks = directiveMeta.type.lifecycleHooks;
      var afterContentLifecycleCallbacksMethod = view.afterContentLifecycleCallbacksMethod;
      afterContentLifecycleCallbacksMethod.resetDebugInfo(compileElement.nodeIndex, compileElement.sourceAst);
      if (lifecycleHooks.indexOf(LifecycleHooks.AfterContentInit) !== -1) {
          afterContentLifecycleCallbacksMethod.addStmt(new IfStmt(STATE_IS_NEVER_CHECKED, [directiveInstance.callMethod('ngAfterContentInit', []).toStmt()]));
      }
      if (lifecycleHooks.indexOf(LifecycleHooks.AfterContentChecked) !== -1) {
          afterContentLifecycleCallbacksMethod.addStmt(directiveInstance.callMethod('ngAfterContentChecked', []).toStmt());
      }
  }
  function bindDirectiveAfterViewLifecycleCallbacks(directiveMeta, directiveInstance, compileElement) {
      var view = compileElement.view;
      var lifecycleHooks = directiveMeta.type.lifecycleHooks;
      var afterViewLifecycleCallbacksMethod = view.afterViewLifecycleCallbacksMethod;
      afterViewLifecycleCallbacksMethod.resetDebugInfo(compileElement.nodeIndex, compileElement.sourceAst);
      if (lifecycleHooks.indexOf(LifecycleHooks.AfterViewInit) !== -1) {
          afterViewLifecycleCallbacksMethod.addStmt(new IfStmt(STATE_IS_NEVER_CHECKED, [directiveInstance.callMethod('ngAfterViewInit', []).toStmt()]));
      }
      if (lifecycleHooks.indexOf(LifecycleHooks.AfterViewChecked) !== -1) {
          afterViewLifecycleCallbacksMethod.addStmt(directiveInstance.callMethod('ngAfterViewChecked', []).toStmt());
      }
  }
  function bindInjectableDestroyLifecycleCallbacks(provider, providerInstance, compileElement) {
      var onDestroyMethod = compileElement.view.destroyMethod;
      onDestroyMethod.resetDebugInfo(compileElement.nodeIndex, compileElement.sourceAst);
      if (provider.lifecycleHooks.indexOf(LifecycleHooks.OnDestroy) !== -1) {
          onDestroyMethod.addStmt(providerInstance.callMethod('ngOnDestroy', []).toStmt());
      }
  }
  function bindPipeDestroyLifecycleCallbacks(pipeMeta, pipeInstance, view) {
      var onDestroyMethod = view.destroyMethod;
      if (pipeMeta.type.lifecycleHooks.indexOf(LifecycleHooks.OnDestroy) !== -1) {
          onDestroyMethod.addStmt(pipeInstance.callMethod('ngOnDestroy', []).toStmt());
      }
  }

  function createBindFieldExpr(exprIndex) {
      return THIS_EXPR.prop("_expr_" + exprIndex);
  }
  function createCurrValueExpr(exprIndex) {
      return variable("currVal_" + exprIndex); // fix syntax highlighting: `
  }
  var EvalResult = (function () {
      function EvalResult(forceUpdate) {
          this.forceUpdate = forceUpdate;
      }
      return EvalResult;
  }());
  function evalCdAst(view, currValExpr, parsedExpression, context, method, bindingIndex) {
      var checkExpression = convertCdExpressionToIr(view, context, parsedExpression, DetectChangesVars.valUnwrapper, bindingIndex);
      if (!checkExpression.expression) {
          // e.g. an empty expression was given
          return null;
      }
      if (checkExpression.temporaryCount) {
          for (var i = 0; i < checkExpression.temporaryCount; i++) {
              method.addStmt(temporaryDeclaration(bindingIndex, i));
          }
      }
      if (checkExpression.needsValueUnwrapper) {
          var initValueUnwrapperStmt = DetectChangesVars.valUnwrapper.callMethod('reset', []).toStmt();
          method.addStmt(initValueUnwrapperStmt);
      }
      method.addStmt(currValExpr.set(checkExpression.expression).toDeclStmt(null, [StmtModifier.Final]));
      if (checkExpression.needsValueUnwrapper) {
          return new EvalResult(DetectChangesVars.valUnwrapper.prop('hasWrappedValue'));
      }
      else {
          return new EvalResult(null);
      }
  }
  function bind(view, currValExpr, fieldExpr, parsedExpression, context, actions, method, bindingIndex) {
      var evalResult = evalCdAst(view, currValExpr, parsedExpression, context, method, bindingIndex);
      if (!evalResult) {
          return;
      }
      // private is fine here as no child view will reference the cached value...
      view.fields.push(new ClassField(fieldExpr.name, null, [StmtModifier.Private]));
      view.createMethod.addStmt(THIS_EXPR.prop(fieldExpr.name)
          .set(importExpr(resolveIdentifier(Identifiers.UNINITIALIZED)))
          .toStmt());
      var condition = importExpr(resolveIdentifier(Identifiers.checkBinding)).callFn([
          DetectChangesVars.throwOnChange, fieldExpr, currValExpr
      ]);
      if (evalResult.forceUpdate) {
          condition = evalResult.forceUpdate.or(condition);
      }
      method.addStmt(new IfStmt(condition, actions.concat([THIS_EXPR.prop(fieldExpr.name).set(currValExpr).toStmt()])));
  }
  function bindRenderText(boundText, compileNode, view) {
      var bindingIndex = view.bindings.length;
      view.bindings.push(new CompileBinding(compileNode, boundText));
      var currValExpr = createCurrValueExpr(bindingIndex);
      var valueField = createBindFieldExpr(bindingIndex);
      view.detectChangesRenderPropertiesMethod.resetDebugInfo(compileNode.nodeIndex, boundText);
      bind(view, currValExpr, valueField, boundText.value, view.componentContext, [THIS_EXPR.prop('renderer')
              .callMethod('setText', [compileNode.renderNode, currValExpr])
              .toStmt()], view.detectChangesRenderPropertiesMethod, bindingIndex);
  }
  function bindAndWriteToRenderer(boundProps, context, compileElement, isHostProp, eventListeners) {
      var view = compileElement.view;
      var renderNode = compileElement.renderNode;
      boundProps.forEach(function (boundProp) {
          var bindingIndex = view.bindings.length;
          view.bindings.push(new CompileBinding(compileElement, boundProp));
          view.detectChangesRenderPropertiesMethod.resetDebugInfo(compileElement.nodeIndex, boundProp);
          var fieldExpr = createBindFieldExpr(bindingIndex);
          var currValExpr = createCurrValueExpr(bindingIndex);
          var oldRenderValue = sanitizedValue(boundProp, fieldExpr);
          var renderValue = sanitizedValue(boundProp, currValExpr);
          var updateStmts = [];
          var compileMethod = view.detectChangesRenderPropertiesMethod;
          switch (boundProp.type) {
              case exports.PropertyBindingType.Property:
                  if (view.genConfig.logBindingUpdate) {
                      updateStmts.push(logBindingUpdateStmt(renderNode, boundProp.name, renderValue));
                  }
                  updateStmts.push(THIS_EXPR.prop('renderer')
                      .callMethod('setElementProperty', [renderNode, literal(boundProp.name), renderValue])
                      .toStmt());
                  break;
              case exports.PropertyBindingType.Attribute:
                  renderValue =
                      renderValue.isBlank().conditional(NULL_EXPR, renderValue.callMethod('toString', []));
                  updateStmts.push(THIS_EXPR.prop('renderer')
                      .callMethod('setElementAttribute', [renderNode, literal(boundProp.name), renderValue])
                      .toStmt());
                  break;
              case exports.PropertyBindingType.Class:
                  updateStmts.push(THIS_EXPR.prop('renderer')
                      .callMethod('setElementClass', [renderNode, literal(boundProp.name), renderValue])
                      .toStmt());
                  break;
              case exports.PropertyBindingType.Style:
                  var strValue = renderValue.callMethod('toString', []);
                  if (isPresent(boundProp.unit)) {
                      strValue = strValue.plus(literal(boundProp.unit));
                  }
                  renderValue = renderValue.isBlank().conditional(NULL_EXPR, strValue);
                  updateStmts.push(THIS_EXPR.prop('renderer')
                      .callMethod('setElementStyle', [renderNode, literal(boundProp.name), renderValue])
                      .toStmt());
                  break;
              case exports.PropertyBindingType.Animation:
                  compileMethod = view.animationBindingsMethod;
                  var detachStmts_1 = [];
                  var animationName_1 = boundProp.name;
                  var targetViewExpr = isHostProp ? compileElement.appElement.prop('componentView') : THIS_EXPR;
                  var animationFnExpr = targetViewExpr.prop('componentType').prop('animations').key(literal(animationName_1));
                  // it's important to normalize the void value as `void` explicitly
                  // so that the styles data can be obtained from the stringmap
                  var emptyStateValue = literal(EMPTY_ANIMATION_STATE);
                  var unitializedValue = importExpr(resolveIdentifier(Identifiers.UNINITIALIZED));
                  var animationTransitionVar_1 = variable('animationTransition_' + animationName_1);
                  updateStmts.push(animationTransitionVar_1
                      .set(animationFnExpr.callFn([
                      THIS_EXPR, renderNode, oldRenderValue.equals(unitializedValue)
                          .conditional(emptyStateValue, oldRenderValue),
                      renderValue.equals(unitializedValue).conditional(emptyStateValue, renderValue)
                  ]))
                      .toDeclStmt());
                  detachStmts_1.push(animationTransitionVar_1
                      .set(animationFnExpr.callFn([THIS_EXPR, renderNode, oldRenderValue, emptyStateValue]))
                      .toDeclStmt());
                  eventListeners.forEach(function (listener) {
                      if (listener.isAnimation && listener.eventName === animationName_1) {
                          var animationStmt = listener.listenToAnimation(animationTransitionVar_1);
                          updateStmts.push(animationStmt);
                          detachStmts_1.push(animationStmt);
                      }
                  });
                  view.detachMethod.addStmts(detachStmts_1);
                  break;
          }
          bind(view, currValExpr, fieldExpr, boundProp.value, context, updateStmts, compileMethod, view.bindings.length);
      });
  }
  function sanitizedValue(boundProp, renderValue) {
      var enumValue;
      switch (boundProp.securityContext) {
          case _angular_core.SecurityContext.NONE:
              return renderValue; // No sanitization needed.
          case _angular_core.SecurityContext.HTML:
              enumValue = 'HTML';
              break;
          case _angular_core.SecurityContext.STYLE:
              enumValue = 'STYLE';
              break;
          case _angular_core.SecurityContext.SCRIPT:
              enumValue = 'SCRIPT';
              break;
          case _angular_core.SecurityContext.URL:
              enumValue = 'URL';
              break;
          case _angular_core.SecurityContext.RESOURCE_URL:
              enumValue = 'RESOURCE_URL';
              break;
          default:
              throw new Error("internal error, unexpected SecurityContext " + boundProp.securityContext + ".");
      }
      var ctx = ViewProperties.viewUtils.prop('sanitizer');
      var args = [importExpr(resolveIdentifier(Identifiers.SecurityContext)).prop(enumValue), renderValue];
      return ctx.callMethod('sanitize', args);
  }
  function bindRenderInputs(boundProps, compileElement, eventListeners) {
      bindAndWriteToRenderer(boundProps, compileElement.view.componentContext, compileElement, false, eventListeners);
  }
  function bindDirectiveHostProps(directiveAst, directiveInstance, compileElement, eventListeners) {
      bindAndWriteToRenderer(directiveAst.hostProperties, directiveInstance, compileElement, true, eventListeners);
  }
  function bindDirectiveInputs(directiveAst, directiveWrapperInstance, compileElement) {
      var view = compileElement.view;
      var detectChangesInInputsMethod = view.detectChangesInInputsMethod;
      detectChangesInInputsMethod.resetDebugInfo(compileElement.nodeIndex, compileElement.sourceAst);
      directiveAst.inputs.forEach(function (input) {
          var bindingIndex = view.bindings.length;
          view.bindings.push(new CompileBinding(compileElement, input));
          detectChangesInInputsMethod.resetDebugInfo(compileElement.nodeIndex, input);
          var currValExpr = createCurrValueExpr(bindingIndex);
          var evalResult = evalCdAst(view, currValExpr, input.value, view.componentContext, detectChangesInInputsMethod, bindingIndex);
          if (!evalResult) {
              return;
          }
          detectChangesInInputsMethod.addStmt(directiveWrapperInstance
              .callMethod("check_" + input.directiveName, [
              currValExpr, DetectChangesVars.throwOnChange,
              evalResult.forceUpdate || literal(false)
          ])
              .toStmt());
      });
      var isOnPushComp = directiveAst.directive.isComponent &&
          !isDefaultChangeDetectionStrategy(directiveAst.directive.changeDetection);
      var directiveDetectChangesExpr = directiveWrapperInstance.callMethod('detectChangesInternal', [THIS_EXPR, compileElement.renderNode, DetectChangesVars.throwOnChange]);
      var directiveDetectChangesStmt = isOnPushComp ?
          new IfStmt(directiveDetectChangesExpr, [compileElement.appElement.prop('componentView')
                  .callMethod('markAsCheckOnce', [])
                  .toStmt()]) :
          directiveDetectChangesExpr.toStmt();
      detectChangesInInputsMethod.addStmt(directiveDetectChangesStmt);
  }
  function logBindingUpdateStmt(renderNode, propName, value) {
      return importExpr(resolveIdentifier(Identifiers.setBindingDebugInfo))
          .callFn([THIS_EXPR.prop('renderer'), renderNode, literal(propName), value])
          .toStmt();
  }

  function bindView(view, parsedTemplate) {
      var visitor = new ViewBinderVisitor(view);
      templateVisitAll(visitor, parsedTemplate);
      view.pipes.forEach(function (pipe) { bindPipeDestroyLifecycleCallbacks(pipe.meta, pipe.instance, pipe.view); });
  }
  var ViewBinderVisitor = (function () {
      function ViewBinderVisitor(view) {
          this.view = view;
          this._nodeIndex = 0;
      }
      ViewBinderVisitor.prototype.visitBoundText = function (ast, parent) {
          var node = this.view.nodes[this._nodeIndex++];
          bindRenderText(ast, node, this.view);
          return null;
      };
      ViewBinderVisitor.prototype.visitText = function (ast, parent) {
          this._nodeIndex++;
          return null;
      };
      ViewBinderVisitor.prototype.visitNgContent = function (ast, parent) { return null; };
      ViewBinderVisitor.prototype.visitElement = function (ast, parent) {
          var compileElement = this.view.nodes[this._nodeIndex++];
          var eventListeners = [];
          collectEventListeners(ast.outputs, ast.directives, compileElement).forEach(function (entry) {
              eventListeners.push(entry);
          });
          bindRenderInputs(ast.inputs, compileElement, eventListeners);
          bindRenderOutputs(eventListeners);
          ast.directives.forEach(function (directiveAst) {
              var directiveInstance = compileElement.instances.get(directiveAst.directive.type.reference);
              var directiveWrapperInstance = compileElement.directiveWrapperInstance.get(directiveAst.directive.type.reference);
              bindDirectiveInputs(directiveAst, directiveWrapperInstance, compileElement);
              bindDirectiveHostProps(directiveAst, directiveInstance, compileElement, eventListeners);
              bindDirectiveOutputs(directiveAst, directiveInstance, eventListeners);
          });
          templateVisitAll(this, ast.children, compileElement);
          // afterContent and afterView lifecycles need to be called bottom up
          // so that children are notified before parents
          ast.directives.forEach(function (directiveAst) {
              var directiveInstance = compileElement.instances.get(directiveAst.directive.type.reference);
              bindDirectiveAfterContentLifecycleCallbacks(directiveAst.directive, directiveInstance, compileElement);
              bindDirectiveAfterViewLifecycleCallbacks(directiveAst.directive, directiveInstance, compileElement);
          });
          ast.providers.forEach(function (providerAst) {
              var providerInstance = compileElement.instances.get(providerAst.token.reference);
              bindInjectableDestroyLifecycleCallbacks(providerAst, providerInstance, compileElement);
          });
          return null;
      };
      ViewBinderVisitor.prototype.visitEmbeddedTemplate = function (ast, parent) {
          var compileElement = this.view.nodes[this._nodeIndex++];
          var eventListeners = collectEventListeners(ast.outputs, ast.directives, compileElement);
          ast.directives.forEach(function (directiveAst) {
              var directiveInstance = compileElement.instances.get(directiveAst.directive.type.reference);
              var directiveWrapperInstance = compileElement.directiveWrapperInstance.get(directiveAst.directive.type.reference);
              bindDirectiveInputs(directiveAst, directiveWrapperInstance, compileElement);
              bindDirectiveOutputs(directiveAst, directiveInstance, eventListeners);
              bindDirectiveAfterContentLifecycleCallbacks(directiveAst.directive, directiveInstance, compileElement);
              bindDirectiveAfterViewLifecycleCallbacks(directiveAst.directive, directiveInstance, compileElement);
          });
          ast.providers.forEach(function (providerAst) {
              var providerInstance = compileElement.instances.get(providerAst.token.reference);
              bindInjectableDestroyLifecycleCallbacks(providerAst, providerInstance, compileElement);
          });
          bindView(compileElement.embeddedView, ast.children);
          return null;
      };
      ViewBinderVisitor.prototype.visitAttr = function (ast, ctx) { return null; };
      ViewBinderVisitor.prototype.visitDirective = function (ast, ctx) { return null; };
      ViewBinderVisitor.prototype.visitEvent = function (ast, eventTargetAndNames) {
          return null;
      };
      ViewBinderVisitor.prototype.visitReference = function (ast, ctx) { return null; };
      ViewBinderVisitor.prototype.visitVariable = function (ast, ctx) { return null; };
      ViewBinderVisitor.prototype.visitDirectiveProperty = function (ast, context) { return null; };
      ViewBinderVisitor.prototype.visitElementProperty = function (ast, context) { return null; };
      return ViewBinderVisitor;
  }());

  var IMPLICIT_TEMPLATE_VAR = '\$implicit';
  var CLASS_ATTR$1 = 'class';
  var STYLE_ATTR = 'style';
  var NG_CONTAINER_TAG = 'ng-container';
  var parentRenderNodeVar = variable('parentRenderNode');
  var rootSelectorVar = variable('rootSelector');
  function buildView(view, template, targetDependencies) {
      var builderVisitor = new ViewBuilderVisitor(view, targetDependencies);
      templateVisitAll(builderVisitor, template, view.declarationElement.isNull() ? view.declarationElement : view.declarationElement.parent);
      return builderVisitor.nestedViewCount;
  }
  function finishView(view, targetStatements) {
      view.afterNodes();
      createViewTopLevelStmts(view, targetStatements);
      view.nodes.forEach(function (node) {
          if (node instanceof CompileElement && node.hasEmbeddedView) {
              finishView(node.embeddedView, targetStatements);
          }
      });
  }
  var ViewBuilderVisitor = (function () {
      function ViewBuilderVisitor(view, targetDependencies) {
          this.view = view;
          this.targetDependencies = targetDependencies;
          this.nestedViewCount = 0;
      }
      ViewBuilderVisitor.prototype._isRootNode = function (parent) { return parent.view !== this.view; };
      ViewBuilderVisitor.prototype._addRootNodeAndProject = function (node) {
          var projectedNode = _getOuterContainerOrSelf(node);
          var parent = projectedNode.parent;
          var ngContentIndex = projectedNode.sourceAst.ngContentIndex;
          var vcAppEl = (node instanceof CompileElement && node.hasViewContainer) ? node.appElement : null;
          if (this._isRootNode(parent)) {
              // store appElement as root node only for ViewContainers
              if (this.view.viewType !== ViewType.COMPONENT) {
                  this.view.rootNodesOrAppElements.push(vcAppEl || node.renderNode);
              }
          }
          else if (isPresent(parent.component) && isPresent(ngContentIndex)) {
              parent.addContentNode(ngContentIndex, vcAppEl || node.renderNode);
          }
      };
      ViewBuilderVisitor.prototype._getParentRenderNode = function (parent) {
          parent = _getOuterContainerParentOrSelf(parent);
          if (this._isRootNode(parent)) {
              if (this.view.viewType === ViewType.COMPONENT) {
                  return parentRenderNodeVar;
              }
              else {
                  // root node of an embedded/host view
                  return NULL_EXPR;
              }
          }
          else {
              return isPresent(parent.component) &&
                  parent.component.template.encapsulation !== _angular_core.ViewEncapsulation.Native ?
                  NULL_EXPR :
                  parent.renderNode;
          }
      };
      ViewBuilderVisitor.prototype.visitBoundText = function (ast, parent) {
          return this._visitText(ast, '', parent);
      };
      ViewBuilderVisitor.prototype.visitText = function (ast, parent) {
          return this._visitText(ast, ast.value, parent);
      };
      ViewBuilderVisitor.prototype._visitText = function (ast, value, parent) {
          var fieldName = "_text_" + this.view.nodes.length;
          this.view.fields.push(new ClassField(fieldName, importType(this.view.genConfig.renderTypes.renderText)));
          var renderNode = THIS_EXPR.prop(fieldName);
          var compileNode = new CompileNode(parent, this.view, this.view.nodes.length, renderNode, ast);
          var createRenderNode = THIS_EXPR.prop(fieldName)
              .set(ViewProperties.renderer.callMethod('createText', [
              this._getParentRenderNode(parent), literal(value),
              this.view.createMethod.resetDebugInfoExpr(this.view.nodes.length, ast)
          ]))
              .toStmt();
          this.view.nodes.push(compileNode);
          this.view.createMethod.addStmt(createRenderNode);
          this._addRootNodeAndProject(compileNode);
          return renderNode;
      };
      ViewBuilderVisitor.prototype.visitNgContent = function (ast, parent) {
          // the projected nodes originate from a different view, so we don't
          // have debug information for them...
          this.view.createMethod.resetDebugInfo(null, ast);
          var parentRenderNode = this._getParentRenderNode(parent);
          var nodesExpression = ViewProperties.projectableNodes.key(literal(ast.index), new ArrayType(importType(this.view.genConfig.renderTypes.renderNode)));
          if (parentRenderNode !== NULL_EXPR) {
              this.view.createMethod.addStmt(ViewProperties.renderer
                  .callMethod('projectNodes', [
                  parentRenderNode,
                  importExpr(resolveIdentifier(Identifiers.flattenNestedViewRenderNodes))
                      .callFn([nodesExpression])
              ])
                  .toStmt());
          }
          else if (this._isRootNode(parent)) {
              if (this.view.viewType !== ViewType.COMPONENT) {
                  // store root nodes only for embedded/host views
                  this.view.rootNodesOrAppElements.push(nodesExpression);
              }
          }
          else {
              if (isPresent(parent.component) && isPresent(ast.ngContentIndex)) {
                  parent.addContentNode(ast.ngContentIndex, nodesExpression);
              }
          }
          return null;
      };
      ViewBuilderVisitor.prototype.visitElement = function (ast, parent) {
          var nodeIndex = this.view.nodes.length;
          var createRenderNodeExpr;
          var debugContextExpr = this.view.createMethod.resetDebugInfoExpr(nodeIndex, ast);
          if (nodeIndex === 0 && this.view.viewType === ViewType.HOST) {
              createRenderNodeExpr = THIS_EXPR.callMethod('selectOrCreateHostElement', [literal(ast.name), rootSelectorVar, debugContextExpr]);
          }
          else {
              if (ast.name === NG_CONTAINER_TAG) {
                  createRenderNodeExpr = ViewProperties.renderer.callMethod('createTemplateAnchor', [this._getParentRenderNode(parent), debugContextExpr]);
              }
              else {
                  createRenderNodeExpr = ViewProperties.renderer.callMethod('createElement', [this._getParentRenderNode(parent), literal(ast.name), debugContextExpr]);
              }
          }
          var fieldName = "_el_" + nodeIndex;
          this.view.fields.push(new ClassField(fieldName, importType(this.view.genConfig.renderTypes.renderElement)));
          this.view.createMethod.addStmt(THIS_EXPR.prop(fieldName).set(createRenderNodeExpr).toStmt());
          var renderNode = THIS_EXPR.prop(fieldName);
          var directives = ast.directives.map(function (directiveAst) { return directiveAst.directive; });
          var component = directives.find(function (directive) { return directive.isComponent; });
          var htmlAttrs = _readHtmlAttrs(ast.attrs);
          var attrNameAndValues = _mergeHtmlAndDirectiveAttrs(htmlAttrs, directives);
          for (var i = 0; i < attrNameAndValues.length; i++) {
              var attrName = attrNameAndValues[i][0];
              if (ast.name !== NG_CONTAINER_TAG) {
                  // <ng-container> are not rendered in the DOM
                  var attrValue = attrNameAndValues[i][1];
                  this.view.createMethod.addStmt(ViewProperties.renderer
                      .callMethod('setElementAttribute', [renderNode, literal(attrName), literal(attrValue)])
                      .toStmt());
              }
          }
          var compileElement = new CompileElement(parent, this.view, nodeIndex, renderNode, ast, component, directives, ast.providers, ast.hasViewContainer, false, ast.references, this.targetDependencies);
          this.view.nodes.push(compileElement);
          var compViewExpr = null;
          if (isPresent(component)) {
              var nestedComponentIdentifier = new CompileIdentifierMetadata({ name: getViewFactoryName(component, 0) });
              this.targetDependencies.push(new ViewFactoryDependency(component.type, nestedComponentIdentifier));
              compViewExpr = variable("compView_" + nodeIndex); // fix highlighting: `
              compileElement.setComponentView(compViewExpr);
              this.view.createMethod.addStmt(compViewExpr
                  .set(importExpr(nestedComponentIdentifier).callFn([
                  ViewProperties.viewUtils, compileElement.injector, compileElement.appElement
              ]))
                  .toDeclStmt());
          }
          compileElement.beforeChildren();
          this._addRootNodeAndProject(compileElement);
          templateVisitAll(this, ast.children, compileElement);
          compileElement.afterChildren(this.view.nodes.length - nodeIndex - 1);
          if (isPresent(compViewExpr)) {
              var codeGenContentNodes;
              if (this.view.component.type.isHost) {
                  codeGenContentNodes = ViewProperties.projectableNodes;
              }
              else {
                  codeGenContentNodes = literalArr(compileElement.contentNodesByNgContentIndex.map(function (nodes) { return createFlatArray(nodes); }));
              }
              this.view.createMethod.addStmt(compViewExpr
                  .callMethod('create', [compileElement.getComponent(), codeGenContentNodes, NULL_EXPR])
                  .toStmt());
          }
          return null;
      };
      ViewBuilderVisitor.prototype.visitEmbeddedTemplate = function (ast, parent) {
          var nodeIndex = this.view.nodes.length;
          var fieldName = "_anchor_" + nodeIndex;
          this.view.fields.push(new ClassField(fieldName, importType(this.view.genConfig.renderTypes.renderComment)));
          this.view.createMethod.addStmt(THIS_EXPR.prop(fieldName)
              .set(ViewProperties.renderer.callMethod('createTemplateAnchor', [
              this._getParentRenderNode(parent),
              this.view.createMethod.resetDebugInfoExpr(nodeIndex, ast)
          ]))
              .toStmt());
          var renderNode = THIS_EXPR.prop(fieldName);
          var templateVariableBindings = ast.variables.map(function (varAst) { return [varAst.value.length > 0 ? varAst.value : IMPLICIT_TEMPLATE_VAR, varAst.name]; });
          var directives = ast.directives.map(function (directiveAst) { return directiveAst.directive; });
          var compileElement = new CompileElement(parent, this.view, nodeIndex, renderNode, ast, null, directives, ast.providers, ast.hasViewContainer, true, ast.references, this.targetDependencies);
          this.view.nodes.push(compileElement);
          this.nestedViewCount++;
          var embeddedView = new CompileView(this.view.component, this.view.genConfig, this.view.pipeMetas, NULL_EXPR, this.view.animations, this.view.viewIndex + this.nestedViewCount, compileElement, templateVariableBindings);
          this.nestedViewCount += buildView(embeddedView, ast.children, this.targetDependencies);
          compileElement.beforeChildren();
          this._addRootNodeAndProject(compileElement);
          compileElement.afterChildren(0);
          return null;
      };
      ViewBuilderVisitor.prototype.visitAttr = function (ast, ctx) { return null; };
      ViewBuilderVisitor.prototype.visitDirective = function (ast, ctx) { return null; };
      ViewBuilderVisitor.prototype.visitEvent = function (ast, eventTargetAndNames) {
          return null;
      };
      ViewBuilderVisitor.prototype.visitReference = function (ast, ctx) { return null; };
      ViewBuilderVisitor.prototype.visitVariable = function (ast, ctx) { return null; };
      ViewBuilderVisitor.prototype.visitDirectiveProperty = function (ast, context) { return null; };
      ViewBuilderVisitor.prototype.visitElementProperty = function (ast, context) { return null; };
      return ViewBuilderVisitor;
  }());
  /**
   * Walks up the nodes while the direct parent is a container.
   *
   * Returns the outer container or the node itself when it is not a direct child of a container.
   *
   * @internal
   */
  function _getOuterContainerOrSelf(node) {
      var view = node.view;
      while (_isNgContainer(node.parent, view)) {
          node = node.parent;
      }
      return node;
  }
  /**
   * Walks up the nodes while they are container and returns the first parent which is not.
   *
   * Returns the parent of the outer container or the node itself when it is not a container.
   *
   * @internal
   */
  function _getOuterContainerParentOrSelf(el) {
      var view = el.view;
      while (_isNgContainer(el, view)) {
          el = el.parent;
      }
      return el;
  }
  function _isNgContainer(node, view) {
      return !node.isNull() && node.sourceAst.name === NG_CONTAINER_TAG &&
          node.view === view;
  }
  function _mergeHtmlAndDirectiveAttrs(declaredHtmlAttrs, directives) {
      var result = {};
      Object.keys(declaredHtmlAttrs).forEach(function (key) { result[key] = declaredHtmlAttrs[key]; });
      directives.forEach(function (directiveMeta) {
          Object.keys(directiveMeta.hostAttributes).forEach(function (name) {
              var value = directiveMeta.hostAttributes[name];
              var prevValue = result[name];
              result[name] = isPresent(prevValue) ? mergeAttributeValue(name, prevValue, value) : value;
          });
      });
      return mapToKeyValueArray(result);
  }
  function _readHtmlAttrs(attrs) {
      var htmlAttrs = {};
      attrs.forEach(function (ast) { htmlAttrs[ast.name] = ast.value; });
      return htmlAttrs;
  }
  function mergeAttributeValue(attrName, attrValue1, attrValue2) {
      if (attrName == CLASS_ATTR$1 || attrName == STYLE_ATTR) {
          return attrValue1 + " " + attrValue2;
      }
      else {
          return attrValue2;
      }
  }
  function mapToKeyValueArray(data) {
      var entryArray = [];
      Object.keys(data).forEach(function (name) { entryArray.push([name, data[name]]); });
      // We need to sort to get a defined output order
      // for tests and for caching generated artifacts...
      ListWrapper.sort(entryArray);
      return entryArray;
  }
  function createViewTopLevelStmts(view, targetStatements) {
      var nodeDebugInfosVar = NULL_EXPR;
      if (view.genConfig.genDebugInfo) {
          nodeDebugInfosVar = variable("nodeDebugInfos_" + view.component.type.name + view.viewIndex); // fix highlighting: `
          targetStatements.push(nodeDebugInfosVar
              .set(literalArr(view.nodes.map(createStaticNodeDebugInfo), new ArrayType(new ExternalType(resolveIdentifier(Identifiers.StaticNodeDebugInfo)), [TypeModifier.Const])))
              .toDeclStmt(null, [StmtModifier.Final]));
      }
      var renderCompTypeVar = variable("renderType_" + view.component.type.name); // fix highlighting: `
      if (view.viewIndex === 0) {
          targetStatements.push(renderCompTypeVar.set(NULL_EXPR)
              .toDeclStmt(importType(resolveIdentifier(Identifiers.RenderComponentType))));
      }
      var viewClass = createViewClass(view, renderCompTypeVar, nodeDebugInfosVar);
      targetStatements.push(viewClass);
      targetStatements.push(createViewFactory(view, viewClass, renderCompTypeVar));
  }
  function createStaticNodeDebugInfo(node) {
      var compileElement = node instanceof CompileElement ? node : null;
      var providerTokens = [];
      var componentToken = NULL_EXPR;
      var varTokenEntries = [];
      if (isPresent(compileElement)) {
          providerTokens = compileElement.getProviderTokens();
          if (isPresent(compileElement.component)) {
              componentToken = createDiTokenExpression(identifierToken(compileElement.component.type));
          }
          Object.keys(compileElement.referenceTokens).forEach(function (varName) {
              var token = compileElement.referenceTokens[varName];
              varTokenEntries.push([varName, isPresent(token) ? createDiTokenExpression(token) : NULL_EXPR]);
          });
      }
      return importExpr(resolveIdentifier(Identifiers.StaticNodeDebugInfo))
          .instantiate([
          literalArr(providerTokens, new ArrayType(DYNAMIC_TYPE, [TypeModifier.Const])),
          componentToken,
          literalMap(varTokenEntries, new MapType(DYNAMIC_TYPE, [TypeModifier.Const]))
      ], importType(resolveIdentifier(Identifiers.StaticNodeDebugInfo), null, [TypeModifier.Const]));
  }
  function createViewClass(view, renderCompTypeVar, nodeDebugInfosVar) {
      var viewConstructorArgs = [
          new FnParam(ViewConstructorVars.viewUtils.name, importType(resolveIdentifier(Identifiers.ViewUtils))),
          new FnParam(ViewConstructorVars.parentInjector.name, importType(resolveIdentifier(Identifiers.Injector))),
          new FnParam(ViewConstructorVars.declarationEl.name, importType(resolveIdentifier(Identifiers.AppElement)))
      ];
      var superConstructorArgs = [
          variable(view.className), renderCompTypeVar, ViewTypeEnum.fromValue(view.viewType),
          ViewConstructorVars.viewUtils, ViewConstructorVars.parentInjector,
          ViewConstructorVars.declarationEl,
          ChangeDetectorStatusEnum.fromValue(getChangeDetectionMode(view))
      ];
      if (view.genConfig.genDebugInfo) {
          superConstructorArgs.push(nodeDebugInfosVar);
      }
      var viewConstructor = new ClassMethod(null, viewConstructorArgs, [SUPER_EXPR.callFn(superConstructorArgs).toStmt()]);
      var viewMethods = [
          new ClassMethod('createInternal', [new FnParam(rootSelectorVar.name, STRING_TYPE)], generateCreateMethod(view), importType(resolveIdentifier(Identifiers.AppElement))),
          new ClassMethod('injectorGetInternal', [
              new FnParam(InjectMethodVars.token.name, DYNAMIC_TYPE),
              // Note: Can't use o.INT_TYPE here as the method in AppView uses number
              new FnParam(InjectMethodVars.requestNodeIndex.name, NUMBER_TYPE),
              new FnParam(InjectMethodVars.notFoundResult.name, DYNAMIC_TYPE)
          ], addReturnValuefNotEmpty(view.injectorGetMethod.finish(), InjectMethodVars.notFoundResult), DYNAMIC_TYPE),
          new ClassMethod('detectChangesInternal', [new FnParam(DetectChangesVars.throwOnChange.name, BOOL_TYPE)], generateDetectChangesMethod(view)),
          new ClassMethod('dirtyParentQueriesInternal', [], view.dirtyParentQueriesMethod.finish()),
          new ClassMethod('destroyInternal', [], view.destroyMethod.finish()),
          new ClassMethod('detachInternal', [], view.detachMethod.finish())
      ].concat(view.eventHandlerMethods);
      var superClass = view.genConfig.genDebugInfo ? Identifiers.DebugAppView : Identifiers.AppView;
      var viewClass = new ClassStmt(view.className, importExpr(resolveIdentifier(superClass), [getContextType(view)]), view.fields, view.getters, viewConstructor, viewMethods.filter(function (method) { return method.body.length > 0; }));
      return viewClass;
  }
  function createViewFactory(view, viewClass, renderCompTypeVar) {
      var viewFactoryArgs = [
          new FnParam(ViewConstructorVars.viewUtils.name, importType(resolveIdentifier(Identifiers.ViewUtils))),
          new FnParam(ViewConstructorVars.parentInjector.name, importType(resolveIdentifier(Identifiers.Injector))),
          new FnParam(ViewConstructorVars.declarationEl.name, importType(resolveIdentifier(Identifiers.AppElement)))
      ];
      var initRenderCompTypeStmts = [];
      var templateUrlInfo;
      if (view.component.template.templateUrl == view.component.type.moduleUrl) {
          templateUrlInfo =
              view.component.type.moduleUrl + " class " + view.component.type.name + " - inline template";
      }
      else {
          templateUrlInfo = view.component.template.templateUrl;
      }
      if (view.viewIndex === 0) {
          var animationsExpr = literalMap(view.animations.map(function (entry) { return [entry.name, entry.fnExp]; }));
          initRenderCompTypeStmts = [
              new IfStmt(renderCompTypeVar.identical(NULL_EXPR), [
                  renderCompTypeVar
                      .set(ViewConstructorVars.viewUtils.callMethod('createRenderComponentType', [
                      view.genConfig.genDebugInfo ? literal(templateUrlInfo) : literal(''),
                      literal(view.component.template.ngContentSelectors.length),
                      ViewEncapsulationEnum.fromValue(view.component.template.encapsulation),
                      view.styles,
                      animationsExpr,
                  ]))
                      .toStmt(),
              ]),
          ];
      }
      return fn(viewFactoryArgs, initRenderCompTypeStmts.concat([
          new ReturnStatement(variable(viewClass.name)
              .instantiate(viewClass.constructorMethod.params.map(function (param) { return variable(param.name); }))),
      ]), importType(resolveIdentifier(Identifiers.AppView), [getContextType(view)]))
          .toDeclStmt(view.viewFactory.name, [StmtModifier.Final]);
  }
  function generateCreateMethod(view) {
      var parentRenderNodeExpr = NULL_EXPR;
      var parentRenderNodeStmts = [];
      if (view.viewType === ViewType.COMPONENT) {
          parentRenderNodeExpr = ViewProperties.renderer.callMethod('createViewRoot', [THIS_EXPR.prop('declarationAppElement').prop('nativeElement')]);
          parentRenderNodeStmts =
              [parentRenderNodeVar.set(parentRenderNodeExpr)
                      .toDeclStmt(importType(view.genConfig.renderTypes.renderNode), [StmtModifier.Final])];
      }
      var resultExpr;
      if (view.viewType === ViewType.HOST) {
          resultExpr = view.nodes[0].appElement;
      }
      else {
          resultExpr = NULL_EXPR;
      }
      return parentRenderNodeStmts.concat(view.createMethod.finish(), [
          THIS_EXPR
              .callMethod('init', [
              createFlatArray(view.rootNodesOrAppElements),
              literalArr(view.nodes.map(function (node) { return node.renderNode; })), literalArr(view.disposables),
              literalArr(view.subscriptions)
          ])
              .toStmt(),
          new ReturnStatement(resultExpr)
      ]);
  }
  function generateDetectChangesMethod(view) {
      var stmts = [];
      if (view.animationBindingsMethod.isEmpty() && view.detectChangesInInputsMethod.isEmpty() &&
          view.updateContentQueriesMethod.isEmpty() &&
          view.afterContentLifecycleCallbacksMethod.isEmpty() &&
          view.detectChangesRenderPropertiesMethod.isEmpty() &&
          view.updateViewQueriesMethod.isEmpty() && view.afterViewLifecycleCallbacksMethod.isEmpty()) {
          return stmts;
      }
      ListWrapper.addAll(stmts, view.animationBindingsMethod.finish());
      ListWrapper.addAll(stmts, view.detectChangesInInputsMethod.finish());
      stmts.push(THIS_EXPR.callMethod('detectContentChildrenChanges', [DetectChangesVars.throwOnChange])
          .toStmt());
      var afterContentStmts = view.updateContentQueriesMethod.finish().concat(view.afterContentLifecycleCallbacksMethod.finish());
      if (afterContentStmts.length > 0) {
          stmts.push(new IfStmt(not(DetectChangesVars.throwOnChange), afterContentStmts));
      }
      ListWrapper.addAll(stmts, view.detectChangesRenderPropertiesMethod.finish());
      stmts.push(THIS_EXPR.callMethod('detectViewChildrenChanges', [DetectChangesVars.throwOnChange])
          .toStmt());
      var afterViewStmts = view.updateViewQueriesMethod.finish().concat(view.afterViewLifecycleCallbacksMethod.finish());
      if (afterViewStmts.length > 0) {
          stmts.push(new IfStmt(not(DetectChangesVars.throwOnChange), afterViewStmts));
      }
      var varStmts = [];
      var readVars = findReadVarNames(stmts);
      if (readVars.has(DetectChangesVars.changed.name)) {
          varStmts.push(DetectChangesVars.changed.set(literal(true)).toDeclStmt(BOOL_TYPE));
      }
      if (readVars.has(DetectChangesVars.changes.name)) {
          varStmts.push(DetectChangesVars.changes.set(NULL_EXPR)
              .toDeclStmt(new MapType(importType(resolveIdentifier(Identifiers.SimpleChange)))));
      }
      if (readVars.has(DetectChangesVars.valUnwrapper.name)) {
          varStmts.push(DetectChangesVars.valUnwrapper
              .set(importExpr(resolveIdentifier(Identifiers.ValueUnwrapper)).instantiate([]))
              .toDeclStmt(null, [StmtModifier.Final]));
      }
      return varStmts.concat(stmts);
  }
  function addReturnValuefNotEmpty(statements, value) {
      if (statements.length > 0) {
          return statements.concat([new ReturnStatement(value)]);
      }
      else {
          return statements;
      }
  }
  function getContextType(view) {
      if (view.viewType === ViewType.COMPONENT) {
          return importType(view.component.type);
      }
      return DYNAMIC_TYPE;
  }
  function getChangeDetectionMode(view) {
      var mode;
      if (view.viewType === ViewType.COMPONENT) {
          mode = isDefaultChangeDetectionStrategy(view.component.changeDetection) ?
              ChangeDetectorStatus.CheckAlways :
              ChangeDetectorStatus.CheckOnce;
      }
      else {
          mode = ChangeDetectorStatus.CheckAlways;
      }
      return mode;
  }

  var ViewCompileResult = (function () {
      function ViewCompileResult(statements, viewFactoryVar, dependencies) {
          this.statements = statements;
          this.viewFactoryVar = viewFactoryVar;
          this.dependencies = dependencies;
      }
      return ViewCompileResult;
  }());
  var ViewCompiler = (function () {
      function ViewCompiler(_genConfig) {
          this._genConfig = _genConfig;
      }
      ViewCompiler.prototype.compileComponent = function (component, template, styles, pipes, compiledAnimations) {
          var dependencies = [];
          var view = new CompileView(component, this._genConfig, pipes, styles, compiledAnimations, 0, CompileElement.createNull(), []);
          var statements = [];
          buildView(view, template, dependencies);
          // Need to separate binding from creation to be able to refer to
          // variables that have been declared after usage.
          bindView(view, template);
          finishView(view, statements);
          return new ViewCompileResult(statements, view.viewFactory.name, dependencies);
      };
      ViewCompiler.decorators = [
          { type: _angular_core.Injectable },
      ];
      /** @nocollapse */
      ViewCompiler.ctorParameters = [
          { type: CompilerConfig, },
      ];
      return ViewCompiler;
  }());

  var SourceModule = (function () {
      function SourceModule(moduleUrl, source) {
          this.moduleUrl = moduleUrl;
          this.source = source;
      }
      return SourceModule;
  }());
  var NgModulesSummary = (function () {
      function NgModulesSummary(ngModuleByDirective, ngModules) {
          this.ngModuleByDirective = ngModuleByDirective;
          this.ngModules = ngModules;
      }
      return NgModulesSummary;
  }());
  function analyzeModules(ngModules, metadataResolver) {
      var ngModuleByDirective = new Map();
      var modules = [];
      ngModules.forEach(function (ngModule) {
          var ngModuleMeta = metadataResolver.getNgModuleMetadata(ngModule);
          modules.push(ngModuleMeta);
          ngModuleMeta.declaredDirectives.forEach(function (dirMeta) {
              ngModuleByDirective.set(dirMeta.type.reference, ngModuleMeta);
          });
      });
      return new NgModulesSummary(ngModuleByDirective, modules);
  }
  var OfflineCompiler = (function () {
      function OfflineCompiler(_metadataResolver, _directiveNormalizer, _templateParser, _styleCompiler, _viewCompiler, _dirWrapperCompiler, _ngModuleCompiler, _outputEmitter, _localeId, _translationFormat) {
          this._metadataResolver = _metadataResolver;
          this._directiveNormalizer = _directiveNormalizer;
          this._templateParser = _templateParser;
          this._styleCompiler = _styleCompiler;
          this._viewCompiler = _viewCompiler;
          this._dirWrapperCompiler = _dirWrapperCompiler;
          this._ngModuleCompiler = _ngModuleCompiler;
          this._outputEmitter = _outputEmitter;
          this._localeId = _localeId;
          this._translationFormat = _translationFormat;
          this._animationParser = new AnimationParser();
          this._animationCompiler = new AnimationCompiler();
      }
      OfflineCompiler.prototype.analyzeModules = function (ngModules) {
          return analyzeModules(ngModules, this._metadataResolver);
      };
      OfflineCompiler.prototype.clearCache = function () {
          this._directiveNormalizer.clearCache();
          this._metadataResolver.clearCache();
      };
      OfflineCompiler.prototype.compile = function (moduleUrl, ngModulesSummary, directives, ngModules) {
          var _this = this;
          var fileSuffix = _splitTypescriptSuffix(moduleUrl)[1];
          var statements = [];
          var exportedVars = [];
          var outputSourceModules = [];
          // compile all ng modules
          exportedVars.push.apply(exportedVars, ngModules.map(function (ngModuleType) { return _this._compileModule(ngModuleType, statements); }));
          // compile directive wrappers
          exportedVars.push.apply(exportedVars, directives.map(function (directiveType) { return _this._compileDirectiveWrapper(directiveType, statements); }));
          // compile components
          return Promise
              .all(directives.map(function (dirType) {
              var compMeta = _this._metadataResolver.getDirectiveMetadata(dirType);
              if (!compMeta.isComponent) {
                  return Promise.resolve(null);
              }
              var ngModule = ngModulesSummary.ngModuleByDirective.get(dirType);
              if (!ngModule) {
                  throw new Error("Cannot determine the module for component " + compMeta.type.name + "!");
              }
              return Promise
                  .all([compMeta].concat(ngModule.transitiveModule.directives).map(function (dirMeta) { return _this._directiveNormalizer.normalizeDirective(dirMeta).asyncResult; }))
                  .then(function (normalizedCompWithDirectives) {
                  var compMeta = normalizedCompWithDirectives[0], dirMetas = normalizedCompWithDirectives.slice(1);
                  _assertComponent(compMeta);
                  // compile styles
                  var stylesCompileResults = _this._styleCompiler.compileComponent(compMeta);
                  stylesCompileResults.externalStylesheets.forEach(function (compiledStyleSheet) {
                      outputSourceModules.push(_this._codgenStyles(compiledStyleSheet, fileSuffix));
                  });
                  // compile components
                  exportedVars.push(_this._compileComponentFactory(compMeta, fileSuffix, statements), _this._compileComponent(compMeta, dirMetas, ngModule.transitiveModule.pipes, ngModule.schemas, stylesCompileResults.componentStylesheet, fileSuffix, statements));
              });
          }))
              .then(function () {
              if (statements.length > 0) {
                  outputSourceModules.unshift(_this._codegenSourceModule(_ngfactoryModuleUrl(moduleUrl), statements, exportedVars));
              }
              return outputSourceModules;
          });
      };
      OfflineCompiler.prototype._compileModule = function (ngModuleType, targetStatements) {
          var ngModule = this._metadataResolver.getNgModuleMetadata(ngModuleType);
          var providers = [];
          if (this._localeId) {
              providers.push(new CompileProviderMetadata({
                  token: resolveIdentifierToken(Identifiers.LOCALE_ID),
                  useValue: this._localeId,
              }));
          }
          if (this._translationFormat) {
              providers.push(new CompileProviderMetadata({
                  token: resolveIdentifierToken(Identifiers.TRANSLATIONS_FORMAT),
                  useValue: this._translationFormat
              }));
          }
          var appCompileResult = this._ngModuleCompiler.compile(ngModule, providers);
          appCompileResult.dependencies.forEach(function (dep) {
              dep.placeholder.name = _componentFactoryName(dep.comp);
              dep.placeholder.moduleUrl = _ngfactoryModuleUrl(dep.comp.moduleUrl);
          });
          targetStatements.push.apply(targetStatements, appCompileResult.statements);
          return appCompileResult.ngModuleFactoryVar;
      };
      OfflineCompiler.prototype._compileDirectiveWrapper = function (directiveType, targetStatements) {
          var dirMeta = this._metadataResolver.getDirectiveMetadata(directiveType);
          var dirCompileResult = this._dirWrapperCompiler.compile(dirMeta);
          targetStatements.push.apply(targetStatements, dirCompileResult.statements);
          return dirCompileResult.dirWrapperClassVar;
      };
      OfflineCompiler.prototype._compileComponentFactory = function (compMeta, fileSuffix, targetStatements) {
          var hostMeta = createHostComponentMeta(compMeta);
          var hostViewFactoryVar = this._compileComponent(hostMeta, [compMeta], [], [], null, fileSuffix, targetStatements);
          var compFactoryVar = _componentFactoryName(compMeta.type);
          targetStatements.push(variable(compFactoryVar)
              .set(importExpr(resolveIdentifier(Identifiers.ComponentFactory), [importType(compMeta.type)])
              .instantiate([
              literal(compMeta.selector),
              variable(hostViewFactoryVar),
              importExpr(compMeta.type),
          ], importType(resolveIdentifier(Identifiers.ComponentFactory), [importType(compMeta.type)], [TypeModifier.Const])))
              .toDeclStmt(null, [StmtModifier.Final]));
          return compFactoryVar;
      };
      OfflineCompiler.prototype._compileComponent = function (compMeta, directives, pipes, schemas, componentStyles, fileSuffix, targetStatements) {
          var parsedAnimations = this._animationParser.parseComponent(compMeta);
          var parsedTemplate = this._templateParser.parse(compMeta, compMeta.template.template, directives, pipes, schemas, compMeta.type.name);
          var stylesExpr = componentStyles ? variable(componentStyles.stylesVar) : literalArr([]);
          var compiledAnimations = this._animationCompiler.compile(compMeta.type.name, parsedAnimations);
          var viewResult = this._viewCompiler.compileComponent(compMeta, parsedTemplate, stylesExpr, pipes, compiledAnimations);
          if (componentStyles) {
              targetStatements.push.apply(targetStatements, _resolveStyleStatements(componentStyles, fileSuffix));
          }
          compiledAnimations.forEach(function (entry) { entry.statements.forEach(function (statement) { targetStatements.push(statement); }); });
          targetStatements.push.apply(targetStatements, _resolveViewStatements(viewResult));
          return viewResult.viewFactoryVar;
      };
      OfflineCompiler.prototype._codgenStyles = function (stylesCompileResult, fileSuffix) {
          _resolveStyleStatements(stylesCompileResult, fileSuffix);
          return this._codegenSourceModule(_stylesModuleUrl(stylesCompileResult.meta.moduleUrl, stylesCompileResult.isShimmed, fileSuffix), stylesCompileResult.statements, [stylesCompileResult.stylesVar]);
      };
      OfflineCompiler.prototype._codegenSourceModule = function (moduleUrl, statements, exportedVars) {
          return new SourceModule(moduleUrl, this._outputEmitter.emitStatements(moduleUrl, statements, exportedVars));
      };
      return OfflineCompiler;
  }());
  function _resolveViewStatements(compileResult) {
      compileResult.dependencies.forEach(function (dep) {
          if (dep instanceof ViewFactoryDependency) {
              var vfd = dep;
              vfd.placeholder.moduleUrl = _ngfactoryModuleUrl(vfd.comp.moduleUrl);
          }
          else if (dep instanceof ComponentFactoryDependency) {
              var cfd = dep;
              cfd.placeholder.name = _componentFactoryName(cfd.comp);
              cfd.placeholder.moduleUrl = _ngfactoryModuleUrl(cfd.comp.moduleUrl);
          }
          else if (dep instanceof DirectiveWrapperDependency) {
              var dwd = dep;
              dwd.placeholder.moduleUrl = _ngfactoryModuleUrl(dwd.dir.moduleUrl);
          }
      });
      return compileResult.statements;
  }
  function _resolveStyleStatements(compileResult, fileSuffix) {
      compileResult.dependencies.forEach(function (dep) {
          dep.valuePlaceholder.moduleUrl = _stylesModuleUrl(dep.moduleUrl, dep.isShimmed, fileSuffix);
      });
      return compileResult.statements;
  }
  function _ngfactoryModuleUrl(dirUrl) {
      var urlWithSuffix = _splitTypescriptSuffix(dirUrl);
      return urlWithSuffix[0] + ".ngfactory" + urlWithSuffix[1];
  }
  function _componentFactoryName(comp) {
      return comp.name + "NgFactory";
  }
  function _stylesModuleUrl(stylesheetUrl, shim, suffix) {
      return shim ? stylesheetUrl + ".shim" + suffix : "" + stylesheetUrl + suffix;
  }
  function _assertComponent(meta) {
      if (!meta.isComponent) {
          throw new Error("Could not compile '" + meta.type.name + "' because it is not a component.");
      }
  }
  function _splitTypescriptSuffix(path) {
      if (path.endsWith('.d.ts')) {
          return [path.slice(0, -5), '.ts'];
      }
      var lastDot = path.lastIndexOf('.');
      if (lastDot !== -1) {
          return [path.substring(0, lastDot), path.substring(lastDot)];
      }
      return [path, ''];
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * An interface for retrieving documents by URL that the compiler uses
   * to load templates.
   */
  var ResourceLoader = (function () {
      function ResourceLoader() {
      }
      ResourceLoader.prototype.get = function (url) { return null; };
      return ResourceLoader;
  }());

  var _ASSET_SCHEME = 'asset:';
  /**
   * Create a {@link UrlResolver} with no package prefix.
   */
  function createUrlResolverWithoutPackagePrefix() {
      return new UrlResolver();
  }
  function createOfflineCompileUrlResolver() {
      return new UrlResolver(_ASSET_SCHEME);
  }
  /**
   * A default provider for {@link PACKAGE_ROOT_URL} that maps to '/'.
   */
  var DEFAULT_PACKAGE_URL_PROVIDER = {
      provide: _angular_core.PACKAGE_ROOT_URL,
      useValue: '/'
  };
  /**
   * Used by the {@link Compiler} when resolving HTML and CSS template URLs.
   *
   * This class can be overridden by the application developer to create custom behavior.
   *
   * See {@link Compiler}
   *
   * ## Example
   *
   * {@example compiler/ts/url_resolver/url_resolver.ts region='url_resolver'}
   *
   * @security  When compiling templates at runtime, you must
   * ensure that the entire template comes from a trusted source.
   * Attacker-controlled data introduced by a template could expose your
   * application to XSS risks. For more detail, see the [Security Guide](http://g.co/ng/security).
   */
  var UrlResolver = (function () {
      function UrlResolver(_packagePrefix) {
          if (_packagePrefix === void 0) { _packagePrefix = null; }
          this._packagePrefix = _packagePrefix;
      }
      /**
       * Resolves the `url` given the `baseUrl`:
       * - when the `url` is null, the `baseUrl` is returned,
       * - if `url` is relative ('path/to/here', './path/to/here'), the resolved url is a combination of
       * `baseUrl` and `url`,
       * - if `url` is absolute (it has a scheme: 'http://', 'https://' or start with '/'), the `url` is
       * returned as is (ignoring the `baseUrl`)
       */
      UrlResolver.prototype.resolve = function (baseUrl, url) {
          var resolvedUrl = url;
          if (isPresent(baseUrl) && baseUrl.length > 0) {
              resolvedUrl = _resolveUrl(baseUrl, resolvedUrl);
          }
          var resolvedParts = _split(resolvedUrl);
          var prefix = this._packagePrefix;
          if (isPresent(prefix) && isPresent(resolvedParts) &&
              resolvedParts[_ComponentIndex.Scheme] == 'package') {
              var path = resolvedParts[_ComponentIndex.Path];
              if (this._packagePrefix === _ASSET_SCHEME) {
                  var pathSegements = path.split(/\//);
                  resolvedUrl = "asset:" + pathSegements[0] + "/lib/" + pathSegements.slice(1).join('/');
              }
              else {
                  prefix = prefix.replace(/\/+$/, '');
                  path = path.replace(/^\/+/, '');
                  return prefix + "/" + path;
              }
          }
          return resolvedUrl;
      };
      UrlResolver.decorators = [
          { type: _angular_core.Injectable },
      ];
      /** @nocollapse */
      UrlResolver.ctorParameters = [
          { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_core.PACKAGE_ROOT_URL,] },] },
      ];
      return UrlResolver;
  }());
  /**
   * Extract the scheme of a URL.
   */
  function getUrlScheme(url) {
      var match = _split(url);
      return (match && match[_ComponentIndex.Scheme]) || '';
  }
  // The code below is adapted from Traceur:
  // https://github.com/google/traceur-compiler/blob/9511c1dafa972bf0de1202a8a863bad02f0f95a8/src/runtime/url.js
  /**
   * Builds a URI string from already-encoded parts.
   *
   * No encoding is performed.  Any component may be omitted as either null or
   * undefined.
   *
   * @param opt_scheme The scheme such as 'http'.
   * @param opt_userInfo The user name before the '@'.
   * @param opt_domain The domain such as 'www.google.com', already
   *     URI-encoded.
   * @param opt_port The port number.
   * @param opt_path The path, already URI-encoded.  If it is not
   *     empty, it must begin with a slash.
   * @param opt_queryData The URI-encoded query data.
   * @param opt_fragment The URI-encoded fragment identifier.
   * @return The fully combined URI.
   */
  function _buildFromEncodedParts(opt_scheme, opt_userInfo, opt_domain, opt_port, opt_path, opt_queryData, opt_fragment) {
      var out = [];
      if (isPresent(opt_scheme)) {
          out.push(opt_scheme + ':');
      }
      if (isPresent(opt_domain)) {
          out.push('//');
          if (isPresent(opt_userInfo)) {
              out.push(opt_userInfo + '@');
          }
          out.push(opt_domain);
          if (isPresent(opt_port)) {
              out.push(':' + opt_port);
          }
      }
      if (isPresent(opt_path)) {
          out.push(opt_path);
      }
      if (isPresent(opt_queryData)) {
          out.push('?' + opt_queryData);
      }
      if (isPresent(opt_fragment)) {
          out.push('#' + opt_fragment);
      }
      return out.join('');
  }
  /**
   * A regular expression for breaking a URI into its component parts.
   *
   * {@link http://www.gbiv.com/protocols/uri/rfc/rfc3986.html#RFC2234} says
   * As the "first-match-wins" algorithm is identical to the "greedy"
   * disambiguation method used by POSIX regular expressions, it is natural and
   * commonplace to use a regular expression for parsing the potential five
   * components of a URI reference.
   *
   * The following line is the regular expression for breaking-down a
   * well-formed URI reference into its components.
   *
   * <pre>
   * ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?
   *  12            3  4          5       6  7        8 9
   * </pre>
   *
   * The numbers in the second line above are only to assist readability; they
   * indicate the reference points for each subexpression (i.e., each paired
   * parenthesis). We refer to the value matched for subexpression <n> as $<n>.
   * For example, matching the above expression to
   * <pre>
   *     http://www.ics.uci.edu/pub/ietf/uri/#Related
   * </pre>
   * results in the following subexpression matches:
   * <pre>
   *    $1 = http:
   *    $2 = http
   *    $3 = //www.ics.uci.edu
   *    $4 = www.ics.uci.edu
   *    $5 = /pub/ietf/uri/
   *    $6 = <undefined>
   *    $7 = <undefined>
   *    $8 = #Related
   *    $9 = Related
   * </pre>
   * where <undefined> indicates that the component is not present, as is the
   * case for the query component in the above example. Therefore, we can
   * determine the value of the five components as
   * <pre>
   *    scheme    = $2
   *    authority = $4
   *    path      = $5
   *    query     = $7
   *    fragment  = $9
   * </pre>
   *
   * The regular expression has been modified slightly to expose the
   * userInfo, domain, and port separately from the authority.
   * The modified version yields
   * <pre>
   *    $1 = http              scheme
   *    $2 = <undefined>       userInfo -\
   *    $3 = www.ics.uci.edu   domain     | authority
   *    $4 = <undefined>       port     -/
   *    $5 = /pub/ietf/uri/    path
   *    $6 = <undefined>       query without ?
   *    $7 = Related           fragment without #
   * </pre>
   * @type {!RegExp}
   * @internal
   */
  var _splitRe = new RegExp('^' +
      '(?:' +
      '([^:/?#.]+)' +
      // used by other URL parts such as :,
      // ?, /, #, and .
      ':)?' +
      '(?://' +
      '(?:([^/?#]*)@)?' +
      '([\\w\\d\\-\\u0100-\\uffff.%]*)' +
      // digits, dashes, dots, percent
      // escapes, and unicode characters.
      '(?::([0-9]+))?' +
      ')?' +
      '([^?#]+)?' +
      '(?:\\?([^#]*))?' +
      '(?:#(.*))?' +
      '$');
  /**
   * The index of each URI component in the return value of goog.uri.utils.split.
   * @enum {number}
   */
  var _ComponentIndex;
  (function (_ComponentIndex) {
      _ComponentIndex[_ComponentIndex["Scheme"] = 1] = "Scheme";
      _ComponentIndex[_ComponentIndex["UserInfo"] = 2] = "UserInfo";
      _ComponentIndex[_ComponentIndex["Domain"] = 3] = "Domain";
      _ComponentIndex[_ComponentIndex["Port"] = 4] = "Port";
      _ComponentIndex[_ComponentIndex["Path"] = 5] = "Path";
      _ComponentIndex[_ComponentIndex["QueryData"] = 6] = "QueryData";
      _ComponentIndex[_ComponentIndex["Fragment"] = 7] = "Fragment";
  })(_ComponentIndex || (_ComponentIndex = {}));
  /**
   * Splits a URI into its component parts.
   *
   * Each component can be accessed via the component indices; for example:
   * <pre>
   * goog.uri.utils.split(someStr)[goog.uri.utils.CompontentIndex.QUERY_DATA];
   * </pre>
   *
   * @param uri The URI string to examine.
   * @return Each component still URI-encoded.
   *     Each component that is present will contain the encoded value, whereas
   *     components that are not present will be undefined or empty, depending
   *     on the browser's regular expression implementation.  Never null, since
   *     arbitrary strings may still look like path names.
   */
  function _split(uri) {
      return uri.match(_splitRe);
  }
  /**
    * Removes dot segments in given path component, as described in
    * RFC 3986, section 5.2.4.
    *
    * @param path A non-empty path component.
    * @return Path component with removed dot segments.
    */
  function _removeDotSegments(path) {
      if (path == '/')
          return '/';
      var leadingSlash = path[0] == '/' ? '/' : '';
      var trailingSlash = path[path.length - 1] === '/' ? '/' : '';
      var segments = path.split('/');
      var out = [];
      var up = 0;
      for (var pos = 0; pos < segments.length; pos++) {
          var segment = segments[pos];
          switch (segment) {
              case '':
              case '.':
                  break;
              case '..':
                  if (out.length > 0) {
                      out.pop();
                  }
                  else {
                      up++;
                  }
                  break;
              default:
                  out.push(segment);
          }
      }
      if (leadingSlash == '') {
          while (up-- > 0) {
              out.unshift('..');
          }
          if (out.length === 0)
              out.push('.');
      }
      return leadingSlash + out.join('/') + trailingSlash;
  }
  /**
   * Takes an array of the parts from split and canonicalizes the path part
   * and then joins all the parts.
   */
  function _joinAndCanonicalizePath(parts) {
      var path = parts[_ComponentIndex.Path];
      path = isBlank(path) ? '' : _removeDotSegments(path);
      parts[_ComponentIndex.Path] = path;
      return _buildFromEncodedParts(parts[_ComponentIndex.Scheme], parts[_ComponentIndex.UserInfo], parts[_ComponentIndex.Domain], parts[_ComponentIndex.Port], path, parts[_ComponentIndex.QueryData], parts[_ComponentIndex.Fragment]);
  }
  /**
   * Resolves a URL.
   * @param base The URL acting as the base URL.
   * @param to The URL to resolve.
   */
  function _resolveUrl(base, url) {
      var parts = _split(encodeURI(url));
      var baseParts = _split(base);
      if (isPresent(parts[_ComponentIndex.Scheme])) {
          return _joinAndCanonicalizePath(parts);
      }
      else {
          parts[_ComponentIndex.Scheme] = baseParts[_ComponentIndex.Scheme];
      }
      for (var i = _ComponentIndex.Scheme; i <= _ComponentIndex.Port; i++) {
          if (isBlank(parts[i])) {
              parts[i] = baseParts[i];
          }
      }
      if (parts[_ComponentIndex.Path][0] == '/') {
          return _joinAndCanonicalizePath(parts);
      }
      var path = baseParts[_ComponentIndex.Path];
      if (isBlank(path))
          path = '/';
      var index = path.lastIndexOf('/');
      path = path.substring(0, index + 1) + parts[_ComponentIndex.Path];
      parts[_ComponentIndex.Path] = path;
      return _joinAndCanonicalizePath(parts);
  }

  var DirectiveNormalizer = (function () {
      function DirectiveNormalizer(_resourceLoader, _urlResolver, _htmlParser, _config) {
          this._resourceLoader = _resourceLoader;
          this._urlResolver = _urlResolver;
          this._htmlParser = _htmlParser;
          this._config = _config;
          this._resourceLoaderCache = new Map();
      }
      DirectiveNormalizer.prototype.clearCache = function () { this._resourceLoaderCache.clear(); };
      DirectiveNormalizer.prototype.clearCacheFor = function (normalizedDirective) {
          var _this = this;
          if (!normalizedDirective.isComponent) {
              return;
          }
          this._resourceLoaderCache.delete(normalizedDirective.template.templateUrl);
          normalizedDirective.template.externalStylesheets.forEach(function (stylesheet) { _this._resourceLoaderCache.delete(stylesheet.moduleUrl); });
      };
      DirectiveNormalizer.prototype._fetch = function (url) {
          var result = this._resourceLoaderCache.get(url);
          if (!result) {
              result = this._resourceLoader.get(url);
              this._resourceLoaderCache.set(url, result);
          }
          return result;
      };
      DirectiveNormalizer.prototype.normalizeDirective = function (directive) {
          var _this = this;
          if (!directive.isComponent) {
              // For non components there is nothing to be normalized yet.
              return new SyncAsyncResult(directive, Promise.resolve(directive));
          }
          var normalizedTemplateSync = null;
          var normalizedTemplateAsync;
          if (isPresent(directive.template.template)) {
              normalizedTemplateSync = this.normalizeTemplateSync(directive.type, directive.template);
              normalizedTemplateAsync = Promise.resolve(normalizedTemplateSync);
          }
          else if (directive.template.templateUrl) {
              normalizedTemplateAsync = this.normalizeTemplateAsync(directive.type, directive.template);
          }
          else {
              throw new Error("No template specified for component " + directive.type.name);
          }
          if (normalizedTemplateSync && normalizedTemplateSync.styleUrls.length === 0) {
              // sync case
              var normalizedDirective = _cloneDirectiveWithTemplate(directive, normalizedTemplateSync);
              return new SyncAsyncResult(normalizedDirective, Promise.resolve(normalizedDirective));
          }
          else {
              // async case
              return new SyncAsyncResult(null, normalizedTemplateAsync
                  .then(function (normalizedTemplate) { return _this.normalizeExternalStylesheets(normalizedTemplate); })
                  .then(function (normalizedTemplate) {
                  return _cloneDirectiveWithTemplate(directive, normalizedTemplate);
              }));
          }
      };
      DirectiveNormalizer.prototype.normalizeTemplateSync = function (directiveType, template) {
          return this.normalizeLoadedTemplate(directiveType, template, template.template, directiveType.moduleUrl);
      };
      DirectiveNormalizer.prototype.normalizeTemplateAsync = function (directiveType, template) {
          var _this = this;
          var templateUrl = this._urlResolver.resolve(directiveType.moduleUrl, template.templateUrl);
          return this._fetch(templateUrl)
              .then(function (value) { return _this.normalizeLoadedTemplate(directiveType, template, value, templateUrl); });
      };
      DirectiveNormalizer.prototype.normalizeLoadedTemplate = function (directiveType, templateMeta, template, templateAbsUrl) {
          var interpolationConfig = InterpolationConfig.fromArray(templateMeta.interpolation);
          var rootNodesAndErrors = this._htmlParser.parse(template, directiveType.name, false, interpolationConfig);
          if (rootNodesAndErrors.errors.length > 0) {
              var errorString = rootNodesAndErrors.errors.join('\n');
              throw new Error("Template parse errors:\n" + errorString);
          }
          var templateMetadataStyles = this.normalizeStylesheet(new CompileStylesheetMetadata({
              styles: templateMeta.styles,
              styleUrls: templateMeta.styleUrls,
              moduleUrl: directiveType.moduleUrl
          }));
          var visitor = new TemplatePreparseVisitor();
          visitAll(visitor, rootNodesAndErrors.rootNodes);
          var templateStyles = this.normalizeStylesheet(new CompileStylesheetMetadata({ styles: visitor.styles, styleUrls: visitor.styleUrls, moduleUrl: templateAbsUrl }));
          var encapsulation = templateMeta.encapsulation;
          if (isBlank(encapsulation)) {
              encapsulation = this._config.defaultEncapsulation;
          }
          var styles = templateMetadataStyles.styles.concat(templateStyles.styles);
          var styleUrls = templateMetadataStyles.styleUrls.concat(templateStyles.styleUrls);
          if (encapsulation === _angular_core.ViewEncapsulation.Emulated && styles.length === 0 &&
              styleUrls.length === 0) {
              encapsulation = _angular_core.ViewEncapsulation.None;
          }
          return new CompileTemplateMetadata({
              encapsulation: encapsulation,
              template: template,
              templateUrl: templateAbsUrl, styles: styles, styleUrls: styleUrls,
              externalStylesheets: templateMeta.externalStylesheets,
              ngContentSelectors: visitor.ngContentSelectors,
              animations: templateMeta.animations,
              interpolation: templateMeta.interpolation,
          });
      };
      DirectiveNormalizer.prototype.normalizeExternalStylesheets = function (templateMeta) {
          return this._loadMissingExternalStylesheets(templateMeta.styleUrls)
              .then(function (externalStylesheets) { return new CompileTemplateMetadata({
              encapsulation: templateMeta.encapsulation,
              template: templateMeta.template,
              templateUrl: templateMeta.templateUrl,
              styles: templateMeta.styles,
              styleUrls: templateMeta.styleUrls,
              externalStylesheets: externalStylesheets,
              ngContentSelectors: templateMeta.ngContentSelectors,
              animations: templateMeta.animations,
              interpolation: templateMeta.interpolation
          }); });
      };
      DirectiveNormalizer.prototype._loadMissingExternalStylesheets = function (styleUrls, loadedStylesheets) {
          var _this = this;
          if (loadedStylesheets === void 0) { loadedStylesheets = new Map(); }
          return Promise
              .all(styleUrls.filter(function (styleUrl) { return !loadedStylesheets.has(styleUrl); })
              .map(function (styleUrl) { return _this._fetch(styleUrl).then(function (loadedStyle) {
              var stylesheet = _this.normalizeStylesheet(new CompileStylesheetMetadata({ styles: [loadedStyle], moduleUrl: styleUrl }));
              loadedStylesheets.set(styleUrl, stylesheet);
              return _this._loadMissingExternalStylesheets(stylesheet.styleUrls, loadedStylesheets);
          }); }))
              .then(function (_) { return MapWrapper.values(loadedStylesheets); });
      };
      DirectiveNormalizer.prototype.normalizeStylesheet = function (stylesheet) {
          var _this = this;
          var allStyleUrls = stylesheet.styleUrls.filter(isStyleUrlResolvable)
              .map(function (url) { return _this._urlResolver.resolve(stylesheet.moduleUrl, url); });
          var allStyles = stylesheet.styles.map(function (style) {
              var styleWithImports = extractStyleUrls(_this._urlResolver, stylesheet.moduleUrl, style);
              allStyleUrls.push.apply(allStyleUrls, styleWithImports.styleUrls);
              return styleWithImports.style;
          });
          return new CompileStylesheetMetadata({ styles: allStyles, styleUrls: allStyleUrls, moduleUrl: stylesheet.moduleUrl });
      };
      DirectiveNormalizer.decorators = [
          { type: _angular_core.Injectable },
      ];
      /** @nocollapse */
      DirectiveNormalizer.ctorParameters = [
          { type: ResourceLoader, },
          { type: UrlResolver, },
          { type: HtmlParser, },
          { type: CompilerConfig, },
      ];
      return DirectiveNormalizer;
  }());
  var TemplatePreparseVisitor = (function () {
      function TemplatePreparseVisitor() {
          this.ngContentSelectors = [];
          this.styles = [];
          this.styleUrls = [];
          this.ngNonBindableStackCount = 0;
      }
      TemplatePreparseVisitor.prototype.visitElement = function (ast, context) {
          var preparsedElement = preparseElement(ast);
          switch (preparsedElement.type) {
              case PreparsedElementType.NG_CONTENT:
                  if (this.ngNonBindableStackCount === 0) {
                      this.ngContentSelectors.push(preparsedElement.selectAttr);
                  }
                  break;
              case PreparsedElementType.STYLE:
                  var textContent = '';
                  ast.children.forEach(function (child) {
                      if (child instanceof Text) {
                          textContent += child.value;
                      }
                  });
                  this.styles.push(textContent);
                  break;
              case PreparsedElementType.STYLESHEET:
                  this.styleUrls.push(preparsedElement.hrefAttr);
                  break;
              default:
                  break;
          }
          if (preparsedElement.nonBindable) {
              this.ngNonBindableStackCount++;
          }
          visitAll(this, ast.children);
          if (preparsedElement.nonBindable) {
              this.ngNonBindableStackCount--;
          }
          return null;
      };
      TemplatePreparseVisitor.prototype.visitComment = function (ast, context) { return null; };
      TemplatePreparseVisitor.prototype.visitAttribute = function (ast, context) { return null; };
      TemplatePreparseVisitor.prototype.visitText = function (ast, context) { return null; };
      TemplatePreparseVisitor.prototype.visitExpansion = function (ast, context) { return null; };
      TemplatePreparseVisitor.prototype.visitExpansionCase = function (ast, context) { return null; };
      return TemplatePreparseVisitor;
  }());
  function _cloneDirectiveWithTemplate(directive, template) {
      return new CompileDirectiveMetadata({
          type: directive.type,
          isComponent: directive.isComponent,
          selector: directive.selector,
          exportAs: directive.exportAs,
          changeDetection: directive.changeDetection,
          inputs: directive.inputs,
          outputs: directive.outputs,
          hostListeners: directive.hostListeners,
          hostProperties: directive.hostProperties,
          hostAttributes: directive.hostAttributes,
          providers: directive.providers,
          viewProviders: directive.viewProviders,
          queries: directive.queries,
          viewQueries: directive.viewQueries,
          entryComponents: directive.entryComponents, template: template,
      });
  }

  /*
   * Resolve a `Type` for {@link Directive}.
   *
   * This interface can be overridden by the application developer to create custom behavior.
   *
   * See {@link Compiler}
   */
  var DirectiveResolver = (function () {
      function DirectiveResolver(_reflector) {
          if (_reflector === void 0) { _reflector = reflector; }
          this._reflector = _reflector;
      }
      /**
       * Return {@link Directive} for a given `Type`.
       */
      DirectiveResolver.prototype.resolve = function (type, throwIfNotFound) {
          if (throwIfNotFound === void 0) { throwIfNotFound = true; }
          var typeMetadata = this._reflector.annotations(_angular_core.resolveForwardRef(type));
          if (typeMetadata) {
              var metadata = typeMetadata.find(isDirectiveMetadata);
              if (metadata) {
                  var propertyMetadata = this._reflector.propMetadata(type);
                  return this._mergeWithPropertyMetadata(metadata, propertyMetadata, type);
              }
          }
          if (throwIfNotFound) {
              throw new Error("No Directive annotation found on " + stringify(type));
          }
          return null;
      };
      DirectiveResolver.prototype._mergeWithPropertyMetadata = function (dm, propertyMetadata, directiveType) {
          var inputs = [];
          var outputs = [];
          var host = {};
          var queries = {};
          Object.keys(propertyMetadata).forEach(function (propName) {
              propertyMetadata[propName].forEach(function (a) {
                  if (a instanceof _angular_core.Input) {
                      if (a.bindingPropertyName) {
                          inputs.push(propName + ": " + a.bindingPropertyName);
                      }
                      else {
                          inputs.push(propName);
                      }
                  }
                  else if (a instanceof _angular_core.Output) {
                      var output = a;
                      if (output.bindingPropertyName) {
                          outputs.push(propName + ": " + output.bindingPropertyName);
                      }
                      else {
                          outputs.push(propName);
                      }
                  }
                  else if (a instanceof _angular_core.HostBinding) {
                      var hostBinding = a;
                      if (hostBinding.hostPropertyName) {
                          var startWith = hostBinding.hostPropertyName[0];
                          if (startWith === '(') {
                              throw new Error("@HostBinding can not bind to events. Use @HostListener instead.");
                          }
                          else if (startWith === '[') {
                              throw new Error("@HostBinding parameter should be a property name, 'class.<name>', or 'attr.<name>'.");
                          }
                          host[("[" + hostBinding.hostPropertyName + "]")] = propName;
                      }
                      else {
                          host[("[" + propName + "]")] = propName;
                      }
                  }
                  else if (a instanceof _angular_core.HostListener) {
                      var hostListener = a;
                      var args = hostListener.args || [];
                      host[("(" + hostListener.eventName + ")")] = propName + "(" + args.join(',') + ")";
                  }
                  else if (a instanceof _angular_core.Query) {
                      queries[propName] = a;
                  }
              });
          });
          return this._merge(dm, inputs, outputs, host, queries, directiveType);
      };
      DirectiveResolver.prototype._extractPublicName = function (def) { return splitAtColon(def, [null, def])[1].trim(); };
      DirectiveResolver.prototype._merge = function (directive, inputs, outputs, host, queries, directiveType) {
          var _this = this;
          var mergedInputs = inputs;
          if (directive.inputs) {
              var inputNames_1 = directive.inputs.map(function (def) { return _this._extractPublicName(def); });
              inputs.forEach(function (inputDef) {
                  var publicName = _this._extractPublicName(inputDef);
                  if (inputNames_1.indexOf(publicName) > -1) {
                      throw new Error("Input '" + publicName + "' defined multiple times in '" + stringify(directiveType) + "'");
                  }
              });
              mergedInputs.unshift.apply(mergedInputs, directive.inputs);
          }
          var mergedOutputs = outputs;
          if (directive.outputs) {
              var outputNames_1 = directive.outputs.map(function (def) { return _this._extractPublicName(def); });
              outputs.forEach(function (outputDef) {
                  var publicName = _this._extractPublicName(outputDef);
                  if (outputNames_1.indexOf(publicName) > -1) {
                      throw new Error("Output event '" + publicName + "' defined multiple times in '" + stringify(directiveType) + "'");
                  }
              });
              mergedOutputs.unshift.apply(mergedOutputs, directive.outputs);
          }
          var mergedHost = directive.host ? StringMapWrapper.merge(directive.host, host) : host;
          var mergedQueries = directive.queries ? StringMapWrapper.merge(directive.queries, queries) : queries;
          if (directive instanceof _angular_core.Component) {
              return new _angular_core.Component({
                  selector: directive.selector,
                  inputs: mergedInputs,
                  outputs: mergedOutputs,
                  host: mergedHost,
                  exportAs: directive.exportAs,
                  moduleId: directive.moduleId,
                  queries: mergedQueries,
                  changeDetection: directive.changeDetection,
                  providers: directive.providers,
                  viewProviders: directive.viewProviders,
                  entryComponents: directive.entryComponents,
                  template: directive.template,
                  templateUrl: directive.templateUrl,
                  styles: directive.styles,
                  styleUrls: directive.styleUrls,
                  encapsulation: directive.encapsulation,
                  animations: directive.animations,
                  interpolation: directive.interpolation
              });
          }
          else {
              return new _angular_core.Directive({
                  selector: directive.selector,
                  inputs: mergedInputs,
                  outputs: mergedOutputs,
                  host: mergedHost,
                  exportAs: directive.exportAs,
                  queries: mergedQueries,
                  providers: directive.providers
              });
          }
      };
      DirectiveResolver.decorators = [
          { type: _angular_core.Injectable },
      ];
      /** @nocollapse */
      DirectiveResolver.ctorParameters = [
          { type: ReflectorReader, },
      ];
      return DirectiveResolver;
  }());
  function isDirectiveMetadata(type) {
      return type instanceof _angular_core.Directive;
  }

  function hasLifecycleHook(hook, token) {
      return reflector.hasLifecycleHook(token, getHookName(hook));
  }
  function getHookName(hook) {
      switch (hook) {
          case LifecycleHooks.OnInit:
              return 'ngOnInit';
          case LifecycleHooks.OnDestroy:
              return 'ngOnDestroy';
          case LifecycleHooks.DoCheck:
              return 'ngDoCheck';
          case LifecycleHooks.OnChanges:
              return 'ngOnChanges';
          case LifecycleHooks.AfterContentInit:
              return 'ngAfterContentInit';
          case LifecycleHooks.AfterContentChecked:
              return 'ngAfterContentChecked';
          case LifecycleHooks.AfterViewInit:
              return 'ngAfterViewInit';
          case LifecycleHooks.AfterViewChecked:
              return 'ngAfterViewChecked';
      }
  }

  function _isNgModuleMetadata(obj) {
      return obj instanceof _angular_core.NgModule;
  }
  /**
   * Resolves types to {@link NgModule}.
   */
  var NgModuleResolver = (function () {
      function NgModuleResolver(_reflector) {
          if (_reflector === void 0) { _reflector = reflector; }
          this._reflector = _reflector;
      }
      NgModuleResolver.prototype.resolve = function (type, throwIfNotFound) {
          if (throwIfNotFound === void 0) { throwIfNotFound = true; }
          var ngModuleMeta = this._reflector.annotations(type).find(_isNgModuleMetadata);
          if (isPresent(ngModuleMeta)) {
              return ngModuleMeta;
          }
          else {
              if (throwIfNotFound) {
                  throw new Error("No NgModule metadata found for '" + stringify(type) + "'.");
              }
              return null;
          }
      };
      NgModuleResolver.decorators = [
          { type: _angular_core.Injectable },
      ];
      /** @nocollapse */
      NgModuleResolver.ctorParameters = [
          { type: ReflectorReader, },
      ];
      return NgModuleResolver;
  }());

  function _isPipeMetadata(type) {
      return type instanceof _angular_core.Pipe;
  }
  /**
   * Resolve a `Type` for {@link Pipe}.
   *
   * This interface can be overridden by the application developer to create custom behavior.
   *
   * See {@link Compiler}
   */
  var PipeResolver = (function () {
      function PipeResolver(_reflector) {
          if (_reflector === void 0) { _reflector = reflector; }
          this._reflector = _reflector;
      }
      /**
       * Return {@link Pipe} for a given `Type`.
       */
      PipeResolver.prototype.resolve = function (type, throwIfNotFound) {
          if (throwIfNotFound === void 0) { throwIfNotFound = true; }
          var metas = this._reflector.annotations(_angular_core.resolveForwardRef(type));
          if (isPresent(metas)) {
              var annotation = metas.find(_isPipeMetadata);
              if (isPresent(annotation)) {
                  return annotation;
              }
          }
          if (throwIfNotFound) {
              throw new Error("No Pipe decorator found on " + stringify(type));
          }
          return null;
      };
      PipeResolver.decorators = [
          { type: _angular_core.Injectable },
      ];
      /** @nocollapse */
      PipeResolver.ctorParameters = [
          { type: ReflectorReader, },
      ];
      return PipeResolver;
  }());

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var __extends$16 = (this && this.__extends) || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var CompileMetadataResolver = (function () {
      function CompileMetadataResolver(_ngModuleResolver, _directiveResolver, _pipeResolver, _schemaRegistry, _reflector) {
          if (_reflector === void 0) { _reflector = reflector; }
          this._ngModuleResolver = _ngModuleResolver;
          this._directiveResolver = _directiveResolver;
          this._pipeResolver = _pipeResolver;
          this._schemaRegistry = _schemaRegistry;
          this._reflector = _reflector;
          this._directiveCache = new Map();
          this._pipeCache = new Map();
          this._ngModuleCache = new Map();
          this._ngModuleOfTypes = new Map();
          this._anonymousTypes = new Map();
          this._anonymousTypeIndex = 0;
      }
      CompileMetadataResolver.prototype.sanitizeTokenName = function (token) {
          var identifier = stringify(token);
          if (identifier.indexOf('(') >= 0) {
              // case: anonymous functions!
              var found = this._anonymousTypes.get(token);
              if (!found) {
                  this._anonymousTypes.set(token, this._anonymousTypeIndex++);
                  found = this._anonymousTypes.get(token);
              }
              identifier = "anonymous_token_" + found + "_";
          }
          return sanitizeIdentifier(identifier);
      };
      CompileMetadataResolver.prototype.clearCacheFor = function (type) {
          this._directiveCache.delete(type);
          this._pipeCache.delete(type);
          this._ngModuleOfTypes.delete(type);
          // Clear all of the NgModule as they contain transitive information!
          this._ngModuleCache.clear();
      };
      CompileMetadataResolver.prototype.clearCache = function () {
          this._directiveCache.clear();
          this._pipeCache.clear();
          this._ngModuleCache.clear();
          this._ngModuleOfTypes.clear();
      };
      CompileMetadataResolver.prototype.getAnimationEntryMetadata = function (entry) {
          var _this = this;
          var defs = entry.definitions.map(function (def) { return _this.getAnimationStateMetadata(def); });
          return new CompileAnimationEntryMetadata(entry.name, defs);
      };
      CompileMetadataResolver.prototype.getAnimationStateMetadata = function (value) {
          if (value instanceof _angular_core.AnimationStateDeclarationMetadata) {
              var styles = this.getAnimationStyleMetadata(value.styles);
              return new CompileAnimationStateDeclarationMetadata(value.stateNameExpr, styles);
          }
          if (value instanceof _angular_core.AnimationStateTransitionMetadata) {
              return new CompileAnimationStateTransitionMetadata(value.stateChangeExpr, this.getAnimationMetadata(value.steps));
          }
          return null;
      };
      CompileMetadataResolver.prototype.getAnimationStyleMetadata = function (value) {
          return new CompileAnimationStyleMetadata(value.offset, value.styles);
      };
      CompileMetadataResolver.prototype.getAnimationMetadata = function (value) {
          var _this = this;
          if (value instanceof _angular_core.AnimationStyleMetadata) {
              return this.getAnimationStyleMetadata(value);
          }
          if (value instanceof _angular_core.AnimationKeyframesSequenceMetadata) {
              return new CompileAnimationKeyframesSequenceMetadata(value.steps.map(function (entry) { return _this.getAnimationStyleMetadata(entry); }));
          }
          if (value instanceof _angular_core.AnimationAnimateMetadata) {
              var animateData = this
                  .getAnimationMetadata(value.styles);
              return new CompileAnimationAnimateMetadata(value.timings, animateData);
          }
          if (value instanceof _angular_core.AnimationWithStepsMetadata) {
              var steps = value.steps.map(function (step) { return _this.getAnimationMetadata(step); });
              if (value instanceof _angular_core.AnimationGroupMetadata) {
                  return new CompileAnimationGroupMetadata(steps);
              }
              return new CompileAnimationSequenceMetadata(steps);
          }
          return null;
      };
      CompileMetadataResolver.prototype.getDirectiveMetadata = function (directiveType, throwIfNotFound) {
          var _this = this;
          if (throwIfNotFound === void 0) { throwIfNotFound = true; }
          directiveType = _angular_core.resolveForwardRef(directiveType);
          var meta = this._directiveCache.get(directiveType);
          if (!meta) {
              var dirMeta = this._directiveResolver.resolve(directiveType, throwIfNotFound);
              if (!dirMeta) {
                  return null;
              }
              var templateMeta = null;
              var changeDetectionStrategy = null;
              var viewProviders = [];
              var moduleUrl = staticTypeModuleUrl(directiveType);
              var entryComponentMetadata = [];
              var selector = dirMeta.selector;
              if (dirMeta instanceof _angular_core.Component) {
                  // Component
                  assertArrayOfStrings('styles', dirMeta.styles);
                  assertArrayOfStrings('styleUrls', dirMeta.styleUrls);
                  assertInterpolationSymbols('interpolation', dirMeta.interpolation);
                  var animations = dirMeta.animations ?
                      dirMeta.animations.map(function (e) { return _this.getAnimationEntryMetadata(e); }) :
                      null;
                  templateMeta = new CompileTemplateMetadata({
                      encapsulation: dirMeta.encapsulation,
                      template: dirMeta.template,
                      templateUrl: dirMeta.templateUrl,
                      styles: dirMeta.styles,
                      styleUrls: dirMeta.styleUrls,
                      animations: animations,
                      interpolation: dirMeta.interpolation
                  });
                  changeDetectionStrategy = dirMeta.changeDetection;
                  if (dirMeta.viewProviders) {
                      viewProviders = this.getProvidersMetadata(dirMeta.viewProviders, entryComponentMetadata, "viewProviders for \"" + stringify(directiveType) + "\"");
                  }
                  moduleUrl = componentModuleUrl(this._reflector, directiveType, dirMeta);
                  if (dirMeta.entryComponents) {
                      entryComponentMetadata =
                          flattenArray(dirMeta.entryComponents)
                              .map(function (type) { return _this.getTypeMetadata(type, staticTypeModuleUrl(type)); })
                              .concat(entryComponentMetadata);
                  }
                  if (!selector) {
                      selector = this._schemaRegistry.getDefaultComponentElementName();
                  }
              }
              else {
                  // Directive
                  if (!selector) {
                      throw new Error("Directive " + stringify(directiveType) + " has no selector, please add it!");
                  }
              }
              var providers = [];
              if (isPresent(dirMeta.providers)) {
                  providers = this.getProvidersMetadata(dirMeta.providers, entryComponentMetadata, "providers for \"" + stringify(directiveType) + "\"");
              }
              var queries = [];
              var viewQueries = [];
              if (isPresent(dirMeta.queries)) {
                  queries = this.getQueriesMetadata(dirMeta.queries, false, directiveType);
                  viewQueries = this.getQueriesMetadata(dirMeta.queries, true, directiveType);
              }
              meta = CompileDirectiveMetadata.create({
                  selector: selector,
                  exportAs: dirMeta.exportAs,
                  isComponent: !!templateMeta,
                  type: this.getTypeMetadata(directiveType, moduleUrl),
                  template: templateMeta,
                  changeDetection: changeDetectionStrategy,
                  inputs: dirMeta.inputs,
                  outputs: dirMeta.outputs,
                  host: dirMeta.host,
                  providers: providers,
                  viewProviders: viewProviders,
                  queries: queries,
                  viewQueries: viewQueries,
                  entryComponents: entryComponentMetadata
              });
              this._directiveCache.set(directiveType, meta);
          }
          return meta;
      };
      CompileMetadataResolver.prototype.getNgModuleMetadata = function (moduleType, throwIfNotFound) {
          var _this = this;
          if (throwIfNotFound === void 0) { throwIfNotFound = true; }
          moduleType = _angular_core.resolveForwardRef(moduleType);
          var compileMeta = this._ngModuleCache.get(moduleType);
          if (!compileMeta) {
              var meta = this._ngModuleResolver.resolve(moduleType, throwIfNotFound);
              if (!meta) {
                  return null;
              }
              var declaredDirectives_1 = [];
              var exportedDirectives_1 = [];
              var declaredPipes_1 = [];
              var exportedPipes_1 = [];
              var importedModules_1 = [];
              var exportedModules_1 = [];
              var providers_1 = [];
              var entryComponents_1 = [];
              var bootstrapComponents = [];
              var schemas = [];
              if (meta.imports) {
                  flattenArray(meta.imports).forEach(function (importedType) {
                      var importedModuleType;
                      if (isValidType(importedType)) {
                          importedModuleType = importedType;
                      }
                      else if (importedType && importedType.ngModule) {
                          var moduleWithProviders = importedType;
                          importedModuleType = moduleWithProviders.ngModule;
                          if (moduleWithProviders.providers) {
                              providers_1.push.apply(providers_1, _this.getProvidersMetadata(moduleWithProviders.providers, entryComponents_1, "provider for the NgModule '" + stringify(importedModuleType) + "'"));
                          }
                      }
                      if (importedModuleType) {
                          var importedMeta = _this.getNgModuleMetadata(importedModuleType, false);
                          if (importedMeta === null) {
                              throw new Error("Unexpected " + _this._getTypeDescriptor(importedType) + " '" + stringify(importedType) + "' imported by the module '" + stringify(moduleType) + "'");
                          }
                          importedModules_1.push(importedMeta);
                      }
                      else {
                          throw new Error("Unexpected value '" + stringify(importedType) + "' imported by the module '" + stringify(moduleType) + "'");
                      }
                  });
              }
              if (meta.exports) {
                  flattenArray(meta.exports).forEach(function (exportedType) {
                      if (!isValidType(exportedType)) {
                          throw new Error("Unexpected value '" + stringify(exportedType) + "' exported by the module '" + stringify(moduleType) + "'");
                      }
                      var exportedDirMeta;
                      var exportedPipeMeta;
                      var exportedModuleMeta;
                      if (exportedDirMeta = _this.getDirectiveMetadata(exportedType, false)) {
                          exportedDirectives_1.push(exportedDirMeta);
                      }
                      else if (exportedPipeMeta = _this.getPipeMetadata(exportedType, false)) {
                          exportedPipes_1.push(exportedPipeMeta);
                      }
                      else if (exportedModuleMeta = _this.getNgModuleMetadata(exportedType, false)) {
                          exportedModules_1.push(exportedModuleMeta);
                      }
                      else {
                          throw new Error("Unexpected " + _this._getTypeDescriptor(exportedType) + " '" + stringify(exportedType) + "' exported by the module '" + stringify(moduleType) + "'");
                      }
                  });
              }
              // Note: This will be modified later, so we rely on
              // getting a new instance every time!
              var transitiveModule_1 = this._getTransitiveNgModuleMetadata(importedModules_1, exportedModules_1);
              if (meta.declarations) {
                  flattenArray(meta.declarations).forEach(function (declaredType) {
                      if (!isValidType(declaredType)) {
                          throw new Error("Unexpected value '" + stringify(declaredType) + "' declared by the module '" + stringify(moduleType) + "'");
                      }
                      var declaredDirMeta;
                      var declaredPipeMeta;
                      if (declaredDirMeta = _this.getDirectiveMetadata(declaredType, false)) {
                          _this._addDirectiveToModule(declaredDirMeta, moduleType, transitiveModule_1, declaredDirectives_1, true);
                      }
                      else if (declaredPipeMeta = _this.getPipeMetadata(declaredType, false)) {
                          _this._addPipeToModule(declaredPipeMeta, moduleType, transitiveModule_1, declaredPipes_1, true);
                      }
                      else {
                          throw new Error("Unexpected " + _this._getTypeDescriptor(declaredType) + " '" + stringify(declaredType) + "' declared by the module '" + stringify(moduleType) + "'");
                      }
                  });
              }
              // The providers of the module have to go last
              // so that they overwrite any other provider we already added.
              if (meta.providers) {
                  providers_1.push.apply(providers_1, this.getProvidersMetadata(meta.providers, entryComponents_1, "provider for the NgModule '" + stringify(moduleType) + "'"));
              }
              if (meta.entryComponents) {
                  entryComponents_1.push.apply(entryComponents_1, flattenArray(meta.entryComponents)
                      .map(function (type) { return _this.getTypeMetadata(type, staticTypeModuleUrl(type)); }));
              }
              if (meta.bootstrap) {
                  var typeMetadata = flattenArray(meta.bootstrap).map(function (type) {
                      if (!isValidType(type)) {
                          throw new Error("Unexpected value '" + stringify(type) + "' used in the bootstrap property of module '" + stringify(moduleType) + "'");
                      }
                      return _this.getTypeMetadata(type, staticTypeModuleUrl(type));
                  });
                  bootstrapComponents.push.apply(bootstrapComponents, typeMetadata);
              }
              entryComponents_1.push.apply(entryComponents_1, bootstrapComponents);
              if (meta.schemas) {
                  schemas.push.apply(schemas, flattenArray(meta.schemas));
              }
              (_a = transitiveModule_1.entryComponents).push.apply(_a, entryComponents_1);
              (_b = transitiveModule_1.providers).push.apply(_b, providers_1);
              compileMeta = new CompileNgModuleMetadata({
                  type: this.getTypeMetadata(moduleType, staticTypeModuleUrl(moduleType)),
                  providers: providers_1,
                  entryComponents: entryComponents_1,
                  bootstrapComponents: bootstrapComponents,
                  schemas: schemas,
                  declaredDirectives: declaredDirectives_1,
                  exportedDirectives: exportedDirectives_1,
                  declaredPipes: declaredPipes_1,
                  exportedPipes: exportedPipes_1,
                  importedModules: importedModules_1,
                  exportedModules: exportedModules_1,
                  transitiveModule: transitiveModule_1,
                  id: meta.id,
              });
              transitiveModule_1.modules.push(compileMeta);
              this._verifyModule(compileMeta);
              this._ngModuleCache.set(moduleType, compileMeta);
          }
          return compileMeta;
          var _a, _b;
      };
      CompileMetadataResolver.prototype._verifyModule = function (moduleMeta) {
          moduleMeta.exportedDirectives.forEach(function (dirMeta) {
              if (!moduleMeta.transitiveModule.directivesSet.has(dirMeta.type.reference)) {
                  throw new Error("Can't export directive " + stringify(dirMeta.type.reference) + " from " + stringify(moduleMeta.type.reference) + " as it was neither declared nor imported!");
              }
          });
          moduleMeta.exportedPipes.forEach(function (pipeMeta) {
              if (!moduleMeta.transitiveModule.pipesSet.has(pipeMeta.type.reference)) {
                  throw new Error("Can't export pipe " + stringify(pipeMeta.type.reference) + " from " + stringify(moduleMeta.type.reference) + " as it was neither declared nor imported!");
              }
          });
      };
      CompileMetadataResolver.prototype._getTypeDescriptor = function (type) {
          if (this._directiveResolver.resolve(type, false) !== null) {
              return 'directive';
          }
          if (this._pipeResolver.resolve(type, false) !== null) {
              return 'pipe';
          }
          if (this._ngModuleResolver.resolve(type, false) !== null) {
              return 'module';
          }
          if (type.provide) {
              return 'provider';
          }
          return 'value';
      };
      CompileMetadataResolver.prototype._addTypeToModule = function (type, moduleType) {
          var oldModule = this._ngModuleOfTypes.get(type);
          if (oldModule && oldModule !== moduleType) {
              throw new Error(("Type " + stringify(type) + " is part of the declarations of 2 modules: " + stringify(oldModule) + " and " + stringify(moduleType) + "! ") +
                  ("Please consider moving " + stringify(type) + " to a higher module that imports " + stringify(oldModule) + " and " + stringify(moduleType) + ". ") +
                  ("You can also create a new NgModule that exports and includes " + stringify(type) + " then import that NgModule in " + stringify(oldModule) + " and " + stringify(moduleType) + "."));
          }
          this._ngModuleOfTypes.set(type, moduleType);
      };
      CompileMetadataResolver.prototype._getTransitiveNgModuleMetadata = function (importedModules, exportedModules) {
          // collect `providers` / `entryComponents` from all imported and all exported modules
          var transitiveModules = getTransitiveModules(importedModules.concat(exportedModules), true);
          var providers = flattenArray(transitiveModules.map(function (ngModule) { return ngModule.providers; }));
          var entryComponents = flattenArray(transitiveModules.map(function (ngModule) { return ngModule.entryComponents; }));
          var transitiveExportedModules = getTransitiveModules(importedModules, false);
          var directives = flattenArray(transitiveExportedModules.map(function (ngModule) { return ngModule.exportedDirectives; }));
          var pipes = flattenArray(transitiveExportedModules.map(function (ngModule) { return ngModule.exportedPipes; }));
          return new TransitiveCompileNgModuleMetadata(transitiveModules, providers, entryComponents, directives, pipes);
      };
      CompileMetadataResolver.prototype._addDirectiveToModule = function (dirMeta, moduleType, transitiveModule, declaredDirectives, force) {
          if (force === void 0) { force = false; }
          if (force || !transitiveModule.directivesSet.has(dirMeta.type.reference)) {
              transitiveModule.directivesSet.add(dirMeta.type.reference);
              transitiveModule.directives.push(dirMeta);
              declaredDirectives.push(dirMeta);
              this._addTypeToModule(dirMeta.type.reference, moduleType);
              return true;
          }
          return false;
      };
      CompileMetadataResolver.prototype._addPipeToModule = function (pipeMeta, moduleType, transitiveModule, declaredPipes, force) {
          if (force === void 0) { force = false; }
          if (force || !transitiveModule.pipesSet.has(pipeMeta.type.reference)) {
              transitiveModule.pipesSet.add(pipeMeta.type.reference);
              transitiveModule.pipes.push(pipeMeta);
              declaredPipes.push(pipeMeta);
              this._addTypeToModule(pipeMeta.type.reference, moduleType);
              return true;
          }
          return false;
      };
      CompileMetadataResolver.prototype.getTypeMetadata = function (type, moduleUrl, dependencies) {
          if (dependencies === void 0) { dependencies = null; }
          type = _angular_core.resolveForwardRef(type);
          return new CompileTypeMetadata({
              name: this.sanitizeTokenName(type),
              moduleUrl: moduleUrl,
              reference: type,
              diDeps: this.getDependenciesMetadata(type, dependencies),
              lifecycleHooks: LIFECYCLE_HOOKS_VALUES.filter(function (hook) { return hasLifecycleHook(hook, type); }),
          });
      };
      CompileMetadataResolver.prototype.getFactoryMetadata = function (factory, moduleUrl, dependencies) {
          if (dependencies === void 0) { dependencies = null; }
          factory = _angular_core.resolveForwardRef(factory);
          return new CompileFactoryMetadata({
              name: this.sanitizeTokenName(factory),
              moduleUrl: moduleUrl,
              reference: factory,
              diDeps: this.getDependenciesMetadata(factory, dependencies)
          });
      };
      CompileMetadataResolver.prototype.getPipeMetadata = function (pipeType, throwIfNotFound) {
          if (throwIfNotFound === void 0) { throwIfNotFound = true; }
          pipeType = _angular_core.resolveForwardRef(pipeType);
          var meta = this._pipeCache.get(pipeType);
          if (!meta) {
              var pipeMeta = this._pipeResolver.resolve(pipeType, throwIfNotFound);
              if (!pipeMeta) {
                  return null;
              }
              meta = new CompilePipeMetadata({
                  type: this.getTypeMetadata(pipeType, staticTypeModuleUrl(pipeType)),
                  name: pipeMeta.name,
                  pure: pipeMeta.pure
              });
              this._pipeCache.set(pipeType, meta);
          }
          return meta;
      };
      CompileMetadataResolver.prototype.getDependenciesMetadata = function (typeOrFunc, dependencies) {
          var _this = this;
          var hasUnknownDeps = false;
          var params = dependencies || this._reflector.parameters(typeOrFunc) || [];
          var dependenciesMetadata = params.map(function (param) {
              var isAttribute = false;
              var isHost = false;
              var isSelf = false;
              var isSkipSelf = false;
              var isOptional = false;
              var query = null;
              var viewQuery = null;
              var token = null;
              if (Array.isArray(param)) {
                  param.forEach(function (paramEntry) {
                      if (paramEntry instanceof _angular_core.Host) {
                          isHost = true;
                      }
                      else if (paramEntry instanceof _angular_core.Self) {
                          isSelf = true;
                      }
                      else if (paramEntry instanceof _angular_core.SkipSelf) {
                          isSkipSelf = true;
                      }
                      else if (paramEntry instanceof _angular_core.Optional) {
                          isOptional = true;
                      }
                      else if (paramEntry instanceof _angular_core.Attribute) {
                          isAttribute = true;
                          token = paramEntry.attributeName;
                      }
                      else if (paramEntry instanceof _angular_core.Query) {
                          if (paramEntry.isViewQuery) {
                              viewQuery = paramEntry;
                          }
                          else {
                              query = paramEntry;
                          }
                      }
                      else if (paramEntry instanceof _angular_core.Inject) {
                          token = paramEntry.token;
                      }
                      else if (isValidType(paramEntry) && isBlank(token)) {
                          token = paramEntry;
                      }
                  });
              }
              else {
                  token = param;
              }
              if (isBlank(token)) {
                  hasUnknownDeps = true;
                  return null;
              }
              return new CompileDiDependencyMetadata({
                  isAttribute: isAttribute,
                  isHost: isHost,
                  isSelf: isSelf,
                  isSkipSelf: isSkipSelf,
                  isOptional: isOptional,
                  query: query ? _this.getQueryMetadata(query, null, typeOrFunc) : null,
                  viewQuery: viewQuery ? _this.getQueryMetadata(viewQuery, null, typeOrFunc) : null,
                  token: _this.getTokenMetadata(token)
              });
          });
          if (hasUnknownDeps) {
              var depsTokens = dependenciesMetadata.map(function (dep) { return dep ? stringify(dep.token) : '?'; }).join(', ');
              throw new Error("Can't resolve all parameters for " + stringify(typeOrFunc) + ": (" + depsTokens + ").");
          }
          return dependenciesMetadata;
      };
      CompileMetadataResolver.prototype.getTokenMetadata = function (token) {
          token = _angular_core.resolveForwardRef(token);
          var compileToken;
          if (typeof token === 'string') {
              compileToken = new CompileTokenMetadata({ value: token });
          }
          else {
              compileToken = new CompileTokenMetadata({
                  identifier: new CompileIdentifierMetadata({
                      reference: token,
                      name: this.sanitizeTokenName(token),
                      moduleUrl: staticTypeModuleUrl(token)
                  })
              });
          }
          return compileToken;
      };
      CompileMetadataResolver.prototype.getProvidersMetadata = function (providers, targetEntryComponents, debugInfo) {
          var _this = this;
          var compileProviders = [];
          providers.forEach(function (provider, providerIdx) {
              provider = _angular_core.resolveForwardRef(provider);
              if (provider && typeof provider == 'object' && provider.hasOwnProperty('provide')) {
                  provider = new ProviderMeta(provider.provide, provider);
              }
              var compileProvider;
              if (Array.isArray(provider)) {
                  compileProvider = _this.getProvidersMetadata(provider, targetEntryComponents, debugInfo);
              }
              else if (provider instanceof ProviderMeta) {
                  var tokenMeta = _this.getTokenMetadata(provider.token);
                  if (tokenMeta.reference ===
                      resolveIdentifierToken(Identifiers.ANALYZE_FOR_ENTRY_COMPONENTS).reference) {
                      targetEntryComponents.push.apply(targetEntryComponents, _this._getEntryComponentsFromProvider(provider));
                  }
                  else {
                      compileProvider = _this.getProviderMetadata(provider);
                  }
              }
              else if (isValidType(provider)) {
                  compileProvider = _this.getTypeMetadata(provider, staticTypeModuleUrl(provider));
              }
              else {
                  var providersInfo = providers.reduce(function (soFar, seenProvider, seenProviderIdx) {
                      if (seenProviderIdx < providerIdx) {
                          soFar.push("" + stringify(seenProvider));
                      }
                      else if (seenProviderIdx == providerIdx) {
                          soFar.push("?" + stringify(seenProvider) + "?");
                      }
                      else if (seenProviderIdx == providerIdx + 1) {
                          soFar.push('...');
                      }
                      return soFar;
                  }, [])
                      .join(', ');
                  throw new Error("Invalid " + (debugInfo ? debugInfo : 'provider') + " - only instances of Provider and Type are allowed, got: [" + providersInfo + "]");
              }
              if (compileProvider) {
                  compileProviders.push(compileProvider);
              }
          });
          return compileProviders;
      };
      CompileMetadataResolver.prototype._getEntryComponentsFromProvider = function (provider) {
          var _this = this;
          var components = [];
          var collectedIdentifiers = [];
          if (provider.useFactory || provider.useExisting || provider.useClass) {
              throw new Error("The ANALYZE_FOR_ENTRY_COMPONENTS token only supports useValue!");
          }
          if (!provider.multi) {
              throw new Error("The ANALYZE_FOR_ENTRY_COMPONENTS token only supports 'multi = true'!");
          }
          convertToCompileValue(provider.useValue, collectedIdentifiers);
          collectedIdentifiers.forEach(function (identifier) {
              var dirMeta = _this.getDirectiveMetadata(identifier.reference, false);
              if (dirMeta) {
                  components.push(dirMeta.type);
              }
          });
          return components;
      };
      CompileMetadataResolver.prototype.getProviderMetadata = function (provider) {
          var compileDeps;
          var compileTypeMetadata = null;
          var compileFactoryMetadata = null;
          if (provider.useClass) {
              compileTypeMetadata = this.getTypeMetadata(provider.useClass, staticTypeModuleUrl(provider.useClass), provider.dependencies);
              compileDeps = compileTypeMetadata.diDeps;
          }
          else if (provider.useFactory) {
              compileFactoryMetadata = this.getFactoryMetadata(provider.useFactory, staticTypeModuleUrl(provider.useFactory), provider.dependencies);
              compileDeps = compileFactoryMetadata.diDeps;
          }
          return new CompileProviderMetadata({
              token: this.getTokenMetadata(provider.token),
              useClass: compileTypeMetadata,
              useValue: convertToCompileValue(provider.useValue, []),
              useFactory: compileFactoryMetadata,
              useExisting: provider.useExisting ? this.getTokenMetadata(provider.useExisting) : null,
              deps: compileDeps,
              multi: provider.multi
          });
      };
      CompileMetadataResolver.prototype.getQueriesMetadata = function (queries, isViewQuery, directiveType) {
          var _this = this;
          var res = [];
          Object.keys(queries).forEach(function (propertyName) {
              var query = queries[propertyName];
              if (query.isViewQuery === isViewQuery) {
                  res.push(_this.getQueryMetadata(query, propertyName, directiveType));
              }
          });
          return res;
      };
      CompileMetadataResolver.prototype._queryVarBindings = function (selector) { return selector.split(/\s*,\s*/); };
      CompileMetadataResolver.prototype.getQueryMetadata = function (q, propertyName, typeOrFunc) {
          var _this = this;
          var selectors;
          if (typeof q.selector === 'string') {
              selectors = this._queryVarBindings(q.selector).map(function (varName) { return _this.getTokenMetadata(varName); });
          }
          else {
              if (!q.selector) {
                  throw new Error("Can't construct a query for the property \"" + propertyName + "\" of \"" + stringify(typeOrFunc) + "\" since the query selector wasn't defined.");
              }
              selectors = [this.getTokenMetadata(q.selector)];
          }
          return new CompileQueryMetadata({
              selectors: selectors,
              first: q.first,
              descendants: q.descendants, propertyName: propertyName,
              read: q.read ? this.getTokenMetadata(q.read) : null
          });
      };
      CompileMetadataResolver.decorators = [
          { type: _angular_core.Injectable },
      ];
      /** @nocollapse */
      CompileMetadataResolver.ctorParameters = [
          { type: NgModuleResolver, },
          { type: DirectiveResolver, },
          { type: PipeResolver, },
          { type: ElementSchemaRegistry, },
          { type: ReflectorReader, },
      ];
      return CompileMetadataResolver;
  }());
  function getTransitiveModules(modules, includeImports, targetModules, visitedModules) {
      if (targetModules === void 0) { targetModules = []; }
      if (visitedModules === void 0) { visitedModules = new Set(); }
      modules.forEach(function (ngModule) {
          if (!visitedModules.has(ngModule.type.reference)) {
              visitedModules.add(ngModule.type.reference);
              var nestedModules = includeImports ?
                  ngModule.importedModules.concat(ngModule.exportedModules) :
                  ngModule.exportedModules;
              getTransitiveModules(nestedModules, includeImports, targetModules, visitedModules);
              // Add after recursing so imported/exported modules are before the module itself.
              // This is important for overwriting providers of imported modules!
              targetModules.push(ngModule);
          }
      });
      return targetModules;
  }
  function flattenArray(tree, out) {
      if (out === void 0) { out = []; }
      if (tree) {
          for (var i = 0; i < tree.length; i++) {
              var item = _angular_core.resolveForwardRef(tree[i]);
              if (Array.isArray(item)) {
                  flattenArray(item, out);
              }
              else {
                  out.push(item);
              }
          }
      }
      return out;
  }
  function isValidType(value) {
      return isStaticSymbol(value) || (value instanceof _angular_core.Type);
  }
  function staticTypeModuleUrl(value) {
      return isStaticSymbol(value) ? value.filePath : null;
  }
  function componentModuleUrl(reflector, type, cmpMetadata) {
      if (isStaticSymbol(type)) {
          return staticTypeModuleUrl(type);
      }
      var moduleId = cmpMetadata.moduleId;
      if (typeof moduleId === 'string') {
          var scheme = getUrlScheme(moduleId);
          return scheme ? moduleId : "package:" + moduleId + MODULE_SUFFIX;
      }
      else if (moduleId !== null && moduleId !== void 0) {
          throw new Error(("moduleId should be a string in \"" + stringify(type) + "\". See https://goo.gl/wIDDiL for more information.\n") +
              "If you're using Webpack you should inline the template and the styles, see https://goo.gl/X2J8zc.");
      }
      return reflector.importUri(type);
  }
  function convertToCompileValue(value, targetIdentifiers) {
      return visitValue(value, new _CompileValueConverter(), targetIdentifiers);
  }
  var _CompileValueConverter = (function (_super) {
      __extends$16(_CompileValueConverter, _super);
      function _CompileValueConverter() {
          _super.apply(this, arguments);
      }
      _CompileValueConverter.prototype.visitOther = function (value, targetIdentifiers) {
          var identifier;
          if (isStaticSymbol(value)) {
              identifier = new CompileIdentifierMetadata({ name: value.name, moduleUrl: value.filePath, reference: value });
          }
          else {
              identifier = new CompileIdentifierMetadata({ reference: value });
          }
          targetIdentifiers.push(identifier);
          return identifier;
      };
      return _CompileValueConverter;
  }(ValueTransformer));

  var ComponentFactoryDependency$1 = (function () {
      function ComponentFactoryDependency(comp, placeholder) {
          this.comp = comp;
          this.placeholder = placeholder;
      }
      return ComponentFactoryDependency;
  }());
  var NgModuleCompileResult = (function () {
      function NgModuleCompileResult(statements, ngModuleFactoryVar, dependencies) {
          this.statements = statements;
          this.ngModuleFactoryVar = ngModuleFactoryVar;
          this.dependencies = dependencies;
      }
      return NgModuleCompileResult;
  }());
  var NgModuleCompiler = (function () {
      function NgModuleCompiler() {
      }
      NgModuleCompiler.prototype.compile = function (ngModuleMeta, extraProviders) {
          var sourceFileName = isPresent(ngModuleMeta.type.moduleUrl) ?
              "in NgModule " + ngModuleMeta.type.name + " in " + ngModuleMeta.type.moduleUrl :
              "in NgModule " + ngModuleMeta.type.name;
          var sourceFile = new ParseSourceFile('', sourceFileName);
          var sourceSpan = new ParseSourceSpan(new ParseLocation(sourceFile, null, null, null), new ParseLocation(sourceFile, null, null, null));
          var deps = [];
          var bootstrapComponentFactories = [];
          var entryComponentFactories = ngModuleMeta.transitiveModule.entryComponents.map(function (entryComponent) {
              var id = new CompileIdentifierMetadata({ name: entryComponent.name });
              if (ngModuleMeta.bootstrapComponents.indexOf(entryComponent) > -1) {
                  bootstrapComponentFactories.push(id);
              }
              deps.push(new ComponentFactoryDependency$1(entryComponent, id));
              return id;
          });
          var builder = new _InjectorBuilder(ngModuleMeta, entryComponentFactories, bootstrapComponentFactories, sourceSpan);
          var providerParser = new NgModuleProviderAnalyzer(ngModuleMeta, extraProviders, sourceSpan);
          providerParser.parse().forEach(function (provider) { return builder.addProvider(provider); });
          var injectorClass = builder.build();
          var ngModuleFactoryVar = ngModuleMeta.type.name + "NgFactory";
          var ngModuleFactoryStmt = variable(ngModuleFactoryVar)
              .set(importExpr(resolveIdentifier(Identifiers.NgModuleFactory))
              .instantiate([variable(injectorClass.name), importExpr(ngModuleMeta.type)], importType(resolveIdentifier(Identifiers.NgModuleFactory), [importType(ngModuleMeta.type)], [TypeModifier.Const])))
              .toDeclStmt(null, [StmtModifier.Final]);
          var stmts = [injectorClass, ngModuleFactoryStmt];
          if (ngModuleMeta.id) {
              var registerFactoryStmt = importExpr(resolveIdentifier(Identifiers.RegisterModuleFactoryFn))
                  .callFn([literal(ngModuleMeta.id), variable(ngModuleFactoryVar)])
                  .toStmt();
              stmts.push(registerFactoryStmt);
          }
          return new NgModuleCompileResult(stmts, ngModuleFactoryVar, deps);
      };
      NgModuleCompiler.decorators = [
          { type: _angular_core.Injectable },
      ];
      /** @nocollapse */
      NgModuleCompiler.ctorParameters = [];
      return NgModuleCompiler;
  }());
  var _InjectorBuilder = (function () {
      function _InjectorBuilder(_ngModuleMeta, _entryComponentFactories, _bootstrapComponentFactories, _sourceSpan) {
          this._ngModuleMeta = _ngModuleMeta;
          this._entryComponentFactories = _entryComponentFactories;
          this._bootstrapComponentFactories = _bootstrapComponentFactories;
          this._sourceSpan = _sourceSpan;
          this._tokens = [];
          this._instances = new Map();
          this._fields = [];
          this._createStmts = [];
          this._destroyStmts = [];
          this._getters = [];
      }
      _InjectorBuilder.prototype.addProvider = function (resolvedProvider) {
          var _this = this;
          var providerValueExpressions = resolvedProvider.providers.map(function (provider) { return _this._getProviderValue(provider); });
          var propName = "_" + resolvedProvider.token.name + "_" + this._instances.size;
          var instance = this._createProviderProperty(propName, resolvedProvider, providerValueExpressions, resolvedProvider.multiProvider, resolvedProvider.eager);
          if (resolvedProvider.lifecycleHooks.indexOf(LifecycleHooks.OnDestroy) !== -1) {
              this._destroyStmts.push(instance.callMethod('ngOnDestroy', []).toStmt());
          }
          this._tokens.push(resolvedProvider.token);
          this._instances.set(resolvedProvider.token.reference, instance);
      };
      _InjectorBuilder.prototype.build = function () {
          var _this = this;
          var getMethodStmts = this._tokens.map(function (token) {
              var providerExpr = _this._instances.get(token.reference);
              return new IfStmt(InjectMethodVars$1.token.identical(createDiTokenExpression(token)), [new ReturnStatement(providerExpr)]);
          });
          var methods = [
              new ClassMethod('createInternal', [], this._createStmts.concat(new ReturnStatement(this._instances.get(this._ngModuleMeta.type.reference))), importType(this._ngModuleMeta.type)),
              new ClassMethod('getInternal', [
                  new FnParam(InjectMethodVars$1.token.name, DYNAMIC_TYPE),
                  new FnParam(InjectMethodVars$1.notFoundResult.name, DYNAMIC_TYPE)
              ], getMethodStmts.concat([new ReturnStatement(InjectMethodVars$1.notFoundResult)]), DYNAMIC_TYPE),
              new ClassMethod('destroyInternal', [], this._destroyStmts),
          ];
          var ctor = new ClassMethod(null, [new FnParam(InjectorProps.parent.name, importType(resolveIdentifier(Identifiers.Injector)))], [SUPER_EXPR
                  .callFn([
                  variable(InjectorProps.parent.name),
                  literalArr(this._entryComponentFactories.map(function (componentFactory) { return importExpr(componentFactory); })),
                  literalArr(this._bootstrapComponentFactories.map(function (componentFactory) { return importExpr(componentFactory); }))
              ])
                  .toStmt()]);
          var injClassName = this._ngModuleMeta.type.name + "Injector";
          return new ClassStmt(injClassName, importExpr(resolveIdentifier(Identifiers.NgModuleInjector), [importType(this._ngModuleMeta.type)]), this._fields, this._getters, ctor, methods);
      };
      _InjectorBuilder.prototype._getProviderValue = function (provider) {
          var _this = this;
          var result;
          if (isPresent(provider.useExisting)) {
              result = this._getDependency(new CompileDiDependencyMetadata({ token: provider.useExisting }));
          }
          else if (isPresent(provider.useFactory)) {
              var deps = provider.deps || provider.useFactory.diDeps;
              var depsExpr = deps.map(function (dep) { return _this._getDependency(dep); });
              result = importExpr(provider.useFactory).callFn(depsExpr);
          }
          else if (isPresent(provider.useClass)) {
              var deps = provider.deps || provider.useClass.diDeps;
              var depsExpr = deps.map(function (dep) { return _this._getDependency(dep); });
              result =
                  importExpr(provider.useClass).instantiate(depsExpr, importType(provider.useClass));
          }
          else {
              result = convertValueToOutputAst(provider.useValue);
          }
          return result;
      };
      _InjectorBuilder.prototype._createProviderProperty = function (propName, provider, providerValueExpressions, isMulti, isEager) {
          var resolvedProviderValueExpr;
          var type;
          if (isMulti) {
              resolvedProviderValueExpr = literalArr(providerValueExpressions);
              type = new ArrayType(DYNAMIC_TYPE);
          }
          else {
              resolvedProviderValueExpr = providerValueExpressions[0];
              type = providerValueExpressions[0].type;
          }
          if (!type) {
              type = DYNAMIC_TYPE;
          }
          if (isEager) {
              this._fields.push(new ClassField(propName, type));
              this._createStmts.push(THIS_EXPR.prop(propName).set(resolvedProviderValueExpr).toStmt());
          }
          else {
              var internalField = "_" + propName;
              this._fields.push(new ClassField(internalField, type));
              // Note: Equals is important for JS so that it also checks the undefined case!
              var getterStmts = [
                  new IfStmt(THIS_EXPR.prop(internalField).isBlank(), [THIS_EXPR.prop(internalField).set(resolvedProviderValueExpr).toStmt()]),
                  new ReturnStatement(THIS_EXPR.prop(internalField))
              ];
              this._getters.push(new ClassGetter(propName, getterStmts, type));
          }
          return THIS_EXPR.prop(propName);
      };
      _InjectorBuilder.prototype._getDependency = function (dep) {
          var result = null;
          if (dep.isValue) {
              result = literal(dep.value);
          }
          if (!dep.isSkipSelf) {
              if (dep.token &&
                  (dep.token.reference === resolveIdentifierToken(Identifiers.Injector).reference ||
                      dep.token.reference ===
                          resolveIdentifierToken(Identifiers.ComponentFactoryResolver).reference)) {
                  result = THIS_EXPR;
              }
              if (!result) {
                  result = this._instances.get(dep.token.reference);
              }
          }
          if (!result) {
              var args = [createDiTokenExpression(dep.token)];
              if (dep.isOptional) {
                  args.push(NULL_EXPR);
              }
              result = InjectorProps.parent.callMethod('get', args);
          }
          return result;
      };
      return _InjectorBuilder;
  }());
  var InjectorProps = (function () {
      function InjectorProps() {
      }
      InjectorProps.parent = THIS_EXPR.prop('parent');
      return InjectorProps;
  }());
  var InjectMethodVars$1 = (function () {
      function InjectMethodVars() {
      }
      InjectMethodVars.token = variable('token');
      InjectMethodVars.notFoundResult = variable('notFoundResult');
      return InjectMethodVars;
  }());

  var _SINGLE_QUOTE_ESCAPE_STRING_RE = /'|\\|\n|\r|\$/g;
  var _LEGAL_IDENTIFIER_RE = /^[$A-Z_][0-9A-Z_$]*$/i;
  var CATCH_ERROR_VAR$2 = variable('error');
  var CATCH_STACK_VAR$2 = variable('stack');
  var _EmittedLine = (function () {
      function _EmittedLine(indent) {
          this.indent = indent;
          this.parts = [];
      }
      return _EmittedLine;
  }());
  var EmitterVisitorContext = (function () {
      function EmitterVisitorContext(_exportedVars, _indent) {
          this._exportedVars = _exportedVars;
          this._indent = _indent;
          this._classes = [];
          this._lines = [new _EmittedLine(_indent)];
      }
      EmitterVisitorContext.createRoot = function (exportedVars) {
          return new EmitterVisitorContext(exportedVars, 0);
      };
      Object.defineProperty(EmitterVisitorContext.prototype, "_currentLine", {
          get: function () { return this._lines[this._lines.length - 1]; },
          enumerable: true,
          configurable: true
      });
      EmitterVisitorContext.prototype.isExportedVar = function (varName) { return this._exportedVars.indexOf(varName) !== -1; };
      EmitterVisitorContext.prototype.println = function (lastPart) {
          if (lastPart === void 0) { lastPart = ''; }
          this.print(lastPart, true);
      };
      EmitterVisitorContext.prototype.lineIsEmpty = function () { return this._currentLine.parts.length === 0; };
      EmitterVisitorContext.prototype.print = function (part, newLine) {
          if (newLine === void 0) { newLine = false; }
          if (part.length > 0) {
              this._currentLine.parts.push(part);
          }
          if (newLine) {
              this._lines.push(new _EmittedLine(this._indent));
          }
      };
      EmitterVisitorContext.prototype.removeEmptyLastLine = function () {
          if (this.lineIsEmpty()) {
              this._lines.pop();
          }
      };
      EmitterVisitorContext.prototype.incIndent = function () {
          this._indent++;
          this._currentLine.indent = this._indent;
      };
      EmitterVisitorContext.prototype.decIndent = function () {
          this._indent--;
          this._currentLine.indent = this._indent;
      };
      EmitterVisitorContext.prototype.pushClass = function (clazz) { this._classes.push(clazz); };
      EmitterVisitorContext.prototype.popClass = function () { return this._classes.pop(); };
      Object.defineProperty(EmitterVisitorContext.prototype, "currentClass", {
          get: function () {
              return this._classes.length > 0 ? this._classes[this._classes.length - 1] : null;
          },
          enumerable: true,
          configurable: true
      });
      EmitterVisitorContext.prototype.toSource = function () {
          var lines = this._lines;
          if (lines[lines.length - 1].parts.length === 0) {
              lines = lines.slice(0, lines.length - 1);
          }
          return lines
              .map(function (line) {
              if (line.parts.length > 0) {
                  return _createIndent(line.indent) + line.parts.join('');
              }
              else {
                  return '';
              }
          })
              .join('\n');
      };
      return EmitterVisitorContext;
  }());
  var AbstractEmitterVisitor = (function () {
      function AbstractEmitterVisitor(_escapeDollarInStrings) {
          this._escapeDollarInStrings = _escapeDollarInStrings;
      }
      AbstractEmitterVisitor.prototype.visitExpressionStmt = function (stmt, ctx) {
          stmt.expr.visitExpression(this, ctx);
          ctx.println(';');
          return null;
      };
      AbstractEmitterVisitor.prototype.visitReturnStmt = function (stmt, ctx) {
          ctx.print("return ");
          stmt.value.visitExpression(this, ctx);
          ctx.println(';');
          return null;
      };
      AbstractEmitterVisitor.prototype.visitIfStmt = function (stmt, ctx) {
          ctx.print("if (");
          stmt.condition.visitExpression(this, ctx);
          ctx.print(") {");
          var hasElseCase = isPresent(stmt.falseCase) && stmt.falseCase.length > 0;
          if (stmt.trueCase.length <= 1 && !hasElseCase) {
              ctx.print(" ");
              this.visitAllStatements(stmt.trueCase, ctx);
              ctx.removeEmptyLastLine();
              ctx.print(" ");
          }
          else {
              ctx.println();
              ctx.incIndent();
              this.visitAllStatements(stmt.trueCase, ctx);
              ctx.decIndent();
              if (hasElseCase) {
                  ctx.println("} else {");
                  ctx.incIndent();
                  this.visitAllStatements(stmt.falseCase, ctx);
                  ctx.decIndent();
              }
          }
          ctx.println("}");
          return null;
      };
      AbstractEmitterVisitor.prototype.visitThrowStmt = function (stmt, ctx) {
          ctx.print("throw ");
          stmt.error.visitExpression(this, ctx);
          ctx.println(";");
          return null;
      };
      AbstractEmitterVisitor.prototype.visitCommentStmt = function (stmt, ctx) {
          var lines = stmt.comment.split('\n');
          lines.forEach(function (line) { ctx.println("// " + line); });
          return null;
      };
      AbstractEmitterVisitor.prototype.visitWriteVarExpr = function (expr, ctx) {
          var lineWasEmpty = ctx.lineIsEmpty();
          if (!lineWasEmpty) {
              ctx.print('(');
          }
          ctx.print(expr.name + " = ");
          expr.value.visitExpression(this, ctx);
          if (!lineWasEmpty) {
              ctx.print(')');
          }
          return null;
      };
      AbstractEmitterVisitor.prototype.visitWriteKeyExpr = function (expr, ctx) {
          var lineWasEmpty = ctx.lineIsEmpty();
          if (!lineWasEmpty) {
              ctx.print('(');
          }
          expr.receiver.visitExpression(this, ctx);
          ctx.print("[");
          expr.index.visitExpression(this, ctx);
          ctx.print("] = ");
          expr.value.visitExpression(this, ctx);
          if (!lineWasEmpty) {
              ctx.print(')');
          }
          return null;
      };
      AbstractEmitterVisitor.prototype.visitWritePropExpr = function (expr, ctx) {
          var lineWasEmpty = ctx.lineIsEmpty();
          if (!lineWasEmpty) {
              ctx.print('(');
          }
          expr.receiver.visitExpression(this, ctx);
          ctx.print("." + expr.name + " = ");
          expr.value.visitExpression(this, ctx);
          if (!lineWasEmpty) {
              ctx.print(')');
          }
          return null;
      };
      AbstractEmitterVisitor.prototype.visitInvokeMethodExpr = function (expr, ctx) {
          expr.receiver.visitExpression(this, ctx);
          var name = expr.name;
          if (isPresent(expr.builtin)) {
              name = this.getBuiltinMethodName(expr.builtin);
              if (isBlank(name)) {
                  // some builtins just mean to skip the call.
                  return null;
              }
          }
          ctx.print("." + name + "(");
          this.visitAllExpressions(expr.args, ctx, ",");
          ctx.print(")");
          return null;
      };
      AbstractEmitterVisitor.prototype.visitInvokeFunctionExpr = function (expr, ctx) {
          expr.fn.visitExpression(this, ctx);
          ctx.print("(");
          this.visitAllExpressions(expr.args, ctx, ',');
          ctx.print(")");
          return null;
      };
      AbstractEmitterVisitor.prototype.visitReadVarExpr = function (ast, ctx) {
          var varName = ast.name;
          if (isPresent(ast.builtin)) {
              switch (ast.builtin) {
                  case BuiltinVar.Super:
                      varName = 'super';
                      break;
                  case BuiltinVar.This:
                      varName = 'this';
                      break;
                  case BuiltinVar.CatchError:
                      varName = CATCH_ERROR_VAR$2.name;
                      break;
                  case BuiltinVar.CatchStack:
                      varName = CATCH_STACK_VAR$2.name;
                      break;
                  default:
                      throw new Error("Unknown builtin variable " + ast.builtin);
              }
          }
          ctx.print(varName);
          return null;
      };
      AbstractEmitterVisitor.prototype.visitInstantiateExpr = function (ast, ctx) {
          ctx.print("new ");
          ast.classExpr.visitExpression(this, ctx);
          ctx.print("(");
          this.visitAllExpressions(ast.args, ctx, ',');
          ctx.print(")");
          return null;
      };
      AbstractEmitterVisitor.prototype.visitLiteralExpr = function (ast, ctx, absentValue) {
          if (absentValue === void 0) { absentValue = 'null'; }
          var value = ast.value;
          if (typeof value === 'string') {
              ctx.print(escapeIdentifier(value, this._escapeDollarInStrings));
          }
          else if (isBlank(value)) {
              ctx.print(absentValue);
          }
          else {
              ctx.print("" + value);
          }
          return null;
      };
      AbstractEmitterVisitor.prototype.visitConditionalExpr = function (ast, ctx) {
          ctx.print("(");
          ast.condition.visitExpression(this, ctx);
          ctx.print('? ');
          ast.trueCase.visitExpression(this, ctx);
          ctx.print(': ');
          ast.falseCase.visitExpression(this, ctx);
          ctx.print(")");
          return null;
      };
      AbstractEmitterVisitor.prototype.visitNotExpr = function (ast, ctx) {
          ctx.print('!');
          ast.condition.visitExpression(this, ctx);
          return null;
      };
      AbstractEmitterVisitor.prototype.visitBinaryOperatorExpr = function (ast, ctx) {
          var opStr;
          switch (ast.operator) {
              case BinaryOperator.Equals:
                  opStr = '==';
                  break;
              case BinaryOperator.Identical:
                  opStr = '===';
                  break;
              case BinaryOperator.NotEquals:
                  opStr = '!=';
                  break;
              case BinaryOperator.NotIdentical:
                  opStr = '!==';
                  break;
              case BinaryOperator.And:
                  opStr = '&&';
                  break;
              case BinaryOperator.Or:
                  opStr = '||';
                  break;
              case BinaryOperator.Plus:
                  opStr = '+';
                  break;
              case BinaryOperator.Minus:
                  opStr = '-';
                  break;
              case BinaryOperator.Divide:
                  opStr = '/';
                  break;
              case BinaryOperator.Multiply:
                  opStr = '*';
                  break;
              case BinaryOperator.Modulo:
                  opStr = '%';
                  break;
              case BinaryOperator.Lower:
                  opStr = '<';
                  break;
              case BinaryOperator.LowerEquals:
                  opStr = '<=';
                  break;
              case BinaryOperator.Bigger:
                  opStr = '>';
                  break;
              case BinaryOperator.BiggerEquals:
                  opStr = '>=';
                  break;
              default:
                  throw new Error("Unknown operator " + ast.operator);
          }
          ctx.print("(");
          ast.lhs.visitExpression(this, ctx);
          ctx.print(" " + opStr + " ");
          ast.rhs.visitExpression(this, ctx);
          ctx.print(")");
          return null;
      };
      AbstractEmitterVisitor.prototype.visitReadPropExpr = function (ast, ctx) {
          ast.receiver.visitExpression(this, ctx);
          ctx.print(".");
          ctx.print(ast.name);
          return null;
      };
      AbstractEmitterVisitor.prototype.visitReadKeyExpr = function (ast, ctx) {
          ast.receiver.visitExpression(this, ctx);
          ctx.print("[");
          ast.index.visitExpression(this, ctx);
          ctx.print("]");
          return null;
      };
      AbstractEmitterVisitor.prototype.visitLiteralArrayExpr = function (ast, ctx) {
          var useNewLine = ast.entries.length > 1;
          ctx.print("[", useNewLine);
          ctx.incIndent();
          this.visitAllExpressions(ast.entries, ctx, ',', useNewLine);
          ctx.decIndent();
          ctx.print("]", useNewLine);
          return null;
      };
      AbstractEmitterVisitor.prototype.visitLiteralMapExpr = function (ast, ctx) {
          var _this = this;
          var useNewLine = ast.entries.length > 1;
          ctx.print("{", useNewLine);
          ctx.incIndent();
          this.visitAllObjects(function (entry) {
              ctx.print(escapeIdentifier(entry[0], _this._escapeDollarInStrings, false) + ": ");
              entry[1].visitExpression(_this, ctx);
          }, ast.entries, ctx, ',', useNewLine);
          ctx.decIndent();
          ctx.print("}", useNewLine);
          return null;
      };
      AbstractEmitterVisitor.prototype.visitAllExpressions = function (expressions, ctx, separator, newLine) {
          var _this = this;
          if (newLine === void 0) { newLine = false; }
          this.visitAllObjects(function (expr) { return expr.visitExpression(_this, ctx); }, expressions, ctx, separator, newLine);
      };
      AbstractEmitterVisitor.prototype.visitAllObjects = function (handler, expressions, ctx, separator, newLine) {
          if (newLine === void 0) { newLine = false; }
          for (var i = 0; i < expressions.length; i++) {
              if (i > 0) {
                  ctx.print(separator, newLine);
              }
              handler(expressions[i]);
          }
          if (newLine) {
              ctx.println();
          }
      };
      AbstractEmitterVisitor.prototype.visitAllStatements = function (statements, ctx) {
          var _this = this;
          statements.forEach(function (stmt) { return stmt.visitStatement(_this, ctx); });
      };
      return AbstractEmitterVisitor;
  }());
  function escapeIdentifier(input, escapeDollar, alwaysQuote) {
      if (alwaysQuote === void 0) { alwaysQuote = true; }
      if (isBlank(input)) {
          return null;
      }
      var body = input.replace(_SINGLE_QUOTE_ESCAPE_STRING_RE, function () {
          var match = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              match[_i - 0] = arguments[_i];
          }
          if (match[0] == '$') {
              return escapeDollar ? '\\$' : '$';
          }
          else if (match[0] == '\n') {
              return '\\n';
          }
          else if (match[0] == '\r') {
              return '\\r';
          }
          else {
              return "\\" + match[0];
          }
      });
      var requiresQuotes = alwaysQuote || !_LEGAL_IDENTIFIER_RE.test(body);
      return requiresQuotes ? "'" + body + "'" : body;
  }
  function _createIndent(count) {
      var res = '';
      for (var i = 0; i < count; i++) {
          res += '  ';
      }
      return res;
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var __extends$17 = (this && this.__extends) || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var _debugModuleUrl = 'asset://debug/lib';
  function debugOutputAstAsTypeScript(ast) {
      var converter = new _TsEmitterVisitor(_debugModuleUrl);
      var ctx = EmitterVisitorContext.createRoot([]);
      var asts = Array.isArray(ast) ? ast : [ast];
      asts.forEach(function (ast) {
          if (ast instanceof Statement) {
              ast.visitStatement(converter, ctx);
          }
          else if (ast instanceof Expression) {
              ast.visitExpression(converter, ctx);
          }
          else if (ast instanceof Type$1) {
              ast.visitType(converter, ctx);
          }
          else {
              throw new Error("Don't know how to print debug info for " + ast);
          }
      });
      return ctx.toSource();
  }
  var TypeScriptEmitter = (function () {
      function TypeScriptEmitter(_importGenerator) {
          this._importGenerator = _importGenerator;
      }
      TypeScriptEmitter.prototype.emitStatements = function (moduleUrl, stmts, exportedVars) {
          var _this = this;
          var converter = new _TsEmitterVisitor(moduleUrl);
          var ctx = EmitterVisitorContext.createRoot(exportedVars);
          converter.visitAllStatements(stmts, ctx);
          var srcParts = [];
          converter.importsWithPrefixes.forEach(function (prefix, importedModuleUrl) {
              // Note: can't write the real word for import as it screws up system.js auto detection...
              srcParts.push("imp" +
                  ("ort * as " + prefix + " from '" + _this._importGenerator.getImportPath(moduleUrl, importedModuleUrl) + "';"));
          });
          srcParts.push(ctx.toSource());
          return srcParts.join('\n');
      };
      return TypeScriptEmitter;
  }());
  var _TsEmitterVisitor = (function (_super) {
      __extends$17(_TsEmitterVisitor, _super);
      function _TsEmitterVisitor(_moduleUrl) {
          _super.call(this, false);
          this._moduleUrl = _moduleUrl;
          this.importsWithPrefixes = new Map();
      }
      _TsEmitterVisitor.prototype.visitType = function (t, ctx, defaultType) {
          if (defaultType === void 0) { defaultType = 'any'; }
          if (isPresent(t)) {
              t.visitType(this, ctx);
          }
          else {
              ctx.print(defaultType);
          }
      };
      _TsEmitterVisitor.prototype.visitLiteralExpr = function (ast, ctx) {
          _super.prototype.visitLiteralExpr.call(this, ast, ctx, '(null as any)');
      };
      // Temporary workaround to support strictNullCheck enabled consumers of ngc emit.
      // In SNC mode, [] have the type never[], so we cast here to any[].
      // TODO: narrow the cast to a more explicit type, or use a pattern that does not
      // start with [].concat. see https://github.com/angular/angular/pull/11846
      _TsEmitterVisitor.prototype.visitLiteralArrayExpr = function (ast, ctx) {
          if (ast.entries.length === 0) {
              ctx.print('(');
          }
          var result = _super.prototype.visitLiteralArrayExpr.call(this, ast, ctx);
          if (ast.entries.length === 0) {
              ctx.print(' as any[])');
          }
          return result;
      };
      _TsEmitterVisitor.prototype.visitExternalExpr = function (ast, ctx) {
          this._visitIdentifier(ast.value, ast.typeParams, ctx);
          return null;
      };
      _TsEmitterVisitor.prototype.visitDeclareVarStmt = function (stmt, ctx) {
          if (ctx.isExportedVar(stmt.name)) {
              ctx.print("export ");
          }
          if (stmt.hasModifier(StmtModifier.Final)) {
              ctx.print("const");
          }
          else {
              ctx.print("var");
          }
          ctx.print(" " + stmt.name + ":");
          this.visitType(stmt.type, ctx);
          ctx.print(" = ");
          stmt.value.visitExpression(this, ctx);
          ctx.println(";");
          return null;
      };
      _TsEmitterVisitor.prototype.visitCastExpr = function (ast, ctx) {
          ctx.print("(<");
          ast.type.visitType(this, ctx);
          ctx.print(">");
          ast.value.visitExpression(this, ctx);
          ctx.print(")");
          return null;
      };
      _TsEmitterVisitor.prototype.visitDeclareClassStmt = function (stmt, ctx) {
          var _this = this;
          ctx.pushClass(stmt);
          if (ctx.isExportedVar(stmt.name)) {
              ctx.print("export ");
          }
          ctx.print("class " + stmt.name);
          if (isPresent(stmt.parent)) {
              ctx.print(" extends ");
              stmt.parent.visitExpression(this, ctx);
          }
          ctx.println(" {");
          ctx.incIndent();
          stmt.fields.forEach(function (field) { return _this._visitClassField(field, ctx); });
          if (isPresent(stmt.constructorMethod)) {
              this._visitClassConstructor(stmt, ctx);
          }
          stmt.getters.forEach(function (getter) { return _this._visitClassGetter(getter, ctx); });
          stmt.methods.forEach(function (method) { return _this._visitClassMethod(method, ctx); });
          ctx.decIndent();
          ctx.println("}");
          ctx.popClass();
          return null;
      };
      _TsEmitterVisitor.prototype._visitClassField = function (field, ctx) {
          if (field.hasModifier(StmtModifier.Private)) {
              // comment out as a workaround for #10967
              ctx.print("/*private*/ ");
          }
          ctx.print(field.name);
          ctx.print(':');
          this.visitType(field.type, ctx);
          ctx.println(";");
      };
      _TsEmitterVisitor.prototype._visitClassGetter = function (getter, ctx) {
          if (getter.hasModifier(StmtModifier.Private)) {
              ctx.print("private ");
          }
          ctx.print("get " + getter.name + "()");
          ctx.print(':');
          this.visitType(getter.type, ctx);
          ctx.println(" {");
          ctx.incIndent();
          this.visitAllStatements(getter.body, ctx);
          ctx.decIndent();
          ctx.println("}");
      };
      _TsEmitterVisitor.prototype._visitClassConstructor = function (stmt, ctx) {
          ctx.print("constructor(");
          this._visitParams(stmt.constructorMethod.params, ctx);
          ctx.println(") {");
          ctx.incIndent();
          this.visitAllStatements(stmt.constructorMethod.body, ctx);
          ctx.decIndent();
          ctx.println("}");
      };
      _TsEmitterVisitor.prototype._visitClassMethod = function (method, ctx) {
          if (method.hasModifier(StmtModifier.Private)) {
              ctx.print("private ");
          }
          ctx.print(method.name + "(");
          this._visitParams(method.params, ctx);
          ctx.print("):");
          this.visitType(method.type, ctx, 'void');
          ctx.println(" {");
          ctx.incIndent();
          this.visitAllStatements(method.body, ctx);
          ctx.decIndent();
          ctx.println("}");
      };
      _TsEmitterVisitor.prototype.visitFunctionExpr = function (ast, ctx) {
          ctx.print("(");
          this._visitParams(ast.params, ctx);
          ctx.print("):");
          this.visitType(ast.type, ctx, 'void');
          ctx.println(" => {");
          ctx.incIndent();
          this.visitAllStatements(ast.statements, ctx);
          ctx.decIndent();
          ctx.print("}");
          return null;
      };
      _TsEmitterVisitor.prototype.visitDeclareFunctionStmt = function (stmt, ctx) {
          if (ctx.isExportedVar(stmt.name)) {
              ctx.print("export ");
          }
          ctx.print("function " + stmt.name + "(");
          this._visitParams(stmt.params, ctx);
          ctx.print("):");
          this.visitType(stmt.type, ctx, 'void');
          ctx.println(" {");
          ctx.incIndent();
          this.visitAllStatements(stmt.statements, ctx);
          ctx.decIndent();
          ctx.println("}");
          return null;
      };
      _TsEmitterVisitor.prototype.visitTryCatchStmt = function (stmt, ctx) {
          ctx.println("try {");
          ctx.incIndent();
          this.visitAllStatements(stmt.bodyStmts, ctx);
          ctx.decIndent();
          ctx.println("} catch (" + CATCH_ERROR_VAR$2.name + ") {");
          ctx.incIndent();
          var catchStmts = [CATCH_STACK_VAR$2.set(CATCH_ERROR_VAR$2.prop('stack')).toDeclStmt(null, [
                  StmtModifier.Final
              ])].concat(stmt.catchStmts);
          this.visitAllStatements(catchStmts, ctx);
          ctx.decIndent();
          ctx.println("}");
          return null;
      };
      _TsEmitterVisitor.prototype.visitBuiltintType = function (type, ctx) {
          var typeStr;
          switch (type.name) {
              case BuiltinTypeName.Bool:
                  typeStr = 'boolean';
                  break;
              case BuiltinTypeName.Dynamic:
                  typeStr = 'any';
                  break;
              case BuiltinTypeName.Function:
                  typeStr = 'Function';
                  break;
              case BuiltinTypeName.Number:
                  typeStr = 'number';
                  break;
              case BuiltinTypeName.Int:
                  typeStr = 'number';
                  break;
              case BuiltinTypeName.String:
                  typeStr = 'string';
                  break;
              default:
                  throw new Error("Unsupported builtin type " + type.name);
          }
          ctx.print(typeStr);
          return null;
      };
      _TsEmitterVisitor.prototype.visitExternalType = function (ast, ctx) {
          this._visitIdentifier(ast.value, ast.typeParams, ctx);
          return null;
      };
      _TsEmitterVisitor.prototype.visitArrayType = function (type, ctx) {
          this.visitType(type.of, ctx);
          ctx.print("[]");
          return null;
      };
      _TsEmitterVisitor.prototype.visitMapType = function (type, ctx) {
          ctx.print("{[key: string]:");
          this.visitType(type.valueType, ctx);
          ctx.print("}");
          return null;
      };
      _TsEmitterVisitor.prototype.getBuiltinMethodName = function (method) {
          var name;
          switch (method) {
              case BuiltinMethod.ConcatArray:
                  name = 'concat';
                  break;
              case BuiltinMethod.SubscribeObservable:
                  name = 'subscribe';
                  break;
              case BuiltinMethod.Bind:
                  name = 'bind';
                  break;
              default:
                  throw new Error("Unknown builtin method: " + method);
          }
          return name;
      };
      _TsEmitterVisitor.prototype._visitParams = function (params, ctx) {
          var _this = this;
          this.visitAllObjects(function (param) {
              ctx.print(param.name);
              ctx.print(':');
              _this.visitType(param.type, ctx);
          }, params, ctx, ',');
      };
      _TsEmitterVisitor.prototype._visitIdentifier = function (value, typeParams, ctx) {
          var _this = this;
          if (isBlank(value.name)) {
              throw new Error("Internal error: unknown identifier " + value);
          }
          if (isPresent(value.moduleUrl) && value.moduleUrl != this._moduleUrl) {
              var prefix = this.importsWithPrefixes.get(value.moduleUrl);
              if (isBlank(prefix)) {
                  prefix = "import" + this.importsWithPrefixes.size;
                  this.importsWithPrefixes.set(value.moduleUrl, prefix);
              }
              ctx.print(prefix + ".");
          }
          if (value.reference && value.reference.members) {
              ctx.print(value.reference.name);
              ctx.print('.');
              ctx.print(value.reference.members.join('.'));
          }
          else {
              ctx.print(value.name);
          }
          if (isPresent(typeParams) && typeParams.length > 0) {
              ctx.print("<");
              this.visitAllObjects(function (type) { return type.visitType(_this, ctx); }, typeParams, ctx, ',');
              ctx.print(">");
          }
      };
      return _TsEmitterVisitor;
  }(AbstractEmitterVisitor));

  function interpretStatements(statements, resultVar) {
      var stmtsWithReturn = statements.concat([new ReturnStatement(variable(resultVar))]);
      var ctx = new _ExecutionContext(null, null, null, new Map());
      var visitor = new StatementInterpreter();
      var result = visitor.visitAllStatements(stmtsWithReturn, ctx);
      return isPresent(result) ? result.value : null;
  }
  function _executeFunctionStatements(varNames, varValues, statements, ctx, visitor) {
      var childCtx = ctx.createChildWihtLocalVars();
      for (var i = 0; i < varNames.length; i++) {
          childCtx.vars.set(varNames[i], varValues[i]);
      }
      var result = visitor.visitAllStatements(statements, childCtx);
      return isPresent(result) ? result.value : null;
  }
  var _ExecutionContext = (function () {
      function _ExecutionContext(parent, instance, className, vars) {
          this.parent = parent;
          this.instance = instance;
          this.className = className;
          this.vars = vars;
      }
      _ExecutionContext.prototype.createChildWihtLocalVars = function () {
          return new _ExecutionContext(this, this.instance, this.className, new Map());
      };
      return _ExecutionContext;
  }());
  var ReturnValue = (function () {
      function ReturnValue(value) {
          this.value = value;
      }
      return ReturnValue;
  }());
  function createDynamicClass(_classStmt, _ctx, _visitor) {
      var propertyDescriptors = {};
      _classStmt.getters.forEach(function (getter) {
          // Note: use `function` instead of arrow function to capture `this`
          propertyDescriptors[getter.name] = {
              configurable: false,
              get: function () {
                  var instanceCtx = new _ExecutionContext(_ctx, this, _classStmt.name, _ctx.vars);
                  return _executeFunctionStatements([], [], getter.body, instanceCtx, _visitor);
              }
          };
      });
      _classStmt.methods.forEach(function (method) {
          var paramNames = method.params.map(function (param) { return param.name; });
          // Note: use `function` instead of arrow function to capture `this`
          propertyDescriptors[method.name] = {
              writable: false,
              configurable: false,
              value: function () {
                  var args = [];
                  for (var _i = 0; _i < arguments.length; _i++) {
                      args[_i - 0] = arguments[_i];
                  }
                  var instanceCtx = new _ExecutionContext(_ctx, this, _classStmt.name, _ctx.vars);
                  return _executeFunctionStatements(paramNames, args, method.body, instanceCtx, _visitor);
              }
          };
      });
      var ctorParamNames = _classStmt.constructorMethod.params.map(function (param) { return param.name; });
      // Note: use `function` instead of arrow function to capture `this`
      var ctor = function () {
          var _this = this;
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              args[_i - 0] = arguments[_i];
          }
          var instanceCtx = new _ExecutionContext(_ctx, this, _classStmt.name, _ctx.vars);
          _classStmt.fields.forEach(function (field) { _this[field.name] = undefined; });
          _executeFunctionStatements(ctorParamNames, args, _classStmt.constructorMethod.body, instanceCtx, _visitor);
      };
      var superClass = _classStmt.parent ? _classStmt.parent.visitExpression(_visitor, _ctx) : Object;
      ctor.prototype = Object.create(superClass.prototype, propertyDescriptors);
      return ctor;
  }
  var StatementInterpreter = (function () {
      function StatementInterpreter() {
      }
      StatementInterpreter.prototype.debugAst = function (ast) { return debugOutputAstAsTypeScript(ast); };
      StatementInterpreter.prototype.visitDeclareVarStmt = function (stmt, ctx) {
          ctx.vars.set(stmt.name, stmt.value.visitExpression(this, ctx));
          return null;
      };
      StatementInterpreter.prototype.visitWriteVarExpr = function (expr, ctx) {
          var value = expr.value.visitExpression(this, ctx);
          var currCtx = ctx;
          while (currCtx != null) {
              if (currCtx.vars.has(expr.name)) {
                  currCtx.vars.set(expr.name, value);
                  return value;
              }
              currCtx = currCtx.parent;
          }
          throw new Error("Not declared variable " + expr.name);
      };
      StatementInterpreter.prototype.visitReadVarExpr = function (ast, ctx) {
          var varName = ast.name;
          if (isPresent(ast.builtin)) {
              switch (ast.builtin) {
                  case BuiltinVar.Super:
                      return ctx.instance.__proto__;
                  case BuiltinVar.This:
                      return ctx.instance;
                  case BuiltinVar.CatchError:
                      varName = CATCH_ERROR_VAR$1;
                      break;
                  case BuiltinVar.CatchStack:
                      varName = CATCH_STACK_VAR$1;
                      break;
                  default:
                      throw new Error("Unknown builtin variable " + ast.builtin);
              }
          }
          var currCtx = ctx;
          while (currCtx != null) {
              if (currCtx.vars.has(varName)) {
                  return currCtx.vars.get(varName);
              }
              currCtx = currCtx.parent;
          }
          throw new Error("Not declared variable " + varName);
      };
      StatementInterpreter.prototype.visitWriteKeyExpr = function (expr, ctx) {
          var receiver = expr.receiver.visitExpression(this, ctx);
          var index = expr.index.visitExpression(this, ctx);
          var value = expr.value.visitExpression(this, ctx);
          receiver[index] = value;
          return value;
      };
      StatementInterpreter.prototype.visitWritePropExpr = function (expr, ctx) {
          var receiver = expr.receiver.visitExpression(this, ctx);
          var value = expr.value.visitExpression(this, ctx);
          receiver[expr.name] = value;
          return value;
      };
      StatementInterpreter.prototype.visitInvokeMethodExpr = function (expr, ctx) {
          var receiver = expr.receiver.visitExpression(this, ctx);
          var args = this.visitAllExpressions(expr.args, ctx);
          var result;
          if (isPresent(expr.builtin)) {
              switch (expr.builtin) {
                  case BuiltinMethod.ConcatArray:
                      result = ListWrapper.concat(receiver, args[0]);
                      break;
                  case BuiltinMethod.SubscribeObservable:
                      result = receiver.subscribe({ next: args[0] });
                      break;
                  case BuiltinMethod.Bind:
                      result = receiver.bind(args[0]);
                      break;
                  default:
                      throw new Error("Unknown builtin method " + expr.builtin);
              }
          }
          else {
              result = receiver[expr.name].apply(receiver, args);
          }
          return result;
      };
      StatementInterpreter.prototype.visitInvokeFunctionExpr = function (stmt, ctx) {
          var args = this.visitAllExpressions(stmt.args, ctx);
          var fnExpr = stmt.fn;
          if (fnExpr instanceof ReadVarExpr && fnExpr.builtin === BuiltinVar.Super) {
              ctx.instance.constructor.prototype.constructor.apply(ctx.instance, args);
              return null;
          }
          else {
              var fn = stmt.fn.visitExpression(this, ctx);
              return fn.apply(null, args);
          }
      };
      StatementInterpreter.prototype.visitReturnStmt = function (stmt, ctx) {
          return new ReturnValue(stmt.value.visitExpression(this, ctx));
      };
      StatementInterpreter.prototype.visitDeclareClassStmt = function (stmt, ctx) {
          var clazz = createDynamicClass(stmt, ctx, this);
          ctx.vars.set(stmt.name, clazz);
          return null;
      };
      StatementInterpreter.prototype.visitExpressionStmt = function (stmt, ctx) {
          return stmt.expr.visitExpression(this, ctx);
      };
      StatementInterpreter.prototype.visitIfStmt = function (stmt, ctx) {
          var condition = stmt.condition.visitExpression(this, ctx);
          if (condition) {
              return this.visitAllStatements(stmt.trueCase, ctx);
          }
          else if (isPresent(stmt.falseCase)) {
              return this.visitAllStatements(stmt.falseCase, ctx);
          }
          return null;
      };
      StatementInterpreter.prototype.visitTryCatchStmt = function (stmt, ctx) {
          try {
              return this.visitAllStatements(stmt.bodyStmts, ctx);
          }
          catch (e) {
              var childCtx = ctx.createChildWihtLocalVars();
              childCtx.vars.set(CATCH_ERROR_VAR$1, e);
              childCtx.vars.set(CATCH_STACK_VAR$1, e.stack);
              return this.visitAllStatements(stmt.catchStmts, childCtx);
          }
      };
      StatementInterpreter.prototype.visitThrowStmt = function (stmt, ctx) {
          throw stmt.error.visitExpression(this, ctx);
      };
      StatementInterpreter.prototype.visitCommentStmt = function (stmt, context) { return null; };
      StatementInterpreter.prototype.visitInstantiateExpr = function (ast, ctx) {
          var args = this.visitAllExpressions(ast.args, ctx);
          var clazz = ast.classExpr.visitExpression(this, ctx);
          return new (clazz.bind.apply(clazz, [void 0].concat(args)))();
      };
      StatementInterpreter.prototype.visitLiteralExpr = function (ast, ctx) { return ast.value; };
      StatementInterpreter.prototype.visitExternalExpr = function (ast, ctx) {
          return ast.value.reference;
      };
      StatementInterpreter.prototype.visitConditionalExpr = function (ast, ctx) {
          if (ast.condition.visitExpression(this, ctx)) {
              return ast.trueCase.visitExpression(this, ctx);
          }
          else if (isPresent(ast.falseCase)) {
              return ast.falseCase.visitExpression(this, ctx);
          }
          return null;
      };
      StatementInterpreter.prototype.visitNotExpr = function (ast, ctx) {
          return !ast.condition.visitExpression(this, ctx);
      };
      StatementInterpreter.prototype.visitCastExpr = function (ast, ctx) {
          return ast.value.visitExpression(this, ctx);
      };
      StatementInterpreter.prototype.visitFunctionExpr = function (ast, ctx) {
          var paramNames = ast.params.map(function (param) { return param.name; });
          return _declareFn(paramNames, ast.statements, ctx, this);
      };
      StatementInterpreter.prototype.visitDeclareFunctionStmt = function (stmt, ctx) {
          var paramNames = stmt.params.map(function (param) { return param.name; });
          ctx.vars.set(stmt.name, _declareFn(paramNames, stmt.statements, ctx, this));
          return null;
      };
      StatementInterpreter.prototype.visitBinaryOperatorExpr = function (ast, ctx) {
          var _this = this;
          var lhs = function () { return ast.lhs.visitExpression(_this, ctx); };
          var rhs = function () { return ast.rhs.visitExpression(_this, ctx); };
          switch (ast.operator) {
              case BinaryOperator.Equals:
                  return lhs() == rhs();
              case BinaryOperator.Identical:
                  return lhs() === rhs();
              case BinaryOperator.NotEquals:
                  return lhs() != rhs();
              case BinaryOperator.NotIdentical:
                  return lhs() !== rhs();
              case BinaryOperator.And:
                  return lhs() && rhs();
              case BinaryOperator.Or:
                  return lhs() || rhs();
              case BinaryOperator.Plus:
                  return lhs() + rhs();
              case BinaryOperator.Minus:
                  return lhs() - rhs();
              case BinaryOperator.Divide:
                  return lhs() / rhs();
              case BinaryOperator.Multiply:
                  return lhs() * rhs();
              case BinaryOperator.Modulo:
                  return lhs() % rhs();
              case BinaryOperator.Lower:
                  return lhs() < rhs();
              case BinaryOperator.LowerEquals:
                  return lhs() <= rhs();
              case BinaryOperator.Bigger:
                  return lhs() > rhs();
              case BinaryOperator.BiggerEquals:
                  return lhs() >= rhs();
              default:
                  throw new Error("Unknown operator " + ast.operator);
          }
      };
      StatementInterpreter.prototype.visitReadPropExpr = function (ast, ctx) {
          var result;
          var receiver = ast.receiver.visitExpression(this, ctx);
          result = receiver[ast.name];
          return result;
      };
      StatementInterpreter.prototype.visitReadKeyExpr = function (ast, ctx) {
          var receiver = ast.receiver.visitExpression(this, ctx);
          var prop = ast.index.visitExpression(this, ctx);
          return receiver[prop];
      };
      StatementInterpreter.prototype.visitLiteralArrayExpr = function (ast, ctx) {
          return this.visitAllExpressions(ast.entries, ctx);
      };
      StatementInterpreter.prototype.visitLiteralMapExpr = function (ast, ctx) {
          var _this = this;
          var result = {};
          ast.entries.forEach(function (entry) { return result[entry[0]] =
              entry[1].visitExpression(_this, ctx); });
          return result;
      };
      StatementInterpreter.prototype.visitAllExpressions = function (expressions, ctx) {
          var _this = this;
          return expressions.map(function (expr) { return expr.visitExpression(_this, ctx); });
      };
      StatementInterpreter.prototype.visitAllStatements = function (statements, ctx) {
          for (var i = 0; i < statements.length; i++) {
              var stmt = statements[i];
              var val = stmt.visitStatement(this, ctx);
              if (val instanceof ReturnValue) {
                  return val;
              }
          }
          return null;
      };
      return StatementInterpreter;
  }());
  function _declareFn(varNames, statements, ctx, visitor) {
      return function () {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              args[_i - 0] = arguments[_i];
          }
          return _executeFunctionStatements(varNames, args, statements, ctx, visitor);
      };
  }
  var CATCH_ERROR_VAR$1 = 'error';
  var CATCH_STACK_VAR$1 = 'stack';

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var __extends$19 = (this && this.__extends) || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var AbstractJsEmitterVisitor = (function (_super) {
      __extends$19(AbstractJsEmitterVisitor, _super);
      function AbstractJsEmitterVisitor() {
          _super.call(this, false);
      }
      AbstractJsEmitterVisitor.prototype.visitDeclareClassStmt = function (stmt, ctx) {
          var _this = this;
          ctx.pushClass(stmt);
          this._visitClassConstructor(stmt, ctx);
          if (isPresent(stmt.parent)) {
              ctx.print(stmt.name + ".prototype = Object.create(");
              stmt.parent.visitExpression(this, ctx);
              ctx.println(".prototype);");
          }
          stmt.getters.forEach(function (getter) { return _this._visitClassGetter(stmt, getter, ctx); });
          stmt.methods.forEach(function (method) { return _this._visitClassMethod(stmt, method, ctx); });
          ctx.popClass();
          return null;
      };
      AbstractJsEmitterVisitor.prototype._visitClassConstructor = function (stmt, ctx) {
          ctx.print("function " + stmt.name + "(");
          if (isPresent(stmt.constructorMethod)) {
              this._visitParams(stmt.constructorMethod.params, ctx);
          }
          ctx.println(") {");
          ctx.incIndent();
          if (isPresent(stmt.constructorMethod)) {
              if (stmt.constructorMethod.body.length > 0) {
                  ctx.println("var self = this;");
                  this.visitAllStatements(stmt.constructorMethod.body, ctx);
              }
          }
          ctx.decIndent();
          ctx.println("}");
      };
      AbstractJsEmitterVisitor.prototype._visitClassGetter = function (stmt, getter, ctx) {
          ctx.println("Object.defineProperty(" + stmt.name + ".prototype, '" + getter.name + "', { get: function() {");
          ctx.incIndent();
          if (getter.body.length > 0) {
              ctx.println("var self = this;");
              this.visitAllStatements(getter.body, ctx);
          }
          ctx.decIndent();
          ctx.println("}});");
      };
      AbstractJsEmitterVisitor.prototype._visitClassMethod = function (stmt, method, ctx) {
          ctx.print(stmt.name + ".prototype." + method.name + " = function(");
          this._visitParams(method.params, ctx);
          ctx.println(") {");
          ctx.incIndent();
          if (method.body.length > 0) {
              ctx.println("var self = this;");
              this.visitAllStatements(method.body, ctx);
          }
          ctx.decIndent();
          ctx.println("};");
      };
      AbstractJsEmitterVisitor.prototype.visitReadVarExpr = function (ast, ctx) {
          if (ast.builtin === BuiltinVar.This) {
              ctx.print('self');
          }
          else if (ast.builtin === BuiltinVar.Super) {
              throw new Error("'super' needs to be handled at a parent ast node, not at the variable level!");
          }
          else {
              _super.prototype.visitReadVarExpr.call(this, ast, ctx);
          }
          return null;
      };
      AbstractJsEmitterVisitor.prototype.visitDeclareVarStmt = function (stmt, ctx) {
          ctx.print("var " + stmt.name + " = ");
          stmt.value.visitExpression(this, ctx);
          ctx.println(";");
          return null;
      };
      AbstractJsEmitterVisitor.prototype.visitCastExpr = function (ast, ctx) {
          ast.value.visitExpression(this, ctx);
          return null;
      };
      AbstractJsEmitterVisitor.prototype.visitInvokeFunctionExpr = function (expr, ctx) {
          var fnExpr = expr.fn;
          if (fnExpr instanceof ReadVarExpr && fnExpr.builtin === BuiltinVar.Super) {
              ctx.currentClass.parent.visitExpression(this, ctx);
              ctx.print(".call(this");
              if (expr.args.length > 0) {
                  ctx.print(", ");
                  this.visitAllExpressions(expr.args, ctx, ',');
              }
              ctx.print(")");
          }
          else {
              _super.prototype.visitInvokeFunctionExpr.call(this, expr, ctx);
          }
          return null;
      };
      AbstractJsEmitterVisitor.prototype.visitFunctionExpr = function (ast, ctx) {
          ctx.print("function(");
          this._visitParams(ast.params, ctx);
          ctx.println(") {");
          ctx.incIndent();
          this.visitAllStatements(ast.statements, ctx);
          ctx.decIndent();
          ctx.print("}");
          return null;
      };
      AbstractJsEmitterVisitor.prototype.visitDeclareFunctionStmt = function (stmt, ctx) {
          ctx.print("function " + stmt.name + "(");
          this._visitParams(stmt.params, ctx);
          ctx.println(") {");
          ctx.incIndent();
          this.visitAllStatements(stmt.statements, ctx);
          ctx.decIndent();
          ctx.println("}");
          return null;
      };
      AbstractJsEmitterVisitor.prototype.visitTryCatchStmt = function (stmt, ctx) {
          ctx.println("try {");
          ctx.incIndent();
          this.visitAllStatements(stmt.bodyStmts, ctx);
          ctx.decIndent();
          ctx.println("} catch (" + CATCH_ERROR_VAR$2.name + ") {");
          ctx.incIndent();
          var catchStmts = [CATCH_STACK_VAR$2.set(CATCH_ERROR_VAR$2.prop('stack')).toDeclStmt(null, [
                  StmtModifier.Final
              ])].concat(stmt.catchStmts);
          this.visitAllStatements(catchStmts, ctx);
          ctx.decIndent();
          ctx.println("}");
          return null;
      };
      AbstractJsEmitterVisitor.prototype._visitParams = function (params, ctx) {
          this.visitAllObjects(function (param) { return ctx.print(param.name); }, params, ctx, ',');
      };
      AbstractJsEmitterVisitor.prototype.getBuiltinMethodName = function (method) {
          var name;
          switch (method) {
              case BuiltinMethod.ConcatArray:
                  name = 'concat';
                  break;
              case BuiltinMethod.SubscribeObservable:
                  name = 'subscribe';
                  break;
              case BuiltinMethod.Bind:
                  name = 'bind';
                  break;
              default:
                  throw new Error("Unknown builtin method: " + method);
          }
          return name;
      };
      return AbstractJsEmitterVisitor;
  }(AbstractEmitterVisitor));

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var __extends$18 = (this && this.__extends) || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  function evalExpression(sourceUrl, expr, declarations, vars) {
      var fnBody = declarations + "\nreturn " + expr + "\n//# sourceURL=" + sourceUrl;
      var fnArgNames = [];
      var fnArgValues = [];
      for (var argName in vars) {
          fnArgNames.push(argName);
          fnArgValues.push(vars[argName]);
      }
      return new (Function.bind.apply(Function, [void 0].concat(fnArgNames.concat(fnBody))))().apply(void 0, fnArgValues);
  }
  function jitStatements(sourceUrl, statements, resultVar) {
      var converter = new JitEmitterVisitor();
      var ctx = EmitterVisitorContext.createRoot([resultVar]);
      converter.visitAllStatements(statements, ctx);
      return evalExpression(sourceUrl, resultVar, ctx.toSource(), converter.getArgs());
  }
  var JitEmitterVisitor = (function (_super) {
      __extends$18(JitEmitterVisitor, _super);
      function JitEmitterVisitor() {
          _super.apply(this, arguments);
          this._evalArgNames = [];
          this._evalArgValues = [];
      }
      JitEmitterVisitor.prototype.getArgs = function () {
          var result = {};
          for (var i = 0; i < this._evalArgNames.length; i++) {
              result[this._evalArgNames[i]] = this._evalArgValues[i];
          }
          return result;
      };
      JitEmitterVisitor.prototype.visitExternalExpr = function (ast, ctx) {
          var value = ast.value.reference;
          var id = this._evalArgValues.indexOf(value);
          if (id === -1) {
              id = this._evalArgValues.length;
              this._evalArgValues.push(value);
              var name = isPresent(ast.value.name) ? sanitizeIdentifier(ast.value.name) : 'val';
              this._evalArgNames.push(sanitizeIdentifier("jit_" + name + id));
          }
          ctx.print(this._evalArgNames[id]);
          return null;
      };
      return JitEmitterVisitor;
  }(AbstractJsEmitterVisitor));

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * This file is a port of shadowCSS from webcomponents.js to TypeScript.
   *
   * Please make sure to keep to edits in sync with the source file.
   *
   * Source:
   * https://github.com/webcomponents/webcomponentsjs/blob/4efecd7e0e/src/ShadowCSS/ShadowCSS.js
   *
   * The original file level comment is reproduced below
   */
  /*
    This is a limited shim for ShadowDOM css styling.
    https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html#styles

    The intention here is to support only the styling features which can be
    relatively simply implemented. The goal is to allow users to avoid the
    most obvious pitfalls and do so without compromising performance significantly.
    For ShadowDOM styling that's not covered here, a set of best practices
    can be provided that should allow users to accomplish more complex styling.

    The following is a list of specific ShadowDOM styling features and a brief
    discussion of the approach used to shim.

    Shimmed features:

    * :host, :host-context: ShadowDOM allows styling of the shadowRoot's host
    element using the :host rule. To shim this feature, the :host styles are
    reformatted and prefixed with a given scope name and promoted to a
    document level stylesheet.
    For example, given a scope name of .foo, a rule like this:

      :host {
          background: red;
        }
      }

    becomes:

      .foo {
        background: red;
      }

    * encapsulation: Styles defined within ShadowDOM, apply only to
    dom inside the ShadowDOM. Polymer uses one of two techniques to implement
    this feature.

    By default, rules are prefixed with the host element tag name
    as a descendant selector. This ensures styling does not leak out of the 'top'
    of the element's ShadowDOM. For example,

    div {
        font-weight: bold;
      }

    becomes:

    x-foo div {
        font-weight: bold;
      }

    becomes:


    Alternatively, if WebComponents.ShadowCSS.strictStyling is set to true then
    selectors are scoped by adding an attribute selector suffix to each
    simple selector that contains the host element tag name. Each element
    in the element's ShadowDOM template is also given the scope attribute.
    Thus, these rules match only elements that have the scope attribute.
    For example, given a scope name of x-foo, a rule like this:

      div {
        font-weight: bold;
      }

    becomes:

      div[x-foo] {
        font-weight: bold;
      }

    Note that elements that are dynamically added to a scope must have the scope
    selector added to them manually.

    * upper/lower bound encapsulation: Styles which are defined outside a
    shadowRoot should not cross the ShadowDOM boundary and should not apply
    inside a shadowRoot.

    This styling behavior is not emulated. Some possible ways to do this that
    were rejected due to complexity and/or performance concerns include: (1) reset
    every possible property for every possible selector for a given scope name;
    (2) re-implement css in javascript.

    As an alternative, users should make sure to use selectors
    specific to the scope in which they are working.

    * ::distributed: This behavior is not emulated. It's often not necessary
    to style the contents of a specific insertion point and instead, descendants
    of the host element can be styled selectively. Users can also create an
    extra node around an insertion point and style that node's contents
    via descendent selectors. For example, with a shadowRoot like this:

      <style>
        ::content(div) {
          background: red;
        }
      </style>
      <content></content>

    could become:

      <style>
        / *@polyfill .content-container div * /
        ::content(div) {
          background: red;
        }
      </style>
      <div class="content-container">
        <content></content>
      </div>

    Note the use of @polyfill in the comment above a ShadowDOM specific style
    declaration. This is a directive to the styling shim to use the selector
    in comments in lieu of the next selector when running under polyfill.
  */
  var ShadowCss = (function () {
      function ShadowCss() {
          this.strictStyling = true;
      }
      /*
      * Shim some cssText with the given selector. Returns cssText that can
      * be included in the document via WebComponents.ShadowCSS.addCssToDocument(css).
      *
      * When strictStyling is true:
      * - selector is the attribute added to all elements inside the host,
      * - hostSelector is the attribute added to the host itself.
      */
      ShadowCss.prototype.shimCssText = function (cssText, selector, hostSelector) {
          if (hostSelector === void 0) { hostSelector = ''; }
          var sourceMappingUrl = extractSourceMappingUrl(cssText);
          cssText = stripComments(cssText);
          cssText = this._insertDirectives(cssText);
          return this._scopeCssText(cssText, selector, hostSelector) + sourceMappingUrl;
      };
      ShadowCss.prototype._insertDirectives = function (cssText) {
          cssText = this._insertPolyfillDirectivesInCssText(cssText);
          return this._insertPolyfillRulesInCssText(cssText);
      };
      /*
       * Process styles to convert native ShadowDOM rules that will trip
       * up the css parser; we rely on decorating the stylesheet with inert rules.
       *
       * For example, we convert this rule:
       *
       * polyfill-next-selector { content: ':host menu-item'; }
       * ::content menu-item {
       *
       * to this:
       *
       * scopeName menu-item {
       *
      **/
      ShadowCss.prototype._insertPolyfillDirectivesInCssText = function (cssText) {
          // Difference with webcomponents.js: does not handle comments
          return cssText.replace(_cssContentNextSelectorRe, function () {
              var m = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                  m[_i - 0] = arguments[_i];
              }
              return m[2] + '{';
          });
      };
      /*
       * Process styles to add rules which will only apply under the polyfill
       *
       * For example, we convert this rule:
       *
       * polyfill-rule {
       *   content: ':host menu-item';
       * ...
       * }
       *
       * to this:
       *
       * scopeName menu-item {...}
       *
      **/
      ShadowCss.prototype._insertPolyfillRulesInCssText = function (cssText) {
          // Difference with webcomponents.js: does not handle comments
          return cssText.replace(_cssContentRuleRe, function () {
              var m = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                  m[_i - 0] = arguments[_i];
              }
              var rule = m[0].replace(m[1], '').replace(m[2], '');
              return m[4] + rule;
          });
      };
      /* Ensure styles are scoped. Pseudo-scoping takes a rule like:
       *
       *  .foo {... }
       *
       *  and converts this to
       *
       *  scopeName .foo { ... }
      */
      ShadowCss.prototype._scopeCssText = function (cssText, scopeSelector, hostSelector) {
          var unscopedRules = this._extractUnscopedRulesFromCssText(cssText);
          // replace :host and :host-context -shadowcsshost and -shadowcsshost respectively
          cssText = this._insertPolyfillHostInCssText(cssText);
          cssText = this._convertColonHost(cssText);
          cssText = this._convertColonHostContext(cssText);
          cssText = this._convertShadowDOMSelectors(cssText);
          if (scopeSelector) {
              cssText = this._scopeSelectors(cssText, scopeSelector, hostSelector);
          }
          cssText = cssText + '\n' + unscopedRules;
          return cssText.trim();
      };
      /*
       * Process styles to add rules which will only apply under the polyfill
       * and do not process via CSSOM. (CSSOM is destructive to rules on rare
       * occasions, e.g. -webkit-calc on Safari.)
       * For example, we convert this rule:
       *
       * @polyfill-unscoped-rule {
       *   content: 'menu-item';
       * ... }
       *
       * to this:
       *
       * menu-item {...}
       *
      **/
      ShadowCss.prototype._extractUnscopedRulesFromCssText = function (cssText) {
          // Difference with webcomponents.js: does not handle comments
          var r = '';
          var m;
          _cssContentUnscopedRuleRe.lastIndex = 0;
          while ((m = _cssContentUnscopedRuleRe.exec(cssText)) !== null) {
              var rule = m[0].replace(m[2], '').replace(m[1], m[4]);
              r += rule + '\n\n';
          }
          return r;
      };
      /*
       * convert a rule like :host(.foo) > .bar { }
       *
       * to
       *
       * .foo<scopeName> > .bar
      */
      ShadowCss.prototype._convertColonHost = function (cssText) {
          return this._convertColonRule(cssText, _cssColonHostRe, this._colonHostPartReplacer);
      };
      /*
       * convert a rule like :host-context(.foo) > .bar { }
       *
       * to
       *
       * .foo<scopeName> > .bar, .foo scopeName > .bar { }
       *
       * and
       *
       * :host-context(.foo:host) .bar { ... }
       *
       * to
       *
       * .foo<scopeName> .bar { ... }
      */
      ShadowCss.prototype._convertColonHostContext = function (cssText) {
          return this._convertColonRule(cssText, _cssColonHostContextRe, this._colonHostContextPartReplacer);
      };
      ShadowCss.prototype._convertColonRule = function (cssText, regExp, partReplacer) {
          // m[1] = :host(-context), m[2] = contents of (), m[3] rest of rule
          return cssText.replace(regExp, function () {
              var m = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                  m[_i - 0] = arguments[_i];
              }
              if (m[2]) {
                  var parts = m[2].split(',');
                  var r = [];
                  for (var i = 0; i < parts.length; i++) {
                      var p = parts[i].trim();
                      if (!p)
                          break;
                      r.push(partReplacer(_polyfillHostNoCombinator, p, m[3]));
                  }
                  return r.join(',');
              }
              else {
                  return _polyfillHostNoCombinator + m[3];
              }
          });
      };
      ShadowCss.prototype._colonHostContextPartReplacer = function (host, part, suffix) {
          if (part.indexOf(_polyfillHost) > -1) {
              return this._colonHostPartReplacer(host, part, suffix);
          }
          else {
              return host + part + suffix + ', ' + part + ' ' + host + suffix;
          }
      };
      ShadowCss.prototype._colonHostPartReplacer = function (host, part, suffix) {
          return host + part.replace(_polyfillHost, '') + suffix;
      };
      /*
       * Convert combinators like ::shadow and pseudo-elements like ::content
       * by replacing with space.
      */
      ShadowCss.prototype._convertShadowDOMSelectors = function (cssText) {
          return _shadowDOMSelectorsRe.reduce(function (result, pattern) { return result.replace(pattern, ' '); }, cssText);
      };
      // change a selector like 'div' to 'name div'
      ShadowCss.prototype._scopeSelectors = function (cssText, scopeSelector, hostSelector) {
          var _this = this;
          return processRules(cssText, function (rule) {
              var selector = rule.selector;
              var content = rule.content;
              if (rule.selector[0] != '@') {
                  selector =
                      _this._scopeSelector(rule.selector, scopeSelector, hostSelector, _this.strictStyling);
              }
              else if (rule.selector.startsWith('@media') || rule.selector.startsWith('@supports') ||
                  rule.selector.startsWith('@page') || rule.selector.startsWith('@document')) {
                  content = _this._scopeSelectors(rule.content, scopeSelector, hostSelector);
              }
              return new CssRule(selector, content);
          });
      };
      ShadowCss.prototype._scopeSelector = function (selector, scopeSelector, hostSelector, strict) {
          var _this = this;
          return selector.split(',')
              .map(function (part) { return part.trim().split(_shadowDeepSelectors); })
              .map(function (deepParts) {
              var shallowPart = deepParts[0], otherParts = deepParts.slice(1);
              var applyScope = function (shallowPart) {
                  if (_this._selectorNeedsScoping(shallowPart, scopeSelector)) {
                      return strict ?
                          _this._applyStrictSelectorScope(shallowPart, scopeSelector, hostSelector) :
                          _this._applySelectorScope(shallowPart, scopeSelector, hostSelector);
                  }
                  else {
                      return shallowPart;
                  }
              };
              return [applyScope(shallowPart)].concat(otherParts).join(' ');
          })
              .join(', ');
      };
      ShadowCss.prototype._selectorNeedsScoping = function (selector, scopeSelector) {
          var re = this._makeScopeMatcher(scopeSelector);
          return !re.test(selector);
      };
      ShadowCss.prototype._makeScopeMatcher = function (scopeSelector) {
          var lre = /\[/g;
          var rre = /\]/g;
          scopeSelector = scopeSelector.replace(lre, '\\[').replace(rre, '\\]');
          return new RegExp('^(' + scopeSelector + ')' + _selectorReSuffix, 'm');
      };
      ShadowCss.prototype._applySelectorScope = function (selector, scopeSelector, hostSelector) {
          // Difference from webcomponents.js: scopeSelector could not be an array
          return this._applySimpleSelectorScope(selector, scopeSelector, hostSelector);
      };
      // scope via name and [is=name]
      ShadowCss.prototype._applySimpleSelectorScope = function (selector, scopeSelector, hostSelector) {
          // In Android browser, the lastIndex is not reset when the regex is used in String.replace()
          _polyfillHostRe.lastIndex = 0;
          if (_polyfillHostRe.test(selector)) {
              var replaceBy_1 = this.strictStyling ? "[" + hostSelector + "]" : scopeSelector;
              return selector
                  .replace(_polyfillHostNoCombinatorRe, function (hnc, selector) { return selector[0] === ':' ? replaceBy_1 + selector : selector + replaceBy_1; })
                  .replace(_polyfillHostRe, replaceBy_1 + ' ');
          }
          return scopeSelector + ' ' + selector;
      };
      // return a selector with [name] suffix on each simple selector
      // e.g. .foo.bar > .zot becomes .foo[name].bar[name] > .zot[name]  /** @internal */
      ShadowCss.prototype._applyStrictSelectorScope = function (selector, scopeSelector, hostSelector) {
          var _this = this;
          var isRe = /\[is=([^\]]*)\]/g;
          scopeSelector = scopeSelector.replace(isRe, function (_) {
              var parts = [];
              for (var _i = 1; _i < arguments.length; _i++) {
                  parts[_i - 1] = arguments[_i];
              }
              return parts[0];
          });
          var attrName = '[' + scopeSelector + ']';
          var _scopeSelectorPart = function (p) {
              var scopedP = p.trim();
              if (!scopedP) {
                  return '';
              }
              if (p.indexOf(_polyfillHostNoCombinator) > -1) {
                  scopedP = _this._applySimpleSelectorScope(p, scopeSelector, hostSelector);
              }
              else {
                  // remove :host since it should be unnecessary
                  var t = p.replace(_polyfillHostRe, '');
                  if (t.length > 0) {
                      var matches = t.match(/([^:]*)(:*)(.*)/);
                      if (matches !== null) {
                          scopedP = matches[1] + attrName + matches[2] + matches[3];
                      }
                  }
              }
              return scopedP;
          };
          var attrSelectorIndex = 0;
          var attrSelectors = [];
          // replace attribute selectors with placeholders to avoid issue with white space being treated
          // as separator
          selector = selector.replace(/\[[^\]]*\]/g, function (attrSelector) {
              var replaceBy = "__attr_sel_" + attrSelectorIndex + "__";
              attrSelectors.push(attrSelector);
              attrSelectorIndex++;
              return replaceBy;
          });
          var scopedSelector = '';
          var startIndex = 0;
          var res;
          var sep = /( |>|\+|~(?!=))\s*/g;
          var scopeAfter = selector.indexOf(_polyfillHostNoCombinator);
          while ((res = sep.exec(selector)) !== null) {
              var separator = res[1];
              var part = selector.slice(startIndex, res.index).trim();
              // if a selector appears before :host-context it should not be shimmed as it
              // matches on ancestor elements and not on elements in the host's shadow
              var scopedPart = startIndex >= scopeAfter ? _scopeSelectorPart(part) : part;
              scopedSelector += scopedPart + " " + separator + " ";
              startIndex = sep.lastIndex;
          }
          scopedSelector += _scopeSelectorPart(selector.substring(startIndex));
          // replace the placeholders with their original values
          return scopedSelector.replace(/__attr_sel_(\d+)__/g, function (ph, index) { return attrSelectors[+index]; });
      };
      ShadowCss.prototype._insertPolyfillHostInCssText = function (selector) {
          return selector.replace(_colonHostContextRe, _polyfillHostContext)
              .replace(_colonHostRe, _polyfillHost);
      };
      return ShadowCss;
  }());
  var _cssContentNextSelectorRe = /polyfill-next-selector[^}]*content:[\s]*?(['"])(.*?)\1[;\s]*}([^{]*?){/gim;
  var _cssContentRuleRe = /(polyfill-rule)[^}]*(content:[\s]*(['"])(.*?)\3)[;\s]*[^}]*}/gim;
  var _cssContentUnscopedRuleRe = /(polyfill-unscoped-rule)[^}]*(content:[\s]*(['"])(.*?)\3)[;\s]*[^}]*}/gim;
  var _polyfillHost = '-shadowcsshost';
  // note: :host-context pre-processed to -shadowcsshostcontext.
  var _polyfillHostContext = '-shadowcsscontext';
  var _parenSuffix = ')(?:\\((' +
      '(?:\\([^)(]*\\)|[^)(]*)+?' +
      ')\\))?([^,{]*)';
  var _cssColonHostRe = new RegExp('(' + _polyfillHost + _parenSuffix, 'gim');
  var _cssColonHostContextRe = new RegExp('(' + _polyfillHostContext + _parenSuffix, 'gim');
  var _polyfillHostNoCombinator = _polyfillHost + '-no-combinator';
  var _polyfillHostNoCombinatorRe = /-shadowcsshost-no-combinator([^\s]*)/;
  var _shadowDOMSelectorsRe = [
      /::shadow/g,
      /::content/g,
      // Deprecated selectors
      /\/shadow-deep\//g,
      /\/shadow\//g,
  ];
  var _shadowDeepSelectors = /(?:>>>)|(?:\/deep\/)/g;
  var _selectorReSuffix = '([>\\s~+\[.,{:][\\s\\S]*)?$';
  var _polyfillHostRe = /-shadowcsshost/gim;
  var _colonHostRe = /:host/gim;
  var _colonHostContextRe = /:host-context/gim;
  var _commentRe = /\/\*\s*[\s\S]*?\*\//g;
  function stripComments(input) {
      return input.replace(_commentRe, '');
  }
  // all comments except inline source mapping
  var _sourceMappingUrlRe = /\/\*\s*#\s*sourceMappingURL=[\s\S]+?\*\//;
  function extractSourceMappingUrl(input) {
      var matcher = input.match(_sourceMappingUrlRe);
      return matcher ? matcher[0] : '';
  }
  var _ruleRe = /(\s*)([^;\{\}]+?)(\s*)((?:{%BLOCK%}?\s*;?)|(?:\s*;))/g;
  var _curlyRe = /([{}])/g;
  var OPEN_CURLY = '{';
  var CLOSE_CURLY = '}';
  var BLOCK_PLACEHOLDER = '%BLOCK%';
  var CssRule = (function () {
      function CssRule(selector, content) {
          this.selector = selector;
          this.content = content;
      }
      return CssRule;
  }());
  function processRules(input, ruleCallback) {
      var inputWithEscapedBlocks = escapeBlocks(input);
      var nextBlockIndex = 0;
      return inputWithEscapedBlocks.escapedString.replace(_ruleRe, function () {
          var m = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              m[_i - 0] = arguments[_i];
          }
          var selector = m[2];
          var content = '';
          var suffix = m[4];
          var contentPrefix = '';
          if (suffix && suffix.startsWith('{' + BLOCK_PLACEHOLDER)) {
              content = inputWithEscapedBlocks.blocks[nextBlockIndex++];
              suffix = suffix.substring(BLOCK_PLACEHOLDER.length + 1);
              contentPrefix = '{';
          }
          var rule = ruleCallback(new CssRule(selector, content));
          return "" + m[1] + rule.selector + m[3] + contentPrefix + rule.content + suffix;
      });
  }
  var StringWithEscapedBlocks = (function () {
      function StringWithEscapedBlocks(escapedString, blocks) {
          this.escapedString = escapedString;
          this.blocks = blocks;
      }
      return StringWithEscapedBlocks;
  }());
  function escapeBlocks(input) {
      var inputParts = input.split(_curlyRe);
      var resultParts = [];
      var escapedBlocks = [];
      var bracketCount = 0;
      var currentBlockParts = [];
      for (var partIndex = 0; partIndex < inputParts.length; partIndex++) {
          var part = inputParts[partIndex];
          if (part == CLOSE_CURLY) {
              bracketCount--;
          }
          if (bracketCount > 0) {
              currentBlockParts.push(part);
          }
          else {
              if (currentBlockParts.length > 0) {
                  escapedBlocks.push(currentBlockParts.join(''));
                  resultParts.push(BLOCK_PLACEHOLDER);
                  currentBlockParts = [];
              }
              resultParts.push(part);
          }
          if (part == OPEN_CURLY) {
              bracketCount++;
          }
      }
      if (currentBlockParts.length > 0) {
          escapedBlocks.push(currentBlockParts.join(''));
          resultParts.push(BLOCK_PLACEHOLDER);
      }
      return new StringWithEscapedBlocks(resultParts.join(''), escapedBlocks);
  }

  var COMPONENT_VARIABLE = '%COMP%';
  var HOST_ATTR = "_nghost-" + COMPONENT_VARIABLE;
  var CONTENT_ATTR = "_ngcontent-" + COMPONENT_VARIABLE;
  var StylesCompileDependency = (function () {
      function StylesCompileDependency(moduleUrl, isShimmed, valuePlaceholder) {
          this.moduleUrl = moduleUrl;
          this.isShimmed = isShimmed;
          this.valuePlaceholder = valuePlaceholder;
      }
      return StylesCompileDependency;
  }());
  var StylesCompileResult = (function () {
      function StylesCompileResult(componentStylesheet, externalStylesheets) {
          this.componentStylesheet = componentStylesheet;
          this.externalStylesheets = externalStylesheets;
      }
      return StylesCompileResult;
  }());
  var CompiledStylesheet = (function () {
      function CompiledStylesheet(statements, stylesVar, dependencies, isShimmed, meta) {
          this.statements = statements;
          this.stylesVar = stylesVar;
          this.dependencies = dependencies;
          this.isShimmed = isShimmed;
          this.meta = meta;
      }
      return CompiledStylesheet;
  }());
  var StyleCompiler = (function () {
      function StyleCompiler(_urlResolver) {
          this._urlResolver = _urlResolver;
          this._shadowCss = new ShadowCss();
      }
      StyleCompiler.prototype.compileComponent = function (comp) {
          var _this = this;
          var externalStylesheets = [];
          var componentStylesheet = this._compileStyles(comp, new CompileStylesheetMetadata({
              styles: comp.template.styles,
              styleUrls: comp.template.styleUrls,
              moduleUrl: comp.type.moduleUrl
          }), true);
          comp.template.externalStylesheets.forEach(function (stylesheetMeta) {
              var compiledStylesheet = _this._compileStyles(comp, stylesheetMeta, false);
              externalStylesheets.push(compiledStylesheet);
          });
          return new StylesCompileResult(componentStylesheet, externalStylesheets);
      };
      StyleCompiler.prototype._compileStyles = function (comp, stylesheet, isComponentStylesheet) {
          var _this = this;
          var shim = comp.template.encapsulation === _angular_core.ViewEncapsulation.Emulated;
          var styleExpressions = stylesheet.styles.map(function (plainStyle) { return literal(_this._shimIfNeeded(plainStyle, shim)); });
          var dependencies = [];
          for (var i = 0; i < stylesheet.styleUrls.length; i++) {
              var identifier = new CompileIdentifierMetadata({ name: getStylesVarName(null) });
              dependencies.push(new StylesCompileDependency(stylesheet.styleUrls[i], shim, identifier));
              styleExpressions.push(new ExternalExpr(identifier));
          }
          // styles variable contains plain strings and arrays of other styles arrays (recursive),
          // so we set its type to dynamic.
          var stylesVar = getStylesVarName(isComponentStylesheet ? comp : null);
          var stmt = variable(stylesVar)
              .set(literalArr(styleExpressions, new ArrayType(DYNAMIC_TYPE, [TypeModifier.Const])))
              .toDeclStmt(null, [StmtModifier.Final]);
          return new CompiledStylesheet([stmt], stylesVar, dependencies, shim, stylesheet);
      };
      StyleCompiler.prototype._shimIfNeeded = function (style, shim) {
          return shim ? this._shadowCss.shimCssText(style, CONTENT_ATTR, HOST_ATTR) : style;
      };
      StyleCompiler.decorators = [
          { type: _angular_core.Injectable },
      ];
      /** @nocollapse */
      StyleCompiler.ctorParameters = [
          { type: UrlResolver, },
      ];
      return StyleCompiler;
  }());
  function getStylesVarName(component) {
      var result = "styles";
      if (component) {
          result += "_" + component.type.name;
      }
      return result;
  }

  /**
   * An internal module of the Angular compiler that begins with component types,
   * extracts templates, and eventually produces a compiled version of the component
   * ready for linking into an application.
   *
   * @security  When compiling templates at runtime, you must ensure that the entire template comes
   * from a trusted source. Attacker-controlled data introduced by a template could expose your
   * application to XSS risks.  For more detail, see the [Security Guide](http://g.co/ng/security).
   */
  var RuntimeCompiler = (function () {
      function RuntimeCompiler(_injector, _metadataResolver, _templateNormalizer, _templateParser, _styleCompiler, _viewCompiler, _ngModuleCompiler, _directiveWrapperCompiler, _compilerConfig) {
          this._injector = _injector;
          this._metadataResolver = _metadataResolver;
          this._templateNormalizer = _templateNormalizer;
          this._templateParser = _templateParser;
          this._styleCompiler = _styleCompiler;
          this._viewCompiler = _viewCompiler;
          this._ngModuleCompiler = _ngModuleCompiler;
          this._directiveWrapperCompiler = _directiveWrapperCompiler;
          this._compilerConfig = _compilerConfig;
          this._compiledTemplateCache = new Map();
          this._compiledHostTemplateCache = new Map();
          this._compiledDirectiveWrapperCache = new Map();
          this._compiledNgModuleCache = new Map();
          this._animationParser = new AnimationParser();
          this._animationCompiler = new AnimationCompiler();
      }
      Object.defineProperty(RuntimeCompiler.prototype, "injector", {
          get: function () { return this._injector; },
          enumerable: true,
          configurable: true
      });
      RuntimeCompiler.prototype.compileModuleSync = function (moduleType) {
          return this._compileModuleAndComponents(moduleType, true).syncResult;
      };
      RuntimeCompiler.prototype.compileModuleAsync = function (moduleType) {
          return this._compileModuleAndComponents(moduleType, false).asyncResult;
      };
      RuntimeCompiler.prototype.compileModuleAndAllComponentsSync = function (moduleType) {
          return this._compileModuleAndAllComponents(moduleType, true).syncResult;
      };
      RuntimeCompiler.prototype.compileModuleAndAllComponentsAsync = function (moduleType) {
          return this._compileModuleAndAllComponents(moduleType, false).asyncResult;
      };
      RuntimeCompiler.prototype._compileModuleAndComponents = function (moduleType, isSync) {
          var componentPromise = this._compileComponents(moduleType, isSync);
          var ngModuleFactory = this._compileModule(moduleType);
          return new SyncAsyncResult(ngModuleFactory, componentPromise.then(function () { return ngModuleFactory; }));
      };
      RuntimeCompiler.prototype._compileModuleAndAllComponents = function (moduleType, isSync) {
          var _this = this;
          var componentPromise = this._compileComponents(moduleType, isSync);
          var ngModuleFactory = this._compileModule(moduleType);
          var moduleMeta = this._metadataResolver.getNgModuleMetadata(moduleType);
          var componentFactories = [];
          var templates = new Set();
          moduleMeta.transitiveModule.modules.forEach(function (localModuleMeta) {
              localModuleMeta.declaredDirectives.forEach(function (dirMeta) {
                  if (dirMeta.isComponent) {
                      var template = _this._createCompiledHostTemplate(dirMeta.type.reference, localModuleMeta);
                      templates.add(template);
                      componentFactories.push(template.proxyComponentFactory);
                  }
              });
          });
          var syncResult = new _angular_core.ModuleWithComponentFactories(ngModuleFactory, componentFactories);
          // Note: host components themselves can always be compiled synchronously as they have an
          // inline template. However, we still need to wait for the components that they
          // reference to be loaded / compiled.
          var compile = function () {
              templates.forEach(function (template) { _this._compileTemplate(template); });
              return syncResult;
          };
          var asyncResult = isSync ? Promise.resolve(compile()) : componentPromise.then(compile);
          return new SyncAsyncResult(syncResult, asyncResult);
      };
      RuntimeCompiler.prototype._compileModule = function (moduleType) {
          var _this = this;
          var ngModuleFactory = this._compiledNgModuleCache.get(moduleType);
          if (!ngModuleFactory) {
              var moduleMeta_1 = this._metadataResolver.getNgModuleMetadata(moduleType);
              // Always provide a bound Compiler
              var extraProviders = [this._metadataResolver.getProviderMetadata(new ProviderMeta(_angular_core.Compiler, { useFactory: function () { return new ModuleBoundCompiler(_this, moduleMeta_1.type.reference); } }))];
              var compileResult = this._ngModuleCompiler.compile(moduleMeta_1, extraProviders);
              compileResult.dependencies.forEach(function (dep) {
                  dep.placeholder.reference =
                      _this._assertComponentKnown(dep.comp.reference, true).proxyComponentFactory;
                  dep.placeholder.name = "compFactory_" + dep.comp.name;
              });
              if (!this._compilerConfig.useJit) {
                  ngModuleFactory =
                      interpretStatements(compileResult.statements, compileResult.ngModuleFactoryVar);
              }
              else {
                  ngModuleFactory = jitStatements("/" + moduleMeta_1.type.name + "/module.ngfactory.js", compileResult.statements, compileResult.ngModuleFactoryVar);
              }
              this._compiledNgModuleCache.set(moduleMeta_1.type.reference, ngModuleFactory);
          }
          return ngModuleFactory;
      };
      /**
       * @internal
       */
      RuntimeCompiler.prototype._compileComponents = function (mainModule, isSync) {
          var _this = this;
          var templates = new Set();
          var loadingPromises = [];
          var ngModule = this._metadataResolver.getNgModuleMetadata(mainModule);
          var moduleByDirective = new Map();
          ngModule.transitiveModule.modules.forEach(function (localModuleMeta) {
              localModuleMeta.declaredDirectives.forEach(function (dirMeta) {
                  moduleByDirective.set(dirMeta.type.reference, localModuleMeta);
                  _this._compileDirectiveWrapper(dirMeta, localModuleMeta);
                  if (dirMeta.isComponent) {
                      templates.add(_this._createCompiledTemplate(dirMeta, localModuleMeta));
                  }
              });
          });
          ngModule.transitiveModule.modules.forEach(function (localModuleMeta) {
              localModuleMeta.declaredDirectives.forEach(function (dirMeta) {
                  if (dirMeta.isComponent) {
                      dirMeta.entryComponents.forEach(function (entryComponentType) {
                          var moduleMeta = moduleByDirective.get(entryComponentType.reference);
                          templates.add(_this._createCompiledHostTemplate(entryComponentType.reference, moduleMeta));
                      });
                  }
              });
              localModuleMeta.entryComponents.forEach(function (entryComponentType) {
                  var moduleMeta = moduleByDirective.get(entryComponentType.reference);
                  templates.add(_this._createCompiledHostTemplate(entryComponentType.reference, moduleMeta));
              });
          });
          templates.forEach(function (template) {
              if (template.loading) {
                  if (isSync) {
                      throw new ComponentStillLoadingError(template.compType.reference);
                  }
                  else {
                      loadingPromises.push(template.loading);
                  }
              }
          });
          var compile = function () { templates.forEach(function (template) { _this._compileTemplate(template); }); };
          if (isSync) {
              compile();
              return Promise.resolve(null);
          }
          else {
              return Promise.all(loadingPromises).then(compile);
          }
      };
      RuntimeCompiler.prototype.clearCacheFor = function (type) {
          this._compiledNgModuleCache.delete(type);
          this._metadataResolver.clearCacheFor(type);
          this._compiledHostTemplateCache.delete(type);
          var compiledTemplate = this._compiledTemplateCache.get(type);
          if (compiledTemplate) {
              this._templateNormalizer.clearCacheFor(compiledTemplate.normalizedCompMeta);
              this._compiledTemplateCache.delete(type);
          }
      };
      RuntimeCompiler.prototype.clearCache = function () {
          this._metadataResolver.clearCache();
          this._compiledTemplateCache.clear();
          this._compiledHostTemplateCache.clear();
          this._templateNormalizer.clearCache();
          this._compiledNgModuleCache.clear();
      };
      RuntimeCompiler.prototype._createCompiledHostTemplate = function (compType, ngModule) {
          if (!ngModule) {
              throw new Error("Component " + stringify(compType) + " is not part of any NgModule or the module has not been imported into your module.");
          }
          var compiledTemplate = this._compiledHostTemplateCache.get(compType);
          if (!compiledTemplate) {
              var compMeta = this._metadataResolver.getDirectiveMetadata(compType);
              assertComponent(compMeta);
              var hostMeta = createHostComponentMeta(compMeta);
              compiledTemplate = new CompiledTemplate(true, compMeta.selector, compMeta.type, ngModule, [compMeta], this._templateNormalizer.normalizeDirective(hostMeta));
              this._compiledHostTemplateCache.set(compType, compiledTemplate);
          }
          return compiledTemplate;
      };
      RuntimeCompiler.prototype._createCompiledTemplate = function (compMeta, ngModule) {
          var compiledTemplate = this._compiledTemplateCache.get(compMeta.type.reference);
          if (!compiledTemplate) {
              assertComponent(compMeta);
              compiledTemplate = new CompiledTemplate(false, compMeta.selector, compMeta.type, ngModule, ngModule.transitiveModule.directives, this._templateNormalizer.normalizeDirective(compMeta));
              this._compiledTemplateCache.set(compMeta.type.reference, compiledTemplate);
          }
          return compiledTemplate;
      };
      RuntimeCompiler.prototype._assertComponentKnown = function (compType, isHost) {
          var compiledTemplate = isHost ? this._compiledHostTemplateCache.get(compType) :
              this._compiledTemplateCache.get(compType);
          if (!compiledTemplate) {
              throw new Error("Illegal state: Compiled view for component " + stringify(compType) + " does not exist!");
          }
          return compiledTemplate;
      };
      RuntimeCompiler.prototype._assertComponentLoaded = function (compType, isHost) {
          var compiledTemplate = this._assertComponentKnown(compType, isHost);
          if (compiledTemplate.loading) {
              throw new Error("Illegal state: CompiledTemplate for " + stringify(compType) + " (isHost: " + isHost + ") is still loading!");
          }
          return compiledTemplate;
      };
      RuntimeCompiler.prototype._assertDirectiveWrapper = function (dirType) {
          var dirWrapper = this._compiledDirectiveWrapperCache.get(dirType);
          if (!dirWrapper) {
              throw new Error("Illegal state: Directive wrapper for " + stringify(dirType) + " has not been compiled!");
          }
          return dirWrapper;
      };
      RuntimeCompiler.prototype._compileDirectiveWrapper = function (dirMeta, moduleMeta) {
          var compileResult = this._directiveWrapperCompiler.compile(dirMeta);
          var statements = compileResult.statements;
          var directiveWrapperClass;
          if (!this._compilerConfig.useJit) {
              directiveWrapperClass = interpretStatements(statements, compileResult.dirWrapperClassVar);
          }
          else {
              directiveWrapperClass = jitStatements("/" + moduleMeta.type.name + "/" + dirMeta.type.name + "/wrapper.ngfactory.js", statements, compileResult.dirWrapperClassVar);
          }
          this._compiledDirectiveWrapperCache.set(dirMeta.type.reference, directiveWrapperClass);
      };
      RuntimeCompiler.prototype._compileTemplate = function (template) {
          var _this = this;
          if (template.isCompiled) {
              return;
          }
          var compMeta = template.normalizedCompMeta;
          var externalStylesheetsByModuleUrl = new Map();
          var stylesCompileResult = this._styleCompiler.compileComponent(compMeta);
          stylesCompileResult.externalStylesheets.forEach(function (r) { externalStylesheetsByModuleUrl.set(r.meta.moduleUrl, r); });
          this._resolveStylesCompileResult(stylesCompileResult.componentStylesheet, externalStylesheetsByModuleUrl);
          var viewCompMetas = template.viewComponentTypes.map(function (compType) { return _this._assertComponentLoaded(compType, false).normalizedCompMeta; });
          var parsedAnimations = this._animationParser.parseComponent(compMeta);
          var parsedTemplate = this._templateParser.parse(compMeta, compMeta.template.template, template.viewDirectives.concat(viewCompMetas), template.viewPipes, template.schemas, compMeta.type.name);
          var compiledAnimations = this._animationCompiler.compile(compMeta.type.name, parsedAnimations);
          var compileResult = this._viewCompiler.compileComponent(compMeta, parsedTemplate, variable(stylesCompileResult.componentStylesheet.stylesVar), template.viewPipes, compiledAnimations);
          compileResult.dependencies.forEach(function (dep) {
              var depTemplate;
              if (dep instanceof ViewFactoryDependency) {
                  var vfd = dep;
                  depTemplate = _this._assertComponentLoaded(vfd.comp.reference, false);
                  vfd.placeholder.reference = depTemplate.proxyViewFactory;
                  vfd.placeholder.name = "viewFactory_" + vfd.comp.name;
              }
              else if (dep instanceof ComponentFactoryDependency) {
                  var cfd = dep;
                  depTemplate = _this._assertComponentLoaded(cfd.comp.reference, true);
                  cfd.placeholder.reference = depTemplate.proxyComponentFactory;
                  cfd.placeholder.name = "compFactory_" + cfd.comp.name;
              }
              else if (dep instanceof DirectiveWrapperDependency) {
                  var dwd = dep;
                  dwd.placeholder.reference = _this._assertDirectiveWrapper(dwd.dir.reference);
              }
          });
          var statements = stylesCompileResult.componentStylesheet.statements.concat(compileResult.statements);
          compiledAnimations.forEach(function (entry) { entry.statements.forEach(function (statement) { statements.push(statement); }); });
          var factory;
          if (!this._compilerConfig.useJit) {
              factory = interpretStatements(statements, compileResult.viewFactoryVar);
          }
          else {
              factory = jitStatements("/" + template.ngModule.type.name + "/" + template.compType.name + "/" + (template.isHost ? 'host' : 'component') + ".ngfactory.js", statements, compileResult.viewFactoryVar);
          }
          template.compiled(factory);
      };
      RuntimeCompiler.prototype._resolveStylesCompileResult = function (result, externalStylesheetsByModuleUrl) {
          var _this = this;
          result.dependencies.forEach(function (dep, i) {
              var nestedCompileResult = externalStylesheetsByModuleUrl.get(dep.moduleUrl);
              var nestedStylesArr = _this._resolveAndEvalStylesCompileResult(nestedCompileResult, externalStylesheetsByModuleUrl);
              dep.valuePlaceholder.reference = nestedStylesArr;
              dep.valuePlaceholder.name = "importedStyles" + i;
          });
      };
      RuntimeCompiler.prototype._resolveAndEvalStylesCompileResult = function (result, externalStylesheetsByModuleUrl) {
          this._resolveStylesCompileResult(result, externalStylesheetsByModuleUrl);
          if (!this._compilerConfig.useJit) {
              return interpretStatements(result.statements, result.stylesVar);
          }
          else {
              return jitStatements("/" + result.meta.moduleUrl + ".css.js", result.statements, result.stylesVar);
          }
      };
      RuntimeCompiler.decorators = [
          { type: _angular_core.Injectable },
      ];
      /** @nocollapse */
      RuntimeCompiler.ctorParameters = [
          { type: _angular_core.Injector, },
          { type: CompileMetadataResolver, },
          { type: DirectiveNormalizer, },
          { type: TemplateParser, },
          { type: StyleCompiler, },
          { type: ViewCompiler, },
          { type: NgModuleCompiler, },
          { type: DirectiveWrapperCompiler, },
          { type: CompilerConfig, },
      ];
      return RuntimeCompiler;
  }());
  var CompiledTemplate = (function () {
      function CompiledTemplate(isHost, selector, compType, ngModule, viewDirectiveAndComponents, _normalizeResult) {
          var _this = this;
          this.isHost = isHost;
          this.compType = compType;
          this.ngModule = ngModule;
          this._viewFactory = null;
          this.loading = null;
          this._normalizedCompMeta = null;
          this.isCompiled = false;
          this.isCompiledWithDeps = false;
          this.viewComponentTypes = [];
          this.viewDirectives = [];
          this.viewPipes = ngModule.transitiveModule.pipes;
          this.schemas = ngModule.schemas;
          viewDirectiveAndComponents.forEach(function (dirMeta) {
              if (dirMeta.isComponent) {
                  _this.viewComponentTypes.push(dirMeta.type.reference);
              }
              else {
                  _this.viewDirectives.push(dirMeta);
              }
          });
          this.proxyViewFactory = function () {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                  args[_i - 0] = arguments[_i];
              }
              if (!_this._viewFactory) {
                  throw new Error("Illegal state: CompiledTemplate for " + stringify(_this.compType) + " is not compiled yet!");
              }
              return _this._viewFactory.apply(null, args);
          };
          this.proxyComponentFactory = isHost ?
              new _angular_core.ComponentFactory(selector, this.proxyViewFactory, compType.reference) :
              null;
          if (_normalizeResult.syncResult) {
              this._normalizedCompMeta = _normalizeResult.syncResult;
          }
          else {
              this.loading = _normalizeResult.asyncResult.then(function (normalizedCompMeta) {
                  _this._normalizedCompMeta = normalizedCompMeta;
                  _this.loading = null;
              });
          }
      }
      Object.defineProperty(CompiledTemplate.prototype, "normalizedCompMeta", {
          get: function () {
              if (this.loading) {
                  throw new Error("Template is still loading for " + this.compType.name + "!");
              }
              return this._normalizedCompMeta;
          },
          enumerable: true,
          configurable: true
      });
      CompiledTemplate.prototype.compiled = function (viewFactory) {
          this._viewFactory = viewFactory;
          this.isCompiled = true;
      };
      CompiledTemplate.prototype.depsCompiled = function () { this.isCompiledWithDeps = true; };
      return CompiledTemplate;
  }());
  function assertComponent(meta) {
      if (!meta.isComponent) {
          throw new Error("Could not compile '" + meta.type.name + "' because it is not a component.");
      }
  }
  /**
   * Implements `Compiler` by delegating to the RuntimeCompiler using a known module.
   */
  var ModuleBoundCompiler = (function () {
      function ModuleBoundCompiler(_delegate, _ngModule) {
          this._delegate = _delegate;
          this._ngModule = _ngModule;
      }
      Object.defineProperty(ModuleBoundCompiler.prototype, "_injector", {
          get: function () { return this._delegate.injector; },
          enumerable: true,
          configurable: true
      });
      ModuleBoundCompiler.prototype.compileModuleSync = function (moduleType) {
          return this._delegate.compileModuleSync(moduleType);
      };
      ModuleBoundCompiler.prototype.compileModuleAsync = function (moduleType) {
          return this._delegate.compileModuleAsync(moduleType);
      };
      ModuleBoundCompiler.prototype.compileModuleAndAllComponentsSync = function (moduleType) {
          return this._delegate.compileModuleAndAllComponentsSync(moduleType);
      };
      ModuleBoundCompiler.prototype.compileModuleAndAllComponentsAsync = function (moduleType) {
          return this._delegate.compileModuleAndAllComponentsAsync(moduleType);
      };
      /**
       * Clears all caches
       */
      ModuleBoundCompiler.prototype.clearCache = function () { this._delegate.clearCache(); };
      /**
       * Clears the cache for the given component/ngModule.
       */
      ModuleBoundCompiler.prototype.clearCacheFor = function (type) { this._delegate.clearCacheFor(type); };
      return ModuleBoundCompiler;
  }());

  // =================================================================================================
  // =================================================================================================
  // =========== S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P  ===========
  // =================================================================================================
  // =================================================================================================
  //
  //        DO NOT EDIT THIS LIST OF SECURITY SENSITIVE PROPERTIES WITHOUT A SECURITY REVIEW!
  //                               Reach out to mprobst for details.
  //
  // =================================================================================================
  /** Map from tagName|propertyName SecurityContext. Properties applying to all tags use '*'. */
  var SECURITY_SCHEMA = {};
  function registerContext(ctx, specs) {
      for (var _i = 0, specs_1 = specs; _i < specs_1.length; _i++) {
          var spec = specs_1[_i];
          SECURITY_SCHEMA[spec.toLowerCase()] = ctx;
      }
  }
  // Case is insignificant below, all element and attribute names are lower-cased for lookup.
  registerContext(_angular_core.SecurityContext.HTML, [
      'iframe|srcdoc',
      '*|innerHTML',
      '*|outerHTML',
  ]);
  registerContext(_angular_core.SecurityContext.STYLE, ['*|style']);
  // NB: no SCRIPT contexts here, they are never allowed due to the parser stripping them.
  registerContext(_angular_core.SecurityContext.URL, [
      '*|formAction', 'area|href', 'area|ping', 'audio|src', 'a|href',
      'a|ping', 'blockquote|cite', 'body|background', 'del|cite', 'form|action',
      'img|src', 'img|srcset', 'input|src', 'ins|cite', 'q|cite',
      'source|src', 'source|srcset', 'track|src', 'video|poster', 'video|src',
  ]);
  registerContext(_angular_core.SecurityContext.RESOURCE_URL, [
      'applet|code',
      'applet|codebase',
      'base|href',
      'embed|src',
      'frame|src',
      'head|profile',
      'html|manifest',
      'iframe|src',
      'link|href',
      'media|src',
      'object|codebase',
      'object|data',
      'script|src',
  ]);

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var __extends$20 = (this && this.__extends) || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var BOOLEAN = 'boolean';
  var NUMBER = 'number';
  var STRING = 'string';
  var OBJECT = 'object';
  /**
   * This array represents the DOM schema. It encodes inheritance, properties, and events.
   *
   * ## Overview
   *
   * Each line represents one kind of element. The `element_inheritance` and properties are joined
   * using `element_inheritance|properties` syntax.
   *
   * ## Element Inheritance
   *
   * The `element_inheritance` can be further subdivided as `element1,element2,...^parentElement`.
   * Here the individual elements are separated by `,` (commas). Every element in the list
   * has identical properties.
   *
   * An `element` may inherit additional properties from `parentElement` If no `^parentElement` is
   * specified then `""` (blank) element is assumed.
   *
   * NOTE: The blank element inherits from root `[Element]` element, the super element of all
   * elements.
   *
   * NOTE an element prefix such as `:svg:` has no special meaning to the schema.
   *
   * ## Properties
   *
   * Each element has a set of properties separated by `,` (commas). Each property can be prefixed
   * by a special character designating its type:
   *
   * - (no prefix): property is a string.
   * - `*`: property represents an event.
   * - `!`: property is a boolean.
   * - `#`: property is a number.
   * - `%`: property is an object.
   *
   * ## Query
   *
   * The class creates an internal squas representation which allows to easily answer the query of
   * if a given property exist on a given element.
   *
   * NOTE: We don't yet support querying for types or events.
   * NOTE: This schema is auto extracted from `schema_extractor.ts` located in the test folder,
   *       see dom_element_schema_registry_spec.ts
   */
  // =================================================================================================
  // =================================================================================================
  // =========== S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P  ===========
  // =================================================================================================
  // =================================================================================================
  //
  //                       DO NOT EDIT THIS DOM SCHEMA WITHOUT A SECURITY REVIEW!
  //
  // Newly added properties must be security reviewed and assigned an appropriate SecurityContext in
  // dom_security_schema.ts. Reach out to mprobst & rjamet for details.
  //
  // =================================================================================================
  var SCHEMA = [
      '[Element]|textContent,%classList,className,id,innerHTML,*beforecopy,*beforecut,*beforepaste,*copy,*cut,*paste,*search,*selectstart,*webkitfullscreenchange,*webkitfullscreenerror,*wheel,outerHTML,#scrollLeft,#scrollTop',
      '[HTMLElement]^[Element]|accessKey,contentEditable,dir,!draggable,!hidden,innerText,lang,*abort,*beforecopy,*beforecut,*beforepaste,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*message,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*paste,*pause,*play,*playing,*progress,*ratechange,*reset,*resize,*scroll,*search,*seeked,*seeking,*select,*selectstart,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored,*webkitfullscreenchange,*webkitfullscreenerror,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate',
      'abbr,address,article,aside,b,bdi,bdo,cite,code,dd,dfn,dt,em,figcaption,figure,footer,header,i,kbd,main,mark,nav,noscript,rb,rp,rt,rtc,ruby,s,samp,section,small,strong,sub,sup,u,var,wbr^[HTMLElement]|accessKey,contentEditable,dir,!draggable,!hidden,innerText,lang,*abort,*beforecopy,*beforecut,*beforepaste,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*message,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*paste,*pause,*play,*playing,*progress,*ratechange,*reset,*resize,*scroll,*search,*seeked,*seeking,*select,*selectstart,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored,*webkitfullscreenchange,*webkitfullscreenerror,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate',
      'media^[HTMLElement]|!autoplay,!controls,%crossOrigin,#currentTime,!defaultMuted,#defaultPlaybackRate,!disableRemotePlayback,!loop,!muted,*encrypted,#playbackRate,preload,src,%srcObject,#volume',
      ':svg:^[HTMLElement]|*abort,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,%style,#tabIndex',
      ':svg:graphics^:svg:|',
      ':svg:animation^:svg:|*begin,*end,*repeat',
      ':svg:geometry^:svg:|',
      ':svg:componentTransferFunction^:svg:|',
      ':svg:gradient^:svg:|',
      ':svg:textContent^:svg:graphics|',
      ':svg:textPositioning^:svg:textContent|',
      'a^[HTMLElement]|charset,coords,download,hash,host,hostname,href,hreflang,name,password,pathname,ping,port,protocol,referrerPolicy,rel,rev,search,shape,target,text,type,username',
      'area^[HTMLElement]|alt,coords,hash,host,hostname,href,!noHref,password,pathname,ping,port,protocol,referrerPolicy,search,shape,target,username',
      'audio^media|',
      'br^[HTMLElement]|clear',
      'base^[HTMLElement]|href,target',
      'body^[HTMLElement]|aLink,background,bgColor,link,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,text,vLink',
      'button^[HTMLElement]|!autofocus,!disabled,formAction,formEnctype,formMethod,!formNoValidate,formTarget,name,type,value',
      'canvas^[HTMLElement]|#height,#width',
      'content^[HTMLElement]|select',
      'dl^[HTMLElement]|!compact',
      'datalist^[HTMLElement]|',
      'details^[HTMLElement]|!open',
      'dialog^[HTMLElement]|!open,returnValue',
      'dir^[HTMLElement]|!compact',
      'div^[HTMLElement]|align',
      'embed^[HTMLElement]|align,height,name,src,type,width',
      'fieldset^[HTMLElement]|!disabled,name',
      'font^[HTMLElement]|color,face,size',
      'form^[HTMLElement]|acceptCharset,action,autocomplete,encoding,enctype,method,name,!noValidate,target',
      'frame^[HTMLElement]|frameBorder,longDesc,marginHeight,marginWidth,name,!noResize,scrolling,src',
      'frameset^[HTMLElement]|cols,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,rows',
      'hr^[HTMLElement]|align,color,!noShade,size,width',
      'head^[HTMLElement]|',
      'h1,h2,h3,h4,h5,h6^[HTMLElement]|align',
      'html^[HTMLElement]|version',
      'iframe^[HTMLElement]|align,!allowFullscreen,frameBorder,height,longDesc,marginHeight,marginWidth,name,referrerPolicy,%sandbox,scrolling,src,srcdoc,width',
      'img^[HTMLElement]|align,alt,border,%crossOrigin,#height,#hspace,!isMap,longDesc,lowsrc,name,referrerPolicy,sizes,src,srcset,useMap,#vspace,#width',
      'input^[HTMLElement]|accept,align,alt,autocapitalize,autocomplete,!autofocus,!checked,!defaultChecked,defaultValue,dirName,!disabled,%files,formAction,formEnctype,formMethod,!formNoValidate,formTarget,#height,!incremental,!indeterminate,max,#maxLength,min,#minLength,!multiple,name,pattern,placeholder,!readOnly,!required,selectionDirection,#selectionEnd,#selectionStart,#size,src,step,type,useMap,value,%valueAsDate,#valueAsNumber,#width',
      'keygen^[HTMLElement]|!autofocus,challenge,!disabled,keytype,name',
      'li^[HTMLElement]|type,#value',
      'label^[HTMLElement]|htmlFor',
      'legend^[HTMLElement]|align',
      'link^[HTMLElement]|as,charset,%crossOrigin,!disabled,href,hreflang,integrity,media,rel,%relList,rev,%sizes,target,type',
      'map^[HTMLElement]|name',
      'marquee^[HTMLElement]|behavior,bgColor,direction,height,#hspace,#loop,#scrollAmount,#scrollDelay,!trueSpeed,#vspace,width',
      'menu^[HTMLElement]|!compact',
      'meta^[HTMLElement]|content,httpEquiv,name,scheme',
      'meter^[HTMLElement]|#high,#low,#max,#min,#optimum,#value',
      'ins,del^[HTMLElement]|cite,dateTime',
      'ol^[HTMLElement]|!compact,!reversed,#start,type',
      'object^[HTMLElement]|align,archive,border,code,codeBase,codeType,data,!declare,height,#hspace,name,standby,type,useMap,#vspace,width',
      'optgroup^[HTMLElement]|!disabled,label',
      'option^[HTMLElement]|!defaultSelected,!disabled,label,!selected,text,value',
      'output^[HTMLElement]|defaultValue,%htmlFor,name,value',
      'p^[HTMLElement]|align',
      'param^[HTMLElement]|name,type,value,valueType',
      'picture^[HTMLElement]|',
      'pre^[HTMLElement]|#width',
      'progress^[HTMLElement]|#max,#value',
      'q,blockquote,cite^[HTMLElement]|',
      'script^[HTMLElement]|!async,charset,%crossOrigin,!defer,event,htmlFor,integrity,src,text,type',
      'select^[HTMLElement]|!autofocus,!disabled,#length,!multiple,name,!required,#selectedIndex,#size,value',
      'shadow^[HTMLElement]|',
      'source^[HTMLElement]|media,sizes,src,srcset,type',
      'span^[HTMLElement]|',
      'style^[HTMLElement]|!disabled,media,type',
      'caption^[HTMLElement]|align',
      'th,td^[HTMLElement]|abbr,align,axis,bgColor,ch,chOff,#colSpan,headers,height,!noWrap,#rowSpan,scope,vAlign,width',
      'col,colgroup^[HTMLElement]|align,ch,chOff,#span,vAlign,width',
      'table^[HTMLElement]|align,bgColor,border,%caption,cellPadding,cellSpacing,frame,rules,summary,%tFoot,%tHead,width',
      'tr^[HTMLElement]|align,bgColor,ch,chOff,vAlign',
      'tfoot,thead,tbody^[HTMLElement]|align,ch,chOff,vAlign',
      'template^[HTMLElement]|',
      'textarea^[HTMLElement]|autocapitalize,!autofocus,#cols,defaultValue,dirName,!disabled,#maxLength,#minLength,name,placeholder,!readOnly,!required,#rows,selectionDirection,#selectionEnd,#selectionStart,value,wrap',
      'title^[HTMLElement]|text',
      'track^[HTMLElement]|!default,kind,label,src,srclang',
      'ul^[HTMLElement]|!compact,type',
      'unknown^[HTMLElement]|',
      'video^media|#height,poster,#width',
      ':svg:a^:svg:graphics|',
      ':svg:animate^:svg:animation|',
      ':svg:animateMotion^:svg:animation|',
      ':svg:animateTransform^:svg:animation|',
      ':svg:circle^:svg:geometry|',
      ':svg:clipPath^:svg:graphics|',
      ':svg:cursor^:svg:|',
      ':svg:defs^:svg:graphics|',
      ':svg:desc^:svg:|',
      ':svg:discard^:svg:|',
      ':svg:ellipse^:svg:geometry|',
      ':svg:feBlend^:svg:|',
      ':svg:feColorMatrix^:svg:|',
      ':svg:feComponentTransfer^:svg:|',
      ':svg:feComposite^:svg:|',
      ':svg:feConvolveMatrix^:svg:|',
      ':svg:feDiffuseLighting^:svg:|',
      ':svg:feDisplacementMap^:svg:|',
      ':svg:feDistantLight^:svg:|',
      ':svg:feDropShadow^:svg:|',
      ':svg:feFlood^:svg:|',
      ':svg:feFuncA^:svg:componentTransferFunction|',
      ':svg:feFuncB^:svg:componentTransferFunction|',
      ':svg:feFuncG^:svg:componentTransferFunction|',
      ':svg:feFuncR^:svg:componentTransferFunction|',
      ':svg:feGaussianBlur^:svg:|',
      ':svg:feImage^:svg:|',
      ':svg:feMerge^:svg:|',
      ':svg:feMergeNode^:svg:|',
      ':svg:feMorphology^:svg:|',
      ':svg:feOffset^:svg:|',
      ':svg:fePointLight^:svg:|',
      ':svg:feSpecularLighting^:svg:|',
      ':svg:feSpotLight^:svg:|',
      ':svg:feTile^:svg:|',
      ':svg:feTurbulence^:svg:|',
      ':svg:filter^:svg:|',
      ':svg:foreignObject^:svg:graphics|',
      ':svg:g^:svg:graphics|',
      ':svg:image^:svg:graphics|',
      ':svg:line^:svg:geometry|',
      ':svg:linearGradient^:svg:gradient|',
      ':svg:mpath^:svg:|',
      ':svg:marker^:svg:|',
      ':svg:mask^:svg:|',
      ':svg:metadata^:svg:|',
      ':svg:path^:svg:geometry|',
      ':svg:pattern^:svg:|',
      ':svg:polygon^:svg:geometry|',
      ':svg:polyline^:svg:geometry|',
      ':svg:radialGradient^:svg:gradient|',
      ':svg:rect^:svg:geometry|',
      ':svg:svg^:svg:graphics|#currentScale,#zoomAndPan',
      ':svg:script^:svg:|type',
      ':svg:set^:svg:animation|',
      ':svg:stop^:svg:|',
      ':svg:style^:svg:|!disabled,media,title,type',
      ':svg:switch^:svg:graphics|',
      ':svg:symbol^:svg:|',
      ':svg:tspan^:svg:textPositioning|',
      ':svg:text^:svg:textPositioning|',
      ':svg:textPath^:svg:textContent|',
      ':svg:title^:svg:|',
      ':svg:use^:svg:graphics|',
      ':svg:view^:svg:|#zoomAndPan',
      'data^[HTMLElement]|value',
      'menuitem^[HTMLElement]|type,label,icon,!disabled,!checked,radiogroup,!default',
      'summary^[HTMLElement]|',
      'time^[HTMLElement]|dateTime',
  ];
  var _ATTR_TO_PROP = {
      'class': 'className',
      'formaction': 'formAction',
      'innerHtml': 'innerHTML',
      'readonly': 'readOnly',
      'tabindex': 'tabIndex',
  };
  var DomElementSchemaRegistry = (function (_super) {
      __extends$20(DomElementSchemaRegistry, _super);
      function DomElementSchemaRegistry() {
          var _this = this;
          _super.call(this);
          this._schema = {};
          SCHEMA.forEach(function (encodedType) {
              var type = {};
              var _a = encodedType.split('|'), strType = _a[0], strProperties = _a[1];
              var properties = strProperties.split(',');
              var _b = strType.split('^'), typeNames = _b[0], superName = _b[1];
              typeNames.split(',').forEach(function (tag) { return _this._schema[tag.toLowerCase()] = type; });
              var superType = superName && _this._schema[superName.toLowerCase()];
              if (superType) {
                  Object.keys(superType).forEach(function (prop) { type[prop] = superType[prop]; });
              }
              properties.forEach(function (property) {
                  if (property.length > 0) {
                      switch (property[0]) {
                          case '*':
                              // We don't yet support events.
                              // If ever allowing to bind to events, GO THROUGH A SECURITY REVIEW, allowing events
                              // will
                              // almost certainly introduce bad XSS vulnerabilities.
                              // type[property.substring(1)] = EVENT;
                              break;
                          case '!':
                              type[property.substring(1)] = BOOLEAN;
                              break;
                          case '#':
                              type[property.substring(1)] = NUMBER;
                              break;
                          case '%':
                              type[property.substring(1)] = OBJECT;
                              break;
                          default:
                              type[property] = STRING;
                      }
                  }
              });
          });
      }
      DomElementSchemaRegistry.prototype.hasProperty = function (tagName, propName, schemaMetas) {
          if (schemaMetas.some(function (schema) { return schema.name === _angular_core.NO_ERRORS_SCHEMA.name; })) {
              return true;
          }
          if (tagName.indexOf('-') > -1) {
              if (tagName === 'ng-container' || tagName === 'ng-content') {
                  return false;
              }
              if (schemaMetas.some(function (schema) { return schema.name === _angular_core.CUSTOM_ELEMENTS_SCHEMA.name; })) {
                  // Can't tell now as we don't know which properties a custom element will get
                  // once it is instantiated
                  return true;
              }
          }
          var elementProperties = this._schema[tagName.toLowerCase()] || this._schema['unknown'];
          return !!elementProperties[propName];
      };
      DomElementSchemaRegistry.prototype.hasElement = function (tagName, schemaMetas) {
          if (schemaMetas.some(function (schema) { return schema.name === _angular_core.NO_ERRORS_SCHEMA.name; })) {
              return true;
          }
          if (tagName.indexOf('-') > -1) {
              if (tagName === 'ng-container' || tagName === 'ng-content') {
                  return true;
              }
              if (schemaMetas.some(function (schema) { return schema.name === _angular_core.CUSTOM_ELEMENTS_SCHEMA.name; })) {
                  // Allow any custom elements
                  return true;
              }
          }
          return !!this._schema[tagName.toLowerCase()];
      };
      /**
       * securityContext returns the security context for the given property on the given DOM tag.
       *
       * Tag and property name are statically known and cannot change at runtime, i.e. it is not
       * possible to bind a value into a changing attribute or tag name.
       *
       * The filtering is white list based. All attributes in the schema above are assumed to have the
       * 'NONE' security context, i.e. that they are safe inert string values. Only specific well known
       * attack vectors are assigned their appropriate context.
       */
      DomElementSchemaRegistry.prototype.securityContext = function (tagName, propName) {
          // Make sure comparisons are case insensitive, so that case differences between attribute and
          // property names do not have a security impact.
          tagName = tagName.toLowerCase();
          propName = propName.toLowerCase();
          var ctx = SECURITY_SCHEMA[tagName + '|' + propName];
          if (ctx) {
              return ctx;
          }
          ctx = SECURITY_SCHEMA['*|' + propName];
          return ctx ? ctx : _angular_core.SecurityContext.NONE;
      };
      DomElementSchemaRegistry.prototype.getMappedPropName = function (propName) { return _ATTR_TO_PROP[propName] || propName; };
      DomElementSchemaRegistry.prototype.getDefaultComponentElementName = function () { return 'ng-component'; };
      DomElementSchemaRegistry.prototype.validateProperty = function (name) {
          if (name.toLowerCase().startsWith('on')) {
              var msg = ("Binding to event property '" + name + "' is disallowed for security reasons, ") +
                  ("please use (" + name.slice(2) + ")=...") +
                  ("\nIf '" + name + "' is a directive input, make sure the directive is imported by the") +
                  " current module.";
              return { error: true, msg: msg };
          }
          else {
              return { error: false };
          }
      };
      DomElementSchemaRegistry.prototype.validateAttribute = function (name) {
          if (name.toLowerCase().startsWith('on')) {
              var msg = ("Binding to event attribute '" + name + "' is disallowed for security reasons, ") +
                  ("please use (" + name.slice(2) + ")=...");
              return { error: true, msg: msg };
          }
          else {
              return { error: false };
          }
      };
      DomElementSchemaRegistry.decorators = [
          { type: _angular_core.Injectable },
      ];
      /** @nocollapse */
      DomElementSchemaRegistry.ctorParameters = [];
      return DomElementSchemaRegistry;
  }(ElementSchemaRegistry));

  var _NO_RESOURCE_LOADER = {
      get: function (url) {
          throw new Error("No ResourceLoader implementation has been provided. Can't read the url \"" + url + "\"");
      }
  };
  /**
   * A set of providers that provide `RuntimeCompiler` and its dependencies to use for
   * template compilation.
   */
  var COMPILER_PROVIDERS = [
      { provide: Reflector, useValue: reflector },
      { provide: ReflectorReader, useExisting: Reflector },
      { provide: ResourceLoader, useValue: _NO_RESOURCE_LOADER },
      Console,
      Lexer,
      Parser,
      HtmlParser,
      {
          provide: I18NHtmlParser,
          useFactory: function (parser, translations, format) {
              return new I18NHtmlParser(parser, translations, format);
          },
          deps: [
              HtmlParser,
              [new _angular_core.Optional(), new _angular_core.Inject(_angular_core.TRANSLATIONS)],
              [new _angular_core.Optional(), new _angular_core.Inject(_angular_core.TRANSLATIONS_FORMAT)],
          ]
      },
      TemplateParser,
      DirectiveNormalizer,
      CompileMetadataResolver,
      DEFAULT_PACKAGE_URL_PROVIDER,
      StyleCompiler,
      ViewCompiler,
      NgModuleCompiler,
      DirectiveWrapperCompiler,
      { provide: CompilerConfig, useValue: new CompilerConfig() },
      RuntimeCompiler,
      { provide: _angular_core.Compiler, useExisting: RuntimeCompiler },
      DomElementSchemaRegistry,
      { provide: ElementSchemaRegistry, useExisting: DomElementSchemaRegistry },
      UrlResolver,
      DirectiveResolver,
      PipeResolver,
      NgModuleResolver
  ];
  var RuntimeCompilerFactory = (function () {
      function RuntimeCompilerFactory(defaultOptions) {
          this._defaultOptions = [{
                  useDebug: _angular_core.isDevMode(),
                  useJit: true,
                  defaultEncapsulation: _angular_core.ViewEncapsulation.Emulated
              }].concat(defaultOptions);
      }
      RuntimeCompilerFactory.prototype.createCompiler = function (options) {
          if (options === void 0) { options = []; }
          var mergedOptions = _mergeOptions(this._defaultOptions.concat(options));
          var injector = _angular_core.ReflectiveInjector.resolveAndCreate([
              COMPILER_PROVIDERS, {
                  provide: CompilerConfig,
                  useFactory: function () {
                      return new CompilerConfig({
                          // let explicit values from the compiler options overwrite options
                          // from the app providers. E.g. important for the testing platform.
                          genDebugInfo: mergedOptions.useDebug,
                          // let explicit values from the compiler options overwrite options
                          // from the app providers
                          useJit: mergedOptions.useJit,
                          // let explicit values from the compiler options overwrite options
                          // from the app providers
                          defaultEncapsulation: mergedOptions.defaultEncapsulation,
                          logBindingUpdate: mergedOptions.useDebug
                      });
                  },
                  deps: []
              },
              mergedOptions.providers
          ]);
          return injector.get(_angular_core.Compiler);
      };
      RuntimeCompilerFactory.decorators = [
          { type: _angular_core.Injectable },
      ];
      /** @nocollapse */
      RuntimeCompilerFactory.ctorParameters = [
          { type: Array, decorators: [{ type: _angular_core.Inject, args: [_angular_core.COMPILER_OPTIONS,] },] },
      ];
      return RuntimeCompilerFactory;
  }());
  function _initReflector() {
      reflector.reflectionCapabilities = new ReflectionCapabilities();
  }
  /**
   * A platform that included corePlatform and the compiler.
   *
   * @experimental
   */
  var platformCoreDynamic = _angular_core.createPlatformFactory(_angular_core.platformCore, 'coreDynamic', [
      { provide: _angular_core.COMPILER_OPTIONS, useValue: {}, multi: true },
      { provide: _angular_core.CompilerFactory, useClass: RuntimeCompilerFactory },
      { provide: _angular_core.PLATFORM_INITIALIZER, useValue: _initReflector, multi: true },
  ]);
  function _mergeOptions(optionsArr) {
      return {
          useDebug: _lastDefined(optionsArr.map(function (options) { return options.useDebug; })),
          useJit: _lastDefined(optionsArr.map(function (options) { return options.useJit; })),
          defaultEncapsulation: _lastDefined(optionsArr.map(function (options) { return options.defaultEncapsulation; })),
          providers: _mergeArrays(optionsArr.map(function (options) { return options.providers; }))
      };
  }
  function _lastDefined(args) {
      for (var i = args.length - 1; i >= 0; i--) {
          if (args[i] !== undefined) {
              return args[i];
          }
      }
      return undefined;
  }
  function _mergeArrays(parts) {
      var result = [];
      parts.forEach(function (part) { return part && result.push.apply(result, part); });
      return result;
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  // asset:<package-name>/<realm>/<path-to-module>
  var _ASSET_URL_RE = /asset:([^\/]+)\/([^\/]+)\/(.+)/;
  /**
   * Interface that defines how import statements should be generated.
   */
  var ImportGenerator = (function () {
      function ImportGenerator() {
      }
      ImportGenerator.parseAssetUrl = function (url) { return AssetUrl.parse(url); };
      return ImportGenerator;
  }());
  var AssetUrl = (function () {
      function AssetUrl(packageName, firstLevelDir, modulePath) {
          this.packageName = packageName;
          this.firstLevelDir = firstLevelDir;
          this.modulePath = modulePath;
      }
      AssetUrl.parse = function (url, allowNonMatching) {
          if (allowNonMatching === void 0) { allowNonMatching = true; }
          var match = url.match(_ASSET_URL_RE);
          if (match !== null) {
              return new AssetUrl(match[1], match[2], match[3]);
          }
          if (allowNonMatching) {
              return null;
          }
          throw new Error("Url " + url + " is not a valid asset: url");
      };
      return AssetUrl;
  }());

  exports.TEMPLATE_TRANSFORMS = TEMPLATE_TRANSFORMS;
  exports.CompilerConfig = CompilerConfig;
  exports.RenderTypes = RenderTypes;
  exports.RuntimeCompiler = RuntimeCompiler;
  exports.DirectiveResolver = DirectiveResolver;
  exports.PipeResolver = PipeResolver;
  exports.NgModuleResolver = NgModuleResolver;
  exports.DEFAULT_INTERPOLATION_CONFIG = DEFAULT_INTERPOLATION_CONFIG;
  exports.InterpolationConfig = InterpolationConfig;
  exports.ElementSchemaRegistry = ElementSchemaRegistry;
  exports.NgModuleCompiler = NgModuleCompiler;
  exports.DirectiveWrapperCompiler = DirectiveWrapperCompiler;
  exports.ViewCompiler = ViewCompiler;
  exports.TextAst = TextAst;
  exports.BoundTextAst = BoundTextAst;
  exports.AttrAst = AttrAst;
  exports.BoundElementPropertyAst = BoundElementPropertyAst;
  exports.BoundEventAst = BoundEventAst;
  exports.ReferenceAst = ReferenceAst;
  exports.VariableAst = VariableAst;
  exports.ElementAst = ElementAst;
  exports.EmbeddedTemplateAst = EmbeddedTemplateAst;
  exports.BoundDirectivePropertyAst = BoundDirectivePropertyAst;
  exports.DirectiveAst = DirectiveAst;
  exports.ProviderAst = ProviderAst;
  exports.NgContentAst = NgContentAst;
  exports.templateVisitAll = templateVisitAll;
  exports.CompileMetadataWithIdentifier = CompileMetadataWithIdentifier;
  exports.CompileAnimationEntryMetadata = CompileAnimationEntryMetadata;
  exports.CompileAnimationStateMetadata = CompileAnimationStateMetadata;
  exports.CompileAnimationStateDeclarationMetadata = CompileAnimationStateDeclarationMetadata;
  exports.CompileAnimationStateTransitionMetadata = CompileAnimationStateTransitionMetadata;
  exports.CompileAnimationMetadata = CompileAnimationMetadata;
  exports.CompileAnimationKeyframesSequenceMetadata = CompileAnimationKeyframesSequenceMetadata;
  exports.CompileAnimationStyleMetadata = CompileAnimationStyleMetadata;
  exports.CompileAnimationAnimateMetadata = CompileAnimationAnimateMetadata;
  exports.CompileAnimationWithStepsMetadata = CompileAnimationWithStepsMetadata;
  exports.CompileAnimationSequenceMetadata = CompileAnimationSequenceMetadata;
  exports.CompileAnimationGroupMetadata = CompileAnimationGroupMetadata;
  exports.CompileIdentifierMetadata = CompileIdentifierMetadata;
  exports.CompileDiDependencyMetadata = CompileDiDependencyMetadata;
  exports.CompileProviderMetadata = CompileProviderMetadata;
  exports.CompileFactoryMetadata = CompileFactoryMetadata;
  exports.CompileTokenMetadata = CompileTokenMetadata;
  exports.CompileTypeMetadata = CompileTypeMetadata;
  exports.CompileQueryMetadata = CompileQueryMetadata;
  exports.CompileStylesheetMetadata = CompileStylesheetMetadata;
  exports.CompileTemplateMetadata = CompileTemplateMetadata;
  exports.CompileDirectiveMetadata = CompileDirectiveMetadata;
  exports.createHostComponentMeta = createHostComponentMeta;
  exports.CompilePipeMetadata = CompilePipeMetadata;
  exports.CompileNgModuleMetadata = CompileNgModuleMetadata;
  exports.TransitiveCompileNgModuleMetadata = TransitiveCompileNgModuleMetadata;
  exports.removeIdentifierDuplicates = removeIdentifierDuplicates;
  exports.isStaticSymbol = isStaticSymbol;
  exports.ProviderMeta = ProviderMeta;
  exports.SourceModule = SourceModule;
  exports.NgModulesSummary = NgModulesSummary;
  exports.analyzeModules = analyzeModules;
  exports.OfflineCompiler = OfflineCompiler;
  exports.createUrlResolverWithoutPackagePrefix = createUrlResolverWithoutPackagePrefix;
  exports.createOfflineCompileUrlResolver = createOfflineCompileUrlResolver;
  exports.DEFAULT_PACKAGE_URL_PROVIDER = DEFAULT_PACKAGE_URL_PROVIDER;
  exports.UrlResolver = UrlResolver;
  exports.getUrlScheme = getUrlScheme;
  exports.ResourceLoader = ResourceLoader;
  exports.COMPILER_PROVIDERS = COMPILER_PROVIDERS;
  exports.RuntimeCompilerFactory = RuntimeCompilerFactory;
  exports.platformCoreDynamic = platformCoreDynamic;
  exports.I18NHtmlParser = I18NHtmlParser;
  exports.MessageBundle = MessageBundle;
  exports.Xliff = Xliff;
  exports.Xmb = Xmb;
  exports.Xtb = Xtb;
  exports.DirectiveNormalizer = DirectiveNormalizer;
  exports.Lexer = Lexer;
  exports.Token = Token;
  exports.EOF = EOF;
  exports.isIdentifier = isIdentifier;
  exports.isQuote = isQuote;
  exports.SplitInterpolation = SplitInterpolation;
  exports.TemplateBindingParseResult = TemplateBindingParseResult;
  exports.Parser = Parser;
  exports._ParseAST = _ParseAST;
  exports.CompileMetadataResolver = CompileMetadataResolver;
  exports.HtmlParser = HtmlParser;
  exports.ParseTreeResult = ParseTreeResult;
  exports.TreeError = TreeError;
  exports.ImportGenerator = ImportGenerator;
  exports.AssetUrl = AssetUrl;
  exports.debugOutputAstAsTypeScript = debugOutputAstAsTypeScript;
  exports.TypeScriptEmitter = TypeScriptEmitter;
  exports.ParseLocation = ParseLocation;
  exports.ParseSourceFile = ParseSourceFile;
  exports.ParseSourceSpan = ParseSourceSpan;
  exports.ParseError = ParseError;
  exports.DomElementSchemaRegistry = DomElementSchemaRegistry;
  exports.CssSelector = CssSelector;
  exports.SelectorMatcher = SelectorMatcher;
  exports.SelectorListContext = SelectorListContext;
  exports.SelectorContext = SelectorContext;
  exports.StylesCompileDependency = StylesCompileDependency;
  exports.StylesCompileResult = StylesCompileResult;
  exports.CompiledStylesheet = CompiledStylesheet;
  exports.StyleCompiler = StyleCompiler;
  exports.TemplateParseError = TemplateParseError;
  exports.TemplateParseResult = TemplateParseResult;
  exports.TemplateParser = TemplateParser;
  exports.splitClasses = splitClasses;
  exports.PipeCollector = PipeCollector;

}));

},{"@angular/core":6}],6:[function(require,module,exports){
(function (global){
/**
 * @license Angular v2.1.1
 * (c) 2010-2016 Google, Inc. https://angular.io/
 * License: MIT
 */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('rxjs/Subject'), require('rxjs/Observable')) :
    typeof define === 'function' && define.amd ? define(['exports', 'rxjs/Subject', 'rxjs/Observable'], factory) :
    (factory((global.ng = global.ng || {}, global.ng.core = global.ng.core || {}),global.Rx,global.Rx));
}(this, function (exports,rxjs_Subject,rxjs_Observable) { 'use strict';

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var globalScope;
    if (typeof window === 'undefined') {
        if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
            // TODO: Replace any with WorkerGlobalScope from lib.webworker.d.ts #3492
            globalScope = self;
        }
        else {
            globalScope = global;
        }
    }
    else {
        globalScope = window;
    }
    function scheduleMicroTask(fn) {
        Zone.current.scheduleMicroTask('scheduleMicrotask', fn);
    }
    // Need to declare a new variable for global here since TypeScript
    // exports the original value of the symbol.
    var global$1 = globalScope;
    function getTypeNameForDebugging(type) {
        return type['name'] || typeof type;
    }
    // TODO: remove calls to assert in production environment
    // Note: Can't just export this and import in in other files
    // as `assert` is a reserved keyword in Dart
    global$1.assert = function assert(condition) {
        // TODO: to be fixed properly via #2830, noop for now
    };
    function isPresent(obj) {
        return obj !== undefined && obj !== null;
    }
    function isBlank(obj) {
        return obj === undefined || obj === null;
    }
    function stringify(token) {
        if (typeof token === 'string') {
            return token;
        }
        if (token === undefined || token === null) {
            return '' + token;
        }
        if (token.overriddenName) {
            return token.overriddenName;
        }
        if (token.name) {
            return token.name;
        }
        var res = token.toString();
        var newLineIndex = res.indexOf('\n');
        return newLineIndex === -1 ? res : res.substring(0, newLineIndex);
    }
    // JS has NaN !== NaN
    function looseIdentical(a, b) {
        return a === b || typeof a === 'number' && typeof b === 'number' && isNaN(a) && isNaN(b);
    }
    function isJsObject(o) {
        return o !== null && (typeof o === 'function' || typeof o === 'object');
    }
    function print(obj) {
        console.log(obj);
    }
    function warn(obj) {
        console.warn(obj);
    }
    var _symbolIterator = null;
    function getSymbolIterator() {
        if (isBlank(_symbolIterator)) {
            if (isPresent(globalScope.Symbol) && isPresent(Symbol.iterator)) {
                _symbolIterator = Symbol.iterator;
            }
            else {
                // es6-shim specific logic
                var keys = Object.getOwnPropertyNames(Map.prototype);
                for (var i = 0; i < keys.length; ++i) {
                    var key = keys[i];
                    if (key !== 'entries' && key !== 'size' &&
                        Map.prototype[key] === Map.prototype['entries']) {
                        _symbolIterator = key;
                    }
                }
            }
        }
        return _symbolIterator;
    }
    function isPrimitive(obj) {
        return !isJsObject(obj);
    }

    var _nextClassId = 0;
    var Reflect = global$1.Reflect;
    function extractAnnotation(annotation) {
        if (typeof annotation === 'function' && annotation.hasOwnProperty('annotation')) {
            // it is a decorator, extract annotation
            annotation = annotation.annotation;
        }
        return annotation;
    }
    function applyParams(fnOrArray, key) {
        if (fnOrArray === Object || fnOrArray === String || fnOrArray === Function ||
            fnOrArray === Number || fnOrArray === Array) {
            throw new Error("Can not use native " + stringify(fnOrArray) + " as constructor");
        }
        if (typeof fnOrArray === 'function') {
            return fnOrArray;
        }
        if (Array.isArray(fnOrArray)) {
            var annotations = fnOrArray;
            var annoLength = annotations.length - 1;
            var fn = fnOrArray[annoLength];
            if (typeof fn !== 'function') {
                throw new Error("Last position of Class method array must be Function in key " + key + " was '" + stringify(fn) + "'");
            }
            if (annoLength != fn.length) {
                throw new Error("Number of annotations (" + annoLength + ") does not match number of arguments (" + fn.length + ") in the function: " + stringify(fn));
            }
            var paramsAnnotations = [];
            for (var i = 0, ii = annotations.length - 1; i < ii; i++) {
                var paramAnnotations = [];
                paramsAnnotations.push(paramAnnotations);
                var annotation = annotations[i];
                if (Array.isArray(annotation)) {
                    for (var j = 0; j < annotation.length; j++) {
                        paramAnnotations.push(extractAnnotation(annotation[j]));
                    }
                }
                else if (typeof annotation === 'function') {
                    paramAnnotations.push(extractAnnotation(annotation));
                }
                else {
                    paramAnnotations.push(annotation);
                }
            }
            Reflect.defineMetadata('parameters', paramsAnnotations, fn);
            return fn;
        }
        throw new Error("Only Function or Array is supported in Class definition for key '" + key + "' is '" + stringify(fnOrArray) + "'");
    }
    /**
     * Provides a way for expressing ES6 classes with parameter annotations in ES5.
     *
     * ## Basic Example
     *
     * ```
     * var Greeter = ng.Class({
     *   constructor: function(name) {
     *     this.name = name;
     *   },
     *
     *   greet: function() {
     *     alert('Hello ' + this.name + '!');
     *   }
     * });
     * ```
     *
     * is equivalent to ES6:
     *
     * ```
     * class Greeter {
     *   constructor(name) {
     *     this.name = name;
     *   }
     *
     *   greet() {
     *     alert('Hello ' + this.name + '!');
     *   }
     * }
     * ```
     *
     * or equivalent to ES5:
     *
     * ```
     * var Greeter = function (name) {
     *   this.name = name;
     * }
     *
     * Greeter.prototype.greet = function () {
     *   alert('Hello ' + this.name + '!');
     * }
     * ```
     *
     * ### Example with parameter annotations
     *
     * ```
     * var MyService = ng.Class({
     *   constructor: [String, [new Optional(), Service], function(name, myService) {
     *     ...
     *   }]
     * });
     * ```
     *
     * is equivalent to ES6:
     *
     * ```
     * class MyService {
     *   constructor(name: string, @Optional() myService: Service) {
     *     ...
     *   }
     * }
     * ```
     *
     * ### Example with inheritance
     *
     * ```
     * var Shape = ng.Class({
     *   constructor: (color) {
     *     this.color = color;
     *   }
     * });
     *
     * var Square = ng.Class({
     *   extends: Shape,
     *   constructor: function(color, size) {
     *     Shape.call(this, color);
     *     this.size = size;
     *   }
     * });
     * ```
     * @stable
     */
    function Class(clsDef) {
        var constructor = applyParams(clsDef.hasOwnProperty('constructor') ? clsDef.constructor : undefined, 'constructor');
        var proto = constructor.prototype;
        if (clsDef.hasOwnProperty('extends')) {
            if (typeof clsDef.extends === 'function') {
                constructor.prototype = proto =
                    Object.create(clsDef.extends.prototype);
            }
            else {
                throw new Error("Class definition 'extends' property must be a constructor function was: " + stringify(clsDef.extends));
            }
        }
        for (var key in clsDef) {
            if (key !== 'extends' && key !== 'prototype' && clsDef.hasOwnProperty(key)) {
                proto[key] = applyParams(clsDef[key], key);
            }
        }
        if (this && this.annotations instanceof Array) {
            Reflect.defineMetadata('annotations', this.annotations, constructor);
        }
        var constructorName = constructor['name'];
        if (!constructorName || constructorName === 'constructor') {
            constructor['overriddenName'] = "class" + _nextClassId++;
        }
        return constructor;
    }
    function makeDecorator(name, props, parentClass, chainFn) {
        if (chainFn === void 0) { chainFn = null; }
        var metaCtor = makeMetadataCtor([props]);
        function DecoratorFactory(objOrType) {
            if (!(Reflect && Reflect.getMetadata)) {
                throw 'reflect-metadata shim is required when using class decorators';
            }
            if (this instanceof DecoratorFactory) {
                metaCtor.call(this, objOrType);
                return this;
            }
            var annotationInstance = new DecoratorFactory(objOrType);
            var chainAnnotation = typeof this === 'function' && Array.isArray(this.annotations) ? this.annotations : [];
            chainAnnotation.push(annotationInstance);
            var TypeDecorator = function TypeDecorator(cls) {
                var annotations = Reflect.getOwnMetadata('annotations', cls) || [];
                annotations.push(annotationInstance);
                Reflect.defineMetadata('annotations', annotations, cls);
                return cls;
            };
            TypeDecorator.annotations = chainAnnotation;
            TypeDecorator.Class = Class;
            if (chainFn)
                chainFn(TypeDecorator);
            return TypeDecorator;
        }
        if (parentClass) {
            DecoratorFactory.prototype = Object.create(parentClass.prototype);
        }
        DecoratorFactory.prototype.toString = function () { return ("@" + name); };
        DecoratorFactory.annotationCls = DecoratorFactory;
        return DecoratorFactory;
    }
    function makeMetadataCtor(props) {
        return function ctor() {
            var _this = this;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            props.forEach(function (prop, i) {
                var argVal = args[i];
                if (Array.isArray(prop)) {
                    // plain parameter
                    _this[prop[0]] = argVal === undefined ? prop[1] : argVal;
                }
                else {
                    for (var propName in prop) {
                        _this[propName] =
                            argVal && argVal.hasOwnProperty(propName) ? argVal[propName] : prop[propName];
                    }
                }
            });
        };
    }
    function makeParamDecorator(name, props, parentClass) {
        var metaCtor = makeMetadataCtor(props);
        function ParamDecoratorFactory() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            if (this instanceof ParamDecoratorFactory) {
                metaCtor.apply(this, args);
                return this;
            }
            var annotationInstance = new ((_a = ParamDecoratorFactory).bind.apply(_a, [void 0].concat(args)))();
            ParamDecorator.annotation = annotationInstance;
            return ParamDecorator;
            function ParamDecorator(cls, unusedKey, index) {
                var parameters = Reflect.getMetadata('parameters', cls) || [];
                // there might be gaps if some in between parameters do not have annotations.
                // we pad with nulls.
                while (parameters.length <= index) {
                    parameters.push(null);
                }
                parameters[index] = parameters[index] || [];
                parameters[index].push(annotationInstance);
                Reflect.defineMetadata('parameters', parameters, cls);
                return cls;
            }
            var _a;
        }
        if (parentClass) {
            ParamDecoratorFactory.prototype = Object.create(parentClass.prototype);
        }
        ParamDecoratorFactory.prototype.toString = function () { return ("@" + name); };
        ParamDecoratorFactory.annotationCls = ParamDecoratorFactory;
        return ParamDecoratorFactory;
    }
    function makePropDecorator(name, props, parentClass) {
        var metaCtor = makeMetadataCtor(props);
        function PropDecoratorFactory() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            if (this instanceof PropDecoratorFactory) {
                metaCtor.apply(this, args);
                return this;
            }
            var decoratorInstance = new ((_a = PropDecoratorFactory).bind.apply(_a, [void 0].concat(args)))();
            return function PropDecorator(target, name) {
                var meta = Reflect.getOwnMetadata('propMetadata', target.constructor) || {};
                meta[name] = meta.hasOwnProperty(name) && meta[name] || [];
                meta[name].unshift(decoratorInstance);
                Reflect.defineMetadata('propMetadata', meta, target.constructor);
            };
            var _a;
        }
        if (parentClass) {
            PropDecoratorFactory.prototype = Object.create(parentClass.prototype);
        }
        PropDecoratorFactory.prototype.toString = function () { return ("@" + name); };
        PropDecoratorFactory.annotationCls = PropDecoratorFactory;
        return PropDecoratorFactory;
    }

    /**
     * Inject decorator and metadata.
     *
     * @stable
     * @Annotation
     */
    var Inject = makeParamDecorator('Inject', [['token', undefined]]);
    /**
     * Optional decorator and metadata.
     *
     * @stable
     * @Annotation
     */
    var Optional = makeParamDecorator('Optional', []);
    /**
     * Injectable decorator and metadata.
     *
     * @stable
     * @Annotation
     */
    var Injectable = makeParamDecorator('Injectable', []);
    /**
     * Self decorator and metadata.
     *
     * @stable
     * @Annotation
     */
    var Self = makeParamDecorator('Self', []);
    /**
     * SkipSelf decorator and metadata.
     *
     * @stable
     * @Annotation
     */
    var SkipSelf = makeParamDecorator('SkipSelf', []);
    /**
     * Host decorator and metadata.
     *
     * @stable
     * @Annotation
     */
    var Host = makeParamDecorator('Host', []);

    /**
     * Creates a token that can be used in a DI Provider.
     *
     * ### Example ([live demo](http://plnkr.co/edit/Ys9ezXpj2Mnoy3Uc8KBp?p=preview))
     *
     * ```typescript
     * var t = new OpaqueToken("value");
     *
     * var injector = Injector.resolveAndCreate([
     *   {provide: t, useValue: "bindingValue"}
     * ]);
     *
     * expect(injector.get(t)).toEqual("bindingValue");
     * ```
     *
     * Using an `OpaqueToken` is preferable to using strings as tokens because of possible collisions
     * caused by multiple providers using the same string as two different tokens.
     *
     * Using an `OpaqueToken` is preferable to using an `Object` as tokens because it provides better
     * error messages.
     * @stable
     */
    // so that metadata is gathered for this class
    var OpaqueToken = (function () {
        function OpaqueToken(_desc) {
            this._desc = _desc;
        }
        OpaqueToken.prototype.toString = function () { return "Token " + this._desc; };
        OpaqueToken.decorators = [
            { type: Injectable },
        ];
        /** @nocollapse */
        OpaqueToken.ctorParameters = [
            null,
        ];
        return OpaqueToken;
    }());

    /**
     * This token can be used to create a virtual provider that will populate the
     * `entryComponents` fields of components and ng modules based on its `useValue`.
     * All components that are referenced in the `useValue` value (either directly
     * or in a nested array or map) will be added to the `entryComponents` property.
     *
     * ### Example
     * The following example shows how the router can populate the `entryComponents`
     * field of an NgModule based on the router configuration which refers
     * to components.
     *
     * ```typescript
     * // helper function inside the router
     * function provideRoutes(routes) {
     *   return [
     *     {provide: ROUTES, useValue: routes},
     *     {provide: ANALYZE_FOR_ENTRY_COMPONENTS, useValue: routes, multi: true}
     *   ];
     * }
     *
     * // user code
     * let routes = [
     *   {path: '/root', component: RootComp},
     *   {path: '/teams', component: TeamsComp}
     * ];
     *
     * @NgModule({
     *   providers: [provideRoutes(routes)]
     * })
     * class ModuleWithRoutes {}
     * ```
     *
     * @experimental
     */
    var ANALYZE_FOR_ENTRY_COMPONENTS = new OpaqueToken('AnalyzeForEntryComponents');
    /**
     * Attribute decorator and metadata.
     *
     * @stable
     * @Annotation
     */
    var Attribute = makeParamDecorator('Attribute', [['attributeName', undefined]]);
    /**
     * Base class for query metadata.
     *
     * See {@link ContentChildren}, {@link ContentChild}, {@link ViewChildren}, {@link ViewChild} for
     * more information.
     *
     * @stable
     */
    var Query = (function () {
        function Query() {
        }
        return Query;
    }());
    /**
     * ContentChildren decorator and metadata.
     *
     *  @stable
     *  @Annotation
     */
    var ContentChildren = makePropDecorator('ContentChildren', [
        ['selector', undefined], {
            first: false,
            isViewQuery: false,
            descendants: false,
            read: undefined,
        }
    ], Query);
    /**
     * @whatItDoes Configures a content query.
     *
     * @howToUse
     *
     * {@example core/di/ts/contentChild/content_child_howto.ts region='HowTo'}
     *
     * @description
     *
     * You can use ContentChild to get the first element or the directive matching the selector from the
     * content DOM. If the content DOM changes, and a new child matches the selector,
     * the property will be updated.
     *
     * Content queries are set before the `ngAfterContentInit` callback is called.
     *
     * **Metadata Properties**:
     *
     * * **selector** - the directive type or the name used for querying.
     * * **read** - read a different token from the queried element.
     *
     * Let's look at an example:
     *
     * {@example core/di/ts/contentChild/content_child_example.ts region='Component'}
     *
     * **npm package**: `@angular/core`
     *
     * @stable
     * @Annotation
     */
    var ContentChild = makePropDecorator('ContentChild', [
        ['selector', undefined], {
            first: true,
            isViewQuery: false,
            descendants: true,
            read: undefined,
        }
    ], Query);
    /**
     * @whatItDoes Configures a view query.
     *
     * @howToUse
     *
     * {@example core/di/ts/viewChildren/view_children_howto.ts region='HowTo'}
     *
     * @description
     *
     * You can use ViewChildren to get the {@link QueryList} of elements or directives from the
     * view DOM. Any time a child element is added, removed, or moved, the query list will be updated,
     * and the changes observable of the query list will emit a new value.
     *
     * View queries are set before the `ngAfterViewInit` callback is called.
     *
     * **Metadata Properties**:
     *
     * * **selector** - the directive type or the name used for querying.
     * * **read** - read a different token from the queried elements.
     *
     * Let's look at an example:
     *
     * {@example core/di/ts/viewChildren/view_children_example.ts region='Component'}
     *
     * **npm package**: `@angular/core`
     *
     * @stable
     * @Annotation
     */
    var ViewChildren = makePropDecorator('ViewChildren', [
        ['selector', undefined], {
            first: false,
            isViewQuery: true,
            descendants: true,
            read: undefined,
        }
    ], Query);
    /**
     * ViewChild decorator and metadata.
     *
     * @stable
     * @Annotation
     */
    var ViewChild = makePropDecorator('ViewChild', [
        ['selector', undefined], {
            first: true,
            isViewQuery: true,
            descendants: true,
            read: undefined,
        }
    ], Query);

    /**
     * Describes within the change detector which strategy will be used the next time change
     * detection is triggered.
     * @stable
     */
    exports.ChangeDetectionStrategy;
    (function (ChangeDetectionStrategy) {
        /**
         * `OnPush` means that the change detector's mode will be set to `CheckOnce` during hydration.
         */
        ChangeDetectionStrategy[ChangeDetectionStrategy["OnPush"] = 0] = "OnPush";
        /**
         * `Default` means that the change detector's mode will be set to `CheckAlways` during hydration.
         */
        ChangeDetectionStrategy[ChangeDetectionStrategy["Default"] = 1] = "Default";
    })(exports.ChangeDetectionStrategy || (exports.ChangeDetectionStrategy = {}));
    /**
     * Describes the status of the detector.
     */
    var ChangeDetectorStatus;
    (function (ChangeDetectorStatus) {
        /**
         * `CheckedOnce` means that after calling detectChanges the mode of the change detector
         * will become `Checked`.
         */
        ChangeDetectorStatus[ChangeDetectorStatus["CheckOnce"] = 0] = "CheckOnce";
        /**
         * `Checked` means that the change detector should be skipped until its mode changes to
         * `CheckOnce`.
         */
        ChangeDetectorStatus[ChangeDetectorStatus["Checked"] = 1] = "Checked";
        /**
         * `CheckAlways` means that after calling detectChanges the mode of the change detector
         * will remain `CheckAlways`.
         */
        ChangeDetectorStatus[ChangeDetectorStatus["CheckAlways"] = 2] = "CheckAlways";
        /**
         * `Detached` means that the change detector sub tree is not a part of the main tree and
         * should be skipped.
         */
        ChangeDetectorStatus[ChangeDetectorStatus["Detached"] = 3] = "Detached";
        /**
         * `Errored` means that the change detector encountered an error checking a binding
         * or calling a directive lifecycle method and is now in an inconsistent state. Change
         * detectors in this state will no longer detect changes.
         */
        ChangeDetectorStatus[ChangeDetectorStatus["Errored"] = 4] = "Errored";
        /**
         * `Destroyed` means that the change detector is destroyed.
         */
        ChangeDetectorStatus[ChangeDetectorStatus["Destroyed"] = 5] = "Destroyed";
    })(ChangeDetectorStatus || (ChangeDetectorStatus = {}));
    function isDefaultChangeDetectionStrategy(changeDetectionStrategy) {
        return isBlank(changeDetectionStrategy) ||
            changeDetectionStrategy === exports.ChangeDetectionStrategy.Default;
    }

    /**
     * Directive decorator and metadata.
     *
     * @stable
     * @Annotation
     */
    var Directive = makeDecorator('Directive', {
        selector: undefined,
        inputs: undefined,
        outputs: undefined,
        host: undefined,
        providers: undefined,
        exportAs: undefined,
        queries: undefined
    });
    /**
     * Component decorator and metadata.
     *
     * @stable
     * @Annotation
     */
    var Component = makeDecorator('Component', {
        selector: undefined,
        inputs: undefined,
        outputs: undefined,
        host: undefined,
        exportAs: undefined,
        moduleId: undefined,
        providers: undefined,
        viewProviders: undefined,
        changeDetection: exports.ChangeDetectionStrategy.Default,
        queries: undefined,
        templateUrl: undefined,
        template: undefined,
        styleUrls: undefined,
        styles: undefined,
        animations: undefined,
        encapsulation: undefined,
        interpolation: undefined,
        entryComponents: undefined
    }, Directive);
    /**
     * Pipe decorator and metadata.
     *
     * @stable
     * @Annotation
     */
    var Pipe = makeDecorator('Pipe', {
        name: undefined,
        pure: true,
    });
    /**
     * Input decorator and metadata.
     *
     * @stable
     * @Annotation
     */
    var Input = makePropDecorator('Input', [['bindingPropertyName', undefined]]);
    /**
     * Output decorator and metadata.
     *
     * @stable
     * @Annotation
     */
    var Output = makePropDecorator('Output', [['bindingPropertyName', undefined]]);
    /**
     * HostBinding decorator and metadata.
     *
     * @stable
     * @Annotation
     */
    var HostBinding = makePropDecorator('HostBinding', [['hostPropertyName', undefined]]);
    /**
     * HostBinding decorator and metadata.
     *
     * @stable
     * @Annotation
     */
    var HostListener = makePropDecorator('HostListener', [['eventName', undefined], ['args', []]]);

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * @stable
     */
    var LifecycleHooks;
    (function (LifecycleHooks) {
        LifecycleHooks[LifecycleHooks["OnInit"] = 0] = "OnInit";
        LifecycleHooks[LifecycleHooks["OnDestroy"] = 1] = "OnDestroy";
        LifecycleHooks[LifecycleHooks["DoCheck"] = 2] = "DoCheck";
        LifecycleHooks[LifecycleHooks["OnChanges"] = 3] = "OnChanges";
        LifecycleHooks[LifecycleHooks["AfterContentInit"] = 4] = "AfterContentInit";
        LifecycleHooks[LifecycleHooks["AfterContentChecked"] = 5] = "AfterContentChecked";
        LifecycleHooks[LifecycleHooks["AfterViewInit"] = 6] = "AfterViewInit";
        LifecycleHooks[LifecycleHooks["AfterViewChecked"] = 7] = "AfterViewChecked";
    })(LifecycleHooks || (LifecycleHooks = {}));
    var LIFECYCLE_HOOKS_VALUES = [
        LifecycleHooks.OnInit, LifecycleHooks.OnDestroy, LifecycleHooks.DoCheck, LifecycleHooks.OnChanges,
        LifecycleHooks.AfterContentInit, LifecycleHooks.AfterContentChecked, LifecycleHooks.AfterViewInit,
        LifecycleHooks.AfterViewChecked
    ];
    /**
     * @whatItDoes Lifecycle hook that is called when any data-bound property of a directive changes.
     * @howToUse
     * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='OnChanges'}
     *
     * @description
     * `ngOnChanges` is called right after the data-bound properties have been checked and before view
     * and content children are checked if at least one of them has changed.
     * The `changes` parameter contains the changed properties.
     *
     * See {@linkDocs guide/lifecycle-hooks#onchanges "Lifecycle Hooks Guide"}.
     *
     * @stable
     */
    var OnChanges = (function () {
        function OnChanges() {
        }
        return OnChanges;
    }());
    /**
     * @whatItDoes Lifecycle hook that is called after data-bound properties of a directive are
     * initialized.
     * @howToUse
     * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='OnInit'}
     *
     * @description
     * `ngOnInit` is called right after the directive's data-bound properties have been checked for the
     * first time, and before any of its children have been checked. It is invoked only once when the
     * directive is instantiated.
     *
     * See {@linkDocs guide/lifecycle-hooks "Lifecycle Hooks Guide"}.
     *
     * @stable
     */
    var OnInit = (function () {
        function OnInit() {
        }
        return OnInit;
    }());
    /**
     * @whatItDoes Lifecycle hook that is called when Angular dirty checks a directive.
     * @howToUse
     * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='DoCheck'}
     *
     * @description
     * `ngDoCheck` gets called to check the changes in the directives in addition to the default
     * algorithm. The default change detection algorithm looks for differences by comparing
     * bound-property values by reference across change detection runs.
     *
     * Note that a directive typically should not use both `DoCheck` and {@link OnChanges} to respond to
     * changes on the same input, as `ngOnChanges` will continue to be called when the default change
     * detector detects changes.
     *
     * See {@link KeyValueDiffers} and {@link IterableDiffers} for implementing custom dirty checking
     * for collections.
     *
     * See {@linkDocs guide/lifecycle-hooks#docheck "Lifecycle Hooks Guide"}.
     *
     * @stable
     */
    var DoCheck = (function () {
        function DoCheck() {
        }
        return DoCheck;
    }());
    /**
     * @whatItDoes Lifecycle hook that is called when a directive or pipe is destroyed.
     * @howToUse
     * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='OnDestroy'}
     *
     * @description
     * `ngOnDestroy` callback is typically used for any custom cleanup that needs to occur when the
     * instance is destroyed.
     *
     * See {@linkDocs guide/lifecycle-hooks "Lifecycle Hooks Guide"}.
     *
     * @stable
     */
    var OnDestroy = (function () {
        function OnDestroy() {
        }
        return OnDestroy;
    }());
    /**
     *
     * @whatItDoes Lifecycle hook that is called after a directive's content has been fully
     * initialized.
     * @howToUse
     * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='AfterContentInit'}
     *
     * @description
     * See {@linkDocs guide/lifecycle-hooks#aftercontent "Lifecycle Hooks Guide"}.
     *
     * @stable
     */
    var AfterContentInit = (function () {
        function AfterContentInit() {
        }
        return AfterContentInit;
    }());
    /**
     * @whatItDoes Lifecycle hook that is called after every check of a directive's content.
     * @howToUse
     * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='AfterContentChecked'}
     *
     * @description
     * See {@linkDocs guide/lifecycle-hooks#aftercontent "Lifecycle Hooks Guide"}.
     *
     * @stable
     */
    var AfterContentChecked = (function () {
        function AfterContentChecked() {
        }
        return AfterContentChecked;
    }());
    /**
     * @whatItDoes Lifecycle hook that is called after a component's view has been fully
     * initialized.
     * @howToUse
     * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='AfterViewInit'}
     *
     * @description
     * See {@linkDocs guide/lifecycle-hooks#afterview "Lifecycle Hooks Guide"}.
     *
     * @stable
     */
    var AfterViewInit = (function () {
        function AfterViewInit() {
        }
        return AfterViewInit;
    }());
    /**
     * @whatItDoes Lifecycle hook that is called after every check of a component's view.
     * @howToUse
     * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='AfterViewChecked'}
     *
     * @description
     * See {@linkDocs guide/lifecycle-hooks#afterview "Lifecycle Hooks Guide"}.
     *
     * @stable
     */
    var AfterViewChecked = (function () {
        function AfterViewChecked() {
        }
        return AfterViewChecked;
    }());

    /**
     * Defines a schema that will allow:
     * - any non-Angular elements with a `-` in their name,
     * - any properties on elements with a `-` in their name which is the common rule for custom
     * elements.
     *
     * @stable
     */
    var CUSTOM_ELEMENTS_SCHEMA = {
        name: 'custom-elements'
    };
    /**
     * Defines a schema that will allow any property on any element.
     *
     * @experimental
     */
    var NO_ERRORS_SCHEMA = {
        name: 'no-errors-schema'
    };
    /**
     * NgModule decorator and metadata.
     *
     * @stable
     * @Annotation
     */
    var NgModule = makeDecorator('NgModule', {
        providers: undefined,
        declarations: undefined,
        imports: undefined,
        exports: undefined,
        entryComponents: undefined,
        bootstrap: undefined,
        schemas: undefined,
        id: undefined,
    });

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Defines template and style encapsulation options available for Component's {@link Component}.
     *
     * See {@link ViewMetadata#encapsulation}.
     * @stable
     */
    exports.ViewEncapsulation;
    (function (ViewEncapsulation) {
        /**
         * Emulate `Native` scoping of styles by adding an attribute containing surrogate id to the Host
         * Element and pre-processing the style rules provided via
         * {@link ViewMetadata#styles} or {@link ViewMetadata#stylesUrls}, and adding the new Host Element
         * attribute to all selectors.
         *
         * This is the default option.
         */
        ViewEncapsulation[ViewEncapsulation["Emulated"] = 0] = "Emulated";
        /**
         * Use the native encapsulation mechanism of the renderer.
         *
         * For the DOM this means using [Shadow DOM](https://w3c.github.io/webcomponents/spec/shadow/) and
         * creating a ShadowRoot for Component's Host Element.
         */
        ViewEncapsulation[ViewEncapsulation["Native"] = 1] = "Native";
        /**
         * Don't provide any template or style encapsulation.
         */
        ViewEncapsulation[ViewEncapsulation["None"] = 2] = "None";
    })(exports.ViewEncapsulation || (exports.ViewEncapsulation = {}));
    /**
     * Metadata properties available for configuring Views.
     *
     * For details on the `@Component` annotation, see {@link Component}.
     *
     * ### Example
     *
     * ```
     * @Component({
     *   selector: 'greet',
     *   template: 'Hello {{name}}!',
     * })
     * class Greet {
     *   name: string;
     *
     *   constructor() {
     *     this.name = 'World';
     *   }
     * }
     * ```
     *
     * @deprecated Use Component instead.
     *
     * {@link Component}
     */
    var ViewMetadata = (function () {
        function ViewMetadata(_a) {
            var _b = _a === void 0 ? {} : _a, templateUrl = _b.templateUrl, template = _b.template, encapsulation = _b.encapsulation, styles = _b.styles, styleUrls = _b.styleUrls, animations = _b.animations, interpolation = _b.interpolation;
            this.templateUrl = templateUrl;
            this.template = template;
            this.styleUrls = styleUrls;
            this.styles = styles;
            this.encapsulation = encapsulation;
            this.animations = animations;
            this.interpolation = interpolation;
        }
        return ViewMetadata;
    }());

    /**
     * Allows to refer to references which are not yet defined.
     *
     * For instance, `forwardRef` is used when the `token` which we need to refer to for the purposes of
     * DI is declared,
     * but not yet defined. It is also used when the `token` which we use when creating a query is not
     * yet defined.
     *
     * ### Example
     * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='forward_ref'}
     * @experimental
     */
    function forwardRef(forwardRefFn) {
        forwardRefFn.__forward_ref__ = forwardRef;
        forwardRefFn.toString = function () { return stringify(this()); };
        return forwardRefFn;
    }
    /**
     * Lazily retrieves the reference value from a forwardRef.
     *
     * Acts as the identity function when given a non-forward-ref value.
     *
     * ### Example ([live demo](http://plnkr.co/edit/GU72mJrk1fiodChcmiDR?p=preview))
     *
     * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='resolve_forward_ref'}
     *
     * See: {@link forwardRef}
     * @experimental
     */
    function resolveForwardRef(type) {
        if (typeof type === 'function' && type.hasOwnProperty('__forward_ref__') &&
            type.__forward_ref__ === forwardRef) {
            return type();
        }
        else {
            return type;
        }
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    function unimplemented() {
        throw new Error('unimplemented');
    }
    /**
     * @stable
     */
    var BaseError = (function (_super) {
        __extends(BaseError, _super);
        function BaseError(message) {
            // Errors don't use current this, instead they create a new instance.
            // We have to do forward all of our api to the nativeInstance.
            var nativeError = _super.call(this, message);
            this._nativeError = nativeError;
        }
        Object.defineProperty(BaseError.prototype, "message", {
            get: function () { return this._nativeError.message; },
            set: function (message) { this._nativeError.message = message; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseError.prototype, "name", {
            get: function () { return this._nativeError.name; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseError.prototype, "stack", {
            get: function () { return this._nativeError.stack; },
            set: function (value) { this._nativeError.stack = value; },
            enumerable: true,
            configurable: true
        });
        BaseError.prototype.toString = function () { return this._nativeError.toString(); };
        return BaseError;
    }(Error));
    /**
     * @stable
     */
    var WrappedError = (function (_super) {
        __extends(WrappedError, _super);
        function WrappedError(message, error) {
            _super.call(this, message + " caused by: " + (error instanceof Error ? error.message : error));
            this.originalError = error;
        }
        Object.defineProperty(WrappedError.prototype, "stack", {
            get: function () {
                return (this.originalError instanceof Error ? this.originalError : this._nativeError)
                    .stack;
            },
            enumerable: true,
            configurable: true
        });
        return WrappedError;
    }(BaseError));

    var _THROW_IF_NOT_FOUND = new Object();
    var THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;
    var _NullInjector = (function () {
        function _NullInjector() {
        }
        _NullInjector.prototype.get = function (token, notFoundValue) {
            if (notFoundValue === void 0) { notFoundValue = _THROW_IF_NOT_FOUND; }
            if (notFoundValue === _THROW_IF_NOT_FOUND) {
                throw new Error("No provider for " + stringify(token) + "!");
            }
            return notFoundValue;
        };
        return _NullInjector;
    }());
    /**
     * @whatItDoes Injector interface
     * @howToUse
     * ```
     * const injector: Injector = ...;
     * injector.get(...);
     * ```
     *
     * @description
     * For more details, see the {@linkDocs guide/dependency-injection "Dependency Injection Guide"}.
     *
     * ### Example
     *
     * {@example core/di/ts/injector_spec.ts region='Injector'}
     *
     * `Injector` returns itself when given `Injector` as a token:
     * {@example core/di/ts/injector_spec.ts region='injectInjector'}
     *
     * @stable
     */
    var Injector = (function () {
        function Injector() {
        }
        /**
         * Retrieves an instance from the injector based on the provided token.
         * If not found:
         * - Throws {@link NoProviderError} if no `notFoundValue` that is not equal to
         * Injector.THROW_IF_NOT_FOUND is given
         * - Returns the `notFoundValue` otherwise
         */
        Injector.prototype.get = function (token, notFoundValue) { return unimplemented(); };
        Injector.THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;
        Injector.NULL = new _NullInjector();
        return Injector;
    }());

    // Safari doesn't implement MapIterator.next(), which is used is Traceur's polyfill of Array.from
    // TODO(mlaval): remove the work around once we have a working polyfill of Array.from
    var _arrayFromMap = (function () {
        try {
            if ((new Map()).values().next) {
                return function createArrayFromMap(m, getValues) {
                    return getValues ? Array.from(m.values()) : Array.from(m.keys());
                };
            }
        }
        catch (e) {
        }
        return function createArrayFromMapWithForeach(m, getValues) {
            var res = new Array(m.size), i = 0;
            m.forEach(function (v, k) {
                res[i] = getValues ? v : k;
                i++;
            });
            return res;
        };
    })();
    var MapWrapper = (function () {
        function MapWrapper() {
        }
        MapWrapper.createFromStringMap = function (stringMap) {
            var result = new Map();
            for (var prop in stringMap) {
                result.set(prop, stringMap[prop]);
            }
            return result;
        };
        MapWrapper.keys = function (m) { return _arrayFromMap(m, false); };
        MapWrapper.values = function (m) { return _arrayFromMap(m, true); };
        return MapWrapper;
    }());
    /**
     * Wraps Javascript Objects
     */
    var StringMapWrapper = (function () {
        function StringMapWrapper() {
        }
        StringMapWrapper.merge = function (m1, m2) {
            var m = {};
            for (var _i = 0, _a = Object.keys(m1); _i < _a.length; _i++) {
                var k = _a[_i];
                m[k] = m1[k];
            }
            for (var _b = 0, _c = Object.keys(m2); _b < _c.length; _b++) {
                var k = _c[_b];
                m[k] = m2[k];
            }
            return m;
        };
        StringMapWrapper.equals = function (m1, m2) {
            var k1 = Object.keys(m1);
            var k2 = Object.keys(m2);
            if (k1.length != k2.length) {
                return false;
            }
            for (var i = 0; i < k1.length; i++) {
                var key = k1[i];
                if (m1[key] !== m2[key]) {
                    return false;
                }
            }
            return true;
        };
        return StringMapWrapper;
    }());
    var ListWrapper = (function () {
        function ListWrapper() {
        }
        // JS has no way to express a statically fixed size list, but dart does so we
        // keep both methods.
        ListWrapper.createFixedSize = function (size) { return new Array(size); };
        ListWrapper.createGrowableSize = function (size) { return new Array(size); };
        ListWrapper.clone = function (array) { return array.slice(0); };
        ListWrapper.forEachWithIndex = function (array, fn) {
            for (var i = 0; i < array.length; i++) {
                fn(array[i], i);
            }
        };
        ListWrapper.first = function (array) {
            if (!array)
                return null;
            return array[0];
        };
        ListWrapper.last = function (array) {
            if (!array || array.length == 0)
                return null;
            return array[array.length - 1];
        };
        ListWrapper.indexOf = function (array, value, startIndex) {
            if (startIndex === void 0) { startIndex = 0; }
            return array.indexOf(value, startIndex);
        };
        ListWrapper.contains = function (list, el) { return list.indexOf(el) !== -1; };
        ListWrapper.reversed = function (array) {
            var a = ListWrapper.clone(array);
            return a.reverse();
        };
        ListWrapper.concat = function (a, b) { return a.concat(b); };
        ListWrapper.insert = function (list, index, value) { list.splice(index, 0, value); };
        ListWrapper.removeAt = function (list, index) {
            var res = list[index];
            list.splice(index, 1);
            return res;
        };
        ListWrapper.removeAll = function (list, items) {
            for (var i = 0; i < items.length; ++i) {
                var index = list.indexOf(items[i]);
                list.splice(index, 1);
            }
        };
        ListWrapper.remove = function (list, el) {
            var index = list.indexOf(el);
            if (index > -1) {
                list.splice(index, 1);
                return true;
            }
            return false;
        };
        ListWrapper.clear = function (list) { list.length = 0; };
        ListWrapper.isEmpty = function (list) { return list.length == 0; };
        ListWrapper.fill = function (list, value, start, end) {
            if (start === void 0) { start = 0; }
            if (end === void 0) { end = null; }
            list.fill(value, start, end === null ? list.length : end);
        };
        ListWrapper.equals = function (a, b) {
            if (a.length != b.length)
                return false;
            for (var i = 0; i < a.length; ++i) {
                if (a[i] !== b[i])
                    return false;
            }
            return true;
        };
        ListWrapper.slice = function (l, from, to) {
            if (from === void 0) { from = 0; }
            if (to === void 0) { to = null; }
            return l.slice(from, to === null ? undefined : to);
        };
        ListWrapper.splice = function (l, from, length) { return l.splice(from, length); };
        ListWrapper.sort = function (l, compareFn) {
            if (isPresent(compareFn)) {
                l.sort(compareFn);
            }
            else {
                l.sort();
            }
        };
        ListWrapper.toString = function (l) { return l.toString(); };
        ListWrapper.toJSON = function (l) { return JSON.stringify(l); };
        ListWrapper.maximum = function (list, predicate) {
            if (list.length == 0) {
                return null;
            }
            var solution = null;
            var maxValue = -Infinity;
            for (var index = 0; index < list.length; index++) {
                var candidate = list[index];
                if (isBlank(candidate)) {
                    continue;
                }
                var candidateValue = predicate(candidate);
                if (candidateValue > maxValue) {
                    solution = candidate;
                    maxValue = candidateValue;
                }
            }
            return solution;
        };
        ListWrapper.flatten = function (list) {
            var target = [];
            _flattenArray(list, target);
            return target;
        };
        ListWrapper.addAll = function (list, source) {
            for (var i = 0; i < source.length; i++) {
                list.push(source[i]);
            }
        };
        return ListWrapper;
    }());
    function _flattenArray(source, target) {
        if (isPresent(source)) {
            for (var i = 0; i < source.length; i++) {
                var item = source[i];
                if (Array.isArray(item)) {
                    _flattenArray(item, target);
                }
                else {
                    target.push(item);
                }
            }
        }
        return target;
    }
    function isListLikeIterable(obj) {
        if (!isJsObject(obj))
            return false;
        return Array.isArray(obj) ||
            (!(obj instanceof Map) &&
                getSymbolIterator() in obj); // JS Iterable have a Symbol.iterator prop
    }
    function areIterablesEqual(a, b, comparator) {
        var iterator1 = a[getSymbolIterator()]();
        var iterator2 = b[getSymbolIterator()]();
        while (true) {
            var item1 = iterator1.next();
            var item2 = iterator2.next();
            if (item1.done && item2.done)
                return true;
            if (item1.done || item2.done)
                return false;
            if (!comparator(item1.value, item2.value))
                return false;
        }
    }
    function iterateListLike(obj, fn) {
        if (Array.isArray(obj)) {
            for (var i = 0; i < obj.length; i++) {
                fn(obj[i]);
            }
        }
        else {
            var iterator = obj[getSymbolIterator()]();
            var item = void 0;
            while (!((item = iterator.next()).done)) {
                fn(item.value);
            }
        }
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$1 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    function findFirstClosedCycle(keys) {
        var res = [];
        for (var i = 0; i < keys.length; ++i) {
            if (ListWrapper.contains(res, keys[i])) {
                res.push(keys[i]);
                return res;
            }
            res.push(keys[i]);
        }
        return res;
    }
    function constructResolvingPath(keys) {
        if (keys.length > 1) {
            var reversed = findFirstClosedCycle(ListWrapper.reversed(keys));
            var tokenStrs = reversed.map(function (k) { return stringify(k.token); });
            return ' (' + tokenStrs.join(' -> ') + ')';
        }
        return '';
    }
    /**
     * Base class for all errors arising from misconfigured providers.
     * @stable
     */
    var AbstractProviderError = (function (_super) {
        __extends$1(AbstractProviderError, _super);
        function AbstractProviderError(injector, key, constructResolvingMessage) {
            _super.call(this, 'DI Error');
            this.keys = [key];
            this.injectors = [injector];
            this.constructResolvingMessage = constructResolvingMessage;
            this.message = this.constructResolvingMessage(this.keys);
        }
        AbstractProviderError.prototype.addKey = function (injector, key) {
            this.injectors.push(injector);
            this.keys.push(key);
            this.message = this.constructResolvingMessage(this.keys);
        };
        return AbstractProviderError;
    }(BaseError));
    /**
     * Thrown when trying to retrieve a dependency by key from {@link Injector}, but the
     * {@link Injector} does not have a {@link Provider} for the given key.
     *
     * ### Example ([live demo](http://plnkr.co/edit/vq8D3FRB9aGbnWJqtEPE?p=preview))
     *
     * ```typescript
     * class A {
     *   constructor(b:B) {}
     * }
     *
     * expect(() => Injector.resolveAndCreate([A])).toThrowError();
     * ```
     * @stable
     */
    var NoProviderError = (function (_super) {
        __extends$1(NoProviderError, _super);
        function NoProviderError(injector, key) {
            _super.call(this, injector, key, function (keys) {
                var first = stringify(ListWrapper.first(keys).token);
                return "No provider for " + first + "!" + constructResolvingPath(keys);
            });
        }
        return NoProviderError;
    }(AbstractProviderError));
    /**
     * Thrown when dependencies form a cycle.
     *
     * ### Example ([live demo](http://plnkr.co/edit/wYQdNos0Tzql3ei1EV9j?p=info))
     *
     * ```typescript
     * var injector = Injector.resolveAndCreate([
     *   {provide: "one", useFactory: (two) => "two", deps: [[new Inject("two")]]},
     *   {provide: "two", useFactory: (one) => "one", deps: [[new Inject("one")]]}
     * ]);
     *
     * expect(() => injector.get("one")).toThrowError();
     * ```
     *
     * Retrieving `A` or `B` throws a `CyclicDependencyError` as the graph above cannot be constructed.
     * @stable
     */
    var CyclicDependencyError = (function (_super) {
        __extends$1(CyclicDependencyError, _super);
        function CyclicDependencyError(injector, key) {
            _super.call(this, injector, key, function (keys) {
                return "Cannot instantiate cyclic dependency!" + constructResolvingPath(keys);
            });
        }
        return CyclicDependencyError;
    }(AbstractProviderError));
    /**
     * Thrown when a constructing type returns with an Error.
     *
     * The `InstantiationError` class contains the original error plus the dependency graph which caused
     * this object to be instantiated.
     *
     * ### Example ([live demo](http://plnkr.co/edit/7aWYdcqTQsP0eNqEdUAf?p=preview))
     *
     * ```typescript
     * class A {
     *   constructor() {
     *     throw new Error('message');
     *   }
     * }
     *
     * var injector = Injector.resolveAndCreate([A]);

     * try {
     *   injector.get(A);
     * } catch (e) {
     *   expect(e instanceof InstantiationError).toBe(true);
     *   expect(e.originalException.message).toEqual("message");
     *   expect(e.originalStack).toBeDefined();
     * }
     * ```
     * @stable
     */
    var InstantiationError = (function (_super) {
        __extends$1(InstantiationError, _super);
        function InstantiationError(injector, originalException, originalStack, key) {
            _super.call(this, 'DI Error', originalException);
            this.keys = [key];
            this.injectors = [injector];
        }
        InstantiationError.prototype.addKey = function (injector, key) {
            this.injectors.push(injector);
            this.keys.push(key);
        };
        Object.defineProperty(InstantiationError.prototype, "message", {
            get: function () {
                var first = stringify(ListWrapper.first(this.keys).token);
                return this.originalError.message + ": Error during instantiation of " + first + "!" + constructResolvingPath(this.keys) + ".";
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InstantiationError.prototype, "causeKey", {
            get: function () { return this.keys[0]; },
            enumerable: true,
            configurable: true
        });
        return InstantiationError;
    }(WrappedError));
    /**
     * Thrown when an object other then {@link Provider} (or `Type`) is passed to {@link Injector}
     * creation.
     *
     * ### Example ([live demo](http://plnkr.co/edit/YatCFbPAMCL0JSSQ4mvH?p=preview))
     *
     * ```typescript
     * expect(() => Injector.resolveAndCreate(["not a type"])).toThrowError();
     * ```
     * @stable
     */
    var InvalidProviderError = (function (_super) {
        __extends$1(InvalidProviderError, _super);
        function InvalidProviderError(provider) {
            _super.call(this, "Invalid provider - only instances of Provider and Type are allowed, got: " + provider);
        }
        return InvalidProviderError;
    }(BaseError));
    /**
     * Thrown when the class has no annotation information.
     *
     * Lack of annotation information prevents the {@link Injector} from determining which dependencies
     * need to be injected into the constructor.
     *
     * ### Example ([live demo](http://plnkr.co/edit/rHnZtlNS7vJOPQ6pcVkm?p=preview))
     *
     * ```typescript
     * class A {
     *   constructor(b) {}
     * }
     *
     * expect(() => Injector.resolveAndCreate([A])).toThrowError();
     * ```
     *
     * This error is also thrown when the class not marked with {@link Injectable} has parameter types.
     *
     * ```typescript
     * class B {}
     *
     * class A {
     *   constructor(b:B) {} // no information about the parameter types of A is available at runtime.
     * }
     *
     * expect(() => Injector.resolveAndCreate([A,B])).toThrowError();
     * ```
     * @stable
     */
    var NoAnnotationError = (function (_super) {
        __extends$1(NoAnnotationError, _super);
        function NoAnnotationError(typeOrFunc, params) {
            _super.call(this, NoAnnotationError._genMessage(typeOrFunc, params));
        }
        NoAnnotationError._genMessage = function (typeOrFunc, params) {
            var signature = [];
            for (var i = 0, ii = params.length; i < ii; i++) {
                var parameter = params[i];
                if (!parameter || parameter.length == 0) {
                    signature.push('?');
                }
                else {
                    signature.push(parameter.map(stringify).join(' '));
                }
            }
            return 'Cannot resolve all parameters for \'' + stringify(typeOrFunc) + '\'(' +
                signature.join(', ') + '). ' +
                'Make sure that all the parameters are decorated with Inject or have valid type annotations and that \'' +
                stringify(typeOrFunc) + '\' is decorated with Injectable.';
        };
        return NoAnnotationError;
    }(BaseError));
    /**
     * Thrown when getting an object by index.
     *
     * ### Example ([live demo](http://plnkr.co/edit/bRs0SX2OTQiJzqvjgl8P?p=preview))
     *
     * ```typescript
     * class A {}
     *
     * var injector = Injector.resolveAndCreate([A]);
     *
     * expect(() => injector.getAt(100)).toThrowError();
     * ```
     * @stable
     */
    var OutOfBoundsError = (function (_super) {
        __extends$1(OutOfBoundsError, _super);
        function OutOfBoundsError(index) {
            _super.call(this, "Index " + index + " is out-of-bounds.");
        }
        return OutOfBoundsError;
    }(BaseError));
    // TODO: add a working example after alpha38 is released
    /**
     * Thrown when a multi provider and a regular provider are bound to the same token.
     *
     * ### Example
     *
     * ```typescript
     * expect(() => Injector.resolveAndCreate([
     *   { provide: "Strings", useValue: "string1", multi: true},
     *   { provide: "Strings", useValue: "string2", multi: false}
     * ])).toThrowError();
     * ```
     */
    var MixingMultiProvidersWithRegularProvidersError = (function (_super) {
        __extends$1(MixingMultiProvidersWithRegularProvidersError, _super);
        function MixingMultiProvidersWithRegularProvidersError(provider1, provider2) {
            _super.call(this, 'Cannot mix multi providers and regular providers, got: ' + provider1.toString() + ' ' +
                provider2.toString());
        }
        return MixingMultiProvidersWithRegularProvidersError;
    }(BaseError));

    /**
     * A unique object used for retrieving items from the {@link ReflectiveInjector}.
     *
     * Keys have:
     * - a system-wide unique `id`.
     * - a `token`.
     *
     * `Key` is used internally by {@link ReflectiveInjector} because its system-wide unique `id` allows
     * the
     * injector to store created objects in a more efficient way.
     *
     * `Key` should not be created directly. {@link ReflectiveInjector} creates keys automatically when
     * resolving
     * providers.
     * @experimental
     */
    var ReflectiveKey = (function () {
        /**
         * Private
         */
        function ReflectiveKey(token, id) {
            this.token = token;
            this.id = id;
            if (!token) {
                throw new Error('Token must be defined!');
            }
        }
        Object.defineProperty(ReflectiveKey.prototype, "displayName", {
            /**
             * Returns a stringified token.
             */
            get: function () { return stringify(this.token); },
            enumerable: true,
            configurable: true
        });
        /**
         * Retrieves a `Key` for a token.
         */
        ReflectiveKey.get = function (token) {
            return _globalKeyRegistry.get(resolveForwardRef(token));
        };
        Object.defineProperty(ReflectiveKey, "numberOfKeys", {
            /**
             * @returns the number of keys registered in the system.
             */
            get: function () { return _globalKeyRegistry.numberOfKeys; },
            enumerable: true,
            configurable: true
        });
        return ReflectiveKey;
    }());
    /**
     * @internal
     */
    var KeyRegistry = (function () {
        function KeyRegistry() {
            this._allKeys = new Map();
        }
        KeyRegistry.prototype.get = function (token) {
            if (token instanceof ReflectiveKey)
                return token;
            if (this._allKeys.has(token)) {
                return this._allKeys.get(token);
            }
            var newKey = new ReflectiveKey(token, ReflectiveKey.numberOfKeys);
            this._allKeys.set(token, newKey);
            return newKey;
        };
        Object.defineProperty(KeyRegistry.prototype, "numberOfKeys", {
            get: function () { return this._allKeys.size; },
            enumerable: true,
            configurable: true
        });
        return KeyRegistry;
    }());
    var _globalKeyRegistry = new KeyRegistry();

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * @whatItDoes Represents a type that a Component or other object is instances of.
     *
     * @description
     *
     * An example of a `Type` is `MyCustomComponent` class, which in JavaScript is be represented by
     * the `MyCustomComponent` constructor function.
     *
     * @stable
     */
    var Type = Function;

    var ReflectionCapabilities = (function () {
        function ReflectionCapabilities(reflect) {
            this._reflect = reflect || global$1.Reflect;
        }
        ReflectionCapabilities.prototype.isReflectionEnabled = function () { return true; };
        ReflectionCapabilities.prototype.factory = function (t) { return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            return new (t.bind.apply(t, [void 0].concat(args)))();
        }; };
        /** @internal */
        ReflectionCapabilities.prototype._zipTypesAndAnnotations = function (paramTypes, paramAnnotations) {
            var result;
            if (typeof paramTypes === 'undefined') {
                result = new Array(paramAnnotations.length);
            }
            else {
                result = new Array(paramTypes.length);
            }
            for (var i = 0; i < result.length; i++) {
                // TS outputs Object for parameters without types, while Traceur omits
                // the annotations. For now we preserve the Traceur behavior to aid
                // migration, but this can be revisited.
                if (typeof paramTypes === 'undefined') {
                    result[i] = [];
                }
                else if (paramTypes[i] != Object) {
                    result[i] = [paramTypes[i]];
                }
                else {
                    result[i] = [];
                }
                if (paramAnnotations && isPresent(paramAnnotations[i])) {
                    result[i] = result[i].concat(paramAnnotations[i]);
                }
            }
            return result;
        };
        ReflectionCapabilities.prototype.parameters = function (type) {
            // Prefer the direct API.
            if (type.parameters) {
                return type.parameters;
            }
            // API of tsickle for lowering decorators to properties on the class.
            if (type.ctorParameters) {
                var ctorParameters = type.ctorParameters;
                var paramTypes = ctorParameters.map(function (ctorParam) { return ctorParam && ctorParam.type; });
                var paramAnnotations = ctorParameters.map(function (ctorParam) {
                    return ctorParam && convertTsickleDecoratorIntoMetadata(ctorParam.decorators);
                });
                return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);
            }
            // API for metadata created by invoking the decorators.
            if (isPresent(this._reflect) && isPresent(this._reflect.getMetadata)) {
                var paramAnnotations = this._reflect.getMetadata('parameters', type);
                var paramTypes = this._reflect.getMetadata('design:paramtypes', type);
                if (paramTypes || paramAnnotations) {
                    return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);
                }
            }
            // The array has to be filled with `undefined` because holes would be skipped by `some`
            return new Array(type.length).fill(undefined);
        };
        ReflectionCapabilities.prototype.annotations = function (typeOrFunc) {
            // Prefer the direct API.
            if (typeOrFunc.annotations) {
                var annotations = typeOrFunc.annotations;
                if (typeof annotations === 'function' && annotations.annotations) {
                    annotations = annotations.annotations;
                }
                return annotations;
            }
            // API of tsickle for lowering decorators to properties on the class.
            if (typeOrFunc.decorators) {
                return convertTsickleDecoratorIntoMetadata(typeOrFunc.decorators);
            }
            // API for metadata created by invoking the decorators.
            if (this._reflect && this._reflect.getMetadata) {
                var annotations = this._reflect.getMetadata('annotations', typeOrFunc);
                if (annotations)
                    return annotations;
            }
            return [];
        };
        ReflectionCapabilities.prototype.propMetadata = function (typeOrFunc) {
            // Prefer the direct API.
            if (typeOrFunc.propMetadata) {
                var propMetadata = typeOrFunc.propMetadata;
                if (typeof propMetadata === 'function' && propMetadata.propMetadata) {
                    propMetadata = propMetadata.propMetadata;
                }
                return propMetadata;
            }
            // API of tsickle for lowering decorators to properties on the class.
            if (typeOrFunc.propDecorators) {
                var propDecorators_1 = typeOrFunc.propDecorators;
                var propMetadata_1 = {};
                Object.keys(propDecorators_1).forEach(function (prop) {
                    propMetadata_1[prop] = convertTsickleDecoratorIntoMetadata(propDecorators_1[prop]);
                });
                return propMetadata_1;
            }
            // API for metadata created by invoking the decorators.
            if (this._reflect && this._reflect.getMetadata) {
                var propMetadata = this._reflect.getMetadata('propMetadata', typeOrFunc);
                if (propMetadata)
                    return propMetadata;
            }
            return {};
        };
        ReflectionCapabilities.prototype.hasLifecycleHook = function (type, lcProperty) {
            return type instanceof Type && lcProperty in type.prototype;
        };
        ReflectionCapabilities.prototype.getter = function (name) { return new Function('o', 'return o.' + name + ';'); };
        ReflectionCapabilities.prototype.setter = function (name) {
            return new Function('o', 'v', 'return o.' + name + ' = v;');
        };
        ReflectionCapabilities.prototype.method = function (name) {
            var functionBody = "if (!o." + name + ") throw new Error('\"" + name + "\" is undefined');\n        return o." + name + ".apply(o, args);";
            return new Function('o', 'args', functionBody);
        };
        // There is not a concept of import uri in Js, but this is useful in developing Dart applications.
        ReflectionCapabilities.prototype.importUri = function (type) {
            // StaticSymbol
            if (typeof type === 'object' && type['filePath']) {
                return type['filePath'];
            }
            // Runtime type
            return "./" + stringify(type);
        };
        ReflectionCapabilities.prototype.resolveIdentifier = function (name, moduleUrl, runtime) { return runtime; };
        ReflectionCapabilities.prototype.resolveEnum = function (enumIdentifier, name) { return enumIdentifier[name]; };
        return ReflectionCapabilities;
    }());
    function convertTsickleDecoratorIntoMetadata(decoratorInvocations) {
        if (!decoratorInvocations) {
            return [];
        }
        return decoratorInvocations.map(function (decoratorInvocation) {
            var decoratorType = decoratorInvocation.type;
            var annotationCls = decoratorType.annotationCls;
            var annotationArgs = decoratorInvocation.args ? decoratorInvocation.args : [];
            return new (annotationCls.bind.apply(annotationCls, [void 0].concat(annotationArgs)))();
        });
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Provides read-only access to reflection data about symbols. Used internally by Angular
     * to power dependency injection and compilation.
     */
    var ReflectorReader = (function () {
        function ReflectorReader() {
        }
        return ReflectorReader;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$2 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    /**
     * Provides access to reflection data about symbols. Used internally by Angular
     * to power dependency injection and compilation.
     */
    var Reflector = (function (_super) {
        __extends$2(Reflector, _super);
        function Reflector(reflectionCapabilities) {
            _super.call(this);
            this.reflectionCapabilities = reflectionCapabilities;
        }
        Reflector.prototype.updateCapabilities = function (caps) { this.reflectionCapabilities = caps; };
        Reflector.prototype.factory = function (type) { return this.reflectionCapabilities.factory(type); };
        Reflector.prototype.parameters = function (typeOrFunc) {
            return this.reflectionCapabilities.parameters(typeOrFunc);
        };
        Reflector.prototype.annotations = function (typeOrFunc) {
            return this.reflectionCapabilities.annotations(typeOrFunc);
        };
        Reflector.prototype.propMetadata = function (typeOrFunc) {
            return this.reflectionCapabilities.propMetadata(typeOrFunc);
        };
        Reflector.prototype.hasLifecycleHook = function (type, lcProperty) {
            return this.reflectionCapabilities.hasLifecycleHook(type, lcProperty);
        };
        Reflector.prototype.getter = function (name) { return this.reflectionCapabilities.getter(name); };
        Reflector.prototype.setter = function (name) { return this.reflectionCapabilities.setter(name); };
        Reflector.prototype.method = function (name) { return this.reflectionCapabilities.method(name); };
        Reflector.prototype.importUri = function (type) { return this.reflectionCapabilities.importUri(type); };
        Reflector.prototype.resolveIdentifier = function (name, moduleUrl, runtime) {
            return this.reflectionCapabilities.resolveIdentifier(name, moduleUrl, runtime);
        };
        Reflector.prototype.resolveEnum = function (identifier, name) {
            return this.reflectionCapabilities.resolveEnum(identifier, name);
        };
        return Reflector;
    }(ReflectorReader));

    /**
     * The {@link Reflector} used internally in Angular to access metadata
     * about symbols.
     */
    var reflector = new Reflector(new ReflectionCapabilities());

    /**
     * `Dependency` is used by the framework to extend DI.
     * This is internal to Angular and should not be used directly.
     */
    var ReflectiveDependency = (function () {
        function ReflectiveDependency(key, optional, lowerBoundVisibility, upperBoundVisibility, properties) {
            this.key = key;
            this.optional = optional;
            this.lowerBoundVisibility = lowerBoundVisibility;
            this.upperBoundVisibility = upperBoundVisibility;
            this.properties = properties;
        }
        ReflectiveDependency.fromKey = function (key) {
            return new ReflectiveDependency(key, false, null, null, []);
        };
        return ReflectiveDependency;
    }());
    var _EMPTY_LIST = [];
    var ResolvedReflectiveProvider_ = (function () {
        function ResolvedReflectiveProvider_(key, resolvedFactories, multiProvider) {
            this.key = key;
            this.resolvedFactories = resolvedFactories;
            this.multiProvider = multiProvider;
        }
        Object.defineProperty(ResolvedReflectiveProvider_.prototype, "resolvedFactory", {
            get: function () { return this.resolvedFactories[0]; },
            enumerable: true,
            configurable: true
        });
        return ResolvedReflectiveProvider_;
    }());
    /**
     * An internal resolved representation of a factory function created by resolving {@link
     * Provider}.
     * @experimental
     */
    var ResolvedReflectiveFactory = (function () {
        function ResolvedReflectiveFactory(
            /**
             * Factory function which can return an instance of an object represented by a key.
             */
            factory,
            /**
             * Arguments (dependencies) to the `factory` function.
             */
            dependencies) {
            this.factory = factory;
            this.dependencies = dependencies;
        }
        return ResolvedReflectiveFactory;
    }());
    /**
     * Resolve a single provider.
     */
    function resolveReflectiveFactory(provider) {
        var factoryFn;
        var resolvedDeps;
        if (isPresent(provider.useClass)) {
            var useClass = resolveForwardRef(provider.useClass);
            factoryFn = reflector.factory(useClass);
            resolvedDeps = _dependenciesFor(useClass);
        }
        else if (isPresent(provider.useExisting)) {
            factoryFn = function (aliasInstance) { return aliasInstance; };
            resolvedDeps = [ReflectiveDependency.fromKey(ReflectiveKey.get(provider.useExisting))];
        }
        else if (isPresent(provider.useFactory)) {
            factoryFn = provider.useFactory;
            resolvedDeps = constructDependencies(provider.useFactory, provider.deps);
        }
        else {
            factoryFn = function () { return provider.useValue; };
            resolvedDeps = _EMPTY_LIST;
        }
        return new ResolvedReflectiveFactory(factoryFn, resolvedDeps);
    }
    /**
     * Converts the {@link Provider} into {@link ResolvedProvider}.
     *
     * {@link Injector} internally only uses {@link ResolvedProvider}, {@link Provider} contains
     * convenience provider syntax.
     */
    function resolveReflectiveProvider(provider) {
        return new ResolvedReflectiveProvider_(ReflectiveKey.get(provider.provide), [resolveReflectiveFactory(provider)], provider.multi);
    }
    /**
     * Resolve a list of Providers.
     */
    function resolveReflectiveProviders(providers) {
        var normalized = _normalizeProviders(providers, []);
        var resolved = normalized.map(resolveReflectiveProvider);
        return MapWrapper.values(mergeResolvedReflectiveProviders(resolved, new Map()));
    }
    /**
     * Merges a list of ResolvedProviders into a list where
     * each key is contained exactly once and multi providers
     * have been merged.
     */
    function mergeResolvedReflectiveProviders(providers, normalizedProvidersMap) {
        for (var i = 0; i < providers.length; i++) {
            var provider = providers[i];
            var existing = normalizedProvidersMap.get(provider.key.id);
            if (isPresent(existing)) {
                if (provider.multiProvider !== existing.multiProvider) {
                    throw new MixingMultiProvidersWithRegularProvidersError(existing, provider);
                }
                if (provider.multiProvider) {
                    for (var j = 0; j < provider.resolvedFactories.length; j++) {
                        existing.resolvedFactories.push(provider.resolvedFactories[j]);
                    }
                }
                else {
                    normalizedProvidersMap.set(provider.key.id, provider);
                }
            }
            else {
                var resolvedProvider;
                if (provider.multiProvider) {
                    resolvedProvider = new ResolvedReflectiveProvider_(provider.key, ListWrapper.clone(provider.resolvedFactories), provider.multiProvider);
                }
                else {
                    resolvedProvider = provider;
                }
                normalizedProvidersMap.set(provider.key.id, resolvedProvider);
            }
        }
        return normalizedProvidersMap;
    }
    function _normalizeProviders(providers, res) {
        providers.forEach(function (b) {
            if (b instanceof Type) {
                res.push({ provide: b, useClass: b });
            }
            else if (b && typeof b == 'object' && b.provide !== undefined) {
                res.push(b);
            }
            else if (b instanceof Array) {
                _normalizeProviders(b, res);
            }
            else {
                throw new InvalidProviderError(b);
            }
        });
        return res;
    }
    function constructDependencies(typeOrFunc, dependencies) {
        if (!dependencies) {
            return _dependenciesFor(typeOrFunc);
        }
        else {
            var params = dependencies.map(function (t) { return [t]; });
            return dependencies.map(function (t) { return _extractToken(typeOrFunc, t, params); });
        }
    }
    function _dependenciesFor(typeOrFunc) {
        var params = reflector.parameters(typeOrFunc);
        if (!params)
            return [];
        if (params.some(isBlank)) {
            throw new NoAnnotationError(typeOrFunc, params);
        }
        return params.map(function (p) { return _extractToken(typeOrFunc, p, params); });
    }
    function _extractToken(typeOrFunc /** TODO #9100 */, metadata /** TODO #9100 */ /*any[] | any*/, params) {
        var depProps = [];
        var token = null;
        var optional = false;
        if (!Array.isArray(metadata)) {
            if (metadata instanceof Inject) {
                return _createDependency(metadata.token, optional, null, null, depProps);
            }
            else {
                return _createDependency(metadata, optional, null, null, depProps);
            }
        }
        var lowerBoundVisibility = null;
        var upperBoundVisibility = null;
        for (var i = 0; i < metadata.length; ++i) {
            var paramMetadata = metadata[i];
            if (paramMetadata instanceof Type) {
                token = paramMetadata;
            }
            else if (paramMetadata instanceof Inject) {
                token = paramMetadata.token;
            }
            else if (paramMetadata instanceof Optional) {
                optional = true;
            }
            else if (paramMetadata instanceof Self) {
                upperBoundVisibility = paramMetadata;
            }
            else if (paramMetadata instanceof Host) {
                upperBoundVisibility = paramMetadata;
            }
            else if (paramMetadata instanceof SkipSelf) {
                lowerBoundVisibility = paramMetadata;
            }
        }
        token = resolveForwardRef(token);
        if (isPresent(token)) {
            return _createDependency(token, optional, lowerBoundVisibility, upperBoundVisibility, depProps);
        }
        else {
            throw new NoAnnotationError(typeOrFunc, params);
        }
    }
    function _createDependency(token /** TODO #9100 */, optional /** TODO #9100 */, lowerBoundVisibility /** TODO #9100 */, upperBoundVisibility /** TODO #9100 */, depProps /** TODO #9100 */) {
        return new ReflectiveDependency(ReflectiveKey.get(token), optional, lowerBoundVisibility, upperBoundVisibility, depProps);
    }

    // avoid unused import when Type union types are erased
    // Threshold for the dynamic version
    var _MAX_CONSTRUCTION_COUNTER = 10;
    var UNDEFINED = new Object();
    var ReflectiveProtoInjectorInlineStrategy = (function () {
        function ReflectiveProtoInjectorInlineStrategy(protoEI, providers) {
            this.provider0 = null;
            this.provider1 = null;
            this.provider2 = null;
            this.provider3 = null;
            this.provider4 = null;
            this.provider5 = null;
            this.provider6 = null;
            this.provider7 = null;
            this.provider8 = null;
            this.provider9 = null;
            this.keyId0 = null;
            this.keyId1 = null;
            this.keyId2 = null;
            this.keyId3 = null;
            this.keyId4 = null;
            this.keyId5 = null;
            this.keyId6 = null;
            this.keyId7 = null;
            this.keyId8 = null;
            this.keyId9 = null;
            var length = providers.length;
            if (length > 0) {
                this.provider0 = providers[0];
                this.keyId0 = providers[0].key.id;
            }
            if (length > 1) {
                this.provider1 = providers[1];
                this.keyId1 = providers[1].key.id;
            }
            if (length > 2) {
                this.provider2 = providers[2];
                this.keyId2 = providers[2].key.id;
            }
            if (length > 3) {
                this.provider3 = providers[3];
                this.keyId3 = providers[3].key.id;
            }
            if (length > 4) {
                this.provider4 = providers[4];
                this.keyId4 = providers[4].key.id;
            }
            if (length > 5) {
                this.provider5 = providers[5];
                this.keyId5 = providers[5].key.id;
            }
            if (length > 6) {
                this.provider6 = providers[6];
                this.keyId6 = providers[6].key.id;
            }
            if (length > 7) {
                this.provider7 = providers[7];
                this.keyId7 = providers[7].key.id;
            }
            if (length > 8) {
                this.provider8 = providers[8];
                this.keyId8 = providers[8].key.id;
            }
            if (length > 9) {
                this.provider9 = providers[9];
                this.keyId9 = providers[9].key.id;
            }
        }
        ReflectiveProtoInjectorInlineStrategy.prototype.getProviderAtIndex = function (index) {
            if (index == 0)
                return this.provider0;
            if (index == 1)
                return this.provider1;
            if (index == 2)
                return this.provider2;
            if (index == 3)
                return this.provider3;
            if (index == 4)
                return this.provider4;
            if (index == 5)
                return this.provider5;
            if (index == 6)
                return this.provider6;
            if (index == 7)
                return this.provider7;
            if (index == 8)
                return this.provider8;
            if (index == 9)
                return this.provider9;
            throw new OutOfBoundsError(index);
        };
        ReflectiveProtoInjectorInlineStrategy.prototype.createInjectorStrategy = function (injector) {
            return new ReflectiveInjectorInlineStrategy(injector, this);
        };
        return ReflectiveProtoInjectorInlineStrategy;
    }());
    var ReflectiveProtoInjectorDynamicStrategy = (function () {
        function ReflectiveProtoInjectorDynamicStrategy(protoInj, providers) {
            this.providers = providers;
            var len = providers.length;
            this.keyIds = new Array(len);
            for (var i = 0; i < len; i++) {
                this.keyIds[i] = providers[i].key.id;
            }
        }
        ReflectiveProtoInjectorDynamicStrategy.prototype.getProviderAtIndex = function (index) {
            if (index < 0 || index >= this.providers.length) {
                throw new OutOfBoundsError(index);
            }
            return this.providers[index];
        };
        ReflectiveProtoInjectorDynamicStrategy.prototype.createInjectorStrategy = function (ei) {
            return new ReflectiveInjectorDynamicStrategy(this, ei);
        };
        return ReflectiveProtoInjectorDynamicStrategy;
    }());
    var ReflectiveProtoInjector = (function () {
        function ReflectiveProtoInjector(providers) {
            this.numberOfProviders = providers.length;
            this._strategy = providers.length > _MAX_CONSTRUCTION_COUNTER ?
                new ReflectiveProtoInjectorDynamicStrategy(this, providers) :
                new ReflectiveProtoInjectorInlineStrategy(this, providers);
        }
        ReflectiveProtoInjector.fromResolvedProviders = function (providers) {
            return new ReflectiveProtoInjector(providers);
        };
        ReflectiveProtoInjector.prototype.getProviderAtIndex = function (index) {
            return this._strategy.getProviderAtIndex(index);
        };
        return ReflectiveProtoInjector;
    }());
    var ReflectiveInjectorInlineStrategy = (function () {
        function ReflectiveInjectorInlineStrategy(injector, protoStrategy) {
            this.injector = injector;
            this.protoStrategy = protoStrategy;
            this.obj0 = UNDEFINED;
            this.obj1 = UNDEFINED;
            this.obj2 = UNDEFINED;
            this.obj3 = UNDEFINED;
            this.obj4 = UNDEFINED;
            this.obj5 = UNDEFINED;
            this.obj6 = UNDEFINED;
            this.obj7 = UNDEFINED;
            this.obj8 = UNDEFINED;
            this.obj9 = UNDEFINED;
        }
        ReflectiveInjectorInlineStrategy.prototype.resetConstructionCounter = function () { this.injector._constructionCounter = 0; };
        ReflectiveInjectorInlineStrategy.prototype.instantiateProvider = function (provider) {
            return this.injector._new(provider);
        };
        ReflectiveInjectorInlineStrategy.prototype.getObjByKeyId = function (keyId) {
            var p = this.protoStrategy;
            var inj = this.injector;
            if (p.keyId0 === keyId) {
                if (this.obj0 === UNDEFINED) {
                    this.obj0 = inj._new(p.provider0);
                }
                return this.obj0;
            }
            if (p.keyId1 === keyId) {
                if (this.obj1 === UNDEFINED) {
                    this.obj1 = inj._new(p.provider1);
                }
                return this.obj1;
            }
            if (p.keyId2 === keyId) {
                if (this.obj2 === UNDEFINED) {
                    this.obj2 = inj._new(p.provider2);
                }
                return this.obj2;
            }
            if (p.keyId3 === keyId) {
                if (this.obj3 === UNDEFINED) {
                    this.obj3 = inj._new(p.provider3);
                }
                return this.obj3;
            }
            if (p.keyId4 === keyId) {
                if (this.obj4 === UNDEFINED) {
                    this.obj4 = inj._new(p.provider4);
                }
                return this.obj4;
            }
            if (p.keyId5 === keyId) {
                if (this.obj5 === UNDEFINED) {
                    this.obj5 = inj._new(p.provider5);
                }
                return this.obj5;
            }
            if (p.keyId6 === keyId) {
                if (this.obj6 === UNDEFINED) {
                    this.obj6 = inj._new(p.provider6);
                }
                return this.obj6;
            }
            if (p.keyId7 === keyId) {
                if (this.obj7 === UNDEFINED) {
                    this.obj7 = inj._new(p.provider7);
                }
                return this.obj7;
            }
            if (p.keyId8 === keyId) {
                if (this.obj8 === UNDEFINED) {
                    this.obj8 = inj._new(p.provider8);
                }
                return this.obj8;
            }
            if (p.keyId9 === keyId) {
                if (this.obj9 === UNDEFINED) {
                    this.obj9 = inj._new(p.provider9);
                }
                return this.obj9;
            }
            return UNDEFINED;
        };
        ReflectiveInjectorInlineStrategy.prototype.getObjAtIndex = function (index) {
            if (index == 0)
                return this.obj0;
            if (index == 1)
                return this.obj1;
            if (index == 2)
                return this.obj2;
            if (index == 3)
                return this.obj3;
            if (index == 4)
                return this.obj4;
            if (index == 5)
                return this.obj5;
            if (index == 6)
                return this.obj6;
            if (index == 7)
                return this.obj7;
            if (index == 8)
                return this.obj8;
            if (index == 9)
                return this.obj9;
            throw new OutOfBoundsError(index);
        };
        ReflectiveInjectorInlineStrategy.prototype.getMaxNumberOfObjects = function () { return _MAX_CONSTRUCTION_COUNTER; };
        return ReflectiveInjectorInlineStrategy;
    }());
    var ReflectiveInjectorDynamicStrategy = (function () {
        function ReflectiveInjectorDynamicStrategy(protoStrategy, injector) {
            this.protoStrategy = protoStrategy;
            this.injector = injector;
            this.objs = new Array(protoStrategy.providers.length);
            ListWrapper.fill(this.objs, UNDEFINED);
        }
        ReflectiveInjectorDynamicStrategy.prototype.resetConstructionCounter = function () { this.injector._constructionCounter = 0; };
        ReflectiveInjectorDynamicStrategy.prototype.instantiateProvider = function (provider) {
            return this.injector._new(provider);
        };
        ReflectiveInjectorDynamicStrategy.prototype.getObjByKeyId = function (keyId) {
            var p = this.protoStrategy;
            for (var i = 0; i < p.keyIds.length; i++) {
                if (p.keyIds[i] === keyId) {
                    if (this.objs[i] === UNDEFINED) {
                        this.objs[i] = this.injector._new(p.providers[i]);
                    }
                    return this.objs[i];
                }
            }
            return UNDEFINED;
        };
        ReflectiveInjectorDynamicStrategy.prototype.getObjAtIndex = function (index) {
            if (index < 0 || index >= this.objs.length) {
                throw new OutOfBoundsError(index);
            }
            return this.objs[index];
        };
        ReflectiveInjectorDynamicStrategy.prototype.getMaxNumberOfObjects = function () { return this.objs.length; };
        return ReflectiveInjectorDynamicStrategy;
    }());
    /**
     * A ReflectiveDependency injection container used for instantiating objects and resolving
     * dependencies.
     *
     * An `Injector` is a replacement for a `new` operator, which can automatically resolve the
     * constructor dependencies.
     *
     * In typical use, application code asks for the dependencies in the constructor and they are
     * resolved by the `Injector`.
     *
     * ### Example ([live demo](http://plnkr.co/edit/jzjec0?p=preview))
     *
     * The following example creates an `Injector` configured to create `Engine` and `Car`.
     *
     * ```typescript
     * @Injectable()
     * class Engine {
     * }
     *
     * @Injectable()
     * class Car {
     *   constructor(public engine:Engine) {}
     * }
     *
     * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);
     * var car = injector.get(Car);
     * expect(car instanceof Car).toBe(true);
     * expect(car.engine instanceof Engine).toBe(true);
     * ```
     *
     * Notice, we don't use the `new` operator because we explicitly want to have the `Injector`
     * resolve all of the object's dependencies automatically.
     *
     * @stable
     */
    var ReflectiveInjector = (function () {
        function ReflectiveInjector() {
        }
        /**
         * Turns an array of provider definitions into an array of resolved providers.
         *
         * A resolution is a process of flattening multiple nested arrays and converting individual
         * providers into an array of {@link ResolvedReflectiveProvider}s.
         *
         * ### Example ([live demo](http://plnkr.co/edit/AiXTHi?p=preview))
         *
         * ```typescript
         * @Injectable()
         * class Engine {
         * }
         *
         * @Injectable()
         * class Car {
         *   constructor(public engine:Engine) {}
         * }
         *
         * var providers = ReflectiveInjector.resolve([Car, [[Engine]]]);
         *
         * expect(providers.length).toEqual(2);
         *
         * expect(providers[0] instanceof ResolvedReflectiveProvider).toBe(true);
         * expect(providers[0].key.displayName).toBe("Car");
         * expect(providers[0].dependencies.length).toEqual(1);
         * expect(providers[0].factory).toBeDefined();
         *
         * expect(providers[1].key.displayName).toBe("Engine");
         * });
         * ```
         *
         * See {@link ReflectiveInjector#fromResolvedProviders} for more info.
         */
        ReflectiveInjector.resolve = function (providers) {
            return resolveReflectiveProviders(providers);
        };
        /**
         * Resolves an array of providers and creates an injector from those providers.
         *
         * The passed-in providers can be an array of `Type`, {@link Provider},
         * or a recursive array of more providers.
         *
         * ### Example ([live demo](http://plnkr.co/edit/ePOccA?p=preview))
         *
         * ```typescript
         * @Injectable()
         * class Engine {
         * }
         *
         * @Injectable()
         * class Car {
         *   constructor(public engine:Engine) {}
         * }
         *
         * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);
         * expect(injector.get(Car) instanceof Car).toBe(true);
         * ```
         *
         * This function is slower than the corresponding `fromResolvedProviders`
         * because it needs to resolve the passed-in providers first.
         * See {@link Injector#resolve} and {@link Injector#fromResolvedProviders}.
         */
        ReflectiveInjector.resolveAndCreate = function (providers, parent) {
            if (parent === void 0) { parent = null; }
            var ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);
            return ReflectiveInjector.fromResolvedProviders(ResolvedReflectiveProviders, parent);
        };
        /**
         * Creates an injector from previously resolved providers.
         *
         * This API is the recommended way to construct injectors in performance-sensitive parts.
         *
         * ### Example ([live demo](http://plnkr.co/edit/KrSMci?p=preview))
         *
         * ```typescript
         * @Injectable()
         * class Engine {
         * }
         *
         * @Injectable()
         * class Car {
         *   constructor(public engine:Engine) {}
         * }
         *
         * var providers = ReflectiveInjector.resolve([Car, Engine]);
         * var injector = ReflectiveInjector.fromResolvedProviders(providers);
         * expect(injector.get(Car) instanceof Car).toBe(true);
         * ```
         * @experimental
         */
        ReflectiveInjector.fromResolvedProviders = function (providers, parent) {
            if (parent === void 0) { parent = null; }
            return new ReflectiveInjector_(ReflectiveProtoInjector.fromResolvedProviders(providers), parent);
        };
        Object.defineProperty(ReflectiveInjector.prototype, "parent", {
            /**
             * Parent of this injector.
             *
             * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.
             * -->
             *
             * ### Example ([live demo](http://plnkr.co/edit/eosMGo?p=preview))
             *
             * ```typescript
             * var parent = ReflectiveInjector.resolveAndCreate([]);
             * var child = parent.resolveAndCreateChild([]);
             * expect(child.parent).toBe(parent);
             * ```
             */
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        /**
         * Resolves an array of providers and creates a child injector from those providers.
         *
         * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.
         * -->
         *
         * The passed-in providers can be an array of `Type`, {@link Provider},
         * or a recursive array of more providers.
         *
         * ### Example ([live demo](http://plnkr.co/edit/opB3T4?p=preview))
         *
         * ```typescript
         * class ParentProvider {}
         * class ChildProvider {}
         *
         * var parent = ReflectiveInjector.resolveAndCreate([ParentProvider]);
         * var child = parent.resolveAndCreateChild([ChildProvider]);
         *
         * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);
         * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);
         * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));
         * ```
         *
         * This function is slower than the corresponding `createChildFromResolved`
         * because it needs to resolve the passed-in providers first.
         * See {@link Injector#resolve} and {@link Injector#createChildFromResolved}.
         */
        ReflectiveInjector.prototype.resolveAndCreateChild = function (providers) { return unimplemented(); };
        /**
         * Creates a child injector from previously resolved providers.
         *
         * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.
         * -->
         *
         * This API is the recommended way to construct injectors in performance-sensitive parts.
         *
         * ### Example ([live demo](http://plnkr.co/edit/VhyfjN?p=preview))
         *
         * ```typescript
         * class ParentProvider {}
         * class ChildProvider {}
         *
         * var parentProviders = ReflectiveInjector.resolve([ParentProvider]);
         * var childProviders = ReflectiveInjector.resolve([ChildProvider]);
         *
         * var parent = ReflectiveInjector.fromResolvedProviders(parentProviders);
         * var child = parent.createChildFromResolved(childProviders);
         *
         * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);
         * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);
         * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));
         * ```
         */
        ReflectiveInjector.prototype.createChildFromResolved = function (providers) {
            return unimplemented();
        };
        /**
         * Resolves a provider and instantiates an object in the context of the injector.
         *
         * The created object does not get cached by the injector.
         *
         * ### Example ([live demo](http://plnkr.co/edit/yvVXoB?p=preview))
         *
         * ```typescript
         * @Injectable()
         * class Engine {
         * }
         *
         * @Injectable()
         * class Car {
         *   constructor(public engine:Engine) {}
         * }
         *
         * var injector = ReflectiveInjector.resolveAndCreate([Engine]);
         *
         * var car = injector.resolveAndInstantiate(Car);
         * expect(car.engine).toBe(injector.get(Engine));
         * expect(car).not.toBe(injector.resolveAndInstantiate(Car));
         * ```
         */
        ReflectiveInjector.prototype.resolveAndInstantiate = function (provider) { return unimplemented(); };
        /**
         * Instantiates an object using a resolved provider in the context of the injector.
         *
         * The created object does not get cached by the injector.
         *
         * ### Example ([live demo](http://plnkr.co/edit/ptCImQ?p=preview))
         *
         * ```typescript
         * @Injectable()
         * class Engine {
         * }
         *
         * @Injectable()
         * class Car {
         *   constructor(public engine:Engine) {}
         * }
         *
         * var injector = ReflectiveInjector.resolveAndCreate([Engine]);
         * var carProvider = ReflectiveInjector.resolve([Car])[0];
         * var car = injector.instantiateResolved(carProvider);
         * expect(car.engine).toBe(injector.get(Engine));
         * expect(car).not.toBe(injector.instantiateResolved(carProvider));
         * ```
         */
        ReflectiveInjector.prototype.instantiateResolved = function (provider) { return unimplemented(); };
        return ReflectiveInjector;
    }());
    var ReflectiveInjector_ = (function () {
        /**
         * Private
         */
        function ReflectiveInjector_(_proto /* ProtoInjector */, _parent) {
            if (_parent === void 0) { _parent = null; }
            /** @internal */
            this._constructionCounter = 0;
            this._proto = _proto;
            this._parent = _parent;
            this._strategy = _proto._strategy.createInjectorStrategy(this);
        }
        ReflectiveInjector_.prototype.get = function (token, notFoundValue) {
            if (notFoundValue === void 0) { notFoundValue = THROW_IF_NOT_FOUND; }
            return this._getByKey(ReflectiveKey.get(token), null, null, notFoundValue);
        };
        ReflectiveInjector_.prototype.getAt = function (index) { return this._strategy.getObjAtIndex(index); };
        Object.defineProperty(ReflectiveInjector_.prototype, "parent", {
            get: function () { return this._parent; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ReflectiveInjector_.prototype, "internalStrategy", {
            /**
             * @internal
             * Internal. Do not use.
             * We return `any` not to export the InjectorStrategy type.
             */
            get: function () { return this._strategy; },
            enumerable: true,
            configurable: true
        });
        ReflectiveInjector_.prototype.resolveAndCreateChild = function (providers) {
            var ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);
            return this.createChildFromResolved(ResolvedReflectiveProviders);
        };
        ReflectiveInjector_.prototype.createChildFromResolved = function (providers) {
            var proto = new ReflectiveProtoInjector(providers);
            var inj = new ReflectiveInjector_(proto);
            inj._parent = this;
            return inj;
        };
        ReflectiveInjector_.prototype.resolveAndInstantiate = function (provider) {
            return this.instantiateResolved(ReflectiveInjector.resolve([provider])[0]);
        };
        ReflectiveInjector_.prototype.instantiateResolved = function (provider) {
            return this._instantiateProvider(provider);
        };
        /** @internal */
        ReflectiveInjector_.prototype._new = function (provider) {
            if (this._constructionCounter++ > this._strategy.getMaxNumberOfObjects()) {
                throw new CyclicDependencyError(this, provider.key);
            }
            return this._instantiateProvider(provider);
        };
        ReflectiveInjector_.prototype._instantiateProvider = function (provider) {
            if (provider.multiProvider) {
                var res = new Array(provider.resolvedFactories.length);
                for (var i = 0; i < provider.resolvedFactories.length; ++i) {
                    res[i] = this._instantiate(provider, provider.resolvedFactories[i]);
                }
                return res;
            }
            else {
                return this._instantiate(provider, provider.resolvedFactories[0]);
            }
        };
        ReflectiveInjector_.prototype._instantiate = function (provider, ResolvedReflectiveFactory) {
            var factory = ResolvedReflectiveFactory.factory;
            var deps = ResolvedReflectiveFactory.dependencies;
            var length = deps.length;
            var d0;
            var d1;
            var d2;
            var d3;
            var d4;
            var d5;
            var d6;
            var d7;
            var d8;
            var d9;
            var d10;
            var d11;
            var d12;
            var d13;
            var d14;
            var d15;
            var d16;
            var d17;
            var d18;
            var d19;
            try {
                d0 = length > 0 ? this._getByReflectiveDependency(provider, deps[0]) : null;
                d1 = length > 1 ? this._getByReflectiveDependency(provider, deps[1]) : null;
                d2 = length > 2 ? this._getByReflectiveDependency(provider, deps[2]) : null;
                d3 = length > 3 ? this._getByReflectiveDependency(provider, deps[3]) : null;
                d4 = length > 4 ? this._getByReflectiveDependency(provider, deps[4]) : null;
                d5 = length > 5 ? this._getByReflectiveDependency(provider, deps[5]) : null;
                d6 = length > 6 ? this._getByReflectiveDependency(provider, deps[6]) : null;
                d7 = length > 7 ? this._getByReflectiveDependency(provider, deps[7]) : null;
                d8 = length > 8 ? this._getByReflectiveDependency(provider, deps[8]) : null;
                d9 = length > 9 ? this._getByReflectiveDependency(provider, deps[9]) : null;
                d10 = length > 10 ? this._getByReflectiveDependency(provider, deps[10]) : null;
                d11 = length > 11 ? this._getByReflectiveDependency(provider, deps[11]) : null;
                d12 = length > 12 ? this._getByReflectiveDependency(provider, deps[12]) : null;
                d13 = length > 13 ? this._getByReflectiveDependency(provider, deps[13]) : null;
                d14 = length > 14 ? this._getByReflectiveDependency(provider, deps[14]) : null;
                d15 = length > 15 ? this._getByReflectiveDependency(provider, deps[15]) : null;
                d16 = length > 16 ? this._getByReflectiveDependency(provider, deps[16]) : null;
                d17 = length > 17 ? this._getByReflectiveDependency(provider, deps[17]) : null;
                d18 = length > 18 ? this._getByReflectiveDependency(provider, deps[18]) : null;
                d19 = length > 19 ? this._getByReflectiveDependency(provider, deps[19]) : null;
            }
            catch (e) {
                if (e instanceof AbstractProviderError || e instanceof InstantiationError) {
                    e.addKey(this, provider.key);
                }
                throw e;
            }
            var obj;
            try {
                switch (length) {
                    case 0:
                        obj = factory();
                        break;
                    case 1:
                        obj = factory(d0);
                        break;
                    case 2:
                        obj = factory(d0, d1);
                        break;
                    case 3:
                        obj = factory(d0, d1, d2);
                        break;
                    case 4:
                        obj = factory(d0, d1, d2, d3);
                        break;
                    case 5:
                        obj = factory(d0, d1, d2, d3, d4);
                        break;
                    case 6:
                        obj = factory(d0, d1, d2, d3, d4, d5);
                        break;
                    case 7:
                        obj = factory(d0, d1, d2, d3, d4, d5, d6);
                        break;
                    case 8:
                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7);
                        break;
                    case 9:
                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8);
                        break;
                    case 10:
                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9);
                        break;
                    case 11:
                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10);
                        break;
                    case 12:
                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11);
                        break;
                    case 13:
                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12);
                        break;
                    case 14:
                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13);
                        break;
                    case 15:
                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14);
                        break;
                    case 16:
                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15);
                        break;
                    case 17:
                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16);
                        break;
                    case 18:
                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16, d17);
                        break;
                    case 19:
                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16, d17, d18);
                        break;
                    case 20:
                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16, d17, d18, d19);
                        break;
                    default:
                        throw new Error("Cannot instantiate '" + provider.key.displayName + "' because it has more than 20 dependencies");
                }
            }
            catch (e) {
                throw new InstantiationError(this, e, e.stack, provider.key);
            }
            return obj;
        };
        ReflectiveInjector_.prototype._getByReflectiveDependency = function (provider, dep) {
            return this._getByKey(dep.key, dep.lowerBoundVisibility, dep.upperBoundVisibility, dep.optional ? null : THROW_IF_NOT_FOUND);
        };
        ReflectiveInjector_.prototype._getByKey = function (key, lowerBoundVisibility, upperBoundVisibility, notFoundValue) {
            if (key === INJECTOR_KEY) {
                return this;
            }
            if (upperBoundVisibility instanceof Self) {
                return this._getByKeySelf(key, notFoundValue);
            }
            else {
                return this._getByKeyDefault(key, notFoundValue, lowerBoundVisibility);
            }
        };
        /** @internal */
        ReflectiveInjector_.prototype._throwOrNull = function (key, notFoundValue) {
            if (notFoundValue !== THROW_IF_NOT_FOUND) {
                return notFoundValue;
            }
            else {
                throw new NoProviderError(this, key);
            }
        };
        /** @internal */
        ReflectiveInjector_.prototype._getByKeySelf = function (key, notFoundValue) {
            var obj = this._strategy.getObjByKeyId(key.id);
            return (obj !== UNDEFINED) ? obj : this._throwOrNull(key, notFoundValue);
        };
        /** @internal */
        ReflectiveInjector_.prototype._getByKeyDefault = function (key, notFoundValue, lowerBoundVisibility) {
            var inj;
            if (lowerBoundVisibility instanceof SkipSelf) {
                inj = this._parent;
            }
            else {
                inj = this;
            }
            while (inj instanceof ReflectiveInjector_) {
                var inj_ = inj;
                var obj = inj_._strategy.getObjByKeyId(key.id);
                if (obj !== UNDEFINED)
                    return obj;
                inj = inj_._parent;
            }
            if (inj !== null) {
                return inj.get(key.token, notFoundValue);
            }
            else {
                return this._throwOrNull(key, notFoundValue);
            }
        };
        Object.defineProperty(ReflectiveInjector_.prototype, "displayName", {
            get: function () {
                var providers = _mapProviders(this, function (b) { return ' "' + b.key.displayName + '" '; })
                    .join(', ');
                return "ReflectiveInjector(providers: [" + providers + "])";
            },
            enumerable: true,
            configurable: true
        });
        ReflectiveInjector_.prototype.toString = function () { return this.displayName; };
        return ReflectiveInjector_;
    }());
    var INJECTOR_KEY = ReflectiveKey.get(Injector);
    function _mapProviders(injector, fn) {
        var res = new Array(injector._proto.numberOfProviders);
        for (var i = 0; i < injector._proto.numberOfProviders; ++i) {
            res[i] = fn(injector._proto.getProviderAtIndex(i));
        }
        return res;
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * @whatItDoes Provides a hook for centralized exception handling.
     *
     * @description
     *
     * The default implementation of `ErrorHandler` prints error messages to the `console`. To
     * intercept error handling, write a custom exception handler that replaces this default as
     * appropriate for your app.
     *
     * ### Example
     *
     * ```
     * class MyErrorHandler implements ErrorHandler {
     *   handleError(error) {
     *     // do something with the exception
     *   }
     * }
     *
     * @NgModule({
     *   providers: [{provide: ErrorHandler, useClass: MyErrorHandler}]
     * })
     * class MyModule {}
     * ```
     *
     * @stable
     */
    var ErrorHandler = (function () {
        function ErrorHandler(rethrowError) {
            if (rethrowError === void 0) { rethrowError = true; }
            /**
             * @internal
             */
            this._console = console;
            this.rethrowError = rethrowError;
        }
        ErrorHandler.prototype.handleError = function (error) {
            var originalError = this._findOriginalError(error);
            var originalStack = this._findOriginalStack(error);
            var context = this._findContext(error);
            this._console.error("EXCEPTION: " + this._extractMessage(error));
            if (originalError) {
                this._console.error("ORIGINAL EXCEPTION: " + this._extractMessage(originalError));
            }
            if (originalStack) {
                this._console.error('ORIGINAL STACKTRACE:');
                this._console.error(originalStack);
            }
            if (context) {
                this._console.error('ERROR CONTEXT:');
                this._console.error(context);
            }
            // We rethrow exceptions, so operations like 'bootstrap' will result in an error
            // when an error happens. If we do not rethrow, bootstrap will always succeed.
            if (this.rethrowError)
                throw error;
        };
        /** @internal */
        ErrorHandler.prototype._extractMessage = function (error) {
            return error instanceof Error ? error.message : error.toString();
        };
        /** @internal */
        ErrorHandler.prototype._findContext = function (error) {
            if (error) {
                return error.context ? error.context :
                    this._findContext(error.originalError);
            }
            return null;
        };
        /** @internal */
        ErrorHandler.prototype._findOriginalError = function (error) {
            var e = error.originalError;
            while (e && e.originalError) {
                e = e.originalError;
            }
            return e;
        };
        /** @internal */
        ErrorHandler.prototype._findOriginalStack = function (error) {
            if (!(error instanceof Error))
                return null;
            var e = error;
            var stack = e.stack;
            while (e instanceof Error && e.originalError) {
                e = e.originalError;
                if (e instanceof Error && e.stack) {
                    stack = e.stack;
                }
            }
            return stack;
        };
        return ErrorHandler;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function isPromise(obj) {
        // allow any Promise/A+ compliant thenable.
        // It's up to the caller to ensure that obj.then conforms to the spec
        return !!obj && typeof obj.then === 'function';
    }

    /**
     * A function that will be executed when an application is initialized.
     * @experimental
     */
    var APP_INITIALIZER = new OpaqueToken('Application Initializer');
    /**
     * A class that reflects the state of running {@link APP_INITIALIZER}s.
     *
     * @experimental
     */
    var ApplicationInitStatus = (function () {
        function ApplicationInitStatus(appInits) {
            var _this = this;
            this._done = false;
            var asyncInitPromises = [];
            if (appInits) {
                for (var i = 0; i < appInits.length; i++) {
                    var initResult = appInits[i]();
                    if (isPromise(initResult)) {
                        asyncInitPromises.push(initResult);
                    }
                }
            }
            this._donePromise = Promise.all(asyncInitPromises).then(function () { _this._done = true; });
            if (asyncInitPromises.length === 0) {
                this._done = true;
            }
        }
        Object.defineProperty(ApplicationInitStatus.prototype, "done", {
            get: function () { return this._done; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ApplicationInitStatus.prototype, "donePromise", {
            get: function () { return this._donePromise; },
            enumerable: true,
            configurable: true
        });
        ApplicationInitStatus.decorators = [
            { type: Injectable },
        ];
        /** @nocollapse */
        ApplicationInitStatus.ctorParameters = [
            { type: Array, decorators: [{ type: Inject, args: [APP_INITIALIZER,] }, { type: Optional },] },
        ];
        return ApplicationInitStatus;
    }());

    /**
     * A DI Token representing a unique string id assigned to the application by Angular and used
     * primarily for prefixing application attributes and CSS styles when
     * {@link ViewEncapsulation#Emulated} is being used.
     *
     * If you need to avoid randomly generated value to be used as an application id, you can provide
     * a custom value via a DI provider <!-- TODO: provider --> configuring the root {@link Injector}
     * using this token.
     * @experimental
     */
    var APP_ID = new OpaqueToken('AppId');
    function _appIdRandomProviderFactory() {
        return "" + _randomChar() + _randomChar() + _randomChar();
    }
    /**
     * Providers that will generate a random APP_ID_TOKEN.
     * @experimental
     */
    var APP_ID_RANDOM_PROVIDER = {
        provide: APP_ID,
        useFactory: _appIdRandomProviderFactory,
        deps: [],
    };
    function _randomChar() {
        return String.fromCharCode(97 + Math.floor(Math.random() * 25));
    }
    /**
     * A function that will be executed when a platform is initialized.
     * @experimental
     */
    var PLATFORM_INITIALIZER = new OpaqueToken('Platform Initializer');
    /**
     * All callbacks provided via this token will be called for every component that is bootstrapped.
     * Signature of the callback:
     *
     * `(componentRef: ComponentRef) => void`.
     *
     * @experimental
     */
    var APP_BOOTSTRAP_LISTENER = new OpaqueToken('appBootstrapListener');
    /**
     * A token which indicates the root directory of the application
     * @experimental
     */
    var PACKAGE_ROOT_URL = new OpaqueToken('Application Packages Root URL');

    var Console = (function () {
        function Console() {
        }
        Console.prototype.log = function (message) { print(message); };
        // Note: for reporting errors use `DOM.logError()` as it is platform specific
        Console.prototype.warn = function (message) { warn(message); };
        Console.decorators = [
            { type: Injectable },
        ];
        /** @nocollapse */
        Console.ctorParameters = [];
        return Console;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$4 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    /**
     * Indicates that a component is still being loaded in a synchronous compile.
     *
     * @stable
     */
    var ComponentStillLoadingError = (function (_super) {
        __extends$4(ComponentStillLoadingError, _super);
        function ComponentStillLoadingError(compType) {
            _super.call(this, "Can't compile synchronously as " + stringify(compType) + " is still being loaded!");
            this.compType = compType;
        }
        return ComponentStillLoadingError;
    }(BaseError));
    /**
     * Combination of NgModuleFactory and ComponentFactorys.
     *
     * @experimental
     */
    var ModuleWithComponentFactories = (function () {
        function ModuleWithComponentFactories(ngModuleFactory, componentFactories) {
            this.ngModuleFactory = ngModuleFactory;
            this.componentFactories = componentFactories;
        }
        return ModuleWithComponentFactories;
    }());
    function _throwError() {
        throw new Error("Runtime compiler is not loaded");
    }
    /**
     * Low-level service for running the angular compiler during runtime
     * to create {@link ComponentFactory}s, which
     * can later be used to create and render a Component instance.
     *
     * Each `@NgModule` provides an own `Compiler` to its injector,
     * that will use the directives/pipes of the ng module for compilation
     * of components.
     * @stable
     */
    var Compiler = (function () {
        function Compiler() {
        }
        /**
         * Compiles the given NgModule and all of its components. All templates of the components listed
         * in `entryComponents`
         * have to be inlined. Otherwise throws a {@link ComponentStillLoadingError}.
         */
        Compiler.prototype.compileModuleSync = function (moduleType) { throw _throwError(); };
        /**
         * Compiles the given NgModule and all of its components
         */
        Compiler.prototype.compileModuleAsync = function (moduleType) { throw _throwError(); };
        /**
         * Same as {@link compileModuleSync} but also creates ComponentFactories for all components.
         */
        Compiler.prototype.compileModuleAndAllComponentsSync = function (moduleType) {
            throw _throwError();
        };
        /**
         * Same as {@link compileModuleAsync} but also creates ComponentFactories for all components.
         */
        Compiler.prototype.compileModuleAndAllComponentsAsync = function (moduleType) {
            throw _throwError();
        };
        /**
         * Clears all caches.
         */
        Compiler.prototype.clearCache = function () { };
        /**
         * Clears the cache for the given component/ngModule.
         */
        Compiler.prototype.clearCacheFor = function (type) { };
        return Compiler;
    }());
    /**
     * Token to provide CompilerOptions in the platform injector.
     *
     * @experimental
     */
    var COMPILER_OPTIONS = new OpaqueToken('compilerOptions');
    /**
     * A factory for creating a Compiler
     *
     * @experimental
     */
    var CompilerFactory = (function () {
        function CompilerFactory() {
        }
        return CompilerFactory;
    }());

    var DefaultIterableDifferFactory = (function () {
        function DefaultIterableDifferFactory() {
        }
        DefaultIterableDifferFactory.prototype.supports = function (obj) { return isListLikeIterable(obj); };
        DefaultIterableDifferFactory.prototype.create = function (cdRef, trackByFn) {
            return new DefaultIterableDiffer(trackByFn);
        };
        return DefaultIterableDifferFactory;
    }());
    var trackByIdentity = function (index, item) { return item; };
    /**
     * @stable
     */
    var DefaultIterableDiffer = (function () {
        function DefaultIterableDiffer(_trackByFn) {
            this._trackByFn = _trackByFn;
            this._length = null;
            this._collection = null;
            // Keeps track of the used records at any point in time (during & across `_check()` calls)
            this._linkedRecords = null;
            // Keeps track of the removed records at any point in time during `_check()` calls.
            this._unlinkedRecords = null;
            this._previousItHead = null;
            this._itHead = null;
            this._itTail = null;
            this._additionsHead = null;
            this._additionsTail = null;
            this._movesHead = null;
            this._movesTail = null;
            this._removalsHead = null;
            this._removalsTail = null;
            // Keeps track of records where custom track by is the same, but item identity has changed
            this._identityChangesHead = null;
            this._identityChangesTail = null;
            this._trackByFn = this._trackByFn || trackByIdentity;
        }
        Object.defineProperty(DefaultIterableDiffer.prototype, "collection", {
            get: function () { return this._collection; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DefaultIterableDiffer.prototype, "length", {
            get: function () { return this._length; },
            enumerable: true,
            configurable: true
        });
        DefaultIterableDiffer.prototype.forEachItem = function (fn) {
            var record;
            for (record = this._itHead; record !== null; record = record._next) {
                fn(record);
            }
        };
        DefaultIterableDiffer.prototype.forEachOperation = function (fn) {
            var nextIt = this._itHead;
            var nextRemove = this._removalsHead;
            var addRemoveOffset = 0;
            var moveOffsets = null;
            while (nextIt || nextRemove) {
                // Figure out which is the next record to process
                // Order: remove, add, move
                var record = !nextRemove ||
                    nextIt &&
                        nextIt.currentIndex < getPreviousIndex(nextRemove, addRemoveOffset, moveOffsets) ?
                    nextIt :
                    nextRemove;
                var adjPreviousIndex = getPreviousIndex(record, addRemoveOffset, moveOffsets);
                var currentIndex = record.currentIndex;
                // consume the item, and adjust the addRemoveOffset and update moveDistance if necessary
                if (record === nextRemove) {
                    addRemoveOffset--;
                    nextRemove = nextRemove._nextRemoved;
                }
                else {
                    nextIt = nextIt._next;
                    if (record.previousIndex == null) {
                        addRemoveOffset++;
                    }
                    else {
                        // INVARIANT:  currentIndex < previousIndex
                        if (!moveOffsets)
                            moveOffsets = [];
                        var localMovePreviousIndex = adjPreviousIndex - addRemoveOffset;
                        var localCurrentIndex = currentIndex - addRemoveOffset;
                        if (localMovePreviousIndex != localCurrentIndex) {
                            for (var i = 0; i < localMovePreviousIndex; i++) {
                                var offset = i < moveOffsets.length ? moveOffsets[i] : (moveOffsets[i] = 0);
                                var index = offset + i;
                                if (localCurrentIndex <= index && index < localMovePreviousIndex) {
                                    moveOffsets[i] = offset + 1;
                                }
                            }
                            var previousIndex = record.previousIndex;
                            moveOffsets[previousIndex] = localCurrentIndex - localMovePreviousIndex;
                        }
                    }
                }
                if (adjPreviousIndex !== currentIndex) {
                    fn(record, adjPreviousIndex, currentIndex);
                }
            }
        };
        DefaultIterableDiffer.prototype.forEachPreviousItem = function (fn) {
            var record;
            for (record = this._previousItHead; record !== null; record = record._nextPrevious) {
                fn(record);
            }
        };
        DefaultIterableDiffer.prototype.forEachAddedItem = function (fn) {
            var record;
            for (record = this._additionsHead; record !== null; record = record._nextAdded) {
                fn(record);
            }
        };
        DefaultIterableDiffer.prototype.forEachMovedItem = function (fn) {
            var record;
            for (record = this._movesHead; record !== null; record = record._nextMoved) {
                fn(record);
            }
        };
        DefaultIterableDiffer.prototype.forEachRemovedItem = function (fn) {
            var record;
            for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
                fn(record);
            }
        };
        DefaultIterableDiffer.prototype.forEachIdentityChange = function (fn) {
            var record;
            for (record = this._identityChangesHead; record !== null; record = record._nextIdentityChange) {
                fn(record);
            }
        };
        DefaultIterableDiffer.prototype.diff = function (collection) {
            if (isBlank(collection))
                collection = [];
            if (!isListLikeIterable(collection)) {
                throw new Error("Error trying to diff '" + collection + "'");
            }
            if (this.check(collection)) {
                return this;
            }
            else {
                return null;
            }
        };
        DefaultIterableDiffer.prototype.onDestroy = function () { };
        // todo(vicb): optim for UnmodifiableListView (frozen arrays)
        DefaultIterableDiffer.prototype.check = function (collection) {
            var _this = this;
            this._reset();
            var record = this._itHead;
            var mayBeDirty = false;
            var index;
            var item;
            var itemTrackBy;
            if (Array.isArray(collection)) {
                var list = collection;
                this._length = collection.length;
                for (var index_1 = 0; index_1 < this._length; index_1++) {
                    item = list[index_1];
                    itemTrackBy = this._trackByFn(index_1, item);
                    if (record === null || !looseIdentical(record.trackById, itemTrackBy)) {
                        record = this._mismatch(record, item, itemTrackBy, index_1);
                        mayBeDirty = true;
                    }
                    else {
                        if (mayBeDirty) {
                            // TODO(misko): can we limit this to duplicates only?
                            record = this._verifyReinsertion(record, item, itemTrackBy, index_1);
                        }
                        if (!looseIdentical(record.item, item))
                            this._addIdentityChange(record, item);
                    }
                    record = record._next;
                }
            }
            else {
                index = 0;
                iterateListLike(collection, function (item /** TODO #9100 */) {
                    itemTrackBy = _this._trackByFn(index, item);
                    if (record === null || !looseIdentical(record.trackById, itemTrackBy)) {
                        record = _this._mismatch(record, item, itemTrackBy, index);
                        mayBeDirty = true;
                    }
                    else {
                        if (mayBeDirty) {
                            // TODO(misko): can we limit this to duplicates only?
                            record = _this._verifyReinsertion(record, item, itemTrackBy, index);
                        }
                        if (!looseIdentical(record.item, item))
                            _this._addIdentityChange(record, item);
                    }
                    record = record._next;
                    index++;
                });
                this._length = index;
            }
            this._truncate(record);
            this._collection = collection;
            return this.isDirty;
        };
        Object.defineProperty(DefaultIterableDiffer.prototype, "isDirty", {
            /* CollectionChanges is considered dirty if it has any additions, moves, removals, or identity
             * changes.
             */
            get: function () {
                return this._additionsHead !== null || this._movesHead !== null ||
                    this._removalsHead !== null || this._identityChangesHead !== null;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Reset the state of the change objects to show no changes. This means set previousKey to
         * currentKey, and clear all of the queues (additions, moves, removals).
         * Set the previousIndexes of moved and added items to their currentIndexes
         * Reset the list of additions, moves and removals
         *
         * @internal
         */
        DefaultIterableDiffer.prototype._reset = function () {
            if (this.isDirty) {
                var record;
                var nextRecord;
                for (record = this._previousItHead = this._itHead; record !== null; record = record._next) {
                    record._nextPrevious = record._next;
                }
                for (record = this._additionsHead; record !== null; record = record._nextAdded) {
                    record.previousIndex = record.currentIndex;
                }
                this._additionsHead = this._additionsTail = null;
                for (record = this._movesHead; record !== null; record = nextRecord) {
                    record.previousIndex = record.currentIndex;
                    nextRecord = record._nextMoved;
                }
                this._movesHead = this._movesTail = null;
                this._removalsHead = this._removalsTail = null;
                this._identityChangesHead = this._identityChangesTail = null;
            }
        };
        /**
         * This is the core function which handles differences between collections.
         *
         * - `record` is the record which we saw at this position last time. If null then it is a new
         *   item.
         * - `item` is the current item in the collection
         * - `index` is the position of the item in the collection
         *
         * @internal
         */
        DefaultIterableDiffer.prototype._mismatch = function (record, item, itemTrackBy, index) {
            // The previous record after which we will append the current one.
            var previousRecord;
            if (record === null) {
                previousRecord = this._itTail;
            }
            else {
                previousRecord = record._prev;
                // Remove the record from the collection since we know it does not match the item.
                this._remove(record);
            }
            // Attempt to see if we have seen the item before.
            record = this._linkedRecords === null ? null : this._linkedRecords.get(itemTrackBy, index);
            if (record !== null) {
                // We have seen this before, we need to move it forward in the collection.
                // But first we need to check if identity changed, so we can update in view if necessary
                if (!looseIdentical(record.item, item))
                    this._addIdentityChange(record, item);
                this._moveAfter(record, previousRecord, index);
            }
            else {
                // Never seen it, check evicted list.
                record = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy);
                if (record !== null) {
                    // It is an item which we have evicted earlier: reinsert it back into the list.
                    // But first we need to check if identity changed, so we can update in view if necessary
                    if (!looseIdentical(record.item, item))
                        this._addIdentityChange(record, item);
                    this._reinsertAfter(record, previousRecord, index);
                }
                else {
                    // It is a new item: add it.
                    record =
                        this._addAfter(new CollectionChangeRecord(item, itemTrackBy), previousRecord, index);
                }
            }
            return record;
        };
        /**
         * This check is only needed if an array contains duplicates. (Short circuit of nothing dirty)
         *
         * Use case: `[a, a]` => `[b, a, a]`
         *
         * If we did not have this check then the insertion of `b` would:
         *   1) evict first `a`
         *   2) insert `b` at `0` index.
         *   3) leave `a` at index `1` as is. <-- this is wrong!
         *   3) reinsert `a` at index 2. <-- this is wrong!
         *
         * The correct behavior is:
         *   1) evict first `a`
         *   2) insert `b` at `0` index.
         *   3) reinsert `a` at index 1.
         *   3) move `a` at from `1` to `2`.
         *
         *
         * Double check that we have not evicted a duplicate item. We need to check if the item type may
         * have already been removed:
         * The insertion of b will evict the first 'a'. If we don't reinsert it now it will be reinserted
         * at the end. Which will show up as the two 'a's switching position. This is incorrect, since a
         * better way to think of it is as insert of 'b' rather then switch 'a' with 'b' and then add 'a'
         * at the end.
         *
         * @internal
         */
        DefaultIterableDiffer.prototype._verifyReinsertion = function (record, item, itemTrackBy, index) {
            var reinsertRecord = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy);
            if (reinsertRecord !== null) {
                record = this._reinsertAfter(reinsertRecord, record._prev, index);
            }
            else if (record.currentIndex != index) {
                record.currentIndex = index;
                this._addToMoves(record, index);
            }
            return record;
        };
        /**
         * Get rid of any excess {@link CollectionChangeRecord}s from the previous collection
         *
         * - `record` The first excess {@link CollectionChangeRecord}.
         *
         * @internal
         */
        DefaultIterableDiffer.prototype._truncate = function (record) {
            // Anything after that needs to be removed;
            while (record !== null) {
                var nextRecord = record._next;
                this._addToRemovals(this._unlink(record));
                record = nextRecord;
            }
            if (this._unlinkedRecords !== null) {
                this._unlinkedRecords.clear();
            }
            if (this._additionsTail !== null) {
                this._additionsTail._nextAdded = null;
            }
            if (this._movesTail !== null) {
                this._movesTail._nextMoved = null;
            }
            if (this._itTail !== null) {
                this._itTail._next = null;
            }
            if (this._removalsTail !== null) {
                this._removalsTail._nextRemoved = null;
            }
            if (this._identityChangesTail !== null) {
                this._identityChangesTail._nextIdentityChange = null;
            }
        };
        /** @internal */
        DefaultIterableDiffer.prototype._reinsertAfter = function (record, prevRecord, index) {
            if (this._unlinkedRecords !== null) {
                this._unlinkedRecords.remove(record);
            }
            var prev = record._prevRemoved;
            var next = record._nextRemoved;
            if (prev === null) {
                this._removalsHead = next;
            }
            else {
                prev._nextRemoved = next;
            }
            if (next === null) {
                this._removalsTail = prev;
            }
            else {
                next._prevRemoved = prev;
            }
            this._insertAfter(record, prevRecord, index);
            this._addToMoves(record, index);
            return record;
        };
        /** @internal */
        DefaultIterableDiffer.prototype._moveAfter = function (record, prevRecord, index) {
            this._unlink(record);
            this._insertAfter(record, prevRecord, index);
            this._addToMoves(record, index);
            return record;
        };
        /** @internal */
        DefaultIterableDiffer.prototype._addAfter = function (record, prevRecord, index) {
            this._insertAfter(record, prevRecord, index);
            if (this._additionsTail === null) {
                // todo(vicb)
                // assert(this._additionsHead === null);
                this._additionsTail = this._additionsHead = record;
            }
            else {
                // todo(vicb)
                // assert(_additionsTail._nextAdded === null);
                // assert(record._nextAdded === null);
                this._additionsTail = this._additionsTail._nextAdded = record;
            }
            return record;
        };
        /** @internal */
        DefaultIterableDiffer.prototype._insertAfter = function (record, prevRecord, index) {
            // todo(vicb)
            // assert(record != prevRecord);
            // assert(record._next === null);
            // assert(record._prev === null);
            var next = prevRecord === null ? this._itHead : prevRecord._next;
            // todo(vicb)
            // assert(next != record);
            // assert(prevRecord != record);
            record._next = next;
            record._prev = prevRecord;
            if (next === null) {
                this._itTail = record;
            }
            else {
                next._prev = record;
            }
            if (prevRecord === null) {
                this._itHead = record;
            }
            else {
                prevRecord._next = record;
            }
            if (this._linkedRecords === null) {
                this._linkedRecords = new _DuplicateMap();
            }
            this._linkedRecords.put(record);
            record.currentIndex = index;
            return record;
        };
        /** @internal */
        DefaultIterableDiffer.prototype._remove = function (record) {
            return this._addToRemovals(this._unlink(record));
        };
        /** @internal */
        DefaultIterableDiffer.prototype._unlink = function (record) {
            if (this._linkedRecords !== null) {
                this._linkedRecords.remove(record);
            }
            var prev = record._prev;
            var next = record._next;
            // todo(vicb)
            // assert((record._prev = null) === null);
            // assert((record._next = null) === null);
            if (prev === null) {
                this._itHead = next;
            }
            else {
                prev._next = next;
            }
            if (next === null) {
                this._itTail = prev;
            }
            else {
                next._prev = prev;
            }
            return record;
        };
        /** @internal */
        DefaultIterableDiffer.prototype._addToMoves = function (record, toIndex) {
            // todo(vicb)
            // assert(record._nextMoved === null);
            if (record.previousIndex === toIndex) {
                return record;
            }
            if (this._movesTail === null) {
                // todo(vicb)
                // assert(_movesHead === null);
                this._movesTail = this._movesHead = record;
            }
            else {
                // todo(vicb)
                // assert(_movesTail._nextMoved === null);
                this._movesTail = this._movesTail._nextMoved = record;
            }
            return record;
        };
        /** @internal */
        DefaultIterableDiffer.prototype._addToRemovals = function (record) {
            if (this._unlinkedRecords === null) {
                this._unlinkedRecords = new _DuplicateMap();
            }
            this._unlinkedRecords.put(record);
            record.currentIndex = null;
            record._nextRemoved = null;
            if (this._removalsTail === null) {
                // todo(vicb)
                // assert(_removalsHead === null);
                this._removalsTail = this._removalsHead = record;
                record._prevRemoved = null;
            }
            else {
                // todo(vicb)
                // assert(_removalsTail._nextRemoved === null);
                // assert(record._nextRemoved === null);
                record._prevRemoved = this._removalsTail;
                this._removalsTail = this._removalsTail._nextRemoved = record;
            }
            return record;
        };
        /** @internal */
        DefaultIterableDiffer.prototype._addIdentityChange = function (record, item) {
            record.item = item;
            if (this._identityChangesTail === null) {
                this._identityChangesTail = this._identityChangesHead = record;
            }
            else {
                this._identityChangesTail = this._identityChangesTail._nextIdentityChange = record;
            }
            return record;
        };
        DefaultIterableDiffer.prototype.toString = function () {
            var list = [];
            this.forEachItem(function (record /** TODO #9100 */) { return list.push(record); });
            var previous = [];
            this.forEachPreviousItem(function (record /** TODO #9100 */) { return previous.push(record); });
            var additions = [];
            this.forEachAddedItem(function (record /** TODO #9100 */) { return additions.push(record); });
            var moves = [];
            this.forEachMovedItem(function (record /** TODO #9100 */) { return moves.push(record); });
            var removals = [];
            this.forEachRemovedItem(function (record /** TODO #9100 */) { return removals.push(record); });
            var identityChanges = [];
            this.forEachIdentityChange(function (record /** TODO #9100 */) { return identityChanges.push(record); });
            return 'collection: ' + list.join(', ') + '\n' +
                'previous: ' + previous.join(', ') + '\n' +
                'additions: ' + additions.join(', ') + '\n' +
                'moves: ' + moves.join(', ') + '\n' +
                'removals: ' + removals.join(', ') + '\n' +
                'identityChanges: ' + identityChanges.join(', ') + '\n';
        };
        return DefaultIterableDiffer;
    }());
    /**
     * @stable
     */
    var CollectionChangeRecord = (function () {
        function CollectionChangeRecord(item, trackById) {
            this.item = item;
            this.trackById = trackById;
            this.currentIndex = null;
            this.previousIndex = null;
            /** @internal */
            this._nextPrevious = null;
            /** @internal */
            this._prev = null;
            /** @internal */
            this._next = null;
            /** @internal */
            this._prevDup = null;
            /** @internal */
            this._nextDup = null;
            /** @internal */
            this._prevRemoved = null;
            /** @internal */
            this._nextRemoved = null;
            /** @internal */
            this._nextAdded = null;
            /** @internal */
            this._nextMoved = null;
            /** @internal */
            this._nextIdentityChange = null;
        }
        CollectionChangeRecord.prototype.toString = function () {
            return this.previousIndex === this.currentIndex ? stringify(this.item) :
                stringify(this.item) + '[' +
                    stringify(this.previousIndex) + '->' + stringify(this.currentIndex) + ']';
        };
        return CollectionChangeRecord;
    }());
    // A linked list of CollectionChangeRecords with the same CollectionChangeRecord.item
    var _DuplicateItemRecordList = (function () {
        function _DuplicateItemRecordList() {
            /** @internal */
            this._head = null;
            /** @internal */
            this._tail = null;
        }
        /**
         * Append the record to the list of duplicates.
         *
         * Note: by design all records in the list of duplicates hold the same value in record.item.
         */
        _DuplicateItemRecordList.prototype.add = function (record) {
            if (this._head === null) {
                this._head = this._tail = record;
                record._nextDup = null;
                record._prevDup = null;
            }
            else {
                // todo(vicb)
                // assert(record.item ==  _head.item ||
                //       record.item is num && record.item.isNaN && _head.item is num && _head.item.isNaN);
                this._tail._nextDup = record;
                record._prevDup = this._tail;
                record._nextDup = null;
                this._tail = record;
            }
        };
        // Returns a CollectionChangeRecord having CollectionChangeRecord.trackById == trackById and
        // CollectionChangeRecord.currentIndex >= afterIndex
        _DuplicateItemRecordList.prototype.get = function (trackById, afterIndex) {
            var record;
            for (record = this._head; record !== null; record = record._nextDup) {
                if ((afterIndex === null || afterIndex < record.currentIndex) &&
                    looseIdentical(record.trackById, trackById)) {
                    return record;
                }
            }
            return null;
        };
        /**
         * Remove one {@link CollectionChangeRecord} from the list of duplicates.
         *
         * Returns whether the list of duplicates is empty.
         */
        _DuplicateItemRecordList.prototype.remove = function (record) {
            // todo(vicb)
            // assert(() {
            //  // verify that the record being removed is in the list.
            //  for (CollectionChangeRecord cursor = _head; cursor != null; cursor = cursor._nextDup) {
            //    if (identical(cursor, record)) return true;
            //  }
            //  return false;
            //});
            var prev = record._prevDup;
            var next = record._nextDup;
            if (prev === null) {
                this._head = next;
            }
            else {
                prev._nextDup = next;
            }
            if (next === null) {
                this._tail = prev;
            }
            else {
                next._prevDup = prev;
            }
            return this._head === null;
        };
        return _DuplicateItemRecordList;
    }());
    var _DuplicateMap = (function () {
        function _DuplicateMap() {
            this.map = new Map();
        }
        _DuplicateMap.prototype.put = function (record) {
            var key = record.trackById;
            var duplicates = this.map.get(key);
            if (!duplicates) {
                duplicates = new _DuplicateItemRecordList();
                this.map.set(key, duplicates);
            }
            duplicates.add(record);
        };
        /**
         * Retrieve the `value` using key. Because the CollectionChangeRecord value may be one which we
         * have already iterated over, we use the afterIndex to pretend it is not there.
         *
         * Use case: `[a, b, c, a, a]` if we are at index `3` which is the second `a` then asking if we
         * have any more `a`s needs to return the last `a` not the first or second.
         */
        _DuplicateMap.prototype.get = function (trackById, afterIndex) {
            if (afterIndex === void 0) { afterIndex = null; }
            var key = trackById;
            var recordList = this.map.get(key);
            return recordList ? recordList.get(trackById, afterIndex) : null;
        };
        /**
         * Removes a {@link CollectionChangeRecord} from the list of duplicates.
         *
         * The list of duplicates also is removed from the map if it gets empty.
         */
        _DuplicateMap.prototype.remove = function (record) {
            var key = record.trackById;
            var recordList = this.map.get(key);
            // Remove the list of duplicates when it gets empty
            if (recordList.remove(record)) {
                this.map.delete(key);
            }
            return record;
        };
        Object.defineProperty(_DuplicateMap.prototype, "isEmpty", {
            get: function () { return this.map.size === 0; },
            enumerable: true,
            configurable: true
        });
        _DuplicateMap.prototype.clear = function () { this.map.clear(); };
        _DuplicateMap.prototype.toString = function () { return '_DuplicateMap(' + stringify(this.map) + ')'; };
        return _DuplicateMap;
    }());
    function getPreviousIndex(item, addRemoveOffset, moveOffsets) {
        var previousIndex = item.previousIndex;
        if (previousIndex === null)
            return previousIndex;
        var moveOffset = 0;
        if (moveOffsets && previousIndex < moveOffsets.length) {
            moveOffset = moveOffsets[previousIndex];
        }
        return previousIndex + addRemoveOffset + moveOffset;
    }

    var DefaultKeyValueDifferFactory = (function () {
        function DefaultKeyValueDifferFactory() {
        }
        DefaultKeyValueDifferFactory.prototype.supports = function (obj) { return obj instanceof Map || isJsObject(obj); };
        DefaultKeyValueDifferFactory.prototype.create = function (cdRef) { return new DefaultKeyValueDiffer(); };
        return DefaultKeyValueDifferFactory;
    }());
    var DefaultKeyValueDiffer = (function () {
        function DefaultKeyValueDiffer() {
            this._records = new Map();
            this._mapHead = null;
            this._previousMapHead = null;
            this._changesHead = null;
            this._changesTail = null;
            this._additionsHead = null;
            this._additionsTail = null;
            this._removalsHead = null;
            this._removalsTail = null;
        }
        Object.defineProperty(DefaultKeyValueDiffer.prototype, "isDirty", {
            get: function () {
                return this._additionsHead !== null || this._changesHead !== null ||
                    this._removalsHead !== null;
            },
            enumerable: true,
            configurable: true
        });
        DefaultKeyValueDiffer.prototype.forEachItem = function (fn) {
            var record;
            for (record = this._mapHead; record !== null; record = record._next) {
                fn(record);
            }
        };
        DefaultKeyValueDiffer.prototype.forEachPreviousItem = function (fn) {
            var record;
            for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {
                fn(record);
            }
        };
        DefaultKeyValueDiffer.prototype.forEachChangedItem = function (fn) {
            var record;
            for (record = this._changesHead; record !== null; record = record._nextChanged) {
                fn(record);
            }
        };
        DefaultKeyValueDiffer.prototype.forEachAddedItem = function (fn) {
            var record;
            for (record = this._additionsHead; record !== null; record = record._nextAdded) {
                fn(record);
            }
        };
        DefaultKeyValueDiffer.prototype.forEachRemovedItem = function (fn) {
            var record;
            for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
                fn(record);
            }
        };
        DefaultKeyValueDiffer.prototype.diff = function (map) {
            if (!map) {
                map = new Map();
            }
            else if (!(map instanceof Map || isJsObject(map))) {
                throw new Error("Error trying to diff '" + map + "'");
            }
            return this.check(map) ? this : null;
        };
        DefaultKeyValueDiffer.prototype.onDestroy = function () { };
        DefaultKeyValueDiffer.prototype.check = function (map) {
            var _this = this;
            this._reset();
            var records = this._records;
            var oldSeqRecord = this._mapHead;
            var lastOldSeqRecord = null;
            var lastNewSeqRecord = null;
            var seqChanged = false;
            this._forEach(map, function (value, key) {
                var newSeqRecord;
                if (oldSeqRecord && key === oldSeqRecord.key) {
                    newSeqRecord = oldSeqRecord;
                    _this._maybeAddToChanges(newSeqRecord, value);
                }
                else {
                    seqChanged = true;
                    if (oldSeqRecord !== null) {
                        _this._removeFromSeq(lastOldSeqRecord, oldSeqRecord);
                        _this._addToRemovals(oldSeqRecord);
                    }
                    if (records.has(key)) {
                        newSeqRecord = records.get(key);
                        _this._maybeAddToChanges(newSeqRecord, value);
                    }
                    else {
                        newSeqRecord = new KeyValueChangeRecord(key);
                        records.set(key, newSeqRecord);
                        newSeqRecord.currentValue = value;
                        _this._addToAdditions(newSeqRecord);
                    }
                }
                if (seqChanged) {
                    if (_this._isInRemovals(newSeqRecord)) {
                        _this._removeFromRemovals(newSeqRecord);
                    }
                    if (lastNewSeqRecord == null) {
                        _this._mapHead = newSeqRecord;
                    }
                    else {
                        lastNewSeqRecord._next = newSeqRecord;
                    }
                }
                lastOldSeqRecord = oldSeqRecord;
                lastNewSeqRecord = newSeqRecord;
                oldSeqRecord = oldSeqRecord && oldSeqRecord._next;
            });
            this._truncate(lastOldSeqRecord, oldSeqRecord);
            return this.isDirty;
        };
        /** @internal */
        DefaultKeyValueDiffer.prototype._reset = function () {
            if (this.isDirty) {
                var record = void 0;
                // Record the state of the mapping
                for (record = this._previousMapHead = this._mapHead; record !== null; record = record._next) {
                    record._nextPrevious = record._next;
                }
                for (record = this._changesHead; record !== null; record = record._nextChanged) {
                    record.previousValue = record.currentValue;
                }
                for (record = this._additionsHead; record != null; record = record._nextAdded) {
                    record.previousValue = record.currentValue;
                }
                this._changesHead = this._changesTail = null;
                this._additionsHead = this._additionsTail = null;
                this._removalsHead = this._removalsTail = null;
            }
        };
        /** @internal */
        DefaultKeyValueDiffer.prototype._truncate = function (lastRecord, record) {
            while (record !== null) {
                if (lastRecord === null) {
                    this._mapHead = null;
                }
                else {
                    lastRecord._next = null;
                }
                var nextRecord = record._next;
                this._addToRemovals(record);
                lastRecord = record;
                record = nextRecord;
            }
            for (var rec = this._removalsHead; rec !== null; rec = rec._nextRemoved) {
                rec.previousValue = rec.currentValue;
                rec.currentValue = null;
                this._records.delete(rec.key);
            }
        };
        DefaultKeyValueDiffer.prototype._maybeAddToChanges = function (record, newValue) {
            if (!looseIdentical(newValue, record.currentValue)) {
                record.previousValue = record.currentValue;
                record.currentValue = newValue;
                this._addToChanges(record);
            }
        };
        /** @internal */
        DefaultKeyValueDiffer.prototype._isInRemovals = function (record) {
            return record === this._removalsHead || record._nextRemoved !== null ||
                record._prevRemoved !== null;
        };
        /** @internal */
        DefaultKeyValueDiffer.prototype._addToRemovals = function (record) {
            if (this._removalsHead === null) {
                this._removalsHead = this._removalsTail = record;
            }
            else {
                this._removalsTail._nextRemoved = record;
                record._prevRemoved = this._removalsTail;
                this._removalsTail = record;
            }
        };
        /** @internal */
        DefaultKeyValueDiffer.prototype._removeFromSeq = function (prev, record) {
            var next = record._next;
            if (prev === null) {
                this._mapHead = next;
            }
            else {
                prev._next = next;
            }
            record._next = null;
        };
        /** @internal */
        DefaultKeyValueDiffer.prototype._removeFromRemovals = function (record) {
            var prev = record._prevRemoved;
            var next = record._nextRemoved;
            if (prev === null) {
                this._removalsHead = next;
            }
            else {
                prev._nextRemoved = next;
            }
            if (next === null) {
                this._removalsTail = prev;
            }
            else {
                next._prevRemoved = prev;
            }
            record._prevRemoved = record._nextRemoved = null;
        };
        /** @internal */
        DefaultKeyValueDiffer.prototype._addToAdditions = function (record) {
            if (this._additionsHead === null) {
                this._additionsHead = this._additionsTail = record;
            }
            else {
                this._additionsTail._nextAdded = record;
                this._additionsTail = record;
            }
        };
        /** @internal */
        DefaultKeyValueDiffer.prototype._addToChanges = function (record) {
            if (this._changesHead === null) {
                this._changesHead = this._changesTail = record;
            }
            else {
                this._changesTail._nextChanged = record;
                this._changesTail = record;
            }
        };
        DefaultKeyValueDiffer.prototype.toString = function () {
            var items = [];
            var previous = [];
            var changes = [];
            var additions = [];
            var removals = [];
            var record;
            for (record = this._mapHead; record !== null; record = record._next) {
                items.push(stringify(record));
            }
            for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {
                previous.push(stringify(record));
            }
            for (record = this._changesHead; record !== null; record = record._nextChanged) {
                changes.push(stringify(record));
            }
            for (record = this._additionsHead; record !== null; record = record._nextAdded) {
                additions.push(stringify(record));
            }
            for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
                removals.push(stringify(record));
            }
            return 'map: ' + items.join(', ') + '\n' +
                'previous: ' + previous.join(', ') + '\n' +
                'additions: ' + additions.join(', ') + '\n' +
                'changes: ' + changes.join(', ') + '\n' +
                'removals: ' + removals.join(', ') + '\n';
        };
        /** @internal */
        DefaultKeyValueDiffer.prototype._forEach = function (obj, fn) {
            if (obj instanceof Map) {
                obj.forEach(fn);
            }
            else {
                Object.keys(obj).forEach(function (k) { return fn(obj[k], k); });
            }
        };
        return DefaultKeyValueDiffer;
    }());
    /**
     * @stable
     */
    var KeyValueChangeRecord = (function () {
        function KeyValueChangeRecord(key) {
            this.key = key;
            this.previousValue = null;
            this.currentValue = null;
            /** @internal */
            this._nextPrevious = null;
            /** @internal */
            this._next = null;
            /** @internal */
            this._nextAdded = null;
            /** @internal */
            this._nextRemoved = null;
            /** @internal */
            this._prevRemoved = null;
            /** @internal */
            this._nextChanged = null;
        }
        KeyValueChangeRecord.prototype.toString = function () {
            return looseIdentical(this.previousValue, this.currentValue) ?
                stringify(this.key) :
                (stringify(this.key) + '[' + stringify(this.previousValue) + '->' +
                    stringify(this.currentValue) + ']');
        };
        return KeyValueChangeRecord;
    }());

    /**
     * A repository of different iterable diffing strategies used by NgFor, NgClass, and others.
     * @stable
     */
    var IterableDiffers = (function () {
        function IterableDiffers(factories) {
            this.factories = factories;
        }
        IterableDiffers.create = function (factories, parent) {
            if (isPresent(parent)) {
                var copied = ListWrapper.clone(parent.factories);
                factories = factories.concat(copied);
                return new IterableDiffers(factories);
            }
            else {
                return new IterableDiffers(factories);
            }
        };
        /**
         * Takes an array of {@link IterableDifferFactory} and returns a provider used to extend the
         * inherited {@link IterableDiffers} instance with the provided factories and return a new
         * {@link IterableDiffers} instance.
         *
         * The following example shows how to extend an existing list of factories,
               * which will only be applied to the injector for this component and its children.
               * This step is all that's required to make a new {@link IterableDiffer} available.
         *
         * ### Example
         *
         * ```
         * @Component({
         *   viewProviders: [
         *     IterableDiffers.extend([new ImmutableListDiffer()])
         *   ]
         * })
         * ```
         */
        IterableDiffers.extend = function (factories) {
            return {
                provide: IterableDiffers,
                useFactory: function (parent) {
                    if (!parent) {
                        // Typically would occur when calling IterableDiffers.extend inside of dependencies passed
                        // to
                        // bootstrap(), which would override default pipes instead of extending them.
                        throw new Error('Cannot extend IterableDiffers without a parent injector');
                    }
                    return IterableDiffers.create(factories, parent);
                },
                // Dependency technically isn't optional, but we can provide a better error message this way.
                deps: [[IterableDiffers, new SkipSelf(), new Optional()]]
            };
        };
        IterableDiffers.prototype.find = function (iterable) {
            var factory = this.factories.find(function (f) { return f.supports(iterable); });
            if (isPresent(factory)) {
                return factory;
            }
            else {
                throw new Error("Cannot find a differ supporting object '" + iterable + "' of type '" + getTypeNameForDebugging(iterable) + "'");
            }
        };
        return IterableDiffers;
    }());

    /**
     * A repository of different Map diffing strategies used by NgClass, NgStyle, and others.
     * @stable
     */
    var KeyValueDiffers = (function () {
        function KeyValueDiffers(factories) {
            this.factories = factories;
        }
        KeyValueDiffers.create = function (factories, parent) {
            if (isPresent(parent)) {
                var copied = ListWrapper.clone(parent.factories);
                factories = factories.concat(copied);
                return new KeyValueDiffers(factories);
            }
            else {
                return new KeyValueDiffers(factories);
            }
        };
        /**
         * Takes an array of {@link KeyValueDifferFactory} and returns a provider used to extend the
         * inherited {@link KeyValueDiffers} instance with the provided factories and return a new
         * {@link KeyValueDiffers} instance.
         *
         * The following example shows how to extend an existing list of factories,
               * which will only be applied to the injector for this component and its children.
               * This step is all that's required to make a new {@link KeyValueDiffer} available.
         *
         * ### Example
         *
         * ```
         * @Component({
         *   viewProviders: [
         *     KeyValueDiffers.extend([new ImmutableMapDiffer()])
         *   ]
         * })
         * ```
         */
        KeyValueDiffers.extend = function (factories) {
            return {
                provide: KeyValueDiffers,
                useFactory: function (parent) {
                    if (!parent) {
                        // Typically would occur when calling KeyValueDiffers.extend inside of dependencies passed
                        // to
                        // bootstrap(), which would override default pipes instead of extending them.
                        throw new Error('Cannot extend KeyValueDiffers without a parent injector');
                    }
                    return KeyValueDiffers.create(factories, parent);
                },
                // Dependency technically isn't optional, but we can provide a better error message this way.
                deps: [[KeyValueDiffers, new SkipSelf(), new Optional()]]
            };
        };
        KeyValueDiffers.prototype.find = function (kv) {
            var factory = this.factories.find(function (f) { return f.supports(kv); });
            if (isPresent(factory)) {
                return factory;
            }
            else {
                throw new Error("Cannot find a differ supporting object '" + kv + "'");
            }
        };
        return KeyValueDiffers;
    }());

    var UNINITIALIZED = {
        toString: function () { return 'CD_INIT_VALUE'; }
    };
    function devModeEqual(a, b) {
        if (isListLikeIterable(a) && isListLikeIterable(b)) {
            return areIterablesEqual(a, b, devModeEqual);
        }
        else if (!isListLikeIterable(a) && !isPrimitive(a) && !isListLikeIterable(b) && !isPrimitive(b)) {
            return true;
        }
        else {
            return looseIdentical(a, b);
        }
    }
    /**
     * Indicates that the result of a {@link Pipe} transformation has changed even though the
     * reference
     * has not changed.
     *
     * The wrapped value will be unwrapped by change detection, and the unwrapped value will be stored.
     *
     * Example:
     *
     * ```
     * if (this._latestValue === this._latestReturnedValue) {
     *    return this._latestReturnedValue;
     *  } else {
     *    this._latestReturnedValue = this._latestValue;
     *    return WrappedValue.wrap(this._latestValue); // this will force update
     *  }
     * ```
     * @stable
     */
    var WrappedValue = (function () {
        function WrappedValue(wrapped) {
            this.wrapped = wrapped;
        }
        WrappedValue.wrap = function (value) { return new WrappedValue(value); };
        return WrappedValue;
    }());
    /**
     * Helper class for unwrapping WrappedValue s
     */
    var ValueUnwrapper = (function () {
        function ValueUnwrapper() {
            this.hasWrappedValue = false;
        }
        ValueUnwrapper.prototype.unwrap = function (value) {
            if (value instanceof WrappedValue) {
                this.hasWrappedValue = true;
                return value.wrapped;
            }
            return value;
        };
        ValueUnwrapper.prototype.reset = function () { this.hasWrappedValue = false; };
        return ValueUnwrapper;
    }());
    /**
     * Represents a basic change from a previous to a new value.
     * @stable
     */
    var SimpleChange = (function () {
        function SimpleChange(previousValue, currentValue) {
            this.previousValue = previousValue;
            this.currentValue = currentValue;
        }
        /**
         * Check whether the new value is the first value assigned.
         */
        SimpleChange.prototype.isFirstChange = function () { return this.previousValue === UNINITIALIZED; };
        return SimpleChange;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * @stable
     */
    var ChangeDetectorRef = (function () {
        function ChangeDetectorRef() {
        }
        return ChangeDetectorRef;
    }());

    /**
     * Structural diffing for `Object`s and `Map`s.
     */
    var keyValDiff = [new DefaultKeyValueDifferFactory()];
    /**
     * Structural diffing for `Iterable` types such as `Array`s.
     */
    var iterableDiff = [new DefaultIterableDifferFactory()];
    var defaultIterableDiffers = new IterableDiffers(iterableDiff);
    var defaultKeyValueDiffers = new KeyValueDiffers(keyValDiff);

    /**
     * @experimental
     */
    // TODO (matsko): add typing for the animation function
    var RenderComponentType = (function () {
        function RenderComponentType(id, templateUrl, slotCount, encapsulation, styles, animations) {
            this.id = id;
            this.templateUrl = templateUrl;
            this.slotCount = slotCount;
            this.encapsulation = encapsulation;
            this.styles = styles;
            this.animations = animations;
        }
        return RenderComponentType;
    }());
    var RenderDebugInfo = (function () {
        function RenderDebugInfo() {
        }
        Object.defineProperty(RenderDebugInfo.prototype, "injector", {
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RenderDebugInfo.prototype, "component", {
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RenderDebugInfo.prototype, "providerTokens", {
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RenderDebugInfo.prototype, "references", {
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RenderDebugInfo.prototype, "context", {
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RenderDebugInfo.prototype, "source", {
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        return RenderDebugInfo;
    }());
    /**
     * @experimental
     */
    var Renderer = (function () {
        function Renderer() {
        }
        return Renderer;
    }());
    /**
     * Injectable service that provides a low-level interface for modifying the UI.
     *
     * Use this service to bypass Angular's templating and make custom UI changes that can't be
     * expressed declaratively. For example if you need to set a property or an attribute whose name is
     * not statically known, use {@link #setElementProperty} or {@link #setElementAttribute}
     * respectively.
     *
     * If you are implementing a custom renderer, you must implement this interface.
     *
     * The default Renderer implementation is `DomRenderer`. Also available is `WebWorkerRenderer`.
     * @experimental
     */
    var RootRenderer = (function () {
        function RootRenderer() {
        }
        return RootRenderer;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A SecurityContext marks a location that has dangerous security implications, e.g. a DOM property
     * like `innerHTML` that could cause Cross Site Scripting (XSS) security bugs when improperly
     * handled.
     *
     * See DomSanitizer for more details on security in Angular applications.
     *
     * @stable
     */
    exports.SecurityContext;
    (function (SecurityContext) {
        SecurityContext[SecurityContext["NONE"] = 0] = "NONE";
        SecurityContext[SecurityContext["HTML"] = 1] = "HTML";
        SecurityContext[SecurityContext["STYLE"] = 2] = "STYLE";
        SecurityContext[SecurityContext["SCRIPT"] = 3] = "SCRIPT";
        SecurityContext[SecurityContext["URL"] = 4] = "URL";
        SecurityContext[SecurityContext["RESOURCE_URL"] = 5] = "RESOURCE_URL";
    })(exports.SecurityContext || (exports.SecurityContext = {}));
    /**
     * Sanitizer is used by the views to sanitize potentially dangerous values.
     *
     * @stable
     */
    var Sanitizer = (function () {
        function Sanitizer() {
        }
        return Sanitizer;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A wrapper around a native element inside of a View.
     *
     * An `ElementRef` is backed by a render-specific element. In the browser, this is usually a DOM
     * element.
     *
     * @security Permitting direct access to the DOM can make your application more vulnerable to
     * XSS attacks. Carefully review any use of `ElementRef` in your code. For more detail, see the
     * [Security Guide](http://g.co/ng/security).
     *
     * @stable
     */
    // Note: We don't expose things like `Injector`, `ViewContainer`, ... here,
    // i.e. users have to ask for what they need. With that, we can build better analysis tools
    // and could do better codegen in the future.
    var ElementRef = (function () {
        function ElementRef(nativeElement) {
            this.nativeElement = nativeElement;
        }
        return ElementRef;
    }());

    var trace;
    var events;
    function detectWTF() {
        var wtf = global$1['wtf'];
        if (wtf) {
            trace = wtf['trace'];
            if (trace) {
                events = trace['events'];
                return true;
            }
        }
        return false;
    }
    function createScope(signature, flags) {
        if (flags === void 0) { flags = null; }
        return events.createScope(signature, flags);
    }
    function leave(scope, returnValue) {
        trace.leaveScope(scope, returnValue);
        return returnValue;
    }
    function startTimeRange(rangeType, action) {
        return trace.beginTimeRange(rangeType, action);
    }
    function endTimeRange(range) {
        trace.endTimeRange(range);
    }

    /**
     * True if WTF is enabled.
     */
    var wtfEnabled = detectWTF();
    function noopScope(arg0, arg1) {
        return null;
    }
    /**
     * Create trace scope.
     *
     * Scopes must be strictly nested and are analogous to stack frames, but
     * do not have to follow the stack frames. Instead it is recommended that they follow logical
     * nesting. You may want to use
     * [Event
     * Signatures](http://google.github.io/tracing-framework/instrumenting-code.html#custom-events)
     * as they are defined in WTF.
     *
     * Used to mark scope entry. The return value is used to leave the scope.
     *
     *     var myScope = wtfCreateScope('MyClass#myMethod(ascii someVal)');
     *
     *     someMethod() {
     *        var s = myScope('Foo'); // 'Foo' gets stored in tracing UI
     *        // DO SOME WORK HERE
     *        return wtfLeave(s, 123); // Return value 123
     *     }
     *
     * Note, adding try-finally block around the work to ensure that `wtfLeave` gets called can
     * negatively impact the performance of your application. For this reason we recommend that
     * you don't add them to ensure that `wtfLeave` gets called. In production `wtfLeave` is a noop and
     * so try-finally block has no value. When debugging perf issues, skipping `wtfLeave`, do to
     * exception, will produce incorrect trace, but presence of exception signifies logic error which
     * needs to be fixed before the app should be profiled. Add try-finally only when you expect that
     * an exception is expected during normal execution while profiling.
     *
     * @experimental
     */
    var wtfCreateScope = wtfEnabled ? createScope : function (signature, flags) { return noopScope; };
    /**
     * Used to mark end of Scope.
     *
     * - `scope` to end.
     * - `returnValue` (optional) to be passed to the WTF.
     *
     * Returns the `returnValue for easy chaining.
     * @experimental
     */
    var wtfLeave = wtfEnabled ? leave : function (s, r) { return r; };
    /**
     * Used to mark Async start. Async are similar to scope but they don't have to be strictly nested.
     * The return value is used in the call to [endAsync]. Async ranges only work if WTF has been
     * enabled.
     *
     *     someMethod() {
     *        var s = wtfStartTimeRange('HTTP:GET', 'some.url');
     *        var future = new Future.delay(5).then((_) {
     *          wtfEndTimeRange(s);
     *        });
     *     }
     * @experimental
     */
    var wtfStartTimeRange = wtfEnabled ? startTimeRange : function (rangeType, action) { return null; };
    /**
     * Ends a async time range operation.
     * [range] is the return value from [wtfStartTimeRange] Async ranges only work if WTF has been
     * enabled.
     * @experimental
     */
    var wtfEndTimeRange = wtfEnabled ? endTimeRange : function (r) { return null; };

    /**
     * Represents a container where one or more Views can be attached.
     *
     * The container can contain two kinds of Views. Host Views, created by instantiating a
     * {@link Component} via {@link #createComponent}, and Embedded Views, created by instantiating an
     * {@link TemplateRef Embedded Template} via {@link #createEmbeddedView}.
     *
     * The location of the View Container within the containing View is specified by the Anchor
     * `element`. Each View Container can have only one Anchor Element and each Anchor Element can only
     * have a single View Container.
     *
     * Root elements of Views attached to this container become siblings of the Anchor Element in
     * the Rendered View.
     *
     * To access a `ViewContainerRef` of an Element, you can either place a {@link Directive} injected
     * with `ViewContainerRef` on the Element, or you obtain it via a {@link ViewChild} query.
     * @stable
     */
    var ViewContainerRef = (function () {
        function ViewContainerRef() {
        }
        Object.defineProperty(ViewContainerRef.prototype, "element", {
            /**
             * Anchor element that specifies the location of this container in the containing View.
             * <!-- TODO: rename to anchorElement -->
             */
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ViewContainerRef.prototype, "injector", {
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ViewContainerRef.prototype, "parentInjector", {
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ViewContainerRef.prototype, "length", {
            /**
             * Returns the number of Views currently attached to this container.
             */
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        ;
        return ViewContainerRef;
    }());
    var ViewContainerRef_ = (function () {
        function ViewContainerRef_(_element) {
            this._element = _element;
            /** @internal */
            this._createComponentInContainerScope = wtfCreateScope('ViewContainerRef#createComponent()');
            /** @internal */
            this._insertScope = wtfCreateScope('ViewContainerRef#insert()');
            /** @internal */
            this._removeScope = wtfCreateScope('ViewContainerRef#remove()');
            /** @internal */
            this._detachScope = wtfCreateScope('ViewContainerRef#detach()');
        }
        ViewContainerRef_.prototype.get = function (index) { return this._element.nestedViews[index].ref; };
        Object.defineProperty(ViewContainerRef_.prototype, "length", {
            get: function () {
                var views = this._element.nestedViews;
                return isPresent(views) ? views.length : 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ViewContainerRef_.prototype, "element", {
            get: function () { return this._element.elementRef; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ViewContainerRef_.prototype, "injector", {
            get: function () { return this._element.injector; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ViewContainerRef_.prototype, "parentInjector", {
            get: function () { return this._element.parentInjector; },
            enumerable: true,
            configurable: true
        });
        // TODO(rado): profile and decide whether bounds checks should be added
        // to the methods below.
        ViewContainerRef_.prototype.createEmbeddedView = function (templateRef, context, index) {
            if (context === void 0) { context = null; }
            if (index === void 0) { index = -1; }
            var viewRef = templateRef.createEmbeddedView(context);
            this.insert(viewRef, index);
            return viewRef;
        };
        ViewContainerRef_.prototype.createComponent = function (componentFactory, index, injector, projectableNodes) {
            if (index === void 0) { index = -1; }
            if (injector === void 0) { injector = null; }
            if (projectableNodes === void 0) { projectableNodes = null; }
            var s = this._createComponentInContainerScope();
            var contextInjector = injector || this._element.parentInjector;
            var componentRef = componentFactory.create(contextInjector, projectableNodes);
            this.insert(componentRef.hostView, index);
            return wtfLeave(s, componentRef);
        };
        // TODO(i): refactor insert+remove into move
        ViewContainerRef_.prototype.insert = function (viewRef, index) {
            if (index === void 0) { index = -1; }
            var s = this._insertScope();
            if (index == -1)
                index = this.length;
            var viewRef_ = viewRef;
            this._element.attachView(viewRef_.internalView, index);
            return wtfLeave(s, viewRef_);
        };
        ViewContainerRef_.prototype.move = function (viewRef, currentIndex) {
            var s = this._insertScope();
            if (currentIndex == -1)
                return;
            var viewRef_ = viewRef;
            this._element.moveView(viewRef_.internalView, currentIndex);
            return wtfLeave(s, viewRef_);
        };
        ViewContainerRef_.prototype.indexOf = function (viewRef) {
            return ListWrapper.indexOf(this._element.nestedViews, viewRef.internalView);
        };
        // TODO(i): rename to destroy
        ViewContainerRef_.prototype.remove = function (index) {
            if (index === void 0) { index = -1; }
            var s = this._removeScope();
            if (index == -1)
                index = this.length - 1;
            var view = this._element.detachView(index);
            view.destroy();
            // view is intentionally not returned to the client.
            wtfLeave(s);
        };
        // TODO(i): refactor insert+remove into move
        ViewContainerRef_.prototype.detach = function (index) {
            if (index === void 0) { index = -1; }
            var s = this._detachScope();
            if (index == -1)
                index = this.length - 1;
            var view = this._element.detachView(index);
            return wtfLeave(s, view.ref);
        };
        ViewContainerRef_.prototype.clear = function () {
            for (var i = this.length - 1; i >= 0; i--) {
                this.remove(i);
            }
        };
        return ViewContainerRef_;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var ViewType;
    (function (ViewType) {
        // A view that contains the host element with bound component directive.
        // Contains a COMPONENT view
        ViewType[ViewType["HOST"] = 0] = "HOST";
        // The view of the component
        // Can contain 0 to n EMBEDDED views
        ViewType[ViewType["COMPONENT"] = 1] = "COMPONENT";
        // A view that is embedded into another View via a <template> element
        // inside of a COMPONENT view
        ViewType[ViewType["EMBEDDED"] = 2] = "EMBEDDED";
    })(ViewType || (ViewType = {}));

    /**
     * An AppElement is created for elements that have a ViewContainerRef,
     * a nested component or a <template> element to keep data around
     * that is needed for later instantiations.
     */
    var AppElement = (function () {
        function AppElement(index, parentIndex, parentView, nativeElement) {
            this.index = index;
            this.parentIndex = parentIndex;
            this.parentView = parentView;
            this.nativeElement = nativeElement;
            this.nestedViews = null;
            this.componentView = null;
        }
        Object.defineProperty(AppElement.prototype, "elementRef", {
            get: function () { return new ElementRef(this.nativeElement); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AppElement.prototype, "vcRef", {
            get: function () { return new ViewContainerRef_(this); },
            enumerable: true,
            configurable: true
        });
        AppElement.prototype.initComponent = function (component, componentConstructorViewQueries, view) {
            this.component = component;
            this.componentConstructorViewQueries = componentConstructorViewQueries;
            this.componentView = view;
        };
        Object.defineProperty(AppElement.prototype, "parentInjector", {
            get: function () { return this.parentView.injector(this.parentIndex); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AppElement.prototype, "injector", {
            get: function () { return this.parentView.injector(this.index); },
            enumerable: true,
            configurable: true
        });
        AppElement.prototype.mapNestedViews = function (nestedViewClass, callback) {
            var result = [];
            if (isPresent(this.nestedViews)) {
                this.nestedViews.forEach(function (nestedView) {
                    if (nestedView.clazz === nestedViewClass) {
                        result.push(callback(nestedView));
                    }
                });
            }
            return result;
        };
        AppElement.prototype.moveView = function (view, currentIndex) {
            var previousIndex = this.nestedViews.indexOf(view);
            if (view.type === ViewType.COMPONENT) {
                throw new Error("Component views can't be moved!");
            }
            var nestedViews = this.nestedViews;
            if (nestedViews == null) {
                nestedViews = [];
                this.nestedViews = nestedViews;
            }
            ListWrapper.removeAt(nestedViews, previousIndex);
            ListWrapper.insert(nestedViews, currentIndex, view);
            var refRenderNode;
            if (currentIndex > 0) {
                var prevView = nestedViews[currentIndex - 1];
                refRenderNode = prevView.lastRootNode;
            }
            else {
                refRenderNode = this.nativeElement;
            }
            if (isPresent(refRenderNode)) {
                view.renderer.attachViewAfter(refRenderNode, view.flatRootNodes);
            }
            view.markContentChildAsMoved(this);
        };
        AppElement.prototype.attachView = function (view, viewIndex) {
            if (view.type === ViewType.COMPONENT) {
                throw new Error("Component views can't be moved!");
            }
            var nestedViews = this.nestedViews;
            if (nestedViews == null) {
                nestedViews = [];
                this.nestedViews = nestedViews;
            }
            ListWrapper.insert(nestedViews, viewIndex, view);
            var refRenderNode;
            if (viewIndex > 0) {
                var prevView = nestedViews[viewIndex - 1];
                refRenderNode = prevView.lastRootNode;
            }
            else {
                refRenderNode = this.nativeElement;
            }
            if (isPresent(refRenderNode)) {
                view.renderer.attachViewAfter(refRenderNode, view.flatRootNodes);
            }
            view.addToContentChildren(this);
        };
        AppElement.prototype.detachView = function (viewIndex) {
            var view = ListWrapper.removeAt(this.nestedViews, viewIndex);
            if (view.type === ViewType.COMPONENT) {
                throw new Error("Component views can't be moved!");
            }
            view.detach();
            view.removeFromContentChildren(this);
            return view;
        };
        return AppElement;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$6 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    /**
     * An error thrown if application changes model breaking the top-down data flow.
     *
     * This exception is only thrown in dev mode.
     *
     * <!-- TODO: Add a link once the dev mode option is configurable -->
     *
     * ### Example
     *
     * ```typescript
     * @Component({
     *   selector: 'parent',
     *   template: '<child [prop]="parentProp"></child>',
     * })
     * class Parent {
     *   parentProp = 'init';
     * }
     *
     * @Directive({selector: 'child', inputs: ['prop']})
     * class Child {
     *   constructor(public parent: Parent) {}
     *
     *   set prop(v) {
     *     // this updates the parent property, which is disallowed during change detection
     *     // this will result in ExpressionChangedAfterItHasBeenCheckedError
     *     this.parent.parentProp = 'updated';
     *   }
     * }
     * ```
     * @stable
     */
    var ExpressionChangedAfterItHasBeenCheckedError = (function (_super) {
        __extends$6(ExpressionChangedAfterItHasBeenCheckedError, _super);
        function ExpressionChangedAfterItHasBeenCheckedError(oldValue, currValue) {
            var msg = "Expression has changed after it was checked. Previous value: '" + oldValue + "'. Current value: '" + currValue + "'.";
            if (oldValue === UNINITIALIZED) {
                msg +=
                    " It seems like the view has been created after its parent and its children have been dirty checked." +
                        " Has it been created in a change detection hook ?";
            }
            _super.call(this, msg);
        }
        return ExpressionChangedAfterItHasBeenCheckedError;
    }(BaseError));
    /**
     * Thrown when an exception was raised during view creation, change detection or destruction.
     *
     * This error wraps the original exception to attach additional contextual information that can
     * be useful for debugging.
     * @stable
     */
    var ViewWrappedError = (function (_super) {
        __extends$6(ViewWrappedError, _super);
        function ViewWrappedError(originalError, context) {
            _super.call(this, "Error in " + context.source, originalError);
            this.context = context;
        }
        return ViewWrappedError;
    }(WrappedError));
    /**
     * Thrown when a destroyed view is used.
     *
     * This error indicates a bug in the framework.
     *
     * This is an internal Angular error.
     * @stable
     */
    var ViewDestroyedError = (function (_super) {
        __extends$6(ViewDestroyedError, _super);
        function ViewDestroyedError(details) {
            _super.call(this, "Attempt to use a destroyed view: " + details);
        }
        return ViewDestroyedError;
    }(BaseError));

    var ViewUtils = (function () {
        function ViewUtils(_renderer, _appId, sanitizer) {
            this._renderer = _renderer;
            this._appId = _appId;
            this._nextCompTypeId = 0;
            this.sanitizer = sanitizer;
        }
        /**
         * Used by the generated code
         */
        // TODO (matsko): add typing for the animation function
        ViewUtils.prototype.createRenderComponentType = function (templateUrl, slotCount, encapsulation, styles, animations) {
            return new RenderComponentType(this._appId + "-" + this._nextCompTypeId++, templateUrl, slotCount, encapsulation, styles, animations);
        };
        /** @internal */
        ViewUtils.prototype.renderComponent = function (renderComponentType) {
            return this._renderer.renderComponent(renderComponentType);
        };
        ViewUtils.decorators = [
            { type: Injectable },
        ];
        /** @nocollapse */
        ViewUtils.ctorParameters = [
            { type: RootRenderer, },
            { type: undefined, decorators: [{ type: Inject, args: [APP_ID,] },] },
            { type: Sanitizer, },
        ];
        return ViewUtils;
    }());
    function flattenNestedViewRenderNodes(nodes) {
        return _flattenNestedViewRenderNodes(nodes, []);
    }
    function _flattenNestedViewRenderNodes(nodes, renderNodes) {
        for (var i = 0; i < nodes.length; i++) {
            var node = nodes[i];
            if (node instanceof AppElement) {
                var appEl = node;
                renderNodes.push(appEl.nativeElement);
                if (isPresent(appEl.nestedViews)) {
                    for (var k = 0; k < appEl.nestedViews.length; k++) {
                        _flattenNestedViewRenderNodes(appEl.nestedViews[k].rootNodesOrAppElements, renderNodes);
                    }
                }
            }
            else {
                renderNodes.push(node);
            }
        }
        return renderNodes;
    }
    var EMPTY_ARR = [];
    function ensureSlotCount(projectableNodes, expectedSlotCount) {
        var res;
        if (!projectableNodes) {
            res = EMPTY_ARR;
        }
        else if (projectableNodes.length < expectedSlotCount) {
            var givenSlotCount = projectableNodes.length;
            res = new Array(expectedSlotCount);
            for (var i = 0; i < expectedSlotCount; i++) {
                res[i] = (i < givenSlotCount) ? projectableNodes[i] : EMPTY_ARR;
            }
        }
        else {
            res = projectableNodes;
        }
        return res;
    }
    var MAX_INTERPOLATION_VALUES = 9;
    function interpolate(valueCount, c0, a1, c1, a2, c2, a3, c3, a4, c4, a5, c5, a6, c6, a7, c7, a8, c8, a9, c9) {
        switch (valueCount) {
            case 1:
                return c0 + _toStringWithNull(a1) + c1;
            case 2:
                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2;
            case 3:
                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
                    c3;
            case 4:
                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
                    c3 + _toStringWithNull(a4) + c4;
            case 5:
                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
                    c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5;
            case 6:
                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
                    c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) + c6;
            case 7:
                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
                    c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) +
                    c6 + _toStringWithNull(a7) + c7;
            case 8:
                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
                    c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) +
                    c6 + _toStringWithNull(a7) + c7 + _toStringWithNull(a8) + c8;
            case 9:
                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
                    c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) +
                    c6 + _toStringWithNull(a7) + c7 + _toStringWithNull(a8) + c8 + _toStringWithNull(a9) + c9;
            default:
                throw new Error("Does not support more than 9 expressions");
        }
    }
    function _toStringWithNull(v) {
        return v != null ? v.toString() : '';
    }
    function checkBinding(throwOnChange, oldValue, newValue) {
        if (throwOnChange) {
            if (!devModeEqual(oldValue, newValue)) {
                throw new ExpressionChangedAfterItHasBeenCheckedError(oldValue, newValue);
            }
            return false;
        }
        else {
            return !looseIdentical(oldValue, newValue);
        }
    }
    function castByValue(input, value) {
        return input;
    }
    var EMPTY_ARRAY = [];
    var EMPTY_MAP = {};
    function pureProxy1(fn) {
        var result;
        var v0 = UNINITIALIZED;
        return function (p0) {
            if (!looseIdentical(v0, p0)) {
                v0 = p0;
                result = fn(p0);
            }
            return result;
        };
    }
    function pureProxy2(fn) {
        var result;
        var v0 = UNINITIALIZED;
        var v1 = UNINITIALIZED;
        return function (p0, p1) {
            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1)) {
                v0 = p0;
                v1 = p1;
                result = fn(p0, p1);
            }
            return result;
        };
    }
    function pureProxy3(fn) {
        var result;
        var v0 = UNINITIALIZED;
        var v1 = UNINITIALIZED;
        var v2 = UNINITIALIZED;
        return function (p0, p1, p2) {
            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2)) {
                v0 = p0;
                v1 = p1;
                v2 = p2;
                result = fn(p0, p1, p2);
            }
            return result;
        };
    }
    function pureProxy4(fn) {
        var result;
        var v0, v1, v2, v3;
        v0 = v1 = v2 = v3 = UNINITIALIZED;
        return function (p0, p1, p2, p3) {
            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) ||
                !looseIdentical(v3, p3)) {
                v0 = p0;
                v1 = p1;
                v2 = p2;
                v3 = p3;
                result = fn(p0, p1, p2, p3);
            }
            return result;
        };
    }
    function pureProxy5(fn) {
        var result;
        var v0, v1, v2, v3, v4;
        v0 = v1 = v2 = v3 = v4 = UNINITIALIZED;
        return function (p0, p1, p2, p3, p4) {
            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) ||
                !looseIdentical(v3, p3) || !looseIdentical(v4, p4)) {
                v0 = p0;
                v1 = p1;
                v2 = p2;
                v3 = p3;
                v4 = p4;
                result = fn(p0, p1, p2, p3, p4);
            }
            return result;
        };
    }
    function pureProxy6(fn) {
        var result;
        var v0, v1, v2, v3, v4, v5;
        v0 = v1 = v2 = v3 = v4 = v5 = UNINITIALIZED;
        return function (p0, p1, p2, p3, p4, p5) {
            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) ||
                !looseIdentical(v3, p3) || !looseIdentical(v4, p4) || !looseIdentical(v5, p5)) {
                v0 = p0;
                v1 = p1;
                v2 = p2;
                v3 = p3;
                v4 = p4;
                v5 = p5;
                result = fn(p0, p1, p2, p3, p4, p5);
            }
            return result;
        };
    }
    function pureProxy7(fn) {
        var result;
        var v0, v1, v2, v3, v4, v5, v6;
        v0 = v1 = v2 = v3 = v4 = v5 = v6 = UNINITIALIZED;
        return function (p0, p1, p2, p3, p4, p5, p6) {
            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) ||
                !looseIdentical(v3, p3) || !looseIdentical(v4, p4) || !looseIdentical(v5, p5) ||
                !looseIdentical(v6, p6)) {
                v0 = p0;
                v1 = p1;
                v2 = p2;
                v3 = p3;
                v4 = p4;
                v5 = p5;
                v6 = p6;
                result = fn(p0, p1, p2, p3, p4, p5, p6);
            }
            return result;
        };
    }
    function pureProxy8(fn) {
        var result;
        var v0, v1, v2, v3, v4, v5, v6, v7;
        v0 = v1 = v2 = v3 = v4 = v5 = v6 = v7 = UNINITIALIZED;
        return function (p0, p1, p2, p3, p4, p5, p6, p7) {
            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) ||
                !looseIdentical(v3, p3) || !looseIdentical(v4, p4) || !looseIdentical(v5, p5) ||
                !looseIdentical(v6, p6) || !looseIdentical(v7, p7)) {
                v0 = p0;
                v1 = p1;
                v2 = p2;
                v3 = p3;
                v4 = p4;
                v5 = p5;
                v6 = p6;
                v7 = p7;
                result = fn(p0, p1, p2, p3, p4, p5, p6, p7);
            }
            return result;
        };
    }
    function pureProxy9(fn) {
        var result;
        var v0, v1, v2, v3, v4, v5, v6, v7, v8;
        v0 = v1 = v2 = v3 = v4 = v5 = v6 = v7 = v8 = UNINITIALIZED;
        return function (p0, p1, p2, p3, p4, p5, p6, p7, p8) {
            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) ||
                !looseIdentical(v3, p3) || !looseIdentical(v4, p4) || !looseIdentical(v5, p5) ||
                !looseIdentical(v6, p6) || !looseIdentical(v7, p7) || !looseIdentical(v8, p8)) {
                v0 = p0;
                v1 = p1;
                v2 = p2;
                v3 = p3;
                v4 = p4;
                v5 = p5;
                v6 = p6;
                v7 = p7;
                v8 = p8;
                result = fn(p0, p1, p2, p3, p4, p5, p6, p7, p8);
            }
            return result;
        };
    }
    function pureProxy10(fn) {
        var result;
        var v0, v1, v2, v3, v4, v5, v6, v7, v8, v9;
        v0 = v1 = v2 = v3 = v4 = v5 = v6 = v7 = v8 = v9 = UNINITIALIZED;
        return function (p0, p1, p2, p3, p4, p5, p6, p7, p8, p9) {
            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) ||
                !looseIdentical(v3, p3) || !looseIdentical(v4, p4) || !looseIdentical(v5, p5) ||
                !looseIdentical(v6, p6) || !looseIdentical(v7, p7) || !looseIdentical(v8, p8) ||
                !looseIdentical(v9, p9)) {
                v0 = p0;
                v1 = p1;
                v2 = p2;
                v3 = p3;
                v4 = p4;
                v5 = p5;
                v6 = p6;
                v7 = p7;
                v8 = p8;
                v9 = p9;
                result = fn(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
            }
            return result;
        };
    }
    function setBindingDebugInfoForChanges(renderer, el, changes) {
        Object.keys(changes).forEach(function (propName) {
            setBindingDebugInfo(renderer, el, propName, changes[propName].currentValue);
        });
    }
    function setBindingDebugInfo(renderer, el, propName, value) {
        try {
            renderer.setBindingDebugInfo(el, "ng-reflect-" + camelCaseToDashCase(propName), value ? value.toString() : null);
        }
        catch (e) {
            renderer.setBindingDebugInfo(el, "ng-reflect-" + camelCaseToDashCase(propName), '[ERROR] Exception while trying to serialize the value');
        }
    }
    var CAMEL_CASE_REGEXP = /([A-Z])/g;
    function camelCaseToDashCase(input) {
        return input.replace(CAMEL_CASE_REGEXP, function () {
            var m = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                m[_i - 0] = arguments[_i];
            }
            return '-' + m[1].toLowerCase();
        });
    }


    var view_utils = Object.freeze({
        ViewUtils: ViewUtils,
        flattenNestedViewRenderNodes: flattenNestedViewRenderNodes,
        ensureSlotCount: ensureSlotCount,
        MAX_INTERPOLATION_VALUES: MAX_INTERPOLATION_VALUES,
        interpolate: interpolate,
        checkBinding: checkBinding,
        castByValue: castByValue,
        EMPTY_ARRAY: EMPTY_ARRAY,
        EMPTY_MAP: EMPTY_MAP,
        pureProxy1: pureProxy1,
        pureProxy2: pureProxy2,
        pureProxy3: pureProxy3,
        pureProxy4: pureProxy4,
        pureProxy5: pureProxy5,
        pureProxy6: pureProxy6,
        pureProxy7: pureProxy7,
        pureProxy8: pureProxy8,
        pureProxy9: pureProxy9,
        pureProxy10: pureProxy10,
        setBindingDebugInfoForChanges: setBindingDebugInfoForChanges,
        setBindingDebugInfo: setBindingDebugInfo
    });

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$5 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    /**
     * Represents an instance of a Component created via a {@link ComponentFactory}.
     *
     * `ComponentRef` provides access to the Component Instance as well other objects related to this
     * Component Instance and allows you to destroy the Component Instance via the {@link #destroy}
     * method.
     * @stable
     */
    var ComponentRef = (function () {
        function ComponentRef() {
        }
        Object.defineProperty(ComponentRef.prototype, "location", {
            /**
             * Location of the Host Element of this Component Instance.
             */
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ComponentRef.prototype, "injector", {
            /**
             * The injector on which the component instance exists.
             */
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ComponentRef.prototype, "instance", {
            /**
             * The instance of the Component.
             */
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        ;
        Object.defineProperty(ComponentRef.prototype, "hostView", {
            /**
             * The {@link ViewRef} of the Host View of this Component instance.
             */
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        ;
        Object.defineProperty(ComponentRef.prototype, "changeDetectorRef", {
            /**
             * The {@link ChangeDetectorRef} of the Component instance.
             */
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ComponentRef.prototype, "componentType", {
            /**
             * The component type.
             */
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        return ComponentRef;
    }());
    var ComponentRef_ = (function (_super) {
        __extends$5(ComponentRef_, _super);
        function ComponentRef_(_hostElement, _componentType) {
            _super.call(this);
            this._hostElement = _hostElement;
            this._componentType = _componentType;
        }
        Object.defineProperty(ComponentRef_.prototype, "location", {
            get: function () { return this._hostElement.elementRef; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ComponentRef_.prototype, "injector", {
            get: function () { return this._hostElement.injector; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ComponentRef_.prototype, "instance", {
            get: function () { return this._hostElement.component; },
            enumerable: true,
            configurable: true
        });
        ;
        Object.defineProperty(ComponentRef_.prototype, "hostView", {
            get: function () { return this._hostElement.parentView.ref; },
            enumerable: true,
            configurable: true
        });
        ;
        Object.defineProperty(ComponentRef_.prototype, "changeDetectorRef", {
            get: function () { return this._hostElement.parentView.ref; },
            enumerable: true,
            configurable: true
        });
        ;
        Object.defineProperty(ComponentRef_.prototype, "componentType", {
            get: function () { return this._componentType; },
            enumerable: true,
            configurable: true
        });
        ComponentRef_.prototype.destroy = function () { this._hostElement.parentView.destroy(); };
        ComponentRef_.prototype.onDestroy = function (callback) { this.hostView.onDestroy(callback); };
        return ComponentRef_;
    }(ComponentRef));
    /**
     * @experimental
     */
    var EMPTY_CONTEXT = new Object();
    /**
     * @stable
     */
    var ComponentFactory = (function () {
        function ComponentFactory(selector, _viewFactory, _componentType) {
            this.selector = selector;
            this._viewFactory = _viewFactory;
            this._componentType = _componentType;
        }
        Object.defineProperty(ComponentFactory.prototype, "componentType", {
            get: function () { return this._componentType; },
            enumerable: true,
            configurable: true
        });
        /**
         * Creates a new component.
         */
        ComponentFactory.prototype.create = function (injector, projectableNodes, rootSelectorOrNode) {
            if (projectableNodes === void 0) { projectableNodes = null; }
            if (rootSelectorOrNode === void 0) { rootSelectorOrNode = null; }
            var vu = injector.get(ViewUtils);
            if (!projectableNodes) {
                projectableNodes = [];
            }
            // Note: Host views don't need a declarationAppElement!
            var hostView = this._viewFactory(vu, injector, null);
            var hostElement = hostView.create(EMPTY_CONTEXT, projectableNodes, rootSelectorOrNode);
            return new ComponentRef_(hostElement, this._componentType);
        };
        return ComponentFactory;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$7 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    /**
     * @stable
     */
    var NoComponentFactoryError = (function (_super) {
        __extends$7(NoComponentFactoryError, _super);
        function NoComponentFactoryError(component) {
            _super.call(this, "No component factory found for " + stringify(component));
            this.component = component;
        }
        return NoComponentFactoryError;
    }(BaseError));
    var _NullComponentFactoryResolver = (function () {
        function _NullComponentFactoryResolver() {
        }
        _NullComponentFactoryResolver.prototype.resolveComponentFactory = function (component) {
            throw new NoComponentFactoryError(component);
        };
        return _NullComponentFactoryResolver;
    }());
    /**
     * @stable
     */
    var ComponentFactoryResolver = (function () {
        function ComponentFactoryResolver() {
        }
        ComponentFactoryResolver.NULL = new _NullComponentFactoryResolver();
        return ComponentFactoryResolver;
    }());
    var CodegenComponentFactoryResolver = (function () {
        function CodegenComponentFactoryResolver(factories, _parent) {
            this._parent = _parent;
            this._factories = new Map();
            for (var i = 0; i < factories.length; i++) {
                var factory = factories[i];
                this._factories.set(factory.componentType, factory);
            }
        }
        CodegenComponentFactoryResolver.prototype.resolveComponentFactory = function (component) {
            var result = this._factories.get(component);
            if (!result) {
                result = this._parent.resolveComponentFactory(component);
            }
            return result;
        };
        return CodegenComponentFactoryResolver;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$8 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    /**
     * Use by directives and components to emit custom Events.
     *
     * ### Examples
     *
     * In the following example, `Zippy` alternatively emits `open` and `close` events when its
     * title gets clicked:
     *
     * ```
     * @Component({
     *   selector: 'zippy',
     *   template: `
     *   <div class="zippy">
     *     <div (click)="toggle()">Toggle</div>
     *     <div [hidden]="!visible">
     *       <ng-content></ng-content>
     *     </div>
     *  </div>`})
     * export class Zippy {
     *   visible: boolean = true;
     *   @Output() open: EventEmitter<any> = new EventEmitter();
     *   @Output() close: EventEmitter<any> = new EventEmitter();
     *
     *   toggle() {
     *     this.visible = !this.visible;
     *     if (this.visible) {
     *       this.open.emit(null);
     *     } else {
     *       this.close.emit(null);
     *     }
     *   }
     * }
     * ```
     *
     * The events payload can be accessed by the parameter `$event` on the components output event
     * handler:
     *
     * ```
     * <zippy (open)="onOpen($event)" (close)="onClose($event)"></zippy>
     * ```
     *
     * Uses Rx.Observable but provides an adapter to make it work as specified here:
     * https://github.com/jhusain/observable-spec
     *
     * Once a reference implementation of the spec is available, switch to it.
     * @stable
     */
    var EventEmitter = (function (_super) {
        __extends$8(EventEmitter, _super);
        /**
         * Creates an instance of [EventEmitter], which depending on [isAsync],
         * delivers events synchronously or asynchronously.
         */
        function EventEmitter(isAsync) {
            if (isAsync === void 0) { isAsync = false; }
            _super.call(this);
            this.__isAsync = isAsync;
        }
        EventEmitter.prototype.emit = function (value) { _super.prototype.next.call(this, value); };
        EventEmitter.prototype.subscribe = function (generatorOrNext, error, complete) {
            var schedulerFn;
            var errorFn = function (err) { return null; };
            var completeFn = function () { return null; };
            if (generatorOrNext && typeof generatorOrNext === 'object') {
                schedulerFn = this.__isAsync ? function (value) {
                    setTimeout(function () { return generatorOrNext.next(value); });
                } : function (value) { generatorOrNext.next(value); };
                if (generatorOrNext.error) {
                    errorFn = this.__isAsync ? function (err) { setTimeout(function () { return generatorOrNext.error(err); }); } :
                        function (err) { generatorOrNext.error(err); };
                }
                if (generatorOrNext.complete) {
                    completeFn = this.__isAsync ? function () { setTimeout(function () { return generatorOrNext.complete(); }); } :
                        function () { generatorOrNext.complete(); };
                }
            }
            else {
                schedulerFn = this.__isAsync ? function (value) { setTimeout(function () { return generatorOrNext(value); }); } :
                    function (value) { generatorOrNext(value); };
                if (error) {
                    errorFn =
                        this.__isAsync ? function (err) { setTimeout(function () { return error(err); }); } : function (err) { error(err); };
                }
                if (complete) {
                    completeFn =
                        this.__isAsync ? function () { setTimeout(function () { return complete(); }); } : function () { complete(); };
                }
            }
            return _super.prototype.subscribe.call(this, schedulerFn, errorFn, completeFn);
        };
        return EventEmitter;
    }(rxjs_Subject.Subject));

    /**
     * An injectable service for executing work inside or outside of the Angular zone.
     *
     * The most common use of this service is to optimize performance when starting a work consisting of
     * one or more asynchronous tasks that don't require UI updates or error handling to be handled by
     * Angular. Such tasks can be kicked off via {@link runOutsideAngular} and if needed, these tasks
     * can reenter the Angular zone via {@link run}.
     *
     * <!-- TODO: add/fix links to:
     *   - docs explaining zones and the use of zones in Angular and change-detection
     *   - link to runOutsideAngular/run (throughout this file!)
     *   -->
     *
     * ### Example
     * ```
     * import {Component, NgZone} from '@angular/core';
     * import {NgIf} from '@angular/common';
     *
     * @Component({
     *   selector: 'ng-zone-demo'.
     *   template: `
     *     <h2>Demo: NgZone</h2>
     *
     *     <p>Progress: {{progress}}%</p>
     *     <p *ngIf="progress >= 100">Done processing {{label}} of Angular zone!</p>
     *
     *     <button (click)="processWithinAngularZone()">Process within Angular zone</button>
     *     <button (click)="processOutsideOfAngularZone()">Process outside of Angular zone</button>
     *   `,
     * })
     * export class NgZoneDemo {
     *   progress: number = 0;
     *   label: string;
     *
     *   constructor(private _ngZone: NgZone) {}
     *
     *   // Loop inside the Angular zone
     *   // so the UI DOES refresh after each setTimeout cycle
     *   processWithinAngularZone() {
     *     this.label = 'inside';
     *     this.progress = 0;
     *     this._increaseProgress(() => console.log('Inside Done!'));
     *   }
     *
     *   // Loop outside of the Angular zone
     *   // so the UI DOES NOT refresh after each setTimeout cycle
     *   processOutsideOfAngularZone() {
     *     this.label = 'outside';
     *     this.progress = 0;
     *     this._ngZone.runOutsideAngular(() => {
     *       this._increaseProgress(() => {
     *       // reenter the Angular zone and display done
     *       this._ngZone.run(() => {console.log('Outside Done!') });
     *     }}));
     *   }
     *
     *   _increaseProgress(doneCallback: () => void) {
     *     this.progress += 1;
     *     console.log(`Current progress: ${this.progress}%`);
     *
     *     if (this.progress < 100) {
     *       window.setTimeout(() => this._increaseProgress(doneCallback)), 10)
     *     } else {
     *       doneCallback();
     *     }
     *   }
     * }
     * ```
     * @experimental
     */
    var NgZone = (function () {
        function NgZone(_a) {
            var _b = _a.enableLongStackTrace, enableLongStackTrace = _b === void 0 ? false : _b;
            this._hasPendingMicrotasks = false;
            this._hasPendingMacrotasks = false;
            this._isStable = true;
            this._nesting = 0;
            this._onUnstable = new EventEmitter(false);
            this._onMicrotaskEmpty = new EventEmitter(false);
            this._onStable = new EventEmitter(false);
            this._onErrorEvents = new EventEmitter(false);
            if (typeof Zone == 'undefined') {
                throw new Error('Angular requires Zone.js prolyfill.');
            }
            Zone.assertZonePatched();
            this.outer = this.inner = Zone.current;
            if (Zone['wtfZoneSpec']) {
                this.inner = this.inner.fork(Zone['wtfZoneSpec']);
            }
            if (enableLongStackTrace && Zone['longStackTraceZoneSpec']) {
                this.inner = this.inner.fork(Zone['longStackTraceZoneSpec']);
            }
            this.forkInnerZoneWithAngularBehavior();
        }
        NgZone.isInAngularZone = function () { return Zone.current.get('isAngularZone') === true; };
        NgZone.assertInAngularZone = function () {
            if (!NgZone.isInAngularZone()) {
                throw new Error('Expected to be in Angular Zone, but it is not!');
            }
        };
        NgZone.assertNotInAngularZone = function () {
            if (NgZone.isInAngularZone()) {
                throw new Error('Expected to not be in Angular Zone, but it is!');
            }
        };
        /**
         * Executes the `fn` function synchronously within the Angular zone and returns value returned by
         * the function.
         *
         * Running functions via `run` allows you to reenter Angular zone from a task that was executed
         * outside of the Angular zone (typically started via {@link runOutsideAngular}).
         *
         * Any future tasks or microtasks scheduled from within this function will continue executing from
         * within the Angular zone.
         *
         * If a synchronous error happens it will be rethrown and not reported via `onError`.
         */
        NgZone.prototype.run = function (fn) { return this.inner.run(fn); };
        /**
         * Same as `run`, except that synchronous errors are caught and forwarded via `onError` and not
         * rethrown.
         */
        NgZone.prototype.runGuarded = function (fn) { return this.inner.runGuarded(fn); };
        /**
         * Executes the `fn` function synchronously in Angular's parent zone and returns value returned by
         * the function.
         *
         * Running functions via `runOutsideAngular` allows you to escape Angular's zone and do work that
         * doesn't trigger Angular change-detection or is subject to Angular's error handling.
         *
         * Any future tasks or microtasks scheduled from within this function will continue executing from
         * outside of the Angular zone.
         *
         * Use {@link run} to reenter the Angular zone and do work that updates the application model.
         */
        NgZone.prototype.runOutsideAngular = function (fn) { return this.outer.run(fn); };
        Object.defineProperty(NgZone.prototype, "onUnstable", {
            /**
             * Notifies when code enters Angular Zone. This gets fired first on VM Turn.
             */
            get: function () { return this._onUnstable; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgZone.prototype, "onMicrotaskEmpty", {
            /**
             * Notifies when there is no more microtasks enqueue in the current VM Turn.
             * This is a hint for Angular to do change detection, which may enqueue more microtasks.
             * For this reason this event can fire multiple times per VM Turn.
             */
            get: function () { return this._onMicrotaskEmpty; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgZone.prototype, "onStable", {
            /**
             * Notifies when the last `onMicrotaskEmpty` has run and there are no more microtasks, which
             * implies we are about to relinquish VM turn.
             * This event gets called just once.
             */
            get: function () { return this._onStable; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgZone.prototype, "onError", {
            /**
             * Notify that an error has been delivered.
             */
            get: function () { return this._onErrorEvents; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgZone.prototype, "isStable", {
            /**
             * Whether there are no outstanding microtasks or macrotasks.
             */
            get: function () { return this._isStable; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgZone.prototype, "hasPendingMicrotasks", {
            get: function () { return this._hasPendingMicrotasks; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgZone.prototype, "hasPendingMacrotasks", {
            get: function () { return this._hasPendingMacrotasks; },
            enumerable: true,
            configurable: true
        });
        NgZone.prototype.checkStable = function () {
            var _this = this;
            if (this._nesting == 0 && !this._hasPendingMicrotasks && !this._isStable) {
                try {
                    this._nesting++;
                    this._onMicrotaskEmpty.emit(null);
                }
                finally {
                    this._nesting--;
                    if (!this._hasPendingMicrotasks) {
                        try {
                            this.runOutsideAngular(function () { return _this._onStable.emit(null); });
                        }
                        finally {
                            this._isStable = true;
                        }
                    }
                }
            }
        };
        NgZone.prototype.forkInnerZoneWithAngularBehavior = function () {
            var _this = this;
            this.inner = this.inner.fork({
                name: 'angular',
                properties: { 'isAngularZone': true },
                onInvokeTask: function (delegate, current, target, task, applyThis, applyArgs) {
                    try {
                        _this.onEnter();
                        return delegate.invokeTask(target, task, applyThis, applyArgs);
                    }
                    finally {
                        _this.onLeave();
                    }
                },
                onInvoke: function (delegate, current, target, callback, applyThis, applyArgs, source) {
                    try {
                        _this.onEnter();
                        return delegate.invoke(target, callback, applyThis, applyArgs, source);
                    }
                    finally {
                        _this.onLeave();
                    }
                },
                onHasTask: function (delegate, current, target, hasTaskState) {
                    delegate.hasTask(target, hasTaskState);
                    if (current === target) {
                        // We are only interested in hasTask events which originate from our zone
                        // (A child hasTask event is not interesting to us)
                        if (hasTaskState.change == 'microTask') {
                            _this.setHasMicrotask(hasTaskState.microTask);
                        }
                        else if (hasTaskState.change == 'macroTask') {
                            _this.setHasMacrotask(hasTaskState.macroTask);
                        }
                    }
                },
                onHandleError: function (delegate, current, target, error) {
                    delegate.handleError(target, error);
                    _this.triggerError(error);
                    return false;
                }
            });
        };
        NgZone.prototype.onEnter = function () {
            this._nesting++;
            if (this._isStable) {
                this._isStable = false;
                this._onUnstable.emit(null);
            }
        };
        NgZone.prototype.onLeave = function () {
            this._nesting--;
            this.checkStable();
        };
        NgZone.prototype.setHasMicrotask = function (hasMicrotasks) {
            this._hasPendingMicrotasks = hasMicrotasks;
            this.checkStable();
        };
        NgZone.prototype.setHasMacrotask = function (hasMacrotasks) { this._hasPendingMacrotasks = hasMacrotasks; };
        NgZone.prototype.triggerError = function (error) { this._onErrorEvents.emit(error); };
        return NgZone;
    }());

    /**
     * The Testability service provides testing hooks that can be accessed from
     * the browser and by services such as Protractor. Each bootstrapped Angular
     * application on the page will have an instance of Testability.
     * @experimental
     */
    var Testability = (function () {
        function Testability(_ngZone) {
            this._ngZone = _ngZone;
            /** @internal */
            this._pendingCount = 0;
            /** @internal */
            this._isZoneStable = true;
            /**
             * Whether any work was done since the last 'whenStable' callback. This is
             * useful to detect if this could have potentially destabilized another
             * component while it is stabilizing.
             * @internal
             */
            this._didWork = false;
            /** @internal */
            this._callbacks = [];
            this._watchAngularEvents();
        }
        /** @internal */
        Testability.prototype._watchAngularEvents = function () {
            var _this = this;
            this._ngZone.onUnstable.subscribe({
                next: function () {
                    _this._didWork = true;
                    _this._isZoneStable = false;
                }
            });
            this._ngZone.runOutsideAngular(function () {
                _this._ngZone.onStable.subscribe({
                    next: function () {
                        NgZone.assertNotInAngularZone();
                        scheduleMicroTask(function () {
                            _this._isZoneStable = true;
                            _this._runCallbacksIfReady();
                        });
                    }
                });
            });
        };
        Testability.prototype.increasePendingRequestCount = function () {
            this._pendingCount += 1;
            this._didWork = true;
            return this._pendingCount;
        };
        Testability.prototype.decreasePendingRequestCount = function () {
            this._pendingCount -= 1;
            if (this._pendingCount < 0) {
                throw new Error('pending async requests below zero');
            }
            this._runCallbacksIfReady();
            return this._pendingCount;
        };
        Testability.prototype.isStable = function () {
            return this._isZoneStable && this._pendingCount == 0 && !this._ngZone.hasPendingMacrotasks;
        };
        /** @internal */
        Testability.prototype._runCallbacksIfReady = function () {
            var _this = this;
            if (this.isStable()) {
                // Schedules the call backs in a new frame so that it is always async.
                scheduleMicroTask(function () {
                    while (_this._callbacks.length !== 0) {
                        (_this._callbacks.pop())(_this._didWork);
                    }
                    _this._didWork = false;
                });
            }
            else {
                // Not Ready
                this._didWork = true;
            }
        };
        Testability.prototype.whenStable = function (callback) {
            this._callbacks.push(callback);
            this._runCallbacksIfReady();
        };
        Testability.prototype.getPendingRequestCount = function () { return this._pendingCount; };
        /** @deprecated use findProviders */
        Testability.prototype.findBindings = function (using, provider, exactMatch) {
            // TODO(juliemr): implement.
            return [];
        };
        Testability.prototype.findProviders = function (using, provider, exactMatch) {
            // TODO(juliemr): implement.
            return [];
        };
        Testability.decorators = [
            { type: Injectable },
        ];
        /** @nocollapse */
        Testability.ctorParameters = [
            { type: NgZone, },
        ];
        return Testability;
    }());
    /**
     * A global registry of {@link Testability} instances for specific elements.
     * @experimental
     */
    var TestabilityRegistry = (function () {
        function TestabilityRegistry() {
            /** @internal */
            this._applications = new Map();
            _testabilityGetter.addToWindow(this);
        }
        TestabilityRegistry.prototype.registerApplication = function (token, testability) {
            this._applications.set(token, testability);
        };
        TestabilityRegistry.prototype.getTestability = function (elem) { return this._applications.get(elem); };
        TestabilityRegistry.prototype.getAllTestabilities = function () { return MapWrapper.values(this._applications); };
        TestabilityRegistry.prototype.getAllRootElements = function () { return MapWrapper.keys(this._applications); };
        TestabilityRegistry.prototype.findTestabilityInTree = function (elem, findInAncestors) {
            if (findInAncestors === void 0) { findInAncestors = true; }
            return _testabilityGetter.findTestabilityInTree(this, elem, findInAncestors);
        };
        TestabilityRegistry.decorators = [
            { type: Injectable },
        ];
        /** @nocollapse */
        TestabilityRegistry.ctorParameters = [];
        return TestabilityRegistry;
    }());
    var _NoopGetTestability = (function () {
        function _NoopGetTestability() {
        }
        _NoopGetTestability.prototype.addToWindow = function (registry) { };
        _NoopGetTestability.prototype.findTestabilityInTree = function (registry, elem, findInAncestors) {
            return null;
        };
        return _NoopGetTestability;
    }());
    /**
     * Set the {@link GetTestability} implementation used by the Angular testing framework.
     * @experimental
     */
    function setTestabilityGetter(getter) {
        _testabilityGetter = getter;
    }
    var _testabilityGetter = new _NoopGetTestability();

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$3 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var _devMode = true;
    var _runModeLocked = false;
    var _platform;
    /**
     * Disable Angular's development mode, which turns off assertions and other
     * checks within the framework.
     *
     * One important assertion this disables verifies that a change detection pass
     * does not result in additional changes to any bindings (also known as
     * unidirectional data flow).
     *
     * @stable
     */
    function enableProdMode() {
        if (_runModeLocked) {
            throw new Error('Cannot enable prod mode after platform setup.');
        }
        _devMode = false;
    }
    /**
     * Returns whether Angular is in development mode. After called once,
     * the value is locked and won't change any more.
     *
     * By default, this is true, unless a user calls `enableProdMode` before calling this.
     *
     * @experimental APIs related to application bootstrap are currently under review.
     */
    function isDevMode() {
        _runModeLocked = true;
        return _devMode;
    }
    /**
     * Creates a platform.
     * Platforms have to be eagerly created via this function.
     *
     * @experimental APIs related to application bootstrap are currently under review.
     */
    function createPlatform(injector) {
        if (_platform && !_platform.destroyed) {
            throw new Error('There can be only one platform. Destroy the previous one to create a new one.');
        }
        _platform = injector.get(PlatformRef);
        var inits = injector.get(PLATFORM_INITIALIZER, null);
        if (inits)
            inits.forEach(function (init) { return init(); });
        return _platform;
    }
    /**
     * Creates a factory for a platform
     *
     * @experimental APIs related to application bootstrap are currently under review.
     */
    function createPlatformFactory(parentPlaformFactory, name, providers) {
        if (providers === void 0) { providers = []; }
        var marker = new OpaqueToken("Platform: " + name);
        return function (extraProviders) {
            if (extraProviders === void 0) { extraProviders = []; }
            if (!getPlatform()) {
                if (parentPlaformFactory) {
                    parentPlaformFactory(providers.concat(extraProviders).concat({ provide: marker, useValue: true }));
                }
                else {
                    createPlatform(ReflectiveInjector.resolveAndCreate(providers.concat(extraProviders).concat({ provide: marker, useValue: true })));
                }
            }
            return assertPlatform(marker);
        };
    }
    /**
     * Checks that there currently is a platform
     * which contains the given token as a provider.
     *
     * @experimental APIs related to application bootstrap are currently under review.
     */
    function assertPlatform(requiredToken) {
        var platform = getPlatform();
        if (!platform) {
            throw new Error('No platform exists!');
        }
        if (!platform.injector.get(requiredToken, null)) {
            throw new Error('A platform with a different configuration has been created. Please destroy it first.');
        }
        return platform;
    }
    /**
     * Destroy the existing platform.
     *
     * @experimental APIs related to application bootstrap are currently under review.
     */
    function destroyPlatform() {
        if (_platform && !_platform.destroyed) {
            _platform.destroy();
        }
    }
    /**
     * Returns the current platform.
     *
     * @experimental APIs related to application bootstrap are currently under review.
     */
    function getPlatform() {
        return _platform && !_platform.destroyed ? _platform : null;
    }
    /**
     * The Angular platform is the entry point for Angular on a web page. Each page
     * has exactly one platform, and services (such as reflection) which are common
     * to every Angular application running on the page are bound in its scope.
     *
     * A page's platform is initialized implicitly when {@link bootstrap}() is called, or
     * explicitly by calling {@link createPlatform}().
     *
     * @stable
     */
    var PlatformRef = (function () {
        function PlatformRef() {
        }
        /**
         * Creates an instance of an `@NgModule` for the given platform
         * for offline compilation.
         *
         * ## Simple Example
         *
         * ```typescript
         * my_module.ts:
         *
         * @NgModule({
         *   imports: [BrowserModule]
         * })
         * class MyModule {}
         *
         * main.ts:
         * import {MyModuleNgFactory} from './my_module.ngfactory';
         * import {platformBrowser} from '@angular/platform-browser';
         *
         * let moduleRef = platformBrowser().bootstrapModuleFactory(MyModuleNgFactory);
         * ```
         *
         * @experimental APIs related to application bootstrap are currently under review.
         */
        PlatformRef.prototype.bootstrapModuleFactory = function (moduleFactory) {
            throw unimplemented();
        };
        /**
         * Creates an instance of an `@NgModule` for a given platform using the given runtime compiler.
         *
         * ## Simple Example
         *
         * ```typescript
         * @NgModule({
         *   imports: [BrowserModule]
         * })
         * class MyModule {}
         *
         * let moduleRef = platformBrowser().bootstrapModule(MyModule);
         * ```
         * @stable
         */
        PlatformRef.prototype.bootstrapModule = function (moduleType, compilerOptions) {
            if (compilerOptions === void 0) { compilerOptions = []; }
            throw unimplemented();
        };
        Object.defineProperty(PlatformRef.prototype, "injector", {
            /**
             * Retrieve the platform {@link Injector}, which is the parent injector for
             * every Angular application on the page and provides singleton providers.
             */
            get: function () { throw unimplemented(); },
            enumerable: true,
            configurable: true
        });
        ;
        Object.defineProperty(PlatformRef.prototype, "destroyed", {
            get: function () { throw unimplemented(); },
            enumerable: true,
            configurable: true
        });
        return PlatformRef;
    }());
    function _callAndReportToErrorHandler(errorHandler, callback) {
        try {
            var result = callback();
            if (isPromise(result)) {
                return result.catch(function (e) {
                    errorHandler.handleError(e);
                    // rethrow as the exception handler might not do it
                    throw e;
                });
            }
            return result;
        }
        catch (e) {
            errorHandler.handleError(e);
            // rethrow as the exception handler might not do it
            throw e;
        }
    }
    var PlatformRef_ = (function (_super) {
        __extends$3(PlatformRef_, _super);
        function PlatformRef_(_injector) {
            _super.call(this);
            this._injector = _injector;
            this._modules = [];
            this._destroyListeners = [];
            this._destroyed = false;
        }
        PlatformRef_.prototype.onDestroy = function (callback) { this._destroyListeners.push(callback); };
        Object.defineProperty(PlatformRef_.prototype, "injector", {
            get: function () { return this._injector; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PlatformRef_.prototype, "destroyed", {
            get: function () { return this._destroyed; },
            enumerable: true,
            configurable: true
        });
        PlatformRef_.prototype.destroy = function () {
            if (this._destroyed) {
                throw new Error('The platform has already been destroyed!');
            }
            this._modules.slice().forEach(function (module) { return module.destroy(); });
            this._destroyListeners.forEach(function (listener) { return listener(); });
            this._destroyed = true;
        };
        PlatformRef_.prototype.bootstrapModuleFactory = function (moduleFactory) {
            return this._bootstrapModuleFactoryWithZone(moduleFactory, null);
        };
        PlatformRef_.prototype._bootstrapModuleFactoryWithZone = function (moduleFactory, ngZone) {
            var _this = this;
            // Note: We need to create the NgZone _before_ we instantiate the module,
            // as instantiating the module creates some providers eagerly.
            // So we create a mini parent injector that just contains the new NgZone and
            // pass that as parent to the NgModuleFactory.
            if (!ngZone)
                ngZone = new NgZone({ enableLongStackTrace: isDevMode() });
            // Attention: Don't use ApplicationRef.run here,
            // as we want to be sure that all possible constructor calls are inside `ngZone.run`!
            return ngZone.run(function () {
                var ngZoneInjector = ReflectiveInjector.resolveAndCreate([{ provide: NgZone, useValue: ngZone }], _this.injector);
                var moduleRef = moduleFactory.create(ngZoneInjector);
                var exceptionHandler = moduleRef.injector.get(ErrorHandler, null);
                if (!exceptionHandler) {
                    throw new Error('No ErrorHandler. Is platform module (BrowserModule) included?');
                }
                moduleRef.onDestroy(function () { return ListWrapper.remove(_this._modules, moduleRef); });
                ngZone.onError.subscribe({ next: function (error) { exceptionHandler.handleError(error); } });
                return _callAndReportToErrorHandler(exceptionHandler, function () {
                    var initStatus = moduleRef.injector.get(ApplicationInitStatus);
                    return initStatus.donePromise.then(function () {
                        _this._moduleDoBootstrap(moduleRef);
                        return moduleRef;
                    });
                });
            });
        };
        PlatformRef_.prototype.bootstrapModule = function (moduleType, compilerOptions) {
            if (compilerOptions === void 0) { compilerOptions = []; }
            return this._bootstrapModuleWithZone(moduleType, compilerOptions, null);
        };
        PlatformRef_.prototype._bootstrapModuleWithZone = function (moduleType, compilerOptions, ngZone, componentFactoryCallback) {
            var _this = this;
            if (compilerOptions === void 0) { compilerOptions = []; }
            var compilerFactory = this.injector.get(CompilerFactory);
            var compiler = compilerFactory.createCompiler(Array.isArray(compilerOptions) ? compilerOptions : [compilerOptions]);
            // ugly internal api hack: generate host component factories for all declared components and
            // pass the factories into the callback - this is used by UpdateAdapter to get hold of all
            // factories.
            if (componentFactoryCallback) {
                return compiler.compileModuleAndAllComponentsAsync(moduleType)
                    .then(function (_a) {
                    var ngModuleFactory = _a.ngModuleFactory, componentFactories = _a.componentFactories;
                    componentFactoryCallback(componentFactories);
                    return _this._bootstrapModuleFactoryWithZone(ngModuleFactory, ngZone);
                });
            }
            return compiler.compileModuleAsync(moduleType)
                .then(function (moduleFactory) { return _this._bootstrapModuleFactoryWithZone(moduleFactory, ngZone); });
        };
        PlatformRef_.prototype._moduleDoBootstrap = function (moduleRef) {
            var appRef = moduleRef.injector.get(ApplicationRef);
            if (moduleRef.bootstrapFactories.length > 0) {
                moduleRef.bootstrapFactories.forEach(function (compFactory) { return appRef.bootstrap(compFactory); });
            }
            else if (moduleRef.instance.ngDoBootstrap) {
                moduleRef.instance.ngDoBootstrap(appRef);
            }
            else {
                throw new Error(("The module " + stringify(moduleRef.instance.constructor) + " was bootstrapped, but it does not declare \"@NgModule.bootstrap\" components nor a \"ngDoBootstrap\" method. ") +
                    "Please define one of these.");
            }
        };
        PlatformRef_.decorators = [
            { type: Injectable },
        ];
        /** @nocollapse */
        PlatformRef_.ctorParameters = [
            { type: Injector, },
        ];
        return PlatformRef_;
    }(PlatformRef));
    /**
     * A reference to an Angular application running on a page.
     *
     * For more about Angular applications, see the documentation for {@link bootstrap}.
     *
     * @stable
     */
    var ApplicationRef = (function () {
        function ApplicationRef() {
        }
        Object.defineProperty(ApplicationRef.prototype, "componentTypes", {
            /**
             * Get a list of component types registered to this application.
             * This list is populated even before the component is created.
             */
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        ;
        Object.defineProperty(ApplicationRef.prototype, "components", {
            /**
             * Get a list of components registered to this application.
             */
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        ;
        return ApplicationRef;
    }());
    var ApplicationRef_ = (function (_super) {
        __extends$3(ApplicationRef_, _super);
        function ApplicationRef_(_zone, _console, _injector, _exceptionHandler, _componentFactoryResolver, _initStatus, _testabilityRegistry, _testability) {
            var _this = this;
            _super.call(this);
            this._zone = _zone;
            this._console = _console;
            this._injector = _injector;
            this._exceptionHandler = _exceptionHandler;
            this._componentFactoryResolver = _componentFactoryResolver;
            this._initStatus = _initStatus;
            this._testabilityRegistry = _testabilityRegistry;
            this._testability = _testability;
            this._bootstrapListeners = [];
            this._rootComponents = [];
            this._rootComponentTypes = [];
            this._changeDetectorRefs = [];
            this._runningTick = false;
            this._enforceNoNewChanges = false;
            this._enforceNoNewChanges = isDevMode();
            this._zone.onMicrotaskEmpty.subscribe({ next: function () { _this._zone.run(function () { _this.tick(); }); } });
        }
        ApplicationRef_.prototype.registerChangeDetector = function (changeDetector) {
            this._changeDetectorRefs.push(changeDetector);
        };
        ApplicationRef_.prototype.unregisterChangeDetector = function (changeDetector) {
            ListWrapper.remove(this._changeDetectorRefs, changeDetector);
        };
        ApplicationRef_.prototype.bootstrap = function (componentOrFactory) {
            var _this = this;
            if (!this._initStatus.done) {
                throw new Error('Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module.');
            }
            var componentFactory;
            if (componentOrFactory instanceof ComponentFactory) {
                componentFactory = componentOrFactory;
            }
            else {
                componentFactory = this._componentFactoryResolver.resolveComponentFactory(componentOrFactory);
            }
            this._rootComponentTypes.push(componentFactory.componentType);
            var compRef = componentFactory.create(this._injector, [], componentFactory.selector);
            compRef.onDestroy(function () { _this._unloadComponent(compRef); });
            var testability = compRef.injector.get(Testability, null);
            if (testability) {
                compRef.injector.get(TestabilityRegistry)
                    .registerApplication(compRef.location.nativeElement, testability);
            }
            this._loadComponent(compRef);
            if (isDevMode()) {
                this._console.log("Angular 2 is running in the development mode. Call enableProdMode() to enable the production mode.");
            }
            return compRef;
        };
        /** @internal */
        ApplicationRef_.prototype._loadComponent = function (componentRef) {
            this._changeDetectorRefs.push(componentRef.changeDetectorRef);
            this.tick();
            this._rootComponents.push(componentRef);
            // Get the listeners lazily to prevent DI cycles.
            var listeners = this._injector.get(APP_BOOTSTRAP_LISTENER, [])
                .concat(this._bootstrapListeners);
            listeners.forEach(function (listener) { return listener(componentRef); });
        };
        /** @internal */
        ApplicationRef_.prototype._unloadComponent = function (componentRef) {
            if (this._rootComponents.indexOf(componentRef) == -1) {
                return;
            }
            this.unregisterChangeDetector(componentRef.changeDetectorRef);
            ListWrapper.remove(this._rootComponents, componentRef);
        };
        ApplicationRef_.prototype.tick = function () {
            if (this._runningTick) {
                throw new Error('ApplicationRef.tick is called recursively');
            }
            var scope = ApplicationRef_._tickScope();
            try {
                this._runningTick = true;
                this._changeDetectorRefs.forEach(function (detector) { return detector.detectChanges(); });
                if (this._enforceNoNewChanges) {
                    this._changeDetectorRefs.forEach(function (detector) { return detector.checkNoChanges(); });
                }
            }
            finally {
                this._runningTick = false;
                wtfLeave(scope);
            }
        };
        ApplicationRef_.prototype.ngOnDestroy = function () {
            // TODO(alxhub): Dispose of the NgZone.
            this._rootComponents.slice().forEach(function (component) { return component.destroy(); });
        };
        Object.defineProperty(ApplicationRef_.prototype, "componentTypes", {
            get: function () { return this._rootComponentTypes; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ApplicationRef_.prototype, "components", {
            get: function () { return this._rootComponents; },
            enumerable: true,
            configurable: true
        });
        /** @internal */
        ApplicationRef_._tickScope = wtfCreateScope('ApplicationRef#tick()');
        ApplicationRef_.decorators = [
            { type: Injectable },
        ];
        /** @nocollapse */
        ApplicationRef_.ctorParameters = [
            { type: NgZone, },
            { type: Console, },
            { type: Injector, },
            { type: ErrorHandler, },
            { type: ComponentFactoryResolver, },
            { type: ApplicationInitStatus, },
            { type: TestabilityRegistry, decorators: [{ type: Optional },] },
            { type: Testability, decorators: [{ type: Optional },] },
        ];
        return ApplicationRef_;
    }(ApplicationRef));

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$9 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    /**
     * Represents an instance of an NgModule created via a {@link NgModuleFactory}.
     *
     * `NgModuleRef` provides access to the NgModule Instance as well other objects related to this
     * NgModule Instance.
     *
     * @stable
     */
    var NgModuleRef = (function () {
        function NgModuleRef() {
        }
        Object.defineProperty(NgModuleRef.prototype, "injector", {
            /**
             * The injector that contains all of the providers of the NgModule.
             */
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgModuleRef.prototype, "componentFactoryResolver", {
            /**
             * The ComponentFactoryResolver to get hold of the ComponentFactories
             * declared in the `entryComponents` property of the module.
             */
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgModuleRef.prototype, "instance", {
            /**
             * The NgModule instance.
             */
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        return NgModuleRef;
    }());
    /**
     * @experimental
     */
    var NgModuleFactory = (function () {
        function NgModuleFactory(_injectorClass, _moduleType) {
            this._injectorClass = _injectorClass;
            this._moduleType = _moduleType;
        }
        Object.defineProperty(NgModuleFactory.prototype, "moduleType", {
            get: function () { return this._moduleType; },
            enumerable: true,
            configurable: true
        });
        NgModuleFactory.prototype.create = function (parentInjector) {
            if (!parentInjector) {
                parentInjector = Injector.NULL;
            }
            var instance = new this._injectorClass(parentInjector);
            instance.create();
            return instance;
        };
        return NgModuleFactory;
    }());
    var _UNDEFINED = new Object();
    var NgModuleInjector = (function (_super) {
        __extends$9(NgModuleInjector, _super);
        function NgModuleInjector(parent, factories, bootstrapFactories) {
            _super.call(this, factories, parent.get(ComponentFactoryResolver, ComponentFactoryResolver.NULL));
            this.parent = parent;
            this.bootstrapFactories = bootstrapFactories;
            this._destroyListeners = [];
            this._destroyed = false;
        }
        NgModuleInjector.prototype.create = function () { this.instance = this.createInternal(); };
        NgModuleInjector.prototype.get = function (token, notFoundValue) {
            if (notFoundValue === void 0) { notFoundValue = THROW_IF_NOT_FOUND; }
            if (token === Injector || token === ComponentFactoryResolver) {
                return this;
            }
            var result = this.getInternal(token, _UNDEFINED);
            return result === _UNDEFINED ? this.parent.get(token, notFoundValue) : result;
        };
        Object.defineProperty(NgModuleInjector.prototype, "injector", {
            get: function () { return this; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgModuleInjector.prototype, "componentFactoryResolver", {
            get: function () { return this; },
            enumerable: true,
            configurable: true
        });
        NgModuleInjector.prototype.destroy = function () {
            if (this._destroyed) {
                throw new Error("The ng module " + stringify(this.instance.constructor) + " has already been destroyed.");
            }
            this._destroyed = true;
            this.destroyInternal();
            this._destroyListeners.forEach(function (listener) { return listener(); });
        };
        NgModuleInjector.prototype.onDestroy = function (callback) { this._destroyListeners.push(callback); };
        return NgModuleInjector;
    }(CodegenComponentFactoryResolver));

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Used to load ng module factories.
     * @stable
     */
    var NgModuleFactoryLoader = (function () {
        function NgModuleFactoryLoader() {
        }
        return NgModuleFactoryLoader;
    }());
    var moduleFactories = new Map();
    /**
     * Registers a loaded module. Should only be called from generated NgModuleFactory code.
     * @experimental
     */
    function registerModuleFactory(id, factory) {
        var existing = moduleFactories.get(id);
        if (existing) {
            throw new Error("Duplicate module registered for " + id + " - " + existing.moduleType.name + " vs " + factory.moduleType.name);
        }
        moduleFactories.set(id, factory);
    }
    /**
     * Returns the NgModuleFactory with the given id, if it exists and has been loaded.
     * Factories for modules that do not specify an `id` cannot be retrieved. Throws if the module
     * cannot be found.
     * @experimental
     */
    function getModuleFactory(id) {
        var factory = moduleFactories.get(id);
        if (!factory)
            throw new Error("No module with ID " + id + " loaded");
        return factory;
    }

    /**
     * An unmodifiable list of items that Angular keeps up to date when the state
     * of the application changes.
     *
     * The type of object that {@link Query} and {@link ViewQueryMetadata} provide.
     *
     * Implements an iterable interface, therefore it can be used in both ES6
     * javascript `for (var i of items)` loops as well as in Angular templates with
     * `*ngFor="let i of myList"`.
     *
     * Changes can be observed by subscribing to the changes `Observable`.
     *
     * NOTE: In the future this class will implement an `Observable` interface.
     *
     * ### Example ([live demo](http://plnkr.co/edit/RX8sJnQYl9FWuSCWme5z?p=preview))
     * ```typescript
     * @Component({...})
     * class Container {
     *   @ViewChildren(Item) items:QueryList<Item>;
     * }
     * ```
     * @stable
     */
    var QueryList = (function () {
        function QueryList() {
            this._dirty = true;
            this._results = [];
            this._emitter = new EventEmitter();
        }
        Object.defineProperty(QueryList.prototype, "changes", {
            get: function () { return this._emitter; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(QueryList.prototype, "length", {
            get: function () { return this._results.length; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(QueryList.prototype, "first", {
            get: function () { return this._results[0]; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(QueryList.prototype, "last", {
            get: function () { return this._results[this.length - 1]; },
            enumerable: true,
            configurable: true
        });
        /**
         * See
         * [Array.map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)
         */
        QueryList.prototype.map = function (fn) { return this._results.map(fn); };
        /**
         * See
         * [Array.filter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)
         */
        QueryList.prototype.filter = function (fn) {
            return this._results.filter(fn);
        };
        /**
         * See
         * [Array.reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)
         */
        QueryList.prototype.reduce = function (fn, init) {
            return this._results.reduce(fn, init);
        };
        /**
         * See
         * [Array.forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)
         */
        QueryList.prototype.forEach = function (fn) { this._results.forEach(fn); };
        /**
         * See
         * [Array.some](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some)
         */
        QueryList.prototype.some = function (fn) {
            return this._results.some(fn);
        };
        QueryList.prototype.toArray = function () { return this._results.slice(); };
        QueryList.prototype[getSymbolIterator()] = function () { return this._results[getSymbolIterator()](); };
        QueryList.prototype.toString = function () { return this._results.toString(); };
        QueryList.prototype.reset = function (res) {
            this._results = ListWrapper.flatten(res);
            this._dirty = false;
        };
        QueryList.prototype.notifyOnChanges = function () { this._emitter.emit(this); };
        /** internal */
        QueryList.prototype.setDirty = function () { this._dirty = true; };
        Object.defineProperty(QueryList.prototype, "dirty", {
            /** internal */
            get: function () { return this._dirty; },
            enumerable: true,
            configurable: true
        });
        return QueryList;
    }());

    var _SEPARATOR = '#';
    var FACTORY_CLASS_SUFFIX = 'NgFactory';
    /**
     * Configuration for SystemJsNgModuleLoader.
     * token.
     *
     * @experimental
     */
    var SystemJsNgModuleLoaderConfig = (function () {
        function SystemJsNgModuleLoaderConfig() {
        }
        return SystemJsNgModuleLoaderConfig;
    }());
    var DEFAULT_CONFIG = {
        factoryPathPrefix: '',
        factoryPathSuffix: '.ngfactory',
    };
    /**
     * NgModuleFactoryLoader that uses SystemJS to load NgModuleFactory
     * @experimental
     */
    var SystemJsNgModuleLoader = (function () {
        function SystemJsNgModuleLoader(_compiler, config) {
            this._compiler = _compiler;
            this._config = config || DEFAULT_CONFIG;
        }
        SystemJsNgModuleLoader.prototype.load = function (path) {
            var offlineMode = this._compiler instanceof Compiler;
            return offlineMode ? this.loadFactory(path) : this.loadAndCompile(path);
        };
        SystemJsNgModuleLoader.prototype.loadAndCompile = function (path) {
            var _this = this;
            var _a = path.split(_SEPARATOR), module = _a[0], exportName = _a[1];
            if (exportName === undefined)
                exportName = 'default';
            return System.import(module)
                .then(function (module) { return module[exportName]; })
                .then(function (type) { return checkNotEmpty(type, module, exportName); })
                .then(function (type) { return _this._compiler.compileModuleAsync(type); });
        };
        SystemJsNgModuleLoader.prototype.loadFactory = function (path) {
            var _a = path.split(_SEPARATOR), module = _a[0], exportName = _a[1];
            var factoryClassSuffix = FACTORY_CLASS_SUFFIX;
            if (exportName === undefined) {
                exportName = 'default';
                factoryClassSuffix = '';
            }
            return System.import(this._config.factoryPathPrefix + module + this._config.factoryPathSuffix)
                .then(function (module) { return module[exportName + factoryClassSuffix]; })
                .then(function (factory) { return checkNotEmpty(factory, module, exportName); });
        };
        SystemJsNgModuleLoader.decorators = [
            { type: Injectable },
        ];
        /** @nocollapse */
        SystemJsNgModuleLoader.ctorParameters = [
            { type: Compiler, },
            { type: SystemJsNgModuleLoaderConfig, decorators: [{ type: Optional },] },
        ];
        return SystemJsNgModuleLoader;
    }());
    function checkNotEmpty(value, modulePath, exportName) {
        if (!value) {
            throw new Error("Cannot find '" + exportName + "' in '" + modulePath + "'");
        }
        return value;
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$10 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    /**
     * Represents an Embedded Template that can be used to instantiate Embedded Views.
     *
     * You can access a `TemplateRef`, in two ways. Via a directive placed on a `<template>` element (or
     * directive prefixed with `*`) and have the `TemplateRef` for this Embedded View injected into the
     * constructor of the directive using the `TemplateRef` Token. Alternatively you can query for the
     * `TemplateRef` from a Component or a Directive via {@link Query}.
     *
     * To instantiate Embedded Views based on a Template, use
     * {@link ViewContainerRef#createEmbeddedView}, which will create the View and attach it to the
     * View Container.
     * @stable
     */
    var TemplateRef = (function () {
        function TemplateRef() {
        }
        Object.defineProperty(TemplateRef.prototype, "elementRef", {
            /**
             * The location in the View where the Embedded View logically belongs to.
             *
             * The data-binding and injection contexts of Embedded Views created from this `TemplateRef`
             * inherit from the contexts of this location.
             *
             * Typically new Embedded Views are attached to the View Container of this location, but in
             * advanced use-cases, the View can be attached to a different container while keeping the
             * data-binding and injection context from the original location.
             *
             */
            // TODO(i): rename to anchor or location
            get: function () { return null; },
            enumerable: true,
            configurable: true
        });
        return TemplateRef;
    }());
    var TemplateRef_ = (function (_super) {
        __extends$10(TemplateRef_, _super);
        function TemplateRef_(_appElement, _viewFactory) {
            _super.call(this);
            this._appElement = _appElement;
            this._viewFactory = _viewFactory;
        }
        TemplateRef_.prototype.createEmbeddedView = function (context) {
            var view = this._viewFactory(this._appElement.parentView.viewUtils, this._appElement.parentInjector, this._appElement);
            view.create(context || {}, null, null);
            return view.ref;
        };
        Object.defineProperty(TemplateRef_.prototype, "elementRef", {
            get: function () { return this._appElement.elementRef; },
            enumerable: true,
            configurable: true
        });
        return TemplateRef_;
    }(TemplateRef));

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var _queuedAnimations = [];
    /** @internal */
    function queueAnimationGlobally(player) {
        _queuedAnimations.push(player);
    }
    /** @internal */
    function triggerQueuedAnimations() {
        for (var i = 0; i < _queuedAnimations.length; i++) {
            var player = _queuedAnimations[i];
            player.play();
        }
        _queuedAnimations = [];
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$11 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    /**
     * @stable
     */
    var ViewRef = (function () {
        function ViewRef() {
        }
        Object.defineProperty(ViewRef.prototype, "destroyed", {
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        return ViewRef;
    }());
    /**
     * Represents an Angular View.
     *
     * <!-- TODO: move the next two paragraphs to the dev guide -->
     * A View is a fundamental building block of the application UI. It is the smallest grouping of
     * Elements which are created and destroyed together.
     *
     * Properties of elements in a View can change, but the structure (number and order) of elements in
     * a View cannot. Changing the structure of Elements can only be done by inserting, moving or
     * removing nested Views via a {@link ViewContainerRef}. Each View can contain many View Containers.
     * <!-- /TODO -->
     *
     * ### Example
     *
     * Given this template...
     *
     * ```
     * Count: {{items.length}}
     * <ul>
     *   <li *ngFor="let  item of items">{{item}}</li>
     * </ul>
     * ```
     *
     * We have two {@link TemplateRef}s:
     *
     * Outer {@link TemplateRef}:
     * ```
     * Count: {{items.length}}
     * <ul>
     *   <template ngFor let-item [ngForOf]="items"></template>
     * </ul>
     * ```
     *
     * Inner {@link TemplateRef}:
     * ```
     *   <li>{{item}}</li>
     * ```
     *
     * Notice that the original template is broken down into two separate {@link TemplateRef}s.
     *
     * The outer/inner {@link TemplateRef}s are then assembled into views like so:
     *
     * ```
     * <!-- ViewRef: outer-0 -->
     * Count: 2
     * <ul>
     *   <template view-container-ref></template>
     *   <!-- ViewRef: inner-1 --><li>first</li><!-- /ViewRef: inner-1 -->
     *   <!-- ViewRef: inner-2 --><li>second</li><!-- /ViewRef: inner-2 -->
     * </ul>
     * <!-- /ViewRef: outer-0 -->
     * ```
     * @experimental
     */
    var EmbeddedViewRef = (function (_super) {
        __extends$11(EmbeddedViewRef, _super);
        function EmbeddedViewRef() {
            _super.apply(this, arguments);
        }
        Object.defineProperty(EmbeddedViewRef.prototype, "context", {
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EmbeddedViewRef.prototype, "rootNodes", {
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        ;
        return EmbeddedViewRef;
    }(ViewRef));
    var ViewRef_ = (function () {
        function ViewRef_(_view) {
            this._view = _view;
            this._view = _view;
            this._originalMode = this._view.cdMode;
        }
        Object.defineProperty(ViewRef_.prototype, "internalView", {
            get: function () { return this._view; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ViewRef_.prototype, "rootNodes", {
            get: function () { return this._view.flatRootNodes; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ViewRef_.prototype, "context", {
            get: function () { return this._view.context; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ViewRef_.prototype, "destroyed", {
            get: function () { return this._view.destroyed; },
            enumerable: true,
            configurable: true
        });
        ViewRef_.prototype.markForCheck = function () { this._view.markPathToRootAsCheckOnce(); };
        ViewRef_.prototype.detach = function () { this._view.cdMode = ChangeDetectorStatus.Detached; };
        ViewRef_.prototype.detectChanges = function () {
            this._view.detectChanges(false);
            triggerQueuedAnimations();
        };
        ViewRef_.prototype.checkNoChanges = function () { this._view.detectChanges(true); };
        ViewRef_.prototype.reattach = function () {
            this._view.cdMode = this._originalMode;
            this.markForCheck();
        };
        ViewRef_.prototype.onDestroy = function (callback) { this._view.disposables.push(callback); };
        ViewRef_.prototype.destroy = function () { this._view.destroy(); };
        return ViewRef_;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$12 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var EventListener = (function () {
        function EventListener(name, callback) {
            this.name = name;
            this.callback = callback;
        }
        ;
        return EventListener;
    }());
    /**
     * @experimental All debugging apis are currently experimental.
     */
    var DebugNode = (function () {
        function DebugNode(nativeNode, parent, _debugInfo) {
            this._debugInfo = _debugInfo;
            this.nativeNode = nativeNode;
            if (isPresent(parent) && parent instanceof DebugElement) {
                parent.addChild(this);
            }
            else {
                this.parent = null;
            }
            this.listeners = [];
        }
        Object.defineProperty(DebugNode.prototype, "injector", {
            get: function () { return isPresent(this._debugInfo) ? this._debugInfo.injector : null; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DebugNode.prototype, "componentInstance", {
            get: function () {
                return isPresent(this._debugInfo) ? this._debugInfo.component : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DebugNode.prototype, "context", {
            get: function () { return isPresent(this._debugInfo) ? this._debugInfo.context : null; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DebugNode.prototype, "references", {
            get: function () {
                return isPresent(this._debugInfo) ? this._debugInfo.references : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DebugNode.prototype, "providerTokens", {
            get: function () {
                return isPresent(this._debugInfo) ? this._debugInfo.providerTokens : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DebugNode.prototype, "source", {
            get: function () { return isPresent(this._debugInfo) ? this._debugInfo.source : null; },
            enumerable: true,
            configurable: true
        });
        return DebugNode;
    }());
    /**
     * @experimental All debugging apis are currently experimental.
     */
    var DebugElement = (function (_super) {
        __extends$12(DebugElement, _super);
        function DebugElement(nativeNode, parent, _debugInfo) {
            _super.call(this, nativeNode, parent, _debugInfo);
            this.properties = {};
            this.attributes = {};
            this.classes = {};
            this.styles = {};
            this.childNodes = [];
            this.nativeElement = nativeNode;
        }
        DebugElement.prototype.addChild = function (child) {
            if (isPresent(child)) {
                this.childNodes.push(child);
                child.parent = this;
            }
        };
        DebugElement.prototype.removeChild = function (child) {
            var childIndex = this.childNodes.indexOf(child);
            if (childIndex !== -1) {
                child.parent = null;
                this.childNodes.splice(childIndex, 1);
            }
        };
        DebugElement.prototype.insertChildrenAfter = function (child, newChildren) {
            var siblingIndex = this.childNodes.indexOf(child);
            if (siblingIndex !== -1) {
                var previousChildren = this.childNodes.slice(0, siblingIndex + 1);
                var nextChildren = this.childNodes.slice(siblingIndex + 1);
                this.childNodes =
                    ListWrapper.concat(ListWrapper.concat(previousChildren, newChildren), nextChildren);
                for (var i = 0; i < newChildren.length; ++i) {
                    var newChild = newChildren[i];
                    if (isPresent(newChild.parent)) {
                        newChild.parent.removeChild(newChild);
                    }
                    newChild.parent = this;
                }
            }
        };
        DebugElement.prototype.query = function (predicate) {
            var results = this.queryAll(predicate);
            return results.length > 0 ? results[0] : null;
        };
        DebugElement.prototype.queryAll = function (predicate) {
            var matches = [];
            _queryElementChildren(this, predicate, matches);
            return matches;
        };
        DebugElement.prototype.queryAllNodes = function (predicate) {
            var matches = [];
            _queryNodeChildren(this, predicate, matches);
            return matches;
        };
        Object.defineProperty(DebugElement.prototype, "children", {
            get: function () {
                var children = [];
                this.childNodes.forEach(function (node) {
                    if (node instanceof DebugElement) {
                        children.push(node);
                    }
                });
                return children;
            },
            enumerable: true,
            configurable: true
        });
        DebugElement.prototype.triggerEventHandler = function (eventName, eventObj) {
            this.listeners.forEach(function (listener) {
                if (listener.name == eventName) {
                    listener.callback(eventObj);
                }
            });
        };
        return DebugElement;
    }(DebugNode));
    /**
     * @experimental
     */
    function asNativeElements(debugEls) {
        return debugEls.map(function (el) { return el.nativeElement; });
    }
    function _queryElementChildren(element, predicate, matches) {
        element.childNodes.forEach(function (node) {
            if (node instanceof DebugElement) {
                if (predicate(node)) {
                    matches.push(node);
                }
                _queryElementChildren(node, predicate, matches);
            }
        });
    }
    function _queryNodeChildren(parentNode, predicate, matches) {
        if (parentNode instanceof DebugElement) {
            parentNode.childNodes.forEach(function (node) {
                if (predicate(node)) {
                    matches.push(node);
                }
                if (node instanceof DebugElement) {
                    _queryNodeChildren(node, predicate, matches);
                }
            });
        }
    }
    // Need to keep the nodes in a global Map so that multiple angular apps are supported.
    var _nativeNodeToDebugNode = new Map();
    /**
     * @experimental
     */
    function getDebugNode(nativeNode) {
        return _nativeNodeToDebugNode.get(nativeNode);
    }
    function indexDebugNode(node) {
        _nativeNodeToDebugNode.set(node.nativeNode, node);
    }
    function removeDebugNodeFromIndex(node) {
        _nativeNodeToDebugNode.delete(node.nativeNode);
    }

    function _reflector() {
        return reflector;
    }
    var _CORE_PLATFORM_PROVIDERS = [
        PlatformRef_,
        { provide: PlatformRef, useExisting: PlatformRef_ },
        { provide: Reflector, useFactory: _reflector, deps: [] },
        { provide: ReflectorReader, useExisting: Reflector },
        TestabilityRegistry,
        Console,
    ];
    /**
     * This platform has to be included in any other platform
     *
     * @experimental
     */
    var platformCore = createPlatformFactory(null, 'core', _CORE_PLATFORM_PROVIDERS);

    /**
     * @experimental i18n support is experimental.
     */
    var LOCALE_ID = new OpaqueToken('LocaleId');
    /**
     * @experimental i18n support is experimental.
     */
    var TRANSLATIONS = new OpaqueToken('Translations');
    /**
     * @experimental i18n support is experimental.
     */
    var TRANSLATIONS_FORMAT = new OpaqueToken('TranslationsFormat');

    function _iterableDiffersFactory() {
        return defaultIterableDiffers;
    }
    function _keyValueDiffersFactory() {
        return defaultKeyValueDiffers;
    }
    /**
     * This module includes the providers of @angular/core that are needed
     * to bootstrap components via `ApplicationRef`.
     *
     * @experimental
     */
    var ApplicationModule = (function () {
        function ApplicationModule() {
        }
        ApplicationModule.decorators = [
            { type: NgModule, args: [{
                        providers: [
                            ApplicationRef_,
                            { provide: ApplicationRef, useExisting: ApplicationRef_ },
                            ApplicationInitStatus,
                            Compiler,
                            APP_ID_RANDOM_PROVIDER,
                            ViewUtils,
                            { provide: IterableDiffers, useFactory: _iterableDiffersFactory },
                            { provide: KeyValueDiffers, useFactory: _keyValueDiffersFactory },
                            { provide: LOCALE_ID, useValue: 'en-US' },
                        ]
                    },] },
        ];
        /** @nocollapse */
        ApplicationModule.ctorParameters = [];
        return ApplicationModule;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var FILL_STYLE_FLAG = 'true'; // TODO (matsko): change to boolean
    var ANY_STATE = '*';
    var DEFAULT_STATE = '*';
    var EMPTY_STATE = 'void';

    var AnimationGroupPlayer = (function () {
        function AnimationGroupPlayer(_players) {
            var _this = this;
            this._players = _players;
            this._onDoneFns = [];
            this._onStartFns = [];
            this._finished = false;
            this._started = false;
            this.parentPlayer = null;
            var count = 0;
            var total = this._players.length;
            if (total == 0) {
                scheduleMicroTask(function () { return _this._onFinish(); });
            }
            else {
                this._players.forEach(function (player) {
                    player.parentPlayer = _this;
                    player.onDone(function () {
                        if (++count >= total) {
                            _this._onFinish();
                        }
                    });
                });
            }
        }
        AnimationGroupPlayer.prototype._onFinish = function () {
            if (!this._finished) {
                this._finished = true;
                if (!isPresent(this.parentPlayer)) {
                    this.destroy();
                }
                this._onDoneFns.forEach(function (fn) { return fn(); });
                this._onDoneFns = [];
            }
        };
        AnimationGroupPlayer.prototype.init = function () { this._players.forEach(function (player) { return player.init(); }); };
        AnimationGroupPlayer.prototype.onStart = function (fn) { this._onStartFns.push(fn); };
        AnimationGroupPlayer.prototype.onDone = function (fn) { this._onDoneFns.push(fn); };
        AnimationGroupPlayer.prototype.hasStarted = function () { return this._started; };
        AnimationGroupPlayer.prototype.play = function () {
            if (!isPresent(this.parentPlayer)) {
                this.init();
            }
            if (!this.hasStarted()) {
                this._onStartFns.forEach(function (fn) { return fn(); });
                this._onStartFns = [];
                this._started = true;
            }
            this._players.forEach(function (player) { return player.play(); });
        };
        AnimationGroupPlayer.prototype.pause = function () { this._players.forEach(function (player) { return player.pause(); }); };
        AnimationGroupPlayer.prototype.restart = function () { this._players.forEach(function (player) { return player.restart(); }); };
        AnimationGroupPlayer.prototype.finish = function () {
            this._onFinish();
            this._players.forEach(function (player) { return player.finish(); });
        };
        AnimationGroupPlayer.prototype.destroy = function () {
            this._onFinish();
            this._players.forEach(function (player) { return player.destroy(); });
        };
        AnimationGroupPlayer.prototype.reset = function () { this._players.forEach(function (player) { return player.reset(); }); };
        AnimationGroupPlayer.prototype.setPosition = function (p /** TODO #9100 */) {
            this._players.forEach(function (player) { player.setPosition(p); });
        };
        AnimationGroupPlayer.prototype.getPosition = function () {
            var min = 0;
            this._players.forEach(function (player) {
                var p = player.getPosition();
                min = Math.min(p, min);
            });
            return min;
        };
        return AnimationGroupPlayer;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var AnimationKeyframe = (function () {
        function AnimationKeyframe(offset, styles) {
            this.offset = offset;
            this.styles = styles;
        }
        return AnimationKeyframe;
    }());

    /**
     * @experimental Animation support is experimental.
     */
    var AnimationPlayer = (function () {
        function AnimationPlayer() {
        }
        Object.defineProperty(AnimationPlayer.prototype, "parentPlayer", {
            get: function () { throw new Error('NOT IMPLEMENTED: Base Class'); },
            set: function (player) { throw new Error('NOT IMPLEMENTED: Base Class'); },
            enumerable: true,
            configurable: true
        });
        return AnimationPlayer;
    }());
    var NoOpAnimationPlayer = (function () {
        function NoOpAnimationPlayer() {
            var _this = this;
            this._onDoneFns = [];
            this._onStartFns = [];
            this._started = false;
            this.parentPlayer = null;
            scheduleMicroTask(function () { return _this._onFinish(); });
        }
        /** @internal */
        NoOpAnimationPlayer.prototype._onFinish = function () {
            this._onDoneFns.forEach(function (fn) { return fn(); });
            this._onDoneFns = [];
        };
        NoOpAnimationPlayer.prototype.onStart = function (fn) { this._onStartFns.push(fn); };
        NoOpAnimationPlayer.prototype.onDone = function (fn) { this._onDoneFns.push(fn); };
        NoOpAnimationPlayer.prototype.hasStarted = function () { return this._started; };
        NoOpAnimationPlayer.prototype.init = function () { };
        NoOpAnimationPlayer.prototype.play = function () {
            if (!this.hasStarted()) {
                this._onStartFns.forEach(function (fn) { return fn(); });
                this._onStartFns = [];
            }
            this._started = true;
        };
        NoOpAnimationPlayer.prototype.pause = function () { };
        NoOpAnimationPlayer.prototype.restart = function () { };
        NoOpAnimationPlayer.prototype.finish = function () { this._onFinish(); };
        NoOpAnimationPlayer.prototype.destroy = function () { };
        NoOpAnimationPlayer.prototype.reset = function () { };
        NoOpAnimationPlayer.prototype.setPosition = function (p /** TODO #9100 */) { };
        NoOpAnimationPlayer.prototype.getPosition = function () { return 0; };
        return NoOpAnimationPlayer;
    }());

    var AnimationSequencePlayer = (function () {
        function AnimationSequencePlayer(_players) {
            var _this = this;
            this._players = _players;
            this._currentIndex = 0;
            this._onDoneFns = [];
            this._onStartFns = [];
            this._finished = false;
            this._started = false;
            this.parentPlayer = null;
            this._players.forEach(function (player) { player.parentPlayer = _this; });
            this._onNext(false);
        }
        AnimationSequencePlayer.prototype._onNext = function (start) {
            var _this = this;
            if (this._finished)
                return;
            if (this._players.length == 0) {
                this._activePlayer = new NoOpAnimationPlayer();
                scheduleMicroTask(function () { return _this._onFinish(); });
            }
            else if (this._currentIndex >= this._players.length) {
                this._activePlayer = new NoOpAnimationPlayer();
                this._onFinish();
            }
            else {
                var player = this._players[this._currentIndex++];
                player.onDone(function () { return _this._onNext(true); });
                this._activePlayer = player;
                if (start) {
                    player.play();
                }
            }
        };
        AnimationSequencePlayer.prototype._onFinish = function () {
            if (!this._finished) {
                this._finished = true;
                if (!isPresent(this.parentPlayer)) {
                    this.destroy();
                }
                this._onDoneFns.forEach(function (fn) { return fn(); });
                this._onDoneFns = [];
            }
        };
        AnimationSequencePlayer.prototype.init = function () { this._players.forEach(function (player) { return player.init(); }); };
        AnimationSequencePlayer.prototype.onStart = function (fn) { this._onStartFns.push(fn); };
        AnimationSequencePlayer.prototype.onDone = function (fn) { this._onDoneFns.push(fn); };
        AnimationSequencePlayer.prototype.hasStarted = function () { return this._started; };
        AnimationSequencePlayer.prototype.play = function () {
            if (!isPresent(this.parentPlayer)) {
                this.init();
            }
            if (!this.hasStarted()) {
                this._onStartFns.forEach(function (fn) { return fn(); });
                this._onStartFns = [];
                this._started = true;
            }
            this._activePlayer.play();
        };
        AnimationSequencePlayer.prototype.pause = function () { this._activePlayer.pause(); };
        AnimationSequencePlayer.prototype.restart = function () {
            if (this._players.length > 0) {
                this.reset();
                this._players[0].restart();
            }
        };
        AnimationSequencePlayer.prototype.reset = function () { this._players.forEach(function (player) { return player.reset(); }); };
        AnimationSequencePlayer.prototype.finish = function () {
            this._onFinish();
            this._players.forEach(function (player) { return player.finish(); });
        };
        AnimationSequencePlayer.prototype.destroy = function () {
            this._onFinish();
            this._players.forEach(function (player) { return player.destroy(); });
        };
        AnimationSequencePlayer.prototype.setPosition = function (p /** TODO #9100 */) { this._players[0].setPosition(p); };
        AnimationSequencePlayer.prototype.getPosition = function () { return this._players[0].getPosition(); };
        return AnimationSequencePlayer;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$13 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    /**
     * @experimental Animation support is experimental.
     */
    var AUTO_STYLE = '*';
    /**
     * Metadata representing the entry of animations.
     * Instances of this class are provided via the animation DSL when the {@link trigger trigger
     * animation function} is called.
     *
     * @experimental Animation support is experimental.
     */
    var AnimationEntryMetadata = (function () {
        function AnimationEntryMetadata(name, definitions) {
            this.name = name;
            this.definitions = definitions;
        }
        return AnimationEntryMetadata;
    }());
    /**
     * @experimental Animation support is experimental.
     */
    var AnimationStateMetadata = (function () {
        function AnimationStateMetadata() {
        }
        return AnimationStateMetadata;
    }());
    /**
     * Metadata representing the entry of animations.
     * Instances of this class are provided via the animation DSL when the {@link state state animation
     * function} is called.
     *
     * @experimental Animation support is experimental.
     */
    var AnimationStateDeclarationMetadata = (function (_super) {
        __extends$13(AnimationStateDeclarationMetadata, _super);
        function AnimationStateDeclarationMetadata(stateNameExpr, styles) {
            _super.call(this);
            this.stateNameExpr = stateNameExpr;
            this.styles = styles;
        }
        return AnimationStateDeclarationMetadata;
    }(AnimationStateMetadata));
    /**
     * Metadata representing the entry of animations.
     * Instances of this class are provided via the animation DSL when the
     * {@link transition transition animation function} is called.
     *
     * @experimental Animation support is experimental.
     */
    var AnimationStateTransitionMetadata = (function (_super) {
        __extends$13(AnimationStateTransitionMetadata, _super);
        function AnimationStateTransitionMetadata(stateChangeExpr, steps) {
            _super.call(this);
            this.stateChangeExpr = stateChangeExpr;
            this.steps = steps;
        }
        return AnimationStateTransitionMetadata;
    }(AnimationStateMetadata));
    /**
     * @experimental Animation support is experimental.
     */
    var AnimationMetadata = (function () {
        function AnimationMetadata() {
        }
        return AnimationMetadata;
    }());
    /**
     * Metadata representing the entry of animations.
     * Instances of this class are provided via the animation DSL when the {@link keyframes keyframes
     * animation function} is called.
     *
     * @experimental Animation support is experimental.
     */
    var AnimationKeyframesSequenceMetadata = (function (_super) {
        __extends$13(AnimationKeyframesSequenceMetadata, _super);
        function AnimationKeyframesSequenceMetadata(steps) {
            _super.call(this);
            this.steps = steps;
        }
        return AnimationKeyframesSequenceMetadata;
    }(AnimationMetadata));
    /**
     * Metadata representing the entry of animations.
     * Instances of this class are provided via the animation DSL when the {@link style style animation
     * function} is called.
     *
     * @experimental Animation support is experimental.
     */
    var AnimationStyleMetadata = (function (_super) {
        __extends$13(AnimationStyleMetadata, _super);
        function AnimationStyleMetadata(styles, offset) {
            if (offset === void 0) { offset = null; }
            _super.call(this);
            this.styles = styles;
            this.offset = offset;
        }
        return AnimationStyleMetadata;
    }(AnimationMetadata));
    /**
     * Metadata representing the entry of animations.
     * Instances of this class are provided via the animation DSL when the {@link animate animate
     * animation function} is called.
     *
     * @experimental Animation support is experimental.
     */
    var AnimationAnimateMetadata = (function (_super) {
        __extends$13(AnimationAnimateMetadata, _super);
        function AnimationAnimateMetadata(timings, styles) {
            _super.call(this);
            this.timings = timings;
            this.styles = styles;
        }
        return AnimationAnimateMetadata;
    }(AnimationMetadata));
    /**
     * @experimental Animation support is experimental.
     */
    var AnimationWithStepsMetadata = (function (_super) {
        __extends$13(AnimationWithStepsMetadata, _super);
        function AnimationWithStepsMetadata() {
            _super.call(this);
        }
        Object.defineProperty(AnimationWithStepsMetadata.prototype, "steps", {
            get: function () { throw new Error('NOT IMPLEMENTED: Base Class'); },
            enumerable: true,
            configurable: true
        });
        return AnimationWithStepsMetadata;
    }(AnimationMetadata));
    /**
     * Metadata representing the entry of animations.
     * Instances of this class are provided via the animation DSL when the {@link sequence sequence
     * animation function} is called.
     *
     * @experimental Animation support is experimental.
     */
    var AnimationSequenceMetadata = (function (_super) {
        __extends$13(AnimationSequenceMetadata, _super);
        function AnimationSequenceMetadata(_steps) {
            _super.call(this);
            this._steps = _steps;
        }
        Object.defineProperty(AnimationSequenceMetadata.prototype, "steps", {
            get: function () { return this._steps; },
            enumerable: true,
            configurable: true
        });
        return AnimationSequenceMetadata;
    }(AnimationWithStepsMetadata));
    /**
     * Metadata representing the entry of animations.
     * Instances of this class are provided via the animation DSL when the {@link group group animation
     * function} is called.
     *
     * @experimental Animation support is experimental.
     */
    var AnimationGroupMetadata = (function (_super) {
        __extends$13(AnimationGroupMetadata, _super);
        function AnimationGroupMetadata(_steps) {
            _super.call(this);
            this._steps = _steps;
        }
        Object.defineProperty(AnimationGroupMetadata.prototype, "steps", {
            get: function () { return this._steps; },
            enumerable: true,
            configurable: true
        });
        return AnimationGroupMetadata;
    }(AnimationWithStepsMetadata));
    /**
     * `animate` is an animation-specific function that is designed to be used inside of Angular2's
     * animation
     * DSL language. If this information is new, please navigate to the
     * {@link Component#animations-anchor component animations metadata
     * page} to gain a better understanding of how animations in Angular2 are used.
     *
     * `animate` specifies an animation step that will apply the provided `styles` data for a given
     * amount of
     * time based on the provided `timing` expression value. Calls to `animate` are expected to be
     * used within {@link sequence an animation sequence}, {@link group group}, or {@link transition
     * transition}.
     *
     * ### Usage
     *
     * The `animate` function accepts two input parameters: `timing` and `styles`:
     *
     * - `timing` is a string based value that can be a combination of a duration with optional
     * delay and easing values. The format for the expression breaks down to `duration delay easing`
     * (therefore a value such as `1s 100ms ease-out` will be parse itself into `duration=1000,
     * delay=100, easing=ease-out`.
     * If a numeric value is provided then that will be used as the `duration` value in millisecond
     * form.
     * - `styles` is the style input data which can either be a call to {@link style style} or {@link
     * keyframes keyframes}.
     * If left empty then the styles from the destination state will be collected and used (this is
     * useful when
     * describing an animation step that will complete an animation by {@link
     * transition#the-final-animate-call animating to the final state}).
     *
     * ```typescript
     * // various functions for specifying timing data
     * animate(500, style(...))
     * animate("1s", style(...))
     * animate("100ms 0.5s", style(...))
     * animate("5s ease", style(...))
     * animate("5s 10ms cubic-bezier(.17,.67,.88,.1)", style(...))
     *
     * // either style() of keyframes() can be used
     * animate(500, style({ background: "red" }))
     * animate(500, keyframes([
     *   style({ background: "blue" })),
     *   style({ background: "red" }))
     * ])
     * ```
     *
     * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
     *
     * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
     *
     * @experimental Animation support is experimental.
     */
    function animate(timing, styles) {
        if (styles === void 0) { styles = null; }
        var stylesEntry = styles;
        if (!isPresent(stylesEntry)) {
            var EMPTY_STYLE = {};
            stylesEntry = new AnimationStyleMetadata([EMPTY_STYLE], 1);
        }
        return new AnimationAnimateMetadata(timing, stylesEntry);
    }
    /**
     * `group` is an animation-specific function that is designed to be used inside of Angular2's
     * animation
     * DSL language. If this information is new, please navigate to the
     * {@link Component#animations-anchor component animations metadata
     * page} to gain a better understanding of how animations in Angular2 are used.
     *
     * `group` specifies a list of animation steps that are all run in parallel. Grouped animations
     * are useful when a series of styles must be animated/closed off
     * at different statrting/ending times.
     *
     * The `group` function can either be used within a {@link sequence sequence} or a {@link transition
     * transition}
     * and it will only continue to the next instruction once all of the inner animation steps
     * have completed.
     *
     * ### Usage
     *
     * The `steps` data that is passed into the `group` animation function can either consist
     * of {@link style style} or {@link animate animate} function calls. Each call to `style()` or
     * `animate()`
     * within a group will be executed instantly (use {@link keyframes keyframes} or a
     * {@link animate#usage animate() with a delay value} to offset styles to be applied at a later
     * time).
     *
     * ```typescript
     * group([
     *   animate("1s", { background: "black" }))
     *   animate("2s", { color: "white" }))
     * ])
     * ```
     *
     * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
     *
     * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
     *
     * @experimental Animation support is experimental.
     */
    function group(steps) {
        return new AnimationGroupMetadata(steps);
    }
    /**
     * `sequence` is an animation-specific function that is designed to be used inside of Angular2's
     * animation
     * DSL language. If this information is new, please navigate to the
     * {@link Component#animations-anchor component animations metadata
     * page} to gain a better understanding of how animations in Angular2 are used.
     *
     * `sequence` Specifies a list of animation steps that are run one by one. (`sequence` is used
     * by default when an array is passed as animation data into {@link transition transition}.)
     *
     * The `sequence` function can either be used within a {@link group group} or a {@link transition
     * transition}
     * and it will only continue to the next instruction once each of the inner animation steps
     * have completed.
     *
     * To perform animation styling in parallel with other animation steps then
     * have a look at the {@link group group} animation function.
     *
     * ### Usage
     *
     * The `steps` data that is passed into the `sequence` animation function can either consist
     * of {@link style style} or {@link animate animate} function calls. A call to `style()` will apply
     * the
     * provided styling data immediately while a call to `animate()` will apply its styling
     * data over a given time depending on its timing data.
     *
     * ```typescript
     * sequence([
     *   style({ opacity: 0 })),
     *   animate("1s", { opacity: 1 }))
     * ])
     * ```
     *
     * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
     *
     * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
     *
     * @experimental Animation support is experimental.
     */
    function sequence(steps) {
        return new AnimationSequenceMetadata(steps);
    }
    /**
     * `style` is an animation-specific function that is designed to be used inside of Angular2's
     * animation
     * DSL language. If this information is new, please navigate to the
     * {@link Component#animations-anchor component animations metadata
     * page} to gain a better understanding of how animations in Angular2 are used.
     *
     * `style` declares a key/value object containing CSS properties/styles that can then
     * be used for {@link state animation states}, within an {@link sequence animation sequence}, or as
     * styling data for both {@link animate animate} and {@link keyframes keyframes}.
     *
     * ### Usage
     *
     * `style` takes in a key/value string map as data and expects one or more CSS property/value
     * pairs to be defined.
     *
     * ```typescript
     * // string values are used for css properties
     * style({ background: "red", color: "blue" })
     *
     * // numerical (pixel) values are also supported
     * style({ width: 100, height: 0 })
     * ```
     *
     * #### Auto-styles (using `*`)
     *
     * When an asterix (`*`) character is used as a value then it will be detected from the element
     * being animated
     * and applied as animation data when the animation starts.
     *
     * This feature proves useful for a state depending on layout and/or environment factors; in such
     * cases
     * the styles are calculated just before the animation starts.
     *
     * ```typescript
     * // the steps below will animate from 0 to the
     * // actual height of the element
     * style({ height: 0 }),
     * animate("1s", style({ height: "*" }))
     * ```
     *
     * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
     *
     * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
     *
     * @experimental Animation support is experimental.
     */
    function style(tokens) {
        var input;
        var offset = null;
        if (typeof tokens === 'string') {
            input = [tokens];
        }
        else {
            if (Array.isArray(tokens)) {
                input = tokens;
            }
            else {
                input = [tokens];
            }
            input.forEach(function (entry) {
                var entryOffset = entry['offset'];
                if (isPresent(entryOffset)) {
                    offset = offset == null ? parseFloat(entryOffset) : offset;
                }
            });
        }
        return new AnimationStyleMetadata(input, offset);
    }
    /**
     * `state` is an animation-specific function that is designed to be used inside of Angular2's
     * animation
     * DSL language. If this information is new, please navigate to the
     * {@link Component#animations-anchor component animations metadata
     * page} to gain a better understanding of how animations in Angular2 are used.
     *
     * `state` declares an animation state within the given trigger. When a state is
     * active within a component then its associated styles will persist on
     * the element that the trigger is attached to (even when the animation ends).
     *
     * To animate between states, have a look at the animation {@link transition transition}
     * DSL function. To register states to an animation trigger please have a look
     * at the {@link trigger trigger} function.
     *
     * #### The `void` state
     *
     * The `void` state value is a reserved word that angular uses to determine when the element is not
     * apart
     * of the application anymore (e.g. when an `ngIf` evaluates to false then the state of the
     * associated element
     * is void).
     *
     * #### The `*` (default) state
     *
     * The `*` state (when styled) is a fallback state that will be used if
     * the state that is being animated is not declared within the trigger.
     *
     * ### Usage
     *
     * `state` will declare an animation state with its associated styles
     * within the given trigger.
     *
     * - `stateNameExpr` can be one or more state names separated by commas.
     * - `styles` refers to the {@link style styling data} that will be persisted on the element once
     * the state
     * has been reached.
     *
     * ```typescript
     * // "void" is a reserved name for a state and is used to represent
     * // the state in which an element is detached from from the application.
     * state("void", style({ height: 0 }))
     *
     * // user-defined states
     * state("closed", style({ height: 0 }))
     * state("open, visible", style({ height: "*" }))
     * ```
     *
     * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
     *
     * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
     *
     * @experimental Animation support is experimental.
     */
    function state(stateNameExpr, styles) {
        return new AnimationStateDeclarationMetadata(stateNameExpr, styles);
    }
    /**
     * `keyframes` is an animation-specific function that is designed to be used inside of Angular2's
     * animation
     * DSL language. If this information is new, please navigate to the
     * {@link Component#animations-anchor component animations metadata
     * page} to gain a better understanding of how animations in Angular2 are used.
     *
     * `keyframes` specifies a collection of {@link style style} entries each optionally characterized
     * by an `offset` value.
     *
     * ### Usage
     *
     * The `keyframes` animation function is designed to be used alongside the {@link animate animate}
     * animation function. Instead of applying animations from where they are
     * currently to their destination, keyframes can describe how each style entry is applied
     * and at what point within the animation arc (much like CSS Keyframe Animations do).
     *
     * For each `style()` entry an `offset` value can be set. Doing so allows to specifiy at
     * what percentage of the animate time the styles will be applied.
     *
     * ```typescript
     * // the provided offset values describe when each backgroundColor value is applied.
     * animate("5s", keyframes([
     *   style({ backgroundColor: "red", offset: 0 }),
     *   style({ backgroundColor: "blue", offset: 0.2 }),
     *   style({ backgroundColor: "orange", offset: 0.3 }),
     *   style({ backgroundColor: "black", offset: 1 })
     * ]))
     * ```
     *
     * Alternatively, if there are no `offset` values used within the style entries then the offsets
     * will
     * be calculated automatically.
     *
     * ```typescript
     * animate("5s", keyframes([
     *   style({ backgroundColor: "red" }) // offset = 0
     *   style({ backgroundColor: "blue" }) // offset = 0.33
     *   style({ backgroundColor: "orange" }) // offset = 0.66
     *   style({ backgroundColor: "black" }) // offset = 1
     * ]))
     * ```
     *
     * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
     *
     * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
     *
     * @experimental Animation support is experimental.
     */
    function keyframes(steps) {
        return new AnimationKeyframesSequenceMetadata(steps);
    }
    /**
     * `transition` is an animation-specific function that is designed to be used inside of Angular2's
     * animation
     * DSL language. If this information is new, please navigate to the
     * {@link Component#animations-anchor component animations metadata
     * page} to gain a better understanding of how animations in Angular2 are used.
     *
     * `transition` declares the {@link sequence sequence of animation steps} that will be run when the
     * provided
     * `stateChangeExpr` value is satisfied. The `stateChangeExpr` consists of a `state1 => state2`
     * which consists
     * of two known states (use an asterix (`*`) to refer to a dynamic starting and/or ending state).
     *
     * Animation transitions are placed within an {@link trigger animation trigger}. For an transition
     * to animate to
     * a state value and persist its styles then one or more {@link state animation states} is expected
     * to be defined.
     *
     * ### Usage
     *
     * An animation transition is kicked off the `stateChangeExpr` predicate evaluates to true based on
     * what the
     * previous state is and what the current state has become. In other words, if a transition is
     * defined that
     * matches the old/current state criteria then the associated animation will be triggered.
     *
     * ```typescript
     * // all transition/state changes are defined within an animation trigger
     * trigger("myAnimationTrigger", [
     *   // if a state is defined then its styles will be persisted when the
     *   // animation has fully completed itself
     *   state("on", style({ background: "green" })),
     *   state("off", style({ background: "grey" })),
     *
     *   // a transition animation that will be kicked off when the state value
     *   // bound to "myAnimationTrigger" changes from "on" to "off"
     *   transition("on => off", animate(500)),
     *
     *   // it is also possible to do run the same animation for both directions
     *   transition("on <=> off", animate(500)),
     *
     *   // or to define multiple states pairs separated by commas
     *   transition("on => off, off => void", animate(500)),
     *
     *   // this is a catch-all state change for when an element is inserted into
     *   // the page and the destination state is unknown
     *   transition("void => *", [
     *     style({ opacity: 0 }),
     *     animate(500)
     *   ]),
     *
     *   // this will capture a state change between any states
     *   transition("* => *", animate("1s 0s")),
     * ])
     * ```
     *
     * The template associated with this component will make use of the `myAnimationTrigger`
     * animation trigger by binding to an element within its template code.
     *
     * ```html
     * <!-- somewhere inside of my-component-tpl.html -->
     * <div [@myAnimationTrigger]="myStatusExp">...</div>
     * ```
     *
     * #### The final `animate` call
     *
     * If the final step within the transition steps is a call to `animate()` that **only**
     * uses a timing value with **no style data** then it will be automatically used as the final
     * animation
     * arc for the element to animate itself to the final state. This involves an automatic mix of
     * adding/removing CSS styles so that the element will be in the exact state it should be for the
     * applied state to be presented correctly.
     *
     * ```
     * // start off by hiding the element, but make sure that it animates properly to whatever state
     * // is currently active for "myAnimationTrigger"
     * transition("void => *", [
     *   style({ opacity: 0 }),
     *   animate(500)
     * ])
     * ```
     *
     * ### Transition Aliases (`:enter` and `:leave`)
     *
     * Given that enter (insertion) and leave (removal) animations are so common,
     * the `transition` function accepts both `:enter` and `:leave` values which
     * are aliases for the `void => *` and `* => void` state changes.
     *
     * ```
     * transition(":enter", [
     *   style({ opacity: 0 }),
     *   animate(500, style({ opacity: 1 }))
     * ])
     * transition(":leave", [
     *   animate(500, style({ opacity: 0 }))
     * ])
     * ```
     *
     * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
     *
     * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
     *
     * @experimental Animation support is experimental.
     */
    function transition(stateChangeExpr, steps) {
        var animationData = Array.isArray(steps) ? new AnimationSequenceMetadata(steps) : steps;
        return new AnimationStateTransitionMetadata(stateChangeExpr, animationData);
    }
    /**
     * `trigger` is an animation-specific function that is designed to be used inside of Angular2's
     * animation
     * DSL language. If this information is new, please navigate to the
     * {@link Component#animations-anchor component animations metadata
     * page} to gain a better understanding of how animations in Angular2 are used.
     *
     * `trigger` Creates an animation trigger which will a list of {@link state state} and {@link
     * transition transition}
     * entries that will be evaluated when the expression bound to the trigger changes.
     *
     * Triggers are registered within the component annotation data under the
     * {@link Component#animations-anchor animations section}. An animation trigger can
     * be placed on an element within a template by referencing the name of the
     * trigger followed by the expression value that the trigger is bound to
     * (in the form of `[@triggerName]="expression"`.
     *
     * ### Usage
     *
     * `trigger` will create an animation trigger reference based on the provided `name` value.
     * The provided `animation` value is expected to be an array consisting of {@link state state} and
     * {@link transition transition}
     * declarations.
     *
     * ```typescript
     * @Component({
     *   selector: 'my-component',
     *   templateUrl: 'my-component-tpl.html',
     *   animations: [
     *     trigger("myAnimationTrigger", [
     *       state(...),
     *       state(...),
     *       transition(...),
     *       transition(...)
     *     ])
     *   ]
     * })
     * class MyComponent {
     *   myStatusExp = "something";
     * }
     * ```
     *
     * The template associated with this component will make use of the `myAnimationTrigger`
     * animation trigger by binding to an element within its template code.
     *
     * ```html
     * <!-- somewhere inside of my-component-tpl.html -->
     * <div [@myAnimationTrigger]="myStatusExp">...</div>
     * ```
     *
     * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
     *
     * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
     *
     * @experimental Animation support is experimental.
     */
    function trigger(name, animation) {
        return new AnimationEntryMetadata(name, animation);
    }

    function prepareFinalAnimationStyles(previousStyles, newStyles, nullValue) {
        if (nullValue === void 0) { nullValue = null; }
        var finalStyles = {};
        Object.keys(newStyles).forEach(function (prop) {
            var value = newStyles[prop];
            finalStyles[prop] = value == AUTO_STYLE ? nullValue : value.toString();
        });
        Object.keys(previousStyles).forEach(function (prop) {
            if (!isPresent(finalStyles[prop])) {
                finalStyles[prop] = nullValue;
            }
        });
        return finalStyles;
    }
    function balanceAnimationKeyframes(collectedStyles, finalStateStyles, keyframes) {
        var limit = keyframes.length - 1;
        var firstKeyframe = keyframes[0];
        // phase 1: copy all the styles from the first keyframe into the lookup map
        var flatenedFirstKeyframeStyles = flattenStyles(firstKeyframe.styles.styles);
        var extraFirstKeyframeStyles = {};
        var hasExtraFirstStyles = false;
        Object.keys(collectedStyles).forEach(function (prop) {
            var value = collectedStyles[prop];
            // if the style is already defined in the first keyframe then
            // we do not replace it.
            if (!flatenedFirstKeyframeStyles[prop]) {
                flatenedFirstKeyframeStyles[prop] = value;
                extraFirstKeyframeStyles[prop] = value;
                hasExtraFirstStyles = true;
            }
        });
        var keyframeCollectedStyles = StringMapWrapper.merge({}, flatenedFirstKeyframeStyles);
        // phase 2: normalize the final keyframe
        var finalKeyframe = keyframes[limit];
        ListWrapper.insert(finalKeyframe.styles.styles, 0, finalStateStyles);
        var flatenedFinalKeyframeStyles = flattenStyles(finalKeyframe.styles.styles);
        var extraFinalKeyframeStyles = {};
        var hasExtraFinalStyles = false;
        Object.keys(keyframeCollectedStyles).forEach(function (prop) {
            if (!isPresent(flatenedFinalKeyframeStyles[prop])) {
                extraFinalKeyframeStyles[prop] = AUTO_STYLE;
                hasExtraFinalStyles = true;
            }
        });
        if (hasExtraFinalStyles) {
            finalKeyframe.styles.styles.push(extraFinalKeyframeStyles);
        }
        Object.keys(flatenedFinalKeyframeStyles).forEach(function (prop) {
            if (!isPresent(flatenedFirstKeyframeStyles[prop])) {
                extraFirstKeyframeStyles[prop] = AUTO_STYLE;
                hasExtraFirstStyles = true;
            }
        });
        if (hasExtraFirstStyles) {
            firstKeyframe.styles.styles.push(extraFirstKeyframeStyles);
        }
        return keyframes;
    }
    function clearStyles(styles) {
        var finalStyles = {};
        Object.keys(styles).forEach(function (key) { finalStyles[key] = null; });
        return finalStyles;
    }
    function collectAndResolveStyles(collection, styles) {
        return styles.map(function (entry) {
            var stylesObj = {};
            Object.keys(entry).forEach(function (prop) {
                var value = entry[prop];
                if (value == FILL_STYLE_FLAG) {
                    value = collection[prop];
                    if (!isPresent(value)) {
                        value = AUTO_STYLE;
                    }
                }
                collection[prop] = value;
                stylesObj[prop] = value;
            });
            return stylesObj;
        });
    }
    function renderStyles(element, renderer, styles) {
        Object.keys(styles).forEach(function (prop) { renderer.setElementStyle(element, prop, styles[prop]); });
    }
    function flattenStyles(styles) {
        var finalStyles = {};
        styles.forEach(function (entry) {
            Object.keys(entry).forEach(function (prop) { finalStyles[prop] = entry[prop]; });
        });
        return finalStyles;
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var AnimationStyles = (function () {
        function AnimationStyles(styles) {
            this.styles = styles;
        }
        return AnimationStyles;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * An instance of this class is returned as an event parameter when an animation
     * callback is captured for an animation either during the start or done phase.
     *
     * ```typescript
     * @Component({
     *   host: {
     *     '[@myAnimationTrigger]': 'someExpression',
     *     '(@myAnimationTrigger.start)': 'captureStartEvent($event)',
     *     '(@myAnimationTrigger.done)': 'captureDoneEvent($event)',
     *   },
     *   animations: [
     *     trigger("myAnimationTrigger", [
     *        // ...
     *     ])
     *   ]
     * })
     * class MyComponent {
     *   someExpression: any = false;
     *   captureStartEvent(event: AnimationTransitionEvent) {
     *     // the toState, fromState and totalTime data is accessible from the event variable
     *   }
     *
     *   captureDoneEvent(event: AnimationTransitionEvent) {
     *     // the toState, fromState and totalTime data is accessible from the event variable
     *   }
     * }
     * ```
     *
     * @experimental Animation support is experimental.
     */
    var AnimationTransitionEvent = (function () {
        function AnimationTransitionEvent(_a) {
            var fromState = _a.fromState, toState = _a.toState, totalTime = _a.totalTime, phaseName = _a.phaseName;
            this.fromState = fromState;
            this.toState = toState;
            this.totalTime = totalTime;
            this.phaseName = phaseName;
        }
        return AnimationTransitionEvent;
    }());

    var AnimationTransition = (function () {
        function AnimationTransition(_player, _fromState, _toState, _totalTime) {
            this._player = _player;
            this._fromState = _fromState;
            this._toState = _toState;
            this._totalTime = _totalTime;
        }
        AnimationTransition.prototype._createEvent = function (phaseName) {
            return new AnimationTransitionEvent({
                fromState: this._fromState,
                toState: this._toState,
                totalTime: this._totalTime,
                phaseName: phaseName
            });
        };
        AnimationTransition.prototype.onStart = function (callback) {
            var event = this._createEvent('start');
            this._player.onStart(function () { return callback(event); });
        };
        AnimationTransition.prototype.onDone = function (callback) {
            var event = this._createEvent('done');
            this._player.onDone(function () { return callback(event); });
        };
        return AnimationTransition;
    }());

    var DebugDomRootRenderer = (function () {
        function DebugDomRootRenderer(_delegate) {
            this._delegate = _delegate;
        }
        DebugDomRootRenderer.prototype.renderComponent = function (componentProto) {
            return new DebugDomRenderer(this._delegate.renderComponent(componentProto));
        };
        return DebugDomRootRenderer;
    }());
    var DebugDomRenderer = (function () {
        function DebugDomRenderer(_delegate) {
            this._delegate = _delegate;
        }
        DebugDomRenderer.prototype.selectRootElement = function (selectorOrNode, debugInfo) {
            var nativeEl = this._delegate.selectRootElement(selectorOrNode, debugInfo);
            var debugEl = new DebugElement(nativeEl, null, debugInfo);
            indexDebugNode(debugEl);
            return nativeEl;
        };
        DebugDomRenderer.prototype.createElement = function (parentElement, name, debugInfo) {
            var nativeEl = this._delegate.createElement(parentElement, name, debugInfo);
            var debugEl = new DebugElement(nativeEl, getDebugNode(parentElement), debugInfo);
            debugEl.name = name;
            indexDebugNode(debugEl);
            return nativeEl;
        };
        DebugDomRenderer.prototype.createViewRoot = function (hostElement) { return this._delegate.createViewRoot(hostElement); };
        DebugDomRenderer.prototype.createTemplateAnchor = function (parentElement, debugInfo) {
            var comment = this._delegate.createTemplateAnchor(parentElement, debugInfo);
            var debugEl = new DebugNode(comment, getDebugNode(parentElement), debugInfo);
            indexDebugNode(debugEl);
            return comment;
        };
        DebugDomRenderer.prototype.createText = function (parentElement, value, debugInfo) {
            var text = this._delegate.createText(parentElement, value, debugInfo);
            var debugEl = new DebugNode(text, getDebugNode(parentElement), debugInfo);
            indexDebugNode(debugEl);
            return text;
        };
        DebugDomRenderer.prototype.projectNodes = function (parentElement, nodes) {
            var debugParent = getDebugNode(parentElement);
            if (isPresent(debugParent) && debugParent instanceof DebugElement) {
                var debugElement_1 = debugParent;
                nodes.forEach(function (node) { debugElement_1.addChild(getDebugNode(node)); });
            }
            this._delegate.projectNodes(parentElement, nodes);
        };
        DebugDomRenderer.prototype.attachViewAfter = function (node, viewRootNodes) {
            var debugNode = getDebugNode(node);
            if (isPresent(debugNode)) {
                var debugParent = debugNode.parent;
                if (viewRootNodes.length > 0 && isPresent(debugParent)) {
                    var debugViewRootNodes = [];
                    viewRootNodes.forEach(function (rootNode) { return debugViewRootNodes.push(getDebugNode(rootNode)); });
                    debugParent.insertChildrenAfter(debugNode, debugViewRootNodes);
                }
            }
            this._delegate.attachViewAfter(node, viewRootNodes);
        };
        DebugDomRenderer.prototype.detachView = function (viewRootNodes) {
            viewRootNodes.forEach(function (node) {
                var debugNode = getDebugNode(node);
                if (isPresent(debugNode) && isPresent(debugNode.parent)) {
                    debugNode.parent.removeChild(debugNode);
                }
            });
            this._delegate.detachView(viewRootNodes);
        };
        DebugDomRenderer.prototype.destroyView = function (hostElement, viewAllNodes) {
            viewAllNodes.forEach(function (node) { removeDebugNodeFromIndex(getDebugNode(node)); });
            this._delegate.destroyView(hostElement, viewAllNodes);
        };
        DebugDomRenderer.prototype.listen = function (renderElement, name, callback) {
            var debugEl = getDebugNode(renderElement);
            if (isPresent(debugEl)) {
                debugEl.listeners.push(new EventListener(name, callback));
            }
            return this._delegate.listen(renderElement, name, callback);
        };
        DebugDomRenderer.prototype.listenGlobal = function (target, name, callback) {
            return this._delegate.listenGlobal(target, name, callback);
        };
        DebugDomRenderer.prototype.setElementProperty = function (renderElement, propertyName, propertyValue) {
            var debugEl = getDebugNode(renderElement);
            if (isPresent(debugEl) && debugEl instanceof DebugElement) {
                debugEl.properties[propertyName] = propertyValue;
            }
            this._delegate.setElementProperty(renderElement, propertyName, propertyValue);
        };
        DebugDomRenderer.prototype.setElementAttribute = function (renderElement, attributeName, attributeValue) {
            var debugEl = getDebugNode(renderElement);
            if (isPresent(debugEl) && debugEl instanceof DebugElement) {
                debugEl.attributes[attributeName] = attributeValue;
            }
            this._delegate.setElementAttribute(renderElement, attributeName, attributeValue);
        };
        DebugDomRenderer.prototype.setBindingDebugInfo = function (renderElement, propertyName, propertyValue) {
            this._delegate.setBindingDebugInfo(renderElement, propertyName, propertyValue);
        };
        DebugDomRenderer.prototype.setElementClass = function (renderElement, className, isAdd) {
            var debugEl = getDebugNode(renderElement);
            if (isPresent(debugEl) && debugEl instanceof DebugElement) {
                debugEl.classes[className] = isAdd;
            }
            this._delegate.setElementClass(renderElement, className, isAdd);
        };
        DebugDomRenderer.prototype.setElementStyle = function (renderElement, styleName, styleValue) {
            var debugEl = getDebugNode(renderElement);
            if (isPresent(debugEl) && debugEl instanceof DebugElement) {
                debugEl.styles[styleName] = styleValue;
            }
            this._delegate.setElementStyle(renderElement, styleName, styleValue);
        };
        DebugDomRenderer.prototype.invokeElementMethod = function (renderElement, methodName, args) {
            this._delegate.invokeElementMethod(renderElement, methodName, args);
        };
        DebugDomRenderer.prototype.setText = function (renderNode, text) { this._delegate.setText(renderNode, text); };
        DebugDomRenderer.prototype.animate = function (element, startingStyles, keyframes, duration, delay, easing) {
            return this._delegate.animate(element, startingStyles, keyframes, duration, delay, easing);
        };
        return DebugDomRenderer;
    }());

    var StaticNodeDebugInfo = (function () {
        function StaticNodeDebugInfo(providerTokens, componentToken, refTokens) {
            this.providerTokens = providerTokens;
            this.componentToken = componentToken;
            this.refTokens = refTokens;
        }
        return StaticNodeDebugInfo;
    }());
    var DebugContext = (function () {
        function DebugContext(_view, _nodeIndex, _tplRow, _tplCol) {
            this._view = _view;
            this._nodeIndex = _nodeIndex;
            this._tplRow = _tplRow;
            this._tplCol = _tplCol;
        }
        Object.defineProperty(DebugContext.prototype, "_staticNodeInfo", {
            get: function () {
                return isPresent(this._nodeIndex) ? this._view.staticNodeDebugInfos[this._nodeIndex] : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DebugContext.prototype, "context", {
            get: function () { return this._view.context; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DebugContext.prototype, "component", {
            get: function () {
                var staticNodeInfo = this._staticNodeInfo;
                if (isPresent(staticNodeInfo) && isPresent(staticNodeInfo.componentToken)) {
                    return this.injector.get(staticNodeInfo.componentToken);
                }
                return null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DebugContext.prototype, "componentRenderElement", {
            get: function () {
                var componentView = this._view;
                while (isPresent(componentView.declarationAppElement) &&
                    componentView.type !== ViewType.COMPONENT) {
                    componentView = componentView.declarationAppElement.parentView;
                }
                return isPresent(componentView.declarationAppElement) ?
                    componentView.declarationAppElement.nativeElement :
                    null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DebugContext.prototype, "injector", {
            get: function () { return this._view.injector(this._nodeIndex); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DebugContext.prototype, "renderNode", {
            get: function () {
                if (isPresent(this._nodeIndex) && this._view.allNodes) {
                    return this._view.allNodes[this._nodeIndex];
                }
                else {
                    return null;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DebugContext.prototype, "providerTokens", {
            get: function () {
                var staticNodeInfo = this._staticNodeInfo;
                return isPresent(staticNodeInfo) ? staticNodeInfo.providerTokens : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DebugContext.prototype, "source", {
            get: function () {
                return this._view.componentType.templateUrl + ":" + this._tplRow + ":" + this._tplCol;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DebugContext.prototype, "references", {
            get: function () {
                var _this = this;
                var varValues = {};
                var staticNodeInfo = this._staticNodeInfo;
                if (isPresent(staticNodeInfo)) {
                    var refs = staticNodeInfo.refTokens;
                    Object.keys(refs).forEach(function (refName) {
                        var refToken = refs[refName];
                        var varValue;
                        if (isBlank(refToken)) {
                            varValue = _this._view.allNodes ? _this._view.allNodes[_this._nodeIndex] : null;
                        }
                        else {
                            varValue = _this._view.injectorGet(refToken, _this._nodeIndex, null);
                        }
                        varValues[refName] = varValue;
                    });
                }
                return varValues;
            },
            enumerable: true,
            configurable: true
        });
        return DebugContext;
    }());

    var ViewAnimationMap = (function () {
        function ViewAnimationMap() {
            this._map = new Map();
            this._allPlayers = [];
        }
        ViewAnimationMap.prototype.find = function (element, animationName) {
            var playersByAnimation = this._map.get(element);
            if (isPresent(playersByAnimation)) {
                return playersByAnimation[animationName];
            }
        };
        ViewAnimationMap.prototype.findAllPlayersByElement = function (element) {
            var el = this._map.get(element);
            return el ? Object.keys(el).map(function (k) { return el[k]; }) : [];
        };
        ViewAnimationMap.prototype.set = function (element, animationName, player) {
            var playersByAnimation = this._map.get(element);
            if (!isPresent(playersByAnimation)) {
                playersByAnimation = {};
            }
            var existingEntry = playersByAnimation[animationName];
            if (isPresent(existingEntry)) {
                this.remove(element, animationName);
            }
            playersByAnimation[animationName] = player;
            this._allPlayers.push(player);
            this._map.set(element, playersByAnimation);
        };
        ViewAnimationMap.prototype.getAllPlayers = function () { return this._allPlayers; };
        ViewAnimationMap.prototype.remove = function (element, animationName) {
            var playersByAnimation = this._map.get(element);
            if (playersByAnimation) {
                var player = playersByAnimation[animationName];
                delete playersByAnimation[animationName];
                var index = this._allPlayers.indexOf(player);
                this._allPlayers.splice(index, 1);
                if (Object.keys(playersByAnimation).length === 0) {
                    this._map.delete(element);
                }
            }
        };
        return ViewAnimationMap;
    }());

    var AnimationViewContext = (function () {
        function AnimationViewContext() {
            this._players = new ViewAnimationMap();
        }
        AnimationViewContext.prototype.onAllActiveAnimationsDone = function (callback) {
            var activeAnimationPlayers = this._players.getAllPlayers();
            // we check for the length to avoid having GroupAnimationPlayer
            // issue an unnecessary microtask when zero players are passed in
            if (activeAnimationPlayers.length) {
                new AnimationGroupPlayer(activeAnimationPlayers).onDone(function () { return callback(); });
            }
            else {
                callback();
            }
        };
        AnimationViewContext.prototype.queueAnimation = function (element, animationName, player) {
            queueAnimationGlobally(player);
            this._players.set(element, animationName, player);
        };
        AnimationViewContext.prototype.cancelActiveAnimation = function (element, animationName, removeAllAnimations) {
            if (removeAllAnimations === void 0) { removeAllAnimations = false; }
            if (removeAllAnimations) {
                this._players.findAllPlayersByElement(element).forEach(function (player) { return player.destroy(); });
            }
            else {
                var player = this._players.find(element, animationName);
                if (player) {
                    player.destroy();
                }
            }
        };
        return AnimationViewContext;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$15 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var _UNDEFINED$1 = new Object();
    var ElementInjector = (function (_super) {
        __extends$15(ElementInjector, _super);
        function ElementInjector(_view, _nodeIndex) {
            _super.call(this);
            this._view = _view;
            this._nodeIndex = _nodeIndex;
        }
        ElementInjector.prototype.get = function (token, notFoundValue) {
            if (notFoundValue === void 0) { notFoundValue = THROW_IF_NOT_FOUND; }
            var result = _UNDEFINED$1;
            if (result === _UNDEFINED$1) {
                result = this._view.injectorGet(token, this._nodeIndex, _UNDEFINED$1);
            }
            if (result === _UNDEFINED$1) {
                result = this._view.parentInjector.get(token, notFoundValue);
            }
            return result;
        };
        return ElementInjector;
    }(Injector));

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$14 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var _scope_check = wtfCreateScope("AppView#check(ascii id)");
    /**
     * Cost of making objects: http://jsperf.com/instantiate-size-of-object
     *
     */
    var AppView = (function () {
        function AppView(clazz, componentType, type, viewUtils, parentInjector, declarationAppElement, cdMode) {
            this.clazz = clazz;
            this.componentType = componentType;
            this.type = type;
            this.viewUtils = viewUtils;
            this.parentInjector = parentInjector;
            this.declarationAppElement = declarationAppElement;
            this.cdMode = cdMode;
            this.contentChildren = [];
            this.viewChildren = [];
            this.viewContainerElement = null;
            this.numberOfChecks = 0;
            this.ref = new ViewRef_(this);
            if (type === ViewType.COMPONENT || type === ViewType.HOST) {
                this.renderer = viewUtils.renderComponent(componentType);
            }
            else {
                this.renderer = declarationAppElement.parentView.renderer;
            }
        }
        Object.defineProperty(AppView.prototype, "animationContext", {
            get: function () {
                if (!this._animationContext) {
                    this._animationContext = new AnimationViewContext();
                }
                return this._animationContext;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AppView.prototype, "destroyed", {
            get: function () { return this.cdMode === ChangeDetectorStatus.Destroyed; },
            enumerable: true,
            configurable: true
        });
        AppView.prototype.create = function (context, givenProjectableNodes, rootSelectorOrNode) {
            this.context = context;
            var projectableNodes;
            switch (this.type) {
                case ViewType.COMPONENT:
                    projectableNodes = ensureSlotCount(givenProjectableNodes, this.componentType.slotCount);
                    break;
                case ViewType.EMBEDDED:
                    projectableNodes = this.declarationAppElement.parentView.projectableNodes;
                    break;
                case ViewType.HOST:
                    // Note: Don't ensure the slot count for the projectableNodes as we store
                    // them only for the contained component view (which will later check the slot count...)
                    projectableNodes = givenProjectableNodes;
                    break;
            }
            this._hasExternalHostElement = isPresent(rootSelectorOrNode);
            this.projectableNodes = projectableNodes;
            return this.createInternal(rootSelectorOrNode);
        };
        /**
         * Overwritten by implementations.
         * Returns the AppElement for the host element for ViewType.HOST.
         */
        AppView.prototype.createInternal = function (rootSelectorOrNode) { return null; };
        AppView.prototype.init = function (rootNodesOrAppElements, allNodes, disposables, subscriptions) {
            this.rootNodesOrAppElements = rootNodesOrAppElements;
            this.allNodes = allNodes;
            this.disposables = disposables;
            this.subscriptions = subscriptions;
            if (this.type === ViewType.COMPONENT) {
                // Note: the render nodes have been attached to their host element
                // in the ViewFactory already.
                this.declarationAppElement.parentView.viewChildren.push(this);
                this.dirtyParentQueriesInternal();
            }
        };
        AppView.prototype.selectOrCreateHostElement = function (elementName, rootSelectorOrNode, debugInfo) {
            var hostElement;
            if (isPresent(rootSelectorOrNode)) {
                hostElement = this.renderer.selectRootElement(rootSelectorOrNode, debugInfo);
            }
            else {
                hostElement = this.renderer.createElement(null, elementName, debugInfo);
            }
            return hostElement;
        };
        AppView.prototype.injectorGet = function (token, nodeIndex, notFoundResult) {
            return this.injectorGetInternal(token, nodeIndex, notFoundResult);
        };
        /**
         * Overwritten by implementations
         */
        AppView.prototype.injectorGetInternal = function (token, nodeIndex, notFoundResult) {
            return notFoundResult;
        };
        AppView.prototype.injector = function (nodeIndex) {
            if (isPresent(nodeIndex)) {
                return new ElementInjector(this, nodeIndex);
            }
            else {
                return this.parentInjector;
            }
        };
        AppView.prototype.destroy = function () {
            if (this._hasExternalHostElement) {
                this.renderer.detachView(this.flatRootNodes);
            }
            else if (isPresent(this.viewContainerElement)) {
                this.viewContainerElement.detachView(this.viewContainerElement.nestedViews.indexOf(this));
            }
            this._destroyRecurse();
        };
        AppView.prototype._destroyRecurse = function () {
            if (this.cdMode === ChangeDetectorStatus.Destroyed) {
                return;
            }
            var children = this.contentChildren;
            for (var i = 0; i < children.length; i++) {
                children[i]._destroyRecurse();
            }
            children = this.viewChildren;
            for (var i = 0; i < children.length; i++) {
                children[i]._destroyRecurse();
            }
            this.destroyLocal();
            this.cdMode = ChangeDetectorStatus.Destroyed;
        };
        AppView.prototype.destroyLocal = function () {
            var _this = this;
            var hostElement = this.type === ViewType.COMPONENT ? this.declarationAppElement.nativeElement : null;
            for (var i = 0; i < this.disposables.length; i++) {
                this.disposables[i]();
            }
            for (var i = 0; i < this.subscriptions.length; i++) {
                this.subscriptions[i].unsubscribe();
            }
            this.destroyInternal();
            this.dirtyParentQueriesInternal();
            if (this._animationContext) {
                this._animationContext.onAllActiveAnimationsDone(function () { return _this.renderer.destroyView(hostElement, _this.allNodes); });
            }
            else {
                this.renderer.destroyView(hostElement, this.allNodes);
            }
        };
        /**
         * Overwritten by implementations
         */
        AppView.prototype.destroyInternal = function () { };
        /**
         * Overwritten by implementations
         */
        AppView.prototype.detachInternal = function () { };
        AppView.prototype.detach = function () {
            var _this = this;
            this.detachInternal();
            if (this._animationContext) {
                this._animationContext.onAllActiveAnimationsDone(function () { return _this.renderer.detachView(_this.flatRootNodes); });
            }
            else {
                this.renderer.detachView(this.flatRootNodes);
            }
        };
        Object.defineProperty(AppView.prototype, "changeDetectorRef", {
            get: function () { return this.ref; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AppView.prototype, "parent", {
            get: function () {
                return isPresent(this.declarationAppElement) ? this.declarationAppElement.parentView : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AppView.prototype, "flatRootNodes", {
            get: function () { return flattenNestedViewRenderNodes(this.rootNodesOrAppElements); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AppView.prototype, "lastRootNode", {
            get: function () {
                var lastNode = this.rootNodesOrAppElements.length > 0 ?
                    this.rootNodesOrAppElements[this.rootNodesOrAppElements.length - 1] :
                    null;
                return _findLastRenderNode(lastNode);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Overwritten by implementations
         */
        AppView.prototype.dirtyParentQueriesInternal = function () { };
        AppView.prototype.detectChanges = function (throwOnChange) {
            var s = _scope_check(this.clazz);
            if (this.cdMode === ChangeDetectorStatus.Checked ||
                this.cdMode === ChangeDetectorStatus.Errored)
                return;
            if (this.cdMode === ChangeDetectorStatus.Destroyed) {
                this.throwDestroyedError('detectChanges');
            }
            this.detectChangesInternal(throwOnChange);
            if (this.cdMode === ChangeDetectorStatus.CheckOnce)
                this.cdMode = ChangeDetectorStatus.Checked;
            this.numberOfChecks++;
            wtfLeave(s);
        };
        /**
         * Overwritten by implementations
         */
        AppView.prototype.detectChangesInternal = function (throwOnChange) {
            this.detectContentChildrenChanges(throwOnChange);
            this.detectViewChildrenChanges(throwOnChange);
        };
        AppView.prototype.detectContentChildrenChanges = function (throwOnChange) {
            for (var i = 0; i < this.contentChildren.length; ++i) {
                var child = this.contentChildren[i];
                if (child.cdMode === ChangeDetectorStatus.Detached)
                    continue;
                child.detectChanges(throwOnChange);
            }
        };
        AppView.prototype.detectViewChildrenChanges = function (throwOnChange) {
            for (var i = 0; i < this.viewChildren.length; ++i) {
                var child = this.viewChildren[i];
                if (child.cdMode === ChangeDetectorStatus.Detached)
                    continue;
                child.detectChanges(throwOnChange);
            }
        };
        AppView.prototype.markContentChildAsMoved = function (renderAppElement) { this.dirtyParentQueriesInternal(); };
        AppView.prototype.addToContentChildren = function (renderAppElement) {
            renderAppElement.parentView.contentChildren.push(this);
            this.viewContainerElement = renderAppElement;
            this.dirtyParentQueriesInternal();
        };
        AppView.prototype.removeFromContentChildren = function (renderAppElement) {
            ListWrapper.remove(renderAppElement.parentView.contentChildren, this);
            this.dirtyParentQueriesInternal();
            this.viewContainerElement = null;
        };
        AppView.prototype.markAsCheckOnce = function () { this.cdMode = ChangeDetectorStatus.CheckOnce; };
        AppView.prototype.markPathToRootAsCheckOnce = function () {
            var c = this;
            while (isPresent(c) && c.cdMode !== ChangeDetectorStatus.Detached) {
                if (c.cdMode === ChangeDetectorStatus.Checked) {
                    c.cdMode = ChangeDetectorStatus.CheckOnce;
                }
                var parentEl = c.type === ViewType.COMPONENT ? c.declarationAppElement : c.viewContainerElement;
                c = isPresent(parentEl) ? parentEl.parentView : null;
            }
        };
        AppView.prototype.eventHandler = function (cb) { return cb; };
        AppView.prototype.throwDestroyedError = function (details) { throw new ViewDestroyedError(details); };
        return AppView;
    }());
    var DebugAppView = (function (_super) {
        __extends$14(DebugAppView, _super);
        function DebugAppView(clazz, componentType, type, viewUtils, parentInjector, declarationAppElement, cdMode, staticNodeDebugInfos) {
            _super.call(this, clazz, componentType, type, viewUtils, parentInjector, declarationAppElement, cdMode);
            this.staticNodeDebugInfos = staticNodeDebugInfos;
            this._currentDebugContext = null;
        }
        DebugAppView.prototype.create = function (context, givenProjectableNodes, rootSelectorOrNode) {
            this._resetDebug();
            try {
                return _super.prototype.create.call(this, context, givenProjectableNodes, rootSelectorOrNode);
            }
            catch (e) {
                this._rethrowWithContext(e);
                throw e;
            }
        };
        DebugAppView.prototype.injectorGet = function (token, nodeIndex, notFoundResult) {
            this._resetDebug();
            try {
                return _super.prototype.injectorGet.call(this, token, nodeIndex, notFoundResult);
            }
            catch (e) {
                this._rethrowWithContext(e);
                throw e;
            }
        };
        DebugAppView.prototype.detach = function () {
            this._resetDebug();
            try {
                _super.prototype.detach.call(this);
            }
            catch (e) {
                this._rethrowWithContext(e);
                throw e;
            }
        };
        DebugAppView.prototype.destroyLocal = function () {
            this._resetDebug();
            try {
                _super.prototype.destroyLocal.call(this);
            }
            catch (e) {
                this._rethrowWithContext(e);
                throw e;
            }
        };
        DebugAppView.prototype.detectChanges = function (throwOnChange) {
            this._resetDebug();
            try {
                _super.prototype.detectChanges.call(this, throwOnChange);
            }
            catch (e) {
                this._rethrowWithContext(e);
                throw e;
            }
        };
        DebugAppView.prototype._resetDebug = function () { this._currentDebugContext = null; };
        DebugAppView.prototype.debug = function (nodeIndex, rowNum, colNum) {
            return this._currentDebugContext = new DebugContext(this, nodeIndex, rowNum, colNum);
        };
        DebugAppView.prototype._rethrowWithContext = function (e) {
            if (!(e instanceof ViewWrappedError)) {
                if (!(e instanceof ExpressionChangedAfterItHasBeenCheckedError)) {
                    this.cdMode = ChangeDetectorStatus.Errored;
                }
                if (isPresent(this._currentDebugContext)) {
                    throw new ViewWrappedError(e, this._currentDebugContext);
                }
            }
        };
        DebugAppView.prototype.eventHandler = function (cb) {
            var _this = this;
            var superHandler = _super.prototype.eventHandler.call(this, cb);
            return function (event) {
                _this._resetDebug();
                try {
                    return superHandler(event);
                }
                catch (e) {
                    _this._rethrowWithContext(e);
                    throw e;
                }
            };
        };
        return DebugAppView;
    }(AppView));
    function _findLastRenderNode(node) {
        var lastNode;
        if (node instanceof AppElement) {
            var appEl = node;
            lastNode = appEl.nativeElement;
            if (isPresent(appEl.nestedViews)) {
                // Note: Views might have no root nodes at all!
                for (var i = appEl.nestedViews.length - 1; i >= 0; i--) {
                    var nestedView = appEl.nestedViews[i];
                    if (nestedView.rootNodesOrAppElements.length > 0) {
                        lastNode = _findLastRenderNode(nestedView.rootNodesOrAppElements[nestedView.rootNodesOrAppElements.length - 1]);
                    }
                }
            }
        }
        else {
            lastNode = node;
        }
        return lastNode;
    }

    var __core_private__ = {
        isDefaultChangeDetectionStrategy: isDefaultChangeDetectionStrategy,
        ChangeDetectorStatus: ChangeDetectorStatus,
        constructDependencies: constructDependencies,
        LifecycleHooks: LifecycleHooks,
        LIFECYCLE_HOOKS_VALUES: LIFECYCLE_HOOKS_VALUES,
        ReflectorReader: ReflectorReader,
        CodegenComponentFactoryResolver: CodegenComponentFactoryResolver,
        AppElement: AppElement,
        AppView: AppView,
        DebugAppView: DebugAppView,
        NgModuleInjector: NgModuleInjector,
        registerModuleFactory: registerModuleFactory,
        ViewType: ViewType,
        view_utils: view_utils,
        ViewMetadata: ViewMetadata,
        DebugContext: DebugContext,
        StaticNodeDebugInfo: StaticNodeDebugInfo,
        devModeEqual: devModeEqual,
        UNINITIALIZED: UNINITIALIZED,
        ValueUnwrapper: ValueUnwrapper,
        RenderDebugInfo: RenderDebugInfo,
        TemplateRef_: TemplateRef_,
        ReflectionCapabilities: ReflectionCapabilities,
        makeDecorator: makeDecorator,
        DebugDomRootRenderer: DebugDomRootRenderer,
        Console: Console,
        reflector: reflector,
        Reflector: Reflector,
        NoOpAnimationPlayer: NoOpAnimationPlayer,
        AnimationPlayer: AnimationPlayer,
        AnimationSequencePlayer: AnimationSequencePlayer,
        AnimationGroupPlayer: AnimationGroupPlayer,
        AnimationKeyframe: AnimationKeyframe,
        prepareFinalAnimationStyles: prepareFinalAnimationStyles,
        balanceAnimationKeyframes: balanceAnimationKeyframes,
        flattenStyles: flattenStyles,
        clearStyles: clearStyles,
        renderStyles: renderStyles,
        collectAndResolveStyles: collectAndResolveStyles,
        AnimationStyles: AnimationStyles,
        ANY_STATE: ANY_STATE,
        DEFAULT_STATE: DEFAULT_STATE,
        EMPTY_STATE: EMPTY_STATE,
        FILL_STYLE_FLAG: FILL_STYLE_FLAG,
        ComponentStillLoadingError: ComponentStillLoadingError,
        isPromise: isPromise,
        AnimationTransition: AnimationTransition
    };

    exports.createPlatform = createPlatform;
    exports.assertPlatform = assertPlatform;
    exports.destroyPlatform = destroyPlatform;
    exports.getPlatform = getPlatform;
    exports.PlatformRef = PlatformRef;
    exports.ApplicationRef = ApplicationRef;
    exports.enableProdMode = enableProdMode;
    exports.isDevMode = isDevMode;
    exports.createPlatformFactory = createPlatformFactory;
    exports.APP_ID = APP_ID;
    exports.PACKAGE_ROOT_URL = PACKAGE_ROOT_URL;
    exports.PLATFORM_INITIALIZER = PLATFORM_INITIALIZER;
    exports.APP_BOOTSTRAP_LISTENER = APP_BOOTSTRAP_LISTENER;
    exports.APP_INITIALIZER = APP_INITIALIZER;
    exports.ApplicationInitStatus = ApplicationInitStatus;
    exports.DebugElement = DebugElement;
    exports.DebugNode = DebugNode;
    exports.asNativeElements = asNativeElements;
    exports.getDebugNode = getDebugNode;
    exports.Testability = Testability;
    exports.TestabilityRegistry = TestabilityRegistry;
    exports.setTestabilityGetter = setTestabilityGetter;
    exports.TRANSLATIONS = TRANSLATIONS;
    exports.TRANSLATIONS_FORMAT = TRANSLATIONS_FORMAT;
    exports.LOCALE_ID = LOCALE_ID;
    exports.ApplicationModule = ApplicationModule;
    exports.wtfCreateScope = wtfCreateScope;
    exports.wtfLeave = wtfLeave;
    exports.wtfStartTimeRange = wtfStartTimeRange;
    exports.wtfEndTimeRange = wtfEndTimeRange;
    exports.Type = Type;
    exports.EventEmitter = EventEmitter;
    exports.ErrorHandler = ErrorHandler;
    exports.AnimationTransitionEvent = AnimationTransitionEvent;
    exports.AnimationPlayer = AnimationPlayer;
    exports.Sanitizer = Sanitizer;
    exports.ANALYZE_FOR_ENTRY_COMPONENTS = ANALYZE_FOR_ENTRY_COMPONENTS;
    exports.Attribute = Attribute;
    exports.ContentChild = ContentChild;
    exports.ContentChildren = ContentChildren;
    exports.Query = Query;
    exports.ViewChild = ViewChild;
    exports.ViewChildren = ViewChildren;
    exports.Component = Component;
    exports.Directive = Directive;
    exports.HostBinding = HostBinding;
    exports.HostListener = HostListener;
    exports.Input = Input;
    exports.Output = Output;
    exports.Pipe = Pipe;
    exports.AfterContentChecked = AfterContentChecked;
    exports.AfterContentInit = AfterContentInit;
    exports.AfterViewChecked = AfterViewChecked;
    exports.AfterViewInit = AfterViewInit;
    exports.DoCheck = DoCheck;
    exports.OnChanges = OnChanges;
    exports.OnDestroy = OnDestroy;
    exports.OnInit = OnInit;
    exports.CUSTOM_ELEMENTS_SCHEMA = CUSTOM_ELEMENTS_SCHEMA;
    exports.NO_ERRORS_SCHEMA = NO_ERRORS_SCHEMA;
    exports.NgModule = NgModule;
    exports.Class = Class;
    exports.forwardRef = forwardRef;
    exports.resolveForwardRef = resolveForwardRef;
    exports.Injector = Injector;
    exports.ReflectiveInjector = ReflectiveInjector;
    exports.ResolvedReflectiveFactory = ResolvedReflectiveFactory;
    exports.ReflectiveKey = ReflectiveKey;
    exports.OpaqueToken = OpaqueToken;
    exports.Inject = Inject;
    exports.Optional = Optional;
    exports.Injectable = Injectable;
    exports.Self = Self;
    exports.SkipSelf = SkipSelf;
    exports.Host = Host;
    exports.NgZone = NgZone;
    exports.RenderComponentType = RenderComponentType;
    exports.Renderer = Renderer;
    exports.RootRenderer = RootRenderer;
    exports.COMPILER_OPTIONS = COMPILER_OPTIONS;
    exports.Compiler = Compiler;
    exports.CompilerFactory = CompilerFactory;
    exports.ModuleWithComponentFactories = ModuleWithComponentFactories;
    exports.ComponentFactory = ComponentFactory;
    exports.ComponentRef = ComponentRef;
    exports.ComponentFactoryResolver = ComponentFactoryResolver;
    exports.ElementRef = ElementRef;
    exports.NgModuleFactory = NgModuleFactory;
    exports.NgModuleRef = NgModuleRef;
    exports.NgModuleFactoryLoader = NgModuleFactoryLoader;
    exports.getModuleFactory = getModuleFactory;
    exports.QueryList = QueryList;
    exports.SystemJsNgModuleLoader = SystemJsNgModuleLoader;
    exports.SystemJsNgModuleLoaderConfig = SystemJsNgModuleLoaderConfig;
    exports.TemplateRef = TemplateRef;
    exports.ViewContainerRef = ViewContainerRef;
    exports.EmbeddedViewRef = EmbeddedViewRef;
    exports.ViewRef = ViewRef;
    exports.ChangeDetectorRef = ChangeDetectorRef;
    exports.CollectionChangeRecord = CollectionChangeRecord;
    exports.DefaultIterableDiffer = DefaultIterableDiffer;
    exports.IterableDiffers = IterableDiffers;
    exports.KeyValueChangeRecord = KeyValueChangeRecord;
    exports.KeyValueDiffers = KeyValueDiffers;
    exports.SimpleChange = SimpleChange;
    exports.WrappedValue = WrappedValue;
    exports.platformCore = platformCore;
    exports.__core_private__ = __core_private__;
    exports.AUTO_STYLE = AUTO_STYLE;
    exports.AnimationEntryMetadata = AnimationEntryMetadata;
    exports.AnimationStateMetadata = AnimationStateMetadata;
    exports.AnimationStateDeclarationMetadata = AnimationStateDeclarationMetadata;
    exports.AnimationStateTransitionMetadata = AnimationStateTransitionMetadata;
    exports.AnimationMetadata = AnimationMetadata;
    exports.AnimationKeyframesSequenceMetadata = AnimationKeyframesSequenceMetadata;
    exports.AnimationStyleMetadata = AnimationStyleMetadata;
    exports.AnimationAnimateMetadata = AnimationAnimateMetadata;
    exports.AnimationWithStepsMetadata = AnimationWithStepsMetadata;
    exports.AnimationSequenceMetadata = AnimationSequenceMetadata;
    exports.AnimationGroupMetadata = AnimationGroupMetadata;
    exports.animate = animate;
    exports.group = group;
    exports.sequence = sequence;
    exports.style = style;
    exports.state = state;
    exports.keyframes = keyframes;
    exports.transition = transition;
    exports.trigger = trigger;

}));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"rxjs/Observable":9,"rxjs/Subject":11}],7:[function(require,module,exports){
(function (global){
/**
 * @license Angular v2.1.1
 * (c) 2010-2016 Google, Inc. https://angular.io/
 * License: MIT
 */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/compiler'), require('@angular/core'), require('@angular/platform-browser')) :
    typeof define === 'function' && define.amd ? define(['exports', '@angular/compiler', '@angular/core', '@angular/platform-browser'], factory) :
    (factory((global.ng = global.ng || {}, global.ng.platformBrowserDynamic = global.ng.platformBrowserDynamic || {}),global.ng.compiler,global.ng.core,global.ng.platformBrowser));
}(this, function (exports,_angular_compiler,_angular_core,_angular_platformBrowser) { 'use strict';

    var INTERNAL_BROWSER_PLATFORM_PROVIDERS = _angular_platformBrowser.__platform_browser_private__.INTERNAL_BROWSER_PLATFORM_PROVIDERS;

    var __extends = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var ResourceLoaderImpl = (function (_super) {
        __extends(ResourceLoaderImpl, _super);
        function ResourceLoaderImpl() {
            _super.apply(this, arguments);
        }
        ResourceLoaderImpl.prototype.get = function (url) {
            var resolve;
            var reject;
            var promise = new Promise(function (res, rej) {
                resolve = res;
                reject = rej;
            });
            var xhr = new XMLHttpRequest();
            xhr.open('GET', url, true);
            xhr.responseType = 'text';
            xhr.onload = function () {
                // responseText is the old-school way of retrieving response (supported by IE8 & 9)
                // response/responseType properties were introduced in ResourceLoader Level2 spec (supported
                // by IE10)
                var response = xhr.response || xhr.responseText;
                // normalize IE9 bug (http://bugs.jquery.com/ticket/1450)
                var status = xhr.status === 1223 ? 204 : xhr.status;
                // fix status code when it is 0 (0 status is undocumented).
                // Occurs when accessing file resources or on Android 4.1 stock browser
                // while retrieving files from application cache.
                if (status === 0) {
                    status = response ? 200 : 0;
                }
                if (200 <= status && status <= 300) {
                    resolve(response);
                }
                else {
                    reject("Failed to load " + url);
                }
            };
            xhr.onerror = function () { reject("Failed to load " + url); };
            xhr.send();
            return promise;
        };
        ResourceLoaderImpl.decorators = [
            { type: _angular_core.Injectable },
        ];
        /** @nocollapse */
        ResourceLoaderImpl.ctorParameters = [];
        return ResourceLoaderImpl;
    }(_angular_compiler.ResourceLoader));

    var INTERNAL_BROWSER_DYNAMIC_PLATFORM_PROVIDERS = [
        INTERNAL_BROWSER_PLATFORM_PROVIDERS,
        {
            provide: _angular_core.COMPILER_OPTIONS,
            useValue: { providers: [{ provide: _angular_compiler.ResourceLoader, useClass: ResourceLoaderImpl }] },
            multi: true
        },
    ];

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var globalScope;
    if (typeof window === 'undefined') {
        if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
            // TODO: Replace any with WorkerGlobalScope from lib.webworker.d.ts #3492
            globalScope = self;
        }
        else {
            globalScope = global;
        }
    }
    else {
        globalScope = window;
    }
    // Need to declare a new variable for global here since TypeScript
    // exports the original value of the symbol.
    var _global = globalScope;
    // TODO: remove calls to assert in production environment
    // Note: Can't just export this and import in in other files
    // as `assert` is a reserved keyword in Dart
    _global.assert = function assert(condition) {
        // TODO: to be fixed properly via #2830, noop for now
    };

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$1 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    /**
     * An implementation of ResourceLoader that uses a template cache to avoid doing an actual
     * ResourceLoader.
     *
     * The template cache needs to be built and loaded into window.$templateCache
     * via a separate mechanism.
     */
    var CachedResourceLoader = (function (_super) {
        __extends$1(CachedResourceLoader, _super);
        function CachedResourceLoader() {
            _super.call(this);
            this._cache = _global.$templateCache;
            if (this._cache == null) {
                throw new Error('CachedResourceLoader: Template cache was not found in $templateCache.');
            }
        }
        CachedResourceLoader.prototype.get = function (url) {
            if (this._cache.hasOwnProperty(url)) {
                return Promise.resolve(this._cache[url]);
            }
            else {
                return Promise.reject('CachedResourceLoader: Did not find cached template for ' + url);
            }
        };
        return CachedResourceLoader;
    }(_angular_compiler.ResourceLoader));

    var __platform_browser_dynamic_private__ = {
        INTERNAL_BROWSER_DYNAMIC_PLATFORM_PROVIDERS: INTERNAL_BROWSER_DYNAMIC_PLATFORM_PROVIDERS,
        ResourceLoaderImpl: ResourceLoaderImpl
    };

    /**
     * @experimental
     */
    var RESOURCE_CACHE_PROVIDER = [{ provide: _angular_compiler.ResourceLoader, useClass: CachedResourceLoader }];
    /**
     * @stable
     */
    var platformBrowserDynamic = _angular_core.createPlatformFactory(_angular_compiler.platformCoreDynamic, 'browserDynamic', INTERNAL_BROWSER_DYNAMIC_PLATFORM_PROVIDERS);

    exports.RESOURCE_CACHE_PROVIDER = RESOURCE_CACHE_PROVIDER;
    exports.platformBrowserDynamic = platformBrowserDynamic;
    exports.__platform_browser_dynamic_private__ = __platform_browser_dynamic_private__;

}));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"@angular/compiler":5,"@angular/core":6,"@angular/platform-browser":8}],8:[function(require,module,exports){
(function (global){
/**
 * @license Angular v2.1.1
 * (c) 2010-2016 Google, Inc. https://angular.io/
 * License: MIT
 */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/common'), require('@angular/core')) :
    typeof define === 'function' && define.amd ? define(['exports', '@angular/common', '@angular/core'], factory) :
    (factory((global.ng = global.ng || {}, global.ng.platformBrowser = global.ng.platformBrowser || {}),global.ng.common,global.ng.core));
}(this, function (exports,_angular_common,_angular_core) { 'use strict';

    var DebugDomRootRenderer = _angular_core.__core_private__.DebugDomRootRenderer;
    var NoOpAnimationPlayer = _angular_core.__core_private__.NoOpAnimationPlayer;

    var _NoOpAnimationDriver = (function () {
        function _NoOpAnimationDriver() {
        }
        _NoOpAnimationDriver.prototype.animate = function (element, startingStyles, keyframes, duration, delay, easing) {
            return new NoOpAnimationPlayer();
        };
        return _NoOpAnimationDriver;
    }());
    /**
     * @experimental
     */
    var AnimationDriver = (function () {
        function AnimationDriver() {
        }
        AnimationDriver.NOOP = new _NoOpAnimationDriver();
        return AnimationDriver;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var globalScope;
    if (typeof window === 'undefined') {
        if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
            // TODO: Replace any with WorkerGlobalScope from lib.webworker.d.ts #3492
            globalScope = self;
        }
        else {
            globalScope = global;
        }
    }
    else {
        globalScope = window;
    }
    // Need to declare a new variable for global here since TypeScript
    // exports the original value of the symbol.
    var global$1 = globalScope;
    // TODO: remove calls to assert in production environment
    // Note: Can't just export this and import in in other files
    // as `assert` is a reserved keyword in Dart
    global$1.assert = function assert(condition) {
        // TODO: to be fixed properly via #2830, noop for now
    };
    function isPresent(obj) {
        return obj !== undefined && obj !== null;
    }
    function isBlank(obj) {
        return obj === undefined || obj === null;
    }
    function stringify(token) {
        if (typeof token === 'string') {
            return token;
        }
        if (token === undefined || token === null) {
            return '' + token;
        }
        if (token.overriddenName) {
            return token.overriddenName;
        }
        if (token.name) {
            return token.name;
        }
        var res = token.toString();
        var newLineIndex = res.indexOf('\n');
        return newLineIndex === -1 ? res : res.substring(0, newLineIndex);
    }
    function setValueOnPath(global, path, value) {
        var parts = path.split('.');
        var obj = global;
        while (parts.length > 1) {
            var name = parts.shift();
            if (obj.hasOwnProperty(name) && isPresent(obj[name])) {
                obj = obj[name];
            }
            else {
                obj = obj[name] = {};
            }
        }
        if (obj === undefined || obj === null) {
            obj = {};
        }
        obj[parts.shift()] = value;
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var CAMEL_CASE_REGEXP = /([A-Z])/g;
    var DASH_CASE_REGEXP = /-([a-z])/g;
    function camelCaseToDashCase(input) {
        return input.replace(CAMEL_CASE_REGEXP, function () {
            var m = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                m[_i - 0] = arguments[_i];
            }
            return '-' + m[1].toLowerCase();
        });
    }
    function dashCaseToCamelCase(input) {
        return input.replace(DASH_CASE_REGEXP, function () {
            var m = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                m[_i - 0] = arguments[_i];
            }
            return m[1].toUpperCase();
        });
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var _DOM = null;
    function getDOM() {
        return _DOM;
    }
    function setRootDomAdapter(adapter) {
        if (!_DOM) {
            _DOM = adapter;
        }
    }
    /* tslint:disable:requireParameterType */
    /**
     * Provides DOM operations in an environment-agnostic way.
     *
     * @security Tread carefully! Interacting with the DOM directly is dangerous and
     * can introduce XSS risks.
     */
    var DomAdapter = (function () {
        function DomAdapter() {
            this.resourceLoaderType = null;
        }
        Object.defineProperty(DomAdapter.prototype, "attrToPropMap", {
            /**
             * Maps attribute names to their corresponding property names for cases
             * where attribute name doesn't match property name.
             */
            get: function () { return this._attrToPropMap; },
            set: function (value) { this._attrToPropMap = value; },
            enumerable: true,
            configurable: true
        });
        ;
        ;
        return DomAdapter;
    }());

    var WebAnimationsPlayer = (function () {
        function WebAnimationsPlayer(element, keyframes, options) {
            this.element = element;
            this.keyframes = keyframes;
            this.options = options;
            this._onDoneFns = [];
            this._onStartFns = [];
            this._finished = false;
            this._initialized = false;
            this._started = false;
            this.parentPlayer = null;
            this._duration = options['duration'];
        }
        WebAnimationsPlayer.prototype._onFinish = function () {
            if (!this._finished) {
                this._finished = true;
                if (!isPresent(this.parentPlayer)) {
                    this.destroy();
                }
                this._onDoneFns.forEach(function (fn) { return fn(); });
                this._onDoneFns = [];
            }
        };
        WebAnimationsPlayer.prototype.init = function () {
            var _this = this;
            if (this._initialized)
                return;
            this._initialized = true;
            var keyframes = this.keyframes.map(function (styles) {
                var formattedKeyframe = {};
                Object.keys(styles).forEach(function (prop) {
                    var value = styles[prop];
                    formattedKeyframe[prop] = value == _angular_core.AUTO_STYLE ? _computeStyle(_this.element, prop) : value;
                });
                return formattedKeyframe;
            });
            this._player = this._triggerWebAnimation(this.element, keyframes, this.options);
            // this is required so that the player doesn't start to animate right away
            this.reset();
            this._player.onfinish = function () { return _this._onFinish(); };
        };
        /** @internal */
        WebAnimationsPlayer.prototype._triggerWebAnimation = function (element, keyframes, options) {
            return element.animate(keyframes, options);
        };
        WebAnimationsPlayer.prototype.onStart = function (fn) { this._onStartFns.push(fn); };
        WebAnimationsPlayer.prototype.onDone = function (fn) { this._onDoneFns.push(fn); };
        WebAnimationsPlayer.prototype.play = function () {
            this.init();
            if (!this.hasStarted()) {
                this._onStartFns.forEach(function (fn) { return fn(); });
                this._onStartFns = [];
                this._started = true;
            }
            this._player.play();
        };
        WebAnimationsPlayer.prototype.pause = function () {
            this.init();
            this._player.pause();
        };
        WebAnimationsPlayer.prototype.finish = function () {
            this.init();
            this._onFinish();
            this._player.finish();
        };
        WebAnimationsPlayer.prototype.reset = function () { this._player.cancel(); };
        WebAnimationsPlayer.prototype.restart = function () {
            this.reset();
            this.play();
        };
        WebAnimationsPlayer.prototype.hasStarted = function () { return this._started; };
        WebAnimationsPlayer.prototype.destroy = function () {
            this.reset();
            this._onFinish();
        };
        Object.defineProperty(WebAnimationsPlayer.prototype, "totalTime", {
            get: function () { return this._duration; },
            enumerable: true,
            configurable: true
        });
        WebAnimationsPlayer.prototype.setPosition = function (p) { this._player.currentTime = p * this.totalTime; };
        WebAnimationsPlayer.prototype.getPosition = function () { return this._player.currentTime / this.totalTime; };
        return WebAnimationsPlayer;
    }());
    function _computeStyle(element, prop) {
        return getDOM().getComputedStyle(element)[prop];
    }

    var WebAnimationsDriver = (function () {
        function WebAnimationsDriver() {
        }
        WebAnimationsDriver.prototype.animate = function (element, startingStyles, keyframes, duration, delay, easing) {
            var formattedSteps = [];
            var startingStyleLookup = {};
            if (isPresent(startingStyles) && startingStyles.styles.length > 0) {
                startingStyleLookup = _populateStyles(element, startingStyles, {});
                startingStyleLookup['offset'] = 0;
                formattedSteps.push(startingStyleLookup);
            }
            keyframes.forEach(function (keyframe) {
                var data = _populateStyles(element, keyframe.styles, startingStyleLookup);
                data['offset'] = keyframe.offset;
                formattedSteps.push(data);
            });
            // this is a special case when only styles are applied as an
            // animation. When this occurs we want to animate from start to
            // end with the same values. Removing the offset and having only
            // start/end values is suitable enough for the web-animations API
            if (formattedSteps.length == 1) {
                var start = formattedSteps[0];
                start['offset'] = null;
                formattedSteps = [start, start];
            }
            var playerOptions = {
                'duration': duration,
                'delay': delay,
                'fill': 'both' // we use `both` because it allows for styling at 0% to work with `delay`
            };
            // we check for this to avoid having a null|undefined value be present
            // for the easing (which results in an error for certain browsers #9752)
            if (easing) {
                playerOptions['easing'] = easing;
            }
            return new WebAnimationsPlayer(element, formattedSteps, playerOptions);
        };
        return WebAnimationsDriver;
    }());
    function _populateStyles(element, styles, defaultStyles) {
        var data = {};
        styles.styles.forEach(function (entry) {
            Object.keys(entry).forEach(function (prop) {
                var val = entry[prop];
                var formattedProp = dashCaseToCamelCase(prop);
                data[formattedProp] =
                    val == _angular_core.AUTO_STYLE ? val : val.toString() + _resolveStyleUnit(val, prop, formattedProp);
            });
        });
        Object.keys(defaultStyles).forEach(function (prop) {
            if (!isPresent(data[prop])) {
                data[prop] = defaultStyles[prop];
            }
        });
        return data;
    }
    function _resolveStyleUnit(val, userProvidedProp, formattedProp) {
        var unit = '';
        if (_isPixelDimensionStyle(formattedProp) && val != 0 && val != '0') {
            if (typeof val === 'number') {
                unit = 'px';
            }
            else if (_findDimensionalSuffix(val.toString()).length == 0) {
                throw new Error('Please provide a CSS unit value for ' + userProvidedProp + ':' + val);
            }
        }
        return unit;
    }
    var _$0 = 48;
    var _$9 = 57;
    var _$PERIOD = 46;
    function _findDimensionalSuffix(value) {
        for (var i = 0; i < value.length; i++) {
            var c = value.charCodeAt(i);
            if ((c >= _$0 && c <= _$9) || c == _$PERIOD)
                continue;
            return value.substring(i, value.length);
        }
        return '';
    }
    function _isPixelDimensionStyle(prop) {
        switch (prop) {
            case 'width':
            case 'height':
            case 'minWidth':
            case 'minHeight':
            case 'maxWidth':
            case 'maxHeight':
            case 'left':
            case 'top':
            case 'bottom':
            case 'right':
            case 'fontSize':
            case 'outlineWidth':
            case 'outlineOffset':
            case 'paddingTop':
            case 'paddingLeft':
            case 'paddingBottom':
            case 'paddingRight':
            case 'marginTop':
            case 'marginLeft':
            case 'marginBottom':
            case 'marginRight':
            case 'borderRadius':
            case 'borderWidth':
            case 'borderTopWidth':
            case 'borderLeftWidth':
            case 'borderRightWidth':
            case 'borderBottomWidth':
            case 'textIndent':
                return true;
            default:
                return false;
        }
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$1 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    /**
     * Provides DOM operations in any browser environment.
     *
     * @security Tread carefully! Interacting with the DOM directly is dangerous and
     * can introduce XSS risks.
     */
    var GenericBrowserDomAdapter = (function (_super) {
        __extends$1(GenericBrowserDomAdapter, _super);
        function GenericBrowserDomAdapter() {
            var _this = this;
            _super.call(this);
            this._animationPrefix = null;
            this._transitionEnd = null;
            try {
                var element_1 = this.createElement('div', this.defaultDoc());
                if (isPresent(this.getStyle(element_1, 'animationName'))) {
                    this._animationPrefix = '';
                }
                else {
                    var domPrefixes = ['Webkit', 'Moz', 'O', 'ms'];
                    for (var i = 0; i < domPrefixes.length; i++) {
                        if (isPresent(this.getStyle(element_1, domPrefixes[i] + 'AnimationName'))) {
                            this._animationPrefix = '-' + domPrefixes[i].toLowerCase() + '-';
                            break;
                        }
                    }
                }
                var transEndEventNames_1 = {
                    WebkitTransition: 'webkitTransitionEnd',
                    MozTransition: 'transitionend',
                    OTransition: 'oTransitionEnd otransitionend',
                    transition: 'transitionend'
                };
                Object.keys(transEndEventNames_1).forEach(function (key) {
                    if (isPresent(_this.getStyle(element_1, key))) {
                        _this._transitionEnd = transEndEventNames_1[key];
                    }
                });
            }
            catch (e) {
                this._animationPrefix = null;
                this._transitionEnd = null;
            }
        }
        GenericBrowserDomAdapter.prototype.getDistributedNodes = function (el) { return el.getDistributedNodes(); };
        GenericBrowserDomAdapter.prototype.resolveAndSetHref = function (el, baseUrl, href) {
            el.href = href == null ? baseUrl : baseUrl + '/../' + href;
        };
        GenericBrowserDomAdapter.prototype.supportsDOMEvents = function () { return true; };
        GenericBrowserDomAdapter.prototype.supportsNativeShadowDOM = function () {
            return typeof this.defaultDoc().body.createShadowRoot === 'function';
        };
        GenericBrowserDomAdapter.prototype.getAnimationPrefix = function () { return this._animationPrefix ? this._animationPrefix : ''; };
        GenericBrowserDomAdapter.prototype.getTransitionEnd = function () { return this._transitionEnd ? this._transitionEnd : ''; };
        GenericBrowserDomAdapter.prototype.supportsAnimation = function () {
            return isPresent(this._animationPrefix) && isPresent(this._transitionEnd);
        };
        return GenericBrowserDomAdapter;
    }(DomAdapter));

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var _attrToPropMap = {
        'class': 'className',
        'innerHtml': 'innerHTML',
        'readonly': 'readOnly',
        'tabindex': 'tabIndex',
    };
    var DOM_KEY_LOCATION_NUMPAD = 3;
    // Map to convert some key or keyIdentifier values to what will be returned by getEventKey
    var _keyMap = {
        // The following values are here for cross-browser compatibility and to match the W3C standard
        // cf http://www.w3.org/TR/DOM-Level-3-Events-key/
        '\b': 'Backspace',
        '\t': 'Tab',
        '\x7F': 'Delete',
        '\x1B': 'Escape',
        'Del': 'Delete',
        'Esc': 'Escape',
        'Left': 'ArrowLeft',
        'Right': 'ArrowRight',
        'Up': 'ArrowUp',
        'Down': 'ArrowDown',
        'Menu': 'ContextMenu',
        'Scroll': 'ScrollLock',
        'Win': 'OS'
    };
    // There is a bug in Chrome for numeric keypad keys:
    // https://code.google.com/p/chromium/issues/detail?id=155654
    // 1, 2, 3 ... are reported as A, B, C ...
    var _chromeNumKeyPadMap = {
        'A': '1',
        'B': '2',
        'C': '3',
        'D': '4',
        'E': '5',
        'F': '6',
        'G': '7',
        'H': '8',
        'I': '9',
        'J': '*',
        'K': '+',
        'M': '-',
        'N': '.',
        'O': '/',
        '\x60': '0',
        '\x90': 'NumLock'
    };
    /**
     * A `DomAdapter` powered by full browser DOM APIs.
     *
     * @security Tread carefully! Interacting with the DOM directly is dangerous and
     * can introduce XSS risks.
     */
    /* tslint:disable:requireParameterType */
    var BrowserDomAdapter = (function (_super) {
        __extends(BrowserDomAdapter, _super);
        function BrowserDomAdapter() {
            _super.apply(this, arguments);
        }
        BrowserDomAdapter.prototype.parse = function (templateHtml) { throw new Error('parse not implemented'); };
        BrowserDomAdapter.makeCurrent = function () { setRootDomAdapter(new BrowserDomAdapter()); };
        BrowserDomAdapter.prototype.hasProperty = function (element, name) { return name in element; };
        BrowserDomAdapter.prototype.setProperty = function (el, name, value) { el[name] = value; };
        BrowserDomAdapter.prototype.getProperty = function (el, name) { return el[name]; };
        BrowserDomAdapter.prototype.invoke = function (el, methodName, args) { (_a = el)[methodName].apply(_a, args); var _a; };
        // TODO(tbosch): move this into a separate environment class once we have it
        BrowserDomAdapter.prototype.logError = function (error) { (window.console.error || window.console.log)(error); };
        BrowserDomAdapter.prototype.log = function (error) { window.console.log(error); };
        BrowserDomAdapter.prototype.logGroup = function (error) {
            window.console.group && window.console.group(error);
            this.logError(error);
        };
        BrowserDomAdapter.prototype.logGroupEnd = function () { window.console.groupEnd && window.console.groupEnd(); };
        Object.defineProperty(BrowserDomAdapter.prototype, "attrToPropMap", {
            get: function () { return _attrToPropMap; },
            enumerable: true,
            configurable: true
        });
        BrowserDomAdapter.prototype.query = function (selector) { return document.querySelector(selector); };
        BrowserDomAdapter.prototype.querySelector = function (el, selector) {
            return el.querySelector(selector);
        };
        BrowserDomAdapter.prototype.querySelectorAll = function (el, selector) { return el.querySelectorAll(selector); };
        BrowserDomAdapter.prototype.on = function (el, evt, listener) { el.addEventListener(evt, listener, false); };
        BrowserDomAdapter.prototype.onAndCancel = function (el, evt, listener) {
            el.addEventListener(evt, listener, false);
            // Needed to follow Dart's subscription semantic, until fix of
            // https://code.google.com/p/dart/issues/detail?id=17406
            return function () { el.removeEventListener(evt, listener, false); };
        };
        BrowserDomAdapter.prototype.dispatchEvent = function (el, evt) { el.dispatchEvent(evt); };
        BrowserDomAdapter.prototype.createMouseEvent = function (eventType) {
            var evt = document.createEvent('MouseEvent');
            evt.initEvent(eventType, true, true);
            return evt;
        };
        BrowserDomAdapter.prototype.createEvent = function (eventType) {
            var evt = document.createEvent('Event');
            evt.initEvent(eventType, true, true);
            return evt;
        };
        BrowserDomAdapter.prototype.preventDefault = function (evt) {
            evt.preventDefault();
            evt.returnValue = false;
        };
        BrowserDomAdapter.prototype.isPrevented = function (evt) {
            return evt.defaultPrevented || isPresent(evt.returnValue) && !evt.returnValue;
        };
        BrowserDomAdapter.prototype.getInnerHTML = function (el) { return el.innerHTML; };
        BrowserDomAdapter.prototype.getTemplateContent = function (el) {
            return 'content' in el && el instanceof HTMLTemplateElement ? el.content : null;
        };
        BrowserDomAdapter.prototype.getOuterHTML = function (el) { return el.outerHTML; };
        BrowserDomAdapter.prototype.nodeName = function (node) { return node.nodeName; };
        BrowserDomAdapter.prototype.nodeValue = function (node) { return node.nodeValue; };
        BrowserDomAdapter.prototype.type = function (node) { return node.type; };
        BrowserDomAdapter.prototype.content = function (node) {
            if (this.hasProperty(node, 'content')) {
                return node.content;
            }
            else {
                return node;
            }
        };
        BrowserDomAdapter.prototype.firstChild = function (el) { return el.firstChild; };
        BrowserDomAdapter.prototype.nextSibling = function (el) { return el.nextSibling; };
        BrowserDomAdapter.prototype.parentElement = function (el) { return el.parentNode; };
        BrowserDomAdapter.prototype.childNodes = function (el) { return el.childNodes; };
        BrowserDomAdapter.prototype.childNodesAsList = function (el) {
            var childNodes = el.childNodes;
            var res = new Array(childNodes.length);
            for (var i = 0; i < childNodes.length; i++) {
                res[i] = childNodes[i];
            }
            return res;
        };
        BrowserDomAdapter.prototype.clearNodes = function (el) {
            while (el.firstChild) {
                el.removeChild(el.firstChild);
            }
        };
        BrowserDomAdapter.prototype.appendChild = function (el, node) { el.appendChild(node); };
        BrowserDomAdapter.prototype.removeChild = function (el, node) { el.removeChild(node); };
        BrowserDomAdapter.prototype.replaceChild = function (el, newChild, oldChild) { el.replaceChild(newChild, oldChild); };
        BrowserDomAdapter.prototype.remove = function (node) {
            if (node.parentNode) {
                node.parentNode.removeChild(node);
            }
            return node;
        };
        BrowserDomAdapter.prototype.insertBefore = function (el, node) { el.parentNode.insertBefore(node, el); };
        BrowserDomAdapter.prototype.insertAllBefore = function (el, nodes) {
            nodes.forEach(function (n) { return el.parentNode.insertBefore(n, el); });
        };
        BrowserDomAdapter.prototype.insertAfter = function (el, node) { el.parentNode.insertBefore(node, el.nextSibling); };
        BrowserDomAdapter.prototype.setInnerHTML = function (el, value) { el.innerHTML = value; };
        BrowserDomAdapter.prototype.getText = function (el) { return el.textContent; };
        BrowserDomAdapter.prototype.setText = function (el, value) { el.textContent = value; };
        BrowserDomAdapter.prototype.getValue = function (el) { return el.value; };
        BrowserDomAdapter.prototype.setValue = function (el, value) { el.value = value; };
        BrowserDomAdapter.prototype.getChecked = function (el) { return el.checked; };
        BrowserDomAdapter.prototype.setChecked = function (el, value) { el.checked = value; };
        BrowserDomAdapter.prototype.createComment = function (text) { return document.createComment(text); };
        BrowserDomAdapter.prototype.createTemplate = function (html) {
            var t = document.createElement('template');
            t.innerHTML = html;
            return t;
        };
        BrowserDomAdapter.prototype.createElement = function (tagName, doc) {
            if (doc === void 0) { doc = document; }
            return doc.createElement(tagName);
        };
        BrowserDomAdapter.prototype.createElementNS = function (ns, tagName, doc) {
            if (doc === void 0) { doc = document; }
            return doc.createElementNS(ns, tagName);
        };
        BrowserDomAdapter.prototype.createTextNode = function (text, doc) {
            if (doc === void 0) { doc = document; }
            return doc.createTextNode(text);
        };
        BrowserDomAdapter.prototype.createScriptTag = function (attrName, attrValue, doc) {
            if (doc === void 0) { doc = document; }
            var el = doc.createElement('SCRIPT');
            el.setAttribute(attrName, attrValue);
            return el;
        };
        BrowserDomAdapter.prototype.createStyleElement = function (css, doc) {
            if (doc === void 0) { doc = document; }
            var style = doc.createElement('style');
            this.appendChild(style, this.createTextNode(css));
            return style;
        };
        BrowserDomAdapter.prototype.createShadowRoot = function (el) { return el.createShadowRoot(); };
        BrowserDomAdapter.prototype.getShadowRoot = function (el) { return el.shadowRoot; };
        BrowserDomAdapter.prototype.getHost = function (el) { return el.host; };
        BrowserDomAdapter.prototype.clone = function (node) { return node.cloneNode(true); };
        BrowserDomAdapter.prototype.getElementsByClassName = function (element, name) {
            return element.getElementsByClassName(name);
        };
        BrowserDomAdapter.prototype.getElementsByTagName = function (element, name) {
            return element.getElementsByTagName(name);
        };
        BrowserDomAdapter.prototype.classList = function (element) { return Array.prototype.slice.call(element.classList, 0); };
        BrowserDomAdapter.prototype.addClass = function (element, className) { element.classList.add(className); };
        BrowserDomAdapter.prototype.removeClass = function (element, className) { element.classList.remove(className); };
        BrowserDomAdapter.prototype.hasClass = function (element, className) {
            return element.classList.contains(className);
        };
        BrowserDomAdapter.prototype.setStyle = function (element, styleName, styleValue) {
            element.style[styleName] = styleValue;
        };
        BrowserDomAdapter.prototype.removeStyle = function (element, stylename) {
            // IE requires '' instead of null
            // see https://github.com/angular/angular/issues/7916
            element.style[stylename] = '';
        };
        BrowserDomAdapter.prototype.getStyle = function (element, stylename) { return element.style[stylename]; };
        BrowserDomAdapter.prototype.hasStyle = function (element, styleName, styleValue) {
            if (styleValue === void 0) { styleValue = null; }
            var value = this.getStyle(element, styleName) || '';
            return styleValue ? value == styleValue : value.length > 0;
        };
        BrowserDomAdapter.prototype.tagName = function (element) { return element.tagName; };
        BrowserDomAdapter.prototype.attributeMap = function (element) {
            var res = new Map();
            var elAttrs = element.attributes;
            for (var i = 0; i < elAttrs.length; i++) {
                var attrib = elAttrs[i];
                res.set(attrib.name, attrib.value);
            }
            return res;
        };
        BrowserDomAdapter.prototype.hasAttribute = function (element, attribute) {
            return element.hasAttribute(attribute);
        };
        BrowserDomAdapter.prototype.hasAttributeNS = function (element, ns, attribute) {
            return element.hasAttributeNS(ns, attribute);
        };
        BrowserDomAdapter.prototype.getAttribute = function (element, attribute) {
            return element.getAttribute(attribute);
        };
        BrowserDomAdapter.prototype.getAttributeNS = function (element, ns, name) {
            return element.getAttributeNS(ns, name);
        };
        BrowserDomAdapter.prototype.setAttribute = function (element, name, value) { element.setAttribute(name, value); };
        BrowserDomAdapter.prototype.setAttributeNS = function (element, ns, name, value) {
            element.setAttributeNS(ns, name, value);
        };
        BrowserDomAdapter.prototype.removeAttribute = function (element, attribute) { element.removeAttribute(attribute); };
        BrowserDomAdapter.prototype.removeAttributeNS = function (element, ns, name) {
            element.removeAttributeNS(ns, name);
        };
        BrowserDomAdapter.prototype.templateAwareRoot = function (el) { return this.isTemplateElement(el) ? this.content(el) : el; };
        BrowserDomAdapter.prototype.createHtmlDocument = function () {
            return document.implementation.createHTMLDocument('fakeTitle');
        };
        BrowserDomAdapter.prototype.defaultDoc = function () { return document; };
        BrowserDomAdapter.prototype.getBoundingClientRect = function (el) {
            try {
                return el.getBoundingClientRect();
            }
            catch (e) {
                return { top: 0, bottom: 0, left: 0, right: 0, width: 0, height: 0 };
            }
        };
        BrowserDomAdapter.prototype.getTitle = function () { return document.title; };
        BrowserDomAdapter.prototype.setTitle = function (newTitle) { document.title = newTitle || ''; };
        BrowserDomAdapter.prototype.elementMatches = function (n, selector) {
            if (n instanceof HTMLElement) {
                return n.matches && n.matches(selector) ||
                    n.msMatchesSelector && n.msMatchesSelector(selector) ||
                    n.webkitMatchesSelector && n.webkitMatchesSelector(selector);
            }
            return false;
        };
        BrowserDomAdapter.prototype.isTemplateElement = function (el) {
            return el instanceof HTMLElement && el.nodeName == 'TEMPLATE';
        };
        BrowserDomAdapter.prototype.isTextNode = function (node) { return node.nodeType === Node.TEXT_NODE; };
        BrowserDomAdapter.prototype.isCommentNode = function (node) { return node.nodeType === Node.COMMENT_NODE; };
        BrowserDomAdapter.prototype.isElementNode = function (node) { return node.nodeType === Node.ELEMENT_NODE; };
        BrowserDomAdapter.prototype.hasShadowRoot = function (node) {
            return isPresent(node.shadowRoot) && node instanceof HTMLElement;
        };
        BrowserDomAdapter.prototype.isShadowRoot = function (node) { return node instanceof DocumentFragment; };
        BrowserDomAdapter.prototype.importIntoDoc = function (node) { return document.importNode(this.templateAwareRoot(node), true); };
        BrowserDomAdapter.prototype.adoptNode = function (node) { return document.adoptNode(node); };
        BrowserDomAdapter.prototype.getHref = function (el) { return el.href; };
        BrowserDomAdapter.prototype.getEventKey = function (event) {
            var key = event.key;
            if (isBlank(key)) {
                key = event.keyIdentifier;
                // keyIdentifier is defined in the old draft of DOM Level 3 Events implemented by Chrome and
                // Safari cf
                // http://www.w3.org/TR/2007/WD-DOM-Level-3-Events-20071221/events.html#Events-KeyboardEvents-Interfaces
                if (isBlank(key)) {
                    return 'Unidentified';
                }
                if (key.startsWith('U+')) {
                    key = String.fromCharCode(parseInt(key.substring(2), 16));
                    if (event.location === DOM_KEY_LOCATION_NUMPAD && _chromeNumKeyPadMap.hasOwnProperty(key)) {
                        // There is a bug in Chrome for numeric keypad keys:
                        // https://code.google.com/p/chromium/issues/detail?id=155654
                        // 1, 2, 3 ... are reported as A, B, C ...
                        key = _chromeNumKeyPadMap[key];
                    }
                }
            }
            return _keyMap[key] || key;
        };
        BrowserDomAdapter.prototype.getGlobalEventTarget = function (target) {
            if (target === 'window') {
                return window;
            }
            if (target === 'document') {
                return document;
            }
            if (target === 'body') {
                return document.body;
            }
        };
        BrowserDomAdapter.prototype.getHistory = function () { return window.history; };
        BrowserDomAdapter.prototype.getLocation = function () { return window.location; };
        BrowserDomAdapter.prototype.getBaseHref = function () {
            var href = getBaseElementHref();
            return isBlank(href) ? null : relativePath(href);
        };
        BrowserDomAdapter.prototype.resetBaseElement = function () { baseElement = null; };
        BrowserDomAdapter.prototype.getUserAgent = function () { return window.navigator.userAgent; };
        BrowserDomAdapter.prototype.setData = function (element, name, value) {
            this.setAttribute(element, 'data-' + name, value);
        };
        BrowserDomAdapter.prototype.getData = function (element, name) {
            return this.getAttribute(element, 'data-' + name);
        };
        BrowserDomAdapter.prototype.getComputedStyle = function (element) { return getComputedStyle(element); };
        // TODO(tbosch): move this into a separate environment class once we have it
        BrowserDomAdapter.prototype.setGlobalVar = function (path, value) { setValueOnPath(global$1, path, value); };
        BrowserDomAdapter.prototype.supportsWebAnimation = function () {
            return typeof Element.prototype['animate'] === 'function';
        };
        BrowserDomAdapter.prototype.performanceNow = function () {
            // performance.now() is not available in all browsers, see
            // http://caniuse.com/#search=performance.now
            return window.performance && window.performance.now ? window.performance.now() :
                new Date().getTime();
        };
        BrowserDomAdapter.prototype.supportsCookies = function () { return true; };
        BrowserDomAdapter.prototype.getCookie = function (name) { return parseCookieValue(document.cookie, name); };
        BrowserDomAdapter.prototype.setCookie = function (name, value) {
            // document.cookie is magical, assigning into it assigns/overrides one cookie value, but does
            // not clear other cookies.
            document.cookie = encodeURIComponent(name) + '=' + encodeURIComponent(value);
        };
        return BrowserDomAdapter;
    }(GenericBrowserDomAdapter));
    var baseElement = null;
    function getBaseElementHref() {
        if (!baseElement) {
            baseElement = document.querySelector('base');
            if (!baseElement) {
                return null;
            }
        }
        return baseElement.getAttribute('href');
    }
    // based on urlUtils.js in AngularJS 1
    var urlParsingNode;
    function relativePath(url) {
        if (!urlParsingNode) {
            urlParsingNode = document.createElement('a');
        }
        urlParsingNode.setAttribute('href', url);
        return (urlParsingNode.pathname.charAt(0) === '/') ? urlParsingNode.pathname :
            '/' + urlParsingNode.pathname;
    }
    function parseCookieValue(cookieStr, name) {
        name = encodeURIComponent(name);
        for (var _i = 0, _a = cookieStr.split(';'); _i < _a.length; _i++) {
            var cookie = _a[_i];
            var eqIndex = cookie.indexOf('=');
            var _b = eqIndex == -1 ? [cookie, ''] : [cookie.slice(0, eqIndex), cookie.slice(eqIndex + 1)], cookieName = _b[0], cookieValue = _b[1];
            if (cookieName.trim() === name) {
                return decodeURIComponent(cookieValue);
            }
        }
        return null;
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function supportsState() {
        return !!window.history.pushState;
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$2 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    /**
     * `PlatformLocation` encapsulates all of the direct calls to platform APIs.
     * This class should not be used directly by an application developer. Instead, use
     * {@link Location}.
     */
    var BrowserPlatformLocation = (function (_super) {
        __extends$2(BrowserPlatformLocation, _super);
        function BrowserPlatformLocation() {
            _super.call(this);
            this._init();
        }
        // This is moved to its own method so that `MockPlatformLocationStrategy` can overwrite it
        /** @internal */
        BrowserPlatformLocation.prototype._init = function () {
            this._location = getDOM().getLocation();
            this._history = getDOM().getHistory();
        };
        Object.defineProperty(BrowserPlatformLocation.prototype, "location", {
            get: function () { return this._location; },
            enumerable: true,
            configurable: true
        });
        BrowserPlatformLocation.prototype.getBaseHrefFromDOM = function () { return getDOM().getBaseHref(); };
        BrowserPlatformLocation.prototype.onPopState = function (fn) {
            getDOM().getGlobalEventTarget('window').addEventListener('popstate', fn, false);
        };
        BrowserPlatformLocation.prototype.onHashChange = function (fn) {
            getDOM().getGlobalEventTarget('window').addEventListener('hashchange', fn, false);
        };
        Object.defineProperty(BrowserPlatformLocation.prototype, "pathname", {
            get: function () { return this._location.pathname; },
            set: function (newPath) { this._location.pathname = newPath; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BrowserPlatformLocation.prototype, "search", {
            get: function () { return this._location.search; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BrowserPlatformLocation.prototype, "hash", {
            get: function () { return this._location.hash; },
            enumerable: true,
            configurable: true
        });
        BrowserPlatformLocation.prototype.pushState = function (state, title, url) {
            if (supportsState()) {
                this._history.pushState(state, title, url);
            }
            else {
                this._location.hash = url;
            }
        };
        BrowserPlatformLocation.prototype.replaceState = function (state, title, url) {
            if (supportsState()) {
                this._history.replaceState(state, title, url);
            }
            else {
                this._location.hash = url;
            }
        };
        BrowserPlatformLocation.prototype.forward = function () { this._history.forward(); };
        BrowserPlatformLocation.prototype.back = function () { this._history.back(); };
        BrowserPlatformLocation.decorators = [
            { type: _angular_core.Injectable },
        ];
        /** @nocollapse */
        BrowserPlatformLocation.ctorParameters = [];
        return BrowserPlatformLocation;
    }(_angular_common.PlatformLocation));

    // Safari doesn't implement MapIterator.next(), which is used is Traceur's polyfill of Array.from
    // TODO(mlaval): remove the work around once we have a working polyfill of Array.from
    var _arrayFromMap = (function () {
        try {
            if ((new Map()).values().next) {
                return function createArrayFromMap(m, getValues) {
                    return getValues ? Array.from(m.values()) : Array.from(m.keys());
                };
            }
        }
        catch (e) {
        }
        return function createArrayFromMapWithForeach(m, getValues) {
            var res = new Array(m.size), i = 0;
            m.forEach(function (v, k) {
                res[i] = getValues ? v : k;
                i++;
            });
            return res;
        };
    })();
    /**
     * Wraps Javascript Objects
     */
    var StringMapWrapper = (function () {
        function StringMapWrapper() {
        }
        StringMapWrapper.merge = function (m1, m2) {
            var m = {};
            for (var _i = 0, _a = Object.keys(m1); _i < _a.length; _i++) {
                var k = _a[_i];
                m[k] = m1[k];
            }
            for (var _b = 0, _c = Object.keys(m2); _b < _c.length; _b++) {
                var k = _c[_b];
                m[k] = m2[k];
            }
            return m;
        };
        StringMapWrapper.equals = function (m1, m2) {
            var k1 = Object.keys(m1);
            var k2 = Object.keys(m2);
            if (k1.length != k2.length) {
                return false;
            }
            for (var i = 0; i < k1.length; i++) {
                var key = k1[i];
                if (m1[key] !== m2[key]) {
                    return false;
                }
            }
            return true;
        };
        return StringMapWrapper;
    }());
    var ListWrapper = (function () {
        function ListWrapper() {
        }
        // JS has no way to express a statically fixed size list, but dart does so we
        // keep both methods.
        ListWrapper.createFixedSize = function (size) { return new Array(size); };
        ListWrapper.createGrowableSize = function (size) { return new Array(size); };
        ListWrapper.clone = function (array) { return array.slice(0); };
        ListWrapper.forEachWithIndex = function (array, fn) {
            for (var i = 0; i < array.length; i++) {
                fn(array[i], i);
            }
        };
        ListWrapper.first = function (array) {
            if (!array)
                return null;
            return array[0];
        };
        ListWrapper.last = function (array) {
            if (!array || array.length == 0)
                return null;
            return array[array.length - 1];
        };
        ListWrapper.indexOf = function (array, value, startIndex) {
            if (startIndex === void 0) { startIndex = 0; }
            return array.indexOf(value, startIndex);
        };
        ListWrapper.contains = function (list, el) { return list.indexOf(el) !== -1; };
        ListWrapper.reversed = function (array) {
            var a = ListWrapper.clone(array);
            return a.reverse();
        };
        ListWrapper.concat = function (a, b) { return a.concat(b); };
        ListWrapper.insert = function (list, index, value) { list.splice(index, 0, value); };
        ListWrapper.removeAt = function (list, index) {
            var res = list[index];
            list.splice(index, 1);
            return res;
        };
        ListWrapper.removeAll = function (list, items) {
            for (var i = 0; i < items.length; ++i) {
                var index = list.indexOf(items[i]);
                list.splice(index, 1);
            }
        };
        ListWrapper.remove = function (list, el) {
            var index = list.indexOf(el);
            if (index > -1) {
                list.splice(index, 1);
                return true;
            }
            return false;
        };
        ListWrapper.clear = function (list) { list.length = 0; };
        ListWrapper.isEmpty = function (list) { return list.length == 0; };
        ListWrapper.fill = function (list, value, start, end) {
            if (start === void 0) { start = 0; }
            if (end === void 0) { end = null; }
            list.fill(value, start, end === null ? list.length : end);
        };
        ListWrapper.equals = function (a, b) {
            if (a.length != b.length)
                return false;
            for (var i = 0; i < a.length; ++i) {
                if (a[i] !== b[i])
                    return false;
            }
            return true;
        };
        ListWrapper.slice = function (l, from, to) {
            if (from === void 0) { from = 0; }
            if (to === void 0) { to = null; }
            return l.slice(from, to === null ? undefined : to);
        };
        ListWrapper.splice = function (l, from, length) { return l.splice(from, length); };
        ListWrapper.sort = function (l, compareFn) {
            if (isPresent(compareFn)) {
                l.sort(compareFn);
            }
            else {
                l.sort();
            }
        };
        ListWrapper.toString = function (l) { return l.toString(); };
        ListWrapper.toJSON = function (l) { return JSON.stringify(l); };
        ListWrapper.maximum = function (list, predicate) {
            if (list.length == 0) {
                return null;
            }
            var solution = null;
            var maxValue = -Infinity;
            for (var index = 0; index < list.length; index++) {
                var candidate = list[index];
                if (isBlank(candidate)) {
                    continue;
                }
                var candidateValue = predicate(candidate);
                if (candidateValue > maxValue) {
                    solution = candidate;
                    maxValue = candidateValue;
                }
            }
            return solution;
        };
        ListWrapper.flatten = function (list) {
            var target = [];
            _flattenArray(list, target);
            return target;
        };
        ListWrapper.addAll = function (list, source) {
            for (var i = 0; i < source.length; i++) {
                list.push(source[i]);
            }
        };
        return ListWrapper;
    }());
    function _flattenArray(source, target) {
        if (isPresent(source)) {
            for (var i = 0; i < source.length; i++) {
                var item = source[i];
                if (Array.isArray(item)) {
                    _flattenArray(item, target);
                }
                else {
                    target.push(item);
                }
            }
        }
        return target;
    }

    var BrowserGetTestability = (function () {
        function BrowserGetTestability() {
        }
        BrowserGetTestability.init = function () { _angular_core.setTestabilityGetter(new BrowserGetTestability()); };
        BrowserGetTestability.prototype.addToWindow = function (registry) {
            global$1.getAngularTestability = function (elem, findInAncestors) {
                if (findInAncestors === void 0) { findInAncestors = true; }
                var testability = registry.findTestabilityInTree(elem, findInAncestors);
                if (testability == null) {
                    throw new Error('Could not find testability for element.');
                }
                return testability;
            };
            global$1.getAllAngularTestabilities = function () { return registry.getAllTestabilities(); };
            global$1.getAllAngularRootElements = function () { return registry.getAllRootElements(); };
            var whenAllStable = function (callback /** TODO #9100 */) {
                var testabilities = global$1.getAllAngularTestabilities();
                var count = testabilities.length;
                var didWork = false;
                var decrement = function (didWork_ /** TODO #9100 */) {
                    didWork = didWork || didWork_;
                    count--;
                    if (count == 0) {
                        callback(didWork);
                    }
                };
                testabilities.forEach(function (testability /** TODO #9100 */) {
                    testability.whenStable(decrement);
                });
            };
            if (!global$1['frameworkStabilizers']) {
                global$1['frameworkStabilizers'] = ListWrapper.createGrowableSize(0);
            }
            global$1['frameworkStabilizers'].push(whenAllStable);
        };
        BrowserGetTestability.prototype.findTestabilityInTree = function (registry, elem, findInAncestors) {
            if (elem == null) {
                return null;
            }
            var t = registry.getTestability(elem);
            if (isPresent(t)) {
                return t;
            }
            else if (!findInAncestors) {
                return null;
            }
            if (getDOM().isShadowRoot(elem)) {
                return this.findTestabilityInTree(registry, getDOM().getHost(elem), true);
            }
            return this.findTestabilityInTree(registry, getDOM().parentElement(elem), true);
        };
        return BrowserGetTestability;
    }());

    /**
     * A service that can be used to get and set the title of a current HTML document.
     *
     * Since an Angular 2 application can't be bootstrapped on the entire HTML document (`<html>` tag)
     * it is not possible to bind to the `text` property of the `HTMLTitleElement` elements
     * (representing the `<title>` tag). Instead, this service can be used to set and get the current
     * title value.
     *
     * @experimental
     */
    var Title = (function () {
        function Title() {
        }
        /**
         * Get the title of the current HTML document.
         * @returns {string}
         */
        Title.prototype.getTitle = function () { return getDOM().getTitle(); };
        /**
         * Set the title of the current HTML document.
         * @param newTitle
         */
        Title.prototype.setTitle = function (newTitle) { getDOM().setTitle(newTitle); };
        return Title;
    }());

    /**
     * A DI Token representing the main rendering context. In a browser this is the DOM Document.
     *
     * Note: Document might not be available in the Application Context when Application and Rendering
     * Contexts are not the same (e.g. when running the application into a Web Worker).
     *
     * @stable
     */
    var DOCUMENT = new _angular_core.OpaqueToken('DocumentToken');

    /**
     * @stable
     */
    var EVENT_MANAGER_PLUGINS = new _angular_core.OpaqueToken('EventManagerPlugins');
    /**
     * @stable
     */
    var EventManager = (function () {
        function EventManager(plugins, _zone) {
            var _this = this;
            this._zone = _zone;
            plugins.forEach(function (p) { return p.manager = _this; });
            this._plugins = plugins.slice().reverse();
        }
        EventManager.prototype.addEventListener = function (element, eventName, handler) {
            var plugin = this._findPluginFor(eventName);
            return plugin.addEventListener(element, eventName, handler);
        };
        EventManager.prototype.addGlobalEventListener = function (target, eventName, handler) {
            var plugin = this._findPluginFor(eventName);
            return plugin.addGlobalEventListener(target, eventName, handler);
        };
        EventManager.prototype.getZone = function () { return this._zone; };
        /** @internal */
        EventManager.prototype._findPluginFor = function (eventName) {
            var plugins = this._plugins;
            for (var i = 0; i < plugins.length; i++) {
                var plugin = plugins[i];
                if (plugin.supports(eventName)) {
                    return plugin;
                }
            }
            throw new Error("No event manager plugin found for event " + eventName);
        };
        EventManager.decorators = [
            { type: _angular_core.Injectable },
        ];
        /** @nocollapse */
        EventManager.ctorParameters = [
            { type: Array, decorators: [{ type: _angular_core.Inject, args: [EVENT_MANAGER_PLUGINS,] },] },
            { type: _angular_core.NgZone, },
        ];
        return EventManager;
    }());
    var EventManagerPlugin = (function () {
        function EventManagerPlugin() {
        }
        // That is equivalent to having supporting $event.target
        EventManagerPlugin.prototype.supports = function (eventName) { return false; };
        EventManagerPlugin.prototype.addEventListener = function (element, eventName, handler) {
            throw 'not implemented';
        };
        EventManagerPlugin.prototype.addGlobalEventListener = function (element, eventName, handler) {
            throw 'not implemented';
        };
        return EventManagerPlugin;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$4 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var SharedStylesHost = (function () {
        function SharedStylesHost() {
            /** @internal */
            this._styles = [];
            /** @internal */
            this._stylesSet = new Set();
        }
        SharedStylesHost.prototype.addStyles = function (styles) {
            var _this = this;
            var additions = [];
            styles.forEach(function (style) {
                if (!_this._stylesSet.has(style)) {
                    _this._stylesSet.add(style);
                    _this._styles.push(style);
                    additions.push(style);
                }
            });
            this.onStylesAdded(additions);
        };
        SharedStylesHost.prototype.onStylesAdded = function (additions) { };
        SharedStylesHost.prototype.getAllStyles = function () { return this._styles; };
        SharedStylesHost.decorators = [
            { type: _angular_core.Injectable },
        ];
        /** @nocollapse */
        SharedStylesHost.ctorParameters = [];
        return SharedStylesHost;
    }());
    var DomSharedStylesHost = (function (_super) {
        __extends$4(DomSharedStylesHost, _super);
        function DomSharedStylesHost(doc) {
            _super.call(this);
            this._hostNodes = new Set();
            this._hostNodes.add(doc.head);
        }
        /** @internal */
        DomSharedStylesHost.prototype._addStylesToHost = function (styles, host) {
            for (var i = 0; i < styles.length; i++) {
                var style = styles[i];
                getDOM().appendChild(host, getDOM().createStyleElement(style));
            }
        };
        DomSharedStylesHost.prototype.addHost = function (hostNode) {
            this._addStylesToHost(this._styles, hostNode);
            this._hostNodes.add(hostNode);
        };
        DomSharedStylesHost.prototype.removeHost = function (hostNode) { this._hostNodes.delete(hostNode); };
        DomSharedStylesHost.prototype.onStylesAdded = function (additions) {
            var _this = this;
            this._hostNodes.forEach(function (hostNode) { _this._addStylesToHost(additions, hostNode); });
        };
        DomSharedStylesHost.decorators = [
            { type: _angular_core.Injectable },
        ];
        /** @nocollapse */
        DomSharedStylesHost.ctorParameters = [
            { type: undefined, decorators: [{ type: _angular_core.Inject, args: [DOCUMENT,] },] },
        ];
        return DomSharedStylesHost;
    }(SharedStylesHost));

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$3 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var NAMESPACE_URIS = {
        'xlink': 'http://www.w3.org/1999/xlink',
        'svg': 'http://www.w3.org/2000/svg',
        'xhtml': 'http://www.w3.org/1999/xhtml'
    };
    var TEMPLATE_COMMENT_TEXT = 'template bindings={}';
    var TEMPLATE_BINDINGS_EXP = /^template bindings=(.*)$/;
    var DomRootRenderer = (function () {
        function DomRootRenderer(document, eventManager, sharedStylesHost, animationDriver) {
            this.document = document;
            this.eventManager = eventManager;
            this.sharedStylesHost = sharedStylesHost;
            this.animationDriver = animationDriver;
            this.registeredComponents = new Map();
        }
        DomRootRenderer.prototype.renderComponent = function (componentProto) {
            var renderer = this.registeredComponents.get(componentProto.id);
            if (!renderer) {
                renderer = new DomRenderer(this, componentProto, this.animationDriver);
                this.registeredComponents.set(componentProto.id, renderer);
            }
            return renderer;
        };
        return DomRootRenderer;
    }());
    var DomRootRenderer_ = (function (_super) {
        __extends$3(DomRootRenderer_, _super);
        function DomRootRenderer_(_document, _eventManager, sharedStylesHost, animationDriver) {
            _super.call(this, _document, _eventManager, sharedStylesHost, animationDriver);
        }
        DomRootRenderer_.decorators = [
            { type: _angular_core.Injectable },
        ];
        /** @nocollapse */
        DomRootRenderer_.ctorParameters = [
            { type: undefined, decorators: [{ type: _angular_core.Inject, args: [DOCUMENT,] },] },
            { type: EventManager, },
            { type: DomSharedStylesHost, },
            { type: AnimationDriver, },
        ];
        return DomRootRenderer_;
    }(DomRootRenderer));
    var DomRenderer = (function () {
        function DomRenderer(_rootRenderer, componentProto, _animationDriver) {
            this._rootRenderer = _rootRenderer;
            this.componentProto = componentProto;
            this._animationDriver = _animationDriver;
            this._styles = _flattenStyles(componentProto.id, componentProto.styles, []);
            if (componentProto.encapsulation !== _angular_core.ViewEncapsulation.Native) {
                this._rootRenderer.sharedStylesHost.addStyles(this._styles);
            }
            if (this.componentProto.encapsulation === _angular_core.ViewEncapsulation.Emulated) {
                this._contentAttr = _shimContentAttribute(componentProto.id);
                this._hostAttr = _shimHostAttribute(componentProto.id);
            }
            else {
                this._contentAttr = null;
                this._hostAttr = null;
            }
        }
        DomRenderer.prototype.selectRootElement = function (selectorOrNode, debugInfo) {
            var el;
            if (typeof selectorOrNode === 'string') {
                el = getDOM().querySelector(this._rootRenderer.document, selectorOrNode);
                if (isBlank(el)) {
                    throw new Error("The selector \"" + selectorOrNode + "\" did not match any elements");
                }
            }
            else {
                el = selectorOrNode;
            }
            getDOM().clearNodes(el);
            return el;
        };
        DomRenderer.prototype.createElement = function (parent, name, debugInfo) {
            var nsAndName = splitNamespace(name);
            var el = isPresent(nsAndName[0]) ?
                getDOM().createElementNS(NAMESPACE_URIS[nsAndName[0]], nsAndName[1]) :
                getDOM().createElement(nsAndName[1]);
            if (isPresent(this._contentAttr)) {
                getDOM().setAttribute(el, this._contentAttr, '');
            }
            if (isPresent(parent)) {
                getDOM().appendChild(parent, el);
            }
            return el;
        };
        DomRenderer.prototype.createViewRoot = function (hostElement) {
            var nodesParent;
            if (this.componentProto.encapsulation === _angular_core.ViewEncapsulation.Native) {
                nodesParent = getDOM().createShadowRoot(hostElement);
                this._rootRenderer.sharedStylesHost.addHost(nodesParent);
                for (var i = 0; i < this._styles.length; i++) {
                    getDOM().appendChild(nodesParent, getDOM().createStyleElement(this._styles[i]));
                }
            }
            else {
                if (isPresent(this._hostAttr)) {
                    getDOM().setAttribute(hostElement, this._hostAttr, '');
                }
                nodesParent = hostElement;
            }
            return nodesParent;
        };
        DomRenderer.prototype.createTemplateAnchor = function (parentElement, debugInfo) {
            var comment = getDOM().createComment(TEMPLATE_COMMENT_TEXT);
            if (isPresent(parentElement)) {
                getDOM().appendChild(parentElement, comment);
            }
            return comment;
        };
        DomRenderer.prototype.createText = function (parentElement, value, debugInfo) {
            var node = getDOM().createTextNode(value);
            if (isPresent(parentElement)) {
                getDOM().appendChild(parentElement, node);
            }
            return node;
        };
        DomRenderer.prototype.projectNodes = function (parentElement, nodes) {
            if (isBlank(parentElement))
                return;
            appendNodes(parentElement, nodes);
        };
        DomRenderer.prototype.attachViewAfter = function (node, viewRootNodes) { moveNodesAfterSibling(node, viewRootNodes); };
        DomRenderer.prototype.detachView = function (viewRootNodes) {
            for (var i = 0; i < viewRootNodes.length; i++) {
                getDOM().remove(viewRootNodes[i]);
            }
        };
        DomRenderer.prototype.destroyView = function (hostElement, viewAllNodes) {
            if (this.componentProto.encapsulation === _angular_core.ViewEncapsulation.Native && isPresent(hostElement)) {
                this._rootRenderer.sharedStylesHost.removeHost(getDOM().getShadowRoot(hostElement));
            }
        };
        DomRenderer.prototype.listen = function (renderElement, name, callback) {
            return this._rootRenderer.eventManager.addEventListener(renderElement, name, decoratePreventDefault(callback));
        };
        DomRenderer.prototype.listenGlobal = function (target, name, callback) {
            return this._rootRenderer.eventManager.addGlobalEventListener(target, name, decoratePreventDefault(callback));
        };
        DomRenderer.prototype.setElementProperty = function (renderElement, propertyName, propertyValue) {
            getDOM().setProperty(renderElement, propertyName, propertyValue);
        };
        DomRenderer.prototype.setElementAttribute = function (renderElement, attributeName, attributeValue) {
            var attrNs;
            var nsAndName = splitNamespace(attributeName);
            if (isPresent(nsAndName[0])) {
                attributeName = nsAndName[0] + ':' + nsAndName[1];
                attrNs = NAMESPACE_URIS[nsAndName[0]];
            }
            if (isPresent(attributeValue)) {
                if (isPresent(attrNs)) {
                    getDOM().setAttributeNS(renderElement, attrNs, attributeName, attributeValue);
                }
                else {
                    getDOM().setAttribute(renderElement, attributeName, attributeValue);
                }
            }
            else {
                if (isPresent(attrNs)) {
                    getDOM().removeAttributeNS(renderElement, attrNs, nsAndName[1]);
                }
                else {
                    getDOM().removeAttribute(renderElement, attributeName);
                }
            }
        };
        DomRenderer.prototype.setBindingDebugInfo = function (renderElement, propertyName, propertyValue) {
            var dashCasedPropertyName = camelCaseToDashCase(propertyName);
            if (getDOM().isCommentNode(renderElement)) {
                var existingBindings = getDOM().getText(renderElement).replace(/\n/g, '').match(TEMPLATE_BINDINGS_EXP);
                var parsedBindings = JSON.parse(existingBindings[1]);
                parsedBindings[dashCasedPropertyName] = propertyValue;
                getDOM().setText(renderElement, TEMPLATE_COMMENT_TEXT.replace('{}', JSON.stringify(parsedBindings, null, 2)));
            }
            else {
                this.setElementAttribute(renderElement, propertyName, propertyValue);
            }
        };
        DomRenderer.prototype.setElementClass = function (renderElement, className, isAdd) {
            if (isAdd) {
                getDOM().addClass(renderElement, className);
            }
            else {
                getDOM().removeClass(renderElement, className);
            }
        };
        DomRenderer.prototype.setElementStyle = function (renderElement, styleName, styleValue) {
            if (isPresent(styleValue)) {
                getDOM().setStyle(renderElement, styleName, stringify(styleValue));
            }
            else {
                getDOM().removeStyle(renderElement, styleName);
            }
        };
        DomRenderer.prototype.invokeElementMethod = function (renderElement, methodName, args) {
            getDOM().invoke(renderElement, methodName, args);
        };
        DomRenderer.prototype.setText = function (renderNode, text) { getDOM().setText(renderNode, text); };
        DomRenderer.prototype.animate = function (element, startingStyles, keyframes, duration, delay, easing) {
            return this._animationDriver.animate(element, startingStyles, keyframes, duration, delay, easing);
        };
        return DomRenderer;
    }());
    function moveNodesAfterSibling(sibling /** TODO #9100 */, nodes /** TODO #9100 */) {
        var parent = getDOM().parentElement(sibling);
        if (nodes.length > 0 && isPresent(parent)) {
            var nextSibling = getDOM().nextSibling(sibling);
            if (isPresent(nextSibling)) {
                for (var i = 0; i < nodes.length; i++) {
                    getDOM().insertBefore(nextSibling, nodes[i]);
                }
            }
            else {
                for (var i = 0; i < nodes.length; i++) {
                    getDOM().appendChild(parent, nodes[i]);
                }
            }
        }
    }
    function appendNodes(parent /** TODO #9100 */, nodes /** TODO #9100 */) {
        for (var i = 0; i < nodes.length; i++) {
            getDOM().appendChild(parent, nodes[i]);
        }
    }
    function decoratePreventDefault(eventHandler) {
        return function (event /** TODO #9100 */) {
            var allowDefaultBehavior = eventHandler(event);
            if (allowDefaultBehavior === false) {
                // TODO(tbosch): move preventDefault into event plugins...
                getDOM().preventDefault(event);
            }
        };
    }
    var COMPONENT_REGEX = /%COMP%/g;
    var COMPONENT_VARIABLE = '%COMP%';
    var HOST_ATTR = "_nghost-" + COMPONENT_VARIABLE;
    var CONTENT_ATTR = "_ngcontent-" + COMPONENT_VARIABLE;
    function _shimContentAttribute(componentShortId) {
        return CONTENT_ATTR.replace(COMPONENT_REGEX, componentShortId);
    }
    function _shimHostAttribute(componentShortId) {
        return HOST_ATTR.replace(COMPONENT_REGEX, componentShortId);
    }
    function _flattenStyles(compId, styles, target) {
        for (var i = 0; i < styles.length; i++) {
            var style = styles[i];
            if (Array.isArray(style)) {
                _flattenStyles(compId, style, target);
            }
            else {
                style = style.replace(COMPONENT_REGEX, compId);
                target.push(style);
            }
        }
        return target;
    }
    var NS_PREFIX_RE = /^:([^:]+):(.+)$/;
    function splitNamespace(name) {
        if (name[0] != ':') {
            return [null, name];
        }
        var match = name.match(NS_PREFIX_RE);
        return [match[1], match[2]];
    }

    var CORE_TOKENS = {
        'ApplicationRef': _angular_core.ApplicationRef,
        'NgZone': _angular_core.NgZone
    };
    var INSPECT_GLOBAL_NAME = 'ng.probe';
    var CORE_TOKENS_GLOBAL_NAME = 'ng.coreTokens';
    /**
     * Returns a {@link DebugElement} for the given native DOM element, or
     * null if the given native element does not have an Angular view associated
     * with it.
     */
    function inspectNativeElement(element /** TODO #9100 */) {
        return _angular_core.getDebugNode(element);
    }
    /**
     * @experimental
     */
    var NgProbeToken = (function () {
        function NgProbeToken(name, token) {
            this.name = name;
            this.token = token;
        }
        return NgProbeToken;
    }());
    function _createConditionalRootRenderer(rootRenderer /** TODO #9100 */, extraTokens) {
        if (_angular_core.isDevMode()) {
            return _createRootRenderer(rootRenderer, extraTokens);
        }
        return rootRenderer;
    }
    function _createRootRenderer(rootRenderer /** TODO #9100 */, extraTokens) {
        getDOM().setGlobalVar(INSPECT_GLOBAL_NAME, inspectNativeElement);
        getDOM().setGlobalVar(CORE_TOKENS_GLOBAL_NAME, StringMapWrapper.merge(CORE_TOKENS, _ngProbeTokensToMap(extraTokens || [])));
        return new DebugDomRootRenderer(rootRenderer);
    }
    function _ngProbeTokensToMap(tokens) {
        return tokens.reduce(function (prev, t) { return (prev[t.name] = t.token, prev); }, {});
    }
    /**
     * Providers which support debugging Angular applications (e.g. via `ng.probe`).
     */
    var ELEMENT_PROBE_PROVIDERS = [{
            provide: _angular_core.RootRenderer,
            useFactory: _createConditionalRootRenderer,
            deps: [DomRootRenderer, [NgProbeToken, new _angular_core.Optional()]]
        }];
    var ELEMENT_PROBE_PROVIDERS_PROD_MODE = [{
            provide: _angular_core.RootRenderer,
            useFactory: _createRootRenderer,
            deps: [DomRootRenderer, [NgProbeToken, new _angular_core.Optional()]]
        }];

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$5 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var DomEventsPlugin = (function (_super) {
        __extends$5(DomEventsPlugin, _super);
        function DomEventsPlugin() {
            _super.apply(this, arguments);
        }
        // This plugin should come last in the list of plugins, because it accepts all
        // events.
        DomEventsPlugin.prototype.supports = function (eventName) { return true; };
        DomEventsPlugin.prototype.addEventListener = function (element, eventName, handler) {
            var zone = this.manager.getZone();
            var outsideHandler = function (event /** TODO #9100 */) { return zone.runGuarded(function () { return handler(event); }); };
            return this.manager.getZone().runOutsideAngular(function () { return getDOM().onAndCancel(element, eventName, outsideHandler); });
        };
        DomEventsPlugin.prototype.addGlobalEventListener = function (target, eventName, handler) {
            var element = getDOM().getGlobalEventTarget(target);
            var zone = this.manager.getZone();
            var outsideHandler = function (event /** TODO #9100 */) { return zone.runGuarded(function () { return handler(event); }); };
            return this.manager.getZone().runOutsideAngular(function () { return getDOM().onAndCancel(element, eventName, outsideHandler); });
        };
        DomEventsPlugin.decorators = [
            { type: _angular_core.Injectable },
        ];
        /** @nocollapse */
        DomEventsPlugin.ctorParameters = [];
        return DomEventsPlugin;
    }(EventManagerPlugin));

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$7 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var _eventNames = {
        // pan
        'pan': true,
        'panstart': true,
        'panmove': true,
        'panend': true,
        'pancancel': true,
        'panleft': true,
        'panright': true,
        'panup': true,
        'pandown': true,
        // pinch
        'pinch': true,
        'pinchstart': true,
        'pinchmove': true,
        'pinchend': true,
        'pinchcancel': true,
        'pinchin': true,
        'pinchout': true,
        // press
        'press': true,
        'pressup': true,
        // rotate
        'rotate': true,
        'rotatestart': true,
        'rotatemove': true,
        'rotateend': true,
        'rotatecancel': true,
        // swipe
        'swipe': true,
        'swipeleft': true,
        'swiperight': true,
        'swipeup': true,
        'swipedown': true,
        // tap
        'tap': true,
    };
    var HammerGesturesPluginCommon = (function (_super) {
        __extends$7(HammerGesturesPluginCommon, _super);
        function HammerGesturesPluginCommon() {
            _super.call(this);
        }
        HammerGesturesPluginCommon.prototype.supports = function (eventName) {
            return _eventNames.hasOwnProperty(eventName.toLowerCase());
        };
        return HammerGesturesPluginCommon;
    }(EventManagerPlugin));

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$6 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    /**
     * A DI token that you can use to provide{@link HammerGestureConfig} to Angular. Use it to configure
     * Hammer gestures.
     *
     * @experimental
     */
    var HAMMER_GESTURE_CONFIG = new _angular_core.OpaqueToken('HammerGestureConfig');
    /**
     * @experimental
     */
    var HammerGestureConfig = (function () {
        function HammerGestureConfig() {
            this.events = [];
            this.overrides = {};
        }
        HammerGestureConfig.prototype.buildHammer = function (element) {
            var mc = new Hammer(element);
            mc.get('pinch').set({ enable: true });
            mc.get('rotate').set({ enable: true });
            for (var eventName in this.overrides) {
                mc.get(eventName).set(this.overrides[eventName]);
            }
            return mc;
        };
        HammerGestureConfig.decorators = [
            { type: _angular_core.Injectable },
        ];
        /** @nocollapse */
        HammerGestureConfig.ctorParameters = [];
        return HammerGestureConfig;
    }());
    var HammerGesturesPlugin = (function (_super) {
        __extends$6(HammerGesturesPlugin, _super);
        function HammerGesturesPlugin(_config) {
            _super.call(this);
            this._config = _config;
        }
        HammerGesturesPlugin.prototype.supports = function (eventName) {
            if (!_super.prototype.supports.call(this, eventName) && !this.isCustomEvent(eventName))
                return false;
            if (!isPresent(window['Hammer'])) {
                throw new Error("Hammer.js is not loaded, can not bind " + eventName + " event");
            }
            return true;
        };
        HammerGesturesPlugin.prototype.addEventListener = function (element, eventName, handler) {
            var _this = this;
            var zone = this.manager.getZone();
            eventName = eventName.toLowerCase();
            return zone.runOutsideAngular(function () {
                // Creating the manager bind events, must be done outside of angular
                var mc = _this._config.buildHammer(element);
                var callback = function (eventObj /** TODO #???? */) {
                    zone.runGuarded(function () { handler(eventObj); });
                };
                mc.on(eventName, callback);
                return function () { mc.off(eventName, callback); };
            });
        };
        HammerGesturesPlugin.prototype.isCustomEvent = function (eventName) { return this._config.events.indexOf(eventName) > -1; };
        HammerGesturesPlugin.decorators = [
            { type: _angular_core.Injectable },
        ];
        /** @nocollapse */
        HammerGesturesPlugin.ctorParameters = [
            { type: HammerGestureConfig, decorators: [{ type: _angular_core.Inject, args: [HAMMER_GESTURE_CONFIG,] },] },
        ];
        return HammerGesturesPlugin;
    }(HammerGesturesPluginCommon));

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$8 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var modifierKeys = ['alt', 'control', 'meta', 'shift'];
    var modifierKeyGetters = {
        'alt': function (event) { return event.altKey; },
        'control': function (event) { return event.ctrlKey; },
        'meta': function (event) { return event.metaKey; },
        'shift': function (event) { return event.shiftKey; }
    };
    /**
     * @experimental
     */
    var KeyEventsPlugin = (function (_super) {
        __extends$8(KeyEventsPlugin, _super);
        function KeyEventsPlugin() {
            _super.call(this);
        }
        KeyEventsPlugin.prototype.supports = function (eventName) {
            return isPresent(KeyEventsPlugin.parseEventName(eventName));
        };
        KeyEventsPlugin.prototype.addEventListener = function (element, eventName, handler) {
            var parsedEvent = KeyEventsPlugin.parseEventName(eventName);
            var outsideHandler = KeyEventsPlugin.eventCallback(element, parsedEvent['fullKey'], handler, this.manager.getZone());
            return this.manager.getZone().runOutsideAngular(function () {
                return getDOM().onAndCancel(element, parsedEvent['domEventName'], outsideHandler);
            });
        };
        KeyEventsPlugin.parseEventName = function (eventName) {
            var parts = eventName.toLowerCase().split('.');
            var domEventName = parts.shift();
            if ((parts.length === 0) || !(domEventName === 'keydown' || domEventName === 'keyup')) {
                return null;
            }
            var key = KeyEventsPlugin._normalizeKey(parts.pop());
            var fullKey = '';
            modifierKeys.forEach(function (modifierName) {
                if (ListWrapper.contains(parts, modifierName)) {
                    ListWrapper.remove(parts, modifierName);
                    fullKey += modifierName + '.';
                }
            });
            fullKey += key;
            if (parts.length != 0 || key.length === 0) {
                // returning null instead of throwing to let another plugin process the event
                return null;
            }
            var result = {};
            result['domEventName'] = domEventName;
            result['fullKey'] = fullKey;
            return result;
        };
        KeyEventsPlugin.getEventFullKey = function (event) {
            var fullKey = '';
            var key = getDOM().getEventKey(event);
            key = key.toLowerCase();
            if (key === ' ') {
                key = 'space'; // for readability
            }
            else if (key === '.') {
                key = 'dot'; // because '.' is used as a separator in event names
            }
            modifierKeys.forEach(function (modifierName) {
                if (modifierName != key) {
                    var modifierGetter = modifierKeyGetters[modifierName];
                    if (modifierGetter(event)) {
                        fullKey += modifierName + '.';
                    }
                }
            });
            fullKey += key;
            return fullKey;
        };
        KeyEventsPlugin.eventCallback = function (element, fullKey, handler, zone) {
            return function (event /** TODO #9100 */) {
                if (KeyEventsPlugin.getEventFullKey(event) === fullKey) {
                    zone.runGuarded(function () { return handler(event); });
                }
            };
        };
        /** @internal */
        KeyEventsPlugin._normalizeKey = function (keyName) {
            // TODO: switch to a StringMap if the mapping grows too much
            switch (keyName) {
                case 'esc':
                    return 'escape';
                default:
                    return keyName;
            }
        };
        KeyEventsPlugin.decorators = [
            { type: _angular_core.Injectable },
        ];
        /** @nocollapse */
        KeyEventsPlugin.ctorParameters = [];
        return KeyEventsPlugin;
    }(EventManagerPlugin));

    /**
     * A pattern that recognizes a commonly useful subset of URLs that are safe.
     *
     * This regular expression matches a subset of URLs that will not cause script
     * execution if used in URL context within a HTML document. Specifically, this
     * regular expression matches if (comment from here on and regex copied from
     * Soy's EscapingConventions):
     * (1) Either a protocol in a whitelist (http, https, mailto or ftp).
     * (2) or no protocol.  A protocol must be followed by a colon. The below
     *     allows that by allowing colons only after one of the characters [/?#].
     *     A colon after a hash (#) must be in the fragment.
     *     Otherwise, a colon after a (?) must be in a query.
     *     Otherwise, a colon after a single solidus (/) must be in a path.
     *     Otherwise, a colon after a double solidus (//) must be in the authority
     *     (before port).
     *
     * The pattern disallows &, used in HTML entity declarations before
     * one of the characters in [/?#]. This disallows HTML entities used in the
     * protocol name, which should never happen, e.g. "h&#116;tp" for "http".
     * It also disallows HTML entities in the first path part of a relative path,
     * e.g. "foo&lt;bar/baz".  Our existing escaping functions should not produce
     * that. More importantly, it disallows masking of a colon,
     * e.g. "javascript&#58;...".
     *
     * This regular expression was taken from the Closure sanitization library.
     */
    var SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file):|[^&:/?#]*(?:[/?#]|$))/gi;
    /** A pattern that matches safe data URLs. Only matches image, video and audio types. */
    var DATA_URL_PATTERN = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\/]+=*$/i;
    function sanitizeUrl(url) {
        url = String(url);
        if (url.match(SAFE_URL_PATTERN) || url.match(DATA_URL_PATTERN))
            return url;
        if (_angular_core.isDevMode()) {
            getDOM().log("WARNING: sanitizing unsafe URL value " + url + " (see http://g.co/ng/security#xss)");
        }
        return 'unsafe:' + url;
    }
    function sanitizeSrcset(srcset) {
        srcset = String(srcset);
        return srcset.split(',').map(function (srcset) { return sanitizeUrl(srcset.trim()); }).join(', ');
    }

    /** A <body> element that can be safely used to parse untrusted HTML. Lazily initialized below. */
    var inertElement = null;
    /** Lazily initialized to make sure the DOM adapter gets set before use. */
    var DOM = null;
    /** Returns an HTML element that is guaranteed to not execute code when creating elements in it. */
    function getInertElement() {
        if (inertElement)
            return inertElement;
        DOM = getDOM();
        // Prefer using <template> element if supported.
        var templateEl = DOM.createElement('template');
        if ('content' in templateEl)
            return templateEl;
        var doc = DOM.createHtmlDocument();
        inertElement = DOM.querySelector(doc, 'body');
        if (inertElement == null) {
            // usually there should be only one body element in the document, but IE doesn't have any, so we
            // need to create one.
            var html = DOM.createElement('html', doc);
            inertElement = DOM.createElement('body', doc);
            DOM.appendChild(html, inertElement);
            DOM.appendChild(doc, html);
        }
        return inertElement;
    }
    function tagSet(tags) {
        var res = {};
        for (var _i = 0, _a = tags.split(','); _i < _a.length; _i++) {
            var t = _a[_i];
            res[t] = true;
        }
        return res;
    }
    function merge() {
        var sets = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            sets[_i - 0] = arguments[_i];
        }
        var res = {};
        for (var _a = 0, sets_1 = sets; _a < sets_1.length; _a++) {
            var s = sets_1[_a];
            for (var v in s) {
                if (s.hasOwnProperty(v))
                    res[v] = true;
            }
        }
        return res;
    }
    // Good source of info about elements and attributes
    // http://dev.w3.org/html5/spec/Overview.html#semantics
    // http://simon.html5.org/html-elements
    // Safe Void Elements - HTML5
    // http://dev.w3.org/html5/spec/Overview.html#void-elements
    var VOID_ELEMENTS = tagSet('area,br,col,hr,img,wbr');
    // Elements that you can, intentionally, leave open (and which close themselves)
    // http://dev.w3.org/html5/spec/Overview.html#optional-tags
    var OPTIONAL_END_TAG_BLOCK_ELEMENTS = tagSet('colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr');
    var OPTIONAL_END_TAG_INLINE_ELEMENTS = tagSet('rp,rt');
    var OPTIONAL_END_TAG_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, OPTIONAL_END_TAG_BLOCK_ELEMENTS);
    // Safe Block Elements - HTML5
    var BLOCK_ELEMENTS = merge(OPTIONAL_END_TAG_BLOCK_ELEMENTS, tagSet('address,article,' +
        'aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,' +
        'h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul'));
    // Inline Elements - HTML5
    var INLINE_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, tagSet('a,abbr,acronym,audio,b,' +
        'bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,' +
        'samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video'));
    var VALID_ELEMENTS = merge(VOID_ELEMENTS, BLOCK_ELEMENTS, INLINE_ELEMENTS, OPTIONAL_END_TAG_ELEMENTS);
    // Attributes that have href and hence need to be sanitized
    var URI_ATTRS = tagSet('background,cite,href,itemtype,longdesc,poster,src,xlink:href');
    // Attributes that have special href set hence need to be sanitized
    var SRCSET_ATTRS = tagSet('srcset');
    var HTML_ATTRS = tagSet('abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,' +
        'compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,' +
        'ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,' +
        'scope,scrolling,shape,size,sizes,span,srclang,start,summary,tabindex,target,title,translate,type,usemap,' +
        'valign,value,vspace,width');
    // NB: This currently conciously doesn't support SVG. SVG sanitization has had several security
    // issues in the past, so it seems safer to leave it out if possible. If support for binding SVG via
    // innerHTML is required, SVG attributes should be added here.
    // NB: Sanitization does not allow <form> elements or other active elements (<button> etc). Those
    // can be sanitized, but they increase security surface area without a legitimate use case, so they
    // are left out here.
    var VALID_ATTRS = merge(URI_ATTRS, SRCSET_ATTRS, HTML_ATTRS);
    /**
     * SanitizingHtmlSerializer serializes a DOM fragment, stripping out any unsafe elements and unsafe
     * attributes.
     */
    var SanitizingHtmlSerializer = (function () {
        function SanitizingHtmlSerializer() {
            // Explicitly track if something was stripped, to avoid accidentally warning of sanitization just
            // because characters were re-encoded.
            this.sanitizedSomething = false;
            this.buf = [];
        }
        SanitizingHtmlSerializer.prototype.sanitizeChildren = function (el) {
            // This cannot use a TreeWalker, as it has to run on Angular's various DOM adapters.
            // However this code never accesses properties off of `document` before deleting its contents
            // again, so it shouldn't be vulnerable to DOM clobbering.
            var current = el.firstChild;
            while (current) {
                if (DOM.isElementNode(current)) {
                    this.startElement(current);
                }
                else if (DOM.isTextNode(current)) {
                    this.chars(DOM.nodeValue(current));
                }
                else {
                    // Strip non-element, non-text nodes.
                    this.sanitizedSomething = true;
                }
                if (DOM.firstChild(current)) {
                    current = DOM.firstChild(current);
                    continue;
                }
                while (current) {
                    // Leaving the element. Walk up and to the right, closing tags as we go.
                    if (DOM.isElementNode(current)) {
                        this.endElement(current);
                    }
                    if (DOM.nextSibling(current)) {
                        current = DOM.nextSibling(current);
                        break;
                    }
                    current = DOM.parentElement(current);
                }
            }
            return this.buf.join('');
        };
        SanitizingHtmlSerializer.prototype.startElement = function (element) {
            var _this = this;
            var tagName = DOM.nodeName(element).toLowerCase();
            if (!VALID_ELEMENTS.hasOwnProperty(tagName)) {
                this.sanitizedSomething = true;
                return;
            }
            this.buf.push('<');
            this.buf.push(tagName);
            DOM.attributeMap(element).forEach(function (value, attrName) {
                var lower = attrName.toLowerCase();
                if (!VALID_ATTRS.hasOwnProperty(lower)) {
                    _this.sanitizedSomething = true;
                    return;
                }
                // TODO(martinprobst): Special case image URIs for data:image/...
                if (URI_ATTRS[lower])
                    value = sanitizeUrl(value);
                if (SRCSET_ATTRS[lower])
                    value = sanitizeSrcset(value);
                _this.buf.push(' ');
                _this.buf.push(attrName);
                _this.buf.push('="');
                _this.buf.push(encodeEntities(value));
                _this.buf.push('"');
            });
            this.buf.push('>');
        };
        SanitizingHtmlSerializer.prototype.endElement = function (current) {
            var tagName = DOM.nodeName(current).toLowerCase();
            if (VALID_ELEMENTS.hasOwnProperty(tagName) && !VOID_ELEMENTS.hasOwnProperty(tagName)) {
                this.buf.push('</');
                this.buf.push(tagName);
                this.buf.push('>');
            }
        };
        SanitizingHtmlSerializer.prototype.chars = function (chars /** TODO #9100 */) { this.buf.push(encodeEntities(chars)); };
        return SanitizingHtmlSerializer;
    }());
    // Regular Expressions for parsing tags and attributes
    var SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    // ! to ~ is the ASCII range.
    var NON_ALPHANUMERIC_REGEXP = /([^\#-~ |!])/g;
    /**
     * Escapes all potentially dangerous characters, so that the
     * resulting string can be safely inserted into attribute or
     * element text.
     * @param value
     * @returns {string} escaped text
     */
    function encodeEntities(value) {
        return value.replace(/&/g, '&amp;')
            .replace(SURROGATE_PAIR_REGEXP, function (match) {
            var hi = match.charCodeAt(0);
            var low = match.charCodeAt(1);
            return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';
        })
            .replace(NON_ALPHANUMERIC_REGEXP, function (match) { return '&#' + match.charCodeAt(0) + ';'; })
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');
    }
    /**
     * When IE9-11 comes across an unknown namespaced attribute e.g. 'xlink:foo' it adds 'xmlns:ns1'
     * attribute to declare ns1 namespace and prefixes the attribute with 'ns1' (e.g. 'ns1:xlink:foo').
     *
     * This is undesirable since we don't want to allow any of these custom attributes. This method
     * strips them all.
     */
    function stripCustomNsAttrs(el) {
        DOM.attributeMap(el).forEach(function (_, attrName) {
            if (attrName === 'xmlns:ns1' || attrName.indexOf('ns1:') === 0) {
                DOM.removeAttribute(el, attrName);
            }
        });
        for (var _i = 0, _a = DOM.childNodesAsList(el); _i < _a.length; _i++) {
            var n = _a[_i];
            if (DOM.isElementNode(n))
                stripCustomNsAttrs(n);
        }
    }
    /**
     * Sanitizes the given unsafe, untrusted HTML fragment, and returns HTML text that is safe to add to
     * the DOM in a browser environment.
     */
    function sanitizeHtml(unsafeHtmlInput) {
        try {
            var containerEl = getInertElement();
            // Make sure unsafeHtml is actually a string (TypeScript types are not enforced at runtime).
            var unsafeHtml = unsafeHtmlInput ? String(unsafeHtmlInput) : '';
            // mXSS protection. Repeatedly parse the document to make sure it stabilizes, so that a browser
            // trying to auto-correct incorrect HTML cannot cause formerly inert HTML to become dangerous.
            var mXSSAttempts = 5;
            var parsedHtml = unsafeHtml;
            do {
                if (mXSSAttempts === 0) {
                    throw new Error('Failed to sanitize html because the input is unstable');
                }
                mXSSAttempts--;
                unsafeHtml = parsedHtml;
                DOM.setInnerHTML(containerEl, unsafeHtml);
                if (DOM.defaultDoc().documentMode) {
                    // strip custom-namespaced attributes on IE<=11
                    stripCustomNsAttrs(containerEl);
                }
                parsedHtml = DOM.getInnerHTML(containerEl);
            } while (unsafeHtml !== parsedHtml);
            var sanitizer = new SanitizingHtmlSerializer();
            var safeHtml = sanitizer.sanitizeChildren(DOM.getTemplateContent(containerEl) || containerEl);
            // Clear out the body element.
            var parent_1 = DOM.getTemplateContent(containerEl) || containerEl;
            for (var _i = 0, _a = DOM.childNodesAsList(parent_1); _i < _a.length; _i++) {
                var child = _a[_i];
                DOM.removeChild(parent_1, child);
            }
            if (_angular_core.isDevMode() && sanitizer.sanitizedSomething) {
                DOM.log('WARNING: sanitizing HTML stripped some content (see http://g.co/ng/security#xss).');
            }
            return safeHtml;
        }
        catch (e) {
            // In case anything goes wrong, clear out inertElement to reset the entire DOM structure.
            inertElement = null;
            throw e;
        }
    }

    /**
     * Regular expression for safe style values.
     *
     * Quotes (" and ') are allowed, but a check must be done elsewhere to ensure they're balanced.
     *
     * ',' allows multiple values to be assigned to the same property (e.g. background-attachment or
     * font-family) and hence could allow multiple values to get injected, but that should pose no risk
     * of XSS.
     *
     * The function expression checks only for XSS safety, not for CSS validity.
     *
     * This regular expression was taken from the Closure sanitization library, and augmented for
     * transformation values.
     */
    var VALUES = '[-,."\'%_!# a-zA-Z0-9]+';
    var TRANSFORMATION_FNS = '(?:matrix|translate|scale|rotate|skew|perspective)(?:X|Y|3d)?';
    var COLOR_FNS = '(?:rgb|hsl)a?';
    var FN_ARGS = '\\([-0-9.%, a-zA-Z]+\\)';
    var SAFE_STYLE_VALUE = new RegExp("^(" + VALUES + "|(?:" + TRANSFORMATION_FNS + "|" + COLOR_FNS + ")" + FN_ARGS + ")$", 'g');
    /**
     * Matches a `url(...)` value with an arbitrary argument as long as it does
     * not contain parentheses.
     *
     * The URL value still needs to be sanitized separately.
     *
     * `url(...)` values are a very common use case, e.g. for `background-image`. With carefully crafted
     * CSS style rules, it is possible to construct an information leak with `url` values in CSS, e.g.
     * by observing whether scroll bars are displayed, or character ranges used by a font face
     * definition.
     *
     * Angular only allows binding CSS values (as opposed to entire CSS rules), so it is unlikely that
     * binding a URL value without further cooperation from the page will cause an information leak, and
     * if so, it is just a leak, not a full blown XSS vulnerability.
     *
     * Given the common use case, low likelihood of attack vector, and low impact of an attack, this
     * code is permissive and allows URLs that sanitize otherwise.
     */
    var URL_RE = /^url\(([^)]+)\)$/;
    /**
     * Checks that quotes (" and ') are properly balanced inside a string. Assumes
     * that neither escape (\) nor any other character that could result in
     * breaking out of a string parsing context are allowed;
     * see http://www.w3.org/TR/css3-syntax/#string-token-diagram.
     *
     * This code was taken from the Closure sanitization library.
     */
    function hasBalancedQuotes(value) {
        var outsideSingle = true;
        var outsideDouble = true;
        for (var i = 0; i < value.length; i++) {
            var c = value.charAt(i);
            if (c === '\'' && outsideDouble) {
                outsideSingle = !outsideSingle;
            }
            else if (c === '"' && outsideSingle) {
                outsideDouble = !outsideDouble;
            }
        }
        return outsideSingle && outsideDouble;
    }
    /**
     * Sanitizes the given untrusted CSS style property value (i.e. not an entire object, just a single
     * value) and returns a value that is safe to use in a browser environment.
     */
    function sanitizeStyle(value) {
        value = String(value).trim(); // Make sure it's actually a string.
        if (!value)
            return '';
        // Single url(...) values are supported, but only for URLs that sanitize cleanly. See above for
        // reasoning behind this.
        var urlMatch = value.match(URL_RE);
        if ((urlMatch && sanitizeUrl(urlMatch[1]) === urlMatch[1]) ||
            value.match(SAFE_STYLE_VALUE) && hasBalancedQuotes(value)) {
            return value; // Safe style values.
        }
        if (_angular_core.isDevMode()) {
            getDOM().log("WARNING: sanitizing unsafe style value " + value + " (see http://g.co/ng/security#xss).");
        }
        return 'unsafe';
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$9 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    /**
     * DomSanitizer helps preventing Cross Site Scripting Security bugs (XSS) by sanitizing
     * values to be safe to use in the different DOM contexts.
     *
     * For example, when binding a URL in an `<a [href]="someValue">` hyperlink, `someValue` will be
     * sanitized so that an attacker cannot inject e.g. a `javascript:` URL that would execute code on
     * the website.
     *
     * In specific situations, it might be necessary to disable sanitization, for example if the
     * application genuinely needs to produce a `javascript:` style link with a dynamic value in it.
     * Users can bypass security by constructing a value with one of the `bypassSecurityTrust...`
     * methods, and then binding to that value from the template.
     *
     * These situations should be very rare, and extraordinary care must be taken to avoid creating a
     * Cross Site Scripting (XSS) security bug!
     *
     * When using `bypassSecurityTrust...`, make sure to call the method as early as possible and as
     * close as possible to the source of the value, to make it easy to verify no security bug is
     * created by its use.
     *
     * It is not required (and not recommended) to bypass security if the value is safe, e.g. a URL that
     * does not start with a suspicious protocol, or an HTML snippet that does not contain dangerous
     * code. The sanitizer leaves safe values intact.
     *
     * @security Calling any of the `bypassSecurityTrust...` APIs disables Angular's built-in
     * sanitization for the value passed in. Carefully check and audit all values and code paths going
     * into this call. Make sure any user data is appropriately escaped for this security context.
     * For more detail, see the [Security Guide](http://g.co/ng/security).
     *
     * @stable
     */
    var DomSanitizer = (function () {
        function DomSanitizer() {
        }
        return DomSanitizer;
    }());
    var DomSanitizerImpl = (function (_super) {
        __extends$9(DomSanitizerImpl, _super);
        function DomSanitizerImpl() {
            _super.apply(this, arguments);
        }
        DomSanitizerImpl.prototype.sanitize = function (ctx, value) {
            if (value == null)
                return null;
            switch (ctx) {
                case _angular_core.SecurityContext.NONE:
                    return value;
                case _angular_core.SecurityContext.HTML:
                    if (value instanceof SafeHtmlImpl)
                        return value.changingThisBreaksApplicationSecurity;
                    this.checkNotSafeValue(value, 'HTML');
                    return sanitizeHtml(String(value));
                case _angular_core.SecurityContext.STYLE:
                    if (value instanceof SafeStyleImpl)
                        return value.changingThisBreaksApplicationSecurity;
                    this.checkNotSafeValue(value, 'Style');
                    return sanitizeStyle(value);
                case _angular_core.SecurityContext.SCRIPT:
                    if (value instanceof SafeScriptImpl)
                        return value.changingThisBreaksApplicationSecurity;
                    this.checkNotSafeValue(value, 'Script');
                    throw new Error('unsafe value used in a script context');
                case _angular_core.SecurityContext.URL:
                    if (value instanceof SafeResourceUrlImpl || value instanceof SafeUrlImpl) {
                        // Allow resource URLs in URL contexts, they are strictly more trusted.
                        return value.changingThisBreaksApplicationSecurity;
                    }
                    this.checkNotSafeValue(value, 'URL');
                    return sanitizeUrl(String(value));
                case _angular_core.SecurityContext.RESOURCE_URL:
                    if (value instanceof SafeResourceUrlImpl) {
                        return value.changingThisBreaksApplicationSecurity;
                    }
                    this.checkNotSafeValue(value, 'ResourceURL');
                    throw new Error('unsafe value used in a resource URL context (see http://g.co/ng/security#xss)');
                default:
                    throw new Error("Unexpected SecurityContext " + ctx + " (see http://g.co/ng/security#xss)");
            }
        };
        DomSanitizerImpl.prototype.checkNotSafeValue = function (value, expectedType) {
            if (value instanceof SafeValueImpl) {
                throw new Error(("Required a safe " + expectedType + ", got a " + value.getTypeName() + " ") +
                    "(see http://g.co/ng/security#xss)");
            }
        };
        DomSanitizerImpl.prototype.bypassSecurityTrustHtml = function (value) { return new SafeHtmlImpl(value); };
        DomSanitizerImpl.prototype.bypassSecurityTrustStyle = function (value) { return new SafeStyleImpl(value); };
        DomSanitizerImpl.prototype.bypassSecurityTrustScript = function (value) { return new SafeScriptImpl(value); };
        DomSanitizerImpl.prototype.bypassSecurityTrustUrl = function (value) { return new SafeUrlImpl(value); };
        DomSanitizerImpl.prototype.bypassSecurityTrustResourceUrl = function (value) {
            return new SafeResourceUrlImpl(value);
        };
        DomSanitizerImpl.decorators = [
            { type: _angular_core.Injectable },
        ];
        /** @nocollapse */
        DomSanitizerImpl.ctorParameters = [];
        return DomSanitizerImpl;
    }(DomSanitizer));
    var SafeValueImpl = (function () {
        function SafeValueImpl(changingThisBreaksApplicationSecurity) {
            this.changingThisBreaksApplicationSecurity = changingThisBreaksApplicationSecurity;
            // empty
        }
        SafeValueImpl.prototype.toString = function () {
            return ("SafeValue must use [property]=binding: " + this.changingThisBreaksApplicationSecurity) +
                " (see http://g.co/ng/security#xss)";
        };
        return SafeValueImpl;
    }());
    var SafeHtmlImpl = (function (_super) {
        __extends$9(SafeHtmlImpl, _super);
        function SafeHtmlImpl() {
            _super.apply(this, arguments);
        }
        SafeHtmlImpl.prototype.getTypeName = function () { return 'HTML'; };
        return SafeHtmlImpl;
    }(SafeValueImpl));
    var SafeStyleImpl = (function (_super) {
        __extends$9(SafeStyleImpl, _super);
        function SafeStyleImpl() {
            _super.apply(this, arguments);
        }
        SafeStyleImpl.prototype.getTypeName = function () { return 'Style'; };
        return SafeStyleImpl;
    }(SafeValueImpl));
    var SafeScriptImpl = (function (_super) {
        __extends$9(SafeScriptImpl, _super);
        function SafeScriptImpl() {
            _super.apply(this, arguments);
        }
        SafeScriptImpl.prototype.getTypeName = function () { return 'Script'; };
        return SafeScriptImpl;
    }(SafeValueImpl));
    var SafeUrlImpl = (function (_super) {
        __extends$9(SafeUrlImpl, _super);
        function SafeUrlImpl() {
            _super.apply(this, arguments);
        }
        SafeUrlImpl.prototype.getTypeName = function () { return 'URL'; };
        return SafeUrlImpl;
    }(SafeValueImpl));
    var SafeResourceUrlImpl = (function (_super) {
        __extends$9(SafeResourceUrlImpl, _super);
        function SafeResourceUrlImpl() {
            _super.apply(this, arguments);
        }
        SafeResourceUrlImpl.prototype.getTypeName = function () { return 'ResourceURL'; };
        return SafeResourceUrlImpl;
    }(SafeValueImpl));

    var INTERNAL_BROWSER_PLATFORM_PROVIDERS = [
        { provide: _angular_core.PLATFORM_INITIALIZER, useValue: initDomAdapter, multi: true },
        { provide: _angular_common.PlatformLocation, useClass: BrowserPlatformLocation }
    ];
    /**
     * @security Replacing built-in sanitization providers exposes the application to XSS risks.
     * Attacker-controlled data introduced by an unsanitized provider could expose your
     * application to XSS risks. For more detail, see the [Security Guide](http://g.co/ng/security).
     * @experimental
     */
    var BROWSER_SANITIZATION_PROVIDERS = [
        { provide: _angular_core.Sanitizer, useExisting: DomSanitizer },
        { provide: DomSanitizer, useClass: DomSanitizerImpl },
    ];
    /**
     * @stable
     */
    var platformBrowser = _angular_core.createPlatformFactory(_angular_core.platformCore, 'browser', INTERNAL_BROWSER_PLATFORM_PROVIDERS);
    function initDomAdapter() {
        BrowserDomAdapter.makeCurrent();
        BrowserGetTestability.init();
    }
    function errorHandler() {
        return new _angular_core.ErrorHandler();
    }
    function _document() {
        return getDOM().defaultDoc();
    }
    function _resolveDefaultAnimationDriver() {
        if (getDOM().supportsWebAnimation()) {
            return new WebAnimationsDriver();
        }
        return AnimationDriver.NOOP;
    }
    /**
     * The ng module for the browser.
     *
     * @stable
     */
    var BrowserModule = (function () {
        function BrowserModule(parentModule) {
            if (parentModule) {
                throw new Error("BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.");
            }
        }
        BrowserModule.decorators = [
            { type: _angular_core.NgModule, args: [{
                        providers: [
                            BROWSER_SANITIZATION_PROVIDERS, { provide: _angular_core.ErrorHandler, useFactory: errorHandler, deps: [] },
                            { provide: DOCUMENT, useFactory: _document, deps: [] },
                            { provide: EVENT_MANAGER_PLUGINS, useClass: DomEventsPlugin, multi: true },
                            { provide: EVENT_MANAGER_PLUGINS, useClass: KeyEventsPlugin, multi: true },
                            { provide: EVENT_MANAGER_PLUGINS, useClass: HammerGesturesPlugin, multi: true },
                            { provide: HAMMER_GESTURE_CONFIG, useClass: HammerGestureConfig },
                            { provide: DomRootRenderer, useClass: DomRootRenderer_ },
                            { provide: _angular_core.RootRenderer, useExisting: DomRootRenderer },
                            { provide: SharedStylesHost, useExisting: DomSharedStylesHost },
                            { provide: AnimationDriver, useFactory: _resolveDefaultAnimationDriver }, DomSharedStylesHost,
                            _angular_core.Testability, EventManager, ELEMENT_PROBE_PROVIDERS, Title
                        ],
                        exports: [_angular_common.CommonModule, _angular_core.ApplicationModule]
                    },] },
        ];
        /** @nocollapse */
        BrowserModule.ctorParameters = [
            { type: BrowserModule, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.SkipSelf },] },
        ];
        return BrowserModule;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * JS version of browser APIs. This library can only run in the browser.
     */
    var win = typeof window !== 'undefined' && window || {};

    var ChangeDetectionPerfRecord = (function () {
        function ChangeDetectionPerfRecord(msPerTick, numTicks) {
            this.msPerTick = msPerTick;
            this.numTicks = numTicks;
        }
        return ChangeDetectionPerfRecord;
    }());
    /**
     * Entry point for all Angular debug tools. This object corresponds to the `ng`
     * global variable accessible in the dev console.
     */
    var AngularTools = (function () {
        function AngularTools(ref) {
            this.profiler = new AngularProfiler(ref);
        }
        return AngularTools;
    }());
    /**
     * Entry point for all Angular profiling-related debug tools. This object
     * corresponds to the `ng.profiler` in the dev console.
     */
    var AngularProfiler = (function () {
        function AngularProfiler(ref) {
            this.appRef = ref.injector.get(_angular_core.ApplicationRef);
        }
        /**
         * Exercises change detection in a loop and then prints the average amount of
         * time in milliseconds how long a single round of change detection takes for
         * the current state of the UI. It runs a minimum of 5 rounds for a minimum
         * of 500 milliseconds.
         *
         * Optionally, a user may pass a `config` parameter containing a map of
         * options. Supported options are:
         *
         * `record` (boolean) - causes the profiler to record a CPU profile while
         * it exercises the change detector. Example:
         *
         * ```
         * ng.profiler.timeChangeDetection({record: true})
         * ```
         */
        AngularProfiler.prototype.timeChangeDetection = function (config) {
            var record = config && config['record'];
            var profileName = 'Change Detection';
            // Profiler is not available in Android browsers, nor in IE 9 without dev tools opened
            var isProfilerAvailable = isPresent(win.console.profile);
            if (record && isProfilerAvailable) {
                win.console.profile(profileName);
            }
            var start = getDOM().performanceNow();
            var numTicks = 0;
            while (numTicks < 5 || (getDOM().performanceNow() - start) < 500) {
                this.appRef.tick();
                numTicks++;
            }
            var end = getDOM().performanceNow();
            if (record && isProfilerAvailable) {
                // need to cast to <any> because type checker thinks there's no argument
                // while in fact there is:
                //
                // https://developer.mozilla.org/en-US/docs/Web/API/Console/profileEnd
                win.console.profileEnd(profileName);
            }
            var msPerTick = (end - start) / numTicks;
            win.console.log("ran " + numTicks + " change detection cycles");
            win.console.log(msPerTick.toFixed(2) + " ms per check");
            return new ChangeDetectionPerfRecord(msPerTick, numTicks);
        };
        return AngularProfiler;
    }());

    var context = global$1;
    /**
     * Enabled Angular 2 debug tools that are accessible via your browser's
     * developer console.
     *
     * Usage:
     *
     * 1. Open developer console (e.g. in Chrome Ctrl + Shift + j)
     * 1. Type `ng.` (usually the console will show auto-complete suggestion)
     * 1. Try the change detection profiler `ng.profiler.timeChangeDetection()`
     *    then hit Enter.
     *
     * @experimental All debugging apis are currently experimental.
     */
    function enableDebugTools(ref) {
        context.ng = new AngularTools(ref);
        return ref;
    }
    /**
     * Disables Angular 2 tools.
     *
     * @experimental All debugging apis are currently experimental.
     */
    function disableDebugTools() {
        delete context.ng;
    }

    /**
     * Predicates for use with {@link DebugElement}'s query functions.
     *
     * @experimental All debugging apis are currently experimental.
     */
    var By = (function () {
        function By() {
        }
        /**
         * Match all elements.
         *
         * ## Example
         *
         * {@example platform-browser/dom/debug/ts/by/by.ts region='by_all'}
         */
        By.all = function () { return function (debugElement) { return true; }; };
        /**
         * Match elements by the given CSS selector.
         *
         * ## Example
         *
         * {@example platform-browser/dom/debug/ts/by/by.ts region='by_css'}
         */
        By.css = function (selector) {
            return function (debugElement) {
                return isPresent(debugElement.nativeElement) ?
                    getDOM().elementMatches(debugElement.nativeElement, selector) :
                    false;
            };
        };
        /**
         * Match elements that have the given directive present.
         *
         * ## Example
         *
         * {@example platform-browser/dom/debug/ts/by/by.ts region='by_directive'}
         */
        By.directive = function (type) {
            return function (debugElement) { return debugElement.providerTokens.indexOf(type) !== -1; };
        };
        return By;
    }());

    var __platform_browser_private__ = {
        BrowserPlatformLocation: BrowserPlatformLocation,
        DomAdapter: DomAdapter,
        BrowserDomAdapter: BrowserDomAdapter,
        BrowserGetTestability: BrowserGetTestability,
        getDOM: getDOM,
        setRootDomAdapter: setRootDomAdapter,
        DomRootRenderer_: DomRootRenderer_,
        DomRootRenderer: DomRootRenderer,
        DomSharedStylesHost: DomSharedStylesHost,
        SharedStylesHost: SharedStylesHost,
        ELEMENT_PROBE_PROVIDERS: ELEMENT_PROBE_PROVIDERS,
        DomEventsPlugin: DomEventsPlugin,
        KeyEventsPlugin: KeyEventsPlugin,
        HammerGesturesPlugin: HammerGesturesPlugin,
        initDomAdapter: initDomAdapter,
        INTERNAL_BROWSER_PLATFORM_PROVIDERS: INTERNAL_BROWSER_PLATFORM_PROVIDERS,
        BROWSER_SANITIZATION_PROVIDERS: BROWSER_SANITIZATION_PROVIDERS
    };

    exports.BrowserModule = BrowserModule;
    exports.platformBrowser = platformBrowser;
    exports.Title = Title;
    exports.disableDebugTools = disableDebugTools;
    exports.enableDebugTools = enableDebugTools;
    exports.AnimationDriver = AnimationDriver;
    exports.By = By;
    exports.NgProbeToken = NgProbeToken;
    exports.DOCUMENT = DOCUMENT;
    exports.EVENT_MANAGER_PLUGINS = EVENT_MANAGER_PLUGINS;
    exports.EventManager = EventManager;
    exports.HAMMER_GESTURE_CONFIG = HAMMER_GESTURE_CONFIG;
    exports.HammerGestureConfig = HammerGestureConfig;
    exports.DomSanitizer = DomSanitizer;
    exports.__platform_browser_private__ = __platform_browser_private__;

}));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"@angular/common":4,"@angular/core":6}],9:[function(require,module,exports){
"use strict";
var root_1 = require('./util/root');
var toSubscriber_1 = require('./util/toSubscriber');
var observable_1 = require('./symbol/observable');
/**
 * A representation of any set of values over any amount of time. This the most basic building block
 * of RxJS.
 *
 * @class Observable<T>
 */
var Observable = (function () {
    /**
     * @constructor
     * @param {Function} subscribe the function that is  called when the Observable is
     * initially subscribed to. This function is given a Subscriber, to which new values
     * can be `next`ed, or an `error` method can be called to raise an error, or
     * `complete` can be called to notify of a successful completion.
     */
    function Observable(subscribe) {
        this._isScalar = false;
        if (subscribe) {
            this._subscribe = subscribe;
        }
    }
    /**
     * Creates a new Observable, with this Observable as the source, and the passed
     * operator defined as the new observable's operator.
     * @method lift
     * @param {Operator} operator the operator defining the operation to take on the observable
     * @return {Observable} a new observable with the Operator applied
     */
    Observable.prototype.lift = function (operator) {
        var observable = new Observable();
        observable.source = this;
        observable.operator = operator;
        return observable;
    };
    /**
     * Registers handlers for handling emitted values, error and completions from the observable, and
     *  executes the observable's subscriber function, which will take action to set up the underlying data stream
     * @method subscribe
     * @param {PartialObserver|Function} observerOrNext (optional) either an observer defining all functions to be called,
     *  or the first of three possible handlers, which is the handler for each value emitted from the observable.
     * @param {Function} error (optional) a handler for a terminal event resulting from an error. If no error handler is provided,
     *  the error will be thrown as unhandled
     * @param {Function} complete (optional) a handler for a terminal event resulting from successful completion.
     * @return {ISubscription} a subscription reference to the registered handlers
     */
    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
        var operator = this.operator;
        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);
        if (operator) {
            operator.call(sink, this);
        }
        else {
            sink.add(this._subscribe(sink));
        }
        if (sink.syncErrorThrowable) {
            sink.syncErrorThrowable = false;
            if (sink.syncErrorThrown) {
                throw sink.syncErrorValue;
            }
        }
        return sink;
    };
    /**
     * @method forEach
     * @param {Function} next a handler for each value emitted by the observable
     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise
     * @return {Promise} a promise that either resolves on observable completion or
     *  rejects with the handled error
     */
    Observable.prototype.forEach = function (next, PromiseCtor) {
        var _this = this;
        if (!PromiseCtor) {
            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {
                PromiseCtor = root_1.root.Rx.config.Promise;
            }
            else if (root_1.root.Promise) {
                PromiseCtor = root_1.root.Promise;
            }
        }
        if (!PromiseCtor) {
            throw new Error('no Promise impl found');
        }
        return new PromiseCtor(function (resolve, reject) {
            var subscription = _this.subscribe(function (value) {
                if (subscription) {
                    // if there is a subscription, then we can surmise
                    // the next handling is asynchronous. Any errors thrown
                    // need to be rejected explicitly and unsubscribe must be
                    // called manually
                    try {
                        next(value);
                    }
                    catch (err) {
                        reject(err);
                        subscription.unsubscribe();
                    }
                }
                else {
                    // if there is NO subscription, then we're getting a nexted
                    // value synchronously during subscription. We can just call it.
                    // If it errors, Observable's `subscribe` will ensure the
                    // unsubscription logic is called, then synchronously rethrow the error.
                    // After that, Promise will trap the error and send it
                    // down the rejection path.
                    next(value);
                }
            }, reject, resolve);
        });
    };
    Observable.prototype._subscribe = function (subscriber) {
        return this.source.subscribe(subscriber);
    };
    /**
     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable
     * @method Symbol.observable
     * @return {Observable} this instance of the observable
     */
    Observable.prototype[observable_1.$$observable] = function () {
        return this;
    };
    // HACK: Since TypeScript inherits static properties too, we have to
    // fight against TypeScript here so Subject can have a different static create signature
    /**
     * Creates a new cold Observable by calling the Observable constructor
     * @static true
     * @owner Observable
     * @method create
     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor
     * @return {Observable} a new cold observable
     */
    Observable.create = function (subscribe) {
        return new Observable(subscribe);
    };
    return Observable;
}());
exports.Observable = Observable;

},{"./symbol/observable":15,"./util/root":23,"./util/toSubscriber":24}],10:[function(require,module,exports){
"use strict";
exports.empty = {
    closed: true,
    next: function (value) { },
    error: function (err) { throw err; },
    complete: function () { }
};

},{}],11:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('./Observable');
var Subscriber_1 = require('./Subscriber');
var Subscription_1 = require('./Subscription');
var ObjectUnsubscribedError_1 = require('./util/ObjectUnsubscribedError');
var SubjectSubscription_1 = require('./SubjectSubscription');
var rxSubscriber_1 = require('./symbol/rxSubscriber');
/**
 * @class SubjectSubscriber<T>
 */
var SubjectSubscriber = (function (_super) {
    __extends(SubjectSubscriber, _super);
    function SubjectSubscriber(destination) {
        _super.call(this, destination);
        this.destination = destination;
    }
    return SubjectSubscriber;
}(Subscriber_1.Subscriber));
exports.SubjectSubscriber = SubjectSubscriber;
/**
 * @class Subject<T>
 */
var Subject = (function (_super) {
    __extends(Subject, _super);
    function Subject() {
        _super.call(this);
        this.observers = [];
        this.closed = false;
        this.isStopped = false;
        this.hasError = false;
        this.thrownError = null;
    }
    Subject.prototype[rxSubscriber_1.$$rxSubscriber] = function () {
        return new SubjectSubscriber(this);
    };
    Subject.prototype.lift = function (operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
    };
    Subject.prototype.next = function (value) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        if (!this.isStopped) {
            var observers = this.observers;
            var len = observers.length;
            var copy = observers.slice();
            for (var i = 0; i < len; i++) {
                copy[i].next(value);
            }
        }
    };
    Subject.prototype.error = function (err) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        this.hasError = true;
        this.thrownError = err;
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].error(err);
        }
        this.observers.length = 0;
    };
    Subject.prototype.complete = function () {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].complete();
        }
        this.observers.length = 0;
    };
    Subject.prototype.unsubscribe = function () {
        this.isStopped = true;
        this.closed = true;
        this.observers = null;
    };
    Subject.prototype._subscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        else if (this.hasError) {
            subscriber.error(this.thrownError);
            return Subscription_1.Subscription.EMPTY;
        }
        else if (this.isStopped) {
            subscriber.complete();
            return Subscription_1.Subscription.EMPTY;
        }
        else {
            this.observers.push(subscriber);
            return new SubjectSubscription_1.SubjectSubscription(this, subscriber);
        }
    };
    Subject.prototype.asObservable = function () {
        var observable = new Observable_1.Observable();
        observable.source = this;
        return observable;
    };
    Subject.create = function (destination, source) {
        return new AnonymousSubject(destination, source);
    };
    return Subject;
}(Observable_1.Observable));
exports.Subject = Subject;
/**
 * @class AnonymousSubject<T>
 */
var AnonymousSubject = (function (_super) {
    __extends(AnonymousSubject, _super);
    function AnonymousSubject(destination, source) {
        _super.call(this);
        this.destination = destination;
        this.source = source;
    }
    AnonymousSubject.prototype.next = function (value) {
        var destination = this.destination;
        if (destination && destination.next) {
            destination.next(value);
        }
    };
    AnonymousSubject.prototype.error = function (err) {
        var destination = this.destination;
        if (destination && destination.error) {
            this.destination.error(err);
        }
    };
    AnonymousSubject.prototype.complete = function () {
        var destination = this.destination;
        if (destination && destination.complete) {
            this.destination.complete();
        }
    };
    AnonymousSubject.prototype._subscribe = function (subscriber) {
        var source = this.source;
        if (source) {
            return this.source.subscribe(subscriber);
        }
        else {
            return Subscription_1.Subscription.EMPTY;
        }
    };
    return AnonymousSubject;
}(Subject));
exports.AnonymousSubject = AnonymousSubject;

},{"./Observable":9,"./SubjectSubscription":12,"./Subscriber":13,"./Subscription":14,"./symbol/rxSubscriber":16,"./util/ObjectUnsubscribedError":17}],12:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscription_1 = require('./Subscription');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SubjectSubscription = (function (_super) {
    __extends(SubjectSubscription, _super);
    function SubjectSubscription(subject, subscriber) {
        _super.call(this);
        this.subject = subject;
        this.subscriber = subscriber;
        this.closed = false;
    }
    SubjectSubscription.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.closed = true;
        var subject = this.subject;
        var observers = subject.observers;
        this.subject = null;
        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
            return;
        }
        var subscriberIndex = observers.indexOf(this.subscriber);
        if (subscriberIndex !== -1) {
            observers.splice(subscriberIndex, 1);
        }
    };
    return SubjectSubscription;
}(Subscription_1.Subscription));
exports.SubjectSubscription = SubjectSubscription;

},{"./Subscription":14}],13:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var isFunction_1 = require('./util/isFunction');
var Subscription_1 = require('./Subscription');
var Observer_1 = require('./Observer');
var rxSubscriber_1 = require('./symbol/rxSubscriber');
/**
 * Implements the {@link Observer} interface and extends the
 * {@link Subscription} class. While the {@link Observer} is the public API for
 * consuming the values of an {@link Observable}, all Observers get converted to
 * a Subscriber, in order to provide Subscription-like capabilities such as
 * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for
 * implementing operators, but it is rarely used as a public API.
 *
 * @class Subscriber<T>
 */
var Subscriber = (function (_super) {
    __extends(Subscriber, _super);
    /**
     * @param {Observer|function(value: T): void} [destinationOrNext] A partially
     * defined Observer or a `next` callback function.
     * @param {function(e: ?any): void} [error] The `error` callback of an
     * Observer.
     * @param {function(): void} [complete] The `complete` callback of an
     * Observer.
     */
    function Subscriber(destinationOrNext, error, complete) {
        _super.call(this);
        this.syncErrorValue = null;
        this.syncErrorThrown = false;
        this.syncErrorThrowable = false;
        this.isStopped = false;
        switch (arguments.length) {
            case 0:
                this.destination = Observer_1.empty;
                break;
            case 1:
                if (!destinationOrNext) {
                    this.destination = Observer_1.empty;
                    break;
                }
                if (typeof destinationOrNext === 'object') {
                    if (destinationOrNext instanceof Subscriber) {
                        this.destination = destinationOrNext;
                        this.destination.add(this);
                    }
                    else {
                        this.syncErrorThrowable = true;
                        this.destination = new SafeSubscriber(this, destinationOrNext);
                    }
                    break;
                }
            default:
                this.syncErrorThrowable = true;
                this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);
                break;
        }
    }
    Subscriber.prototype[rxSubscriber_1.$$rxSubscriber] = function () { return this; };
    /**
     * A static factory for a Subscriber, given a (potentially partial) definition
     * of an Observer.
     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.
     * @param {function(e: ?any): void} [error] The `error` callback of an
     * Observer.
     * @param {function(): void} [complete] The `complete` callback of an
     * Observer.
     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)
     * Observer represented by the given arguments.
     */
    Subscriber.create = function (next, error, complete) {
        var subscriber = new Subscriber(next, error, complete);
        subscriber.syncErrorThrowable = false;
        return subscriber;
    };
    /**
     * The {@link Observer} callback to receive notifications of type `next` from
     * the Observable, with a value. The Observable may call this method 0 or more
     * times.
     * @param {T} [value] The `next` value.
     * @return {void}
     */
    Subscriber.prototype.next = function (value) {
        if (!this.isStopped) {
            this._next(value);
        }
    };
    /**
     * The {@link Observer} callback to receive notifications of type `error` from
     * the Observable, with an attached {@link Error}. Notifies the Observer that
     * the Observable has experienced an error condition.
     * @param {any} [err] The `error` exception.
     * @return {void}
     */
    Subscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            this.isStopped = true;
            this._error(err);
        }
    };
    /**
     * The {@link Observer} callback to receive a valueless notification of type
     * `complete` from the Observable. Notifies the Observer that the Observable
     * has finished sending push-based notifications.
     * @return {void}
     */
    Subscriber.prototype.complete = function () {
        if (!this.isStopped) {
            this.isStopped = true;
            this._complete();
        }
    };
    Subscriber.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
    };
    Subscriber.prototype._next = function (value) {
        this.destination.next(value);
    };
    Subscriber.prototype._error = function (err) {
        this.destination.error(err);
        this.unsubscribe();
    };
    Subscriber.prototype._complete = function () {
        this.destination.complete();
        this.unsubscribe();
    };
    return Subscriber;
}(Subscription_1.Subscription));
exports.Subscriber = Subscriber;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SafeSubscriber = (function (_super) {
    __extends(SafeSubscriber, _super);
    function SafeSubscriber(_parent, observerOrNext, error, complete) {
        _super.call(this);
        this._parent = _parent;
        var next;
        var context = this;
        if (isFunction_1.isFunction(observerOrNext)) {
            next = observerOrNext;
        }
        else if (observerOrNext) {
            context = observerOrNext;
            next = observerOrNext.next;
            error = observerOrNext.error;
            complete = observerOrNext.complete;
            if (isFunction_1.isFunction(context.unsubscribe)) {
                this.add(context.unsubscribe.bind(context));
            }
            context.unsubscribe = this.unsubscribe.bind(this);
        }
        this._context = context;
        this._next = next;
        this._error = error;
        this._complete = complete;
    }
    SafeSubscriber.prototype.next = function (value) {
        if (!this.isStopped && this._next) {
            var _parent = this._parent;
            if (!_parent.syncErrorThrowable) {
                this.__tryOrUnsub(this._next, value);
            }
            else if (this.__tryOrSetError(_parent, this._next, value)) {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _parent = this._parent;
            if (this._error) {
                if (!_parent.syncErrorThrowable) {
                    this.__tryOrUnsub(this._error, err);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parent, this._error, err);
                    this.unsubscribe();
                }
            }
            else if (!_parent.syncErrorThrowable) {
                this.unsubscribe();
                throw err;
            }
            else {
                _parent.syncErrorValue = err;
                _parent.syncErrorThrown = true;
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.complete = function () {
        if (!this.isStopped) {
            var _parent = this._parent;
            if (this._complete) {
                if (!_parent.syncErrorThrowable) {
                    this.__tryOrUnsub(this._complete);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parent, this._complete);
                    this.unsubscribe();
                }
            }
            else {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            this.unsubscribe();
            throw err;
        }
    };
    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            parent.syncErrorValue = err;
            parent.syncErrorThrown = true;
            return true;
        }
        return false;
    };
    SafeSubscriber.prototype._unsubscribe = function () {
        var _parent = this._parent;
        this._context = null;
        this._parent = null;
        _parent.unsubscribe();
    };
    return SafeSubscriber;
}(Subscriber));

},{"./Observer":10,"./Subscription":14,"./symbol/rxSubscriber":16,"./util/isFunction":21}],14:[function(require,module,exports){
"use strict";
var isArray_1 = require('./util/isArray');
var isObject_1 = require('./util/isObject');
var isFunction_1 = require('./util/isFunction');
var tryCatch_1 = require('./util/tryCatch');
var errorObject_1 = require('./util/errorObject');
var UnsubscriptionError_1 = require('./util/UnsubscriptionError');
/**
 * Represents a disposable resource, such as the execution of an Observable. A
 * Subscription has one important method, `unsubscribe`, that takes no argument
 * and just disposes the resource held by the subscription.
 *
 * Additionally, subscriptions may be grouped together through the `add()`
 * method, which will attach a child Subscription to the current Subscription.
 * When a Subscription is unsubscribed, all its children (and its grandchildren)
 * will be unsubscribed as well.
 *
 * @class Subscription
 */
var Subscription = (function () {
    /**
     * @param {function(): void} [unsubscribe] A function describing how to
     * perform the disposal of resources when the `unsubscribe` method is called.
     */
    function Subscription(unsubscribe) {
        /**
         * A flag to indicate whether this Subscription has already been unsubscribed.
         * @type {boolean}
         */
        this.closed = false;
        if (unsubscribe) {
            this._unsubscribe = unsubscribe;
        }
    }
    /**
     * Disposes the resources held by the subscription. May, for instance, cancel
     * an ongoing Observable execution or cancel any other type of work that
     * started when the Subscription was created.
     * @return {void}
     */
    Subscription.prototype.unsubscribe = function () {
        var hasErrors = false;
        var errors;
        if (this.closed) {
            return;
        }
        this.closed = true;
        var _a = this, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
        this._subscriptions = null;
        if (isFunction_1.isFunction(_unsubscribe)) {
            var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);
            if (trial === errorObject_1.errorObject) {
                hasErrors = true;
                (errors = errors || []).push(errorObject_1.errorObject.e);
            }
        }
        if (isArray_1.isArray(_subscriptions)) {
            var index = -1;
            var len = _subscriptions.length;
            while (++index < len) {
                var sub = _subscriptions[index];
                if (isObject_1.isObject(sub)) {
                    var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);
                    if (trial === errorObject_1.errorObject) {
                        hasErrors = true;
                        errors = errors || [];
                        var err = errorObject_1.errorObject.e;
                        if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
                            errors = errors.concat(err.errors);
                        }
                        else {
                            errors.push(err);
                        }
                    }
                }
            }
        }
        if (hasErrors) {
            throw new UnsubscriptionError_1.UnsubscriptionError(errors);
        }
    };
    /**
     * Adds a tear down to be called during the unsubscribe() of this
     * Subscription.
     *
     * If the tear down being added is a subscription that is already
     * unsubscribed, is the same reference `add` is being called on, or is
     * `Subscription.EMPTY`, it will not be added.
     *
     * If this subscription is already in an `closed` state, the passed
     * tear down logic will be executed immediately.
     *
     * @param {TeardownLogic} teardown The additional logic to execute on
     * teardown.
     * @return {Subscription} Returns the Subscription used or created to be
     * added to the inner subscriptions list. This Subscription can be used with
     * `remove()` to remove the passed teardown logic from the inner subscriptions
     * list.
     */
    Subscription.prototype.add = function (teardown) {
        if (!teardown || (teardown === Subscription.EMPTY)) {
            return Subscription.EMPTY;
        }
        if (teardown === this) {
            return this;
        }
        var sub = teardown;
        switch (typeof teardown) {
            case 'function':
                sub = new Subscription(teardown);
            case 'object':
                if (sub.closed || typeof sub.unsubscribe !== 'function') {
                    break;
                }
                else if (this.closed) {
                    sub.unsubscribe();
                }
                else {
                    (this._subscriptions || (this._subscriptions = [])).push(sub);
                }
                break;
            default:
                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
        }
        return sub;
    };
    /**
     * Removes a Subscription from the internal list of subscriptions that will
     * unsubscribe during the unsubscribe process of this Subscription.
     * @param {Subscription} subscription The subscription to remove.
     * @return {void}
     */
    Subscription.prototype.remove = function (subscription) {
        // HACK: This might be redundant because of the logic in `add()`
        if (subscription == null || (subscription === this) || (subscription === Subscription.EMPTY)) {
            return;
        }
        var subscriptions = this._subscriptions;
        if (subscriptions) {
            var subscriptionIndex = subscriptions.indexOf(subscription);
            if (subscriptionIndex !== -1) {
                subscriptions.splice(subscriptionIndex, 1);
            }
        }
    };
    Subscription.EMPTY = (function (empty) {
        empty.closed = true;
        return empty;
    }(new Subscription()));
    return Subscription;
}());
exports.Subscription = Subscription;

},{"./util/UnsubscriptionError":18,"./util/errorObject":19,"./util/isArray":20,"./util/isFunction":21,"./util/isObject":22,"./util/tryCatch":25}],15:[function(require,module,exports){
"use strict";
var root_1 = require('../util/root');
function getSymbolObservable(context) {
    var $$observable;
    var Symbol = context.Symbol;
    if (typeof Symbol === 'function') {
        if (Symbol.observable) {
            $$observable = Symbol.observable;
        }
        else {
            $$observable = Symbol('observable');
            Symbol.observable = $$observable;
        }
    }
    else {
        $$observable = '@@observable';
    }
    return $$observable;
}
exports.getSymbolObservable = getSymbolObservable;
exports.$$observable = getSymbolObservable(root_1.root);

},{"../util/root":23}],16:[function(require,module,exports){
"use strict";
var root_1 = require('../util/root');
var Symbol = root_1.root.Symbol;
exports.$$rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?
    Symbol.for('rxSubscriber') : '@@rxSubscriber';

},{"../util/root":23}],17:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when an action is invalid because the object has been
 * unsubscribed.
 *
 * @see {@link Subject}
 * @see {@link BehaviorSubject}
 *
 * @class ObjectUnsubscribedError
 */
var ObjectUnsubscribedError = (function (_super) {
    __extends(ObjectUnsubscribedError, _super);
    function ObjectUnsubscribedError() {
        var err = _super.call(this, 'object unsubscribed');
        this.name = err.name = 'ObjectUnsubscribedError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return ObjectUnsubscribedError;
}(Error));
exports.ObjectUnsubscribedError = ObjectUnsubscribedError;

},{}],18:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when one or more errors have occurred during the
 * `unsubscribe` of a {@link Subscription}.
 */
var UnsubscriptionError = (function (_super) {
    __extends(UnsubscriptionError, _super);
    function UnsubscriptionError(errors) {
        _super.call(this);
        this.errors = errors;
        var err = Error.call(this, errors ?
            errors.length + " errors occurred during unsubscription:\n  " + errors.map(function (err, i) { return ((i + 1) + ") " + err.toString()); }).join('\n  ') : '');
        this.name = err.name = 'UnsubscriptionError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return UnsubscriptionError;
}(Error));
exports.UnsubscriptionError = UnsubscriptionError;

},{}],19:[function(require,module,exports){
"use strict";
// typeof any so that it we don't have to cast when comparing a result to the error object
exports.errorObject = { e: {} };

},{}],20:[function(require,module,exports){
"use strict";
exports.isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });

},{}],21:[function(require,module,exports){
"use strict";
function isFunction(x) {
    return typeof x === 'function';
}
exports.isFunction = isFunction;

},{}],22:[function(require,module,exports){
"use strict";
function isObject(x) {
    return x != null && typeof x === 'object';
}
exports.isObject = isObject;

},{}],23:[function(require,module,exports){
(function (global){
"use strict";
var objectTypes = {
    'boolean': false,
    'function': true,
    'object': true,
    'number': false,
    'string': false,
    'undefined': false
};
exports.root = (objectTypes[typeof self] && self) || (objectTypes[typeof window] && window);
var freeGlobal = objectTypes[typeof global] && global;
if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
    exports.root = freeGlobal;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],24:[function(require,module,exports){
"use strict";
var Subscriber_1 = require('../Subscriber');
var rxSubscriber_1 = require('../symbol/rxSubscriber');
function toSubscriber(nextOrObserver, error, complete) {
    if (nextOrObserver) {
        if (nextOrObserver instanceof Subscriber_1.Subscriber) {
            return nextOrObserver;
        }
        if (nextOrObserver[rxSubscriber_1.$$rxSubscriber]) {
            return nextOrObserver[rxSubscriber_1.$$rxSubscriber]();
        }
    }
    if (!nextOrObserver && !error && !complete) {
        return new Subscriber_1.Subscriber();
    }
    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);
}
exports.toSubscriber = toSubscriber;

},{"../Subscriber":13,"../symbol/rxSubscriber":16}],25:[function(require,module,exports){
"use strict";
var errorObject_1 = require('./errorObject');
var tryCatchTarget;
function tryCatcher() {
    try {
        return tryCatchTarget.apply(this, arguments);
    }
    catch (e) {
        errorObject_1.errorObject.e = e;
        return errorObject_1.errorObject;
    }
}
function tryCatch(fn) {
    tryCatchTarget = fn;
    return tryCatcher;
}
exports.tryCatch = tryCatch;
;

},{"./errorObject":19}]},{},[3])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJhcHAvYXBwLmNvbXBvbmVudC50cyIsImFwcC9hcHAubW9kdWxlLnRzIiwiYXBwL21haW4udHMiLCJub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tbW9uL2J1bmRsZXMvY29tbW9uLnVtZC5qcyIsIm5vZGVfbW9kdWxlcy9AYW5ndWxhci9jb21waWxlci9idW5kbGVzL2NvbXBpbGVyLnVtZC5qcyIsIm5vZGVfbW9kdWxlcy9AYW5ndWxhci9jb3JlL2J1bmRsZXMvY29yZS51bWQuanMiLCJub2RlX21vZHVsZXMvQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci1keW5hbWljL2J1bmRsZXMvcGxhdGZvcm0tYnJvd3Nlci1keW5hbWljLnVtZC5qcyIsIm5vZGVfbW9kdWxlcy9AYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyL2J1bmRsZXMvcGxhdGZvcm0tYnJvd3Nlci51bWQuanMiLCJub2RlX21vZHVsZXMvcnhqcy9PYnNlcnZhYmxlLmpzIiwibm9kZV9tb2R1bGVzL3J4anMvT2JzZXJ2ZXIuanMiLCJub2RlX21vZHVsZXMvcnhqcy9TdWJqZWN0LmpzIiwibm9kZV9tb2R1bGVzL3J4anMvU3ViamVjdFN1YnNjcmlwdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9yeGpzL1N1YnNjcmliZXIuanMiLCJub2RlX21vZHVsZXMvcnhqcy9TdWJzY3JpcHRpb24uanMiLCJub2RlX21vZHVsZXMvcnhqcy9zeW1ib2wvb2JzZXJ2YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9yeGpzL3N5bWJvbC9yeFN1YnNjcmliZXIuanMiLCJub2RlX21vZHVsZXMvcnhqcy91dGlsL09iamVjdFVuc3Vic2NyaWJlZEVycm9yLmpzIiwibm9kZV9tb2R1bGVzL3J4anMvdXRpbC9VbnN1YnNjcmlwdGlvbkVycm9yLmpzIiwibm9kZV9tb2R1bGVzL3J4anMvdXRpbC9lcnJvck9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9yeGpzL3V0aWwvaXNBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9yeGpzL3V0aWwvaXNGdW5jdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9yeGpzL3V0aWwvaXNPYmplY3QuanMiLCJub2RlX21vZHVsZXMvcnhqcy91dGlsL3Jvb3QuanMiLCJub2RlX21vZHVsZXMvcnhqcy91dGlsL3RvU3Vic2NyaWJlci5qcyIsIm5vZGVfbW9kdWxlcy9yeGpzL3V0aWwvdHJ5Q2F0Y2guanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7O0FDQUEsdUJBQTBCLGVBQWUsQ0FBQyxDQUFBO0FBSzFDO0FBQTRCLENBQUM7QUFKN0I7SUFBQyxnQkFBUyxDQUFDO1FBQ1AsUUFBUSxFQUFFLFFBQVE7UUFDbEIsUUFBUSxFQUFFLCtCQUErQjtLQUM1QyxDQUFDOztnQkFBQTtBQUNXLG9CQUFZLGVBQUksQ0FBQTs7Ozs7Ozs7Ozs7O0FDTDdCLHVCQUE4QixlQUFlLENBQUMsQ0FBQTtBQUM5QyxtQ0FBOEIsMkJBQTJCLENBQUMsQ0FBQTtBQUMxRCxnQ0FBK0IsaUJBQWlCLENBQUMsQ0FBQTtBQU1qRDtBQUF5QixDQUFDO0FBTDFCO0lBQUMsZUFBUSxDQUFDO1FBQ04sT0FBTyxFQUFPLENBQUUsZ0NBQWEsQ0FBRTtRQUMvQixZQUFZLEVBQUUsQ0FBRSw0QkFBWSxDQUFFO1FBQzlCLFNBQVMsRUFBSyxDQUFFLDRCQUFZLENBQUU7S0FDakMsQ0FBQzs7YUFBQTtBQUNXLGlCQUFTLFlBQUksQ0FBQTs7O0FDUjFCLDJDQUF1QyxtQ0FBbUMsQ0FBQyxDQUFBO0FBQzNFLDZCQUEwQixjQUFjLENBQUMsQ0FBQTtBQUV6QyxNQUFNLFFBQVEsR0FBRyxpREFBc0IsRUFBRSxDQUFDO0FBQzFDLFFBQVEsQ0FBQyxlQUFlLENBQUMsc0JBQVMsQ0FBQyxDQUFDOzs7QUNKcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDOWdHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzczaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNuMFNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2xLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2p0RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbkBDb21wb25lbnQoe1xyXG4gICAgc2VsZWN0b3I6ICdteS1hcHAnLFxyXG4gICAgdGVtcGxhdGU6ICc8aDE+TXkgRmlyc3QgQW5ndWxhciBBcHA8L2gxPidcclxufSlcclxuZXhwb3J0IGNsYXNzIEFwcENvbXBvbmVudCB7IH0iLCJpbXBvcnQgeyBOZ01vZHVsZSB9ICAgICAgZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IEJyb3dzZXJNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyJztcclxuaW1wb3J0IHsgQXBwQ29tcG9uZW50IH0gICBmcm9tICcuL2FwcC5jb21wb25lbnQnO1xyXG5ATmdNb2R1bGUoe1xyXG4gICAgaW1wb3J0czogICAgICBbIEJyb3dzZXJNb2R1bGUgXSxcclxuICAgIGRlY2xhcmF0aW9uczogWyBBcHBDb21wb25lbnQgXSxcclxuICAgIGJvb3RzdHJhcDogICAgWyBBcHBDb21wb25lbnQgXVxyXG59KVxyXG5leHBvcnQgY2xhc3MgQXBwTW9kdWxlIHsgfSIsImltcG9ydCB7IHBsYXRmb3JtQnJvd3NlckR5bmFtaWMgfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyLWR5bmFtaWMnO1xyXG5pbXBvcnQgeyBBcHBNb2R1bGUgfSBmcm9tICcuL2FwcC5tb2R1bGUnO1xyXG5cclxuY29uc3QgcGxhdGZvcm0gPSBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljKCk7XHJcbnBsYXRmb3JtLmJvb3RzdHJhcE1vZHVsZShBcHBNb2R1bGUpOyIsIi8qKlxuICogQGxpY2Vuc2UgQW5ndWxhciB2Mi4xLjFcbiAqIChjKSAyMDEwLTIwMTYgR29vZ2xlLCBJbmMuIGh0dHBzOi8vYW5ndWxhci5pby9cbiAqIExpY2Vuc2U6IE1JVFxuICovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cywgcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cycsICdAYW5ndWxhci9jb3JlJ10sIGZhY3RvcnkpIDpcbiAgICAoZmFjdG9yeSgoZ2xvYmFsLm5nID0gZ2xvYmFsLm5nIHx8IHt9LCBnbG9iYWwubmcuY29tbW9uID0gZ2xvYmFsLm5nLmNvbW1vbiB8fCB7fSksZ2xvYmFsLm5nLmNvcmUpKTtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMsX2FuZ3VsYXJfY29yZSkgeyAndXNlIHN0cmljdCc7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgLyoqXG4gICAgICogVGhpcyBjbGFzcyBzaG91bGQgbm90IGJlIHVzZWQgZGlyZWN0bHkgYnkgYW4gYXBwbGljYXRpb24gZGV2ZWxvcGVyLiBJbnN0ZWFkLCB1c2VcbiAgICAgKiB7QGxpbmsgTG9jYXRpb259LlxuICAgICAqXG4gICAgICogYFBsYXRmb3JtTG9jYXRpb25gIGVuY2Fwc3VsYXRlcyBhbGwgY2FsbHMgdG8gRE9NIGFwaXMsIHdoaWNoIGFsbG93cyB0aGUgUm91dGVyIHRvIGJlIHBsYXRmb3JtXG4gICAgICogYWdub3N0aWMuXG4gICAgICogVGhpcyBtZWFucyB0aGF0IHdlIGNhbiBoYXZlIGRpZmZlcmVudCBpbXBsZW1lbnRhdGlvbiBvZiBgUGxhdGZvcm1Mb2NhdGlvbmAgZm9yIHRoZSBkaWZmZXJlbnRcbiAgICAgKiBwbGF0Zm9ybXNcbiAgICAgKiB0aGF0IGFuZ3VsYXIgc3VwcG9ydHMuIEZvciBleGFtcGxlLCB0aGUgZGVmYXVsdCBgUGxhdGZvcm1Mb2NhdGlvbmAgaXMge0BsaW5rXG4gICAgICogQnJvd3NlclBsYXRmb3JtTG9jYXRpb259LFxuICAgICAqIGhvd2V2ZXIgd2hlbiB5b3UgcnVuIHlvdXIgYXBwIGluIGEgV2ViV29ya2VyIHlvdSB1c2Uge0BsaW5rIFdlYldvcmtlclBsYXRmb3JtTG9jYXRpb259LlxuICAgICAqXG4gICAgICogVGhlIGBQbGF0Zm9ybUxvY2F0aW9uYCBjbGFzcyBpcyB1c2VkIGRpcmVjdGx5IGJ5IGFsbCBpbXBsZW1lbnRhdGlvbnMgb2Yge0BsaW5rIExvY2F0aW9uU3RyYXRlZ3l9XG4gICAgICogd2hlblxuICAgICAqIHRoZXkgbmVlZCB0byBpbnRlcmFjdCB3aXRoIHRoZSBET00gYXBpcyBsaWtlIHB1c2hTdGF0ZSwgcG9wU3RhdGUsIGV0Yy4uLlxuICAgICAqXG4gICAgICoge0BsaW5rIExvY2F0aW9uU3RyYXRlZ3l9IGluIHR1cm4gaXMgdXNlZCBieSB0aGUge0BsaW5rIExvY2F0aW9ufSBzZXJ2aWNlIHdoaWNoIGlzIHVzZWQgZGlyZWN0bHlcbiAgICAgKiBieVxuICAgICAqIHRoZSB7QGxpbmsgUm91dGVyfSBpbiBvcmRlciB0byBuYXZpZ2F0ZSBiZXR3ZWVuIHJvdXRlcy4gU2luY2UgYWxsIGludGVyYWN0aW9ucyBiZXR3ZWVuIHtAbGlua1xuICAgICAqIFJvdXRlcn0gL1xuICAgICAqIHtAbGluayBMb2NhdGlvbn0gLyB7QGxpbmsgTG9jYXRpb25TdHJhdGVneX0gYW5kIERPTSBhcGlzIGZsb3cgdGhyb3VnaCB0aGUgYFBsYXRmb3JtTG9jYXRpb25gXG4gICAgICogY2xhc3NcbiAgICAgKiB0aGV5IGFyZSBhbGwgcGxhdGZvcm0gaW5kZXBlbmRlbnQuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIFBsYXRmb3JtTG9jYXRpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBQbGF0Zm9ybUxvY2F0aW9uKCkge1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQbGF0Zm9ybUxvY2F0aW9uLnByb3RvdHlwZSwgXCJwYXRobmFtZVwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUGxhdGZvcm1Mb2NhdGlvbi5wcm90b3R5cGUsIFwic2VhcmNoXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQbGF0Zm9ybUxvY2F0aW9uLnByb3RvdHlwZSwgXCJoYXNoXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBQbGF0Zm9ybUxvY2F0aW9uO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBgTG9jYXRpb25TdHJhdGVneWAgaXMgcmVzcG9uc2libGUgZm9yIHJlcHJlc2VudGluZyBhbmQgcmVhZGluZyByb3V0ZSBzdGF0ZVxuICAgICAqIGZyb20gdGhlIGJyb3dzZXIncyBVUkwuIEFuZ3VsYXIgcHJvdmlkZXMgdHdvIHN0cmF0ZWdpZXM6XG4gICAgICoge0BsaW5rIEhhc2hMb2NhdGlvblN0cmF0ZWd5fSBhbmQge0BsaW5rIFBhdGhMb2NhdGlvblN0cmF0ZWd5fSAoZGVmYXVsdCkuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIHVzZWQgdW5kZXIgdGhlIGhvb2Qgb2YgdGhlIHtAbGluayBMb2NhdGlvbn0gc2VydmljZS5cbiAgICAgKlxuICAgICAqIEFwcGxpY2F0aW9ucyBzaG91bGQgdXNlIHRoZSB7QGxpbmsgUm91dGVyfSBvciB7QGxpbmsgTG9jYXRpb259IHNlcnZpY2VzIHRvXG4gICAgICogaW50ZXJhY3Qgd2l0aCBhcHBsaWNhdGlvbiByb3V0ZSBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEZvciBpbnN0YW5jZSwge0BsaW5rIEhhc2hMb2NhdGlvblN0cmF0ZWd5fSBwcm9kdWNlcyBVUkxzIGxpa2VcbiAgICAgKiBgaHR0cDovL2V4YW1wbGUuY29tIy9mb29gLCBhbmQge0BsaW5rIFBhdGhMb2NhdGlvblN0cmF0ZWd5fSBwcm9kdWNlc1xuICAgICAqIGBodHRwOi8vZXhhbXBsZS5jb20vZm9vYCBhcyBhbiBlcXVpdmFsZW50IFVSTC5cbiAgICAgKlxuICAgICAqIFNlZSB0aGVzZSB0d28gY2xhc3NlcyBmb3IgbW9yZS5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgTG9jYXRpb25TdHJhdGVneSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIExvY2F0aW9uU3RyYXRlZ3koKSB7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIExvY2F0aW9uU3RyYXRlZ3k7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBUaGUgYEFQUF9CQVNFX0hSRUZgIHRva2VuIHJlcHJlc2VudHMgdGhlIGJhc2UgaHJlZiB0byBiZSB1c2VkIHdpdGggdGhlXG4gICAgICoge0BsaW5rIFBhdGhMb2NhdGlvblN0cmF0ZWd5fS5cbiAgICAgKlxuICAgICAqIElmIHlvdSdyZSB1c2luZyB7QGxpbmsgUGF0aExvY2F0aW9uU3RyYXRlZ3l9LCB5b3UgbXVzdCBwcm92aWRlIGEgcHJvdmlkZXIgdG8gYSBzdHJpbmdcbiAgICAgKiByZXByZXNlbnRpbmcgdGhlIFVSTCBwcmVmaXggdGhhdCBzaG91bGQgYmUgcHJlc2VydmVkIHdoZW4gZ2VuZXJhdGluZyBhbmQgcmVjb2duaXppbmdcbiAgICAgKiBVUkxzLlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBpbXBvcnQge0NvbXBvbmVudCwgTmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICAgICAqIGltcG9ydCB7QVBQX0JBU0VfSFJFRn0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbiAgICAgKlxuICAgICAqIEBOZ01vZHVsZSh7XG4gICAgICogICBwcm92aWRlcnM6IFt7cHJvdmlkZTogQVBQX0JBU0VfSFJFRiwgdXNlVmFsdWU6ICcvbXkvYXBwJ31dXG4gICAgICogfSlcbiAgICAgKiBjbGFzcyBBcHBNb2R1bGUge31cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgQVBQX0JBU0VfSFJFRiA9IG5ldyBfYW5ndWxhcl9jb3JlLk9wYXF1ZVRva2VuKCdhcHBCYXNlSHJlZicpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBnbG9iYWxTY29wZTtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZiBpbnN0YW5jZW9mIFdvcmtlckdsb2JhbFNjb3BlKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBSZXBsYWNlIGFueSB3aXRoIFdvcmtlckdsb2JhbFNjb3BlIGZyb20gbGliLndlYndvcmtlci5kLnRzICMzNDkyXG4gICAgICAgICAgICBnbG9iYWxTY29wZSA9IHNlbGY7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBnbG9iYWxTY29wZSA9IGdsb2JhbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ2xvYmFsU2NvcGUgPSB3aW5kb3c7XG4gICAgfVxuICAgIC8vIE5lZWQgdG8gZGVjbGFyZSBhIG5ldyB2YXJpYWJsZSBmb3IgZ2xvYmFsIGhlcmUgc2luY2UgVHlwZVNjcmlwdFxuICAgIC8vIGV4cG9ydHMgdGhlIG9yaWdpbmFsIHZhbHVlIG9mIHRoZSBzeW1ib2wuXG4gICAgdmFyIF9nbG9iYWwgPSBnbG9iYWxTY29wZTtcbiAgICBmdW5jdGlvbiBnZXRUeXBlTmFtZUZvckRlYnVnZ2luZyh0eXBlKSB7XG4gICAgICAgIHJldHVybiB0eXBlWyduYW1lJ10gfHwgdHlwZW9mIHR5cGU7XG4gICAgfVxuICAgIC8vIFRPRE86IHJlbW92ZSBjYWxscyB0byBhc3NlcnQgaW4gcHJvZHVjdGlvbiBlbnZpcm9ubWVudFxuICAgIC8vIE5vdGU6IENhbid0IGp1c3QgZXhwb3J0IHRoaXMgYW5kIGltcG9ydCBpbiBpbiBvdGhlciBmaWxlc1xuICAgIC8vIGFzIGBhc3NlcnRgIGlzIGEgcmVzZXJ2ZWQga2V5d29yZCBpbiBEYXJ0XG4gICAgX2dsb2JhbC5hc3NlcnQgPSBmdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uKSB7XG4gICAgICAgIC8vIFRPRE86IHRvIGJlIGZpeGVkIHByb3Blcmx5IHZpYSAjMjgzMCwgbm9vcCBmb3Igbm93XG4gICAgfTtcbiAgICBmdW5jdGlvbiBpc1ByZXNlbnQob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogIT09IHVuZGVmaW5lZCAmJiBvYmogIT09IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzQmxhbmsob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogPT09IHVuZGVmaW5lZCB8fCBvYmogPT09IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzRGF0ZShvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIERhdGUgJiYgIWlzTmFOKG9iai52YWx1ZU9mKCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdHJpbmdpZnkodG9rZW4pIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW4gPT09IHVuZGVmaW5lZCB8fCB0b2tlbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuICcnICsgdG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuLm92ZXJyaWRkZW5OYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW4ub3ZlcnJpZGRlbk5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuLm5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbi5uYW1lO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXMgPSB0b2tlbi50b1N0cmluZygpO1xuICAgICAgICB2YXIgbmV3TGluZUluZGV4ID0gcmVzLmluZGV4T2YoJ1xcbicpO1xuICAgICAgICByZXR1cm4gbmV3TGluZUluZGV4ID09PSAtMSA/IHJlcyA6IHJlcy5zdWJzdHJpbmcoMCwgbmV3TGluZUluZGV4KTtcbiAgICB9XG4gICAgdmFyIE51bWJlcldyYXBwZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBOdW1iZXJXcmFwcGVyKCkge1xuICAgICAgICB9XG4gICAgICAgIE51bWJlcldyYXBwZXIucGFyc2VJbnRBdXRvUmFkaXggPSBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlSW50KHRleHQpO1xuICAgICAgICAgICAgaWYgKGlzTmFOKHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW50ZWdlciBsaXRlcmFsIHdoZW4gcGFyc2luZyAnICsgdGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgICBOdW1iZXJXcmFwcGVyLnBhcnNlSW50ID0gZnVuY3Rpb24gKHRleHQsIHJhZGl4KSB7XG4gICAgICAgICAgICBpZiAocmFkaXggPT0gMTApIHtcbiAgICAgICAgICAgICAgICBpZiAoL14oXFwtfFxcKyk/WzAtOV0rJC8udGVzdCh0ZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQodGV4dCwgcmFkaXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJhZGl4ID09IDE2KSB7XG4gICAgICAgICAgICAgICAgaWYgKC9eKFxcLXxcXCspP1swLTlBQkNERUZhYmNkZWZdKyQvLnRlc3QodGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHRleHQsIHJhZGl4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gcGFyc2VJbnQodGV4dCwgcmFkaXgpO1xuICAgICAgICAgICAgICAgIGlmICghaXNOYU4ocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnRlZ2VyIGxpdGVyYWwgd2hlbiBwYXJzaW5nICcgKyB0ZXh0ICsgJyBpbiBiYXNlICcgKyByYWRpeCk7XG4gICAgICAgIH07XG4gICAgICAgIE51bWJlcldyYXBwZXIuaXNOdW1lcmljID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiAhaXNOYU4odmFsdWUgLSBwYXJzZUZsb2F0KHZhbHVlKSk7IH07XG4gICAgICAgIHJldHVybiBOdW1iZXJXcmFwcGVyO1xuICAgIH0oKSk7XG4gICAgZnVuY3Rpb24gaXNKc09iamVjdChvKSB7XG4gICAgICAgIHJldHVybiBvICE9PSBudWxsICYmICh0eXBlb2YgbyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgbyA9PT0gJ29iamVjdCcpO1xuICAgIH1cbiAgICB2YXIgX3N5bWJvbEl0ZXJhdG9yID0gbnVsbDtcbiAgICBmdW5jdGlvbiBnZXRTeW1ib2xJdGVyYXRvcigpIHtcbiAgICAgICAgaWYgKGlzQmxhbmsoX3N5bWJvbEl0ZXJhdG9yKSkge1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChnbG9iYWxTY29wZS5TeW1ib2wpICYmIGlzUHJlc2VudChTeW1ib2wuaXRlcmF0b3IpKSB7XG4gICAgICAgICAgICAgICAgX3N5bWJvbEl0ZXJhdG9yID0gU3ltYm9sLml0ZXJhdG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZXM2LXNoaW0gc3BlY2lmaWMgbG9naWNcbiAgICAgICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE1hcC5wcm90b3R5cGUpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleSAhPT0gJ2VudHJpZXMnICYmIGtleSAhPT0gJ3NpemUnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXAucHJvdG90eXBlW2tleV0gPT09IE1hcC5wcm90b3R5cGVbJ2VudHJpZXMnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3N5bWJvbEl0ZXJhdG9yID0ga2V5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfc3ltYm9sSXRlcmF0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYExvY2F0aW9uYCBpcyBhIHNlcnZpY2UgdGhhdCBhcHBsaWNhdGlvbnMgY2FuIHVzZSB0byBpbnRlcmFjdCB3aXRoIGEgYnJvd3NlcidzIFVSTC5cbiAgICAgKiBEZXBlbmRpbmcgb24gd2hpY2gge0BsaW5rIExvY2F0aW9uU3RyYXRlZ3l9IGlzIHVzZWQsIGBMb2NhdGlvbmAgd2lsbCBlaXRoZXIgcGVyc2lzdFxuICAgICAqIHRvIHRoZSBVUkwncyBwYXRoIG9yIHRoZSBVUkwncyBoYXNoIHNlZ21lbnQuXG4gICAgICpcbiAgICAgKiBOb3RlOiBpdCdzIGJldHRlciB0byB1c2Uge0BsaW5rIFJvdXRlciNuYXZpZ2F0ZX0gc2VydmljZSB0byB0cmlnZ2VyIHJvdXRlIGNoYW5nZXMuIFVzZVxuICAgICAqIGBMb2NhdGlvbmAgb25seSBpZiB5b3UgbmVlZCB0byBpbnRlcmFjdCB3aXRoIG9yIGNyZWF0ZSBub3JtYWxpemVkIFVSTHMgb3V0c2lkZSBvZlxuICAgICAqIHJvdXRpbmcuXG4gICAgICpcbiAgICAgKiBgTG9jYXRpb25gIGlzIHJlc3BvbnNpYmxlIGZvciBub3JtYWxpemluZyB0aGUgVVJMIGFnYWluc3QgdGhlIGFwcGxpY2F0aW9uJ3MgYmFzZSBocmVmLlxuICAgICAqIEEgbm9ybWFsaXplZCBVUkwgaXMgYWJzb2x1dGUgZnJvbSB0aGUgVVJMIGhvc3QsIGluY2x1ZGVzIHRoZSBhcHBsaWNhdGlvbidzIGJhc2UgaHJlZiwgYW5kIGhhcyBub1xuICAgICAqIHRyYWlsaW5nIHNsYXNoOlxuICAgICAqIC0gYC9teS9hcHAvdXNlci8xMjNgIGlzIG5vcm1hbGl6ZWRcbiAgICAgKiAtIGBteS9hcHAvdXNlci8xMjNgICoqaXMgbm90Kiogbm9ybWFsaXplZFxuICAgICAqIC0gYC9teS9hcHAvdXNlci8xMjMvYCAqKmlzIG5vdCoqIG5vcm1hbGl6ZWRcbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBpbXBvcnQge0NvbXBvbmVudH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG4gICAgICogaW1wb3J0IHtMb2NhdGlvbn0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbiAgICAgKlxuICAgICAqIEBDb21wb25lbnQoe3NlbGVjdG9yOiAnYXBwLWNvbXBvbmVudCd9KVxuICAgICAqIGNsYXNzIEFwcENtcCB7XG4gICAgICogICBjb25zdHJ1Y3Rvcihsb2NhdGlvbjogTG9jYXRpb24pIHtcbiAgICAgKiAgICAgbG9jYXRpb24uZ28oJy9mb28nKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIExvY2F0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTG9jYXRpb24ocGxhdGZvcm1TdHJhdGVneSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX3N1YmplY3QgPSBuZXcgX2FuZ3VsYXJfY29yZS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgICAgIHRoaXMuX3BsYXRmb3JtU3RyYXRlZ3kgPSBwbGF0Zm9ybVN0cmF0ZWd5O1xuICAgICAgICAgICAgdmFyIGJyb3dzZXJCYXNlSHJlZiA9IHRoaXMuX3BsYXRmb3JtU3RyYXRlZ3kuZ2V0QmFzZUhyZWYoKTtcbiAgICAgICAgICAgIHRoaXMuX2Jhc2VIcmVmID0gTG9jYXRpb24uc3RyaXBUcmFpbGluZ1NsYXNoKF9zdHJpcEluZGV4SHRtbChicm93c2VyQmFzZUhyZWYpKTtcbiAgICAgICAgICAgIHRoaXMuX3BsYXRmb3JtU3RyYXRlZ3kub25Qb3BTdGF0ZShmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fc3ViamVjdC5lbWl0KHtcbiAgICAgICAgICAgICAgICAgICAgJ3VybCc6IF90aGlzLnBhdGgodHJ1ZSksXG4gICAgICAgICAgICAgICAgICAgICdwb3AnOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAndHlwZSc6IGV2LnR5cGUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgbm9ybWFsaXplZCBVUkwgcGF0aC5cbiAgICAgICAgICovXG4gICAgICAgIC8vIFRPRE86IHZzYXZraW4uIFJlbW92ZSB0aGUgYm9vbGVhbiBmbGFnIGFuZCBhbHdheXMgaW5jbHVkZSBoYXNoIG9uY2UgdGhlIGRlcHJlY2F0ZWQgcm91dGVyIGlzXG4gICAgICAgIC8vIHJlbW92ZWQuXG4gICAgICAgIExvY2F0aW9uLnByb3RvdHlwZS5wYXRoID0gZnVuY3Rpb24gKGluY2x1ZGVIYXNoKSB7XG4gICAgICAgICAgICBpZiAoaW5jbHVkZUhhc2ggPT09IHZvaWQgMCkgeyBpbmNsdWRlSGFzaCA9IGZhbHNlOyB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ub3JtYWxpemUodGhpcy5fcGxhdGZvcm1TdHJhdGVneS5wYXRoKGluY2x1ZGVIYXNoKSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOb3JtYWxpemVzIHRoZSBnaXZlbiBwYXRoIGFuZCBjb21wYXJlcyB0byB0aGUgY3VycmVudCBub3JtYWxpemVkIHBhdGguXG4gICAgICAgICAqL1xuICAgICAgICBMb2NhdGlvbi5wcm90b3R5cGUuaXNDdXJyZW50UGF0aEVxdWFsVG8gPSBmdW5jdGlvbiAocGF0aCwgcXVlcnkpIHtcbiAgICAgICAgICAgIGlmIChxdWVyeSA9PT0gdm9pZCAwKSB7IHF1ZXJ5ID0gJyc7IH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhdGgoKSA9PSB0aGlzLm5vcm1hbGl6ZShwYXRoICsgTG9jYXRpb24ubm9ybWFsaXplUXVlcnlQYXJhbXMocXVlcnkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdpdmVuIGEgc3RyaW5nIHJlcHJlc2VudGluZyBhIFVSTCwgcmV0dXJucyB0aGUgbm9ybWFsaXplZCBVUkwgcGF0aCB3aXRob3V0IGxlYWRpbmcgb3JcbiAgICAgICAgICogdHJhaWxpbmcgc2xhc2hlcy5cbiAgICAgICAgICovXG4gICAgICAgIExvY2F0aW9uLnByb3RvdHlwZS5ub3JtYWxpemUgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgICAgICByZXR1cm4gTG9jYXRpb24uc3RyaXBUcmFpbGluZ1NsYXNoKF9zdHJpcEJhc2VIcmVmKHRoaXMuX2Jhc2VIcmVmLCBfc3RyaXBJbmRleEh0bWwodXJsKSkpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2l2ZW4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgVVJMLCByZXR1cm5zIHRoZSBwbGF0Zm9ybS1zcGVjaWZpYyBleHRlcm5hbCBVUkwgcGF0aC5cbiAgICAgICAgICogSWYgdGhlIGdpdmVuIFVSTCBkb2Vzbid0IGJlZ2luIHdpdGggYSBsZWFkaW5nIHNsYXNoIChgJy8nYCksIHRoaXMgbWV0aG9kIGFkZHMgb25lXG4gICAgICAgICAqIGJlZm9yZSBub3JtYWxpemluZy4gVGhpcyBtZXRob2Qgd2lsbCBhbHNvIGFkZCBhIGhhc2ggaWYgYEhhc2hMb2NhdGlvblN0cmF0ZWd5YCBpc1xuICAgICAgICAgKiB1c2VkLCBvciB0aGUgYEFQUF9CQVNFX0hSRUZgIGlmIHRoZSBgUGF0aExvY2F0aW9uU3RyYXRlZ3lgIGlzIGluIHVzZS5cbiAgICAgICAgICovXG4gICAgICAgIExvY2F0aW9uLnByb3RvdHlwZS5wcmVwYXJlRXh0ZXJuYWxVcmwgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgICAgICBpZiAodXJsLmxlbmd0aCA+IDAgJiYgIXVybC5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgICAgICAgICAgICB1cmwgPSAnLycgKyB1cmw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGxhdGZvcm1TdHJhdGVneS5wcmVwYXJlRXh0ZXJuYWxVcmwodXJsKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gVE9ETzogcmVuYW1lIHRoaXMgbWV0aG9kIHRvIHB1c2hTdGF0ZVxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hhbmdlcyB0aGUgYnJvd3NlcnMgVVJMIHRvIHRoZSBub3JtYWxpemVkIHZlcnNpb24gb2YgdGhlIGdpdmVuIFVSTCwgYW5kIHB1c2hlcyBhXG4gICAgICAgICAqIG5ldyBpdGVtIG9udG8gdGhlIHBsYXRmb3JtJ3MgaGlzdG9yeS5cbiAgICAgICAgICovXG4gICAgICAgIExvY2F0aW9uLnByb3RvdHlwZS5nbyA9IGZ1bmN0aW9uIChwYXRoLCBxdWVyeSkge1xuICAgICAgICAgICAgaWYgKHF1ZXJ5ID09PSB2b2lkIDApIHsgcXVlcnkgPSAnJzsgfVxuICAgICAgICAgICAgdGhpcy5fcGxhdGZvcm1TdHJhdGVneS5wdXNoU3RhdGUobnVsbCwgJycsIHBhdGgsIHF1ZXJ5KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoYW5nZXMgdGhlIGJyb3dzZXJzIFVSTCB0byB0aGUgbm9ybWFsaXplZCB2ZXJzaW9uIG9mIHRoZSBnaXZlbiBVUkwsIGFuZCByZXBsYWNlc1xuICAgICAgICAgKiB0aGUgdG9wIGl0ZW0gb24gdGhlIHBsYXRmb3JtJ3MgaGlzdG9yeSBzdGFjay5cbiAgICAgICAgICovXG4gICAgICAgIExvY2F0aW9uLnByb3RvdHlwZS5yZXBsYWNlU3RhdGUgPSBmdW5jdGlvbiAocGF0aCwgcXVlcnkpIHtcbiAgICAgICAgICAgIGlmIChxdWVyeSA9PT0gdm9pZCAwKSB7IHF1ZXJ5ID0gJyc7IH1cbiAgICAgICAgICAgIHRoaXMuX3BsYXRmb3JtU3RyYXRlZ3kucmVwbGFjZVN0YXRlKG51bGwsICcnLCBwYXRoLCBxdWVyeSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOYXZpZ2F0ZXMgZm9yd2FyZCBpbiB0aGUgcGxhdGZvcm0ncyBoaXN0b3J5LlxuICAgICAgICAgKi9cbiAgICAgICAgTG9jYXRpb24ucHJvdG90eXBlLmZvcndhcmQgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX3BsYXRmb3JtU3RyYXRlZ3kuZm9yd2FyZCgpOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogTmF2aWdhdGVzIGJhY2sgaW4gdGhlIHBsYXRmb3JtJ3MgaGlzdG9yeS5cbiAgICAgICAgICovXG4gICAgICAgIExvY2F0aW9uLnByb3RvdHlwZS5iYWNrID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9wbGF0Zm9ybVN0cmF0ZWd5LmJhY2soKTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN1YnNjcmliZSB0byB0aGUgcGxhdGZvcm0ncyBgcG9wU3RhdGVgIGV2ZW50cy5cbiAgICAgICAgICovXG4gICAgICAgIExvY2F0aW9uLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAob25OZXh0LCBvblRocm93LCBvblJldHVybikge1xuICAgICAgICAgICAgaWYgKG9uVGhyb3cgPT09IHZvaWQgMCkgeyBvblRocm93ID0gbnVsbDsgfVxuICAgICAgICAgICAgaWYgKG9uUmV0dXJuID09PSB2b2lkIDApIHsgb25SZXR1cm4gPSBudWxsOyB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3ViamVjdC5zdWJzY3JpYmUoeyBuZXh0OiBvbk5leHQsIGVycm9yOiBvblRocm93LCBjb21wbGV0ZTogb25SZXR1cm4gfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHaXZlbiBhIHN0cmluZyBvZiB1cmwgcGFyYW1ldGVycywgcHJlcGVuZCB3aXRoICc/JyBpZiBuZWVkZWQsIG90aGVyd2lzZSByZXR1cm4gcGFyYW1ldGVycyBhc1xuICAgICAgICAgKiBpcy5cbiAgICAgICAgICovXG4gICAgICAgIExvY2F0aW9uLm5vcm1hbGl6ZVF1ZXJ5UGFyYW1zID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICAgICAgcmV0dXJuIChwYXJhbXMubGVuZ3RoID4gMCAmJiBwYXJhbXMuc3Vic3RyaW5nKDAsIDEpICE9ICc/JykgPyAoJz8nICsgcGFyYW1zKSA6IHBhcmFtcztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdpdmVuIDIgcGFydHMgb2YgYSB1cmwsIGpvaW4gdGhlbSB3aXRoIGEgc2xhc2ggaWYgbmVlZGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgTG9jYXRpb24uam9pbldpdGhTbGFzaCA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgICAgICAgICBpZiAoc3RhcnQubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVuZC5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGFydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzbGFzaGVzID0gMDtcbiAgICAgICAgICAgIGlmIChzdGFydC5lbmRzV2l0aCgnLycpKSB7XG4gICAgICAgICAgICAgICAgc2xhc2hlcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVuZC5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgICAgICAgICAgICBzbGFzaGVzKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2xhc2hlcyA9PSAyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0ICsgZW5kLnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzbGFzaGVzID09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnQgKyBlbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3RhcnQgKyAnLycgKyBlbmQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB1cmwgaGFzIGEgdHJhaWxpbmcgc2xhc2gsIHJlbW92ZSBpdCwgb3RoZXJ3aXNlIHJldHVybiB1cmwgYXMgaXMuXG4gICAgICAgICAqL1xuICAgICAgICBMb2NhdGlvbi5zdHJpcFRyYWlsaW5nU2xhc2ggPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgICAgICBpZiAoL1xcLyQvZy50ZXN0KHVybCkpIHtcbiAgICAgICAgICAgICAgICB1cmwgPSB1cmwuc3Vic3RyaW5nKDAsIHVybC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1cmw7XG4gICAgICAgIH07XG4gICAgICAgIExvY2F0aW9uLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgTG9jYXRpb24uY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IExvY2F0aW9uU3RyYXRlZ3ksIH0sXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBMb2NhdGlvbjtcbiAgICB9KCkpO1xuICAgIGZ1bmN0aW9uIF9zdHJpcEJhc2VIcmVmKGJhc2VIcmVmLCB1cmwpIHtcbiAgICAgICAgaWYgKGJhc2VIcmVmLmxlbmd0aCA+IDAgJiYgdXJsLnN0YXJ0c1dpdGgoYmFzZUhyZWYpKSB7XG4gICAgICAgICAgICByZXR1cm4gdXJsLnN1YnN0cmluZyhiYXNlSHJlZi5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9zdHJpcEluZGV4SHRtbCh1cmwpIHtcbiAgICAgICAgaWYgKC9cXC9pbmRleC5odG1sJC9nLnRlc3QodXJsKSkge1xuICAgICAgICAgICAgLy8gJy9pbmRleC5odG1sJy5sZW5ndGggPT0gMTFcbiAgICAgICAgICAgIHJldHVybiB1cmwuc3Vic3RyaW5nKDAsIHVybC5sZW5ndGggLSAxMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGBIYXNoTG9jYXRpb25TdHJhdGVneWAgaXMgYSB7QGxpbmsgTG9jYXRpb25TdHJhdGVneX0gdXNlZCB0byBjb25maWd1cmUgdGhlXG4gICAgICoge0BsaW5rIExvY2F0aW9ufSBzZXJ2aWNlIHRvIHJlcHJlc2VudCBpdHMgc3RhdGUgaW4gdGhlXG4gICAgICogW2hhc2ggZnJhZ21lbnRdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1VuaWZvcm1fUmVzb3VyY2VfTG9jYXRvciNTeW50YXgpXG4gICAgICogb2YgdGhlIGJyb3dzZXIncyBVUkwuXG4gICAgICpcbiAgICAgKiBGb3IgaW5zdGFuY2UsIGlmIHlvdSBjYWxsIGBsb2NhdGlvbi5nbygnL2ZvbycpYCwgdGhlIGJyb3dzZXIncyBVUkwgd2lsbCBiZWNvbWVcbiAgICAgKiBgZXhhbXBsZS5jb20jL2Zvb2AuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogaW1wb3J0IHtDb21wb25lbnQsIE5nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAgICAgKiBpbXBvcnQge1xuICAgICAqICAgTG9jYXRpb25TdHJhdGVneSxcbiAgICAgKiAgIEhhc2hMb2NhdGlvblN0cmF0ZWd5XG4gICAgICogfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuICAgICAqXG4gICAgICogQE5nTW9kdWxlKHtcbiAgICAgKiAgIHByb3ZpZGVyczogW3twcm92aWRlOiBMb2NhdGlvblN0cmF0ZWd5LCB1c2VDbGFzczogSGFzaExvY2F0aW9uU3RyYXRlZ3l9XVxuICAgICAqIH0pXG4gICAgICogY2xhc3MgQXBwTW9kdWxlIHt9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEhhc2hMb2NhdGlvblN0cmF0ZWd5ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKEhhc2hMb2NhdGlvblN0cmF0ZWd5LCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBIYXNoTG9jYXRpb25TdHJhdGVneShfcGxhdGZvcm1Mb2NhdGlvbiwgX2Jhc2VIcmVmKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX3BsYXRmb3JtTG9jYXRpb24gPSBfcGxhdGZvcm1Mb2NhdGlvbjtcbiAgICAgICAgICAgIHRoaXMuX2Jhc2VIcmVmID0gJyc7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KF9iYXNlSHJlZikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9iYXNlSHJlZiA9IF9iYXNlSHJlZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBIYXNoTG9jYXRpb25TdHJhdGVneS5wcm90b3R5cGUub25Qb3BTdGF0ZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgdGhpcy5fcGxhdGZvcm1Mb2NhdGlvbi5vblBvcFN0YXRlKGZuKTtcbiAgICAgICAgICAgIHRoaXMuX3BsYXRmb3JtTG9jYXRpb24ub25IYXNoQ2hhbmdlKGZuKTtcbiAgICAgICAgfTtcbiAgICAgICAgSGFzaExvY2F0aW9uU3RyYXRlZ3kucHJvdG90eXBlLmdldEJhc2VIcmVmID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fYmFzZUhyZWY7IH07XG4gICAgICAgIEhhc2hMb2NhdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5wYXRoID0gZnVuY3Rpb24gKGluY2x1ZGVIYXNoKSB7XG4gICAgICAgICAgICBpZiAoaW5jbHVkZUhhc2ggPT09IHZvaWQgMCkgeyBpbmNsdWRlSGFzaCA9IGZhbHNlOyB9XG4gICAgICAgICAgICAvLyB0aGUgaGFzaCB2YWx1ZSBpcyBhbHdheXMgcHJlZml4ZWQgd2l0aCBhIGAjYFxuICAgICAgICAgICAgLy8gYW5kIGlmIGl0IGlzIGVtcHR5IHRoZW4gaXQgd2lsbCBzdGF5IGVtcHR5XG4gICAgICAgICAgICB2YXIgcGF0aCA9IHRoaXMuX3BsYXRmb3JtTG9jYXRpb24uaGFzaDtcbiAgICAgICAgICAgIGlmICghaXNQcmVzZW50KHBhdGgpKVxuICAgICAgICAgICAgICAgIHBhdGggPSAnIyc7XG4gICAgICAgICAgICByZXR1cm4gcGF0aC5sZW5ndGggPiAwID8gcGF0aC5zdWJzdHJpbmcoMSkgOiBwYXRoO1xuICAgICAgICB9O1xuICAgICAgICBIYXNoTG9jYXRpb25TdHJhdGVneS5wcm90b3R5cGUucHJlcGFyZUV4dGVybmFsVXJsID0gZnVuY3Rpb24gKGludGVybmFsKSB7XG4gICAgICAgICAgICB2YXIgdXJsID0gTG9jYXRpb24uam9pbldpdGhTbGFzaCh0aGlzLl9iYXNlSHJlZiwgaW50ZXJuYWwpO1xuICAgICAgICAgICAgcmV0dXJuIHVybC5sZW5ndGggPiAwID8gKCcjJyArIHVybCkgOiB1cmw7XG4gICAgICAgIH07XG4gICAgICAgIEhhc2hMb2NhdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5wdXNoU3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUsIHRpdGxlLCBwYXRoLCBxdWVyeVBhcmFtcykge1xuICAgICAgICAgICAgdmFyIHVybCA9IHRoaXMucHJlcGFyZUV4dGVybmFsVXJsKHBhdGggKyBMb2NhdGlvbi5ub3JtYWxpemVRdWVyeVBhcmFtcyhxdWVyeVBhcmFtcykpO1xuICAgICAgICAgICAgaWYgKHVybC5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgIHVybCA9IHRoaXMuX3BsYXRmb3JtTG9jYXRpb24ucGF0aG5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9wbGF0Zm9ybUxvY2F0aW9uLnB1c2hTdGF0ZShzdGF0ZSwgdGl0bGUsIHVybCk7XG4gICAgICAgIH07XG4gICAgICAgIEhhc2hMb2NhdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5yZXBsYWNlU3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUsIHRpdGxlLCBwYXRoLCBxdWVyeVBhcmFtcykge1xuICAgICAgICAgICAgdmFyIHVybCA9IHRoaXMucHJlcGFyZUV4dGVybmFsVXJsKHBhdGggKyBMb2NhdGlvbi5ub3JtYWxpemVRdWVyeVBhcmFtcyhxdWVyeVBhcmFtcykpO1xuICAgICAgICAgICAgaWYgKHVybC5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgIHVybCA9IHRoaXMuX3BsYXRmb3JtTG9jYXRpb24ucGF0aG5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9wbGF0Zm9ybUxvY2F0aW9uLnJlcGxhY2VTdGF0ZShzdGF0ZSwgdGl0bGUsIHVybCk7XG4gICAgICAgIH07XG4gICAgICAgIEhhc2hMb2NhdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5mb3J3YXJkID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9wbGF0Zm9ybUxvY2F0aW9uLmZvcndhcmQoKTsgfTtcbiAgICAgICAgSGFzaExvY2F0aW9uU3RyYXRlZ3kucHJvdG90eXBlLmJhY2sgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX3BsYXRmb3JtTG9jYXRpb24uYmFjaygpOyB9O1xuICAgICAgICBIYXNoTG9jYXRpb25TdHJhdGVneS5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIEhhc2hMb2NhdGlvblN0cmF0ZWd5LmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBQbGF0Zm9ybUxvY2F0aW9uLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW0FQUF9CQVNFX0hSRUYsXSB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIEhhc2hMb2NhdGlvblN0cmF0ZWd5O1xuICAgIH0oTG9jYXRpb25TdHJhdGVneSkpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkMSA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGBQYXRoTG9jYXRpb25TdHJhdGVneWAgaXMgYSB7QGxpbmsgTG9jYXRpb25TdHJhdGVneX0gdXNlZCB0byBjb25maWd1cmUgdGhlXG4gICAgICoge0BsaW5rIExvY2F0aW9ufSBzZXJ2aWNlIHRvIHJlcHJlc2VudCBpdHMgc3RhdGUgaW4gdGhlXG4gICAgICogW3BhdGhdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1VuaWZvcm1fUmVzb3VyY2VfTG9jYXRvciNTeW50YXgpIG9mIHRoZVxuICAgICAqIGJyb3dzZXIncyBVUkwuXG4gICAgICpcbiAgICAgKiBgUGF0aExvY2F0aW9uU3RyYXRlZ3lgIGlzIHRoZSBkZWZhdWx0IGJpbmRpbmcgZm9yIHtAbGluayBMb2NhdGlvblN0cmF0ZWd5fVxuICAgICAqIHByb3ZpZGVkIGluIHtAbGluayBST1VURVJfUFJPVklERVJTfS5cbiAgICAgKlxuICAgICAqIElmIHlvdSdyZSB1c2luZyBgUGF0aExvY2F0aW9uU3RyYXRlZ3lgLCB5b3UgbXVzdCBwcm92aWRlIGEge0BsaW5rIEFQUF9CQVNFX0hSRUZ9XG4gICAgICogb3IgYWRkIGEgYmFzZSBlbGVtZW50IHRvIHRoZSBkb2N1bWVudC4gVGhpcyBVUkwgcHJlZml4IHRoYXQgd2lsbCBiZSBwcmVzZXJ2ZWRcbiAgICAgKiB3aGVuIGdlbmVyYXRpbmcgYW5kIHJlY29nbml6aW5nIFVSTHMuXG4gICAgICpcbiAgICAgKiBGb3IgaW5zdGFuY2UsIGlmIHlvdSBwcm92aWRlIGFuIGBBUFBfQkFTRV9IUkVGYCBvZiBgJy9teS9hcHAnYCBhbmQgY2FsbFxuICAgICAqIGBsb2NhdGlvbi5nbygnL2ZvbycpYCwgdGhlIGJyb3dzZXIncyBVUkwgd2lsbCBiZWNvbWVcbiAgICAgKiBgZXhhbXBsZS5jb20vbXkvYXBwL2Zvb2AuXG4gICAgICpcbiAgICAgKiBTaW1pbGFybHksIGlmIHlvdSBhZGQgYDxiYXNlIGhyZWY9Jy9teS9hcHAnLz5gIHRvIHRoZSBkb2N1bWVudCBhbmQgY2FsbFxuICAgICAqIGBsb2NhdGlvbi5nbygnL2ZvbycpYCwgdGhlIGJyb3dzZXIncyBVUkwgd2lsbCBiZWNvbWVcbiAgICAgKiBgZXhhbXBsZS5jb20vbXkvYXBwL2Zvb2AuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIFBhdGhMb2NhdGlvblN0cmF0ZWd5ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDEoUGF0aExvY2F0aW9uU3RyYXRlZ3ksIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIFBhdGhMb2NhdGlvblN0cmF0ZWd5KF9wbGF0Zm9ybUxvY2F0aW9uLCBocmVmKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX3BsYXRmb3JtTG9jYXRpb24gPSBfcGxhdGZvcm1Mb2NhdGlvbjtcbiAgICAgICAgICAgIGlmIChpc0JsYW5rKGhyZWYpKSB7XG4gICAgICAgICAgICAgICAgaHJlZiA9IHRoaXMuX3BsYXRmb3JtTG9jYXRpb24uZ2V0QmFzZUhyZWZGcm9tRE9NKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNCbGFuayhocmVmKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGJhc2UgaHJlZiBzZXQuIFBsZWFzZSBwcm92aWRlIGEgdmFsdWUgZm9yIHRoZSBBUFBfQkFTRV9IUkVGIHRva2VuIG9yIGFkZCBhIGJhc2UgZWxlbWVudCB0byB0aGUgZG9jdW1lbnQuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fYmFzZUhyZWYgPSBocmVmO1xuICAgICAgICB9XG4gICAgICAgIFBhdGhMb2NhdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5vblBvcFN0YXRlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICB0aGlzLl9wbGF0Zm9ybUxvY2F0aW9uLm9uUG9wU3RhdGUoZm4pO1xuICAgICAgICAgICAgdGhpcy5fcGxhdGZvcm1Mb2NhdGlvbi5vbkhhc2hDaGFuZ2UoZm4pO1xuICAgICAgICB9O1xuICAgICAgICBQYXRoTG9jYXRpb25TdHJhdGVneS5wcm90b3R5cGUuZ2V0QmFzZUhyZWYgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9iYXNlSHJlZjsgfTtcbiAgICAgICAgUGF0aExvY2F0aW9uU3RyYXRlZ3kucHJvdG90eXBlLnByZXBhcmVFeHRlcm5hbFVybCA9IGZ1bmN0aW9uIChpbnRlcm5hbCkge1xuICAgICAgICAgICAgcmV0dXJuIExvY2F0aW9uLmpvaW5XaXRoU2xhc2godGhpcy5fYmFzZUhyZWYsIGludGVybmFsKTtcbiAgICAgICAgfTtcbiAgICAgICAgUGF0aExvY2F0aW9uU3RyYXRlZ3kucHJvdG90eXBlLnBhdGggPSBmdW5jdGlvbiAoaW5jbHVkZUhhc2gpIHtcbiAgICAgICAgICAgIGlmIChpbmNsdWRlSGFzaCA9PT0gdm9pZCAwKSB7IGluY2x1ZGVIYXNoID0gZmFsc2U7IH1cbiAgICAgICAgICAgIHZhciBwYXRobmFtZSA9IHRoaXMuX3BsYXRmb3JtTG9jYXRpb24ucGF0aG5hbWUgK1xuICAgICAgICAgICAgICAgIExvY2F0aW9uLm5vcm1hbGl6ZVF1ZXJ5UGFyYW1zKHRoaXMuX3BsYXRmb3JtTG9jYXRpb24uc2VhcmNoKTtcbiAgICAgICAgICAgIHZhciBoYXNoID0gdGhpcy5fcGxhdGZvcm1Mb2NhdGlvbi5oYXNoO1xuICAgICAgICAgICAgcmV0dXJuIGhhc2ggJiYgaW5jbHVkZUhhc2ggPyBcIlwiICsgcGF0aG5hbWUgKyBoYXNoIDogcGF0aG5hbWU7XG4gICAgICAgIH07XG4gICAgICAgIFBhdGhMb2NhdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5wdXNoU3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUsIHRpdGxlLCB1cmwsIHF1ZXJ5UGFyYW1zKSB7XG4gICAgICAgICAgICB2YXIgZXh0ZXJuYWxVcmwgPSB0aGlzLnByZXBhcmVFeHRlcm5hbFVybCh1cmwgKyBMb2NhdGlvbi5ub3JtYWxpemVRdWVyeVBhcmFtcyhxdWVyeVBhcmFtcykpO1xuICAgICAgICAgICAgdGhpcy5fcGxhdGZvcm1Mb2NhdGlvbi5wdXNoU3RhdGUoc3RhdGUsIHRpdGxlLCBleHRlcm5hbFVybCk7XG4gICAgICAgIH07XG4gICAgICAgIFBhdGhMb2NhdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5yZXBsYWNlU3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUsIHRpdGxlLCB1cmwsIHF1ZXJ5UGFyYW1zKSB7XG4gICAgICAgICAgICB2YXIgZXh0ZXJuYWxVcmwgPSB0aGlzLnByZXBhcmVFeHRlcm5hbFVybCh1cmwgKyBMb2NhdGlvbi5ub3JtYWxpemVRdWVyeVBhcmFtcyhxdWVyeVBhcmFtcykpO1xuICAgICAgICAgICAgdGhpcy5fcGxhdGZvcm1Mb2NhdGlvbi5yZXBsYWNlU3RhdGUoc3RhdGUsIHRpdGxlLCBleHRlcm5hbFVybCk7XG4gICAgICAgIH07XG4gICAgICAgIFBhdGhMb2NhdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5mb3J3YXJkID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9wbGF0Zm9ybUxvY2F0aW9uLmZvcndhcmQoKTsgfTtcbiAgICAgICAgUGF0aExvY2F0aW9uU3RyYXRlZ3kucHJvdG90eXBlLmJhY2sgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX3BsYXRmb3JtTG9jYXRpb24uYmFjaygpOyB9O1xuICAgICAgICBQYXRoTG9jYXRpb25TdHJhdGVneS5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIFBhdGhMb2NhdGlvblN0cmF0ZWd5LmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBQbGF0Zm9ybUxvY2F0aW9uLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW0FQUF9CQVNFX0hSRUYsXSB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIFBhdGhMb2NhdGlvblN0cmF0ZWd5O1xuICAgIH0oTG9jYXRpb25TdHJhdGVneSkpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkMiA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgTmdMb2NhbGl6YXRpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBOZ0xvY2FsaXphdGlvbigpIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTmdMb2NhbGl6YXRpb247XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwbHVyYWwgY2F0ZWdvcnkgZm9yIGEgZ2l2ZW4gdmFsdWUuXG4gICAgICogLSBcIj12YWx1ZVwiIHdoZW4gdGhlIGNhc2UgZXhpc3RzLFxuICAgICAqIC0gdGhlIHBsdXJhbCBjYXRlZ29yeSBvdGhlcndpc2VcbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFBsdXJhbENhdGVnb3J5KHZhbHVlLCBjYXNlcywgbmdMb2NhbGl6YXRpb24pIHtcbiAgICAgICAgdmFyIG5iQ2FzZSA9IFwiPVwiICsgdmFsdWU7XG4gICAgICAgIHJldHVybiBjYXNlcy5pbmRleE9mKG5iQ2FzZSkgPiAtMSA/IG5iQ2FzZSA6IG5nTG9jYWxpemF0aW9uLmdldFBsdXJhbENhdGVnb3J5KHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcGx1cmFsIGNhc2UgYmFzZWQgb24gdGhlIGxvY2FsZVxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBOZ0xvY2FsZUxvY2FsaXphdGlvbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQyKE5nTG9jYWxlTG9jYWxpemF0aW9uLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBOZ0xvY2FsZUxvY2FsaXphdGlvbihfbG9jYWxlKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX2xvY2FsZSA9IF9sb2NhbGU7XG4gICAgICAgIH1cbiAgICAgICAgTmdMb2NhbGVMb2NhbGl6YXRpb24ucHJvdG90eXBlLmdldFBsdXJhbENhdGVnb3J5ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgcGx1cmFsID0gZ2V0UGx1cmFsQ2FzZSh0aGlzLl9sb2NhbGUsIHZhbHVlKTtcbiAgICAgICAgICAgIHN3aXRjaCAocGx1cmFsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBQbHVyYWwuWmVybzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd6ZXJvJztcbiAgICAgICAgICAgICAgICBjYXNlIFBsdXJhbC5PbmU6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnb25lJztcbiAgICAgICAgICAgICAgICBjYXNlIFBsdXJhbC5Ud286XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAndHdvJztcbiAgICAgICAgICAgICAgICBjYXNlIFBsdXJhbC5GZXc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnZmV3JztcbiAgICAgICAgICAgICAgICBjYXNlIFBsdXJhbC5NYW55OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ21hbnknO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnb3RoZXInO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBOZ0xvY2FsZUxvY2FsaXphdGlvbi5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIE5nTG9jYWxlTG9jYWxpemF0aW9uLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbX2FuZ3VsYXJfY29yZS5MT0NBTEVfSUQsXSB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIE5nTG9jYWxlTG9jYWxpemF0aW9uO1xuICAgIH0oTmdMb2NhbGl6YXRpb24pKTtcbiAgICAvLyBUaGlzIGlzIGdlbmVyYXRlZCBjb2RlIERPIE5PVCBNT0RJRllcbiAgICAvLyBzZWUgYW5ndWxhcjIvc2NyaXB0L2NsZHIvZ2VuX3BsdXJhbF9ydWxlcy5qc1xuICAgIC8qKiBAZXhwZXJpbWVudGFsICovXG4gICAgdmFyIFBsdXJhbDtcbiAgICAoZnVuY3Rpb24gKFBsdXJhbCkge1xuICAgICAgICBQbHVyYWxbUGx1cmFsW1wiWmVyb1wiXSA9IDBdID0gXCJaZXJvXCI7XG4gICAgICAgIFBsdXJhbFtQbHVyYWxbXCJPbmVcIl0gPSAxXSA9IFwiT25lXCI7XG4gICAgICAgIFBsdXJhbFtQbHVyYWxbXCJUd29cIl0gPSAyXSA9IFwiVHdvXCI7XG4gICAgICAgIFBsdXJhbFtQbHVyYWxbXCJGZXdcIl0gPSAzXSA9IFwiRmV3XCI7XG4gICAgICAgIFBsdXJhbFtQbHVyYWxbXCJNYW55XCJdID0gNF0gPSBcIk1hbnlcIjtcbiAgICAgICAgUGx1cmFsW1BsdXJhbFtcIk90aGVyXCJdID0gNV0gPSBcIk90aGVyXCI7XG4gICAgfSkoUGx1cmFsIHx8IChQbHVyYWwgPSB7fSkpO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHBsdXJhbCBjYXNlIGJhc2VkIG9uIHRoZSBsb2NhbGVcbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRQbHVyYWxDYXNlKGxvY2FsZSwgbkxpa2UpIHtcbiAgICAgICAgLy8gVE9ETyh2aWNiKTogbGF6eSBjb21wdXRlXG4gICAgICAgIGlmICh0eXBlb2Ygbkxpa2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBuTGlrZSA9IHBhcnNlSW50KG5MaWtlLCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG4gPSBuTGlrZTtcbiAgICAgICAgdmFyIG5EZWNpbWFsID0gbi50b1N0cmluZygpLnJlcGxhY2UoL15bXi5dKlxcLj8vLCAnJyk7XG4gICAgICAgIHZhciBpID0gTWF0aC5mbG9vcihNYXRoLmFicyhuKSk7XG4gICAgICAgIHZhciB2ID0gbkRlY2ltYWwubGVuZ3RoO1xuICAgICAgICB2YXIgZiA9IHBhcnNlSW50KG5EZWNpbWFsLCAxMCk7XG4gICAgICAgIHZhciB0ID0gcGFyc2VJbnQobi50b1N0cmluZygpLnJlcGxhY2UoL15bXi5dKlxcLj98MCskL2csICcnKSwgMTApIHx8IDA7XG4gICAgICAgIHZhciBsYW5nID0gbG9jYWxlLnNwbGl0KCctJylbMF0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgc3dpdGNoIChsYW5nKSB7XG4gICAgICAgICAgICBjYXNlICdhZic6XG4gICAgICAgICAgICBjYXNlICdhc2EnOlxuICAgICAgICAgICAgY2FzZSAnYXonOlxuICAgICAgICAgICAgY2FzZSAnYmVtJzpcbiAgICAgICAgICAgIGNhc2UgJ2Jleic6XG4gICAgICAgICAgICBjYXNlICdiZyc6XG4gICAgICAgICAgICBjYXNlICdicngnOlxuICAgICAgICAgICAgY2FzZSAnY2UnOlxuICAgICAgICAgICAgY2FzZSAnY2dnJzpcbiAgICAgICAgICAgIGNhc2UgJ2Nocic6XG4gICAgICAgICAgICBjYXNlICdja2InOlxuICAgICAgICAgICAgY2FzZSAnZWUnOlxuICAgICAgICAgICAgY2FzZSAnZWwnOlxuICAgICAgICAgICAgY2FzZSAnZW8nOlxuICAgICAgICAgICAgY2FzZSAnZXMnOlxuICAgICAgICAgICAgY2FzZSAnZXUnOlxuICAgICAgICAgICAgY2FzZSAnZm8nOlxuICAgICAgICAgICAgY2FzZSAnZnVyJzpcbiAgICAgICAgICAgIGNhc2UgJ2dzdyc6XG4gICAgICAgICAgICBjYXNlICdoYSc6XG4gICAgICAgICAgICBjYXNlICdoYXcnOlxuICAgICAgICAgICAgY2FzZSAnaHUnOlxuICAgICAgICAgICAgY2FzZSAnamdvJzpcbiAgICAgICAgICAgIGNhc2UgJ2ptYyc6XG4gICAgICAgICAgICBjYXNlICdrYSc6XG4gICAgICAgICAgICBjYXNlICdrayc6XG4gICAgICAgICAgICBjYXNlICdra2onOlxuICAgICAgICAgICAgY2FzZSAna2wnOlxuICAgICAgICAgICAgY2FzZSAna3MnOlxuICAgICAgICAgICAgY2FzZSAna3NiJzpcbiAgICAgICAgICAgIGNhc2UgJ2t5JzpcbiAgICAgICAgICAgIGNhc2UgJ2xiJzpcbiAgICAgICAgICAgIGNhc2UgJ2xnJzpcbiAgICAgICAgICAgIGNhc2UgJ21hcyc6XG4gICAgICAgICAgICBjYXNlICdtZ28nOlxuICAgICAgICAgICAgY2FzZSAnbWwnOlxuICAgICAgICAgICAgY2FzZSAnbW4nOlxuICAgICAgICAgICAgY2FzZSAnbmInOlxuICAgICAgICAgICAgY2FzZSAnbmQnOlxuICAgICAgICAgICAgY2FzZSAnbmUnOlxuICAgICAgICAgICAgY2FzZSAnbm4nOlxuICAgICAgICAgICAgY2FzZSAnbm5oJzpcbiAgICAgICAgICAgIGNhc2UgJ255bic6XG4gICAgICAgICAgICBjYXNlICdvbSc6XG4gICAgICAgICAgICBjYXNlICdvcic6XG4gICAgICAgICAgICBjYXNlICdvcyc6XG4gICAgICAgICAgICBjYXNlICdwcyc6XG4gICAgICAgICAgICBjYXNlICdybSc6XG4gICAgICAgICAgICBjYXNlICdyb2YnOlxuICAgICAgICAgICAgY2FzZSAncndrJzpcbiAgICAgICAgICAgIGNhc2UgJ3NhcSc6XG4gICAgICAgICAgICBjYXNlICdzZWgnOlxuICAgICAgICAgICAgY2FzZSAnc24nOlxuICAgICAgICAgICAgY2FzZSAnc28nOlxuICAgICAgICAgICAgY2FzZSAnc3EnOlxuICAgICAgICAgICAgY2FzZSAndGEnOlxuICAgICAgICAgICAgY2FzZSAndGUnOlxuICAgICAgICAgICAgY2FzZSAndGVvJzpcbiAgICAgICAgICAgIGNhc2UgJ3RrJzpcbiAgICAgICAgICAgIGNhc2UgJ3RyJzpcbiAgICAgICAgICAgIGNhc2UgJ3VnJzpcbiAgICAgICAgICAgIGNhc2UgJ3V6JzpcbiAgICAgICAgICAgIGNhc2UgJ3ZvJzpcbiAgICAgICAgICAgIGNhc2UgJ3Z1bic6XG4gICAgICAgICAgICBjYXNlICd3YWUnOlxuICAgICAgICAgICAgY2FzZSAneG9nJzpcbiAgICAgICAgICAgICAgICBpZiAobiA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PdGhlcjtcbiAgICAgICAgICAgIGNhc2UgJ2FncSc6XG4gICAgICAgICAgICBjYXNlICdiYXMnOlxuICAgICAgICAgICAgY2FzZSAnY3UnOlxuICAgICAgICAgICAgY2FzZSAnZGF2JzpcbiAgICAgICAgICAgIGNhc2UgJ2RqZSc6XG4gICAgICAgICAgICBjYXNlICdkdWEnOlxuICAgICAgICAgICAgY2FzZSAnZHlvJzpcbiAgICAgICAgICAgIGNhc2UgJ2VidSc6XG4gICAgICAgICAgICBjYXNlICdld28nOlxuICAgICAgICAgICAgY2FzZSAnZ3V6JzpcbiAgICAgICAgICAgIGNhc2UgJ2thbSc6XG4gICAgICAgICAgICBjYXNlICdraHEnOlxuICAgICAgICAgICAgY2FzZSAna2knOlxuICAgICAgICAgICAgY2FzZSAna2xuJzpcbiAgICAgICAgICAgIGNhc2UgJ2tvayc6XG4gICAgICAgICAgICBjYXNlICdrc2YnOlxuICAgICAgICAgICAgY2FzZSAnbHJjJzpcbiAgICAgICAgICAgIGNhc2UgJ2x1JzpcbiAgICAgICAgICAgIGNhc2UgJ2x1byc6XG4gICAgICAgICAgICBjYXNlICdsdXknOlxuICAgICAgICAgICAgY2FzZSAnbWVyJzpcbiAgICAgICAgICAgIGNhc2UgJ21mZSc6XG4gICAgICAgICAgICBjYXNlICdtZ2gnOlxuICAgICAgICAgICAgY2FzZSAnbXVhJzpcbiAgICAgICAgICAgIGNhc2UgJ216bic6XG4gICAgICAgICAgICBjYXNlICdubWcnOlxuICAgICAgICAgICAgY2FzZSAnbnVzJzpcbiAgICAgICAgICAgIGNhc2UgJ3F1JzpcbiAgICAgICAgICAgIGNhc2UgJ3JuJzpcbiAgICAgICAgICAgIGNhc2UgJ3J3JzpcbiAgICAgICAgICAgIGNhc2UgJ3NicCc6XG4gICAgICAgICAgICBjYXNlICd0d3EnOlxuICAgICAgICAgICAgY2FzZSAndmFpJzpcbiAgICAgICAgICAgIGNhc2UgJ3lhdic6XG4gICAgICAgICAgICBjYXNlICd5dWUnOlxuICAgICAgICAgICAgY2FzZSAnemdoJzpcbiAgICAgICAgICAgIGNhc2UgJ2FrJzpcbiAgICAgICAgICAgIGNhc2UgJ2xuJzpcbiAgICAgICAgICAgIGNhc2UgJ21nJzpcbiAgICAgICAgICAgIGNhc2UgJ3BhJzpcbiAgICAgICAgICAgIGNhc2UgJ3RpJzpcbiAgICAgICAgICAgICAgICBpZiAobiA9PT0gTWF0aC5mbG9vcihuKSAmJiBuID49IDAgJiYgbiA8PSAxKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk9uZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk90aGVyO1xuICAgICAgICAgICAgY2FzZSAnYW0nOlxuICAgICAgICAgICAgY2FzZSAnYXMnOlxuICAgICAgICAgICAgY2FzZSAnYm4nOlxuICAgICAgICAgICAgY2FzZSAnZmEnOlxuICAgICAgICAgICAgY2FzZSAnZ3UnOlxuICAgICAgICAgICAgY2FzZSAnaGknOlxuICAgICAgICAgICAgY2FzZSAna24nOlxuICAgICAgICAgICAgY2FzZSAnbXInOlxuICAgICAgICAgICAgY2FzZSAnenUnOlxuICAgICAgICAgICAgICAgIGlmIChpID09PSAwIHx8IG4gPT09IDEpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT25lO1xuICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT3RoZXI7XG4gICAgICAgICAgICBjYXNlICdhcic6XG4gICAgICAgICAgICAgICAgaWYgKG4gPT09IDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuWmVybztcbiAgICAgICAgICAgICAgICBpZiAobiA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XG4gICAgICAgICAgICAgICAgaWYgKG4gPT09IDIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuVHdvO1xuICAgICAgICAgICAgICAgIGlmIChuICUgMTAwID09PSBNYXRoLmZsb29yKG4gJSAxMDApICYmIG4gJSAxMDAgPj0gMyAmJiBuICUgMTAwIDw9IDEwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLkZldztcbiAgICAgICAgICAgICAgICBpZiAobiAlIDEwMCA9PT0gTWF0aC5mbG9vcihuICUgMTAwKSAmJiBuICUgMTAwID49IDExICYmIG4gJSAxMDAgPD0gOTkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuTWFueTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk90aGVyO1xuICAgICAgICAgICAgY2FzZSAnYXN0JzpcbiAgICAgICAgICAgIGNhc2UgJ2NhJzpcbiAgICAgICAgICAgIGNhc2UgJ2RlJzpcbiAgICAgICAgICAgIGNhc2UgJ2VuJzpcbiAgICAgICAgICAgIGNhc2UgJ2V0JzpcbiAgICAgICAgICAgIGNhc2UgJ2ZpJzpcbiAgICAgICAgICAgIGNhc2UgJ2Z5JzpcbiAgICAgICAgICAgIGNhc2UgJ2dsJzpcbiAgICAgICAgICAgIGNhc2UgJ2l0JzpcbiAgICAgICAgICAgIGNhc2UgJ25sJzpcbiAgICAgICAgICAgIGNhc2UgJ3N2JzpcbiAgICAgICAgICAgIGNhc2UgJ3N3JzpcbiAgICAgICAgICAgIGNhc2UgJ3VyJzpcbiAgICAgICAgICAgIGNhc2UgJ3lpJzpcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMSAmJiB2ID09PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk9uZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk90aGVyO1xuICAgICAgICAgICAgY2FzZSAnYmUnOlxuICAgICAgICAgICAgICAgIGlmIChuICUgMTAgPT09IDEgJiYgIShuICUgMTAwID09PSAxMSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT25lO1xuICAgICAgICAgICAgICAgIGlmIChuICUgMTAgPT09IE1hdGguZmxvb3IobiAlIDEwKSAmJiBuICUgMTAgPj0gMiAmJiBuICUgMTAgPD0gNCAmJlxuICAgICAgICAgICAgICAgICAgICAhKG4gJSAxMDAgPj0gMTIgJiYgbiAlIDEwMCA8PSAxNCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuRmV3O1xuICAgICAgICAgICAgICAgIGlmIChuICUgMTAgPT09IDAgfHwgbiAlIDEwID09PSBNYXRoLmZsb29yKG4gJSAxMCkgJiYgbiAlIDEwID49IDUgJiYgbiAlIDEwIDw9IDkgfHxcbiAgICAgICAgICAgICAgICAgICAgbiAlIDEwMCA9PT0gTWF0aC5mbG9vcihuICUgMTAwKSAmJiBuICUgMTAwID49IDExICYmIG4gJSAxMDAgPD0gMTQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuTWFueTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk90aGVyO1xuICAgICAgICAgICAgY2FzZSAnYnInOlxuICAgICAgICAgICAgICAgIGlmIChuICUgMTAgPT09IDEgJiYgIShuICUgMTAwID09PSAxMSB8fCBuICUgMTAwID09PSA3MSB8fCBuICUgMTAwID09PSA5MSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT25lO1xuICAgICAgICAgICAgICAgIGlmIChuICUgMTAgPT09IDIgJiYgIShuICUgMTAwID09PSAxMiB8fCBuICUgMTAwID09PSA3MiB8fCBuICUgMTAwID09PSA5MikpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuVHdvO1xuICAgICAgICAgICAgICAgIGlmIChuICUgMTAgPT09IE1hdGguZmxvb3IobiAlIDEwKSAmJiAobiAlIDEwID49IDMgJiYgbiAlIDEwIDw9IDQgfHwgbiAlIDEwID09PSA5KSAmJlxuICAgICAgICAgICAgICAgICAgICAhKG4gJSAxMDAgPj0gMTAgJiYgbiAlIDEwMCA8PSAxOSB8fCBuICUgMTAwID49IDcwICYmIG4gJSAxMDAgPD0gNzkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gJSAxMDAgPj0gOTAgJiYgbiAlIDEwMCA8PSA5OSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuRmV3O1xuICAgICAgICAgICAgICAgIGlmICghKG4gPT09IDApICYmIG4gJSAxZTYgPT09IDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuTWFueTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk90aGVyO1xuICAgICAgICAgICAgY2FzZSAnYnMnOlxuICAgICAgICAgICAgY2FzZSAnaHInOlxuICAgICAgICAgICAgY2FzZSAnc3InOlxuICAgICAgICAgICAgICAgIGlmICh2ID09PSAwICYmIGkgJSAxMCA9PT0gMSAmJiAhKGkgJSAxMDAgPT09IDExKSB8fCBmICUgMTAgPT09IDEgJiYgIShmICUgMTAwID09PSAxMSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT25lO1xuICAgICAgICAgICAgICAgIGlmICh2ID09PSAwICYmIGkgJSAxMCA9PT0gTWF0aC5mbG9vcihpICUgMTApICYmIGkgJSAxMCA+PSAyICYmIGkgJSAxMCA8PSA0ICYmXG4gICAgICAgICAgICAgICAgICAgICEoaSAlIDEwMCA+PSAxMiAmJiBpICUgMTAwIDw9IDE0KSB8fFxuICAgICAgICAgICAgICAgICAgICBmICUgMTAgPT09IE1hdGguZmxvb3IoZiAlIDEwKSAmJiBmICUgMTAgPj0gMiAmJiBmICUgMTAgPD0gNCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIShmICUgMTAwID49IDEyICYmIGYgJSAxMDAgPD0gMTQpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLkZldztcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk90aGVyO1xuICAgICAgICAgICAgY2FzZSAnY3MnOlxuICAgICAgICAgICAgY2FzZSAnc2snOlxuICAgICAgICAgICAgICAgIGlmIChpID09PSAxICYmIHYgPT09IDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT25lO1xuICAgICAgICAgICAgICAgIGlmIChpID09PSBNYXRoLmZsb29yKGkpICYmIGkgPj0gMiAmJiBpIDw9IDQgJiYgdiA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5GZXc7XG4gICAgICAgICAgICAgICAgaWYgKCEodiA9PT0gMCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuTWFueTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk90aGVyO1xuICAgICAgICAgICAgY2FzZSAnY3knOlxuICAgICAgICAgICAgICAgIGlmIChuID09PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLlplcm87XG4gICAgICAgICAgICAgICAgaWYgKG4gPT09IDEpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT25lO1xuICAgICAgICAgICAgICAgIGlmIChuID09PSAyKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLlR3bztcbiAgICAgICAgICAgICAgICBpZiAobiA9PT0gMylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5GZXc7XG4gICAgICAgICAgICAgICAgaWYgKG4gPT09IDYpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuTWFueTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk90aGVyO1xuICAgICAgICAgICAgY2FzZSAnZGEnOlxuICAgICAgICAgICAgICAgIGlmIChuID09PSAxIHx8ICEodCA9PT0gMCkgJiYgKGkgPT09IDAgfHwgaSA9PT0gMSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT25lO1xuICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT3RoZXI7XG4gICAgICAgICAgICBjYXNlICdkc2InOlxuICAgICAgICAgICAgY2FzZSAnaHNiJzpcbiAgICAgICAgICAgICAgICBpZiAodiA9PT0gMCAmJiBpICUgMTAwID09PSAxIHx8IGYgJSAxMDAgPT09IDEpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT25lO1xuICAgICAgICAgICAgICAgIGlmICh2ID09PSAwICYmIGkgJSAxMDAgPT09IDIgfHwgZiAlIDEwMCA9PT0gMilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5Ud287XG4gICAgICAgICAgICAgICAgaWYgKHYgPT09IDAgJiYgaSAlIDEwMCA9PT0gTWF0aC5mbG9vcihpICUgMTAwKSAmJiBpICUgMTAwID49IDMgJiYgaSAlIDEwMCA8PSA0IHx8XG4gICAgICAgICAgICAgICAgICAgIGYgJSAxMDAgPT09IE1hdGguZmxvb3IoZiAlIDEwMCkgJiYgZiAlIDEwMCA+PSAzICYmIGYgJSAxMDAgPD0gNClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5GZXc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PdGhlcjtcbiAgICAgICAgICAgIGNhc2UgJ2ZmJzpcbiAgICAgICAgICAgIGNhc2UgJ2ZyJzpcbiAgICAgICAgICAgIGNhc2UgJ2h5JzpcbiAgICAgICAgICAgIGNhc2UgJ2thYic6XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDAgfHwgaSA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PdGhlcjtcbiAgICAgICAgICAgIGNhc2UgJ2ZpbCc6XG4gICAgICAgICAgICAgICAgaWYgKHYgPT09IDAgJiYgKGkgPT09IDEgfHwgaSA9PT0gMiB8fCBpID09PSAzKSB8fFxuICAgICAgICAgICAgICAgICAgICB2ID09PSAwICYmICEoaSAlIDEwID09PSA0IHx8IGkgJSAxMCA9PT0gNiB8fCBpICUgMTAgPT09IDkpIHx8XG4gICAgICAgICAgICAgICAgICAgICEodiA9PT0gMCkgJiYgIShmICUgMTAgPT09IDQgfHwgZiAlIDEwID09PSA2IHx8IGYgJSAxMCA9PT0gOSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT25lO1xuICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT3RoZXI7XG4gICAgICAgICAgICBjYXNlICdnYSc6XG4gICAgICAgICAgICAgICAgaWYgKG4gPT09IDEpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT25lO1xuICAgICAgICAgICAgICAgIGlmIChuID09PSAyKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLlR3bztcbiAgICAgICAgICAgICAgICBpZiAobiA9PT0gTWF0aC5mbG9vcihuKSAmJiBuID49IDMgJiYgbiA8PSA2KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLkZldztcbiAgICAgICAgICAgICAgICBpZiAobiA9PT0gTWF0aC5mbG9vcihuKSAmJiBuID49IDcgJiYgbiA8PSAxMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5NYW55O1xuICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT3RoZXI7XG4gICAgICAgICAgICBjYXNlICdnZCc6XG4gICAgICAgICAgICAgICAgaWYgKG4gPT09IDEgfHwgbiA9PT0gMTEpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT25lO1xuICAgICAgICAgICAgICAgIGlmIChuID09PSAyIHx8IG4gPT09IDEyKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLlR3bztcbiAgICAgICAgICAgICAgICBpZiAobiA9PT0gTWF0aC5mbG9vcihuKSAmJiAobiA+PSAzICYmIG4gPD0gMTAgfHwgbiA+PSAxMyAmJiBuIDw9IDE5KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5GZXc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PdGhlcjtcbiAgICAgICAgICAgIGNhc2UgJ2d2JzpcbiAgICAgICAgICAgICAgICBpZiAodiA9PT0gMCAmJiBpICUgMTAgPT09IDEpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT25lO1xuICAgICAgICAgICAgICAgIGlmICh2ID09PSAwICYmIGkgJSAxMCA9PT0gMilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5Ud287XG4gICAgICAgICAgICAgICAgaWYgKHYgPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgKGkgJSAxMDAgPT09IDAgfHwgaSAlIDEwMCA9PT0gMjAgfHwgaSAlIDEwMCA9PT0gNDAgfHwgaSAlIDEwMCA9PT0gNjAgfHwgaSAlIDEwMCA9PT0gODApKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLkZldztcbiAgICAgICAgICAgICAgICBpZiAoISh2ID09PSAwKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5NYW55O1xuICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT3RoZXI7XG4gICAgICAgICAgICBjYXNlICdoZSc6XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDEgJiYgdiA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDIgJiYgdiA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5Ud287XG4gICAgICAgICAgICAgICAgaWYgKHYgPT09IDAgJiYgIShuID49IDAgJiYgbiA8PSAxMCkgJiYgbiAlIDEwID09PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk1hbnk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PdGhlcjtcbiAgICAgICAgICAgIGNhc2UgJ2lzJzpcbiAgICAgICAgICAgICAgICBpZiAodCA9PT0gMCAmJiBpICUgMTAgPT09IDEgJiYgIShpICUgMTAwID09PSAxMSkgfHwgISh0ID09PSAwKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PdGhlcjtcbiAgICAgICAgICAgIGNhc2UgJ2tzaCc6XG4gICAgICAgICAgICAgICAgaWYgKG4gPT09IDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuWmVybztcbiAgICAgICAgICAgICAgICBpZiAobiA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PdGhlcjtcbiAgICAgICAgICAgIGNhc2UgJ2t3JzpcbiAgICAgICAgICAgIGNhc2UgJ25hcSc6XG4gICAgICAgICAgICBjYXNlICdzZSc6XG4gICAgICAgICAgICBjYXNlICdzbW4nOlxuICAgICAgICAgICAgICAgIGlmIChuID09PSAxKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk9uZTtcbiAgICAgICAgICAgICAgICBpZiAobiA9PT0gMilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5Ud287XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PdGhlcjtcbiAgICAgICAgICAgIGNhc2UgJ2xhZyc6XG4gICAgICAgICAgICAgICAgaWYgKG4gPT09IDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuWmVybztcbiAgICAgICAgICAgICAgICBpZiAoKGkgPT09IDAgfHwgaSA9PT0gMSkgJiYgIShuID09PSAwKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PdGhlcjtcbiAgICAgICAgICAgIGNhc2UgJ2x0JzpcbiAgICAgICAgICAgICAgICBpZiAobiAlIDEwID09PSAxICYmICEobiAlIDEwMCA+PSAxMSAmJiBuICUgMTAwIDw9IDE5KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XG4gICAgICAgICAgICAgICAgaWYgKG4gJSAxMCA9PT0gTWF0aC5mbG9vcihuICUgMTApICYmIG4gJSAxMCA+PSAyICYmIG4gJSAxMCA8PSA5ICYmXG4gICAgICAgICAgICAgICAgICAgICEobiAlIDEwMCA+PSAxMSAmJiBuICUgMTAwIDw9IDE5KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5GZXc7XG4gICAgICAgICAgICAgICAgaWYgKCEoZiA9PT0gMCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuTWFueTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk90aGVyO1xuICAgICAgICAgICAgY2FzZSAnbHYnOlxuICAgICAgICAgICAgY2FzZSAncHJnJzpcbiAgICAgICAgICAgICAgICBpZiAobiAlIDEwID09PSAwIHx8IG4gJSAxMDAgPT09IE1hdGguZmxvb3IobiAlIDEwMCkgJiYgbiAlIDEwMCA+PSAxMSAmJiBuICUgMTAwIDw9IDE5IHx8XG4gICAgICAgICAgICAgICAgICAgIHYgPT09IDIgJiYgZiAlIDEwMCA9PT0gTWF0aC5mbG9vcihmICUgMTAwKSAmJiBmICUgMTAwID49IDExICYmIGYgJSAxMDAgPD0gMTkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuWmVybztcbiAgICAgICAgICAgICAgICBpZiAobiAlIDEwID09PSAxICYmICEobiAlIDEwMCA9PT0gMTEpIHx8IHYgPT09IDIgJiYgZiAlIDEwID09PSAxICYmICEoZiAlIDEwMCA9PT0gMTEpIHx8XG4gICAgICAgICAgICAgICAgICAgICEodiA9PT0gMikgJiYgZiAlIDEwID09PSAxKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk9uZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk90aGVyO1xuICAgICAgICAgICAgY2FzZSAnbWsnOlxuICAgICAgICAgICAgICAgIGlmICh2ID09PSAwICYmIGkgJSAxMCA9PT0gMSB8fCBmICUgMTAgPT09IDEpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT25lO1xuICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT3RoZXI7XG4gICAgICAgICAgICBjYXNlICdtdCc6XG4gICAgICAgICAgICAgICAgaWYgKG4gPT09IDEpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT25lO1xuICAgICAgICAgICAgICAgIGlmIChuID09PSAwIHx8IG4gJSAxMDAgPT09IE1hdGguZmxvb3IobiAlIDEwMCkgJiYgbiAlIDEwMCA+PSAyICYmIG4gJSAxMDAgPD0gMTApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuRmV3O1xuICAgICAgICAgICAgICAgIGlmIChuICUgMTAwID09PSBNYXRoLmZsb29yKG4gJSAxMDApICYmIG4gJSAxMDAgPj0gMTEgJiYgbiAlIDEwMCA8PSAxOSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5NYW55O1xuICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT3RoZXI7XG4gICAgICAgICAgICBjYXNlICdwbCc6XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDEgJiYgdiA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XG4gICAgICAgICAgICAgICAgaWYgKHYgPT09IDAgJiYgaSAlIDEwID09PSBNYXRoLmZsb29yKGkgJSAxMCkgJiYgaSAlIDEwID49IDIgJiYgaSAlIDEwIDw9IDQgJiZcbiAgICAgICAgICAgICAgICAgICAgIShpICUgMTAwID49IDEyICYmIGkgJSAxMDAgPD0gMTQpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLkZldztcbiAgICAgICAgICAgICAgICBpZiAodiA9PT0gMCAmJiAhKGkgPT09IDEpICYmIGkgJSAxMCA9PT0gTWF0aC5mbG9vcihpICUgMTApICYmIGkgJSAxMCA+PSAwICYmIGkgJSAxMCA8PSAxIHx8XG4gICAgICAgICAgICAgICAgICAgIHYgPT09IDAgJiYgaSAlIDEwID09PSBNYXRoLmZsb29yKGkgJSAxMCkgJiYgaSAlIDEwID49IDUgJiYgaSAlIDEwIDw9IDkgfHxcbiAgICAgICAgICAgICAgICAgICAgdiA9PT0gMCAmJiBpICUgMTAwID09PSBNYXRoLmZsb29yKGkgJSAxMDApICYmIGkgJSAxMDAgPj0gMTIgJiYgaSAlIDEwMCA8PSAxNClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5NYW55O1xuICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT3RoZXI7XG4gICAgICAgICAgICBjYXNlICdwdCc6XG4gICAgICAgICAgICAgICAgaWYgKG4gPT09IE1hdGguZmxvb3IobikgJiYgbiA+PSAwICYmIG4gPD0gMiAmJiAhKG4gPT09IDIpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk9uZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk90aGVyO1xuICAgICAgICAgICAgY2FzZSAncm8nOlxuICAgICAgICAgICAgICAgIGlmIChpID09PSAxICYmIHYgPT09IDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT25lO1xuICAgICAgICAgICAgICAgIGlmICghKHYgPT09IDApIHx8IG4gPT09IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgIShuID09PSAxKSAmJiBuICUgMTAwID09PSBNYXRoLmZsb29yKG4gJSAxMDApICYmIG4gJSAxMDAgPj0gMSAmJiBuICUgMTAwIDw9IDE5KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLkZldztcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk90aGVyO1xuICAgICAgICAgICAgY2FzZSAncnUnOlxuICAgICAgICAgICAgY2FzZSAndWsnOlxuICAgICAgICAgICAgICAgIGlmICh2ID09PSAwICYmIGkgJSAxMCA9PT0gMSAmJiAhKGkgJSAxMDAgPT09IDExKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XG4gICAgICAgICAgICAgICAgaWYgKHYgPT09IDAgJiYgaSAlIDEwID09PSBNYXRoLmZsb29yKGkgJSAxMCkgJiYgaSAlIDEwID49IDIgJiYgaSAlIDEwIDw9IDQgJiZcbiAgICAgICAgICAgICAgICAgICAgIShpICUgMTAwID49IDEyICYmIGkgJSAxMDAgPD0gMTQpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLkZldztcbiAgICAgICAgICAgICAgICBpZiAodiA9PT0gMCAmJiBpICUgMTAgPT09IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgdiA9PT0gMCAmJiBpICUgMTAgPT09IE1hdGguZmxvb3IoaSAlIDEwKSAmJiBpICUgMTAgPj0gNSAmJiBpICUgMTAgPD0gOSB8fFxuICAgICAgICAgICAgICAgICAgICB2ID09PSAwICYmIGkgJSAxMDAgPT09IE1hdGguZmxvb3IoaSAlIDEwMCkgJiYgaSAlIDEwMCA+PSAxMSAmJiBpICUgMTAwIDw9IDE0KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk1hbnk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PdGhlcjtcbiAgICAgICAgICAgIGNhc2UgJ3NoaSc6XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDAgfHwgbiA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XG4gICAgICAgICAgICAgICAgaWYgKG4gPT09IE1hdGguZmxvb3IobikgJiYgbiA+PSAyICYmIG4gPD0gMTApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuRmV3O1xuICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT3RoZXI7XG4gICAgICAgICAgICBjYXNlICdzaSc6XG4gICAgICAgICAgICAgICAgaWYgKG4gPT09IDAgfHwgbiA9PT0gMSB8fCBpID09PSAwICYmIGYgPT09IDEpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT25lO1xuICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT3RoZXI7XG4gICAgICAgICAgICBjYXNlICdzbCc6XG4gICAgICAgICAgICAgICAgaWYgKHYgPT09IDAgJiYgaSAlIDEwMCA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XG4gICAgICAgICAgICAgICAgaWYgKHYgPT09IDAgJiYgaSAlIDEwMCA9PT0gMilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5Ud287XG4gICAgICAgICAgICAgICAgaWYgKHYgPT09IDAgJiYgaSAlIDEwMCA9PT0gTWF0aC5mbG9vcihpICUgMTAwKSAmJiBpICUgMTAwID49IDMgJiYgaSAlIDEwMCA8PSA0IHx8ICEodiA9PT0gMCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuRmV3O1xuICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT3RoZXI7XG4gICAgICAgICAgICBjYXNlICd0em0nOlxuICAgICAgICAgICAgICAgIGlmIChuID09PSBNYXRoLmZsb29yKG4pICYmIG4gPj0gMCAmJiBuIDw9IDEgfHwgbiA9PT0gTWF0aC5mbG9vcihuKSAmJiBuID49IDExICYmIG4gPD0gOTkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT25lO1xuICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT3RoZXI7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT3RoZXI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTYWZhcmkgZG9lc24ndCBpbXBsZW1lbnQgTWFwSXRlcmF0b3IubmV4dCgpLCB3aGljaCBpcyB1c2VkIGlzIFRyYWNldXIncyBwb2x5ZmlsbCBvZiBBcnJheS5mcm9tXG4gICAgLy8gVE9ETyhtbGF2YWwpOiByZW1vdmUgdGhlIHdvcmsgYXJvdW5kIG9uY2Ugd2UgaGF2ZSBhIHdvcmtpbmcgcG9seWZpbGwgb2YgQXJyYXkuZnJvbVxuICAgIHZhciBfYXJyYXlGcm9tTWFwID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICgobmV3IE1hcCgpKS52YWx1ZXMoKS5uZXh0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUFycmF5RnJvbU1hcChtLCBnZXRWYWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldFZhbHVlcyA/IEFycmF5LmZyb20obS52YWx1ZXMoKSkgOiBBcnJheS5mcm9tKG0ua2V5cygpKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUFycmF5RnJvbU1hcFdpdGhGb3JlYWNoKG0sIGdldFZhbHVlcykge1xuICAgICAgICAgICAgdmFyIHJlcyA9IG5ldyBBcnJheShtLnNpemUpLCBpID0gMDtcbiAgICAgICAgICAgIG0uZm9yRWFjaChmdW5jdGlvbiAodiwgaykge1xuICAgICAgICAgICAgICAgIHJlc1tpXSA9IGdldFZhbHVlcyA/IHYgOiBrO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfTtcbiAgICB9KSgpO1xuICAgIHZhciBMaXN0V3JhcHBlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIExpc3RXcmFwcGVyKCkge1xuICAgICAgICB9XG4gICAgICAgIC8vIEpTIGhhcyBubyB3YXkgdG8gZXhwcmVzcyBhIHN0YXRpY2FsbHkgZml4ZWQgc2l6ZSBsaXN0LCBidXQgZGFydCBkb2VzIHNvIHdlXG4gICAgICAgIC8vIGtlZXAgYm90aCBtZXRob2RzLlxuICAgICAgICBMaXN0V3JhcHBlci5jcmVhdGVGaXhlZFNpemUgPSBmdW5jdGlvbiAoc2l6ZSkgeyByZXR1cm4gbmV3IEFycmF5KHNpemUpOyB9O1xuICAgICAgICBMaXN0V3JhcHBlci5jcmVhdGVHcm93YWJsZVNpemUgPSBmdW5jdGlvbiAoc2l6ZSkgeyByZXR1cm4gbmV3IEFycmF5KHNpemUpOyB9O1xuICAgICAgICBMaXN0V3JhcHBlci5jbG9uZSA9IGZ1bmN0aW9uIChhcnJheSkgeyByZXR1cm4gYXJyYXkuc2xpY2UoMCk7IH07XG4gICAgICAgIExpc3RXcmFwcGVyLmZvckVhY2hXaXRoSW5kZXggPSBmdW5jdGlvbiAoYXJyYXksIGZuKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm4oYXJyYXlbaV0sIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBMaXN0V3JhcHBlci5maXJzdCA9IGZ1bmN0aW9uIChhcnJheSkge1xuICAgICAgICAgICAgaWYgKCFhcnJheSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBhcnJheVswXTtcbiAgICAgICAgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIubGFzdCA9IGZ1bmN0aW9uIChhcnJheSkge1xuICAgICAgICAgICAgaWYgKCFhcnJheSB8fCBhcnJheS5sZW5ndGggPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBhcnJheVthcnJheS5sZW5ndGggLSAxXTtcbiAgICAgICAgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIuaW5kZXhPZiA9IGZ1bmN0aW9uIChhcnJheSwgdmFsdWUsIHN0YXJ0SW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChzdGFydEluZGV4ID09PSB2b2lkIDApIHsgc3RhcnRJbmRleCA9IDA7IH1cbiAgICAgICAgICAgIHJldHVybiBhcnJheS5pbmRleE9mKHZhbHVlLCBzdGFydEluZGV4KTtcbiAgICAgICAgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIuY29udGFpbnMgPSBmdW5jdGlvbiAobGlzdCwgZWwpIHsgcmV0dXJuIGxpc3QuaW5kZXhPZihlbCkgIT09IC0xOyB9O1xuICAgICAgICBMaXN0V3JhcHBlci5yZXZlcnNlZCA9IGZ1bmN0aW9uIChhcnJheSkge1xuICAgICAgICAgICAgdmFyIGEgPSBMaXN0V3JhcHBlci5jbG9uZShhcnJheSk7XG4gICAgICAgICAgICByZXR1cm4gYS5yZXZlcnNlKCk7XG4gICAgICAgIH07XG4gICAgICAgIExpc3RXcmFwcGVyLmNvbmNhdCA9IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmNvbmNhdChiKTsgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIuaW5zZXJ0ID0gZnVuY3Rpb24gKGxpc3QsIGluZGV4LCB2YWx1ZSkgeyBsaXN0LnNwbGljZShpbmRleCwgMCwgdmFsdWUpOyB9O1xuICAgICAgICBMaXN0V3JhcHBlci5yZW1vdmVBdCA9IGZ1bmN0aW9uIChsaXN0LCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIHJlcyA9IGxpc3RbaW5kZXhdO1xuICAgICAgICAgICAgbGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIucmVtb3ZlQWxsID0gZnVuY3Rpb24gKGxpc3QsIGl0ZW1zKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gbGlzdC5pbmRleE9mKGl0ZW1zW2ldKTtcbiAgICAgICAgICAgICAgICBsaXN0LnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIExpc3RXcmFwcGVyLnJlbW92ZSA9IGZ1bmN0aW9uIChsaXN0LCBlbCkge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gbGlzdC5pbmRleE9mKGVsKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgbGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICBMaXN0V3JhcHBlci5jbGVhciA9IGZ1bmN0aW9uIChsaXN0KSB7IGxpc3QubGVuZ3RoID0gMDsgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIuaXNFbXB0eSA9IGZ1bmN0aW9uIChsaXN0KSB7IHJldHVybiBsaXN0Lmxlbmd0aCA9PSAwOyB9O1xuICAgICAgICBMaXN0V3JhcHBlci5maWxsID0gZnVuY3Rpb24gKGxpc3QsIHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPT09IHZvaWQgMCkgeyBzdGFydCA9IDA7IH1cbiAgICAgICAgICAgIGlmIChlbmQgPT09IHZvaWQgMCkgeyBlbmQgPSBudWxsOyB9XG4gICAgICAgICAgICBsaXN0LmZpbGwodmFsdWUsIHN0YXJ0LCBlbmQgPT09IG51bGwgPyBsaXN0Lmxlbmd0aCA6IGVuZCk7XG4gICAgICAgIH07XG4gICAgICAgIExpc3RXcmFwcGVyLmVxdWFscyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICBMaXN0V3JhcHBlci5zbGljZSA9IGZ1bmN0aW9uIChsLCBmcm9tLCB0bykge1xuICAgICAgICAgICAgaWYgKGZyb20gPT09IHZvaWQgMCkgeyBmcm9tID0gMDsgfVxuICAgICAgICAgICAgaWYgKHRvID09PSB2b2lkIDApIHsgdG8gPSBudWxsOyB9XG4gICAgICAgICAgICByZXR1cm4gbC5zbGljZShmcm9tLCB0byA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6IHRvKTtcbiAgICAgICAgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIuc3BsaWNlID0gZnVuY3Rpb24gKGwsIGZyb20sIGxlbmd0aCkgeyByZXR1cm4gbC5zcGxpY2UoZnJvbSwgbGVuZ3RoKTsgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIuc29ydCA9IGZ1bmN0aW9uIChsLCBjb21wYXJlRm4pIHtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoY29tcGFyZUZuKSkge1xuICAgICAgICAgICAgICAgIGwuc29ydChjb21wYXJlRm4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbC5zb3J0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIExpc3RXcmFwcGVyLnRvU3RyaW5nID0gZnVuY3Rpb24gKGwpIHsgcmV0dXJuIGwudG9TdHJpbmcoKTsgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIudG9KU09OID0gZnVuY3Rpb24gKGwpIHsgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGwpOyB9O1xuICAgICAgICBMaXN0V3JhcHBlci5tYXhpbXVtID0gZnVuY3Rpb24gKGxpc3QsIHByZWRpY2F0ZSkge1xuICAgICAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzb2x1dGlvbiA9IG51bGw7XG4gICAgICAgICAgICB2YXIgbWF4VmFsdWUgPSAtSW5maW5pdHk7XG4gICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGlzdC5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2FuZGlkYXRlID0gbGlzdFtpbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKGlzQmxhbmsoY2FuZGlkYXRlKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGNhbmRpZGF0ZVZhbHVlID0gcHJlZGljYXRlKGNhbmRpZGF0ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGNhbmRpZGF0ZVZhbHVlID4gbWF4VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgc29sdXRpb24gPSBjYW5kaWRhdGU7XG4gICAgICAgICAgICAgICAgICAgIG1heFZhbHVlID0gY2FuZGlkYXRlVmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNvbHV0aW9uO1xuICAgICAgICB9O1xuICAgICAgICBMaXN0V3JhcHBlci5mbGF0dGVuID0gZnVuY3Rpb24gKGxpc3QpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBbXTtcbiAgICAgICAgICAgIF9mbGF0dGVuQXJyYXkobGlzdCwgdGFyZ2V0KTtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgIH07XG4gICAgICAgIExpc3RXcmFwcGVyLmFkZEFsbCA9IGZ1bmN0aW9uIChsaXN0LCBzb3VyY2UpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc291cmNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGlzdC5wdXNoKHNvdXJjZVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBMaXN0V3JhcHBlcjtcbiAgICB9KCkpO1xuICAgIGZ1bmN0aW9uIF9mbGF0dGVuQXJyYXkoc291cmNlLCB0YXJnZXQpIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudChzb3VyY2UpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvdXJjZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gc291cmNlW2ldO1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgIF9mbGF0dGVuQXJyYXkoaXRlbSwgdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0xpc3RMaWtlSXRlcmFibGUob2JqKSB7XG4gICAgICAgIGlmICghaXNKc09iamVjdChvYmopKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShvYmopIHx8XG4gICAgICAgICAgICAoIShvYmogaW5zdGFuY2VvZiBNYXApICYmXG4gICAgICAgICAgICAgICAgZ2V0U3ltYm9sSXRlcmF0b3IoKSBpbiBvYmopOyAvLyBKUyBJdGVyYWJsZSBoYXZlIGEgU3ltYm9sLml0ZXJhdG9yIHByb3BcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbmdNb2R1bGUgQ29tbW9uTW9kdWxlXG4gICAgICpcbiAgICAgKiBAd2hhdEl0RG9lcyBBZGRzIGFuZCByZW1vdmVzIENTUyBjbGFzc2VzIG9uIGFuIEhUTUwgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBob3dUb1VzZVxuICAgICAqIGBgYFxuICAgICAqICAgICA8c29tZS1lbGVtZW50IFtuZ0NsYXNzXT1cIidmaXJzdCBzZWNvbmQnXCI+Li4uPC9zb21lLWVsZW1lbnQ+XG4gICAgICpcbiAgICAgKiAgICAgPHNvbWUtZWxlbWVudCBbbmdDbGFzc109XCJbJ2ZpcnN0JywgJ3NlY29uZCddXCI+Li4uPC9zb21lLWVsZW1lbnQ+XG4gICAgICpcbiAgICAgKiAgICAgPHNvbWUtZWxlbWVudCBbbmdDbGFzc109XCJ7J2ZpcnN0JzogdHJ1ZSwgJ3NlY29uZCc6IHRydWUsICd0aGlyZCc6IGZhbHNlfVwiPi4uLjwvc29tZS1lbGVtZW50PlxuICAgICAqXG4gICAgICogICAgIDxzb21lLWVsZW1lbnQgW25nQ2xhc3NdPVwic3RyaW5nRXhwfGFycmF5RXhwfG9iakV4cFwiPi4uLjwvc29tZS1lbGVtZW50PlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBUaGUgQ1NTIGNsYXNzZXMgYXJlIHVwZGF0ZWQgYXMgZm9sbG93IGRlcGVuZGluZyBvbiB0aGUgdHlwZSBvZiB0aGUgZXhwcmVzc2lvbiBldmFsdWF0aW9uOlxuICAgICAqIC0gYHN0cmluZ2AgLSB0aGUgQ1NTIGNsYXNzZXMgbGlzdGVkIGluIGEgc3RyaW5nIChzcGFjZSBkZWxpbWl0ZWQpIGFyZSBhZGRlZCxcbiAgICAgKiAtIGBBcnJheWAgLSB0aGUgQ1NTIGNsYXNzZXMgKEFycmF5IGVsZW1lbnRzKSBhcmUgYWRkZWQsXG4gICAgICogLSBgT2JqZWN0YCAtIGtleXMgYXJlIENTUyBjbGFzcyBuYW1lcyB0aGF0IGdldCBhZGRlZCB3aGVuIHRoZSBleHByZXNzaW9uIGdpdmVuIGluIHRoZSB2YWx1ZVxuICAgICAqICAgICAgICAgICAgICBldmFsdWF0ZXMgdG8gYSB0cnV0aHkgdmFsdWUsIG90aGVyd2lzZSBjbGFzcyBhcmUgcmVtb3ZlZC5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgTmdDbGFzcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE5nQ2xhc3MoX2l0ZXJhYmxlRGlmZmVycywgX2tleVZhbHVlRGlmZmVycywgX25nRWwsIF9yZW5kZXJlcikge1xuICAgICAgICAgICAgdGhpcy5faXRlcmFibGVEaWZmZXJzID0gX2l0ZXJhYmxlRGlmZmVycztcbiAgICAgICAgICAgIHRoaXMuX2tleVZhbHVlRGlmZmVycyA9IF9rZXlWYWx1ZURpZmZlcnM7XG4gICAgICAgICAgICB0aGlzLl9uZ0VsID0gX25nRWw7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgICAgIHRoaXMuX2luaXRpYWxDbGFzc2VzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nQ2xhc3MucHJvdG90eXBlLCBcImtsYXNzXCIsIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hcHBseUluaXRpYWxDbGFzc2VzKHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXRpYWxDbGFzc2VzID0gdHlwZW9mIHYgPT09ICdzdHJpbmcnID8gdi5zcGxpdCgvXFxzKy8pIDogW107XG4gICAgICAgICAgICAgICAgdGhpcy5fYXBwbHlJbml0aWFsQ2xhc3NlcyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYXBwbHlDbGFzc2VzKHRoaXMuX3Jhd0NsYXNzLCBmYWxzZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nQ2xhc3MucHJvdG90eXBlLCBcIm5nQ2xhc3NcIiwge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NsZWFudXBDbGFzc2VzKHRoaXMuX3Jhd0NsYXNzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pdGVyYWJsZURpZmZlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5fa2V5VmFsdWVEaWZmZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jhd0NsYXNzID0gdHlwZW9mIHYgPT09ICdzdHJpbmcnID8gdi5zcGxpdCgvXFxzKy8pIDogdjtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcmF3Q2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTGlzdExpa2VJdGVyYWJsZSh0aGlzLl9yYXdDbGFzcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2l0ZXJhYmxlRGlmZmVyID0gdGhpcy5faXRlcmFibGVEaWZmZXJzLmZpbmQodGhpcy5fcmF3Q2xhc3MpLmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2tleVZhbHVlRGlmZmVyID0gdGhpcy5fa2V5VmFsdWVEaWZmZXJzLmZpbmQodGhpcy5fcmF3Q2xhc3MpLmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBOZ0NsYXNzLnByb3RvdHlwZS5uZ0RvQ2hlY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faXRlcmFibGVEaWZmZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hhbmdlcyA9IHRoaXMuX2l0ZXJhYmxlRGlmZmVyLmRpZmYodGhpcy5fcmF3Q2xhc3MpO1xuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FwcGx5SXRlcmFibGVDaGFuZ2VzKGNoYW5nZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2tleVZhbHVlRGlmZmVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoYW5nZXMgPSB0aGlzLl9rZXlWYWx1ZURpZmZlci5kaWZmKHRoaXMuX3Jhd0NsYXNzKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hcHBseUtleVZhbHVlQ2hhbmdlcyhjaGFuZ2VzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE5nQ2xhc3MucHJvdG90eXBlLl9jbGVhbnVwQ2xhc3NlcyA9IGZ1bmN0aW9uIChyYXdDbGFzc1ZhbCkge1xuICAgICAgICAgICAgdGhpcy5fYXBwbHlDbGFzc2VzKHJhd0NsYXNzVmFsLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuX2FwcGx5SW5pdGlhbENsYXNzZXMoZmFsc2UpO1xuICAgICAgICB9O1xuICAgICAgICBOZ0NsYXNzLnByb3RvdHlwZS5fYXBwbHlLZXlWYWx1ZUNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGNoYW5nZXMuZm9yRWFjaEFkZGVkSXRlbShmdW5jdGlvbiAocmVjb3JkKSB7IHJldHVybiBfdGhpcy5fdG9nZ2xlQ2xhc3MocmVjb3JkLmtleSwgcmVjb3JkLmN1cnJlbnRWYWx1ZSk7IH0pO1xuICAgICAgICAgICAgY2hhbmdlcy5mb3JFYWNoQ2hhbmdlZEl0ZW0oZnVuY3Rpb24gKHJlY29yZCkgeyByZXR1cm4gX3RoaXMuX3RvZ2dsZUNsYXNzKHJlY29yZC5rZXksIHJlY29yZC5jdXJyZW50VmFsdWUpOyB9KTtcbiAgICAgICAgICAgIGNoYW5nZXMuZm9yRWFjaFJlbW92ZWRJdGVtKGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVjb3JkLnByZXZpb3VzVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3RvZ2dsZUNsYXNzKHJlY29yZC5rZXksIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgTmdDbGFzcy5wcm90b3R5cGUuX2FwcGx5SXRlcmFibGVDaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBjaGFuZ2VzLmZvckVhY2hBZGRlZEl0ZW0oZnVuY3Rpb24gKHJlY29yZCkgeyByZXR1cm4gX3RoaXMuX3RvZ2dsZUNsYXNzKHJlY29yZC5pdGVtLCB0cnVlKTsgfSk7XG4gICAgICAgICAgICBjaGFuZ2VzLmZvckVhY2hSZW1vdmVkSXRlbShmdW5jdGlvbiAocmVjb3JkKSB7IHJldHVybiBfdGhpcy5fdG9nZ2xlQ2xhc3MocmVjb3JkLml0ZW0sIGZhbHNlKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIE5nQ2xhc3MucHJvdG90eXBlLl9hcHBseUluaXRpYWxDbGFzc2VzID0gZnVuY3Rpb24gKGlzQ2xlYW51cCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuX2luaXRpYWxDbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKGtsYXNzKSB7IHJldHVybiBfdGhpcy5fdG9nZ2xlQ2xhc3Moa2xhc3MsICFpc0NsZWFudXApOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgTmdDbGFzcy5wcm90b3R5cGUuX2FwcGx5Q2xhc3NlcyA9IGZ1bmN0aW9uIChyYXdDbGFzc1ZhbCwgaXNDbGVhbnVwKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKHJhd0NsYXNzVmFsKSB7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmF3Q2xhc3NWYWwpIHx8IHJhd0NsYXNzVmFsIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJhd0NsYXNzVmFsLmZvckVhY2goZnVuY3Rpb24gKGtsYXNzKSB7IHJldHVybiBfdGhpcy5fdG9nZ2xlQ2xhc3Moa2xhc3MsICFpc0NsZWFudXApOyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHJhd0NsYXNzVmFsKS5mb3JFYWNoKGZ1bmN0aW9uIChrbGFzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudChyYXdDbGFzc1ZhbFtrbGFzc10pKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl90b2dnbGVDbGFzcyhrbGFzcywgIWlzQ2xlYW51cCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgTmdDbGFzcy5wcm90b3R5cGUuX3RvZ2dsZUNsYXNzID0gZnVuY3Rpb24gKGtsYXNzLCBlbmFibGVkKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAga2xhc3MgPSBrbGFzcy50cmltKCk7XG4gICAgICAgICAgICBpZiAoa2xhc3MpIHtcbiAgICAgICAgICAgICAgICBrbGFzcy5zcGxpdCgvXFxzKy9nKS5mb3JFYWNoKGZ1bmN0aW9uIChrbGFzcykgeyBfdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudENsYXNzKF90aGlzLl9uZ0VsLm5hdGl2ZUVsZW1lbnQsIGtsYXNzLCBlbmFibGVkKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE5nQ2xhc3MuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnW25nQ2xhc3NdJyB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIE5nQ2xhc3MuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSXRlcmFibGVEaWZmZXJzLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLktleVZhbHVlRGlmZmVycywgfSxcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlJlbmRlcmVyLCB9LFxuICAgICAgICBdO1xuICAgICAgICBOZ0NsYXNzLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAgICAgJ2tsYXNzJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCwgYXJnczogWydjbGFzcycsXSB9LF0sXG4gICAgICAgICAgICAnbmdDbGFzcyc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQgfSxdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gTmdDbGFzcztcbiAgICB9KCkpO1xuXG4gICAgdmFyIE5nRm9yUm93ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTmdGb3JSb3coJGltcGxpY2l0LCBpbmRleCwgY291bnQpIHtcbiAgICAgICAgICAgIHRoaXMuJGltcGxpY2l0ID0gJGltcGxpY2l0O1xuICAgICAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgdGhpcy5jb3VudCA9IGNvdW50O1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0ZvclJvdy5wcm90b3R5cGUsIFwiZmlyc3RcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmluZGV4ID09PSAwOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nRm9yUm93LnByb3RvdHlwZSwgXCJsYXN0XCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5pbmRleCA9PT0gdGhpcy5jb3VudCAtIDE7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdGb3JSb3cucHJvdG90eXBlLCBcImV2ZW5cIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmluZGV4ICUgMiA9PT0gMDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0ZvclJvdy5wcm90b3R5cGUsIFwib2RkXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gIXRoaXMuZXZlbjsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBOZ0ZvclJvdztcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIFRoZSBgTmdGb3JgIGRpcmVjdGl2ZSBpbnN0YW50aWF0ZXMgYSB0ZW1wbGF0ZSBvbmNlIHBlciBpdGVtIGZyb20gYW4gaXRlcmFibGUuIFRoZSBjb250ZXh0IGZvclxuICAgICAqIGVhY2ggaW5zdGFudGlhdGVkIHRlbXBsYXRlIGluaGVyaXRzIGZyb20gdGhlIG91dGVyIGNvbnRleHQgd2l0aCB0aGUgZ2l2ZW4gbG9vcCB2YXJpYWJsZSBzZXRcbiAgICAgKiB0byB0aGUgY3VycmVudCBpdGVtIGZyb20gdGhlIGl0ZXJhYmxlLlxuICAgICAqXG4gICAgICogIyMjIExvY2FsIFZhcmlhYmxlc1xuICAgICAqXG4gICAgICogYE5nRm9yYCBwcm92aWRlcyBzZXZlcmFsIGV4cG9ydGVkIHZhbHVlcyB0aGF0IGNhbiBiZSBhbGlhc2VkIHRvIGxvY2FsIHZhcmlhYmxlczpcbiAgICAgKlxuICAgICAqICogYGluZGV4YCB3aWxsIGJlIHNldCB0byB0aGUgY3VycmVudCBsb29wIGl0ZXJhdGlvbiBmb3IgZWFjaCB0ZW1wbGF0ZSBjb250ZXh0LlxuICAgICAqICogYGZpcnN0YCB3aWxsIGJlIHNldCB0byBhIGJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBpdGVtIGlzIHRoZSBmaXJzdCBvbmUgaW4gdGhlXG4gICAgICogICBpdGVyYXRpb24uXG4gICAgICogKiBgbGFzdGAgd2lsbCBiZSBzZXQgdG8gYSBib29sZWFuIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0aGUgaXRlbSBpcyB0aGUgbGFzdCBvbmUgaW4gdGhlXG4gICAgICogICBpdGVyYXRpb24uXG4gICAgICogKiBgZXZlbmAgd2lsbCBiZSBzZXQgdG8gYSBib29sZWFuIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0aGlzIGl0ZW0gaGFzIGFuIGV2ZW4gaW5kZXguXG4gICAgICogKiBgb2RkYCB3aWxsIGJlIHNldCB0byBhIGJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRoaXMgaXRlbSBoYXMgYW4gb2RkIGluZGV4LlxuICAgICAqXG4gICAgICogIyMjIENoYW5nZSBQcm9wYWdhdGlvblxuICAgICAqXG4gICAgICogV2hlbiB0aGUgY29udGVudHMgb2YgdGhlIGl0ZXJhdG9yIGNoYW5nZXMsIGBOZ0ZvcmAgbWFrZXMgdGhlIGNvcnJlc3BvbmRpbmcgY2hhbmdlcyB0byB0aGUgRE9NOlxuICAgICAqXG4gICAgICogKiBXaGVuIGFuIGl0ZW0gaXMgYWRkZWQsIGEgbmV3IGluc3RhbmNlIG9mIHRoZSB0ZW1wbGF0ZSBpcyBhZGRlZCB0byB0aGUgRE9NLlxuICAgICAqICogV2hlbiBhbiBpdGVtIGlzIHJlbW92ZWQsIGl0cyB0ZW1wbGF0ZSBpbnN0YW5jZSBpcyByZW1vdmVkIGZyb20gdGhlIERPTS5cbiAgICAgKiAqIFdoZW4gaXRlbXMgYXJlIHJlb3JkZXJlZCwgdGhlaXIgcmVzcGVjdGl2ZSB0ZW1wbGF0ZXMgYXJlIHJlb3JkZXJlZCBpbiB0aGUgRE9NLlxuICAgICAqICogT3RoZXJ3aXNlLCB0aGUgRE9NIGVsZW1lbnQgZm9yIHRoYXQgaXRlbSB3aWxsIHJlbWFpbiB0aGUgc2FtZS5cbiAgICAgKlxuICAgICAqIEFuZ3VsYXIgdXNlcyBvYmplY3QgaWRlbnRpdHkgdG8gdHJhY2sgaW5zZXJ0aW9ucyBhbmQgZGVsZXRpb25zIHdpdGhpbiB0aGUgaXRlcmF0b3IgYW5kIHJlcHJvZHVjZVxuICAgICAqIHRob3NlIGNoYW5nZXMgaW4gdGhlIERPTS4gVGhpcyBoYXMgaW1wb3J0YW50IGltcGxpY2F0aW9ucyBmb3IgYW5pbWF0aW9ucyBhbmQgYW55IHN0YXRlZnVsXG4gICAgICogY29udHJvbHNcbiAgICAgKiAoc3VjaCBhcyBgPGlucHV0PmAgZWxlbWVudHMgd2hpY2ggYWNjZXB0IHVzZXIgaW5wdXQpIHRoYXQgYXJlIHByZXNlbnQuIEluc2VydGVkIHJvd3MgY2FuIGJlXG4gICAgICogYW5pbWF0ZWQgaW4sIGRlbGV0ZWQgcm93cyBjYW4gYmUgYW5pbWF0ZWQgb3V0LCBhbmQgdW5jaGFuZ2VkIHJvd3MgcmV0YWluIGFueSB1bnNhdmVkIHN0YXRlIHN1Y2hcbiAgICAgKiBhcyB1c2VyIGlucHV0LlxuICAgICAqXG4gICAgICogSXQgaXMgcG9zc2libGUgZm9yIHRoZSBpZGVudGl0aWVzIG9mIGVsZW1lbnRzIGluIHRoZSBpdGVyYXRvciB0byBjaGFuZ2Ugd2hpbGUgdGhlIGRhdGEgZG9lcyBub3QuXG4gICAgICogVGhpcyBjYW4gaGFwcGVuLCBmb3IgZXhhbXBsZSwgaWYgdGhlIGl0ZXJhdG9yIHByb2R1Y2VkIGZyb20gYW4gUlBDIHRvIHRoZSBzZXJ2ZXIsIGFuZCB0aGF0XG4gICAgICogUlBDIGlzIHJlLXJ1bi4gRXZlbiBpZiB0aGUgZGF0YSBoYXNuJ3QgY2hhbmdlZCwgdGhlIHNlY29uZCByZXNwb25zZSB3aWxsIHByb2R1Y2Ugb2JqZWN0cyB3aXRoXG4gICAgICogZGlmZmVyZW50IGlkZW50aXRpZXMsIGFuZCBBbmd1bGFyIHdpbGwgdGVhciBkb3duIHRoZSBlbnRpcmUgRE9NIGFuZCByZWJ1aWxkIGl0IChhcyBpZiBhbGwgb2xkXG4gICAgICogZWxlbWVudHMgd2VyZSBkZWxldGVkIGFuZCBhbGwgbmV3IGVsZW1lbnRzIGluc2VydGVkKS4gVGhpcyBpcyBhbiBleHBlbnNpdmUgb3BlcmF0aW9uIGFuZCBzaG91bGRcbiAgICAgKiBiZSBhdm9pZGVkIGlmIHBvc3NpYmxlLlxuICAgICAqXG4gICAgICogVG8gY3VzdG9taXplIHRoZSBkZWZhdWx0IHRyYWNraW5nIGFsZ29yaXRobSwgYE5nRm9yYCBzdXBwb3J0cyBgdHJhY2tCeWAgb3B0aW9uLlxuICAgICAqIGB0cmFja0J5YCB0YWtlcyBhIGZ1bmN0aW9uIHdoaWNoIGhhcyB0d28gYXJndW1lbnRzOiBgaW5kZXhgIGFuZCBgaXRlbWAuXG4gICAgICogSWYgYHRyYWNrQnlgIGlzIGdpdmVuLCBBbmd1bGFyIHRyYWNrcyBjaGFuZ2VzIGJ5IHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogIyMjIFN5bnRheFxuICAgICAqXG4gICAgICogLSBgPGxpICpuZ0Zvcj1cImxldCBpdGVtIG9mIGl0ZW1zOyBsZXQgaSA9IGluZGV4OyB0cmFja0J5OiB0cmFja0J5Rm5cIj4uLi48L2xpPmBcbiAgICAgKiAtIGA8bGkgdGVtcGxhdGU9XCJuZ0ZvciBsZXQgaXRlbSBvZiBpdGVtczsgbGV0IGkgPSBpbmRleDsgdHJhY2tCeTogdHJhY2tCeUZuXCI+Li4uPC9saT5gXG4gICAgICpcbiAgICAgKiBXaXRoIGA8dGVtcGxhdGU+YCBlbGVtZW50OlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogPHRlbXBsYXRlIG5nRm9yIGxldC1pdGVtIFtuZ0Zvck9mXT1cIml0ZW1zXCIgbGV0LWk9XCJpbmRleFwiIFtuZ0ZvclRyYWNrQnldPVwidHJhY2tCeUZuXCI+XG4gICAgICogICA8bGk+Li4uPC9saT5cbiAgICAgKiA8L3RlbXBsYXRlPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGVcbiAgICAgKlxuICAgICAqIFNlZSBhIFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L0tWdVh4RHAwcWluR0R5bzMwN1FXP3A9cHJldmlldykgZm9yIGEgbW9yZSBkZXRhaWxlZFxuICAgICAqIGV4YW1wbGUuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIE5nRm9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTmdGb3IoX3ZpZXdDb250YWluZXIsIF90ZW1wbGF0ZSwgX2RpZmZlcnMsIF9jZHIpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZpZXdDb250YWluZXIgPSBfdmlld0NvbnRhaW5lcjtcbiAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRlID0gX3RlbXBsYXRlO1xuICAgICAgICAgICAgdGhpcy5fZGlmZmVycyA9IF9kaWZmZXJzO1xuICAgICAgICAgICAgdGhpcy5fY2RyID0gX2NkcjtcbiAgICAgICAgICAgIHRoaXMuX2RpZmZlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nRm9yLnByb3RvdHlwZSwgXCJuZ0ZvclRlbXBsYXRlXCIsIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE5nRm9yLnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgICAgICBpZiAoJ25nRm9yT2YnIGluIGNoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICAvLyBSZWFjdCBvbiBuZ0Zvck9mIGNoYW5nZXMgb25seSBvbmNlIGFsbCBpbnB1dHMgaGF2ZSBiZWVuIGluaXRpYWxpemVkXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gY2hhbmdlc1snbmdGb3JPZiddLmN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2RpZmZlciAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlmZmVyID0gdGhpcy5fZGlmZmVycy5maW5kKHZhbHVlKS5jcmVhdGUodGhpcy5fY2RyLCB0aGlzLm5nRm9yVHJhY2tCeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIGEgZGlmZmVyIHN1cHBvcnRpbmcgb2JqZWN0ICdcIiArIHZhbHVlICsgXCInIG9mIHR5cGUgJ1wiICsgZ2V0VHlwZU5hbWVGb3JEZWJ1Z2dpbmcodmFsdWUpICsgXCInLiBOZ0ZvciBvbmx5IHN1cHBvcnRzIGJpbmRpbmcgdG8gSXRlcmFibGVzIHN1Y2ggYXMgQXJyYXlzLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgTmdGb3IucHJvdG90eXBlLm5nRG9DaGVjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kaWZmZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hhbmdlcyA9IHRoaXMuX2RpZmZlci5kaWZmKHRoaXMubmdGb3JPZik7XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZXMpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FwcGx5Q2hhbmdlcyhjaGFuZ2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgTmdGb3IucHJvdG90eXBlLl9hcHBseUNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBpbnNlcnRUdXBsZXMgPSBbXTtcbiAgICAgICAgICAgIGNoYW5nZXMuZm9yRWFjaE9wZXJhdGlvbihmdW5jdGlvbiAoaXRlbSwgYWRqdXN0ZWRQcmV2aW91c0luZGV4LCBjdXJyZW50SW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5wcmV2aW91c0luZGV4ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZpZXcgPSBfdGhpcy5fdmlld0NvbnRhaW5lci5jcmVhdGVFbWJlZGRlZFZpZXcoX3RoaXMuX3RlbXBsYXRlLCBuZXcgTmdGb3JSb3cobnVsbCwgbnVsbCwgbnVsbCksIGN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0dXBsZSA9IG5ldyBSZWNvcmRWaWV3VHVwbGUoaXRlbSwgdmlldyk7XG4gICAgICAgICAgICAgICAgICAgIGluc2VydFR1cGxlcy5wdXNoKHR1cGxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudEluZGV4ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3ZpZXdDb250YWluZXIucmVtb3ZlKGFkanVzdGVkUHJldmlvdXNJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmlldyA9IF90aGlzLl92aWV3Q29udGFpbmVyLmdldChhZGp1c3RlZFByZXZpb3VzSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fdmlld0NvbnRhaW5lci5tb3ZlKHZpZXcsIGN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0dXBsZSA9IG5ldyBSZWNvcmRWaWV3VHVwbGUoaXRlbSwgdmlldyk7XG4gICAgICAgICAgICAgICAgICAgIGluc2VydFR1cGxlcy5wdXNoKHR1cGxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5zZXJ0VHVwbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGVyVmlld0NoYW5nZShpbnNlcnRUdXBsZXNbaV0udmlldywgaW5zZXJ0VHVwbGVzW2ldLnJlY29yZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWxlbiA9IHRoaXMuX3ZpZXdDb250YWluZXIubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZpZXdSZWYgPSB0aGlzLl92aWV3Q29udGFpbmVyLmdldChpKTtcbiAgICAgICAgICAgICAgICB2aWV3UmVmLmNvbnRleHQuaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIHZpZXdSZWYuY29udGV4dC5jb3VudCA9IGlsZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGFuZ2VzLmZvckVhY2hJZGVudGl0eUNoYW5nZShmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZpZXdSZWYgPSBfdGhpcy5fdmlld0NvbnRhaW5lci5nZXQocmVjb3JkLmN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICAgICAgdmlld1JlZi5jb250ZXh0LiRpbXBsaWNpdCA9IHJlY29yZC5pdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIE5nRm9yLnByb3RvdHlwZS5fcGVyVmlld0NoYW5nZSA9IGZ1bmN0aW9uICh2aWV3LCByZWNvcmQpIHtcbiAgICAgICAgICAgIHZpZXcuY29udGV4dC4kaW1wbGljaXQgPSByZWNvcmQuaXRlbTtcbiAgICAgICAgfTtcbiAgICAgICAgTmdGb3IuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnW25nRm9yXVtuZ0Zvck9mXScgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBOZ0Zvci5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5WaWV3Q29udGFpbmVyUmVmLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlRlbXBsYXRlUmVmLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkl0ZXJhYmxlRGlmZmVycywgfSxcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5DaGFuZ2VEZXRlY3RvclJlZiwgfSxcbiAgICAgICAgXTtcbiAgICAgICAgTmdGb3IucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICAgICAnbmdGb3JPZic6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQgfSxdLFxuICAgICAgICAgICAgJ25nRm9yVHJhY2tCeSc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQgfSxdLFxuICAgICAgICAgICAgJ25nRm9yVGVtcGxhdGUnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0IH0sXSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE5nRm9yO1xuICAgIH0oKSk7XG4gICAgdmFyIFJlY29yZFZpZXdUdXBsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFJlY29yZFZpZXdUdXBsZShyZWNvcmQsIHZpZXcpIHtcbiAgICAgICAgICAgIHRoaXMucmVjb3JkID0gcmVjb3JkO1xuICAgICAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUmVjb3JkVmlld1R1cGxlO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIG9yIHJlY3JlYXRlcyBhIHBvcnRpb24gb2YgdGhlIERPTSB0cmVlIGJhc2VkIG9uIGFuIHtleHByZXNzaW9ufS5cbiAgICAgKlxuICAgICAqIElmIHRoZSBleHByZXNzaW9uIGFzc2lnbmVkIHRvIGBuZ0lmYCBldmFsdWF0ZXMgdG8gYSBmYWxzeSB2YWx1ZSB0aGVuIHRoZSBlbGVtZW50XG4gICAgICogaXMgcmVtb3ZlZCBmcm9tIHRoZSBET00sIG90aGVyd2lzZSBhIGNsb25lIG9mIHRoZSBlbGVtZW50IGlzIHJlaW5zZXJ0ZWQgaW50byB0aGUgRE9NLlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L2ZlMGtnZW1GQnRtUU9ZMzFiNHR3P3A9cHJldmlldykpOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogPGRpdiAqbmdJZj1cImVycm9yQ291bnQgPiAwXCIgY2xhc3M9XCJlcnJvclwiPlxuICAgICAqICAgPCEtLSBFcnJvciBtZXNzYWdlIGRpc3BsYXllZCB3aGVuIHRoZSBlcnJvckNvdW50IHByb3BlcnR5IGluIHRoZSBjdXJyZW50IGNvbnRleHQgaXMgZ3JlYXRlclxuICAgICAqIHRoYW4gMC4gLS0+XG4gICAgICogICB7e2Vycm9yQ291bnR9fSBlcnJvcnMgZGV0ZWN0ZWRcbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqICMjIyBTeW50YXhcbiAgICAgKlxuICAgICAqIC0gYDxkaXYgKm5nSWY9XCJjb25kaXRpb25cIj4uLi48L2Rpdj5gXG4gICAgICogLSBgPGRpdiB0ZW1wbGF0ZT1cIm5nSWYgY29uZGl0aW9uXCI+Li4uPC9kaXY+YFxuICAgICAqIC0gYDx0ZW1wbGF0ZSBbbmdJZl09XCJjb25kaXRpb25cIj48ZGl2Pi4uLjwvZGl2PjwvdGVtcGxhdGU+YFxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBOZ0lmID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTmdJZihfdmlld0NvbnRhaW5lciwgX3RlbXBsYXRlKSB7XG4gICAgICAgICAgICB0aGlzLl92aWV3Q29udGFpbmVyID0gX3ZpZXdDb250YWluZXI7XG4gICAgICAgICAgICB0aGlzLl90ZW1wbGF0ZSA9IF90ZW1wbGF0ZTtcbiAgICAgICAgICAgIHRoaXMuX2hhc1ZpZXcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdJZi5wcm90b3R5cGUsIFwibmdJZlwiLCB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChjb25kaXRpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoY29uZGl0aW9uICYmICF0aGlzLl9oYXNWaWV3KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhc1ZpZXcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl92aWV3Q29udGFpbmVyLmNyZWF0ZUVtYmVkZGVkVmlldyh0aGlzLl90ZW1wbGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFjb25kaXRpb24gJiYgdGhpcy5faGFzVmlldykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYXNWaWV3ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZpZXdDb250YWluZXIuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgTmdJZi5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICdbbmdJZl0nIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgTmdJZi5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5WaWV3Q29udGFpbmVyUmVmLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlRlbXBsYXRlUmVmLCB9LFxuICAgICAgICBdO1xuICAgICAgICBOZ0lmLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAgICAgJ25nSWYnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0IH0sXSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE5nSWY7XG4gICAgfSgpKTtcblxuICAgIHZhciBfQ0FTRV9ERUZBVUxUID0ge307XG4gICAgdmFyIFN3aXRjaFZpZXcgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBTd2l0Y2hWaWV3KF92aWV3Q29udGFpbmVyUmVmLCBfdGVtcGxhdGVSZWYpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZpZXdDb250YWluZXJSZWYgPSBfdmlld0NvbnRhaW5lclJlZjtcbiAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRlUmVmID0gX3RlbXBsYXRlUmVmO1xuICAgICAgICB9XG4gICAgICAgIFN3aXRjaFZpZXcucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fdmlld0NvbnRhaW5lclJlZi5jcmVhdGVFbWJlZGRlZFZpZXcodGhpcy5fdGVtcGxhdGVSZWYpOyB9O1xuICAgICAgICBTd2l0Y2hWaWV3LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkgeyB0aGlzLl92aWV3Q29udGFpbmVyUmVmLmNsZWFyKCk7IH07XG4gICAgICAgIHJldHVybiBTd2l0Y2hWaWV3O1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogQG5nTW9kdWxlIENvbW1vbk1vZHVsZVxuICAgICAqXG4gICAgICogQHdoYXRJdERvZXMgQWRkcyAvIHJlbW92ZXMgRE9NIHN1Yi10cmVlcyB3aGVuIHRoZSBuZXN0IG1hdGNoIGV4cHJlc3Npb25zIG1hdGNoZXMgdGhlIHN3aXRjaFxuICAgICAqICAgICAgICAgICAgIGV4cHJlc3Npb24uXG4gICAgICpcbiAgICAgKiBAaG93VG9Vc2VcbiAgICAgKiBgYGBcbiAgICAgKiAgICAgPGNvbnRhaW5lci1lbGVtZW50IFtuZ1N3aXRjaF09XCJzd2l0Y2hfZXhwcmVzc2lvblwiPlxuICAgICAqICAgICAgIDxzb21lLWVsZW1lbnQgKm5nU3dpdGNoQ2FzZT1cIm1hdGNoX2V4cHJlc3Npb25fMVwiPi4uLjwvc29tZS1lbGVtZW50PlxuICAgICAqICAgICAgIDxzb21lLWVsZW1lbnQgKm5nU3dpdGNoQ2FzZT1cIm1hdGNoX2V4cHJlc3Npb25fMlwiPi4uLjwvc29tZS1lbGVtZW50PlxuICAgICAqICAgICAgIDxzb21lLW90aGVyLWVsZW1lbnQgKm5nU3dpdGNoQ2FzZT1cIm1hdGNoX2V4cHJlc3Npb25fM1wiPi4uLjwvc29tZS1vdGhlci1lbGVtZW50PlxuICAgICAqICAgICAgIDxuZy1jb250YWluZXIgKm5nU3dpdGNoQ2FzZT1cIm1hdGNoX2V4cHJlc3Npb25fM1wiPlxuICAgICAqICAgICAgICAgPCEtLSB1c2UgYSBuZy1jb250YWluZXIgdG8gZ3JvdXAgbXVsdGlwbGUgcm9vdCBub2RlcyAtLT5cbiAgICAgKiAgICAgICAgIDxpbm5lci1lbGVtZW50PjwvaW5uZXItZWxlbWVudD5cbiAgICAgKiAgICAgICAgIDxpbm5lci1vdGhlci1lbGVtZW50PjwvaW5uZXItb3RoZXItZWxlbWVudD5cbiAgICAgKiAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgKiAgICAgICA8c29tZS1lbGVtZW50ICpuZ1N3aXRjaERlZmF1bHQ+Li4uPC9zb21lLWVsZW1lbnQ+XG4gICAgICogICAgIDwvY29udGFpbmVyLWVsZW1lbnQ+XG4gICAgICogYGBgXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBgTmdTd2l0Y2hgIHN0YW1wcyBvdXQgbmVzdGVkIHZpZXdzIHdoZW4gdGhlaXIgbWF0Y2ggZXhwcmVzc2lvbiB2YWx1ZSBtYXRjaGVzIHRoZSB2YWx1ZSBvZiB0aGVcbiAgICAgKiBzd2l0Y2ggZXhwcmVzc2lvbi5cbiAgICAgKlxuICAgICAqIEluIG90aGVyIHdvcmRzOlxuICAgICAqIC0geW91IGRlZmluZSBhIGNvbnRhaW5lciBlbGVtZW50ICh3aGVyZSB5b3UgcGxhY2UgdGhlIGRpcmVjdGl2ZSB3aXRoIGEgc3dpdGNoIGV4cHJlc3Npb24gb24gdGhlXG4gICAgICogYFtuZ1N3aXRjaF09XCIuLi5cImAgYXR0cmlidXRlKVxuICAgICAqIC0geW91IGRlZmluZSBpbm5lciB2aWV3cyBpbnNpZGUgdGhlIGBOZ1N3aXRjaGAgYW5kIHBsYWNlIGEgYCpuZ1N3aXRjaENhc2VgIGF0dHJpYnV0ZSBvbiB0aGUgdmlld1xuICAgICAqIHJvb3QgZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBFbGVtZW50cyB3aXRoaW4gYE5nU3dpdGNoYCBidXQgb3V0c2lkZSBvZiBhIGBOZ1N3aXRjaENhc2VgIG9yIGBOZ1N3aXRjaERlZmF1bHRgIGRpcmVjdGl2ZXMgd2lsbFxuICAgICAqIGJlIHByZXNlcnZlZCBhdCB0aGUgbG9jYXRpb24uXG4gICAgICpcbiAgICAgKiBUaGUgYG5nU3dpdGNoQ2FzZWAgZGlyZWN0aXZlIGluZm9ybXMgdGhlIHBhcmVudCBgTmdTd2l0Y2hgIG9mIHdoaWNoIHZpZXcgdG8gZGlzcGxheSB3aGVuIHRoZVxuICAgICAqIGV4cHJlc3Npb24gaXMgZXZhbHVhdGVkLlxuICAgICAqIFdoZW4gbm8gbWF0Y2hpbmcgZXhwcmVzc2lvbiBpcyBmb3VuZCBvbiBhIGBuZ1N3aXRjaENhc2VgIHZpZXcsIHRoZSBgbmdTd2l0Y2hEZWZhdWx0YCB2aWV3IGlzXG4gICAgICogc3RhbXBlZCBvdXQuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIE5nU3dpdGNoID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTmdTd2l0Y2goKSB7XG4gICAgICAgICAgICB0aGlzLl91c2VEZWZhdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZVZpZXdzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgdGhpcy5fYWN0aXZlVmlld3MgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdTd2l0Y2gucHJvdG90eXBlLCBcIm5nU3dpdGNoXCIsIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8gU2V0IG9mIHZpZXdzIHRvIGRpc3BsYXkgZm9yIHRoaXMgdmFsdWVcbiAgICAgICAgICAgICAgICB2YXIgdmlld3MgPSB0aGlzLl92YWx1ZVZpZXdzLmdldCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHZpZXdzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3VzZURlZmF1bHQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vIHZpZXcgdG8gZGlzcGxheSBmb3IgdGhlIGN1cnJlbnQgdmFsdWUgLT4gZGVmYXVsdCBjYXNlXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdGhpbmcgdG8gZG8gaWYgdGhlIGRlZmF1bHQgY2FzZSB3YXMgYWxyZWFkeSBhY3RpdmVcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3VzZURlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl91c2VEZWZhdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmlld3MgPSB0aGlzLl92YWx1ZVZpZXdzLmdldChfQ0FTRV9ERUZBVUxUKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fZW1wdHlBbGxBY3RpdmVWaWV3cygpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2YXRlVmlld3Modmlld3MpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N3aXRjaFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBOZ1N3aXRjaC5wcm90b3R5cGUuX29uQ2FzZVZhbHVlQ2hhbmdlZCA9IGZ1bmN0aW9uIChvbGRDYXNlLCBuZXdDYXNlLCB2aWV3KSB7XG4gICAgICAgICAgICB0aGlzLl9kZXJlZ2lzdGVyVmlldyhvbGRDYXNlLCB2aWV3KTtcbiAgICAgICAgICAgIHRoaXMuX3JlZ2lzdGVyVmlldyhuZXdDYXNlLCB2aWV3KTtcbiAgICAgICAgICAgIGlmIChvbGRDYXNlID09PSB0aGlzLl9zd2l0Y2hWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHZpZXcuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIExpc3RXcmFwcGVyLnJlbW92ZSh0aGlzLl9hY3RpdmVWaWV3cywgdmlldyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuZXdDYXNlID09PSB0aGlzLl9zd2l0Y2hWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl91c2VEZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3VzZURlZmF1bHQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW1wdHlBbGxBY3RpdmVWaWV3cygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2aWV3LmNyZWF0ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZVZpZXdzLnB1c2godmlldyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTd2l0Y2ggdG8gZGVmYXVsdCB3aGVuIHRoZXJlIGlzIG5vIG1vcmUgYWN0aXZlIFZpZXdDb250YWluZXJzXG4gICAgICAgICAgICBpZiAodGhpcy5fYWN0aXZlVmlld3MubGVuZ3RoID09PSAwICYmICF0aGlzLl91c2VEZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXNlRGVmYXVsdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZhdGVWaWV3cyh0aGlzLl92YWx1ZVZpZXdzLmdldChfQ0FTRV9ERUZBVUxUKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE5nU3dpdGNoLnByb3RvdHlwZS5fZW1wdHlBbGxBY3RpdmVWaWV3cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhY3RpdmVDb250YWluZXJzID0gdGhpcy5fYWN0aXZlVmlld3M7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFjdGl2ZUNvbnRhaW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhY3RpdmVDb250YWluZXJzW2ldLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2FjdGl2ZVZpZXdzID0gW107XG4gICAgICAgIH07XG4gICAgICAgIE5nU3dpdGNoLnByb3RvdHlwZS5fYWN0aXZhdGVWaWV3cyA9IGZ1bmN0aW9uICh2aWV3cykge1xuICAgICAgICAgICAgaWYgKHZpZXdzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2aWV3c1tpXS5jcmVhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZlVmlld3MgPSB2aWV3cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBOZ1N3aXRjaC5wcm90b3R5cGUuX3JlZ2lzdGVyVmlldyA9IGZ1bmN0aW9uICh2YWx1ZSwgdmlldykge1xuICAgICAgICAgICAgdmFyIHZpZXdzID0gdGhpcy5fdmFsdWVWaWV3cy5nZXQodmFsdWUpO1xuICAgICAgICAgICAgaWYgKCF2aWV3cykge1xuICAgICAgICAgICAgICAgIHZpZXdzID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVWaWV3cy5zZXQodmFsdWUsIHZpZXdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZpZXdzLnB1c2godmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIE5nU3dpdGNoLnByb3RvdHlwZS5fZGVyZWdpc3RlclZpZXcgPSBmdW5jdGlvbiAodmFsdWUsIHZpZXcpIHtcbiAgICAgICAgICAgIC8vIGBfQ0FTRV9ERUZBVUxUYCBpcyB1c2VkIGEgbWFya2VyIGZvciBub24tcmVnaXN0ZXJlZCBjYXNlc1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBfQ0FTRV9ERUZBVUxUKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciB2aWV3cyA9IHRoaXMuX3ZhbHVlVmlld3MuZ2V0KHZhbHVlKTtcbiAgICAgICAgICAgIGlmICh2aWV3cy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlVmlld3MuZGVsZXRlKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIExpc3RXcmFwcGVyLnJlbW92ZSh2aWV3cywgdmlldyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE5nU3dpdGNoLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbeyBzZWxlY3RvcjogJ1tuZ1N3aXRjaF0nIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgTmdTd2l0Y2guY3RvclBhcmFtZXRlcnMgPSBbXTtcbiAgICAgICAgTmdTd2l0Y2gucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICAgICAnbmdTd2l0Y2gnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0IH0sXSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE5nU3dpdGNoO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogQG5nTW9kdWxlIENvbW1vbk1vZHVsZVxuICAgICAqXG4gICAgICogQHdoYXRJdERvZXMgQ3JlYXRlcyBhIHZpZXcgdGhhdCB3aWxsIGJlIGFkZGVkL3JlbW92ZWQgZnJvbSB0aGUgcGFyZW50IHtAbGluayBOZ1N3aXRjaH0gd2hlbiB0aGVcbiAgICAgKiAgICAgICAgICAgICBnaXZlbiBleHByZXNzaW9uIGV2YWx1YXRlIHRvIHJlc3BlY3RpdmVseSB0aGUgc2FtZS9kaWZmZXJlbnQgdmFsdWUgYXMgdGhlIHN3aXRjaFxuICAgICAqICAgICAgICAgICAgIGV4cHJlc3Npb24uXG4gICAgICpcbiAgICAgKiBAaG93VG9Vc2VcbiAgICAgKiBgYGBcbiAgICAgKiA8Y29udGFpbmVyLWVsZW1lbnQgW25nU3dpdGNoXT1cInN3aXRjaF9leHByZXNzaW9uXCI+XG4gICAgICogICA8c29tZS1lbGVtZW50ICpuZ1N3aXRjaENhc2U9XCJtYXRjaF9leHByZXNzaW9uXzFcIj4uLi48L3NvbWUtZWxlbWVudD5cbiAgICAgKiA8L2NvbnRhaW5lci1lbGVtZW50PlxuICAgICAqYGBgXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBJbnNlcnQgdGhlIHN1Yi10cmVlIHdoZW4gdGhlIGV4cHJlc3Npb24gZXZhbHVhdGVzIHRvIHRoZSBzYW1lIHZhbHVlIGFzIHRoZSBlbmNsb3Npbmcgc3dpdGNoXG4gICAgICogZXhwcmVzc2lvbi5cbiAgICAgKlxuICAgICAqIElmIG11bHRpcGxlIG1hdGNoIGV4cHJlc3Npb25zIG1hdGNoIHRoZSBzd2l0Y2ggZXhwcmVzc2lvbiB2YWx1ZSwgYWxsIG9mIHRoZW0gYXJlIGRpc3BsYXllZC5cbiAgICAgKlxuICAgICAqIFNlZSB7QGxpbmsgTmdTd2l0Y2h9IGZvciBtb3JlIGRldGFpbHMgYW5kIGV4YW1wbGUuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIE5nU3dpdGNoQ2FzZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE5nU3dpdGNoQ2FzZSh2aWV3Q29udGFpbmVyLCB0ZW1wbGF0ZVJlZiwgbmdTd2l0Y2gpIHtcbiAgICAgICAgICAgIC8vIGBfQ0FTRV9ERUZBVUxUYCBpcyB1c2VkIGFzIGEgbWFya2VyIGZvciBhIG5vdCB5ZXQgaW5pdGlhbGl6ZWQgdmFsdWVcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gX0NBU0VfREVGQVVMVDtcbiAgICAgICAgICAgIHRoaXMuX3N3aXRjaCA9IG5nU3dpdGNoO1xuICAgICAgICAgICAgdGhpcy5fdmlldyA9IG5ldyBTd2l0Y2hWaWV3KHZpZXdDb250YWluZXIsIHRlbXBsYXRlUmVmKTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdTd2l0Y2hDYXNlLnByb3RvdHlwZSwgXCJuZ1N3aXRjaENhc2VcIiwge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zd2l0Y2guX29uQ2FzZVZhbHVlQ2hhbmdlZCh0aGlzLl92YWx1ZSwgdmFsdWUsIHRoaXMuX3ZpZXcpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgTmdTd2l0Y2hDYXNlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbeyBzZWxlY3RvcjogJ1tuZ1N3aXRjaENhc2VdJyB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIE5nU3dpdGNoQ2FzZS5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5WaWV3Q29udGFpbmVyUmVmLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlRlbXBsYXRlUmVmLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBOZ1N3aXRjaCwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5Ib3N0IH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICBOZ1N3aXRjaENhc2UucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICAgICAnbmdTd2l0Y2hDYXNlJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCB9LF0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBOZ1N3aXRjaENhc2U7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBAbmdNb2R1bGUgQ29tbW9uTW9kdWxlXG4gICAgICogQHdoYXRJdERvZXMgQ3JlYXRlcyBhIHZpZXcgdGhhdCBpcyBhZGRlZCB0byB0aGUgcGFyZW50IHtAbGluayBOZ1N3aXRjaH0gd2hlbiBubyBjYXNlIGV4cHJlc3Npb25zXG4gICAgICogbWF0Y2ggdGhlXG4gICAgICogICAgICAgICAgICAgc3dpdGNoIGV4cHJlc3Npb24uXG4gICAgICpcbiAgICAgKiBAaG93VG9Vc2VcbiAgICAgKiBgYGBcbiAgICAgKiA8Y29udGFpbmVyLWVsZW1lbnQgW25nU3dpdGNoXT1cInN3aXRjaF9leHByZXNzaW9uXCI+XG4gICAgICogICA8c29tZS1lbGVtZW50ICpuZ1N3aXRjaENhc2U9XCJtYXRjaF9leHByZXNzaW9uXzFcIj4uLi48L3NvbWUtZWxlbWVudD5cbiAgICAgKiAgIDxzb21lLW90aGVyLWVsZW1lbnQgKm5nU3dpdGNoRGVmYXVsdD4uLi48L3NvbWUtb3RoZXItZWxlbWVudD5cbiAgICAgKiA8L2NvbnRhaW5lci1lbGVtZW50PlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBJbnNlcnQgdGhlIHN1Yi10cmVlIHdoZW4gbm8gY2FzZSBleHByZXNzaW9ucyBldmFsdWF0ZSB0byB0aGUgc2FtZSB2YWx1ZSBhcyB0aGUgZW5jbG9zaW5nIHN3aXRjaFxuICAgICAqIGV4cHJlc3Npb24uXG4gICAgICpcbiAgICAgKiBTZWUge0BsaW5rIE5nU3dpdGNofSBmb3IgbW9yZSBkZXRhaWxzIGFuZCBleGFtcGxlLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBOZ1N3aXRjaERlZmF1bHQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBOZ1N3aXRjaERlZmF1bHQodmlld0NvbnRhaW5lciwgdGVtcGxhdGVSZWYsIHNzd2l0Y2gpIHtcbiAgICAgICAgICAgIHNzd2l0Y2guX3JlZ2lzdGVyVmlldyhfQ0FTRV9ERUZBVUxULCBuZXcgU3dpdGNoVmlldyh2aWV3Q29udGFpbmVyLCB0ZW1wbGF0ZVJlZikpO1xuICAgICAgICB9XG4gICAgICAgIE5nU3dpdGNoRGVmYXVsdC5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICdbbmdTd2l0Y2hEZWZhdWx0XScgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBOZ1N3aXRjaERlZmF1bHQuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuVmlld0NvbnRhaW5lclJlZiwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5UZW1wbGF0ZVJlZiwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogTmdTd2l0Y2gsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSG9zdCB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIE5nU3dpdGNoRGVmYXVsdDtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQG5nTW9kdWxlIENvbW1vbk1vZHVsZVxuICAgICAqXG4gICAgICogQHdoYXRJdERvZXMgQWRkcyAvIHJlbW92ZXMgRE9NIHN1Yi10cmVlcyBiYXNlZCBvbiBhIG51bWVyaWMgdmFsdWUuIFRhaWxvcmVkIGZvciBwbHVyYWxpemF0aW9uLlxuICAgICAqXG4gICAgICogQGhvd1RvVXNlXG4gICAgICogYGBgXG4gICAgICogPHNvbWUtZWxlbWVudCBbbmdQbHVyYWxdPVwidmFsdWVcIj5cbiAgICAgKiAgIDxuZy1jb250YWluZXIgKm5nUGx1cmFsQ2FzZT1cIic9MCdcIj50aGVyZSBpcyBub3RoaW5nPC9uZy1jb250YWluZXI+XG4gICAgICogICA8bmctY29udGFpbmVyICpuZ1BsdXJhbENhc2U9XCInPTEnXCI+dGhlcmUgaXMgb25lPC9uZy1jb250YWluZXI+XG4gICAgICogICA8bmctY29udGFpbmVyICpuZ1BsdXJhbENhc2U9XCInZmV3J1wiPnRoZXJlIGFyZSBhIGZldzwvbmctY29udGFpbmVyPlxuICAgICAqICAgPG5nLWNvbnRhaW5lciAqbmdQbHVyYWxDYXNlPVwiJ290aGVyJ1wiPnRoZXJlIGFyZSBleGFjdGx5ICM8L25nLWNvbnRhaW5lcj5cbiAgICAgKiA8L3NvbWUtZWxlbWVudD5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogRGlzcGxheXMgRE9NIHN1Yi10cmVlcyB0aGF0IG1hdGNoIHRoZSBzd2l0Y2ggZXhwcmVzc2lvbiB2YWx1ZSwgb3IgZmFpbGluZyB0aGF0LCBET00gc3ViLXRyZWVzXG4gICAgICogdGhhdCBtYXRjaCB0aGUgc3dpdGNoIGV4cHJlc3Npb24ncyBwbHVyYWxpemF0aW9uIGNhdGVnb3J5LlxuICAgICAqXG4gICAgICogVG8gdXNlIHRoaXMgZGlyZWN0aXZlIHlvdSBtdXN0IHByb3ZpZGUgYSBjb250YWluZXIgZWxlbWVudCB0aGF0IHNldHMgdGhlIGBbbmdQbHVyYWxdYCBhdHRyaWJ1dGVcbiAgICAgKiB0byBhIHN3aXRjaCBleHByZXNzaW9uLiBJbm5lciBlbGVtZW50cyB3aXRoIGEgYFtuZ1BsdXJhbENhc2VdYCB3aWxsIGRpc3BsYXkgYmFzZWQgb24gdGhlaXJcbiAgICAgKiBleHByZXNzaW9uOlxuICAgICAqIC0gaWYgYFtuZ1BsdXJhbENhc2VdYCBpcyBzZXQgdG8gYSB2YWx1ZSBzdGFydGluZyB3aXRoIGA9YCwgaXQgd2lsbCBvbmx5IGRpc3BsYXkgaWYgdGhlIHZhbHVlXG4gICAgICogICBtYXRjaGVzIHRoZSBzd2l0Y2ggZXhwcmVzc2lvbiBleGFjdGx5LFxuICAgICAqIC0gb3RoZXJ3aXNlLCB0aGUgdmlldyB3aWxsIGJlIHRyZWF0ZWQgYXMgYSBcImNhdGVnb3J5IG1hdGNoXCIsIGFuZCB3aWxsIG9ubHkgZGlzcGxheSBpZiBleGFjdFxuICAgICAqICAgdmFsdWUgbWF0Y2hlcyBhcmVuJ3QgZm91bmQgYW5kIHRoZSB2YWx1ZSBtYXBzIHRvIGl0cyBjYXRlZ29yeSBmb3IgdGhlIGRlZmluZWQgbG9jYWxlLlxuICAgICAqXG4gICAgICogU2VlIGh0dHA6Ly9jbGRyLnVuaWNvZGUub3JnL2luZGV4L2NsZHItc3BlYy9wbHVyYWwtcnVsZXNcbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgTmdQbHVyYWwgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBOZ1BsdXJhbChfbG9jYWxpemF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2NhbGl6YXRpb24gPSBfbG9jYWxpemF0aW9uO1xuICAgICAgICAgICAgdGhpcy5fY2FzZVZpZXdzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nUGx1cmFsLnByb3RvdHlwZSwgXCJuZ1BsdXJhbFwiLCB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N3aXRjaFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlVmlldygpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE5nUGx1cmFsLnByb3RvdHlwZS5hZGRDYXNlID0gZnVuY3Rpb24gKHZhbHVlLCBzd2l0Y2hWaWV3KSB7IHRoaXMuX2Nhc2VWaWV3c1t2YWx1ZV0gPSBzd2l0Y2hWaWV3OyB9O1xuICAgICAgICBOZ1BsdXJhbC5wcm90b3R5cGUuX3VwZGF0ZVZpZXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9jbGVhclZpZXdzKCk7XG4gICAgICAgICAgICB2YXIgY2FzZXMgPSBPYmplY3Qua2V5cyh0aGlzLl9jYXNlVmlld3MpO1xuICAgICAgICAgICAgdmFyIGtleSA9IGdldFBsdXJhbENhdGVnb3J5KHRoaXMuX3N3aXRjaFZhbHVlLCBjYXNlcywgdGhpcy5fbG9jYWxpemF0aW9uKTtcbiAgICAgICAgICAgIHRoaXMuX2FjdGl2YXRlVmlldyh0aGlzLl9jYXNlVmlld3Nba2V5XSk7XG4gICAgICAgIH07XG4gICAgICAgIE5nUGx1cmFsLnByb3RvdHlwZS5fY2xlYXJWaWV3cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9hY3RpdmVWaWV3KVxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZVZpZXcuZGVzdHJveSgpO1xuICAgICAgICB9O1xuICAgICAgICBOZ1BsdXJhbC5wcm90b3R5cGUuX2FjdGl2YXRlVmlldyA9IGZ1bmN0aW9uICh2aWV3KSB7XG4gICAgICAgICAgICBpZiAodmlldykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZVZpZXcgPSB2aWV3O1xuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZVZpZXcuY3JlYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE5nUGx1cmFsLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbeyBzZWxlY3RvcjogJ1tuZ1BsdXJhbF0nIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgTmdQbHVyYWwuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IE5nTG9jYWxpemF0aW9uLCB9LFxuICAgICAgICBdO1xuICAgICAgICBOZ1BsdXJhbC5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgICAgICduZ1BsdXJhbCc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQgfSxdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gTmdQbHVyYWw7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBAbmdNb2R1bGUgQ29tbW9uTW9kdWxlXG4gICAgICpcbiAgICAgKiBAd2hhdEl0RG9lcyBDcmVhdGVzIGEgdmlldyB0aGF0IHdpbGwgYmUgYWRkZWQvcmVtb3ZlZCBmcm9tIHRoZSBwYXJlbnQge0BsaW5rIE5nUGx1cmFsfSB3aGVuIHRoZVxuICAgICAqICAgICAgICAgICAgIGdpdmVuIGV4cHJlc3Npb24gbWF0Y2hlcyB0aGUgcGx1cmFsIGV4cHJlc3Npb24gYWNjb3JkaW5nIHRvIENMRFIgcnVsZXMuXG4gICAgICpcbiAgICAgKiBAaG93VG9Vc2VcbiAgICAgKiBgYGBcbiAgICAgKiA8c29tZS1lbGVtZW50IFtuZ1BsdXJhbF09XCJ2YWx1ZVwiPlxuICAgICAqICAgPG5nLWNvbnRhaW5lciAqbmdQbHVyYWxDYXNlPVwiJz0wJ1wiPi4uLjwvbmctY29udGFpbmVyPlxuICAgICAqICAgPG5nLWNvbnRhaW5lciAqbmdQbHVyYWxDYXNlPVwiJ290aGVyJ1wiPi4uLjwvbmctY29udGFpbmVyPlxuICAgICAqIDwvc29tZS1lbGVtZW50PlxuICAgICAqYGBgXG4gICAgICpcbiAgICAgKiBTZWUge0BsaW5rIE5nUGx1cmFsfSBmb3IgbW9yZSBkZXRhaWxzIGFuZCBleGFtcGxlLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBOZ1BsdXJhbENhc2UgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBOZ1BsdXJhbENhc2UodmFsdWUsIHRlbXBsYXRlLCB2aWV3Q29udGFpbmVyLCBuZ1BsdXJhbCkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgbmdQbHVyYWwuYWRkQ2FzZSh2YWx1ZSwgbmV3IFN3aXRjaFZpZXcodmlld0NvbnRhaW5lciwgdGVtcGxhdGUpKTtcbiAgICAgICAgfVxuICAgICAgICBOZ1BsdXJhbENhc2UuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnW25nUGx1cmFsQ2FzZV0nIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgTmdQbHVyYWxDYXNlLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuQXR0cmlidXRlLCBhcmdzOiBbJ25nUGx1cmFsQ2FzZScsXSB9LF0gfSxcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5UZW1wbGF0ZVJlZiwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5WaWV3Q29udGFpbmVyUmVmLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBOZ1BsdXJhbCwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5Ib3N0IH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gTmdQbHVyYWxDYXNlO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbmdNb2R1bGUgQ29tbW9uTW9kdWxlXG4gICAgICpcbiAgICAgKiBAd2hhdEl0RG9lcyBVcGRhdGUgYW4gSFRNTCBlbGVtZW50IHN0eWxlcy5cbiAgICAgKlxuICAgICAqIEBob3dUb1VzZVxuICAgICAqIGBgYFxuICAgICAqIDxzb21lLWVsZW1lbnQgW25nU3R5bGVdPVwieydmb250LXN0eWxlJzogc3R5bGVFeHB9XCI+Li4uPC9zb21lLWVsZW1lbnQ+XG4gICAgICpcbiAgICAgKiA8c29tZS1lbGVtZW50IFtuZ1N0eWxlXT1cInsnbWF4LXdpZHRoLnB4Jzogd2lkdGhFeHB9XCI+Li4uPC9zb21lLWVsZW1lbnQ+XG4gICAgICpcbiAgICAgKiA8c29tZS1lbGVtZW50IFtuZ1N0eWxlXT1cIm9iakV4cFwiPi4uLjwvc29tZS1lbGVtZW50PlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBUaGUgc3R5bGVzIGFyZSB1cGRhdGVkIGFjY29yZGluZyB0byB0aGUgdmFsdWUgb2YgdGhlIGV4cHJlc3Npb24gZXZhbHVhdGlvbjpcbiAgICAgKiAtIGtleXMgYXJlIHN0eWxlIG5hbWVzIHdpdGggYW4gb3B0aW9uIGAuPHVuaXQ+YCBzdWZmaXggKGllICd0b3AucHgnLCAnZm9udC1zdHlsZS5lbScpLFxuICAgICAqIC0gdmFsdWVzIGFyZSB0aGUgdmFsdWVzIGFzc2lnbmVkIHRvIHRob3NlIHByb3BlcnRpZXMgKGV4cHJlc3NlZCBpbiB0aGUgZ2l2ZW4gdW5pdCkuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIE5nU3R5bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBOZ1N0eWxlKF9kaWZmZXJzLCBfbmdFbCwgX3JlbmRlcmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9kaWZmZXJzID0gX2RpZmZlcnM7XG4gICAgICAgICAgICB0aGlzLl9uZ0VsID0gX25nRWw7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdTdHlsZS5wcm90b3R5cGUsIFwibmdTdHlsZVwiLCB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbmdTdHlsZSA9IHY7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9kaWZmZXIgJiYgdikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaWZmZXIgPSB0aGlzLl9kaWZmZXJzLmZpbmQodikuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBOZ1N0eWxlLnByb3RvdHlwZS5uZ0RvQ2hlY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZGlmZmVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoYW5nZXMgPSB0aGlzLl9kaWZmZXIuZGlmZih0aGlzLl9uZ1N0eWxlKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hcHBseUNoYW5nZXMoY2hhbmdlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBOZ1N0eWxlLnByb3RvdHlwZS5fYXBwbHlDaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBjaGFuZ2VzLmZvckVhY2hSZW1vdmVkSXRlbShmdW5jdGlvbiAocmVjb3JkKSB7IHJldHVybiBfdGhpcy5fc2V0U3R5bGUocmVjb3JkLmtleSwgbnVsbCk7IH0pO1xuICAgICAgICAgICAgY2hhbmdlcy5mb3JFYWNoQWRkZWRJdGVtKGZ1bmN0aW9uIChyZWNvcmQpIHsgcmV0dXJuIF90aGlzLl9zZXRTdHlsZShyZWNvcmQua2V5LCByZWNvcmQuY3VycmVudFZhbHVlKTsgfSk7XG4gICAgICAgICAgICBjaGFuZ2VzLmZvckVhY2hDaGFuZ2VkSXRlbShmdW5jdGlvbiAocmVjb3JkKSB7IHJldHVybiBfdGhpcy5fc2V0U3R5bGUocmVjb3JkLmtleSwgcmVjb3JkLmN1cnJlbnRWYWx1ZSk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICBOZ1N0eWxlLnByb3RvdHlwZS5fc2V0U3R5bGUgPSBmdW5jdGlvbiAobmFtZUFuZFVuaXQsIHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBuYW1lQW5kVW5pdC5zcGxpdCgnLicpLCBuYW1lID0gX2FbMF0sIHVuaXQgPSBfYVsxXTtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgJiYgdW5pdCA/IFwiXCIgKyB2YWx1ZSArIHVuaXQgOiB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEVsZW1lbnRTdHlsZSh0aGlzLl9uZ0VsLm5hdGl2ZUVsZW1lbnQsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgTmdTdHlsZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICdbbmdTdHlsZV0nIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgTmdTdHlsZS5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5LZXlWYWx1ZURpZmZlcnMsIH0sXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRWxlbWVudFJlZiwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5SZW5kZXJlciwgfSxcbiAgICAgICAgXTtcbiAgICAgICAgTmdTdHlsZS5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgICAgICduZ1N0eWxlJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCB9LF0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBOZ1N0eWxlO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbmdNb2R1bGUgQ29tbW9uTW9kdWxlXG4gICAgICpcbiAgICAgKiBAd2hhdEl0RG9lcyBJbnNlcnRzIGFuIGVtYmVkZGVkIHZpZXcgZnJvbSBhIHByZXBhcmVkIGBUZW1wbGF0ZVJlZmBcbiAgICAgKlxuICAgICAqIEBob3dUb1VzZVxuICAgICAqIGBgYFxuICAgICAqIDx0ZW1wbGF0ZSBbbmdUZW1wbGF0ZU91dGxldF09XCJ0ZW1wbGF0ZVJlZkV4cHJlc3Npb25cIlxuICAgICAqICAgICAgICAgICBbbmdPdXRsZXRDb250ZXh0XT1cIm9iamVjdEV4cHJlc3Npb25cIj5cbiAgICAgKiA8L3RlbXBsYXRlPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIGF0dGFjaCBhIGNvbnRleHQgb2JqZWN0IHRvIHRoZSBgRW1iZWRkZWRWaWV3UmVmYCBieSBzZXR0aW5nIGBbbmdPdXRsZXRDb250ZXh0XWAuXG4gICAgICogYFtuZ091dGxldENvbnRleHRdYCBzaG91bGQgYmUgYW4gb2JqZWN0LCB0aGUgb2JqZWN0J3Mga2V5cyB3aWxsIGJlIHRoZSBsb2NhbCB0ZW1wbGF0ZSB2YXJpYWJsZXNcbiAgICAgKiBhdmFpbGFibGUgd2l0aGluIHRoZSBgVGVtcGxhdGVSZWZgLlxuICAgICAqXG4gICAgICogTm90ZTogdXNpbmcgdGhlIGtleSBgJGltcGxpY2l0YCBpbiB0aGUgY29udGV4dCBvYmplY3Qgd2lsbCBzZXQgaXQncyB2YWx1ZSBhcyBkZWZhdWx0LlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBOZ1RlbXBsYXRlT3V0bGV0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTmdUZW1wbGF0ZU91dGxldChfdmlld0NvbnRhaW5lclJlZikge1xuICAgICAgICAgICAgdGhpcy5fdmlld0NvbnRhaW5lclJlZiA9IF92aWV3Q29udGFpbmVyUmVmO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ1RlbXBsYXRlT3V0bGV0LnByb3RvdHlwZSwgXCJuZ091dGxldENvbnRleHRcIiwge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoY29udGV4dCkgeyB0aGlzLl9jb250ZXh0ID0gY29udGV4dDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ1RlbXBsYXRlT3V0bGV0LnByb3RvdHlwZSwgXCJuZ1RlbXBsYXRlT3V0bGV0XCIsIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHRlbXBsYXRlUmVmKSB7IHRoaXMuX3RlbXBsYXRlUmVmID0gdGVtcGxhdGVSZWY7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBOZ1RlbXBsYXRlT3V0bGV0LnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fdmlld1JlZikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZpZXdDb250YWluZXJSZWYucmVtb3ZlKHRoaXMuX3ZpZXdDb250YWluZXJSZWYuaW5kZXhPZih0aGlzLl92aWV3UmVmKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fdGVtcGxhdGVSZWYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl92aWV3UmVmID0gdGhpcy5fdmlld0NvbnRhaW5lclJlZi5jcmVhdGVFbWJlZGRlZFZpZXcodGhpcy5fdGVtcGxhdGVSZWYsIHRoaXMuX2NvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBOZ1RlbXBsYXRlT3V0bGV0LmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbeyBzZWxlY3RvcjogJ1tuZ1RlbXBsYXRlT3V0bGV0XScgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBOZ1RlbXBsYXRlT3V0bGV0LmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlZpZXdDb250YWluZXJSZWYsIH0sXG4gICAgICAgIF07XG4gICAgICAgIE5nVGVtcGxhdGVPdXRsZXQucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICAgICAnbmdPdXRsZXRDb250ZXh0JzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCB9LF0sXG4gICAgICAgICAgICAnbmdUZW1wbGF0ZU91dGxldCc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQgfSxdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gTmdUZW1wbGF0ZU91dGxldDtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQSBjb2xsZWN0aW9uIG9mIEFuZ3VsYXIgZGlyZWN0aXZlcyB0aGF0IGFyZSBsaWtlbHkgdG8gYmUgdXNlZCBpbiBlYWNoIGFuZCBldmVyeSBBbmd1bGFyXG4gICAgICogYXBwbGljYXRpb24uXG4gICAgICovXG4gICAgdmFyIENPTU1PTl9ESVJFQ1RJVkVTID0gW1xuICAgICAgICBOZ0NsYXNzLFxuICAgICAgICBOZ0ZvcixcbiAgICAgICAgTmdJZixcbiAgICAgICAgTmdUZW1wbGF0ZU91dGxldCxcbiAgICAgICAgTmdTdHlsZSxcbiAgICAgICAgTmdTd2l0Y2gsXG4gICAgICAgIE5nU3dpdGNoQ2FzZSxcbiAgICAgICAgTmdTd2l0Y2hEZWZhdWx0LFxuICAgICAgICBOZ1BsdXJhbCxcbiAgICAgICAgTmdQbHVyYWxDYXNlLFxuICAgIF07XG5cbiAgICB2YXIgaXNQcm9taXNlID0gX2FuZ3VsYXJfY29yZS5fX2NvcmVfcHJpdmF0ZV9fLmlzUHJvbWlzZTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDQgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEJhc2VFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQ0KEJhc2VFcnJvciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gQmFzZUVycm9yKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIC8vIEVycm9ycyBkb24ndCB1c2UgY3VycmVudCB0aGlzLCBpbnN0ZWFkIHRoZXkgY3JlYXRlIGEgbmV3IGluc3RhbmNlLlxuICAgICAgICAgICAgLy8gV2UgaGF2ZSB0byBkbyBmb3J3YXJkIGFsbCBvZiBvdXIgYXBpIHRvIHRoZSBuYXRpdmVJbnN0YW5jZS5cbiAgICAgICAgICAgIHZhciBuYXRpdmVFcnJvciA9IF9zdXBlci5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgdGhpcy5fbmF0aXZlRXJyb3IgPSBuYXRpdmVFcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZUVycm9yLnByb3RvdHlwZSwgXCJtZXNzYWdlXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbmF0aXZlRXJyb3IubWVzc2FnZTsgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKG1lc3NhZ2UpIHsgdGhpcy5fbmF0aXZlRXJyb3IubWVzc2FnZSA9IG1lc3NhZ2U7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZUVycm9yLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbmF0aXZlRXJyb3IubmFtZTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNlRXJyb3IucHJvdG90eXBlLCBcInN0YWNrXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbmF0aXZlRXJyb3Iuc3RhY2s7IH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyB0aGlzLl9uYXRpdmVFcnJvci5zdGFjayA9IHZhbHVlOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgQmFzZUVycm9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX25hdGl2ZUVycm9yLnRvU3RyaW5nKCk7IH07XG4gICAgICAgIHJldHVybiBCYXNlRXJyb3I7XG4gICAgfShFcnJvcikpO1xuICAgIC8qKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgV3JhcHBlZEVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDQoV3JhcHBlZEVycm9yLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBXcmFwcGVkRXJyb3IobWVzc2FnZSwgZXJyb3IpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIG1lc3NhZ2UgKyBcIiBjYXVzZWQgYnk6IFwiICsgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogZXJyb3IpKTtcbiAgICAgICAgICAgIHRoaXMub3JpZ2luYWxFcnJvciA9IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcmFwcGVkRXJyb3IucHJvdG90eXBlLCBcInN0YWNrXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5vcmlnaW5hbEVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyB0aGlzLm9yaWdpbmFsRXJyb3IgOiB0aGlzLl9uYXRpdmVFcnJvcilcbiAgICAgICAgICAgICAgICAgICAgLnN0YWNrO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBXcmFwcGVkRXJyb3I7XG4gICAgfShCYXNlRXJyb3IpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICB2YXIgSW52YWxpZFBpcGVBcmd1bWVudEVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDMoSW52YWxpZFBpcGVBcmd1bWVudEVycm9yLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBJbnZhbGlkUGlwZUFyZ3VtZW50RXJyb3IodHlwZSwgdmFsdWUpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIFwiSW52YWxpZCBhcmd1bWVudCAnXCIgKyB2YWx1ZSArIFwiJyBmb3IgcGlwZSAnXCIgKyBzdHJpbmdpZnkodHlwZSkgKyBcIidcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEludmFsaWRQaXBlQXJndW1lbnRFcnJvcjtcbiAgICB9KEJhc2VFcnJvcikpO1xuXG4gICAgdmFyIE9ic2VydmFibGVTdHJhdGVneSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE9ic2VydmFibGVTdHJhdGVneSgpIHtcbiAgICAgICAgfVxuICAgICAgICBPYnNlcnZhYmxlU3RyYXRlZ3kucHJvdG90eXBlLmNyZWF0ZVN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uIChhc3luYywgdXBkYXRlTGF0ZXN0VmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBhc3luYy5zdWJzY3JpYmUoeyBuZXh0OiB1cGRhdGVMYXRlc3RWYWx1ZSwgZXJyb3I6IGZ1bmN0aW9uIChlKSB7IHRocm93IGU7IH0gfSk7XG4gICAgICAgIH07XG4gICAgICAgIE9ic2VydmFibGVTdHJhdGVneS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIChzdWJzY3JpcHRpb24pIHsgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7IH07XG4gICAgICAgIE9ic2VydmFibGVTdHJhdGVneS5wcm90b3R5cGUub25EZXN0cm95ID0gZnVuY3Rpb24gKHN1YnNjcmlwdGlvbikgeyBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTsgfTtcbiAgICAgICAgcmV0dXJuIE9ic2VydmFibGVTdHJhdGVneTtcbiAgICB9KCkpO1xuICAgIHZhciBQcm9taXNlU3RyYXRlZ3kgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBQcm9taXNlU3RyYXRlZ3koKSB7XG4gICAgICAgIH1cbiAgICAgICAgUHJvbWlzZVN0cmF0ZWd5LnByb3RvdHlwZS5jcmVhdGVTdWJzY3JpcHRpb24gPSBmdW5jdGlvbiAoYXN5bmMsIHVwZGF0ZUxhdGVzdFZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gYXN5bmMudGhlbih1cGRhdGVMYXRlc3RWYWx1ZSwgZnVuY3Rpb24gKGUpIHsgdGhyb3cgZTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIFByb21pc2VTdHJhdGVneS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIChzdWJzY3JpcHRpb24pIHsgfTtcbiAgICAgICAgUHJvbWlzZVN0cmF0ZWd5LnByb3RvdHlwZS5vbkRlc3Ryb3kgPSBmdW5jdGlvbiAoc3Vic2NyaXB0aW9uKSB7IH07XG4gICAgICAgIHJldHVybiBQcm9taXNlU3RyYXRlZ3k7XG4gICAgfSgpKTtcbiAgICB2YXIgX3Byb21pc2VTdHJhdGVneSA9IG5ldyBQcm9taXNlU3RyYXRlZ3koKTtcbiAgICB2YXIgX29ic2VydmFibGVTdHJhdGVneSA9IG5ldyBPYnNlcnZhYmxlU3RyYXRlZ3koKTtcbiAgICAvKipcbiAgICAgKiBAbmdNb2R1bGUgQ29tbW9uTW9kdWxlXG4gICAgICogQHdoYXRJdERvZXMgVW53cmFwcyBhIHZhbHVlIGZyb20gYW4gYXN5bmNocm9ub3VzIHByaW1pdGl2ZS5cbiAgICAgKiBAaG93VG9Vc2UgYG9ic2VydmFibGVfb3JfcHJvbWlzZV9leHByZXNzaW9uIHwgYXN5bmNgXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogVGhlIGBhc3luY2AgcGlwZSBzdWJzY3JpYmVzIHRvIGFuIGBPYnNlcnZhYmxlYCBvciBgUHJvbWlzZWAgYW5kIHJldHVybnMgdGhlIGxhdGVzdCB2YWx1ZSBpdCBoYXNcbiAgICAgKiBlbWl0dGVkLiBXaGVuIGEgbmV3IHZhbHVlIGlzIGVtaXR0ZWQsIHRoZSBgYXN5bmNgIHBpcGUgbWFya3MgdGhlIGNvbXBvbmVudCB0byBiZSBjaGVja2VkIGZvclxuICAgICAqIGNoYW5nZXMuIFdoZW4gdGhlIGNvbXBvbmVudCBnZXRzIGRlc3Ryb3llZCwgdGhlIGBhc3luY2AgcGlwZSB1bnN1YnNjcmliZXMgYXV0b21hdGljYWxseSB0byBhdm9pZFxuICAgICAqIHBvdGVudGlhbCBtZW1vcnkgbGVha3MuXG4gICAgICpcbiAgICAgKlxuICAgICAqICMjIEV4YW1wbGVzXG4gICAgICpcbiAgICAgKiBUaGlzIGV4YW1wbGUgYmluZHMgYSBgUHJvbWlzZWAgdG8gdGhlIHZpZXcuIENsaWNraW5nIHRoZSBgUmVzb2x2ZWAgYnV0dG9uIHJlc29sdmVzIHRoZVxuICAgICAqIHByb21pc2UuXG4gICAgICpcbiAgICAgKiB7QGV4YW1wbGUgY29tbW9uL3BpcGVzL3RzL2FzeW5jX3BpcGUudHMgcmVnaW9uPSdBc3luY1BpcGVQcm9taXNlJ31cbiAgICAgKlxuICAgICAqIEl0J3MgYWxzbyBwb3NzaWJsZSB0byB1c2UgYGFzeW5jYCB3aXRoIE9ic2VydmFibGVzLiBUaGUgZXhhbXBsZSBiZWxvdyBiaW5kcyB0aGUgYHRpbWVgIE9ic2VydmFibGVcbiAgICAgKiB0byB0aGUgdmlldy4gVGhlIE9ic2VydmFibGUgY29udGludWVzbHkgdXBkYXRlcyB0aGUgdmlldyB3aXRoIHRoZSBjdXJyZW50IHRpbWUuXG4gICAgICpcbiAgICAgKiB7QGV4YW1wbGUgY29tbW9uL3BpcGVzL3RzL2FzeW5jX3BpcGUudHMgcmVnaW9uPSdBc3luY1BpcGVPYnNlcnZhYmxlJ31cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgQXN5bmNQaXBlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQXN5bmNQaXBlKF9yZWYpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlZiA9IF9yZWY7XG4gICAgICAgICAgICB0aGlzLl9sYXRlc3RWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9sYXRlc3RSZXR1cm5lZFZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9vYmogPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fc3RyYXRlZ3kgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIEFzeW5jUGlwZS5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzcG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBBc3luY1BpcGUucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9iaikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdWJzY3JpYmUob2JqKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fbGF0ZXN0UmV0dXJuZWRWYWx1ZSA9IHRoaXMuX2xhdGVzdFZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9sYXRlc3RWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmogIT09IHRoaXMuX29iaikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0ob2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9sYXRlc3RWYWx1ZSA9PT0gdGhpcy5fbGF0ZXN0UmV0dXJuZWRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9sYXRlc3RSZXR1cm5lZFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbGF0ZXN0UmV0dXJuZWRWYWx1ZSA9IHRoaXMuX2xhdGVzdFZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIF9hbmd1bGFyX2NvcmUuV3JhcHBlZFZhbHVlLndyYXAodGhpcy5fbGF0ZXN0VmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICBBc3luY1BpcGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5fb2JqID0gb2JqO1xuICAgICAgICAgICAgdGhpcy5fc3RyYXRlZ3kgPSB0aGlzLl9zZWxlY3RTdHJhdGVneShvYmopO1xuICAgICAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uID0gdGhpcy5fc3RyYXRlZ3kuY3JlYXRlU3Vic2NyaXB0aW9uKG9iaiwgZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBfdGhpcy5fdXBkYXRlTGF0ZXN0VmFsdWUob2JqLCB2YWx1ZSk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICBBc3luY1BpcGUucHJvdG90eXBlLl9zZWxlY3RTdHJhdGVneSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIGlmIChpc1Byb21pc2Uob2JqKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfcHJvbWlzZVN0cmF0ZWd5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iai5zdWJzY3JpYmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX29ic2VydmFibGVTdHJhdGVneTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkUGlwZUFyZ3VtZW50RXJyb3IoQXN5bmNQaXBlLCBvYmopO1xuICAgICAgICB9O1xuICAgICAgICBBc3luY1BpcGUucHJvdG90eXBlLl9kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fc3RyYXRlZ3kuZGlzcG9zZSh0aGlzLl9zdWJzY3JpcHRpb24pO1xuICAgICAgICAgICAgdGhpcy5fbGF0ZXN0VmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fbGF0ZXN0UmV0dXJuZWRWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fb2JqID0gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgQXN5bmNQaXBlLnByb3RvdHlwZS5fdXBkYXRlTGF0ZXN0VmFsdWUgPSBmdW5jdGlvbiAoYXN5bmMsIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoYXN5bmMgPT09IHRoaXMuX29iaikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xhdGVzdFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVmLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBBc3luY1BpcGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5QaXBlLCBhcmdzOiBbeyBuYW1lOiAnYXN5bmMnLCBwdXJlOiBmYWxzZSB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIEFzeW5jUGlwZS5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5DaGFuZ2VEZXRlY3RvclJlZiwgfSxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIEFzeW5jUGlwZTtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBOdW1iZXJGb3JtYXRTdHlsZTtcbiAgICAoZnVuY3Rpb24gKE51bWJlckZvcm1hdFN0eWxlKSB7XG4gICAgICAgIE51bWJlckZvcm1hdFN0eWxlW051bWJlckZvcm1hdFN0eWxlW1wiRGVjaW1hbFwiXSA9IDBdID0gXCJEZWNpbWFsXCI7XG4gICAgICAgIE51bWJlckZvcm1hdFN0eWxlW051bWJlckZvcm1hdFN0eWxlW1wiUGVyY2VudFwiXSA9IDFdID0gXCJQZXJjZW50XCI7XG4gICAgICAgIE51bWJlckZvcm1hdFN0eWxlW051bWJlckZvcm1hdFN0eWxlW1wiQ3VycmVuY3lcIl0gPSAyXSA9IFwiQ3VycmVuY3lcIjtcbiAgICB9KShOdW1iZXJGb3JtYXRTdHlsZSB8fCAoTnVtYmVyRm9ybWF0U3R5bGUgPSB7fSkpO1xuICAgIHZhciBOdW1iZXJGb3JtYXR0ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBOdW1iZXJGb3JtYXR0ZXIoKSB7XG4gICAgICAgIH1cbiAgICAgICAgTnVtYmVyRm9ybWF0dGVyLmZvcm1hdCA9IGZ1bmN0aW9uIChudW0sIGxvY2FsZSwgc3R5bGUsIF9hKSB7XG4gICAgICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgbWluaW11bUludGVnZXJEaWdpdHMgPSBfYi5taW5pbXVtSW50ZWdlckRpZ2l0cywgbWluaW11bUZyYWN0aW9uRGlnaXRzID0gX2IubWluaW11bUZyYWN0aW9uRGlnaXRzLCBtYXhpbXVtRnJhY3Rpb25EaWdpdHMgPSBfYi5tYXhpbXVtRnJhY3Rpb25EaWdpdHMsIGN1cnJlbmN5ID0gX2IuY3VycmVuY3ksIF9jID0gX2IuY3VycmVuY3lBc1N5bWJvbCwgY3VycmVuY3lBc1N5bWJvbCA9IF9jID09PSB2b2lkIDAgPyBmYWxzZSA6IF9jO1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgbWluaW11bUludGVnZXJEaWdpdHM6IG1pbmltdW1JbnRlZ2VyRGlnaXRzLFxuICAgICAgICAgICAgICAgIG1pbmltdW1GcmFjdGlvbkRpZ2l0czogbWluaW11bUZyYWN0aW9uRGlnaXRzLFxuICAgICAgICAgICAgICAgIG1heGltdW1GcmFjdGlvbkRpZ2l0czogbWF4aW11bUZyYWN0aW9uRGlnaXRzLFxuICAgICAgICAgICAgICAgIHN0eWxlOiBOdW1iZXJGb3JtYXRTdHlsZVtzdHlsZV0udG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChzdHlsZSA9PSBOdW1iZXJGb3JtYXRTdHlsZS5DdXJyZW5jeSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuY3VycmVuY3kgPSBjdXJyZW5jeTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmN1cnJlbmN5RGlzcGxheSA9IGN1cnJlbmN5QXNTeW1ib2wgPyAnc3ltYm9sJyA6ICdjb2RlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgSW50bC5OdW1iZXJGb3JtYXQobG9jYWxlLCBvcHRpb25zKS5mb3JtYXQobnVtKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE51bWJlckZvcm1hdHRlcjtcbiAgICB9KCkpO1xuICAgIHZhciBEQVRFX0ZPUk1BVFNfU1BMSVQgPSAvKCg/OlteeU1MZEhobXNhelpFd0dqSiddKyl8KD86Jyg/OlteJ118JycpKicpfCg/OkUrfHkrfE0rfEwrfGQrfEgrfGgrfEorfGorfG0rfHMrfGF8enxafEcrfHcrKSkoLiopLztcbiAgICB2YXIgUEFUVEVSTl9BTElBU0VTID0ge1xuICAgICAgICB5TU1NZGptczogZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KGNvbWJpbmUoW1xuICAgICAgICAgICAgZGlnaXRDb25kaXRpb24oJ3llYXInLCAxKSxcbiAgICAgICAgICAgIG5hbWVDb25kaXRpb24oJ21vbnRoJywgMyksXG4gICAgICAgICAgICBkaWdpdENvbmRpdGlvbignZGF5JywgMSksXG4gICAgICAgICAgICBkaWdpdENvbmRpdGlvbignaG91cicsIDEpLFxuICAgICAgICAgICAgZGlnaXRDb25kaXRpb24oJ21pbnV0ZScsIDEpLFxuICAgICAgICAgICAgZGlnaXRDb25kaXRpb24oJ3NlY29uZCcsIDEpLFxuICAgICAgICBdKSksXG4gICAgICAgIHlNZGptOiBkYXRlUGFydEdldHRlckZhY3RvcnkoY29tYmluZShbXG4gICAgICAgICAgICBkaWdpdENvbmRpdGlvbigneWVhcicsIDEpLCBkaWdpdENvbmRpdGlvbignbW9udGgnLCAxKSwgZGlnaXRDb25kaXRpb24oJ2RheScsIDEpLFxuICAgICAgICAgICAgZGlnaXRDb25kaXRpb24oJ2hvdXInLCAxKSwgZGlnaXRDb25kaXRpb24oJ21pbnV0ZScsIDEpXG4gICAgICAgIF0pKSxcbiAgICAgICAgeU1NTU1FRUVFZDogZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KGNvbWJpbmUoW1xuICAgICAgICAgICAgZGlnaXRDb25kaXRpb24oJ3llYXInLCAxKSwgbmFtZUNvbmRpdGlvbignbW9udGgnLCA0KSwgbmFtZUNvbmRpdGlvbignd2Vla2RheScsIDQpLFxuICAgICAgICAgICAgZGlnaXRDb25kaXRpb24oJ2RheScsIDEpXG4gICAgICAgIF0pKSxcbiAgICAgICAgeU1NTU1kOiBkYXRlUGFydEdldHRlckZhY3RvcnkoY29tYmluZShbZGlnaXRDb25kaXRpb24oJ3llYXInLCAxKSwgbmFtZUNvbmRpdGlvbignbW9udGgnLCA0KSwgZGlnaXRDb25kaXRpb24oJ2RheScsIDEpXSkpLFxuICAgICAgICB5TU1NZDogZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KGNvbWJpbmUoW2RpZ2l0Q29uZGl0aW9uKCd5ZWFyJywgMSksIG5hbWVDb25kaXRpb24oJ21vbnRoJywgMyksIGRpZ2l0Q29uZGl0aW9uKCdkYXknLCAxKV0pKSxcbiAgICAgICAgeU1kOiBkYXRlUGFydEdldHRlckZhY3RvcnkoY29tYmluZShbZGlnaXRDb25kaXRpb24oJ3llYXInLCAxKSwgZGlnaXRDb25kaXRpb24oJ21vbnRoJywgMSksIGRpZ2l0Q29uZGl0aW9uKCdkYXknLCAxKV0pKSxcbiAgICAgICAgam1zOiBkYXRlUGFydEdldHRlckZhY3RvcnkoY29tYmluZShbZGlnaXRDb25kaXRpb24oJ2hvdXInLCAxKSwgZGlnaXRDb25kaXRpb24oJ3NlY29uZCcsIDEpLCBkaWdpdENvbmRpdGlvbignbWludXRlJywgMSldKSksXG4gICAgICAgIGptOiBkYXRlUGFydEdldHRlckZhY3RvcnkoY29tYmluZShbZGlnaXRDb25kaXRpb24oJ2hvdXInLCAxKSwgZGlnaXRDb25kaXRpb24oJ21pbnV0ZScsIDEpXSkpXG4gICAgfTtcbiAgICB2YXIgREFURV9GT1JNQVRTID0ge1xuICAgICAgICB5eXl5OiBkYXRlUGFydEdldHRlckZhY3RvcnkoZGlnaXRDb25kaXRpb24oJ3llYXInLCA0KSksXG4gICAgICAgIHl5OiBkYXRlUGFydEdldHRlckZhY3RvcnkoZGlnaXRDb25kaXRpb24oJ3llYXInLCAyKSksXG4gICAgICAgIHk6IGRhdGVQYXJ0R2V0dGVyRmFjdG9yeShkaWdpdENvbmRpdGlvbigneWVhcicsIDEpKSxcbiAgICAgICAgTU1NTTogZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KG5hbWVDb25kaXRpb24oJ21vbnRoJywgNCkpLFxuICAgICAgICBNTU06IGRhdGVQYXJ0R2V0dGVyRmFjdG9yeShuYW1lQ29uZGl0aW9uKCdtb250aCcsIDMpKSxcbiAgICAgICAgTU06IGRhdGVQYXJ0R2V0dGVyRmFjdG9yeShkaWdpdENvbmRpdGlvbignbW9udGgnLCAyKSksXG4gICAgICAgIE06IGRhdGVQYXJ0R2V0dGVyRmFjdG9yeShkaWdpdENvbmRpdGlvbignbW9udGgnLCAxKSksXG4gICAgICAgIExMTEw6IGRhdGVQYXJ0R2V0dGVyRmFjdG9yeShuYW1lQ29uZGl0aW9uKCdtb250aCcsIDQpKSxcbiAgICAgICAgZGQ6IGRhdGVQYXJ0R2V0dGVyRmFjdG9yeShkaWdpdENvbmRpdGlvbignZGF5JywgMikpLFxuICAgICAgICBkOiBkYXRlUGFydEdldHRlckZhY3RvcnkoZGlnaXRDb25kaXRpb24oJ2RheScsIDEpKSxcbiAgICAgICAgSEg6IGRpZ2l0TW9kaWZpZXIoaG91ckV4dHJhY3RlcihkYXRlUGFydEdldHRlckZhY3RvcnkoaG91cjEyTW9kaWZ5KGRpZ2l0Q29uZGl0aW9uKCdob3VyJywgMiksIGZhbHNlKSkpKSxcbiAgICAgICAgSDogaG91ckV4dHJhY3RlcihkYXRlUGFydEdldHRlckZhY3RvcnkoaG91cjEyTW9kaWZ5KGRpZ2l0Q29uZGl0aW9uKCdob3VyJywgMSksIGZhbHNlKSkpLFxuICAgICAgICBoaDogZGlnaXRNb2RpZmllcihob3VyRXh0cmFjdGVyKGRhdGVQYXJ0R2V0dGVyRmFjdG9yeShob3VyMTJNb2RpZnkoZGlnaXRDb25kaXRpb24oJ2hvdXInLCAyKSwgdHJ1ZSkpKSksXG4gICAgICAgIGg6IGhvdXJFeHRyYWN0ZXIoZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KGhvdXIxMk1vZGlmeShkaWdpdENvbmRpdGlvbignaG91cicsIDEpLCB0cnVlKSkpLFxuICAgICAgICBqajogZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KGRpZ2l0Q29uZGl0aW9uKCdob3VyJywgMikpLFxuICAgICAgICBqOiBkYXRlUGFydEdldHRlckZhY3RvcnkoZGlnaXRDb25kaXRpb24oJ2hvdXInLCAxKSksXG4gICAgICAgIG1tOiBkaWdpdE1vZGlmaWVyKGRhdGVQYXJ0R2V0dGVyRmFjdG9yeShkaWdpdENvbmRpdGlvbignbWludXRlJywgMikpKSxcbiAgICAgICAgbTogZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KGRpZ2l0Q29uZGl0aW9uKCdtaW51dGUnLCAxKSksXG4gICAgICAgIHNzOiBkaWdpdE1vZGlmaWVyKGRhdGVQYXJ0R2V0dGVyRmFjdG9yeShkaWdpdENvbmRpdGlvbignc2Vjb25kJywgMikpKSxcbiAgICAgICAgczogZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KGRpZ2l0Q29uZGl0aW9uKCdzZWNvbmQnLCAxKSksXG4gICAgICAgIC8vIHdoaWxlIElTTyA4NjAxIHJlcXVpcmVzIGZyYWN0aW9ucyB0byBiZSBwcmVmaXhlZCB3aXRoIGAuYCBvciBgLGBcbiAgICAgICAgLy8gd2UgY2FuIGJlIGp1c3Qgc2FmZWx5IHJlbHkgb24gdXNpbmcgYHNzc2Agc2luY2Ugd2UgY3VycmVudGx5IGRvbid0IHN1cHBvcnQgc2luZ2xlIG9yIHR3byBkaWdpdFxuICAgICAgICAvLyBmcmFjdGlvbnNcbiAgICAgICAgc3NzOiBkYXRlUGFydEdldHRlckZhY3RvcnkoZGlnaXRDb25kaXRpb24oJ3NlY29uZCcsIDMpKSxcbiAgICAgICAgRUVFRTogZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KG5hbWVDb25kaXRpb24oJ3dlZWtkYXknLCA0KSksXG4gICAgICAgIEVFRTogZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KG5hbWVDb25kaXRpb24oJ3dlZWtkYXknLCAzKSksXG4gICAgICAgIEVFOiBkYXRlUGFydEdldHRlckZhY3RvcnkobmFtZUNvbmRpdGlvbignd2Vla2RheScsIDIpKSxcbiAgICAgICAgRTogZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KG5hbWVDb25kaXRpb24oJ3dlZWtkYXknLCAxKSksXG4gICAgICAgIGE6IGhvdXJDbG9ja0V4dHJhY3RlcihkYXRlUGFydEdldHRlckZhY3RvcnkoaG91cjEyTW9kaWZ5KGRpZ2l0Q29uZGl0aW9uKCdob3VyJywgMSksIHRydWUpKSksXG4gICAgICAgIFo6IHRpbWVab25lR2V0dGVyKCdzaG9ydCcpLFxuICAgICAgICB6OiB0aW1lWm9uZUdldHRlcignbG9uZycpLFxuICAgICAgICB3dzogZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KHt9KSxcbiAgICAgICAgLy8gZmlyc3QgVGh1cnNkYXkgb2YgdGhlIHllYXIuIG5vdCBzdXBwb3J0ID9cbiAgICAgICAgdzogZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KHt9KSxcbiAgICAgICAgLy8gb2YgdGhlIHllYXIgbm90IHN1cHBvcnQgP1xuICAgICAgICBHOiBkYXRlUGFydEdldHRlckZhY3RvcnkobmFtZUNvbmRpdGlvbignZXJhJywgMSkpLFxuICAgICAgICBHRzogZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KG5hbWVDb25kaXRpb24oJ2VyYScsIDIpKSxcbiAgICAgICAgR0dHOiBkYXRlUGFydEdldHRlckZhY3RvcnkobmFtZUNvbmRpdGlvbignZXJhJywgMykpLFxuICAgICAgICBHR0dHOiBkYXRlUGFydEdldHRlckZhY3RvcnkobmFtZUNvbmRpdGlvbignZXJhJywgNCkpXG4gICAgfTtcbiAgICBmdW5jdGlvbiBkaWdpdE1vZGlmaWVyKGlubmVyKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZGF0ZSwgbG9jYWxlKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gaW5uZXIoZGF0ZSwgbG9jYWxlKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQubGVuZ3RoID09IDEgPyAnMCcgKyByZXN1bHQgOiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhvdXJDbG9ja0V4dHJhY3Rlcihpbm5lcikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGUsIGxvY2FsZSkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGlubmVyKGRhdGUsIGxvY2FsZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnNwbGl0KCcgJylbMV07XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhvdXJFeHRyYWN0ZXIoaW5uZXIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRlLCBsb2NhbGUpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBpbm5lcihkYXRlLCBsb2NhbGUpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5zcGxpdCgnICcpWzBdO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnRsRGF0ZUZvcm1hdChkYXRlLCBsb2NhbGUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxvY2FsZSwgb3B0aW9ucykuZm9ybWF0KGRhdGUpLnJlcGxhY2UoL1tcXHUyMDBlXFx1MjAwZl0vZywgJycpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0aW1lWm9uZUdldHRlcih0aW1lem9uZSkge1xuICAgICAgICAvLyBUbyB3b3JrYXJvdW5kIGBJbnRsYCBBUEkgcmVzdHJpY3Rpb24gZm9yIHNpbmdsZSB0aW1lem9uZSBsZXQgZm9ybWF0IHdpdGggMjQgaG91cnNcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7IGhvdXI6ICcyLWRpZ2l0JywgaG91cjEyOiBmYWxzZSwgdGltZVpvbmVOYW1lOiB0aW1lem9uZSB9O1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGUsIGxvY2FsZSkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGludGxEYXRlRm9ybWF0KGRhdGUsIGxvY2FsZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAvLyBUaGVuIGV4dHJhY3QgZmlyc3QgMyBsZXR0ZXJzIHRoYXQgcmVsYXRlZCB0byBob3Vyc1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCA/IHJlc3VsdC5zdWJzdHJpbmcoMykgOiAnJztcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaG91cjEyTW9kaWZ5KG9wdGlvbnMsIHZhbHVlKSB7XG4gICAgICAgIG9wdGlvbnMuaG91cjEyID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkaWdpdENvbmRpdGlvbihwcm9wLCBsZW4pIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICByZXN1bHRbcHJvcF0gPSBsZW4gPT0gMiA/ICcyLWRpZ2l0JyA6ICdudW1lcmljJztcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbmFtZUNvbmRpdGlvbihwcm9wLCBsZW4pIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICByZXN1bHRbcHJvcF0gPSBsZW4gPCA0ID8gJ3Nob3J0JyA6ICdsb25nJztcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tYmluZShvcHRpb25zKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgb3B0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChvcHRpb24pIHsgT2JqZWN0LmFzc2lnbihyZXN1bHQsIG9wdGlvbik7IH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkYXRlUGFydEdldHRlckZhY3RvcnkocmV0KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZGF0ZSwgbG9jYWxlKSB7IHJldHVybiBpbnRsRGF0ZUZvcm1hdChkYXRlLCBsb2NhbGUsIHJldCk7IH07XG4gICAgfVxuICAgIHZhciBkYXRlUGFydHNGb3JtYXR0ZXJDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICBmdW5jdGlvbiBkYXRlRm9ybWF0dGVyKGZvcm1hdCwgZGF0ZSwgbG9jYWxlKSB7XG4gICAgICAgIHZhciB0ZXh0ID0gJyc7XG4gICAgICAgIHZhciBtYXRjaDtcbiAgICAgICAgdmFyIGZuO1xuICAgICAgICB2YXIgcGFydHMgPSBbXTtcbiAgICAgICAgaWYgKFBBVFRFUk5fQUxJQVNFU1tmb3JtYXRdKSB7XG4gICAgICAgICAgICByZXR1cm4gUEFUVEVSTl9BTElBU0VTW2Zvcm1hdF0oZGF0ZSwgbG9jYWxlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0ZVBhcnRzRm9ybWF0dGVyQ2FjaGUuaGFzKGZvcm1hdCkpIHtcbiAgICAgICAgICAgIHBhcnRzID0gZGF0ZVBhcnRzRm9ybWF0dGVyQ2FjaGUuZ2V0KGZvcm1hdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IERBVEVfRk9STUFUU19TUExJVC5leGVjKGZvcm1hdCk7XG4gICAgICAgICAgICB3aGlsZSAoZm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgbWF0Y2ggPSBEQVRFX0ZPUk1BVFNfU1BMSVQuZXhlYyhmb3JtYXQpO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0cyA9IGNvbmNhdChwYXJ0cywgbWF0Y2gsIDEpO1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXQgPSBwYXJ0cy5wb3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goZm9ybWF0KTtcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRlUGFydHNGb3JtYXR0ZXJDYWNoZS5zZXQoZm9ybWF0LCBwYXJ0cyk7XG4gICAgICAgIH1cbiAgICAgICAgcGFydHMuZm9yRWFjaChmdW5jdGlvbiAocGFydCkge1xuICAgICAgICAgICAgZm4gPSBEQVRFX0ZPUk1BVFNbcGFydF07XG4gICAgICAgICAgICB0ZXh0ICs9IGZuID8gZm4oZGF0ZSwgbG9jYWxlKSA6XG4gICAgICAgICAgICAgICAgcGFydCA9PT0gJ1xcJ1xcJycgPyAnXFwnJyA6IHBhcnQucmVwbGFjZSgvKF4nfCckKS9nLCAnJykucmVwbGFjZSgvJycvZywgJ1xcJycpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIHZhciBzbGljZSA9IFtdLnNsaWNlO1xuICAgIGZ1bmN0aW9uIGNvbmNhdChhcnJheTEgLyoqIFRPRE8gIzkxMDAgKi8sIGFycmF5MiAvKiogVE9ETyAjOTEwMCAqLywgaW5kZXggLyoqIFRPRE8gIzkxMDAgKi8pIHtcbiAgICAgICAgcmV0dXJuIGFycmF5MS5jb25jYXQoc2xpY2UuY2FsbChhcnJheTIsIGluZGV4KSk7XG4gICAgfVxuICAgIHZhciBEYXRlRm9ybWF0dGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gRGF0ZUZvcm1hdHRlcigpIHtcbiAgICAgICAgfVxuICAgICAgICBEYXRlRm9ybWF0dGVyLmZvcm1hdCA9IGZ1bmN0aW9uIChkYXRlLCBsb2NhbGUsIHBhdHRlcm4pIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRlRm9ybWF0dGVyKHBhdHRlcm4sIGRhdGUsIGxvY2FsZSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBEYXRlRm9ybWF0dGVyO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbmdNb2R1bGUgQ29tbW9uTW9kdWxlXG4gICAgICogQHdoYXRJdERvZXMgRm9ybWF0cyBhIGRhdGUgYWNjb3JkaW5nIHRvIGxvY2FsZSBydWxlcy5cbiAgICAgKiBAaG93VG9Vc2UgYGRhdGVfZXhwcmVzc2lvbiB8IGRhdGVbOmZvcm1hdF1gXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBXaGVyZTpcbiAgICAgKiAtIGBleHByZXNzaW9uYCBpcyBhIGRhdGUgb2JqZWN0IG9yIGEgbnVtYmVyIChtaWxsaXNlY29uZHMgc2luY2UgVVRDIGVwb2NoKSBvciBhbiBJU08gc3RyaW5nXG4gICAgICogKGh0dHBzOi8vd3d3LnczLm9yZy9UUi9OT1RFLWRhdGV0aW1lKS5cbiAgICAgKiAtIGBmb3JtYXRgIGluZGljYXRlcyB3aGljaCBkYXRlL3RpbWUgY29tcG9uZW50cyB0byBpbmNsdWRlLiBUaGUgZm9ybWF0IGNhbiBiZSBwcmVkaWZpbmVkIGFzXG4gICAgICogICBzaG93biBiZWxvdyBvciBjdXN0b20gYXMgc2hvd24gaW4gdGhlIHRhYmxlLlxuICAgICAqICAgLSBgJ21lZGl1bSdgOiBlcXVpdmFsZW50IHRvIGAneU1NTWRqbXMnYCAoZS5nLiBgU2VwIDMsIDIwMTAsIDEyOjA1OjA4IFBNYCBmb3IgYGVuLVVTYClcbiAgICAgKiAgIC0gYCdzaG9ydCdgOiBlcXVpdmFsZW50IHRvIGAneU1kam0nYCAoZS5nLiBgOS8zLzIwMTAsIDEyOjA1IFBNYCBmb3IgYGVuLVVTYClcbiAgICAgKiAgIC0gYCdmdWxsRGF0ZSdgOiBlcXVpdmFsZW50IHRvIGAneU1NTU1FRUVFZCdgIChlLmcuIGBGcmlkYXksIFNlcHRlbWJlciAzLCAyMDEwYCBmb3IgYGVuLVVTYClcbiAgICAgKiAgIC0gYCdsb25nRGF0ZSdgOiBlcXVpdmFsZW50IHRvIGAneU1NTU1kJ2AgKGUuZy4gYFNlcHRlbWJlciAzLCAyMDEwYCBmb3IgYGVuLVVTYClcbiAgICAgKiAgIC0gYCdtZWRpdW1EYXRlJ2A6IGVxdWl2YWxlbnQgdG8gYCd5TU1NZCdgIChlLmcuIGBTZXAgMywgMjAxMGAgZm9yIGBlbi1VU2ApXG4gICAgICogICAtIGAnc2hvcnREYXRlJ2A6IGVxdWl2YWxlbnQgdG8gYCd5TWQnYCAoZS5nLiBgOS8zLzIwMTBgIGZvciBgZW4tVVNgKVxuICAgICAqICAgLSBgJ21lZGl1bVRpbWUnYDogZXF1aXZhbGVudCB0byBgJ2ptcydgIChlLmcuIGAxMjowNTowOCBQTWAgZm9yIGBlbi1VU2ApXG4gICAgICogICAtIGAnc2hvcnRUaW1lJ2A6IGVxdWl2YWxlbnQgdG8gYCdqbSdgIChlLmcuIGAxMjowNSBQTWAgZm9yIGBlbi1VU2ApXG4gICAgICpcbiAgICAgKlxuICAgICAqICB8IENvbXBvbmVudCB8IFN5bWJvbCB8IFNob3J0IEZvcm0gICB8IExvbmcgRm9ybSAgICAgICAgIHwgTnVtZXJpYyAgIHwgMi1kaWdpdCAgIHxcbiAgICAgKiAgfC0tLS0tLS0tLS0tfDotLS0tLS06fC0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS18LS0tLS0tLS0tLS18XG4gICAgICogIHwgZXJhICAgICAgIHwgICBHICAgIHwgRyAoQUQpICAgICAgIHwgR0dHRyAoQW5ubyBEb21pbmkpfCAtICAgICAgICAgfCAtICAgICAgICAgfFxuICAgICAqICB8IHllYXIgICAgICB8ICAgeSAgICB8IC0gICAgICAgICAgICB8IC0gICAgICAgICAgICAgICAgIHwgeSAoMjAxNSkgIHwgeXkgKDE1KSAgIHxcbiAgICAgKiAgfCBtb250aCAgICAgfCAgIE0gICAgfCBNTU0gKFNlcCkgICAgfCBNTU1NIChTZXB0ZW1iZXIpICB8IE0gKDkpICAgICB8IE1NICgwOSkgICB8XG4gICAgICogIHwgZGF5ICAgICAgIHwgICBkICAgIHwgLSAgICAgICAgICAgIHwgLSAgICAgICAgICAgICAgICAgfCBkICgzKSAgICAgfCBkZCAoMDMpICAgfFxuICAgICAqICB8IHdlZWtkYXkgICB8ICAgRSAgICB8IEVFRSAoU3VuKSAgICB8IEVFRUUgKFN1bmRheSkgICAgIHwgLSAgICAgICAgIHwgLSAgICAgICAgIHxcbiAgICAgKiAgfCBob3VyICAgICAgfCAgIGogICAgfCAtICAgICAgICAgICAgfCAtICAgICAgICAgICAgICAgICB8IGogKDEzKSAgICB8IGpqICgxMykgICB8XG4gICAgICogIHwgaG91cjEyICAgIHwgICBoICAgIHwgLSAgICAgICAgICAgIHwgLSAgICAgICAgICAgICAgICAgfCBoICgxIFBNKSAgfCBoaCAoMDEgUE0pfFxuICAgICAqICB8IGhvdXIyNCAgICB8ICAgSCAgICB8IC0gICAgICAgICAgICB8IC0gICAgICAgICAgICAgICAgIHwgSCAoMTMpICAgIHwgSEggKDEzKSAgIHxcbiAgICAgKiAgfCBtaW51dGUgICAgfCAgIG0gICAgfCAtICAgICAgICAgICAgfCAtICAgICAgICAgICAgICAgICB8IG0gKDUpICAgICB8IG1tICgwNSkgICB8XG4gICAgICogIHwgc2Vjb25kICAgIHwgICBzICAgIHwgLSAgICAgICAgICAgIHwgLSAgICAgICAgICAgICAgICAgfCBzICg5KSAgICAgfCBzcyAoMDkpICAgfFxuICAgICAqICB8IHRpbWV6b25lICB8ICAgeiAgICB8IC0gICAgICAgICAgICB8IHogKFBhY2lmaWMgU3RhbmRhcmQgVGltZSl8IC0gIHwgLSAgICAgICAgIHxcbiAgICAgKiAgfCB0aW1lem9uZSAgfCAgIFogICAgfCBaIChHTVQtODowMCkgfCAtICAgICAgICAgICAgICAgICB8IC0gICAgICAgICB8IC0gICAgICAgICB8XG4gICAgICogIHwgdGltZXpvbmUgIHwgICBhICAgIHwgYSAoUE0pICAgICAgIHwgLSAgICAgICAgICAgICAgICAgfCAtICAgICAgICAgfCAtICAgICAgICAgfFxuICAgICAqXG4gICAgICogSW4gamF2YXNjcmlwdCwgb25seSB0aGUgY29tcG9uZW50cyBzcGVjaWZpZWQgd2lsbCBiZSByZXNwZWN0ZWQgKG5vdCB0aGUgb3JkZXJpbmcsXG4gICAgICogcHVuY3R1YXRpb25zLCAuLi4pIGFuZCBkZXRhaWxzIG9mIHRoZSBmb3JtYXR0aW5nIHdpbGwgYmUgZGVwZW5kZW50IG9uIHRoZSBsb2NhbGUuXG4gICAgICpcbiAgICAgKiBUaW1lem9uZSBvZiB0aGUgZm9ybWF0dGVkIHRleHQgd2lsbCBiZSB0aGUgbG9jYWwgc3lzdGVtIHRpbWV6b25lIG9mIHRoZSBlbmQtdXNlcidzIG1hY2hpbmUuXG4gICAgICpcbiAgICAgKiBXQVJOSU5HUzpcbiAgICAgKiAtIHRoaXMgcGlwZSBpcyBtYXJrZWQgYXMgcHVyZSBoZW5jZSBpdCB3aWxsIG5vdCBiZSByZS1ldmFsdWF0ZWQgd2hlbiB0aGUgaW5wdXQgaXMgbXV0YXRlZC5cbiAgICAgKiAgIEluc3RlYWQgdXNlcnMgc2hvdWxkIHRyZWF0IHRoZSBkYXRlIGFzIGFuIGltbXV0YWJsZSBvYmplY3QgYW5kIGNoYW5nZSB0aGUgcmVmZXJlbmNlIHdoZW4gdGhlXG4gICAgICogICBwaXBlIG5lZWRzIHRvIHJlLXJ1biAodGhpcyBpcyB0byBhdm9pZCByZWZvcm1hdHRpbmcgdGhlIGRhdGUgb24gZXZlcnkgY2hhbmdlIGRldGVjdGlvbiBydW5cbiAgICAgKiAgIHdoaWNoIHdvdWxkIGJlIGFuIGV4cGVuc2l2ZSBvcGVyYXRpb24pLlxuICAgICAqIC0gdGhpcyBwaXBlIHVzZXMgdGhlIEludGVybmF0aW9uYWxpemF0aW9uIEFQSS4gVGhlcmVmb3JlIGl0IGlzIG9ubHkgcmVsaWFibGUgaW4gQ2hyb21lIGFuZCBPcGVyYVxuICAgICAqICAgYnJvd3NlcnMuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZXNcbiAgICAgKlxuICAgICAqIEFzc3VtaW5nIGBkYXRlT2JqYCBpcyAoeWVhcjogMjAxNSwgbW9udGg6IDYsIGRheTogMTUsIGhvdXI6IDIxLCBtaW51dGU6IDQzLCBzZWNvbmQ6IDExKVxuICAgICAqIGluIHRoZSBfbG9jYWxfIHRpbWUgYW5kIGxvY2FsZSBpcyAnZW4tVVMnOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogICAgIHt7IGRhdGVPYmogfCBkYXRlIH19ICAgICAgICAgICAgICAgLy8gb3V0cHV0IGlzICdKdW4gMTUsIDIwMTUnXG4gICAgICogICAgIHt7IGRhdGVPYmogfCBkYXRlOidtZWRpdW0nIH19ICAgICAgLy8gb3V0cHV0IGlzICdKdW4gMTUsIDIwMTUsIDk6NDM6MTEgUE0nXG4gICAgICogICAgIHt7IGRhdGVPYmogfCBkYXRlOidzaG9ydFRpbWUnIH19ICAgLy8gb3V0cHV0IGlzICc5OjQzIFBNJ1xuICAgICAqICAgICB7eyBkYXRlT2JqIHwgZGF0ZTonbW1zcycgfX0gICAgICAgIC8vIG91dHB1dCBpcyAnNDM6MTEnXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiB7QGV4YW1wbGUgY29tbW9uL3BpcGVzL3RzL2RhdGVfcGlwZS50cyByZWdpb249J0RhdGVQaXBlJ31cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgRGF0ZVBpcGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBEYXRlUGlwZShfbG9jYWxlKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2NhbGUgPSBfbG9jYWxlO1xuICAgICAgICB9XG4gICAgICAgIERhdGVQaXBlLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAodmFsdWUsIHBhdHRlcm4pIHtcbiAgICAgICAgICAgIGlmIChwYXR0ZXJuID09PSB2b2lkIDApIHsgcGF0dGVybiA9ICdtZWRpdW1EYXRlJzsgfVxuICAgICAgICAgICAgaWYgKGlzQmxhbmsodmFsdWUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnN1cHBvcnRzKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkUGlwZUFyZ3VtZW50RXJyb3IoRGF0ZVBpcGUsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChOdW1iZXJXcmFwcGVyLmlzTnVtZXJpYyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIERhdGVGb3JtYXR0ZXIuZm9ybWF0KG5ldyBEYXRlKHZhbHVlKSwgdGhpcy5fbG9jYWxlLCBEYXRlUGlwZS5fQUxJQVNFU1twYXR0ZXJuXSB8fCBwYXR0ZXJuKTtcbiAgICAgICAgfTtcbiAgICAgICAgRGF0ZVBpcGUucHJvdG90eXBlLnN1cHBvcnRzID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgcmV0dXJuIGlzRGF0ZShvYmopIHx8IE51bWJlcldyYXBwZXIuaXNOdW1lcmljKG9iaikgfHxcbiAgICAgICAgICAgICAgICAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycgJiYgaXNEYXRlKG5ldyBEYXRlKG9iaikpKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBEYXRlUGlwZS5fQUxJQVNFUyA9IHtcbiAgICAgICAgICAgICdtZWRpdW0nOiAneU1NTWRqbXMnLFxuICAgICAgICAgICAgJ3Nob3J0JzogJ3lNZGptJyxcbiAgICAgICAgICAgICdmdWxsRGF0ZSc6ICd5TU1NTUVFRUVkJyxcbiAgICAgICAgICAgICdsb25nRGF0ZSc6ICd5TU1NTWQnLFxuICAgICAgICAgICAgJ21lZGl1bURhdGUnOiAneU1NTWQnLFxuICAgICAgICAgICAgJ3Nob3J0RGF0ZSc6ICd5TWQnLFxuICAgICAgICAgICAgJ21lZGl1bVRpbWUnOiAnam1zJyxcbiAgICAgICAgICAgICdzaG9ydFRpbWUnOiAnam0nXG4gICAgICAgIH07XG4gICAgICAgIERhdGVQaXBlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuUGlwZSwgYXJnczogW3sgbmFtZTogJ2RhdGUnLCBwdXJlOiB0cnVlIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgRGF0ZVBpcGUuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtfYW5ndWxhcl9jb3JlLkxPQ0FMRV9JRCxdIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gRGF0ZVBpcGU7XG4gICAgfSgpKTtcblxuICAgIHZhciBfSU5URVJQT0xBVElPTl9SRUdFWFAgPSAvIy9nO1xuICAgIC8qKlxuICAgICAqIEBuZ01vZHVsZSBDb21tb25Nb2R1bGVcbiAgICAgKiBAd2hhdEl0RG9lcyBNYXBzIGEgdmFsdWUgdG8gYSBzdHJpbmcgdGhhdCBwbHVyYWxpemVzIHRoZSB2YWx1ZSBhY2NvcmRpbmcgdG8gbG9jYWxlIHJ1bGVzLlxuICAgICAqIEBob3dUb1VzZSBgZXhwcmVzc2lvbiB8IGkxOG5QbHVyYWw6bWFwcGluZ2BcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqICBXaGVyZTpcbiAgICAgKiAgLSBgZXhwcmVzc2lvbmAgaXMgYSBudW1iZXIuXG4gICAgICogIC0gYG1hcHBpbmdgIGlzIGFuIG9iamVjdCB0aGF0IG1pbWljcyB0aGUgSUNVIGZvcm1hdCwgc2VlXG4gICAgICogICAgaHR0cDovL3VzZXJndWlkZS5pY3UtcHJvamVjdC5vcmcvZm9ybWF0cGFyc2UvbWVzc2FnZXNcbiAgICAgKlxuICAgICAqICAjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiB7QGV4YW1wbGUgY29tbW9uL3BpcGVzL3RzL2kxOG5fcGlwZS50cyByZWdpb249J0kxOG5QbHVyYWxQaXBlQ29tcG9uZW50J31cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgSTE4blBsdXJhbFBpcGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBJMThuUGx1cmFsUGlwZShfbG9jYWxpemF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2NhbGl6YXRpb24gPSBfbG9jYWxpemF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIEkxOG5QbHVyYWxQaXBlLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAodmFsdWUsIHBsdXJhbE1hcCkge1xuICAgICAgICAgICAgaWYgKGlzQmxhbmsodmFsdWUpKVxuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGx1cmFsTWFwICE9PSAnb2JqZWN0JyB8fCBwbHVyYWxNYXAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFBpcGVBcmd1bWVudEVycm9yKEkxOG5QbHVyYWxQaXBlLCBwbHVyYWxNYXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGtleSA9IGdldFBsdXJhbENhdGVnb3J5KHZhbHVlLCBPYmplY3Qua2V5cyhwbHVyYWxNYXApLCB0aGlzLl9sb2NhbGl6YXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHBsdXJhbE1hcFtrZXldLnJlcGxhY2UoX0lOVEVSUE9MQVRJT05fUkVHRVhQLCB2YWx1ZS50b1N0cmluZygpKTtcbiAgICAgICAgfTtcbiAgICAgICAgSTE4blBsdXJhbFBpcGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5QaXBlLCBhcmdzOiBbeyBuYW1lOiAnaTE4blBsdXJhbCcsIHB1cmU6IHRydWUgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBJMThuUGx1cmFsUGlwZS5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogTmdMb2NhbGl6YXRpb24sIH0sXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBJMThuUGx1cmFsUGlwZTtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQG5nTW9kdWxlIENvbW1vbk1vZHVsZVxuICAgICAqIEB3aGF0SXREb2VzIEdlbmVyaWMgc2VsZWN0b3IgdGhhdCBkaXNwbGF5cyB0aGUgc3RyaW5nIHRoYXQgbWF0Y2hlcyB0aGUgY3VycmVudCB2YWx1ZS5cbiAgICAgKiBAaG93VG9Vc2UgYGV4cHJlc3Npb24gfCBpMThuU2VsZWN0Om1hcHBpbmdgXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiAgV2hlcmU6XG4gICAgICogIC0gYG1hcHBpbmdgOiBpcyBhbiBvYmplY3QgdGhhdCBpbmRpY2F0ZXMgdGhlIHRleHQgdGhhdCBzaG91bGQgYmUgZGlzcGxheWVkXG4gICAgICogIGZvciBkaWZmZXJlbnQgdmFsdWVzIG9mIHRoZSBwcm92aWRlZCBgZXhwcmVzc2lvbmAuXG4gICAgICpcbiAgICAgKiAgIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICoge0BleGFtcGxlIGNvbW1vbi9waXBlcy90cy9pMThuX3BpcGUudHMgcmVnaW9uPSdJMThuU2VsZWN0UGlwZUNvbXBvbmVudCd9XG4gICAgICpcbiAgICAgKiAgQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBJMThuU2VsZWN0UGlwZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEkxOG5TZWxlY3RQaXBlKCkge1xuICAgICAgICB9XG4gICAgICAgIEkxOG5TZWxlY3RQaXBlLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAodmFsdWUsIG1hcHBpbmcpIHtcbiAgICAgICAgICAgIGlmIChpc0JsYW5rKHZhbHVlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1hcHBpbmcgIT09ICdvYmplY3QnIHx8IG1hcHBpbmcgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFBpcGVBcmd1bWVudEVycm9yKEkxOG5TZWxlY3RQaXBlLCBtYXBwaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXBwaW5nW3ZhbHVlXSB8fCAnJztcbiAgICAgICAgfTtcbiAgICAgICAgSTE4blNlbGVjdFBpcGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5QaXBlLCBhcmdzOiBbeyBuYW1lOiAnaTE4blNlbGVjdCcsIHB1cmU6IHRydWUgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBJMThuU2VsZWN0UGlwZS5jdG9yUGFyYW1ldGVycyA9IFtdO1xuICAgICAgICByZXR1cm4gSTE4blNlbGVjdFBpcGU7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEBuZ01vZHVsZSBDb21tb25Nb2R1bGVcbiAgICAgKiBAd2hhdEl0RG9lcyBDb252ZXJ0cyB2YWx1ZSBpbnRvIEpTT04gc3RyaW5nLlxuICAgICAqIEBob3dUb1VzZSBgZXhwcmVzc2lvbiB8IGpzb25gXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBDb252ZXJ0cyB2YWx1ZSBpbnRvIHN0cmluZyB1c2luZyBgSlNPTi5zdHJpbmdpZnlgLiBVc2VmdWwgZm9yIGRlYnVnZ2luZy5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICoge0BleGFtcGxlIGNvbW1vbi9waXBlcy90cy9qc29uX3BpcGUudHMgcmVnaW9uPSdKc29uUGlwZSd9XG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEpzb25QaXBlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gSnNvblBpcGUoKSB7XG4gICAgICAgIH1cbiAgICAgICAgSnNvblBpcGUucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUsIG51bGwsIDIpOyB9O1xuICAgICAgICBKc29uUGlwZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlBpcGUsIGFyZ3M6IFt7IG5hbWU6ICdqc29uJywgcHVyZTogZmFsc2UgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBKc29uUGlwZS5jdG9yUGFyYW1ldGVycyA9IFtdO1xuICAgICAgICByZXR1cm4gSnNvblBpcGU7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEBuZ01vZHVsZSBDb21tb25Nb2R1bGVcbiAgICAgKiBAd2hhdEl0RG9lcyBUcmFuc2Zvcm1zIHN0cmluZyB0byBsb3dlcmNhc2UuXG4gICAgICogQGhvd1RvVXNlIGBleHByZXNzaW9uIHwgbG93ZXJjYXNlYFxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogQ29udmVydHMgdmFsdWUgaW50byBsb3dlcmNhc2Ugc3RyaW5nIHVzaW5nIGBTdHJpbmcucHJvdG90eXBlLnRvTG93ZXJDYXNlKClgLlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGVcbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBjb21tb24vcGlwZXMvdHMvbG93ZXJ1cHBlcl9waXBlLnRzIHJlZ2lvbj0nTG93ZXJVcHBlclBpcGUnfVxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBMb3dlckNhc2VQaXBlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTG93ZXJDYXNlUGlwZSgpIHtcbiAgICAgICAgfVxuICAgICAgICBMb3dlckNhc2VQaXBlLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChpc0JsYW5rKHZhbHVlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkUGlwZUFyZ3VtZW50RXJyb3IoTG93ZXJDYXNlUGlwZSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH07XG4gICAgICAgIExvd2VyQ2FzZVBpcGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5QaXBlLCBhcmdzOiBbeyBuYW1lOiAnbG93ZXJjYXNlJyB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIExvd2VyQ2FzZVBpcGUuY3RvclBhcmFtZXRlcnMgPSBbXTtcbiAgICAgICAgcmV0dXJuIExvd2VyQ2FzZVBpcGU7XG4gICAgfSgpKTtcblxuICAgIHZhciBfTlVNQkVSX0ZPUk1BVF9SRUdFWFAgPSAvXihcXGQrKT9cXC4oKFxcZCspKC0oXFxkKykpPyk/JC87XG4gICAgZnVuY3Rpb24gZm9ybWF0TnVtYmVyKHBpcGUsIGxvY2FsZSwgdmFsdWUsIHN0eWxlLCBkaWdpdHMsIGN1cnJlbmN5LCBjdXJyZW5jeUFzU3ltYm9sKSB7XG4gICAgICAgIGlmIChjdXJyZW5jeSA9PT0gdm9pZCAwKSB7IGN1cnJlbmN5ID0gbnVsbDsgfVxuICAgICAgICBpZiAoY3VycmVuY3lBc1N5bWJvbCA9PT0gdm9pZCAwKSB7IGN1cnJlbmN5QXNTeW1ib2wgPSBmYWxzZTsgfVxuICAgICAgICBpZiAoaXNCbGFuayh2YWx1ZSkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgLy8gQ29udmVydCBzdHJpbmdzIHRvIG51bWJlcnNcbiAgICAgICAgdmFsdWUgPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIE51bWJlcldyYXBwZXIuaXNOdW1lcmljKHZhbHVlKSA/ICt2YWx1ZSA6IHZhbHVlO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRQaXBlQXJndW1lbnRFcnJvcihwaXBlLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1pbkludDtcbiAgICAgICAgdmFyIG1pbkZyYWN0aW9uO1xuICAgICAgICB2YXIgbWF4RnJhY3Rpb247XG4gICAgICAgIGlmIChzdHlsZSAhPT0gTnVtYmVyRm9ybWF0U3R5bGUuQ3VycmVuY3kpIHtcbiAgICAgICAgICAgIC8vIHJlbHkgb24gSW50bCBkZWZhdWx0IGZvciBjdXJyZW5jeVxuICAgICAgICAgICAgbWluSW50ID0gMTtcbiAgICAgICAgICAgIG1pbkZyYWN0aW9uID0gMDtcbiAgICAgICAgICAgIG1heEZyYWN0aW9uID0gMztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlnaXRzKSB7XG4gICAgICAgICAgICB2YXIgcGFydHMgPSBkaWdpdHMubWF0Y2goX05VTUJFUl9GT1JNQVRfUkVHRVhQKTtcbiAgICAgICAgICAgIGlmIChwYXJ0cyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihkaWdpdHMgKyBcIiBpcyBub3QgYSB2YWxpZCBkaWdpdCBpbmZvIGZvciBudW1iZXIgcGlwZXNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHBhcnRzWzFdKSkge1xuICAgICAgICAgICAgICAgIG1pbkludCA9IE51bWJlcldyYXBwZXIucGFyc2VJbnRBdXRvUmFkaXgocGFydHNbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChwYXJ0c1szXSkpIHtcbiAgICAgICAgICAgICAgICBtaW5GcmFjdGlvbiA9IE51bWJlcldyYXBwZXIucGFyc2VJbnRBdXRvUmFkaXgocGFydHNbM10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChwYXJ0c1s1XSkpIHtcbiAgICAgICAgICAgICAgICBtYXhGcmFjdGlvbiA9IE51bWJlcldyYXBwZXIucGFyc2VJbnRBdXRvUmFkaXgocGFydHNbNV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBOdW1iZXJGb3JtYXR0ZXIuZm9ybWF0KHZhbHVlLCBsb2NhbGUsIHN0eWxlLCB7XG4gICAgICAgICAgICBtaW5pbXVtSW50ZWdlckRpZ2l0czogbWluSW50LFxuICAgICAgICAgICAgbWluaW11bUZyYWN0aW9uRGlnaXRzOiBtaW5GcmFjdGlvbixcbiAgICAgICAgICAgIG1heGltdW1GcmFjdGlvbkRpZ2l0czogbWF4RnJhY3Rpb24sXG4gICAgICAgICAgICBjdXJyZW5jeTogY3VycmVuY3ksXG4gICAgICAgICAgICBjdXJyZW5jeUFzU3ltYm9sOiBjdXJyZW5jeUFzU3ltYm9sLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQG5nTW9kdWxlIENvbW1vbk1vZHVsZVxuICAgICAqIEB3aGF0SXREb2VzIEZvcm1hdHMgYSBudW1iZXIgYWNjb3JkaW5nIHRvIGxvY2FsZSBydWxlcy5cbiAgICAgKiBAaG93VG9Vc2UgYG51bWJlcl9leHByZXNzaW9uIHwgbnVtYmVyWzpkaWdpdEluZm9dYFxuICAgICAqXG4gICAgICogRm9ybWF0cyBhIG51bWJlciBhcyB0ZXh0LiBHcm91cCBzaXppbmcgYW5kIHNlcGFyYXRvciBhbmQgb3RoZXIgbG9jYWxlLXNwZWNpZmljXG4gICAgICogY29uZmlndXJhdGlvbnMgYXJlIGJhc2VkIG9uIHRoZSBhY3RpdmUgbG9jYWxlLlxuICAgICAqXG4gICAgICogd2hlcmUgYGV4cHJlc3Npb25gIGlzIGEgbnVtYmVyOlxuICAgICAqICAtIGBkaWdpdEluZm9gIGlzIGEgYHN0cmluZ2Agd2hpY2ggaGFzIGEgZm9sbG93aW5nIGZvcm1hdDogPGJyPlxuICAgICAqICAgICA8Y29kZT57bWluSW50ZWdlckRpZ2l0c30ue21pbkZyYWN0aW9uRGlnaXRzfS17bWF4RnJhY3Rpb25EaWdpdHN9PC9jb2RlPlxuICAgICAqICAgLSBgbWluSW50ZWdlckRpZ2l0c2AgaXMgdGhlIG1pbmltdW0gbnVtYmVyIG9mIGludGVnZXIgZGlnaXRzIHRvIHVzZS4gRGVmYXVsdHMgdG8gYDFgLlxuICAgICAqICAgLSBgbWluRnJhY3Rpb25EaWdpdHNgIGlzIHRoZSBtaW5pbXVtIG51bWJlciBvZiBkaWdpdHMgYWZ0ZXIgZnJhY3Rpb24uIERlZmF1bHRzIHRvIGAwYC5cbiAgICAgKiAgIC0gYG1heEZyYWN0aW9uRGlnaXRzYCBpcyB0aGUgbWF4aW11bSBudW1iZXIgb2YgZGlnaXRzIGFmdGVyIGZyYWN0aW9uLiBEZWZhdWx0cyB0byBgM2AuXG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGUgYWNjZXB0YWJsZSByYW5nZSBmb3IgZWFjaCBvZiB0aGVzZSBudW1iZXJzIGFuZCBvdGhlclxuICAgICAqIGRldGFpbHMgc2VlIHlvdXIgbmF0aXZlIGludGVybmF0aW9uYWxpemF0aW9uIGxpYnJhcnkuXG4gICAgICpcbiAgICAgKiBXQVJOSU5HOiB0aGlzIHBpcGUgdXNlcyB0aGUgSW50ZXJuYXRpb25hbGl6YXRpb24gQVBJIHdoaWNoIGlzIG5vdCB5ZXQgYXZhaWxhYmxlIGluIGFsbCBicm93c2Vyc1xuICAgICAqIGFuZCBtYXkgcmVxdWlyZSBhIHBvbHlmaWxsLiBTZWUge0BsaW5rRG9jcyBndWlkZS9icm93c2VyLXN1cHBvcnR9IGZvciBkZXRhaWxzLlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGVcbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBjb21tb24vcGlwZXMvdHMvbnVtYmVyX3BpcGUudHMgcmVnaW9uPSdOdW1iZXJQaXBlJ31cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgRGVjaW1hbFBpcGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBEZWNpbWFsUGlwZShfbG9jYWxlKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2NhbGUgPSBfbG9jYWxlO1xuICAgICAgICB9XG4gICAgICAgIERlY2ltYWxQaXBlLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAodmFsdWUsIGRpZ2l0cykge1xuICAgICAgICAgICAgaWYgKGRpZ2l0cyA9PT0gdm9pZCAwKSB7IGRpZ2l0cyA9IG51bGw7IH1cbiAgICAgICAgICAgIHJldHVybiBmb3JtYXROdW1iZXIoRGVjaW1hbFBpcGUsIHRoaXMuX2xvY2FsZSwgdmFsdWUsIE51bWJlckZvcm1hdFN0eWxlLkRlY2ltYWwsIGRpZ2l0cyk7XG4gICAgICAgIH07XG4gICAgICAgIERlY2ltYWxQaXBlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuUGlwZSwgYXJnczogW3sgbmFtZTogJ251bWJlcicgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBEZWNpbWFsUGlwZS5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW19hbmd1bGFyX2NvcmUuTE9DQUxFX0lELF0gfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBEZWNpbWFsUGlwZTtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIEBuZ01vZHVsZSBDb21tb25Nb2R1bGVcbiAgICAgKiBAd2hhdEl0RG9lcyBGb3JtYXRzIGEgbnVtYmVyIGFzIGEgcGVyY2VudGFnZSBhY2NvcmRpbmcgdG8gbG9jYWxlIHJ1bGVzLlxuICAgICAqIEBob3dUb1VzZSBgbnVtYmVyX2V4cHJlc3Npb24gfCBwZXJjZW50WzpkaWdpdEluZm9dYFxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBGb3JtYXRzIGEgbnVtYmVyIGFzIHBlcmNlbnRhZ2UuXG4gICAgICpcbiAgICAgKiAtIGBkaWdpdEluZm9gIFNlZSB7QGxpbmsgRGVjaW1hbFBpcGV9IGZvciBkZXRhaWxlZCBkZXNjcmlwdGlvbi5cbiAgICAgKlxuICAgICAqIFdBUk5JTkc6IHRoaXMgcGlwZSB1c2VzIHRoZSBJbnRlcm5hdGlvbmFsaXphdGlvbiBBUEkgd2hpY2ggaXMgbm90IHlldCBhdmFpbGFibGUgaW4gYWxsIGJyb3dzZXJzXG4gICAgICogYW5kIG1heSByZXF1aXJlIGEgcG9seWZpbGwuIFNlZSB7QGxpbmtEb2NzIGd1aWRlL2Jyb3dzZXItc3VwcG9ydH0gZm9yIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICoge0BleGFtcGxlIGNvbW1vbi9waXBlcy90cy9udW1iZXJfcGlwZS50cyByZWdpb249J1BlcmNlbnRQaXBlJ31cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgUGVyY2VudFBpcGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBQZXJjZW50UGlwZShfbG9jYWxlKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2NhbGUgPSBfbG9jYWxlO1xuICAgICAgICB9XG4gICAgICAgIFBlcmNlbnRQaXBlLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAodmFsdWUsIGRpZ2l0cykge1xuICAgICAgICAgICAgaWYgKGRpZ2l0cyA9PT0gdm9pZCAwKSB7IGRpZ2l0cyA9IG51bGw7IH1cbiAgICAgICAgICAgIHJldHVybiBmb3JtYXROdW1iZXIoUGVyY2VudFBpcGUsIHRoaXMuX2xvY2FsZSwgdmFsdWUsIE51bWJlckZvcm1hdFN0eWxlLlBlcmNlbnQsIGRpZ2l0cyk7XG4gICAgICAgIH07XG4gICAgICAgIFBlcmNlbnRQaXBlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuUGlwZSwgYXJnczogW3sgbmFtZTogJ3BlcmNlbnQnIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgUGVyY2VudFBpcGUuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtfYW5ndWxhcl9jb3JlLkxPQ0FMRV9JRCxdIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gUGVyY2VudFBpcGU7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBAbmdNb2R1bGUgQ29tbW9uTW9kdWxlXG4gICAgICogQHdoYXRJdERvZXMgRm9ybWF0cyBhIG51bWJlciBhcyBjdXJyZW5jeSB1c2luZyBsb2NhbGUgcnVsZXMuXG4gICAgICogQGhvd1RvVXNlIGBudW1iZXJfZXhwcmVzc2lvbiB8IGN1cnJlbmN5WzpjdXJyZW5jeUNvZGVbOnN5bWJvbERpc3BsYXlbOmRpZ2l0SW5mb11dXWBcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIFVzZSBgY3VycmVuY3lgIHRvIGZvcm1hdCBhIG51bWJlciBhcyBjdXJyZW5jeS5cbiAgICAgKlxuICAgICAqIC0gYGN1cnJlbmN5Q29kZWAgaXMgdGhlIFtJU08gNDIxN10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPXzQyMTcpIGN1cnJlbmN5IGNvZGUsIHN1Y2hcbiAgICAgKiAgICBhcyBgVVNEYCBmb3IgdGhlIFVTIGRvbGxhciBhbmQgYEVVUmAgZm9yIHRoZSBldXJvLlxuICAgICAqIC0gYHN5bWJvbERpc3BsYXlgIGlzIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdG8gdXNlIHRoZSBjdXJyZW5jeSBzeW1ib2wgb3IgY29kZS5cbiAgICAgKiAgIC0gYHRydWVgOiB1c2Ugc3ltYm9sIChlLmcuIGAkYCkuXG4gICAgICogICAtIGBmYWxzZWAoZGVmYXVsdCk6IHVzZSBjb2RlIChlLmcuIGBVU0RgKS5cbiAgICAgKiAtIGBkaWdpdEluZm9gIFNlZSB7QGxpbmsgRGVjaW1hbFBpcGV9IGZvciBkZXRhaWxlZCBkZXNjcmlwdGlvbi5cbiAgICAgKlxuICAgICAqIFdBUk5JTkc6IHRoaXMgcGlwZSB1c2VzIHRoZSBJbnRlcm5hdGlvbmFsaXphdGlvbiBBUEkgd2hpY2ggaXMgbm90IHlldCBhdmFpbGFibGUgaW4gYWxsIGJyb3dzZXJzXG4gICAgICogYW5kIG1heSByZXF1aXJlIGEgcG9seWZpbGwuIFNlZSB7QGxpbmtEb2NzIGd1aWRlL2Jyb3dzZXItc3VwcG9ydH0gZm9yIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICoge0BleGFtcGxlIGNvbW1vbi9waXBlcy90cy9udW1iZXJfcGlwZS50cyByZWdpb249J0N1cnJlbmN5UGlwZSd9XG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEN1cnJlbmN5UGlwZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEN1cnJlbmN5UGlwZShfbG9jYWxlKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2NhbGUgPSBfbG9jYWxlO1xuICAgICAgICB9XG4gICAgICAgIEN1cnJlbmN5UGlwZS5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24gKHZhbHVlLCBjdXJyZW5jeUNvZGUsIHN5bWJvbERpc3BsYXksIGRpZ2l0cykge1xuICAgICAgICAgICAgaWYgKGN1cnJlbmN5Q29kZSA9PT0gdm9pZCAwKSB7IGN1cnJlbmN5Q29kZSA9ICdVU0QnOyB9XG4gICAgICAgICAgICBpZiAoc3ltYm9sRGlzcGxheSA9PT0gdm9pZCAwKSB7IHN5bWJvbERpc3BsYXkgPSBmYWxzZTsgfVxuICAgICAgICAgICAgaWYgKGRpZ2l0cyA9PT0gdm9pZCAwKSB7IGRpZ2l0cyA9IG51bGw7IH1cbiAgICAgICAgICAgIHJldHVybiBmb3JtYXROdW1iZXIoQ3VycmVuY3lQaXBlLCB0aGlzLl9sb2NhbGUsIHZhbHVlLCBOdW1iZXJGb3JtYXRTdHlsZS5DdXJyZW5jeSwgZGlnaXRzLCBjdXJyZW5jeUNvZGUsIHN5bWJvbERpc3BsYXkpO1xuICAgICAgICB9O1xuICAgICAgICBDdXJyZW5jeVBpcGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5QaXBlLCBhcmdzOiBbeyBuYW1lOiAnY3VycmVuY3knIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgQ3VycmVuY3lQaXBlLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbX2FuZ3VsYXJfY29yZS5MT0NBTEVfSUQsXSB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIEN1cnJlbmN5UGlwZTtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQG5nTW9kdWxlIENvbW1vbk1vZHVsZVxuICAgICAqIEB3aGF0SXREb2VzIENyZWF0ZXMgYSBuZXcgTGlzdCBvciBTdHJpbmcgY29udGFpbmluZyBhIHN1YnNldCAoc2xpY2UpIG9mIHRoZSBlbGVtZW50cy5cbiAgICAgKiBAaG93VG9Vc2UgYGFycmF5X29yX3N0cmluZ19leHByZXNzaW9uIHwgc2xpY2U6c3RhcnRbOmVuZF1gXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBXaGVyZSB0aGUgaW5wdXQgZXhwcmVzc2lvbiBpcyBhIGBMaXN0YCBvciBgU3RyaW5nYCwgYW5kOlxuICAgICAqIC0gYHN0YXJ0YDogVGhlIHN0YXJ0aW5nIGluZGV4IG9mIHRoZSBzdWJzZXQgdG8gcmV0dXJuLlxuICAgICAqICAgLSAqKmEgcG9zaXRpdmUgaW50ZWdlcioqOiByZXR1cm4gdGhlIGl0ZW0gYXQgYHN0YXJ0YCBpbmRleCBhbmQgYWxsIGl0ZW1zIGFmdGVyXG4gICAgICogICAgIGluIHRoZSBsaXN0IG9yIHN0cmluZyBleHByZXNzaW9uLlxuICAgICAqICAgLSAqKmEgbmVnYXRpdmUgaW50ZWdlcioqOiByZXR1cm4gdGhlIGl0ZW0gYXQgYHN0YXJ0YCBpbmRleCBmcm9tIHRoZSBlbmQgYW5kIGFsbCBpdGVtcyBhZnRlclxuICAgICAqICAgICBpbiB0aGUgbGlzdCBvciBzdHJpbmcgZXhwcmVzc2lvbi5cbiAgICAgKiAgIC0gKippZiBwb3NpdGl2ZSBhbmQgZ3JlYXRlciB0aGFuIHRoZSBzaXplIG9mIHRoZSBleHByZXNzaW9uKio6IHJldHVybiBhbiBlbXB0eSBsaXN0IG9yIHN0cmluZy5cbiAgICAgKiAgIC0gKippZiBuZWdhdGl2ZSBhbmQgZ3JlYXRlciB0aGFuIHRoZSBzaXplIG9mIHRoZSBleHByZXNzaW9uKio6IHJldHVybiBlbnRpcmUgbGlzdCBvciBzdHJpbmcuXG4gICAgICogLSBgZW5kYDogVGhlIGVuZGluZyBpbmRleCBvZiB0aGUgc3Vic2V0IHRvIHJldHVybi5cbiAgICAgKiAgIC0gKipvbWl0dGVkKio6IHJldHVybiBhbGwgaXRlbXMgdW50aWwgdGhlIGVuZC5cbiAgICAgKiAgIC0gKippZiBwb3NpdGl2ZSoqOiByZXR1cm4gYWxsIGl0ZW1zIGJlZm9yZSBgZW5kYCBpbmRleCBvZiB0aGUgbGlzdCBvciBzdHJpbmcuXG4gICAgICogICAtICoqaWYgbmVnYXRpdmUqKjogcmV0dXJuIGFsbCBpdGVtcyBiZWZvcmUgYGVuZGAgaW5kZXggZnJvbSB0aGUgZW5kIG9mIHRoZSBsaXN0IG9yIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEFsbCBiZWhhdmlvciBpcyBiYXNlZCBvbiB0aGUgZXhwZWN0ZWQgYmVoYXZpb3Igb2YgdGhlIEphdmFTY3JpcHQgQVBJIGBBcnJheS5wcm90b3R5cGUuc2xpY2UoKWBcbiAgICAgKiBhbmQgYFN0cmluZy5wcm90b3R5cGUuc2xpY2UoKWAuXG4gICAgICpcbiAgICAgKiBXaGVuIG9wZXJhdGluZyBvbiBhIFtMaXN0XSwgdGhlIHJldHVybmVkIGxpc3QgaXMgYWx3YXlzIGEgY29weSBldmVuIHdoZW4gYWxsXG4gICAgICogdGhlIGVsZW1lbnRzIGFyZSBiZWluZyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIFdoZW4gb3BlcmF0aW5nIG9uIGEgYmxhbmsgdmFsdWUsIHRoZSBwaXBlIHJldHVybnMgdGhlIGJsYW5rIHZhbHVlLlxuICAgICAqXG4gICAgICogIyMgTGlzdCBFeGFtcGxlXG4gICAgICpcbiAgICAgKiBUaGlzIGBuZ0ZvcmAgZXhhbXBsZTpcbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBjb21tb24vcGlwZXMvdHMvc2xpY2VfcGlwZS50cyByZWdpb249J1NsaWNlUGlwZV9saXN0J31cbiAgICAgKlxuICAgICAqIHByb2R1Y2VzIHRoZSBmb2xsb3dpbmc6XG4gICAgICpcbiAgICAgKiAgICAgPGxpPmI8L2xpPlxuICAgICAqICAgICA8bGk+YzwvbGk+XG4gICAgICpcbiAgICAgKiAjIyBTdHJpbmcgRXhhbXBsZXNcbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBjb21tb24vcGlwZXMvdHMvc2xpY2VfcGlwZS50cyByZWdpb249J1NsaWNlUGlwZV9zdHJpbmcnfVxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBTbGljZVBpcGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBTbGljZVBpcGUoKSB7XG4gICAgICAgIH1cbiAgICAgICAgU2xpY2VQaXBlLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAodmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgICAgIGlmIChpc0JsYW5rKHZhbHVlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc3VwcG9ydHModmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRQaXBlQXJndW1lbnRFcnJvcihTbGljZVBpcGUsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgICAgfTtcbiAgICAgICAgU2xpY2VQaXBlLnByb3RvdHlwZS5zdXBwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdzdHJpbmcnIHx8IEFycmF5LmlzQXJyYXkob2JqKTsgfTtcbiAgICAgICAgU2xpY2VQaXBlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuUGlwZSwgYXJnczogW3sgbmFtZTogJ3NsaWNlJywgcHVyZTogZmFsc2UgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBTbGljZVBpcGUuY3RvclBhcmFtZXRlcnMgPSBbXTtcbiAgICAgICAgcmV0dXJuIFNsaWNlUGlwZTtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQG5nTW9kdWxlIENvbW1vbk1vZHVsZVxuICAgICAqIEB3aGF0SXREb2VzIFRyYW5zZm9ybXMgc3RyaW5nIHRvIHVwcGVyY2FzZS5cbiAgICAgKiBAaG93VG9Vc2UgYGV4cHJlc3Npb24gfCB1cHBlcmNhc2VgXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBDb252ZXJ0cyB2YWx1ZSBpbnRvIGxvd2VyY2FzZSBzdHJpbmcgdXNpbmcgYFN0cmluZy5wcm90b3R5cGUudG9VcHBlckNhc2UoKWAuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICoge0BleGFtcGxlIGNvbW1vbi9waXBlcy90cy9sb3dlcnVwcGVyX3BpcGUudHMgcmVnaW9uPSdMb3dlclVwcGVyUGlwZSd9XG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIFVwcGVyQ2FzZVBpcGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBVcHBlckNhc2VQaXBlKCkge1xuICAgICAgICB9XG4gICAgICAgIFVwcGVyQ2FzZVBpcGUucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGlzQmxhbmsodmFsdWUpKVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRQaXBlQXJndW1lbnRFcnJvcihVcHBlckNhc2VQaXBlLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudG9VcHBlckNhc2UoKTtcbiAgICAgICAgfTtcbiAgICAgICAgVXBwZXJDYXNlUGlwZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlBpcGUsIGFyZ3M6IFt7IG5hbWU6ICd1cHBlcmNhc2UnIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgVXBwZXJDYXNlUGlwZS5jdG9yUGFyYW1ldGVycyA9IFtdO1xuICAgICAgICByZXR1cm4gVXBwZXJDYXNlUGlwZTtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQSBjb2xsZWN0aW9uIG9mIEFuZ3VsYXIgcGlwZXMgdGhhdCBhcmUgbGlrZWx5IHRvIGJlIHVzZWQgaW4gZWFjaCBhbmQgZXZlcnkgYXBwbGljYXRpb24uXG4gICAgICovXG4gICAgdmFyIENPTU1PTl9QSVBFUyA9IFtcbiAgICAgICAgQXN5bmNQaXBlLFxuICAgICAgICBVcHBlckNhc2VQaXBlLFxuICAgICAgICBMb3dlckNhc2VQaXBlLFxuICAgICAgICBKc29uUGlwZSxcbiAgICAgICAgU2xpY2VQaXBlLFxuICAgICAgICBEZWNpbWFsUGlwZSxcbiAgICAgICAgUGVyY2VudFBpcGUsXG4gICAgICAgIEN1cnJlbmN5UGlwZSxcbiAgICAgICAgRGF0ZVBpcGUsXG4gICAgICAgIEkxOG5QbHVyYWxQaXBlLFxuICAgICAgICBJMThuU2VsZWN0UGlwZSxcbiAgICBdO1xuXG4gICAgLy8gTm90ZTogVGhpcyBkb2VzIG5vdCBjb250YWluIHRoZSBsb2NhdGlvbiBwcm92aWRlcnMsXG4gICAgLy8gYXMgdGhleSBuZWVkIHNvbWUgcGxhdGZvcm0gc3BlY2lmaWMgaW1wbGVtZW50YXRpb25zIHRvIHdvcmsuXG4gICAgLyoqXG4gICAgICogVGhlIG1vZHVsZSB0aGF0IGluY2x1ZGVzIGFsbCB0aGUgYmFzaWMgQW5ndWxhciBkaXJlY3RpdmVzIGxpa2Uge0BsaW5rIE5nSWZ9LCB7QGxpbmsgTmdGb3J9LCAuLi5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgQ29tbW9uTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQ29tbW9uTW9kdWxlKCkge1xuICAgICAgICB9XG4gICAgICAgIENvbW1vbk1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbQ09NTU9OX0RJUkVDVElWRVMsIENPTU1PTl9QSVBFU10sXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBvcnRzOiBbQ09NTU9OX0RJUkVDVElWRVMsIENPTU1PTl9QSVBFU10sXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IE5nTG9jYWxpemF0aW9uLCB1c2VDbGFzczogTmdMb2NhbGVMb2NhbGl6YXRpb24gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgQ29tbW9uTW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gW107XG4gICAgICAgIHJldHVybiBDb21tb25Nb2R1bGU7XG4gICAgfSgpKTtcblxuICAgIGV4cG9ydHMuTmdMb2NhbGl6YXRpb24gPSBOZ0xvY2FsaXphdGlvbjtcbiAgICBleHBvcnRzLkNvbW1vbk1vZHVsZSA9IENvbW1vbk1vZHVsZTtcbiAgICBleHBvcnRzLk5nQ2xhc3MgPSBOZ0NsYXNzO1xuICAgIGV4cG9ydHMuTmdGb3IgPSBOZ0ZvcjtcbiAgICBleHBvcnRzLk5nSWYgPSBOZ0lmO1xuICAgIGV4cG9ydHMuTmdQbHVyYWwgPSBOZ1BsdXJhbDtcbiAgICBleHBvcnRzLk5nUGx1cmFsQ2FzZSA9IE5nUGx1cmFsQ2FzZTtcbiAgICBleHBvcnRzLk5nU3R5bGUgPSBOZ1N0eWxlO1xuICAgIGV4cG9ydHMuTmdTd2l0Y2ggPSBOZ1N3aXRjaDtcbiAgICBleHBvcnRzLk5nU3dpdGNoQ2FzZSA9IE5nU3dpdGNoQ2FzZTtcbiAgICBleHBvcnRzLk5nU3dpdGNoRGVmYXVsdCA9IE5nU3dpdGNoRGVmYXVsdDtcbiAgICBleHBvcnRzLk5nVGVtcGxhdGVPdXRsZXQgPSBOZ1RlbXBsYXRlT3V0bGV0O1xuICAgIGV4cG9ydHMuQXN5bmNQaXBlID0gQXN5bmNQaXBlO1xuICAgIGV4cG9ydHMuRGF0ZVBpcGUgPSBEYXRlUGlwZTtcbiAgICBleHBvcnRzLkkxOG5QbHVyYWxQaXBlID0gSTE4blBsdXJhbFBpcGU7XG4gICAgZXhwb3J0cy5JMThuU2VsZWN0UGlwZSA9IEkxOG5TZWxlY3RQaXBlO1xuICAgIGV4cG9ydHMuSnNvblBpcGUgPSBKc29uUGlwZTtcbiAgICBleHBvcnRzLkxvd2VyQ2FzZVBpcGUgPSBMb3dlckNhc2VQaXBlO1xuICAgIGV4cG9ydHMuQ3VycmVuY3lQaXBlID0gQ3VycmVuY3lQaXBlO1xuICAgIGV4cG9ydHMuRGVjaW1hbFBpcGUgPSBEZWNpbWFsUGlwZTtcbiAgICBleHBvcnRzLlBlcmNlbnRQaXBlID0gUGVyY2VudFBpcGU7XG4gICAgZXhwb3J0cy5TbGljZVBpcGUgPSBTbGljZVBpcGU7XG4gICAgZXhwb3J0cy5VcHBlckNhc2VQaXBlID0gVXBwZXJDYXNlUGlwZTtcbiAgICBleHBvcnRzLlBsYXRmb3JtTG9jYXRpb24gPSBQbGF0Zm9ybUxvY2F0aW9uO1xuICAgIGV4cG9ydHMuTG9jYXRpb25TdHJhdGVneSA9IExvY2F0aW9uU3RyYXRlZ3k7XG4gICAgZXhwb3J0cy5BUFBfQkFTRV9IUkVGID0gQVBQX0JBU0VfSFJFRjtcbiAgICBleHBvcnRzLkhhc2hMb2NhdGlvblN0cmF0ZWd5ID0gSGFzaExvY2F0aW9uU3RyYXRlZ3k7XG4gICAgZXhwb3J0cy5QYXRoTG9jYXRpb25TdHJhdGVneSA9IFBhdGhMb2NhdGlvblN0cmF0ZWd5O1xuICAgIGV4cG9ydHMuTG9jYXRpb24gPSBMb2NhdGlvbjtcblxufSkpO1xuIiwiLyoqXG4gKiBAbGljZW5zZSBBbmd1bGFyIHYyLjEuMVxuICogKGMpIDIwMTAtMjAxNiBHb29nbGUsIEluYy4gaHR0cHM6Ly9hbmd1bGFyLmlvL1xuICogTGljZW5zZTogTUlUXG4gKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cywgcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnLCAnQGFuZ3VsYXIvY29yZSddLCBmYWN0b3J5KSA6XG4gIChmYWN0b3J5KChnbG9iYWwubmcgPSBnbG9iYWwubmcgfHwge30sIGdsb2JhbC5uZy5jb21waWxlciA9IGdsb2JhbC5uZy5jb21waWxlciB8fCB7fSksZ2xvYmFsLm5nLmNvcmUpKTtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMsX2FuZ3VsYXJfY29yZSkgeyAndXNlIHN0cmljdCc7XG5cbiAgLyoqXG4gICAqIEBsaWNlbnNlXG4gICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgKlxuICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAqL1xuICAvKipcbiAgICogQSBzZWdtZW50IG9mIHRleHQgd2l0aGluIHRoZSB0ZW1wbGF0ZS5cbiAgICovXG4gIHZhciBUZXh0QXN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFRleHRBc3QodmFsdWUsIG5nQ29udGVudEluZGV4LCBzb3VyY2VTcGFuKSB7XG4gICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIHRoaXMubmdDb250ZW50SW5kZXggPSBuZ0NvbnRlbnRJbmRleDtcbiAgICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgfVxuICAgICAgVGV4dEFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdFRleHQodGhpcywgY29udGV4dCk7IH07XG4gICAgICByZXR1cm4gVGV4dEFzdDtcbiAgfSgpKTtcbiAgLyoqXG4gICAqIEEgYm91bmQgZXhwcmVzc2lvbiB3aXRoaW4gdGhlIHRleHQgb2YgYSB0ZW1wbGF0ZS5cbiAgICovXG4gIHZhciBCb3VuZFRleHRBc3QgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQm91bmRUZXh0QXN0KHZhbHVlLCBuZ0NvbnRlbnRJbmRleCwgc291cmNlU3Bhbikge1xuICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICB0aGlzLm5nQ29udGVudEluZGV4ID0gbmdDb250ZW50SW5kZXg7XG4gICAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgIH1cbiAgICAgIEJvdW5kVGV4dEFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Qm91bmRUZXh0KHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBCb3VuZFRleHRBc3Q7XG4gIH0oKSk7XG4gIC8qKlxuICAgKiBBIHBsYWluIGF0dHJpYnV0ZSBvbiBhbiBlbGVtZW50LlxuICAgKi9cbiAgdmFyIEF0dHJBc3QgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQXR0ckFzdChuYW1lLCB2YWx1ZSwgc291cmNlU3Bhbikge1xuICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICB9XG4gICAgICBBdHRyQXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7IHJldHVybiB2aXNpdG9yLnZpc2l0QXR0cih0aGlzLCBjb250ZXh0KTsgfTtcbiAgICAgIHJldHVybiBBdHRyQXN0O1xuICB9KCkpO1xuICAvKipcbiAgICogQSBiaW5kaW5nIGZvciBhbiBlbGVtZW50IHByb3BlcnR5IChlLmcuIGBbcHJvcGVydHldPVwiZXhwcmVzc2lvblwiYCkgb3IgYW4gYW5pbWF0aW9uIHRyaWdnZXIgKGUuZy5cbiAgICogYFtAdHJpZ2dlcl09XCJzdGF0ZUV4cFwiYClcbiAgICovXG4gIHZhciBCb3VuZEVsZW1lbnRQcm9wZXJ0eUFzdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBCb3VuZEVsZW1lbnRQcm9wZXJ0eUFzdChuYW1lLCB0eXBlLCBzZWN1cml0eUNvbnRleHQsIHZhbHVlLCB1bml0LCBzb3VyY2VTcGFuKSB7XG4gICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICAgIHRoaXMuc2VjdXJpdHlDb250ZXh0ID0gc2VjdXJpdHlDb250ZXh0O1xuICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICB0aGlzLnVuaXQgPSB1bml0O1xuICAgICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICB9XG4gICAgICBCb3VuZEVsZW1lbnRQcm9wZXJ0eUFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RWxlbWVudFByb3BlcnR5KHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCb3VuZEVsZW1lbnRQcm9wZXJ0eUFzdC5wcm90b3R5cGUsIFwiaXNBbmltYXRpb25cIiwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50eXBlID09PSBleHBvcnRzLlByb3BlcnR5QmluZGluZ1R5cGUuQW5pbWF0aW9uOyB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBCb3VuZEVsZW1lbnRQcm9wZXJ0eUFzdDtcbiAgfSgpKTtcbiAgLyoqXG4gICAqIEEgYmluZGluZyBmb3IgYW4gZWxlbWVudCBldmVudCAoZS5nLiBgKGV2ZW50KT1cImhhbmRsZXIoKVwiYCkgb3IgYW4gYW5pbWF0aW9uIHRyaWdnZXIgZXZlbnQgKGUuZy5cbiAgICogYChAdHJpZ2dlci5waGFzZSk9XCJjYWxsYmFjaygkZXZlbnQpXCJgKS5cbiAgICovXG4gIHZhciBCb3VuZEV2ZW50QXN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIEJvdW5kRXZlbnRBc3QobmFtZSwgdGFyZ2V0LCBwaGFzZSwgaGFuZGxlciwgc291cmNlU3Bhbikge1xuICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgICAgdGhpcy5waGFzZSA9IHBoYXNlO1xuICAgICAgICAgIHRoaXMuaGFuZGxlciA9IGhhbmRsZXI7XG4gICAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgIH1cbiAgICAgIEJvdW5kRXZlbnRBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEV2ZW50KHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCb3VuZEV2ZW50QXN0LnByb3RvdHlwZSwgXCJmdWxsTmFtZVwiLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLnRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudGFyZ2V0ICsgXCI6XCIgKyB0aGlzLm5hbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQm91bmRFdmVudEFzdC5wcm90b3R5cGUsIFwiaXNBbmltYXRpb25cIiwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gISF0aGlzLnBoYXNlOyB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBCb3VuZEV2ZW50QXN0O1xuICB9KCkpO1xuICAvKipcbiAgICogQSByZWZlcmVuY2UgZGVjbGFyYXRpb24gb24gYW4gZWxlbWVudCAoZS5nLiBgbGV0IHNvbWVOYW1lPVwiZXhwcmVzc2lvblwiYCkuXG4gICAqL1xuICB2YXIgUmVmZXJlbmNlQXN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFJlZmVyZW5jZUFzdChuYW1lLCB2YWx1ZSwgc291cmNlU3Bhbikge1xuICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICB9XG4gICAgICBSZWZlcmVuY2VBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFJlZmVyZW5jZSh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gUmVmZXJlbmNlQXN0O1xuICB9KCkpO1xuICAvKipcbiAgICogQSB2YXJpYWJsZSBkZWNsYXJhdGlvbiBvbiBhIDx0ZW1wbGF0ZT4gKGUuZy4gYHZhci1zb21lTmFtZT1cInNvbWVMb2NhbE5hbWVcImApLlxuICAgKi9cbiAgdmFyIFZhcmlhYmxlQXN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFZhcmlhYmxlQXN0KG5hbWUsIHZhbHVlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgIH1cbiAgICAgIFZhcmlhYmxlQXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRWYXJpYWJsZSh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gVmFyaWFibGVBc3Q7XG4gIH0oKSk7XG4gIC8qKlxuICAgKiBBbiBlbGVtZW50IGRlY2xhcmF0aW9uIGluIGEgdGVtcGxhdGUuXG4gICAqL1xuICB2YXIgRWxlbWVudEFzdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBFbGVtZW50QXN0KG5hbWUsIGF0dHJzLCBpbnB1dHMsIG91dHB1dHMsIHJlZmVyZW5jZXMsIGRpcmVjdGl2ZXMsIHByb3ZpZGVycywgaGFzVmlld0NvbnRhaW5lciwgY2hpbGRyZW4sIG5nQ29udGVudEluZGV4LCBzb3VyY2VTcGFuLCBlbmRTb3VyY2VTcGFuKSB7XG4gICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICB0aGlzLmF0dHJzID0gYXR0cnM7XG4gICAgICAgICAgdGhpcy5pbnB1dHMgPSBpbnB1dHM7XG4gICAgICAgICAgdGhpcy5vdXRwdXRzID0gb3V0cHV0cztcbiAgICAgICAgICB0aGlzLnJlZmVyZW5jZXMgPSByZWZlcmVuY2VzO1xuICAgICAgICAgIHRoaXMuZGlyZWN0aXZlcyA9IGRpcmVjdGl2ZXM7XG4gICAgICAgICAgdGhpcy5wcm92aWRlcnMgPSBwcm92aWRlcnM7XG4gICAgICAgICAgdGhpcy5oYXNWaWV3Q29udGFpbmVyID0gaGFzVmlld0NvbnRhaW5lcjtcbiAgICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgICAgdGhpcy5uZ0NvbnRlbnRJbmRleCA9IG5nQ29udGVudEluZGV4O1xuICAgICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICAgICAgdGhpcy5lbmRTb3VyY2VTcGFuID0gZW5kU291cmNlU3BhbjtcbiAgICAgIH1cbiAgICAgIEVsZW1lbnRBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEVsZW1lbnQodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIEVsZW1lbnRBc3Q7XG4gIH0oKSk7XG4gIC8qKlxuICAgKiBBIGA8dGVtcGxhdGU+YCBlbGVtZW50IGluY2x1ZGVkIGluIGFuIEFuZ3VsYXIgdGVtcGxhdGUuXG4gICAqL1xuICB2YXIgRW1iZWRkZWRUZW1wbGF0ZUFzdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBFbWJlZGRlZFRlbXBsYXRlQXN0KGF0dHJzLCBvdXRwdXRzLCByZWZlcmVuY2VzLCB2YXJpYWJsZXMsIGRpcmVjdGl2ZXMsIHByb3ZpZGVycywgaGFzVmlld0NvbnRhaW5lciwgY2hpbGRyZW4sIG5nQ29udGVudEluZGV4LCBzb3VyY2VTcGFuKSB7XG4gICAgICAgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgICAgICAgIHRoaXMub3V0cHV0cyA9IG91dHB1dHM7XG4gICAgICAgICAgdGhpcy5yZWZlcmVuY2VzID0gcmVmZXJlbmNlcztcbiAgICAgICAgICB0aGlzLnZhcmlhYmxlcyA9IHZhcmlhYmxlcztcbiAgICAgICAgICB0aGlzLmRpcmVjdGl2ZXMgPSBkaXJlY3RpdmVzO1xuICAgICAgICAgIHRoaXMucHJvdmlkZXJzID0gcHJvdmlkZXJzO1xuICAgICAgICAgIHRoaXMuaGFzVmlld0NvbnRhaW5lciA9IGhhc1ZpZXdDb250YWluZXI7XG4gICAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICAgIHRoaXMubmdDb250ZW50SW5kZXggPSBuZ0NvbnRlbnRJbmRleDtcbiAgICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgfVxuICAgICAgRW1iZWRkZWRUZW1wbGF0ZUFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RW1iZWRkZWRUZW1wbGF0ZSh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gRW1iZWRkZWRUZW1wbGF0ZUFzdDtcbiAgfSgpKTtcbiAgLyoqXG4gICAqIEEgZGlyZWN0aXZlIHByb3BlcnR5IHdpdGggYSBib3VuZCB2YWx1ZSAoZS5nLiBgKm5nSWY9XCJjb25kaXRpb25cIikuXG4gICAqL1xuICB2YXIgQm91bmREaXJlY3RpdmVQcm9wZXJ0eUFzdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBCb3VuZERpcmVjdGl2ZVByb3BlcnR5QXN0KGRpcmVjdGl2ZU5hbWUsIHRlbXBsYXRlTmFtZSwgdmFsdWUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgICB0aGlzLmRpcmVjdGl2ZU5hbWUgPSBkaXJlY3RpdmVOYW1lO1xuICAgICAgICAgIHRoaXMudGVtcGxhdGVOYW1lID0gdGVtcGxhdGVOYW1lO1xuICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgfVxuICAgICAgQm91bmREaXJlY3RpdmVQcm9wZXJ0eUFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RGlyZWN0aXZlUHJvcGVydHkodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIEJvdW5kRGlyZWN0aXZlUHJvcGVydHlBc3Q7XG4gIH0oKSk7XG4gIC8qKlxuICAgKiBBIGRpcmVjdGl2ZSBkZWNsYXJlZCBvbiBhbiBlbGVtZW50LlxuICAgKi9cbiAgdmFyIERpcmVjdGl2ZUFzdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBEaXJlY3RpdmVBc3QoZGlyZWN0aXZlLCBpbnB1dHMsIGhvc3RQcm9wZXJ0aWVzLCBob3N0RXZlbnRzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgICAgdGhpcy5kaXJlY3RpdmUgPSBkaXJlY3RpdmU7XG4gICAgICAgICAgdGhpcy5pbnB1dHMgPSBpbnB1dHM7XG4gICAgICAgICAgdGhpcy5ob3N0UHJvcGVydGllcyA9IGhvc3RQcm9wZXJ0aWVzO1xuICAgICAgICAgIHRoaXMuaG9zdEV2ZW50cyA9IGhvc3RFdmVudHM7XG4gICAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgIH1cbiAgICAgIERpcmVjdGl2ZUFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RGlyZWN0aXZlKHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBEaXJlY3RpdmVBc3Q7XG4gIH0oKSk7XG4gIC8qKlxuICAgKiBBIHByb3ZpZGVyIGRlY2xhcmVkIG9uIGFuIGVsZW1lbnRcbiAgICovXG4gIHZhciBQcm92aWRlckFzdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBQcm92aWRlckFzdCh0b2tlbiwgbXVsdGlQcm92aWRlciwgZWFnZXIsIHByb3ZpZGVycywgcHJvdmlkZXJUeXBlLCBsaWZlY3ljbGVIb29rcywgc291cmNlU3Bhbikge1xuICAgICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICB0aGlzLm11bHRpUHJvdmlkZXIgPSBtdWx0aVByb3ZpZGVyO1xuICAgICAgICAgIHRoaXMuZWFnZXIgPSBlYWdlcjtcbiAgICAgICAgICB0aGlzLnByb3ZpZGVycyA9IHByb3ZpZGVycztcbiAgICAgICAgICB0aGlzLnByb3ZpZGVyVHlwZSA9IHByb3ZpZGVyVHlwZTtcbiAgICAgICAgICB0aGlzLmxpZmVjeWNsZUhvb2tzID0gbGlmZWN5Y2xlSG9va3M7XG4gICAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgIH1cbiAgICAgIFByb3ZpZGVyQXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgLy8gTm8gdmlzaXQgbWV0aG9kIGluIHRoZSB2aXNpdG9yIGZvciBub3cuLi5cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICByZXR1cm4gUHJvdmlkZXJBc3Q7XG4gIH0oKSk7XG4gIGV4cG9ydHMuUHJvdmlkZXJBc3RUeXBlO1xuICAoZnVuY3Rpb24gKFByb3ZpZGVyQXN0VHlwZSkge1xuICAgICAgUHJvdmlkZXJBc3RUeXBlW1Byb3ZpZGVyQXN0VHlwZVtcIlB1YmxpY1NlcnZpY2VcIl0gPSAwXSA9IFwiUHVibGljU2VydmljZVwiO1xuICAgICAgUHJvdmlkZXJBc3RUeXBlW1Byb3ZpZGVyQXN0VHlwZVtcIlByaXZhdGVTZXJ2aWNlXCJdID0gMV0gPSBcIlByaXZhdGVTZXJ2aWNlXCI7XG4gICAgICBQcm92aWRlckFzdFR5cGVbUHJvdmlkZXJBc3RUeXBlW1wiQ29tcG9uZW50XCJdID0gMl0gPSBcIkNvbXBvbmVudFwiO1xuICAgICAgUHJvdmlkZXJBc3RUeXBlW1Byb3ZpZGVyQXN0VHlwZVtcIkRpcmVjdGl2ZVwiXSA9IDNdID0gXCJEaXJlY3RpdmVcIjtcbiAgICAgIFByb3ZpZGVyQXN0VHlwZVtQcm92aWRlckFzdFR5cGVbXCJCdWlsdGluXCJdID0gNF0gPSBcIkJ1aWx0aW5cIjtcbiAgfSkoZXhwb3J0cy5Qcm92aWRlckFzdFR5cGUgfHwgKGV4cG9ydHMuUHJvdmlkZXJBc3RUeXBlID0ge30pKTtcbiAgLyoqXG4gICAqIFBvc2l0aW9uIHdoZXJlIGNvbnRlbnQgaXMgdG8gYmUgcHJvamVjdGVkIChpbnN0YW5jZSBvZiBgPG5nLWNvbnRlbnQ+YCBpbiBhIHRlbXBsYXRlKS5cbiAgICovXG4gIHZhciBOZ0NvbnRlbnRBc3QgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gTmdDb250ZW50QXN0KGluZGV4LCBuZ0NvbnRlbnRJbmRleCwgc291cmNlU3Bhbikge1xuICAgICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgICB0aGlzLm5nQ29udGVudEluZGV4ID0gbmdDb250ZW50SW5kZXg7XG4gICAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgIH1cbiAgICAgIE5nQ29udGVudEFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0TmdDb250ZW50KHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBOZ0NvbnRlbnRBc3Q7XG4gIH0oKSk7XG4gIC8qKlxuICAgKiBFbnVtZXJhdGlvbiBvZiB0eXBlcyBvZiBwcm9wZXJ0eSBiaW5kaW5ncy5cbiAgICovXG4gIGV4cG9ydHMuUHJvcGVydHlCaW5kaW5nVHlwZTtcbiAgKGZ1bmN0aW9uIChQcm9wZXJ0eUJpbmRpbmdUeXBlKSB7XG4gICAgICAvKipcbiAgICAgICAqIEEgbm9ybWFsIGJpbmRpbmcgdG8gYSBwcm9wZXJ0eSAoZS5nLiBgW3Byb3BlcnR5XT1cImV4cHJlc3Npb25cImApLlxuICAgICAgICovXG4gICAgICBQcm9wZXJ0eUJpbmRpbmdUeXBlW1Byb3BlcnR5QmluZGluZ1R5cGVbXCJQcm9wZXJ0eVwiXSA9IDBdID0gXCJQcm9wZXJ0eVwiO1xuICAgICAgLyoqXG4gICAgICAgKiBBIGJpbmRpbmcgdG8gYW4gZWxlbWVudCBhdHRyaWJ1dGUgKGUuZy4gYFthdHRyLm5hbWVdPVwiZXhwcmVzc2lvblwiYCkuXG4gICAgICAgKi9cbiAgICAgIFByb3BlcnR5QmluZGluZ1R5cGVbUHJvcGVydHlCaW5kaW5nVHlwZVtcIkF0dHJpYnV0ZVwiXSA9IDFdID0gXCJBdHRyaWJ1dGVcIjtcbiAgICAgIC8qKlxuICAgICAgICogQSBiaW5kaW5nIHRvIGEgQ1NTIGNsYXNzIChlLmcuIGBbY2xhc3MubmFtZV09XCJjb25kaXRpb25cImApLlxuICAgICAgICovXG4gICAgICBQcm9wZXJ0eUJpbmRpbmdUeXBlW1Byb3BlcnR5QmluZGluZ1R5cGVbXCJDbGFzc1wiXSA9IDJdID0gXCJDbGFzc1wiO1xuICAgICAgLyoqXG4gICAgICAgKiBBIGJpbmRpbmcgdG8gYSBzdHlsZSBydWxlIChlLmcuIGBbc3R5bGUucnVsZV09XCJleHByZXNzaW9uXCJgKS5cbiAgICAgICAqL1xuICAgICAgUHJvcGVydHlCaW5kaW5nVHlwZVtQcm9wZXJ0eUJpbmRpbmdUeXBlW1wiU3R5bGVcIl0gPSAzXSA9IFwiU3R5bGVcIjtcbiAgICAgIC8qKlxuICAgICAgICogQSBiaW5kaW5nIHRvIGFuIGFuaW1hdGlvbiByZWZlcmVuY2UgKGUuZy4gYFthbmltYXRlLmtleV09XCJleHByZXNzaW9uXCJgKS5cbiAgICAgICAqL1xuICAgICAgUHJvcGVydHlCaW5kaW5nVHlwZVtQcm9wZXJ0eUJpbmRpbmdUeXBlW1wiQW5pbWF0aW9uXCJdID0gNF0gPSBcIkFuaW1hdGlvblwiO1xuICB9KShleHBvcnRzLlByb3BlcnR5QmluZGluZ1R5cGUgfHwgKGV4cG9ydHMuUHJvcGVydHlCaW5kaW5nVHlwZSA9IHt9KSk7XG4gIC8qKlxuICAgKiBWaXNpdCBldmVyeSBub2RlIGluIGEgbGlzdCBvZiB7QGxpbmsgVGVtcGxhdGVBc3R9cyB3aXRoIHRoZSBnaXZlbiB7QGxpbmsgVGVtcGxhdGVBc3RWaXNpdG9yfS5cbiAgICovXG4gIGZ1bmN0aW9uIHRlbXBsYXRlVmlzaXRBbGwodmlzaXRvciwgYXN0cywgY29udGV4dCkge1xuICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgdmFyIHZpc2l0ID0gdmlzaXRvci52aXNpdCA/XG4gICAgICAgICAgZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gdmlzaXRvci52aXNpdChhc3QsIGNvbnRleHQpIHx8IGFzdC52aXNpdCh2aXNpdG9yLCBjb250ZXh0KTsgfSA6XG4gICAgICAgICAgZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gYXN0LnZpc2l0KHZpc2l0b3IsIGNvbnRleHQpOyB9O1xuICAgICAgYXN0cy5mb3JFYWNoKGZ1bmN0aW9uIChhc3QpIHtcbiAgICAgICAgICB2YXIgYXN0UmVzdWx0ID0gdmlzaXQoYXN0KTtcbiAgICAgICAgICBpZiAoYXN0UmVzdWx0KSB7XG4gICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFzdFJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gaXNQcmVzZW50KG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAhPT0gdW5kZWZpbmVkICYmIG9iaiAhPT0gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBpc0JsYW5rKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA9PT0gdW5kZWZpbmVkIHx8IG9iaiA9PT0gbnVsbDtcbiAgfVxuICB2YXIgU1RSSU5HX01BUF9QUk9UTyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih7fSk7XG4gIGZ1bmN0aW9uIGlzU3RyaWN0U3RyaW5nTWFwKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iaiAhPT0gbnVsbCAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKSA9PT0gU1RSSU5HX01BUF9QUk9UTztcbiAgfVxuICBmdW5jdGlvbiBzdHJpbmdpZnkodG9rZW4pIHtcbiAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgfVxuICAgICAgaWYgKHRva2VuID09PSB1bmRlZmluZWQgfHwgdG9rZW4gPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gJycgKyB0b2tlbjtcbiAgICAgIH1cbiAgICAgIGlmICh0b2tlbi5vdmVycmlkZGVuTmFtZSkge1xuICAgICAgICAgIHJldHVybiB0b2tlbi5vdmVycmlkZGVuTmFtZTtcbiAgICAgIH1cbiAgICAgIGlmICh0b2tlbi5uYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIHRva2VuLm5hbWU7XG4gICAgICB9XG4gICAgICB2YXIgcmVzID0gdG9rZW4udG9TdHJpbmcoKTtcbiAgICAgIHZhciBuZXdMaW5lSW5kZXggPSByZXMuaW5kZXhPZignXFxuJyk7XG4gICAgICByZXR1cm4gbmV3TGluZUluZGV4ID09PSAtMSA/IHJlcyA6IHJlcy5zdWJzdHJpbmcoMCwgbmV3TGluZUluZGV4KTtcbiAgfVxuICB2YXIgTnVtYmVyV3JhcHBlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBOdW1iZXJXcmFwcGVyKCkge1xuICAgICAgfVxuICAgICAgTnVtYmVyV3JhcHBlci5wYXJzZUludEF1dG9SYWRpeCA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlSW50KHRleHQpO1xuICAgICAgICAgIGlmIChpc05hTihyZXN1bHQpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnRlZ2VyIGxpdGVyYWwgd2hlbiBwYXJzaW5nICcgKyB0ZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgICBOdW1iZXJXcmFwcGVyLnBhcnNlSW50ID0gZnVuY3Rpb24gKHRleHQsIHJhZGl4KSB7XG4gICAgICAgICAgaWYgKHJhZGl4ID09IDEwKSB7XG4gICAgICAgICAgICAgIGlmICgvXihcXC18XFwrKT9bMC05XSskLy50ZXN0KHRleHQpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQodGV4dCwgcmFkaXgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKHJhZGl4ID09IDE2KSB7XG4gICAgICAgICAgICAgIGlmICgvXihcXC18XFwrKT9bMC05QUJDREVGYWJjZGVmXSskLy50ZXN0KHRleHQpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQodGV4dCwgcmFkaXgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gcGFyc2VJbnQodGV4dCwgcmFkaXgpO1xuICAgICAgICAgICAgICBpZiAoIWlzTmFOKHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGludGVnZXIgbGl0ZXJhbCB3aGVuIHBhcnNpbmcgJyArIHRleHQgKyAnIGluIGJhc2UgJyArIHJhZGl4KTtcbiAgICAgIH07XG4gICAgICBOdW1iZXJXcmFwcGVyLmlzTnVtZXJpYyA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gIWlzTmFOKHZhbHVlIC0gcGFyc2VGbG9hdCh2YWx1ZSkpOyB9O1xuICAgICAgcmV0dXJuIE51bWJlcldyYXBwZXI7XG4gIH0oKSk7XG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZUJsYW5rKG9iaikge1xuICAgICAgcmV0dXJuIGlzQmxhbmsob2JqKSA/IG51bGwgOiBvYmo7XG4gIH1cbiAgZnVuY3Rpb24gbm9ybWFsaXplQm9vbChvYmopIHtcbiAgICAgIHJldHVybiBpc0JsYW5rKG9iaikgPyBmYWxzZSA6IG9iajtcbiAgfVxuICBmdW5jdGlvbiBpc0pzT2JqZWN0KG8pIHtcbiAgICAgIHJldHVybiBvICE9PSBudWxsICYmICh0eXBlb2YgbyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgbyA9PT0gJ29iamVjdCcpO1xuICB9XG4gIGZ1bmN0aW9uIGlzUHJpbWl0aXZlKG9iaikge1xuICAgICAgcmV0dXJuICFpc0pzT2JqZWN0KG9iaik7XG4gIH1cbiAgZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHMpIHtcbiAgICAgIHJldHVybiBzLnJlcGxhY2UoLyhbLiorP149IToke30oKXxbXFxdXFwvXFxcXF0pL2csICdcXFxcJDEnKTtcbiAgfVxuXG4gIC8vIFNhZmFyaSBkb2Vzbid0IGltcGxlbWVudCBNYXBJdGVyYXRvci5uZXh0KCksIHdoaWNoIGlzIHVzZWQgaXMgVHJhY2V1cidzIHBvbHlmaWxsIG9mIEFycmF5LmZyb21cbiAgLy8gVE9ETyhtbGF2YWwpOiByZW1vdmUgdGhlIHdvcmsgYXJvdW5kIG9uY2Ugd2UgaGF2ZSBhIHdvcmtpbmcgcG9seWZpbGwgb2YgQXJyYXkuZnJvbVxuICB2YXIgX2FycmF5RnJvbU1hcCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICB0cnkge1xuICAgICAgICAgIGlmICgobmV3IE1hcCgpKS52YWx1ZXMoKS5uZXh0KSB7XG4gICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBjcmVhdGVBcnJheUZyb21NYXAobSwgZ2V0VmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0VmFsdWVzID8gQXJyYXkuZnJvbShtLnZhbHVlcygpKSA6IEFycmF5LmZyb20obS5rZXlzKCkpO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNhdGNoIChlKSB7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlQXJyYXlGcm9tTWFwV2l0aEZvcmVhY2gobSwgZ2V0VmFsdWVzKSB7XG4gICAgICAgICAgdmFyIHJlcyA9IG5ldyBBcnJheShtLnNpemUpLCBpID0gMDtcbiAgICAgICAgICBtLmZvckVhY2goZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgICAgICAgICAgcmVzW2ldID0gZ2V0VmFsdWVzID8gdiA6IGs7XG4gICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfTtcbiAgfSkoKTtcbiAgdmFyIE1hcFdyYXBwZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gTWFwV3JhcHBlcigpIHtcbiAgICAgIH1cbiAgICAgIE1hcFdyYXBwZXIuY3JlYXRlRnJvbVN0cmluZ01hcCA9IGZ1bmN0aW9uIChzdHJpbmdNYXApIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IE1hcCgpO1xuICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gc3RyaW5nTWFwKSB7XG4gICAgICAgICAgICAgIHJlc3VsdC5zZXQocHJvcCwgc3RyaW5nTWFwW3Byb3BdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgICBNYXBXcmFwcGVyLmtleXMgPSBmdW5jdGlvbiAobSkgeyByZXR1cm4gX2FycmF5RnJvbU1hcChtLCBmYWxzZSk7IH07XG4gICAgICBNYXBXcmFwcGVyLnZhbHVlcyA9IGZ1bmN0aW9uIChtKSB7IHJldHVybiBfYXJyYXlGcm9tTWFwKG0sIHRydWUpOyB9O1xuICAgICAgcmV0dXJuIE1hcFdyYXBwZXI7XG4gIH0oKSk7XG4gIC8qKlxuICAgKiBXcmFwcyBKYXZhc2NyaXB0IE9iamVjdHNcbiAgICovXG4gIHZhciBTdHJpbmdNYXBXcmFwcGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFN0cmluZ01hcFdyYXBwZXIoKSB7XG4gICAgICB9XG4gICAgICBTdHJpbmdNYXBXcmFwcGVyLm1lcmdlID0gZnVuY3Rpb24gKG0xLCBtMikge1xuICAgICAgICAgIHZhciBtID0ge307XG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IE9iamVjdC5rZXlzKG0xKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgdmFyIGsgPSBfYVtfaV07XG4gICAgICAgICAgICAgIG1ba10gPSBtMVtrXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IE9iamVjdC5rZXlzKG0yKTsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcbiAgICAgICAgICAgICAgdmFyIGsgPSBfY1tfYl07XG4gICAgICAgICAgICAgIG1ba10gPSBtMltrXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG07XG4gICAgICB9O1xuICAgICAgU3RyaW5nTWFwV3JhcHBlci5lcXVhbHMgPSBmdW5jdGlvbiAobTEsIG0yKSB7XG4gICAgICAgICAgdmFyIGsxID0gT2JqZWN0LmtleXMobTEpO1xuICAgICAgICAgIHZhciBrMiA9IE9iamVjdC5rZXlzKG0yKTtcbiAgICAgICAgICBpZiAoazEubGVuZ3RoICE9IGsyLmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgazEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIGtleSA9IGsxW2ldO1xuICAgICAgICAgICAgICBpZiAobTFba2V5XSAhPT0gbTJba2V5XSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBTdHJpbmdNYXBXcmFwcGVyO1xuICB9KCkpO1xuICB2YXIgTGlzdFdyYXBwZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gTGlzdFdyYXBwZXIoKSB7XG4gICAgICB9XG4gICAgICAvLyBKUyBoYXMgbm8gd2F5IHRvIGV4cHJlc3MgYSBzdGF0aWNhbGx5IGZpeGVkIHNpemUgbGlzdCwgYnV0IGRhcnQgZG9lcyBzbyB3ZVxuICAgICAgLy8ga2VlcCBib3RoIG1ldGhvZHMuXG4gICAgICBMaXN0V3JhcHBlci5jcmVhdGVGaXhlZFNpemUgPSBmdW5jdGlvbiAoc2l6ZSkgeyByZXR1cm4gbmV3IEFycmF5KHNpemUpOyB9O1xuICAgICAgTGlzdFdyYXBwZXIuY3JlYXRlR3Jvd2FibGVTaXplID0gZnVuY3Rpb24gKHNpemUpIHsgcmV0dXJuIG5ldyBBcnJheShzaXplKTsgfTtcbiAgICAgIExpc3RXcmFwcGVyLmNsb25lID0gZnVuY3Rpb24gKGFycmF5KSB7IHJldHVybiBhcnJheS5zbGljZSgwKTsgfTtcbiAgICAgIExpc3RXcmFwcGVyLmZvckVhY2hXaXRoSW5kZXggPSBmdW5jdGlvbiAoYXJyYXksIGZuKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBmbihhcnJheVtpXSwgaSk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIExpc3RXcmFwcGVyLmZpcnN0ID0gZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgICAgICAgaWYgKCFhcnJheSlcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgcmV0dXJuIGFycmF5WzBdO1xuICAgICAgfTtcbiAgICAgIExpc3RXcmFwcGVyLmxhc3QgPSBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICAgICAgICBpZiAoIWFycmF5IHx8IGFycmF5Lmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICByZXR1cm4gYXJyYXlbYXJyYXkubGVuZ3RoIC0gMV07XG4gICAgICB9O1xuICAgICAgTGlzdFdyYXBwZXIuaW5kZXhPZiA9IGZ1bmN0aW9uIChhcnJheSwgdmFsdWUsIHN0YXJ0SW5kZXgpIHtcbiAgICAgICAgICBpZiAoc3RhcnRJbmRleCA9PT0gdm9pZCAwKSB7IHN0YXJ0SW5kZXggPSAwOyB9XG4gICAgICAgICAgcmV0dXJuIGFycmF5LmluZGV4T2YodmFsdWUsIHN0YXJ0SW5kZXgpO1xuICAgICAgfTtcbiAgICAgIExpc3RXcmFwcGVyLmNvbnRhaW5zID0gZnVuY3Rpb24gKGxpc3QsIGVsKSB7IHJldHVybiBsaXN0LmluZGV4T2YoZWwpICE9PSAtMTsgfTtcbiAgICAgIExpc3RXcmFwcGVyLnJldmVyc2VkID0gZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgICAgICAgdmFyIGEgPSBMaXN0V3JhcHBlci5jbG9uZShhcnJheSk7XG4gICAgICAgICAgcmV0dXJuIGEucmV2ZXJzZSgpO1xuICAgICAgfTtcbiAgICAgIExpc3RXcmFwcGVyLmNvbmNhdCA9IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmNvbmNhdChiKTsgfTtcbiAgICAgIExpc3RXcmFwcGVyLmluc2VydCA9IGZ1bmN0aW9uIChsaXN0LCBpbmRleCwgdmFsdWUpIHsgbGlzdC5zcGxpY2UoaW5kZXgsIDAsIHZhbHVlKTsgfTtcbiAgICAgIExpc3RXcmFwcGVyLnJlbW92ZUF0ID0gZnVuY3Rpb24gKGxpc3QsIGluZGV4KSB7XG4gICAgICAgICAgdmFyIHJlcyA9IGxpc3RbaW5kZXhdO1xuICAgICAgICAgIGxpc3Quc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfTtcbiAgICAgIExpc3RXcmFwcGVyLnJlbW92ZUFsbCA9IGZ1bmN0aW9uIChsaXN0LCBpdGVtcykge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgdmFyIGluZGV4ID0gbGlzdC5pbmRleE9mKGl0ZW1zW2ldKTtcbiAgICAgICAgICAgICAgbGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBMaXN0V3JhcHBlci5yZW1vdmUgPSBmdW5jdGlvbiAobGlzdCwgZWwpIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSBsaXN0LmluZGV4T2YoZWwpO1xuICAgICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgIGxpc3Quc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG4gICAgICBMaXN0V3JhcHBlci5jbGVhciA9IGZ1bmN0aW9uIChsaXN0KSB7IGxpc3QubGVuZ3RoID0gMDsgfTtcbiAgICAgIExpc3RXcmFwcGVyLmlzRW1wdHkgPSBmdW5jdGlvbiAobGlzdCkgeyByZXR1cm4gbGlzdC5sZW5ndGggPT0gMDsgfTtcbiAgICAgIExpc3RXcmFwcGVyLmZpbGwgPSBmdW5jdGlvbiAobGlzdCwgdmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgICBpZiAoc3RhcnQgPT09IHZvaWQgMCkgeyBzdGFydCA9IDA7IH1cbiAgICAgICAgICBpZiAoZW5kID09PSB2b2lkIDApIHsgZW5kID0gbnVsbDsgfVxuICAgICAgICAgIGxpc3QuZmlsbCh2YWx1ZSwgc3RhcnQsIGVuZCA9PT0gbnVsbCA/IGxpc3QubGVuZ3RoIDogZW5kKTtcbiAgICAgIH07XG4gICAgICBMaXN0V3JhcHBlci5lcXVhbHMgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aClcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICBpZiAoYVtpXSAhPT0gYltpXSlcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9O1xuICAgICAgTGlzdFdyYXBwZXIuc2xpY2UgPSBmdW5jdGlvbiAobCwgZnJvbSwgdG8pIHtcbiAgICAgICAgICBpZiAoZnJvbSA9PT0gdm9pZCAwKSB7IGZyb20gPSAwOyB9XG4gICAgICAgICAgaWYgKHRvID09PSB2b2lkIDApIHsgdG8gPSBudWxsOyB9XG4gICAgICAgICAgcmV0dXJuIGwuc2xpY2UoZnJvbSwgdG8gPT09IG51bGwgPyB1bmRlZmluZWQgOiB0byk7XG4gICAgICB9O1xuICAgICAgTGlzdFdyYXBwZXIuc3BsaWNlID0gZnVuY3Rpb24gKGwsIGZyb20sIGxlbmd0aCkgeyByZXR1cm4gbC5zcGxpY2UoZnJvbSwgbGVuZ3RoKTsgfTtcbiAgICAgIExpc3RXcmFwcGVyLnNvcnQgPSBmdW5jdGlvbiAobCwgY29tcGFyZUZuKSB7XG4gICAgICAgICAgaWYgKGlzUHJlc2VudChjb21wYXJlRm4pKSB7XG4gICAgICAgICAgICAgIGwuc29ydChjb21wYXJlRm4pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgbC5zb3J0KCk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIExpc3RXcmFwcGVyLnRvU3RyaW5nID0gZnVuY3Rpb24gKGwpIHsgcmV0dXJuIGwudG9TdHJpbmcoKTsgfTtcbiAgICAgIExpc3RXcmFwcGVyLnRvSlNPTiA9IGZ1bmN0aW9uIChsKSB7IHJldHVybiBKU09OLnN0cmluZ2lmeShsKTsgfTtcbiAgICAgIExpc3RXcmFwcGVyLm1heGltdW0gPSBmdW5jdGlvbiAobGlzdCwgcHJlZGljYXRlKSB7XG4gICAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBzb2x1dGlvbiA9IG51bGw7XG4gICAgICAgICAgdmFyIG1heFZhbHVlID0gLUluZmluaXR5O1xuICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsaXN0Lmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICB2YXIgY2FuZGlkYXRlID0gbGlzdFtpbmRleF07XG4gICAgICAgICAgICAgIGlmIChpc0JsYW5rKGNhbmRpZGF0ZSkpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBjYW5kaWRhdGVWYWx1ZSA9IHByZWRpY2F0ZShjYW5kaWRhdGUpO1xuICAgICAgICAgICAgICBpZiAoY2FuZGlkYXRlVmFsdWUgPiBtYXhWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgc29sdXRpb24gPSBjYW5kaWRhdGU7XG4gICAgICAgICAgICAgICAgICBtYXhWYWx1ZSA9IGNhbmRpZGF0ZVZhbHVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzb2x1dGlvbjtcbiAgICAgIH07XG4gICAgICBMaXN0V3JhcHBlci5mbGF0dGVuID0gZnVuY3Rpb24gKGxpc3QpIHtcbiAgICAgICAgICB2YXIgdGFyZ2V0ID0gW107XG4gICAgICAgICAgX2ZsYXR0ZW5BcnJheShsaXN0LCB0YXJnZXQpO1xuICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICB9O1xuICAgICAgTGlzdFdyYXBwZXIuYWRkQWxsID0gZnVuY3Rpb24gKGxpc3QsIHNvdXJjZSkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc291cmNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGxpc3QucHVzaChzb3VyY2VbaV0pO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gTGlzdFdyYXBwZXI7XG4gIH0oKSk7XG4gIGZ1bmN0aW9uIF9mbGF0dGVuQXJyYXkoc291cmNlLCB0YXJnZXQpIHtcbiAgICAgIGlmIChpc1ByZXNlbnQoc291cmNlKSkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc291cmNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBpdGVtID0gc291cmNlW2ldO1xuICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xuICAgICAgICAgICAgICAgICAgX2ZsYXR0ZW5BcnJheShpdGVtLCB0YXJnZXQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgLyoqXG4gICAqIEBsaWNlbnNlXG4gICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgKlxuICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAqL1xuICB2YXIgVGFnQ29udGVudFR5cGU7XG4gIChmdW5jdGlvbiAoVGFnQ29udGVudFR5cGUpIHtcbiAgICAgIFRhZ0NvbnRlbnRUeXBlW1RhZ0NvbnRlbnRUeXBlW1wiUkFXX1RFWFRcIl0gPSAwXSA9IFwiUkFXX1RFWFRcIjtcbiAgICAgIFRhZ0NvbnRlbnRUeXBlW1RhZ0NvbnRlbnRUeXBlW1wiRVNDQVBBQkxFX1JBV19URVhUXCJdID0gMV0gPSBcIkVTQ0FQQUJMRV9SQVdfVEVYVFwiO1xuICAgICAgVGFnQ29udGVudFR5cGVbVGFnQ29udGVudFR5cGVbXCJQQVJTQUJMRV9EQVRBXCJdID0gMl0gPSBcIlBBUlNBQkxFX0RBVEFcIjtcbiAgfSkoVGFnQ29udGVudFR5cGUgfHwgKFRhZ0NvbnRlbnRUeXBlID0ge30pKTtcbiAgZnVuY3Rpb24gc3BsaXROc05hbWUoZWxlbWVudE5hbWUpIHtcbiAgICAgIGlmIChlbGVtZW50TmFtZVswXSAhPSAnOicpIHtcbiAgICAgICAgICByZXR1cm4gW251bGwsIGVsZW1lbnROYW1lXTtcbiAgICAgIH1cbiAgICAgIHZhciBjb2xvbkluZGV4ID0gZWxlbWVudE5hbWUuaW5kZXhPZignOicsIDEpO1xuICAgICAgaWYgKGNvbG9uSW5kZXggPT0gLTEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBmb3JtYXQgXFxcIlwiICsgZWxlbWVudE5hbWUgKyBcIlxcXCIgZXhwZWN0aW5nIFxcXCI6bmFtZXNwYWNlOm5hbWVcXFwiXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtlbGVtZW50TmFtZS5zbGljZSgxLCBjb2xvbkluZGV4KSwgZWxlbWVudE5hbWUuc2xpY2UoY29sb25JbmRleCArIDEpXTtcbiAgfVxuICBmdW5jdGlvbiBnZXROc1ByZWZpeChmdWxsTmFtZSkge1xuICAgICAgcmV0dXJuIGZ1bGxOYW1lID09PSBudWxsID8gbnVsbCA6IHNwbGl0TnNOYW1lKGZ1bGxOYW1lKVswXTtcbiAgfVxuICBmdW5jdGlvbiBtZXJnZU5zQW5kTmFtZShwcmVmaXgsIGxvY2FsTmFtZSkge1xuICAgICAgcmV0dXJuIHByZWZpeCA/IFwiOlwiICsgcHJlZml4ICsgXCI6XCIgKyBsb2NhbE5hbWUgOiBsb2NhbE5hbWU7XG4gIH1cbiAgLy8gc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1MS9zeW50YXguaHRtbCNuYW1lZC1jaGFyYWN0ZXItcmVmZXJlbmNlc1xuICAvLyBzZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW50aXRpZXMuanNvblxuICAvLyBUaGlzIGxpc3QgaXMgbm90IGV4aGF1c3RpdmUgdG8ga2VlcCB0aGUgY29tcGlsZXIgZm9vdHByaW50IGxvdy5cbiAgLy8gVGhlIGAmIzEyMztgIC8gYCYjeDFhYjtgIHN5bnRheCBzaG91bGQgYmUgdXNlZCB3aGVuIHRoZSBuYW1lZCBjaGFyYWN0ZXIgcmVmZXJlbmNlIGRvZXMgbm90IGV4aXN0LlxuICB2YXIgTkFNRURfRU5USVRJRVMgPSB7XG4gICAgICAnQWFjdXRlJzogJ1xcdTAwQzEnLFxuICAgICAgJ2FhY3V0ZSc6ICdcXHUwMEUxJyxcbiAgICAgICdBY2lyYyc6ICdcXHUwMEMyJyxcbiAgICAgICdhY2lyYyc6ICdcXHUwMEUyJyxcbiAgICAgICdhY3V0ZSc6ICdcXHUwMEI0JyxcbiAgICAgICdBRWxpZyc6ICdcXHUwMEM2JyxcbiAgICAgICdhZWxpZyc6ICdcXHUwMEU2JyxcbiAgICAgICdBZ3JhdmUnOiAnXFx1MDBDMCcsXG4gICAgICAnYWdyYXZlJzogJ1xcdTAwRTAnLFxuICAgICAgJ2FsZWZzeW0nOiAnXFx1MjEzNScsXG4gICAgICAnQWxwaGEnOiAnXFx1MDM5MScsXG4gICAgICAnYWxwaGEnOiAnXFx1MDNCMScsXG4gICAgICAnYW1wJzogJyYnLFxuICAgICAgJ2FuZCc6ICdcXHUyMjI3JyxcbiAgICAgICdhbmcnOiAnXFx1MjIyMCcsXG4gICAgICAnYXBvcyc6ICdcXHUwMDI3JyxcbiAgICAgICdBcmluZyc6ICdcXHUwMEM1JyxcbiAgICAgICdhcmluZyc6ICdcXHUwMEU1JyxcbiAgICAgICdhc3ltcCc6ICdcXHUyMjQ4JyxcbiAgICAgICdBdGlsZGUnOiAnXFx1MDBDMycsXG4gICAgICAnYXRpbGRlJzogJ1xcdTAwRTMnLFxuICAgICAgJ0F1bWwnOiAnXFx1MDBDNCcsXG4gICAgICAnYXVtbCc6ICdcXHUwMEU0JyxcbiAgICAgICdiZHF1byc6ICdcXHUyMDFFJyxcbiAgICAgICdCZXRhJzogJ1xcdTAzOTInLFxuICAgICAgJ2JldGEnOiAnXFx1MDNCMicsXG4gICAgICAnYnJ2YmFyJzogJ1xcdTAwQTYnLFxuICAgICAgJ2J1bGwnOiAnXFx1MjAyMicsXG4gICAgICAnY2FwJzogJ1xcdTIyMjknLFxuICAgICAgJ0NjZWRpbCc6ICdcXHUwMEM3JyxcbiAgICAgICdjY2VkaWwnOiAnXFx1MDBFNycsXG4gICAgICAnY2VkaWwnOiAnXFx1MDBCOCcsXG4gICAgICAnY2VudCc6ICdcXHUwMEEyJyxcbiAgICAgICdDaGknOiAnXFx1MDNBNycsXG4gICAgICAnY2hpJzogJ1xcdTAzQzcnLFxuICAgICAgJ2NpcmMnOiAnXFx1MDJDNicsXG4gICAgICAnY2x1YnMnOiAnXFx1MjY2MycsXG4gICAgICAnY29uZyc6ICdcXHUyMjQ1JyxcbiAgICAgICdjb3B5JzogJ1xcdTAwQTknLFxuICAgICAgJ2NyYXJyJzogJ1xcdTIxQjUnLFxuICAgICAgJ2N1cCc6ICdcXHUyMjJBJyxcbiAgICAgICdjdXJyZW4nOiAnXFx1MDBBNCcsXG4gICAgICAnZGFnZ2VyJzogJ1xcdTIwMjAnLFxuICAgICAgJ0RhZ2dlcic6ICdcXHUyMDIxJyxcbiAgICAgICdkYXJyJzogJ1xcdTIxOTMnLFxuICAgICAgJ2RBcnInOiAnXFx1MjFEMycsXG4gICAgICAnZGVnJzogJ1xcdTAwQjAnLFxuICAgICAgJ0RlbHRhJzogJ1xcdTAzOTQnLFxuICAgICAgJ2RlbHRhJzogJ1xcdTAzQjQnLFxuICAgICAgJ2RpYW1zJzogJ1xcdTI2NjYnLFxuICAgICAgJ2RpdmlkZSc6ICdcXHUwMEY3JyxcbiAgICAgICdFYWN1dGUnOiAnXFx1MDBDOScsXG4gICAgICAnZWFjdXRlJzogJ1xcdTAwRTknLFxuICAgICAgJ0VjaXJjJzogJ1xcdTAwQ0EnLFxuICAgICAgJ2VjaXJjJzogJ1xcdTAwRUEnLFxuICAgICAgJ0VncmF2ZSc6ICdcXHUwMEM4JyxcbiAgICAgICdlZ3JhdmUnOiAnXFx1MDBFOCcsXG4gICAgICAnZW1wdHknOiAnXFx1MjIwNScsXG4gICAgICAnZW1zcCc6ICdcXHUyMDAzJyxcbiAgICAgICdlbnNwJzogJ1xcdTIwMDInLFxuICAgICAgJ0Vwc2lsb24nOiAnXFx1MDM5NScsXG4gICAgICAnZXBzaWxvbic6ICdcXHUwM0I1JyxcbiAgICAgICdlcXVpdic6ICdcXHUyMjYxJyxcbiAgICAgICdFdGEnOiAnXFx1MDM5NycsXG4gICAgICAnZXRhJzogJ1xcdTAzQjcnLFxuICAgICAgJ0VUSCc6ICdcXHUwMEQwJyxcbiAgICAgICdldGgnOiAnXFx1MDBGMCcsXG4gICAgICAnRXVtbCc6ICdcXHUwMENCJyxcbiAgICAgICdldW1sJzogJ1xcdTAwRUInLFxuICAgICAgJ2V1cm8nOiAnXFx1MjBBQycsXG4gICAgICAnZXhpc3QnOiAnXFx1MjIwMycsXG4gICAgICAnZm5vZic6ICdcXHUwMTkyJyxcbiAgICAgICdmb3JhbGwnOiAnXFx1MjIwMCcsXG4gICAgICAnZnJhYzEyJzogJ1xcdTAwQkQnLFxuICAgICAgJ2ZyYWMxNCc6ICdcXHUwMEJDJyxcbiAgICAgICdmcmFjMzQnOiAnXFx1MDBCRScsXG4gICAgICAnZnJhc2wnOiAnXFx1MjA0NCcsXG4gICAgICAnR2FtbWEnOiAnXFx1MDM5MycsXG4gICAgICAnZ2FtbWEnOiAnXFx1MDNCMycsXG4gICAgICAnZ2UnOiAnXFx1MjI2NScsXG4gICAgICAnZ3QnOiAnPicsXG4gICAgICAnaGFycic6ICdcXHUyMTk0JyxcbiAgICAgICdoQXJyJzogJ1xcdTIxRDQnLFxuICAgICAgJ2hlYXJ0cyc6ICdcXHUyNjY1JyxcbiAgICAgICdoZWxsaXAnOiAnXFx1MjAyNicsXG4gICAgICAnSWFjdXRlJzogJ1xcdTAwQ0QnLFxuICAgICAgJ2lhY3V0ZSc6ICdcXHUwMEVEJyxcbiAgICAgICdJY2lyYyc6ICdcXHUwMENFJyxcbiAgICAgICdpY2lyYyc6ICdcXHUwMEVFJyxcbiAgICAgICdpZXhjbCc6ICdcXHUwMEExJyxcbiAgICAgICdJZ3JhdmUnOiAnXFx1MDBDQycsXG4gICAgICAnaWdyYXZlJzogJ1xcdTAwRUMnLFxuICAgICAgJ2ltYWdlJzogJ1xcdTIxMTEnLFxuICAgICAgJ2luZmluJzogJ1xcdTIyMUUnLFxuICAgICAgJ2ludCc6ICdcXHUyMjJCJyxcbiAgICAgICdJb3RhJzogJ1xcdTAzOTknLFxuICAgICAgJ2lvdGEnOiAnXFx1MDNCOScsXG4gICAgICAnaXF1ZXN0JzogJ1xcdTAwQkYnLFxuICAgICAgJ2lzaW4nOiAnXFx1MjIwOCcsXG4gICAgICAnSXVtbCc6ICdcXHUwMENGJyxcbiAgICAgICdpdW1sJzogJ1xcdTAwRUYnLFxuICAgICAgJ0thcHBhJzogJ1xcdTAzOUEnLFxuICAgICAgJ2thcHBhJzogJ1xcdTAzQkEnLFxuICAgICAgJ0xhbWJkYSc6ICdcXHUwMzlCJyxcbiAgICAgICdsYW1iZGEnOiAnXFx1MDNCQicsXG4gICAgICAnbGFuZyc6ICdcXHUyN0U4JyxcbiAgICAgICdsYXF1byc6ICdcXHUwMEFCJyxcbiAgICAgICdsYXJyJzogJ1xcdTIxOTAnLFxuICAgICAgJ2xBcnInOiAnXFx1MjFEMCcsXG4gICAgICAnbGNlaWwnOiAnXFx1MjMwOCcsXG4gICAgICAnbGRxdW8nOiAnXFx1MjAxQycsXG4gICAgICAnbGUnOiAnXFx1MjI2NCcsXG4gICAgICAnbGZsb29yJzogJ1xcdTIzMEEnLFxuICAgICAgJ2xvd2FzdCc6ICdcXHUyMjE3JyxcbiAgICAgICdsb3onOiAnXFx1MjVDQScsXG4gICAgICAnbHJtJzogJ1xcdTIwMEUnLFxuICAgICAgJ2xzYXF1byc6ICdcXHUyMDM5JyxcbiAgICAgICdsc3F1byc6ICdcXHUyMDE4JyxcbiAgICAgICdsdCc6ICc8JyxcbiAgICAgICdtYWNyJzogJ1xcdTAwQUYnLFxuICAgICAgJ21kYXNoJzogJ1xcdTIwMTQnLFxuICAgICAgJ21pY3JvJzogJ1xcdTAwQjUnLFxuICAgICAgJ21pZGRvdCc6ICdcXHUwMEI3JyxcbiAgICAgICdtaW51cyc6ICdcXHUyMjEyJyxcbiAgICAgICdNdSc6ICdcXHUwMzlDJyxcbiAgICAgICdtdSc6ICdcXHUwM0JDJyxcbiAgICAgICduYWJsYSc6ICdcXHUyMjA3JyxcbiAgICAgICduYnNwJzogJ1xcdTAwQTAnLFxuICAgICAgJ25kYXNoJzogJ1xcdTIwMTMnLFxuICAgICAgJ25lJzogJ1xcdTIyNjAnLFxuICAgICAgJ25pJzogJ1xcdTIyMEInLFxuICAgICAgJ25vdCc6ICdcXHUwMEFDJyxcbiAgICAgICdub3Rpbic6ICdcXHUyMjA5JyxcbiAgICAgICduc3ViJzogJ1xcdTIyODQnLFxuICAgICAgJ050aWxkZSc6ICdcXHUwMEQxJyxcbiAgICAgICdudGlsZGUnOiAnXFx1MDBGMScsXG4gICAgICAnTnUnOiAnXFx1MDM5RCcsXG4gICAgICAnbnUnOiAnXFx1MDNCRCcsXG4gICAgICAnT2FjdXRlJzogJ1xcdTAwRDMnLFxuICAgICAgJ29hY3V0ZSc6ICdcXHUwMEYzJyxcbiAgICAgICdPY2lyYyc6ICdcXHUwMEQ0JyxcbiAgICAgICdvY2lyYyc6ICdcXHUwMEY0JyxcbiAgICAgICdPRWxpZyc6ICdcXHUwMTUyJyxcbiAgICAgICdvZWxpZyc6ICdcXHUwMTUzJyxcbiAgICAgICdPZ3JhdmUnOiAnXFx1MDBEMicsXG4gICAgICAnb2dyYXZlJzogJ1xcdTAwRjInLFxuICAgICAgJ29saW5lJzogJ1xcdTIwM0UnLFxuICAgICAgJ09tZWdhJzogJ1xcdTAzQTknLFxuICAgICAgJ29tZWdhJzogJ1xcdTAzQzknLFxuICAgICAgJ09taWNyb24nOiAnXFx1MDM5RicsXG4gICAgICAnb21pY3Jvbic6ICdcXHUwM0JGJyxcbiAgICAgICdvcGx1cyc6ICdcXHUyMjk1JyxcbiAgICAgICdvcic6ICdcXHUyMjI4JyxcbiAgICAgICdvcmRmJzogJ1xcdTAwQUEnLFxuICAgICAgJ29yZG0nOiAnXFx1MDBCQScsXG4gICAgICAnT3NsYXNoJzogJ1xcdTAwRDgnLFxuICAgICAgJ29zbGFzaCc6ICdcXHUwMEY4JyxcbiAgICAgICdPdGlsZGUnOiAnXFx1MDBENScsXG4gICAgICAnb3RpbGRlJzogJ1xcdTAwRjUnLFxuICAgICAgJ290aW1lcyc6ICdcXHUyMjk3JyxcbiAgICAgICdPdW1sJzogJ1xcdTAwRDYnLFxuICAgICAgJ291bWwnOiAnXFx1MDBGNicsXG4gICAgICAncGFyYSc6ICdcXHUwMEI2JyxcbiAgICAgICdwZXJtaWwnOiAnXFx1MjAzMCcsXG4gICAgICAncGVycCc6ICdcXHUyMkE1JyxcbiAgICAgICdQaGknOiAnXFx1MDNBNicsXG4gICAgICAncGhpJzogJ1xcdTAzQzYnLFxuICAgICAgJ1BpJzogJ1xcdTAzQTAnLFxuICAgICAgJ3BpJzogJ1xcdTAzQzAnLFxuICAgICAgJ3Bpdic6ICdcXHUwM0Q2JyxcbiAgICAgICdwbHVzbW4nOiAnXFx1MDBCMScsXG4gICAgICAncG91bmQnOiAnXFx1MDBBMycsXG4gICAgICAncHJpbWUnOiAnXFx1MjAzMicsXG4gICAgICAnUHJpbWUnOiAnXFx1MjAzMycsXG4gICAgICAncHJvZCc6ICdcXHUyMjBGJyxcbiAgICAgICdwcm9wJzogJ1xcdTIyMUQnLFxuICAgICAgJ1BzaSc6ICdcXHUwM0E4JyxcbiAgICAgICdwc2knOiAnXFx1MDNDOCcsXG4gICAgICAncXVvdCc6ICdcXHUwMDIyJyxcbiAgICAgICdyYWRpYyc6ICdcXHUyMjFBJyxcbiAgICAgICdyYW5nJzogJ1xcdTI3RTknLFxuICAgICAgJ3JhcXVvJzogJ1xcdTAwQkInLFxuICAgICAgJ3JhcnInOiAnXFx1MjE5MicsXG4gICAgICAnckFycic6ICdcXHUyMUQyJyxcbiAgICAgICdyY2VpbCc6ICdcXHUyMzA5JyxcbiAgICAgICdyZHF1byc6ICdcXHUyMDFEJyxcbiAgICAgICdyZWFsJzogJ1xcdTIxMUMnLFxuICAgICAgJ3JlZyc6ICdcXHUwMEFFJyxcbiAgICAgICdyZmxvb3InOiAnXFx1MjMwQicsXG4gICAgICAnUmhvJzogJ1xcdTAzQTEnLFxuICAgICAgJ3Jobyc6ICdcXHUwM0MxJyxcbiAgICAgICdybG0nOiAnXFx1MjAwRicsXG4gICAgICAncnNhcXVvJzogJ1xcdTIwM0EnLFxuICAgICAgJ3JzcXVvJzogJ1xcdTIwMTknLFxuICAgICAgJ3NicXVvJzogJ1xcdTIwMUEnLFxuICAgICAgJ1NjYXJvbic6ICdcXHUwMTYwJyxcbiAgICAgICdzY2Fyb24nOiAnXFx1MDE2MScsXG4gICAgICAnc2RvdCc6ICdcXHUyMkM1JyxcbiAgICAgICdzZWN0JzogJ1xcdTAwQTcnLFxuICAgICAgJ3NoeSc6ICdcXHUwMEFEJyxcbiAgICAgICdTaWdtYSc6ICdcXHUwM0EzJyxcbiAgICAgICdzaWdtYSc6ICdcXHUwM0MzJyxcbiAgICAgICdzaWdtYWYnOiAnXFx1MDNDMicsXG4gICAgICAnc2ltJzogJ1xcdTIyM0MnLFxuICAgICAgJ3NwYWRlcyc6ICdcXHUyNjYwJyxcbiAgICAgICdzdWInOiAnXFx1MjI4MicsXG4gICAgICAnc3ViZSc6ICdcXHUyMjg2JyxcbiAgICAgICdzdW0nOiAnXFx1MjIxMScsXG4gICAgICAnc3VwJzogJ1xcdTIyODMnLFxuICAgICAgJ3N1cDEnOiAnXFx1MDBCOScsXG4gICAgICAnc3VwMic6ICdcXHUwMEIyJyxcbiAgICAgICdzdXAzJzogJ1xcdTAwQjMnLFxuICAgICAgJ3N1cGUnOiAnXFx1MjI4NycsXG4gICAgICAnc3psaWcnOiAnXFx1MDBERicsXG4gICAgICAnVGF1JzogJ1xcdTAzQTQnLFxuICAgICAgJ3RhdSc6ICdcXHUwM0M0JyxcbiAgICAgICd0aGVyZTQnOiAnXFx1MjIzNCcsXG4gICAgICAnVGhldGEnOiAnXFx1MDM5OCcsXG4gICAgICAndGhldGEnOiAnXFx1MDNCOCcsXG4gICAgICAndGhldGFzeW0nOiAnXFx1MDNEMScsXG4gICAgICAndGhpbnNwJzogJ1xcdTIwMDknLFxuICAgICAgJ1RIT1JOJzogJ1xcdTAwREUnLFxuICAgICAgJ3Rob3JuJzogJ1xcdTAwRkUnLFxuICAgICAgJ3RpbGRlJzogJ1xcdTAyREMnLFxuICAgICAgJ3RpbWVzJzogJ1xcdTAwRDcnLFxuICAgICAgJ3RyYWRlJzogJ1xcdTIxMjInLFxuICAgICAgJ1VhY3V0ZSc6ICdcXHUwMERBJyxcbiAgICAgICd1YWN1dGUnOiAnXFx1MDBGQScsXG4gICAgICAndWFycic6ICdcXHUyMTkxJyxcbiAgICAgICd1QXJyJzogJ1xcdTIxRDEnLFxuICAgICAgJ1VjaXJjJzogJ1xcdTAwREInLFxuICAgICAgJ3VjaXJjJzogJ1xcdTAwRkInLFxuICAgICAgJ1VncmF2ZSc6ICdcXHUwMEQ5JyxcbiAgICAgICd1Z3JhdmUnOiAnXFx1MDBGOScsXG4gICAgICAndW1sJzogJ1xcdTAwQTgnLFxuICAgICAgJ3Vwc2loJzogJ1xcdTAzRDInLFxuICAgICAgJ1Vwc2lsb24nOiAnXFx1MDNBNScsXG4gICAgICAndXBzaWxvbic6ICdcXHUwM0M1JyxcbiAgICAgICdVdW1sJzogJ1xcdTAwREMnLFxuICAgICAgJ3V1bWwnOiAnXFx1MDBGQycsXG4gICAgICAnd2VpZXJwJzogJ1xcdTIxMTgnLFxuICAgICAgJ1hpJzogJ1xcdTAzOUUnLFxuICAgICAgJ3hpJzogJ1xcdTAzQkUnLFxuICAgICAgJ1lhY3V0ZSc6ICdcXHUwMEREJyxcbiAgICAgICd5YWN1dGUnOiAnXFx1MDBGRCcsXG4gICAgICAneWVuJzogJ1xcdTAwQTUnLFxuICAgICAgJ3l1bWwnOiAnXFx1MDBGRicsXG4gICAgICAnWXVtbCc6ICdcXHUwMTc4JyxcbiAgICAgICdaZXRhJzogJ1xcdTAzOTYnLFxuICAgICAgJ3pldGEnOiAnXFx1MDNCNicsXG4gICAgICAnendqJzogJ1xcdTIwMEQnLFxuICAgICAgJ3p3bmonOiAnXFx1MjAwQycsXG4gIH07XG5cbiAgdmFyIEh0bWxUYWdEZWZpbml0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIEh0bWxUYWdEZWZpbml0aW9uKF9hKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgY2xvc2VkQnlDaGlsZHJlbiA9IF9iLmNsb3NlZEJ5Q2hpbGRyZW4sIHJlcXVpcmVkUGFyZW50cyA9IF9iLnJlcXVpcmVkUGFyZW50cywgaW1wbGljaXROYW1lc3BhY2VQcmVmaXggPSBfYi5pbXBsaWNpdE5hbWVzcGFjZVByZWZpeCwgX2MgPSBfYi5jb250ZW50VHlwZSwgY29udGVudFR5cGUgPSBfYyA9PT0gdm9pZCAwID8gVGFnQ29udGVudFR5cGUuUEFSU0FCTEVfREFUQSA6IF9jLCBfZCA9IF9iLmNsb3NlZEJ5UGFyZW50LCBjbG9zZWRCeVBhcmVudCA9IF9kID09PSB2b2lkIDAgPyBmYWxzZSA6IF9kLCBfZSA9IF9iLmlzVm9pZCwgaXNWb2lkID0gX2UgPT09IHZvaWQgMCA/IGZhbHNlIDogX2UsIF9mID0gX2IuaWdub3JlRmlyc3RMZiwgaWdub3JlRmlyc3RMZiA9IF9mID09PSB2b2lkIDAgPyBmYWxzZSA6IF9mO1xuICAgICAgICAgIHRoaXMuY2xvc2VkQnlDaGlsZHJlbiA9IHt9O1xuICAgICAgICAgIHRoaXMuY2xvc2VkQnlQYXJlbnQgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmNhblNlbGZDbG9zZSA9IGZhbHNlO1xuICAgICAgICAgIGlmIChjbG9zZWRCeUNoaWxkcmVuICYmIGNsb3NlZEJ5Q2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBjbG9zZWRCeUNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKHRhZ05hbWUpIHsgcmV0dXJuIF90aGlzLmNsb3NlZEJ5Q2hpbGRyZW5bdGFnTmFtZV0gPSB0cnVlOyB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5pc1ZvaWQgPSBpc1ZvaWQ7XG4gICAgICAgICAgdGhpcy5jbG9zZWRCeVBhcmVudCA9IGNsb3NlZEJ5UGFyZW50IHx8IGlzVm9pZDtcbiAgICAgICAgICBpZiAocmVxdWlyZWRQYXJlbnRzICYmIHJlcXVpcmVkUGFyZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHRoaXMucmVxdWlyZWRQYXJlbnRzID0ge307XG4gICAgICAgICAgICAgIC8vIFRoZSBmaXJzdCBwYXJlbnQgaXMgdGhlIGxpc3QgaXMgYXV0b21hdGljYWxseSB3aGVuIG5vbmUgb2YgdGhlIGxpc3RlZCBwYXJlbnRzIGFyZSBwcmVzZW50XG4gICAgICAgICAgICAgIHRoaXMucGFyZW50VG9BZGQgPSByZXF1aXJlZFBhcmVudHNbMF07XG4gICAgICAgICAgICAgIHJlcXVpcmVkUGFyZW50cy5mb3JFYWNoKGZ1bmN0aW9uICh0YWdOYW1lKSB7IHJldHVybiBfdGhpcy5yZXF1aXJlZFBhcmVudHNbdGFnTmFtZV0gPSB0cnVlOyB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5pbXBsaWNpdE5hbWVzcGFjZVByZWZpeCA9IGltcGxpY2l0TmFtZXNwYWNlUHJlZml4O1xuICAgICAgICAgIHRoaXMuY29udGVudFR5cGUgPSBjb250ZW50VHlwZTtcbiAgICAgICAgICB0aGlzLmlnbm9yZUZpcnN0TGYgPSBpZ25vcmVGaXJzdExmO1xuICAgICAgfVxuICAgICAgSHRtbFRhZ0RlZmluaXRpb24ucHJvdG90eXBlLnJlcXVpcmVFeHRyYVBhcmVudCA9IGZ1bmN0aW9uIChjdXJyZW50UGFyZW50KSB7XG4gICAgICAgICAgaWYgKCF0aGlzLnJlcXVpcmVkUGFyZW50cykge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghY3VycmVudFBhcmVudCkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGxjUGFyZW50ID0gY3VycmVudFBhcmVudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVpcmVkUGFyZW50c1tsY1BhcmVudF0gIT0gdHJ1ZSAmJiBsY1BhcmVudCAhPSAndGVtcGxhdGUnO1xuICAgICAgfTtcbiAgICAgIEh0bWxUYWdEZWZpbml0aW9uLnByb3RvdHlwZS5pc0Nsb3NlZEJ5Q2hpbGQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmlzVm9pZCB8fCBuYW1lLnRvTG93ZXJDYXNlKCkgaW4gdGhpcy5jbG9zZWRCeUNoaWxkcmVuO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBIdG1sVGFnRGVmaW5pdGlvbjtcbiAgfSgpKTtcbiAgLy8gc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1MS9zeW50YXguaHRtbCNvcHRpb25hbC10YWdzXG4gIC8vIFRoaXMgaW1wbGVtZW50YXRpb24gZG9lcyBub3QgZnVsbHkgY29uZm9ybSB0byB0aGUgSFRNTDUgc3BlYy5cbiAgdmFyIFRBR19ERUZJTklUSU9OUyA9IHtcbiAgICAgICdiYXNlJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaXNWb2lkOiB0cnVlIH0pLFxuICAgICAgJ21ldGEnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpc1ZvaWQ6IHRydWUgfSksXG4gICAgICAnYXJlYSc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAgICdlbWJlZCc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAgICdsaW5rJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaXNWb2lkOiB0cnVlIH0pLFxuICAgICAgJ2ltZyc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAgICdpbnB1dCc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAgICdwYXJhbSc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAgICdocic6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAgICdicic6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAgICdzb3VyY2UnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpc1ZvaWQ6IHRydWUgfSksXG4gICAgICAndHJhY2snOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpc1ZvaWQ6IHRydWUgfSksXG4gICAgICAnd2JyJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaXNWb2lkOiB0cnVlIH0pLFxuICAgICAgJ3AnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oe1xuICAgICAgICAgIGNsb3NlZEJ5Q2hpbGRyZW46IFtcbiAgICAgICAgICAgICAgJ2FkZHJlc3MnLCAnYXJ0aWNsZScsICdhc2lkZScsICdibG9ja3F1b3RlJywgJ2RpdicsICdkbCcsICdmaWVsZHNldCcsICdmb290ZXInLCAnZm9ybScsXG4gICAgICAgICAgICAgICdoMScsICdoMicsICdoMycsICdoNCcsICdoNScsICdoNicsICdoZWFkZXInLCAnaGdyb3VwJywgJ2hyJyxcbiAgICAgICAgICAgICAgJ21haW4nLCAnbmF2JywgJ29sJywgJ3AnLCAncHJlJywgJ3NlY3Rpb24nLCAndGFibGUnLCAndWwnXG4gICAgICAgICAgXSxcbiAgICAgICAgICBjbG9zZWRCeVBhcmVudDogdHJ1ZVxuICAgICAgfSksXG4gICAgICAndGhlYWQnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ3Rib2R5JywgJ3Rmb290J10gfSksXG4gICAgICAndGJvZHknOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ3Rib2R5JywgJ3Rmb290J10sIGNsb3NlZEJ5UGFyZW50OiB0cnVlIH0pLFxuICAgICAgJ3Rmb290JzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY2xvc2VkQnlDaGlsZHJlbjogWyd0Ym9keSddLCBjbG9zZWRCeVBhcmVudDogdHJ1ZSB9KSxcbiAgICAgICd0cic6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7XG4gICAgICAgICAgY2xvc2VkQnlDaGlsZHJlbjogWyd0ciddLFxuICAgICAgICAgIHJlcXVpcmVkUGFyZW50czogWyd0Ym9keScsICd0Zm9vdCcsICd0aGVhZCddLFxuICAgICAgICAgIGNsb3NlZEJ5UGFyZW50OiB0cnVlXG4gICAgICB9KSxcbiAgICAgICd0ZCc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsndGQnLCAndGgnXSwgY2xvc2VkQnlQYXJlbnQ6IHRydWUgfSksXG4gICAgICAndGgnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ3RkJywgJ3RoJ10sIGNsb3NlZEJ5UGFyZW50OiB0cnVlIH0pLFxuICAgICAgJ2NvbCc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IHJlcXVpcmVkUGFyZW50czogWydjb2xncm91cCddLCBpc1ZvaWQ6IHRydWUgfSksXG4gICAgICAnc3ZnJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaW1wbGljaXROYW1lc3BhY2VQcmVmaXg6ICdzdmcnIH0pLFxuICAgICAgJ21hdGgnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpbXBsaWNpdE5hbWVzcGFjZVByZWZpeDogJ21hdGgnIH0pLFxuICAgICAgJ2xpJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY2xvc2VkQnlDaGlsZHJlbjogWydsaSddLCBjbG9zZWRCeVBhcmVudDogdHJ1ZSB9KSxcbiAgICAgICdkdCc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsnZHQnLCAnZGQnXSB9KSxcbiAgICAgICdkZCc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsnZHQnLCAnZGQnXSwgY2xvc2VkQnlQYXJlbnQ6IHRydWUgfSksXG4gICAgICAncmInOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ3JiJywgJ3J0JywgJ3J0YycsICdycCddLCBjbG9zZWRCeVBhcmVudDogdHJ1ZSB9KSxcbiAgICAgICdydCc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsncmInLCAncnQnLCAncnRjJywgJ3JwJ10sIGNsb3NlZEJ5UGFyZW50OiB0cnVlIH0pLFxuICAgICAgJ3J0Yyc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsncmInLCAncnRjJywgJ3JwJ10sIGNsb3NlZEJ5UGFyZW50OiB0cnVlIH0pLFxuICAgICAgJ3JwJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY2xvc2VkQnlDaGlsZHJlbjogWydyYicsICdydCcsICdydGMnLCAncnAnXSwgY2xvc2VkQnlQYXJlbnQ6IHRydWUgfSksXG4gICAgICAnb3B0Z3JvdXAnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ29wdGdyb3VwJ10sIGNsb3NlZEJ5UGFyZW50OiB0cnVlIH0pLFxuICAgICAgJ29wdGlvbic6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsnb3B0aW9uJywgJ29wdGdyb3VwJ10sIGNsb3NlZEJ5UGFyZW50OiB0cnVlIH0pLFxuICAgICAgJ3ByZSc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlnbm9yZUZpcnN0TGY6IHRydWUgfSksXG4gICAgICAnbGlzdGluZyc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlnbm9yZUZpcnN0TGY6IHRydWUgfSksXG4gICAgICAnc3R5bGUnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjb250ZW50VHlwZTogVGFnQ29udGVudFR5cGUuUkFXX1RFWFQgfSksXG4gICAgICAnc2NyaXB0JzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY29udGVudFR5cGU6IFRhZ0NvbnRlbnRUeXBlLlJBV19URVhUIH0pLFxuICAgICAgJ3RpdGxlJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY29udGVudFR5cGU6IFRhZ0NvbnRlbnRUeXBlLkVTQ0FQQUJMRV9SQVdfVEVYVCB9KSxcbiAgICAgICd0ZXh0YXJlYSc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNvbnRlbnRUeXBlOiBUYWdDb250ZW50VHlwZS5FU0NBUEFCTEVfUkFXX1RFWFQsIGlnbm9yZUZpcnN0TGY6IHRydWUgfSksXG4gIH07XG4gIHZhciBfREVGQVVMVF9UQUdfREVGSU5JVElPTiA9IG5ldyBIdG1sVGFnRGVmaW5pdGlvbigpO1xuICBmdW5jdGlvbiBnZXRIdG1sVGFnRGVmaW5pdGlvbih0YWdOYW1lKSB7XG4gICAgICByZXR1cm4gVEFHX0RFRklOSVRJT05TW3RhZ05hbWUudG9Mb3dlckNhc2UoKV0gfHwgX0RFRkFVTFRfVEFHX0RFRklOSVRJT047XG4gIH1cblxuICB2YXIgX1NFTEVDVE9SX1JFR0VYUCA9IG5ldyBSZWdFeHAoJyhcXFxcOm5vdFxcXFwoKXwnICtcbiAgICAgICcoWy1cXFxcd10rKXwnICtcbiAgICAgICcoPzpcXFxcLihbLVxcXFx3XSspKXwnICtcbiAgICAgICcoPzpcXFxcWyhbLVxcXFx3Kl0rKSg/Oj0oW15cXFxcXV0qKSk/XFxcXF0pfCcgK1xuICAgICAgJyhcXFxcKSl8JyArXG4gICAgICAnKFxcXFxzKixcXFxccyopJywgLy8gXCIsXCJcbiAgJ2cnKTtcbiAgLyoqXG4gICAqIEEgY3NzIHNlbGVjdG9yIGNvbnRhaW5zIGFuIGVsZW1lbnQgbmFtZSxcbiAgICogY3NzIGNsYXNzZXMgYW5kIGF0dHJpYnV0ZS92YWx1ZSBwYWlycyB3aXRoIHRoZSBwdXJwb3NlXG4gICAqIG9mIHNlbGVjdGluZyBzdWJzZXRzIG91dCBvZiB0aGVtLlxuICAgKi9cbiAgdmFyIENzc1NlbGVjdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIENzc1NlbGVjdG9yKCkge1xuICAgICAgICAgIHRoaXMuZWxlbWVudCA9IG51bGw7XG4gICAgICAgICAgdGhpcy5jbGFzc05hbWVzID0gW107XG4gICAgICAgICAgdGhpcy5hdHRycyA9IFtdO1xuICAgICAgICAgIHRoaXMubm90U2VsZWN0b3JzID0gW107XG4gICAgICB9XG4gICAgICBDc3NTZWxlY3Rvci5wYXJzZSA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgICAgdmFyIF9hZGRSZXN1bHQgPSBmdW5jdGlvbiAocmVzLCBjc3NTZWwpIHtcbiAgICAgICAgICAgICAgaWYgKGNzc1NlbC5ub3RTZWxlY3RvcnMubGVuZ3RoID4gMCAmJiAhY3NzU2VsLmVsZW1lbnQgJiYgY3NzU2VsLmNsYXNzTmFtZXMubGVuZ3RoID09IDAgJiZcbiAgICAgICAgICAgICAgICAgIGNzc1NlbC5hdHRycy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgICAgY3NzU2VsLmVsZW1lbnQgPSAnKic7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzLnB1c2goY3NzU2VsKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciBjc3NTZWxlY3RvciA9IG5ldyBDc3NTZWxlY3RvcigpO1xuICAgICAgICAgIHZhciBtYXRjaDtcbiAgICAgICAgICB2YXIgY3VycmVudCA9IGNzc1NlbGVjdG9yO1xuICAgICAgICAgIHZhciBpbk5vdCA9IGZhbHNlO1xuICAgICAgICAgIF9TRUxFQ1RPUl9SRUdFWFAubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICB3aGlsZSAobWF0Y2ggPSBfU0VMRUNUT1JfUkVHRVhQLmV4ZWMoc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgICAgICAgICAgICAgaWYgKGluTm90KSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZXN0aW5nIDpub3QgaXMgbm90IGFsbG93ZWQgaW4gYSBzZWxlY3RvcicpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaW5Ob3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgY3VycmVudCA9IG5ldyBDc3NTZWxlY3RvcigpO1xuICAgICAgICAgICAgICAgICAgY3NzU2VsZWN0b3Iubm90U2VsZWN0b3JzLnB1c2goY3VycmVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKG1hdGNoWzJdKSB7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50LnNldEVsZW1lbnQobWF0Y2hbMl0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChtYXRjaFszXSkge1xuICAgICAgICAgICAgICAgICAgY3VycmVudC5hZGRDbGFzc05hbWUobWF0Y2hbM10pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChtYXRjaFs0XSkge1xuICAgICAgICAgICAgICAgICAgY3VycmVudC5hZGRBdHRyaWJ1dGUobWF0Y2hbNF0sIG1hdGNoWzVdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobWF0Y2hbNl0pIHtcbiAgICAgICAgICAgICAgICAgIGluTm90ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3NzU2VsZWN0b3I7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKG1hdGNoWzddKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaW5Ob3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011bHRpcGxlIHNlbGVjdG9ycyBpbiA6bm90IGFyZSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBfYWRkUmVzdWx0KHJlc3VsdHMsIGNzc1NlbGVjdG9yKTtcbiAgICAgICAgICAgICAgICAgIGNzc1NlbGVjdG9yID0gY3VycmVudCA9IG5ldyBDc3NTZWxlY3RvcigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIF9hZGRSZXN1bHQocmVzdWx0cywgY3NzU2VsZWN0b3IpO1xuICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgfTtcbiAgICAgIENzc1NlbGVjdG9yLnByb3RvdHlwZS5pc0VsZW1lbnRTZWxlY3RvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5oYXNFbGVtZW50U2VsZWN0b3IoKSAmJiB0aGlzLmNsYXNzTmFtZXMubGVuZ3RoID09IDAgJiYgdGhpcy5hdHRycy5sZW5ndGggPT0gMCAmJlxuICAgICAgICAgICAgICB0aGlzLm5vdFNlbGVjdG9ycy5sZW5ndGggPT09IDA7XG4gICAgICB9O1xuICAgICAgQ3NzU2VsZWN0b3IucHJvdG90eXBlLmhhc0VsZW1lbnRTZWxlY3RvciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICEhdGhpcy5lbGVtZW50OyB9O1xuICAgICAgQ3NzU2VsZWN0b3IucHJvdG90eXBlLnNldEVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgIGlmIChlbGVtZW50ID09PSB2b2lkIDApIHsgZWxlbWVudCA9IG51bGw7IH1cbiAgICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgfTtcbiAgICAgIC8qKiBHZXRzIGEgdGVtcGxhdGUgc3RyaW5nIGZvciBhbiBlbGVtZW50IHRoYXQgbWF0Y2hlcyB0aGUgc2VsZWN0b3IuICovXG4gICAgICBDc3NTZWxlY3Rvci5wcm90b3R5cGUuZ2V0TWF0Y2hpbmdFbGVtZW50VGVtcGxhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHRhZ05hbWUgPSB0aGlzLmVsZW1lbnQgfHwgJ2Rpdic7XG4gICAgICAgICAgdmFyIGNsYXNzQXR0ciA9IHRoaXMuY2xhc3NOYW1lcy5sZW5ndGggPiAwID8gXCIgY2xhc3M9XFxcIlwiICsgdGhpcy5jbGFzc05hbWVzLmpvaW4oJyAnKSArIFwiXFxcIlwiIDogJyc7XG4gICAgICAgICAgdmFyIGF0dHJzID0gJyc7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmF0dHJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICAgIHZhciBhdHRyTmFtZSA9IHRoaXMuYXR0cnNbaV07XG4gICAgICAgICAgICAgIHZhciBhdHRyVmFsdWUgPSB0aGlzLmF0dHJzW2kgKyAxXSAhPT0gJycgPyBcIj1cXFwiXCIgKyB0aGlzLmF0dHJzW2kgKyAxXSArIFwiXFxcIlwiIDogJyc7XG4gICAgICAgICAgICAgIGF0dHJzICs9IFwiIFwiICsgYXR0ck5hbWUgKyBhdHRyVmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBnZXRIdG1sVGFnRGVmaW5pdGlvbih0YWdOYW1lKS5pc1ZvaWQgPyBcIjxcIiArIHRhZ05hbWUgKyBjbGFzc0F0dHIgKyBhdHRycyArIFwiLz5cIiA6XG4gICAgICAgICAgICAgIFwiPFwiICsgdGFnTmFtZSArIGNsYXNzQXR0ciArIGF0dHJzICsgXCI+PC9cIiArIHRhZ05hbWUgKyBcIj5cIjtcbiAgICAgIH07XG4gICAgICBDc3NTZWxlY3Rvci5wcm90b3R5cGUuYWRkQXR0cmlidXRlID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHsgdmFsdWUgPSAnJzsgfVxuICAgICAgICAgIHRoaXMuYXR0cnMucHVzaChuYW1lLCB2YWx1ZSAmJiB2YWx1ZS50b0xvd2VyQ2FzZSgpIHx8ICcnKTtcbiAgICAgIH07XG4gICAgICBDc3NTZWxlY3Rvci5wcm90b3R5cGUuYWRkQ2xhc3NOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHsgdGhpcy5jbGFzc05hbWVzLnB1c2gobmFtZS50b0xvd2VyQ2FzZSgpKTsgfTtcbiAgICAgIENzc1NlbGVjdG9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgcmVzID0gdGhpcy5lbGVtZW50IHx8ICcnO1xuICAgICAgICAgIGlmICh0aGlzLmNsYXNzTmFtZXMpIHtcbiAgICAgICAgICAgICAgdGhpcy5jbGFzc05hbWVzLmZvckVhY2goZnVuY3Rpb24gKGtsYXNzKSB7IHJldHVybiByZXMgKz0gXCIuXCIgKyBrbGFzczsgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLmF0dHJzKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hdHRycy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgICAgdmFyIG5hbWVfMSA9IHRoaXMuYXR0cnNbaV07XG4gICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmF0dHJzW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgIHJlcyArPSBcIltcIiArIG5hbWVfMSArICh2YWx1ZSA/ICc9JyArIHZhbHVlIDogJycpICsgXCJdXCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5ub3RTZWxlY3RvcnMuZm9yRWFjaChmdW5jdGlvbiAobm90U2VsZWN0b3IpIHsgcmV0dXJuIHJlcyArPSBcIjpub3QoXCIgKyBub3RTZWxlY3RvciArIFwiKVwiOyB9KTtcbiAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBDc3NTZWxlY3RvcjtcbiAgfSgpKTtcbiAgLyoqXG4gICAqIFJlYWRzIGEgbGlzdCBvZiBDc3NTZWxlY3RvcnMgYW5kIGFsbG93cyB0byBjYWxjdWxhdGUgd2hpY2ggb25lc1xuICAgKiBhcmUgY29udGFpbmVkIGluIGEgZ2l2ZW4gQ3NzU2VsZWN0b3IuXG4gICAqL1xuICB2YXIgU2VsZWN0b3JNYXRjaGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFNlbGVjdG9yTWF0Y2hlcigpIHtcbiAgICAgICAgICB0aGlzLl9lbGVtZW50TWFwID0ge307XG4gICAgICAgICAgdGhpcy5fZWxlbWVudFBhcnRpYWxNYXAgPSB7fTtcbiAgICAgICAgICB0aGlzLl9jbGFzc01hcCA9IHt9O1xuICAgICAgICAgIHRoaXMuX2NsYXNzUGFydGlhbE1hcCA9IHt9O1xuICAgICAgICAgIHRoaXMuX2F0dHJWYWx1ZU1hcCA9IHt9O1xuICAgICAgICAgIHRoaXMuX2F0dHJWYWx1ZVBhcnRpYWxNYXAgPSB7fTtcbiAgICAgICAgICB0aGlzLl9saXN0Q29udGV4dHMgPSBbXTtcbiAgICAgIH1cbiAgICAgIFNlbGVjdG9yTWF0Y2hlci5jcmVhdGVOb3RNYXRjaGVyID0gZnVuY3Rpb24gKG5vdFNlbGVjdG9ycykge1xuICAgICAgICAgIHZhciBub3RNYXRjaGVyID0gbmV3IFNlbGVjdG9yTWF0Y2hlcigpO1xuICAgICAgICAgIG5vdE1hdGNoZXIuYWRkU2VsZWN0YWJsZXMobm90U2VsZWN0b3JzLCBudWxsKTtcbiAgICAgICAgICByZXR1cm4gbm90TWF0Y2hlcjtcbiAgICAgIH07XG4gICAgICBTZWxlY3Rvck1hdGNoZXIucHJvdG90eXBlLmFkZFNlbGVjdGFibGVzID0gZnVuY3Rpb24gKGNzc1NlbGVjdG9ycywgY2FsbGJhY2tDdHh0KSB7XG4gICAgICAgICAgdmFyIGxpc3RDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgICBpZiAoY3NzU2VsZWN0b3JzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgbGlzdENvbnRleHQgPSBuZXcgU2VsZWN0b3JMaXN0Q29udGV4dChjc3NTZWxlY3RvcnMpO1xuICAgICAgICAgICAgICB0aGlzLl9saXN0Q29udGV4dHMucHVzaChsaXN0Q29udGV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3NzU2VsZWN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2FkZFNlbGVjdGFibGUoY3NzU2VsZWN0b3JzW2ldLCBjYWxsYmFja0N0eHQsIGxpc3RDb250ZXh0KTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgLyoqXG4gICAgICAgKiBBZGQgYW4gb2JqZWN0IHRoYXQgY2FuIGJlIGZvdW5kIGxhdGVyIG9uIGJ5IGNhbGxpbmcgYG1hdGNoYC5cbiAgICAgICAqIEBwYXJhbSBjc3NTZWxlY3RvciBBIGNzcyBzZWxlY3RvclxuICAgICAgICogQHBhcmFtIGNhbGxiYWNrQ3R4dCBBbiBvcGFxdWUgb2JqZWN0IHRoYXQgd2lsbCBiZSBnaXZlbiB0byB0aGUgY2FsbGJhY2sgb2YgdGhlIGBtYXRjaGAgZnVuY3Rpb25cbiAgICAgICAqL1xuICAgICAgU2VsZWN0b3JNYXRjaGVyLnByb3RvdHlwZS5fYWRkU2VsZWN0YWJsZSA9IGZ1bmN0aW9uIChjc3NTZWxlY3RvciwgY2FsbGJhY2tDdHh0LCBsaXN0Q29udGV4dCkge1xuICAgICAgICAgIHZhciBtYXRjaGVyID0gdGhpcztcbiAgICAgICAgICB2YXIgZWxlbWVudCA9IGNzc1NlbGVjdG9yLmVsZW1lbnQ7XG4gICAgICAgICAgdmFyIGNsYXNzTmFtZXMgPSBjc3NTZWxlY3Rvci5jbGFzc05hbWVzO1xuICAgICAgICAgIHZhciBhdHRycyA9IGNzc1NlbGVjdG9yLmF0dHJzO1xuICAgICAgICAgIHZhciBzZWxlY3RhYmxlID0gbmV3IFNlbGVjdG9yQ29udGV4dChjc3NTZWxlY3RvciwgY2FsbGJhY2tDdHh0LCBsaXN0Q29udGV4dCk7XG4gICAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgdmFyIGlzVGVybWluYWwgPSBhdHRycy5sZW5ndGggPT09IDAgJiYgY2xhc3NOYW1lcy5sZW5ndGggPT09IDA7XG4gICAgICAgICAgICAgIGlmIChpc1Rlcm1pbmFsKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9hZGRUZXJtaW5hbChtYXRjaGVyLl9lbGVtZW50TWFwLCBlbGVtZW50LCBzZWxlY3RhYmxlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG1hdGNoZXIgPSB0aGlzLl9hZGRQYXJ0aWFsKG1hdGNoZXIuX2VsZW1lbnRQYXJ0aWFsTWFwLCBlbGVtZW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2xhc3NOYW1lcykge1xuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsYXNzTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIHZhciBpc1Rlcm1pbmFsID0gYXR0cnMubGVuZ3RoID09PSAwICYmIGkgPT09IGNsYXNzTmFtZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgIHZhciBjbGFzc05hbWUgPSBjbGFzc05hbWVzW2ldO1xuICAgICAgICAgICAgICAgICAgaWYgKGlzVGVybWluYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRUZXJtaW5hbChtYXRjaGVyLl9jbGFzc01hcCwgY2xhc3NOYW1lLCBzZWxlY3RhYmxlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXIgPSB0aGlzLl9hZGRQYXJ0aWFsKG1hdGNoZXIuX2NsYXNzUGFydGlhbE1hcCwgY2xhc3NOYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYXR0cnMpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgICAgdmFyIGlzVGVybWluYWwgPSBpID09PSBhdHRycy5sZW5ndGggLSAyO1xuICAgICAgICAgICAgICAgICAgdmFyIG5hbWVfMiA9IGF0dHJzW2ldO1xuICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cnNbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgaWYgKGlzVGVybWluYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgdGVybWluYWxNYXAgPSBtYXRjaGVyLl9hdHRyVmFsdWVNYXA7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHRlcm1pbmFsVmFsdWVzTWFwID0gdGVybWluYWxNYXBbbmFtZV8yXTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRlcm1pbmFsVmFsdWVzTWFwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRlcm1pbmFsVmFsdWVzTWFwID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRlcm1pbmFsTWFwW25hbWVfMl0gPSB0ZXJtaW5hbFZhbHVlc01hcDtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkVGVybWluYWwodGVybWluYWxWYWx1ZXNNYXAsIHZhbHVlLCBzZWxlY3RhYmxlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJ0aWFsTWFwID0gbWF0Y2hlci5fYXR0clZhbHVlUGFydGlhbE1hcDtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFydGlhbFZhbHVlc01hcCA9IHBhcnRpYWxNYXBbbmFtZV8yXTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcnRpYWxWYWx1ZXNNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbFZhbHVlc01hcCA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsTWFwW25hbWVfMl0gPSBwYXJ0aWFsVmFsdWVzTWFwO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVyID0gdGhpcy5fYWRkUGFydGlhbChwYXJ0aWFsVmFsdWVzTWFwLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgU2VsZWN0b3JNYXRjaGVyLnByb3RvdHlwZS5fYWRkVGVybWluYWwgPSBmdW5jdGlvbiAobWFwLCBuYW1lLCBzZWxlY3RhYmxlKSB7XG4gICAgICAgICAgdmFyIHRlcm1pbmFsTGlzdCA9IG1hcFtuYW1lXTtcbiAgICAgICAgICBpZiAoIXRlcm1pbmFsTGlzdCkge1xuICAgICAgICAgICAgICB0ZXJtaW5hbExpc3QgPSBbXTtcbiAgICAgICAgICAgICAgbWFwW25hbWVdID0gdGVybWluYWxMaXN0O1xuICAgICAgICAgIH1cbiAgICAgICAgICB0ZXJtaW5hbExpc3QucHVzaChzZWxlY3RhYmxlKTtcbiAgICAgIH07XG4gICAgICBTZWxlY3Rvck1hdGNoZXIucHJvdG90eXBlLl9hZGRQYXJ0aWFsID0gZnVuY3Rpb24gKG1hcCwgbmFtZSkge1xuICAgICAgICAgIHZhciBtYXRjaGVyID0gbWFwW25hbWVdO1xuICAgICAgICAgIGlmICghbWF0Y2hlcikge1xuICAgICAgICAgICAgICBtYXRjaGVyID0gbmV3IFNlbGVjdG9yTWF0Y2hlcigpO1xuICAgICAgICAgICAgICBtYXBbbmFtZV0gPSBtYXRjaGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWF0Y2hlcjtcbiAgICAgIH07XG4gICAgICAvKipcbiAgICAgICAqIEZpbmQgdGhlIG9iamVjdHMgdGhhdCBoYXZlIGJlZW4gYWRkZWQgdmlhIGBhZGRTZWxlY3RhYmxlYFxuICAgICAgICogd2hvc2UgY3NzIHNlbGVjdG9yIGlzIGNvbnRhaW5lZCBpbiB0aGUgZ2l2ZW4gY3NzIHNlbGVjdG9yLlxuICAgICAgICogQHBhcmFtIGNzc1NlbGVjdG9yIEEgY3NzIHNlbGVjdG9yXG4gICAgICAgKiBAcGFyYW0gbWF0Y2hlZENhbGxiYWNrIFRoaXMgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgb2JqZWN0IGhhbmRlZCBpbnRvIGBhZGRTZWxlY3RhYmxlYFxuICAgICAgICogQHJldHVybiBib29sZWFuIHRydWUgaWYgYSBtYXRjaCB3YXMgZm91bmRcbiAgICAgICovXG4gICAgICBTZWxlY3Rvck1hdGNoZXIucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24gKGNzc1NlbGVjdG9yLCBtYXRjaGVkQ2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSBjc3NTZWxlY3Rvci5lbGVtZW50O1xuICAgICAgICAgIHZhciBjbGFzc05hbWVzID0gY3NzU2VsZWN0b3IuY2xhc3NOYW1lcztcbiAgICAgICAgICB2YXIgYXR0cnMgPSBjc3NTZWxlY3Rvci5hdHRycztcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2xpc3RDb250ZXh0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB0aGlzLl9saXN0Q29udGV4dHNbaV0uYWxyZWFkeU1hdGNoZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0ID0gdGhpcy5fbWF0Y2hUZXJtaW5hbCh0aGlzLl9lbGVtZW50TWFwLCBlbGVtZW50LCBjc3NTZWxlY3RvciwgbWF0Y2hlZENhbGxiYWNrKSB8fCByZXN1bHQ7XG4gICAgICAgICAgcmVzdWx0ID0gdGhpcy5fbWF0Y2hQYXJ0aWFsKHRoaXMuX2VsZW1lbnRQYXJ0aWFsTWFwLCBlbGVtZW50LCBjc3NTZWxlY3RvciwgbWF0Y2hlZENhbGxiYWNrKSB8fFxuICAgICAgICAgICAgICByZXN1bHQ7XG4gICAgICAgICAgaWYgKGNsYXNzTmFtZXMpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGFzc05hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gY2xhc3NOYW1lc1tpXTtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCA9XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWF0Y2hUZXJtaW5hbCh0aGlzLl9jbGFzc01hcCwgY2xhc3NOYW1lLCBjc3NTZWxlY3RvciwgbWF0Y2hlZENhbGxiYWNrKSB8fCByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICByZXN1bHQgPVxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21hdGNoUGFydGlhbCh0aGlzLl9jbGFzc1BhcnRpYWxNYXAsIGNsYXNzTmFtZSwgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhdHRycykge1xuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgbmFtZV8zID0gYXR0cnNbaV07XG4gICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhdHRyc1tpICsgMV07XG4gICAgICAgICAgICAgICAgICB2YXIgdGVybWluYWxWYWx1ZXNNYXAgPSB0aGlzLl9hdHRyVmFsdWVNYXBbbmFtZV8zXTtcbiAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21hdGNoVGVybWluYWwodGVybWluYWxWYWx1ZXNNYXAsICcnLCBjc3NTZWxlY3RvciwgbWF0Y2hlZENhbGxiYWNrKSB8fCByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXN1bHQgPVxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21hdGNoVGVybWluYWwodGVybWluYWxWYWx1ZXNNYXAsIHZhbHVlLCBjc3NTZWxlY3RvciwgbWF0Y2hlZENhbGxiYWNrKSB8fCByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICB2YXIgcGFydGlhbFZhbHVlc01hcCA9IHRoaXMuX2F0dHJWYWx1ZVBhcnRpYWxNYXBbbmFtZV8zXTtcbiAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuX21hdGNoUGFydGlhbChwYXJ0aWFsVmFsdWVzTWFwLCAnJywgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykgfHwgcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmVzdWx0ID1cbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXRjaFBhcnRpYWwocGFydGlhbFZhbHVlc01hcCwgdmFsdWUsIGNzc1NlbGVjdG9yLCBtYXRjaGVkQ2FsbGJhY2spIHx8IHJlc3VsdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgIFNlbGVjdG9yTWF0Y2hlci5wcm90b3R5cGUuX21hdGNoVGVybWluYWwgPSBmdW5jdGlvbiAobWFwLCBuYW1lLCBjc3NTZWxlY3RvciwgbWF0Y2hlZENhbGxiYWNrKSB7XG4gICAgICAgICAgaWYgKCFtYXAgfHwgdHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHNlbGVjdGFibGVzID0gbWFwW25hbWVdO1xuICAgICAgICAgIHZhciBzdGFyU2VsZWN0YWJsZXMgPSBtYXBbJyonXTtcbiAgICAgICAgICBpZiAoc3RhclNlbGVjdGFibGVzKSB7XG4gICAgICAgICAgICAgIHNlbGVjdGFibGVzID0gc2VsZWN0YWJsZXMuY29uY2F0KHN0YXJTZWxlY3RhYmxlcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghc2VsZWN0YWJsZXMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgc2VsZWN0YWJsZTtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxlY3RhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBzZWxlY3RhYmxlID0gc2VsZWN0YWJsZXNbaV07XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHNlbGVjdGFibGUuZmluYWxpemUoY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykgfHwgcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgIFNlbGVjdG9yTWF0Y2hlci5wcm90b3R5cGUuX21hdGNoUGFydGlhbCA9IGZ1bmN0aW9uIChtYXAsIG5hbWUsIGNzc1NlbGVjdG9yLCBtYXRjaGVkQ2FsbGJhY2spIHtcbiAgICAgICAgICBpZiAoIW1hcCB8fCB0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbmVzdGVkU2VsZWN0b3IgPSBtYXBbbmFtZV07XG4gICAgICAgICAgaWYgKCFuZXN0ZWRTZWxlY3Rvcikge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFRPRE8ocGVyZik6IGdldCByaWQgb2YgcmVjdXJzaW9uIGFuZCBtZWFzdXJlIGFnYWluXG4gICAgICAgICAgLy8gVE9ETyhwZXJmKTogZG9uJ3QgcGFzcyB0aGUgd2hvbGUgc2VsZWN0b3IgaW50byB0aGUgcmVjdXJzaW9uLFxuICAgICAgICAgIC8vIGJ1dCBvbmx5IHRoZSBub3QgcHJvY2Vzc2VkIHBhcnRzXG4gICAgICAgICAgcmV0dXJuIG5lc3RlZFNlbGVjdG9yLm1hdGNoKGNzc1NlbGVjdG9yLCBtYXRjaGVkQ2FsbGJhY2spO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBTZWxlY3Rvck1hdGNoZXI7XG4gIH0oKSk7XG4gIHZhciBTZWxlY3Rvckxpc3RDb250ZXh0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFNlbGVjdG9yTGlzdENvbnRleHQoc2VsZWN0b3JzKSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3RvcnMgPSBzZWxlY3RvcnM7XG4gICAgICAgICAgdGhpcy5hbHJlYWR5TWF0Y2hlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFNlbGVjdG9yTGlzdENvbnRleHQ7XG4gIH0oKSk7XG4gIC8vIFN0b3JlIGNvbnRleHQgdG8gcGFzcyBiYWNrIHNlbGVjdG9yIGFuZCBjb250ZXh0IHdoZW4gYSBzZWxlY3RvciBpcyBtYXRjaGVkXG4gIHZhciBTZWxlY3RvckNvbnRleHQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gU2VsZWN0b3JDb250ZXh0KHNlbGVjdG9yLCBjYkNvbnRleHQsIGxpc3RDb250ZXh0KSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgICAgICAgIHRoaXMuY2JDb250ZXh0ID0gY2JDb250ZXh0O1xuICAgICAgICAgIHRoaXMubGlzdENvbnRleHQgPSBsaXN0Q29udGV4dDtcbiAgICAgICAgICB0aGlzLm5vdFNlbGVjdG9ycyA9IHNlbGVjdG9yLm5vdFNlbGVjdG9ycztcbiAgICAgIH1cbiAgICAgIFNlbGVjdG9yQ29udGV4dC5wcm90b3R5cGUuZmluYWxpemUgPSBmdW5jdGlvbiAoY3NzU2VsZWN0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IHRydWU7XG4gICAgICAgICAgaWYgKHRoaXMubm90U2VsZWN0b3JzLmxlbmd0aCA+IDAgJiYgKCF0aGlzLmxpc3RDb250ZXh0IHx8ICF0aGlzLmxpc3RDb250ZXh0LmFscmVhZHlNYXRjaGVkKSkge1xuICAgICAgICAgICAgICB2YXIgbm90TWF0Y2hlciA9IFNlbGVjdG9yTWF0Y2hlci5jcmVhdGVOb3RNYXRjaGVyKHRoaXMubm90U2VsZWN0b3JzKTtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gIW5vdE1hdGNoZXIubWF0Y2goY3NzU2VsZWN0b3IsIG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0ICYmIGNhbGxiYWNrICYmICghdGhpcy5saXN0Q29udGV4dCB8fCAhdGhpcy5saXN0Q29udGV4dC5hbHJlYWR5TWF0Y2hlZCkpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMubGlzdENvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMubGlzdENvbnRleHQuYWxyZWFkeU1hdGNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhbGxiYWNrKHRoaXMuc2VsZWN0b3IsIHRoaXMuY2JDb250ZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgICByZXR1cm4gU2VsZWN0b3JDb250ZXh0O1xuICB9KCkpO1xuXG4gIC8qKlxuICAgKiBAbGljZW5zZVxuICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICpcbiAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgKi9cbiAgdmFyIF9fZXh0ZW5kcyQyID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICB9O1xuICAvLy8vIFR5cGVzXG4gIHZhciBUeXBlTW9kaWZpZXI7XG4gIChmdW5jdGlvbiAoVHlwZU1vZGlmaWVyKSB7XG4gICAgICBUeXBlTW9kaWZpZXJbVHlwZU1vZGlmaWVyW1wiQ29uc3RcIl0gPSAwXSA9IFwiQ29uc3RcIjtcbiAgfSkoVHlwZU1vZGlmaWVyIHx8IChUeXBlTW9kaWZpZXIgPSB7fSkpO1xuICB2YXIgVHlwZSQxID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFR5cGUobW9kaWZpZXJzKSB7XG4gICAgICAgICAgaWYgKG1vZGlmaWVycyA9PT0gdm9pZCAwKSB7IG1vZGlmaWVycyA9IG51bGw7IH1cbiAgICAgICAgICB0aGlzLm1vZGlmaWVycyA9IG1vZGlmaWVycztcbiAgICAgICAgICBpZiAoIW1vZGlmaWVycykge1xuICAgICAgICAgICAgICB0aGlzLm1vZGlmaWVycyA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFR5cGUucHJvdG90eXBlLmhhc01vZGlmaWVyID0gZnVuY3Rpb24gKG1vZGlmaWVyKSB7IHJldHVybiB0aGlzLm1vZGlmaWVycy5pbmRleE9mKG1vZGlmaWVyKSAhPT0gLTE7IH07XG4gICAgICByZXR1cm4gVHlwZTtcbiAgfSgpKTtcbiAgdmFyIEJ1aWx0aW5UeXBlTmFtZTtcbiAgKGZ1bmN0aW9uIChCdWlsdGluVHlwZU5hbWUpIHtcbiAgICAgIEJ1aWx0aW5UeXBlTmFtZVtCdWlsdGluVHlwZU5hbWVbXCJEeW5hbWljXCJdID0gMF0gPSBcIkR5bmFtaWNcIjtcbiAgICAgIEJ1aWx0aW5UeXBlTmFtZVtCdWlsdGluVHlwZU5hbWVbXCJCb29sXCJdID0gMV0gPSBcIkJvb2xcIjtcbiAgICAgIEJ1aWx0aW5UeXBlTmFtZVtCdWlsdGluVHlwZU5hbWVbXCJTdHJpbmdcIl0gPSAyXSA9IFwiU3RyaW5nXCI7XG4gICAgICBCdWlsdGluVHlwZU5hbWVbQnVpbHRpblR5cGVOYW1lW1wiSW50XCJdID0gM10gPSBcIkludFwiO1xuICAgICAgQnVpbHRpblR5cGVOYW1lW0J1aWx0aW5UeXBlTmFtZVtcIk51bWJlclwiXSA9IDRdID0gXCJOdW1iZXJcIjtcbiAgICAgIEJ1aWx0aW5UeXBlTmFtZVtCdWlsdGluVHlwZU5hbWVbXCJGdW5jdGlvblwiXSA9IDVdID0gXCJGdW5jdGlvblwiO1xuICB9KShCdWlsdGluVHlwZU5hbWUgfHwgKEJ1aWx0aW5UeXBlTmFtZSA9IHt9KSk7XG4gIHZhciBCdWlsdGluVHlwZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMihCdWlsdGluVHlwZSwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIEJ1aWx0aW5UeXBlKG5hbWUsIG1vZGlmaWVycykge1xuICAgICAgICAgIGlmIChtb2RpZmllcnMgPT09IHZvaWQgMCkgeyBtb2RpZmllcnMgPSBudWxsOyB9XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgbW9kaWZpZXJzKTtcbiAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgfVxuICAgICAgQnVpbHRpblR5cGUucHJvdG90eXBlLnZpc2l0VHlwZSA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRCdWlsdGludFR5cGUodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIEJ1aWx0aW5UeXBlO1xuICB9KFR5cGUkMSkpO1xuICB2YXIgRXh0ZXJuYWxUeXBlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQyKEV4dGVybmFsVHlwZSwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIEV4dGVybmFsVHlwZSh2YWx1ZSwgdHlwZVBhcmFtcywgbW9kaWZpZXJzKSB7XG4gICAgICAgICAgaWYgKHR5cGVQYXJhbXMgPT09IHZvaWQgMCkgeyB0eXBlUGFyYW1zID0gbnVsbDsgfVxuICAgICAgICAgIGlmIChtb2RpZmllcnMgPT09IHZvaWQgMCkgeyBtb2RpZmllcnMgPSBudWxsOyB9XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgbW9kaWZpZXJzKTtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy50eXBlUGFyYW1zID0gdHlwZVBhcmFtcztcbiAgICAgIH1cbiAgICAgIEV4dGVybmFsVHlwZS5wcm90b3R5cGUudmlzaXRUeXBlID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEV4dGVybmFsVHlwZSh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gRXh0ZXJuYWxUeXBlO1xuICB9KFR5cGUkMSkpO1xuICB2YXIgQXJyYXlUeXBlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQyKEFycmF5VHlwZSwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIEFycmF5VHlwZShvZiwgbW9kaWZpZXJzKSB7XG4gICAgICAgICAgaWYgKG1vZGlmaWVycyA9PT0gdm9pZCAwKSB7IG1vZGlmaWVycyA9IG51bGw7IH1cbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBtb2RpZmllcnMpO1xuICAgICAgICAgIHRoaXMub2YgPSBvZjtcbiAgICAgIH1cbiAgICAgIEFycmF5VHlwZS5wcm90b3R5cGUudmlzaXRUeXBlID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEFycmF5VHlwZSh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gQXJyYXlUeXBlO1xuICB9KFR5cGUkMSkpO1xuICB2YXIgTWFwVHlwZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMihNYXBUeXBlLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gTWFwVHlwZSh2YWx1ZVR5cGUsIG1vZGlmaWVycykge1xuICAgICAgICAgIGlmIChtb2RpZmllcnMgPT09IHZvaWQgMCkgeyBtb2RpZmllcnMgPSBudWxsOyB9XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgbW9kaWZpZXJzKTtcbiAgICAgICAgICB0aGlzLnZhbHVlVHlwZSA9IHZhbHVlVHlwZTtcbiAgICAgIH1cbiAgICAgIE1hcFR5cGUucHJvdG90eXBlLnZpc2l0VHlwZSA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7IHJldHVybiB2aXNpdG9yLnZpc2l0TWFwVHlwZSh0aGlzLCBjb250ZXh0KTsgfTtcbiAgICAgIHJldHVybiBNYXBUeXBlO1xuICB9KFR5cGUkMSkpO1xuICB2YXIgRFlOQU1JQ19UWVBFID0gbmV3IEJ1aWx0aW5UeXBlKEJ1aWx0aW5UeXBlTmFtZS5EeW5hbWljKTtcbiAgdmFyIEJPT0xfVFlQRSA9IG5ldyBCdWlsdGluVHlwZShCdWlsdGluVHlwZU5hbWUuQm9vbCk7XG4gIHZhciBJTlRfVFlQRSA9IG5ldyBCdWlsdGluVHlwZShCdWlsdGluVHlwZU5hbWUuSW50KTtcbiAgdmFyIE5VTUJFUl9UWVBFID0gbmV3IEJ1aWx0aW5UeXBlKEJ1aWx0aW5UeXBlTmFtZS5OdW1iZXIpO1xuICB2YXIgU1RSSU5HX1RZUEUgPSBuZXcgQnVpbHRpblR5cGUoQnVpbHRpblR5cGVOYW1lLlN0cmluZyk7XG4gIHZhciBGVU5DVElPTl9UWVBFID0gbmV3IEJ1aWx0aW5UeXBlKEJ1aWx0aW5UeXBlTmFtZS5GdW5jdGlvbik7XG4gIC8vLy8vIEV4cHJlc3Npb25zXG4gIHZhciBCaW5hcnlPcGVyYXRvcjtcbiAgKGZ1bmN0aW9uIChCaW5hcnlPcGVyYXRvcikge1xuICAgICAgQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3JbXCJFcXVhbHNcIl0gPSAwXSA9IFwiRXF1YWxzXCI7XG4gICAgICBCaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvcltcIk5vdEVxdWFsc1wiXSA9IDFdID0gXCJOb3RFcXVhbHNcIjtcbiAgICAgIEJpbmFyeU9wZXJhdG9yW0JpbmFyeU9wZXJhdG9yW1wiSWRlbnRpY2FsXCJdID0gMl0gPSBcIklkZW50aWNhbFwiO1xuICAgICAgQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3JbXCJOb3RJZGVudGljYWxcIl0gPSAzXSA9IFwiTm90SWRlbnRpY2FsXCI7XG4gICAgICBCaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvcltcIk1pbnVzXCJdID0gNF0gPSBcIk1pbnVzXCI7XG4gICAgICBCaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvcltcIlBsdXNcIl0gPSA1XSA9IFwiUGx1c1wiO1xuICAgICAgQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3JbXCJEaXZpZGVcIl0gPSA2XSA9IFwiRGl2aWRlXCI7XG4gICAgICBCaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvcltcIk11bHRpcGx5XCJdID0gN10gPSBcIk11bHRpcGx5XCI7XG4gICAgICBCaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvcltcIk1vZHVsb1wiXSA9IDhdID0gXCJNb2R1bG9cIjtcbiAgICAgIEJpbmFyeU9wZXJhdG9yW0JpbmFyeU9wZXJhdG9yW1wiQW5kXCJdID0gOV0gPSBcIkFuZFwiO1xuICAgICAgQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3JbXCJPclwiXSA9IDEwXSA9IFwiT3JcIjtcbiAgICAgIEJpbmFyeU9wZXJhdG9yW0JpbmFyeU9wZXJhdG9yW1wiTG93ZXJcIl0gPSAxMV0gPSBcIkxvd2VyXCI7XG4gICAgICBCaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvcltcIkxvd2VyRXF1YWxzXCJdID0gMTJdID0gXCJMb3dlckVxdWFsc1wiO1xuICAgICAgQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3JbXCJCaWdnZXJcIl0gPSAxM10gPSBcIkJpZ2dlclwiO1xuICAgICAgQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3JbXCJCaWdnZXJFcXVhbHNcIl0gPSAxNF0gPSBcIkJpZ2dlckVxdWFsc1wiO1xuICB9KShCaW5hcnlPcGVyYXRvciB8fCAoQmluYXJ5T3BlcmF0b3IgPSB7fSkpO1xuICB2YXIgRXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBFeHByZXNzaW9uKHR5cGUpIHtcbiAgICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgfVxuICAgICAgRXhwcmVzc2lvbi5wcm90b3R5cGUucHJvcCA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBuZXcgUmVhZFByb3BFeHByKHRoaXMsIG5hbWUpOyB9O1xuICAgICAgRXhwcmVzc2lvbi5wcm90b3R5cGUua2V5ID0gZnVuY3Rpb24gKGluZGV4LCB0eXBlKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgICAgIHJldHVybiBuZXcgUmVhZEtleUV4cHIodGhpcywgaW5kZXgsIHR5cGUpO1xuICAgICAgfTtcbiAgICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLmNhbGxNZXRob2QgPSBmdW5jdGlvbiAobmFtZSwgcGFyYW1zKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBJbnZva2VNZXRob2RFeHByKHRoaXMsIG5hbWUsIHBhcmFtcyk7XG4gICAgICB9O1xuICAgICAgRXhwcmVzc2lvbi5wcm90b3R5cGUuY2FsbEZuID0gZnVuY3Rpb24gKHBhcmFtcykgeyByZXR1cm4gbmV3IEludm9rZUZ1bmN0aW9uRXhwcih0aGlzLCBwYXJhbXMpOyB9O1xuICAgICAgRXhwcmVzc2lvbi5wcm90b3R5cGUuaW5zdGFudGlhdGUgPSBmdW5jdGlvbiAocGFyYW1zLCB0eXBlKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgICAgIHJldHVybiBuZXcgSW5zdGFudGlhdGVFeHByKHRoaXMsIHBhcmFtcywgdHlwZSk7XG4gICAgICB9O1xuICAgICAgRXhwcmVzc2lvbi5wcm90b3R5cGUuY29uZGl0aW9uYWwgPSBmdW5jdGlvbiAodHJ1ZUNhc2UsIGZhbHNlQ2FzZSkge1xuICAgICAgICAgIGlmIChmYWxzZUNhc2UgPT09IHZvaWQgMCkgeyBmYWxzZUNhc2UgPSBudWxsOyB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBDb25kaXRpb25hbEV4cHIodGhpcywgdHJ1ZUNhc2UsIGZhbHNlQ2FzZSk7XG4gICAgICB9O1xuICAgICAgRXhwcmVzc2lvbi5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKHJocykge1xuICAgICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLkVxdWFscywgdGhpcywgcmhzKTtcbiAgICAgIH07XG4gICAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5ub3RFcXVhbHMgPSBmdW5jdGlvbiAocmhzKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoQmluYXJ5T3BlcmF0b3IuTm90RXF1YWxzLCB0aGlzLCByaHMpO1xuICAgICAgfTtcbiAgICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLmlkZW50aWNhbCA9IGZ1bmN0aW9uIChyaHMpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5JZGVudGljYWwsIHRoaXMsIHJocyk7XG4gICAgICB9O1xuICAgICAgRXhwcmVzc2lvbi5wcm90b3R5cGUubm90SWRlbnRpY2FsID0gZnVuY3Rpb24gKHJocykge1xuICAgICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLk5vdElkZW50aWNhbCwgdGhpcywgcmhzKTtcbiAgICAgIH07XG4gICAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5taW51cyA9IGZ1bmN0aW9uIChyaHMpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5NaW51cywgdGhpcywgcmhzKTtcbiAgICAgIH07XG4gICAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5wbHVzID0gZnVuY3Rpb24gKHJocykge1xuICAgICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLlBsdXMsIHRoaXMsIHJocyk7XG4gICAgICB9O1xuICAgICAgRXhwcmVzc2lvbi5wcm90b3R5cGUuZGl2aWRlID0gZnVuY3Rpb24gKHJocykge1xuICAgICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLkRpdmlkZSwgdGhpcywgcmhzKTtcbiAgICAgIH07XG4gICAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uIChyaHMpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5NdWx0aXBseSwgdGhpcywgcmhzKTtcbiAgICAgIH07XG4gICAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5tb2R1bG8gPSBmdW5jdGlvbiAocmhzKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoQmluYXJ5T3BlcmF0b3IuTW9kdWxvLCB0aGlzLCByaHMpO1xuICAgICAgfTtcbiAgICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uIChyaHMpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5BbmQsIHRoaXMsIHJocyk7XG4gICAgICB9O1xuICAgICAgRXhwcmVzc2lvbi5wcm90b3R5cGUub3IgPSBmdW5jdGlvbiAocmhzKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoQmluYXJ5T3BlcmF0b3IuT3IsIHRoaXMsIHJocyk7XG4gICAgICB9O1xuICAgICAgRXhwcmVzc2lvbi5wcm90b3R5cGUubG93ZXIgPSBmdW5jdGlvbiAocmhzKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoQmluYXJ5T3BlcmF0b3IuTG93ZXIsIHRoaXMsIHJocyk7XG4gICAgICB9O1xuICAgICAgRXhwcmVzc2lvbi5wcm90b3R5cGUubG93ZXJFcXVhbHMgPSBmdW5jdGlvbiAocmhzKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoQmluYXJ5T3BlcmF0b3IuTG93ZXJFcXVhbHMsIHRoaXMsIHJocyk7XG4gICAgICB9O1xuICAgICAgRXhwcmVzc2lvbi5wcm90b3R5cGUuYmlnZ2VyID0gZnVuY3Rpb24gKHJocykge1xuICAgICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLkJpZ2dlciwgdGhpcywgcmhzKTtcbiAgICAgIH07XG4gICAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5iaWdnZXJFcXVhbHMgPSBmdW5jdGlvbiAocmhzKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoQmluYXJ5T3BlcmF0b3IuQmlnZ2VyRXF1YWxzLCB0aGlzLCByaHMpO1xuICAgICAgfTtcbiAgICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLmlzQmxhbmsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gTm90ZTogV2UgdXNlIGVxdWFscyBieSBwdXJwb3NlIGhlcmUgdG8gY29tcGFyZSB0byBudWxsIGFuZCB1bmRlZmluZWQgaW4gSlMuXG4gICAgICAgICAgcmV0dXJuIHRoaXMuZXF1YWxzKE5VTExfRVhQUik7XG4gICAgICB9O1xuICAgICAgRXhwcmVzc2lvbi5wcm90b3R5cGUuY2FzdCA9IGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiBuZXcgQ2FzdEV4cHIodGhpcywgdHlwZSk7IH07XG4gICAgICBFeHByZXNzaW9uLnByb3RvdHlwZS50b1N0bXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgRXhwcmVzc2lvblN0YXRlbWVudCh0aGlzKTsgfTtcbiAgICAgIHJldHVybiBFeHByZXNzaW9uO1xuICB9KCkpO1xuICB2YXIgQnVpbHRpblZhcjtcbiAgKGZ1bmN0aW9uIChCdWlsdGluVmFyKSB7XG4gICAgICBCdWlsdGluVmFyW0J1aWx0aW5WYXJbXCJUaGlzXCJdID0gMF0gPSBcIlRoaXNcIjtcbiAgICAgIEJ1aWx0aW5WYXJbQnVpbHRpblZhcltcIlN1cGVyXCJdID0gMV0gPSBcIlN1cGVyXCI7XG4gICAgICBCdWlsdGluVmFyW0J1aWx0aW5WYXJbXCJDYXRjaEVycm9yXCJdID0gMl0gPSBcIkNhdGNoRXJyb3JcIjtcbiAgICAgIEJ1aWx0aW5WYXJbQnVpbHRpblZhcltcIkNhdGNoU3RhY2tcIl0gPSAzXSA9IFwiQ2F0Y2hTdGFja1wiO1xuICB9KShCdWlsdGluVmFyIHx8IChCdWlsdGluVmFyID0ge30pKTtcbiAgdmFyIFJlYWRWYXJFeHByID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQyKFJlYWRWYXJFeHByLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gUmVhZFZhckV4cHIobmFtZSwgdHlwZSkge1xuICAgICAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlKTtcbiAgICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgICAgIHRoaXMuYnVpbHRpbiA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLm5hbWUgPSBudWxsO1xuICAgICAgICAgICAgICB0aGlzLmJ1aWx0aW4gPSBuYW1lO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFJlYWRWYXJFeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0UmVhZFZhckV4cHIodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgUmVhZFZhckV4cHIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gbmV3IFdyaXRlVmFyRXhwcih0aGlzLm5hbWUsIHZhbHVlKTsgfTtcbiAgICAgIHJldHVybiBSZWFkVmFyRXhwcjtcbiAgfShFeHByZXNzaW9uKSk7XG4gIHZhciBXcml0ZVZhckV4cHIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDIoV3JpdGVWYXJFeHByLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gV3JpdGVWYXJFeHByKG5hbWUsIHZhbHVlLCB0eXBlKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHR5cGUgfHwgdmFsdWUudHlwZSk7XG4gICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBXcml0ZVZhckV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRXcml0ZVZhckV4cHIodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgV3JpdGVWYXJFeHByLnByb3RvdHlwZS50b0RlY2xTdG10ID0gZnVuY3Rpb24gKHR5cGUsIG1vZGlmaWVycykge1xuICAgICAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICAgICAgICBpZiAobW9kaWZpZXJzID09PSB2b2lkIDApIHsgbW9kaWZpZXJzID0gbnVsbDsgfVxuICAgICAgICAgIHJldHVybiBuZXcgRGVjbGFyZVZhclN0bXQodGhpcy5uYW1lLCB0aGlzLnZhbHVlLCB0eXBlLCBtb2RpZmllcnMpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBXcml0ZVZhckV4cHI7XG4gIH0oRXhwcmVzc2lvbikpO1xuICB2YXIgV3JpdGVLZXlFeHByID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQyKFdyaXRlS2V5RXhwciwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIFdyaXRlS2V5RXhwcihyZWNlaXZlciwgaW5kZXgsIHZhbHVlLCB0eXBlKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHR5cGUgfHwgdmFsdWUudHlwZSk7XG4gICAgICAgICAgdGhpcy5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBXcml0ZUtleUV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRXcml0ZUtleUV4cHIodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFdyaXRlS2V5RXhwcjtcbiAgfShFeHByZXNzaW9uKSk7XG4gIHZhciBXcml0ZVByb3BFeHByID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQyKFdyaXRlUHJvcEV4cHIsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBXcml0ZVByb3BFeHByKHJlY2VpdmVyLCBuYW1lLCB2YWx1ZSwgdHlwZSkge1xuICAgICAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlIHx8IHZhbHVlLnR5cGUpO1xuICAgICAgICAgIHRoaXMucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIFdyaXRlUHJvcEV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRXcml0ZVByb3BFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBXcml0ZVByb3BFeHByO1xuICB9KEV4cHJlc3Npb24pKTtcbiAgdmFyIEJ1aWx0aW5NZXRob2Q7XG4gIChmdW5jdGlvbiAoQnVpbHRpbk1ldGhvZCkge1xuICAgICAgQnVpbHRpbk1ldGhvZFtCdWlsdGluTWV0aG9kW1wiQ29uY2F0QXJyYXlcIl0gPSAwXSA9IFwiQ29uY2F0QXJyYXlcIjtcbiAgICAgIEJ1aWx0aW5NZXRob2RbQnVpbHRpbk1ldGhvZFtcIlN1YnNjcmliZU9ic2VydmFibGVcIl0gPSAxXSA9IFwiU3Vic2NyaWJlT2JzZXJ2YWJsZVwiO1xuICAgICAgQnVpbHRpbk1ldGhvZFtCdWlsdGluTWV0aG9kW1wiQmluZFwiXSA9IDJdID0gXCJCaW5kXCI7XG4gIH0pKEJ1aWx0aW5NZXRob2QgfHwgKEJ1aWx0aW5NZXRob2QgPSB7fSkpO1xuICB2YXIgSW52b2tlTWV0aG9kRXhwciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMihJbnZva2VNZXRob2RFeHByLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gSW52b2tlTWV0aG9kRXhwcihyZWNlaXZlciwgbWV0aG9kLCBhcmdzLCB0eXBlKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHR5cGUpO1xuICAgICAgICAgIHRoaXMucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICAgICAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgICAgICAgIGlmICh0eXBlb2YgbWV0aG9kID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICB0aGlzLm5hbWUgPSBtZXRob2Q7XG4gICAgICAgICAgICAgIHRoaXMuYnVpbHRpbiA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLm5hbWUgPSBudWxsO1xuICAgICAgICAgICAgICB0aGlzLmJ1aWx0aW4gPSBtZXRob2Q7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgSW52b2tlTWV0aG9kRXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEludm9rZU1ldGhvZEV4cHIodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIEludm9rZU1ldGhvZEV4cHI7XG4gIH0oRXhwcmVzc2lvbikpO1xuICB2YXIgSW52b2tlRnVuY3Rpb25FeHByID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQyKEludm9rZUZ1bmN0aW9uRXhwciwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIEludm9rZUZ1bmN0aW9uRXhwcihmbiwgYXJncywgdHlwZSkge1xuICAgICAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlKTtcbiAgICAgICAgICB0aGlzLmZuID0gZm47XG4gICAgICAgICAgdGhpcy5hcmdzID0gYXJncztcbiAgICAgIH1cbiAgICAgIEludm9rZUZ1bmN0aW9uRXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEludm9rZUZ1bmN0aW9uRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gSW52b2tlRnVuY3Rpb25FeHByO1xuICB9KEV4cHJlc3Npb24pKTtcbiAgdmFyIEluc3RhbnRpYXRlRXhwciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMihJbnN0YW50aWF0ZUV4cHIsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBJbnN0YW50aWF0ZUV4cHIoY2xhc3NFeHByLCBhcmdzLCB0eXBlKSB7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgdHlwZSk7XG4gICAgICAgICAgdGhpcy5jbGFzc0V4cHIgPSBjbGFzc0V4cHI7XG4gICAgICAgICAgdGhpcy5hcmdzID0gYXJncztcbiAgICAgIH1cbiAgICAgIEluc3RhbnRpYXRlRXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEluc3RhbnRpYXRlRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gSW5zdGFudGlhdGVFeHByO1xuICB9KEV4cHJlc3Npb24pKTtcbiAgdmFyIExpdGVyYWxFeHByID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQyKExpdGVyYWxFeHByLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gTGl0ZXJhbEV4cHIodmFsdWUsIHR5cGUpIHtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgdHlwZSk7XG4gICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgTGl0ZXJhbEV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRMaXRlcmFsRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gTGl0ZXJhbEV4cHI7XG4gIH0oRXhwcmVzc2lvbikpO1xuICB2YXIgRXh0ZXJuYWxFeHByID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQyKEV4dGVybmFsRXhwciwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIEV4dGVybmFsRXhwcih2YWx1ZSwgdHlwZSwgdHlwZVBhcmFtcykge1xuICAgICAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICAgICAgICBpZiAodHlwZVBhcmFtcyA9PT0gdm9pZCAwKSB7IHR5cGVQYXJhbXMgPSBudWxsOyB9XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgdHlwZSk7XG4gICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIHRoaXMudHlwZVBhcmFtcyA9IHR5cGVQYXJhbXM7XG4gICAgICB9XG4gICAgICBFeHRlcm5hbEV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRFeHRlcm5hbEV4cHIodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIEV4dGVybmFsRXhwcjtcbiAgfShFeHByZXNzaW9uKSk7XG4gIHZhciBDb25kaXRpb25hbEV4cHIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDIoQ29uZGl0aW9uYWxFeHByLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gQ29uZGl0aW9uYWxFeHByKGNvbmRpdGlvbiwgdHJ1ZUNhc2UsIGZhbHNlQ2FzZSwgdHlwZSkge1xuICAgICAgICAgIGlmIChmYWxzZUNhc2UgPT09IHZvaWQgMCkgeyBmYWxzZUNhc2UgPSBudWxsOyB9XG4gICAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHR5cGUgfHwgdHJ1ZUNhc2UudHlwZSk7XG4gICAgICAgICAgdGhpcy5jb25kaXRpb24gPSBjb25kaXRpb247XG4gICAgICAgICAgdGhpcy5mYWxzZUNhc2UgPSBmYWxzZUNhc2U7XG4gICAgICAgICAgdGhpcy50cnVlQ2FzZSA9IHRydWVDYXNlO1xuICAgICAgfVxuICAgICAgQ29uZGl0aW9uYWxFeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q29uZGl0aW9uYWxFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBDb25kaXRpb25hbEV4cHI7XG4gIH0oRXhwcmVzc2lvbikpO1xuICB2YXIgTm90RXhwciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMihOb3RFeHByLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gTm90RXhwcihjb25kaXRpb24pIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBCT09MX1RZUEUpO1xuICAgICAgICAgIHRoaXMuY29uZGl0aW9uID0gY29uZGl0aW9uO1xuICAgICAgfVxuICAgICAgTm90RXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdE5vdEV4cHIodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIE5vdEV4cHI7XG4gIH0oRXhwcmVzc2lvbikpO1xuICB2YXIgQ2FzdEV4cHIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDIoQ2FzdEV4cHIsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBDYXN0RXhwcih2YWx1ZSwgdHlwZSkge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHR5cGUpO1xuICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIENhc3RFeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2FzdEV4cHIodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIENhc3RFeHByO1xuICB9KEV4cHJlc3Npb24pKTtcbiAgdmFyIEZuUGFyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gRm5QYXJhbShuYW1lLCB0eXBlKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBGblBhcmFtO1xuICB9KCkpO1xuICB2YXIgRnVuY3Rpb25FeHByID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQyKEZ1bmN0aW9uRXhwciwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIEZ1bmN0aW9uRXhwcihwYXJhbXMsIHN0YXRlbWVudHMsIHR5cGUpIHtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgdHlwZSk7XG4gICAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgICAgICAgdGhpcy5zdGF0ZW1lbnRzID0gc3RhdGVtZW50cztcbiAgICAgIH1cbiAgICAgIEZ1bmN0aW9uRXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEZ1bmN0aW9uRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICBGdW5jdGlvbkV4cHIucHJvdG90eXBlLnRvRGVjbFN0bXQgPSBmdW5jdGlvbiAobmFtZSwgbW9kaWZpZXJzKSB7XG4gICAgICAgICAgaWYgKG1vZGlmaWVycyA9PT0gdm9pZCAwKSB7IG1vZGlmaWVycyA9IG51bGw7IH1cbiAgICAgICAgICByZXR1cm4gbmV3IERlY2xhcmVGdW5jdGlvblN0bXQobmFtZSwgdGhpcy5wYXJhbXMsIHRoaXMuc3RhdGVtZW50cywgdGhpcy50eXBlLCBtb2RpZmllcnMpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBGdW5jdGlvbkV4cHI7XG4gIH0oRXhwcmVzc2lvbikpO1xuICB2YXIgQmluYXJ5T3BlcmF0b3JFeHByID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQyKEJpbmFyeU9wZXJhdG9yRXhwciwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIEJpbmFyeU9wZXJhdG9yRXhwcihvcGVyYXRvciwgbGhzLCByaHMsIHR5cGUpIHtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgdHlwZSB8fCBsaHMudHlwZSk7XG4gICAgICAgICAgdGhpcy5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgICAgICAgIHRoaXMucmhzID0gcmhzO1xuICAgICAgICAgIHRoaXMubGhzID0gbGhzO1xuICAgICAgfVxuICAgICAgQmluYXJ5T3BlcmF0b3JFeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QmluYXJ5T3BlcmF0b3JFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBCaW5hcnlPcGVyYXRvckV4cHI7XG4gIH0oRXhwcmVzc2lvbikpO1xuICB2YXIgUmVhZFByb3BFeHByID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQyKFJlYWRQcm9wRXhwciwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIFJlYWRQcm9wRXhwcihyZWNlaXZlciwgbmFtZSwgdHlwZSkge1xuICAgICAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlKTtcbiAgICAgICAgICB0aGlzLnJlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgIH1cbiAgICAgIFJlYWRQcm9wRXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFJlYWRQcm9wRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICBSZWFkUHJvcEV4cHIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBuZXcgV3JpdGVQcm9wRXhwcih0aGlzLnJlY2VpdmVyLCB0aGlzLm5hbWUsIHZhbHVlKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gUmVhZFByb3BFeHByO1xuICB9KEV4cHJlc3Npb24pKTtcbiAgdmFyIFJlYWRLZXlFeHByID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQyKFJlYWRLZXlFeHByLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gUmVhZEtleUV4cHIocmVjZWl2ZXIsIGluZGV4LCB0eXBlKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHR5cGUpO1xuICAgICAgICAgIHRoaXMucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICB9XG4gICAgICBSZWFkS2V5RXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFJlYWRLZXlFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIFJlYWRLZXlFeHByLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFdyaXRlS2V5RXhwcih0aGlzLnJlY2VpdmVyLCB0aGlzLmluZGV4LCB2YWx1ZSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFJlYWRLZXlFeHByO1xuICB9KEV4cHJlc3Npb24pKTtcbiAgdmFyIExpdGVyYWxBcnJheUV4cHIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDIoTGl0ZXJhbEFycmF5RXhwciwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIExpdGVyYWxBcnJheUV4cHIoZW50cmllcywgdHlwZSkge1xuICAgICAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlKTtcbiAgICAgICAgICB0aGlzLmVudHJpZXMgPSBlbnRyaWVzO1xuICAgICAgfVxuICAgICAgTGl0ZXJhbEFycmF5RXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdExpdGVyYWxBcnJheUV4cHIodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIExpdGVyYWxBcnJheUV4cHI7XG4gIH0oRXhwcmVzc2lvbikpO1xuICB2YXIgTGl0ZXJhbE1hcEV4cHIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDIoTGl0ZXJhbE1hcEV4cHIsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBMaXRlcmFsTWFwRXhwcihlbnRyaWVzLCB0eXBlKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHR5cGUpO1xuICAgICAgICAgIHRoaXMuZW50cmllcyA9IGVudHJpZXM7XG4gICAgICAgICAgdGhpcy52YWx1ZVR5cGUgPSBudWxsO1xuICAgICAgICAgIGlmIChpc1ByZXNlbnQodHlwZSkpIHtcbiAgICAgICAgICAgICAgdGhpcy52YWx1ZVR5cGUgPSB0eXBlLnZhbHVlVHlwZTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBMaXRlcmFsTWFwRXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdExpdGVyYWxNYXBFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBMaXRlcmFsTWFwRXhwcjtcbiAgfShFeHByZXNzaW9uKSk7XG4gIHZhciBUSElTX0VYUFIgPSBuZXcgUmVhZFZhckV4cHIoQnVpbHRpblZhci5UaGlzKTtcbiAgdmFyIFNVUEVSX0VYUFIgPSBuZXcgUmVhZFZhckV4cHIoQnVpbHRpblZhci5TdXBlcik7XG4gIHZhciBDQVRDSF9FUlJPUl9WQVIgPSBuZXcgUmVhZFZhckV4cHIoQnVpbHRpblZhci5DYXRjaEVycm9yKTtcbiAgdmFyIENBVENIX1NUQUNLX1ZBUiA9IG5ldyBSZWFkVmFyRXhwcihCdWlsdGluVmFyLkNhdGNoU3RhY2spO1xuICB2YXIgTlVMTF9FWFBSID0gbmV3IExpdGVyYWxFeHByKG51bGwsIG51bGwpO1xuICAvLy8vIFN0YXRlbWVudHNcbiAgdmFyIFN0bXRNb2RpZmllcjtcbiAgKGZ1bmN0aW9uIChTdG10TW9kaWZpZXIpIHtcbiAgICAgIFN0bXRNb2RpZmllcltTdG10TW9kaWZpZXJbXCJGaW5hbFwiXSA9IDBdID0gXCJGaW5hbFwiO1xuICAgICAgU3RtdE1vZGlmaWVyW1N0bXRNb2RpZmllcltcIlByaXZhdGVcIl0gPSAxXSA9IFwiUHJpdmF0ZVwiO1xuICB9KShTdG10TW9kaWZpZXIgfHwgKFN0bXRNb2RpZmllciA9IHt9KSk7XG4gIHZhciBTdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gU3RhdGVtZW50KG1vZGlmaWVycykge1xuICAgICAgICAgIGlmIChtb2RpZmllcnMgPT09IHZvaWQgMCkgeyBtb2RpZmllcnMgPSBudWxsOyB9XG4gICAgICAgICAgdGhpcy5tb2RpZmllcnMgPSBtb2RpZmllcnM7XG4gICAgICAgICAgaWYgKCFtb2RpZmllcnMpIHtcbiAgICAgICAgICAgICAgdGhpcy5tb2RpZmllcnMgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBTdGF0ZW1lbnQucHJvdG90eXBlLmhhc01vZGlmaWVyID0gZnVuY3Rpb24gKG1vZGlmaWVyKSB7IHJldHVybiB0aGlzLm1vZGlmaWVycy5pbmRleE9mKG1vZGlmaWVyKSAhPT0gLTE7IH07XG4gICAgICByZXR1cm4gU3RhdGVtZW50O1xuICB9KCkpO1xuICB2YXIgRGVjbGFyZVZhclN0bXQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDIoRGVjbGFyZVZhclN0bXQsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBEZWNsYXJlVmFyU3RtdChuYW1lLCB2YWx1ZSwgdHlwZSwgbW9kaWZpZXJzKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgICAgIGlmIChtb2RpZmllcnMgPT09IHZvaWQgMCkgeyBtb2RpZmllcnMgPSBudWxsOyB9XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgbW9kaWZpZXJzKTtcbiAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICB0aGlzLnR5cGUgPSB0eXBlIHx8IHZhbHVlLnR5cGU7XG4gICAgICB9XG4gICAgICBEZWNsYXJlVmFyU3RtdC5wcm90b3R5cGUudmlzaXRTdGF0ZW1lbnQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RGVjbGFyZVZhclN0bXQodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIERlY2xhcmVWYXJTdG10O1xuICB9KFN0YXRlbWVudCkpO1xuICB2YXIgRGVjbGFyZUZ1bmN0aW9uU3RtdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMihEZWNsYXJlRnVuY3Rpb25TdG10LCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gRGVjbGFyZUZ1bmN0aW9uU3RtdChuYW1lLCBwYXJhbXMsIHN0YXRlbWVudHMsIHR5cGUsIG1vZGlmaWVycykge1xuICAgICAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICAgICAgICBpZiAobW9kaWZpZXJzID09PSB2b2lkIDApIHsgbW9kaWZpZXJzID0gbnVsbDsgfVxuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIG1vZGlmaWVycyk7XG4gICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICAgICAgICB0aGlzLnN0YXRlbWVudHMgPSBzdGF0ZW1lbnRzO1xuICAgICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICB9XG4gICAgICBEZWNsYXJlRnVuY3Rpb25TdG10LnByb3RvdHlwZS52aXNpdFN0YXRlbWVudCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXREZWNsYXJlRnVuY3Rpb25TdG10KHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBEZWNsYXJlRnVuY3Rpb25TdG10O1xuICB9KFN0YXRlbWVudCkpO1xuICB2YXIgRXhwcmVzc2lvblN0YXRlbWVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMihFeHByZXNzaW9uU3RhdGVtZW50LCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gRXhwcmVzc2lvblN0YXRlbWVudChleHByKSB7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgdGhpcy5leHByID0gZXhwcjtcbiAgICAgIH1cbiAgICAgIEV4cHJlc3Npb25TdGF0ZW1lbnQucHJvdG90eXBlLnZpc2l0U3RhdGVtZW50ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEV4cHJlc3Npb25TdG10KHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBFeHByZXNzaW9uU3RhdGVtZW50O1xuICB9KFN0YXRlbWVudCkpO1xuICB2YXIgUmV0dXJuU3RhdGVtZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQyKFJldHVyblN0YXRlbWVudCwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIFJldHVyblN0YXRlbWVudCh2YWx1ZSkge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIFJldHVyblN0YXRlbWVudC5wcm90b3R5cGUudmlzaXRTdGF0ZW1lbnQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0UmV0dXJuU3RtdCh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gUmV0dXJuU3RhdGVtZW50O1xuICB9KFN0YXRlbWVudCkpO1xuICB2YXIgQWJzdHJhY3RDbGFzc1BhcnQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQWJzdHJhY3RDbGFzc1BhcnQodHlwZSwgbW9kaWZpZXJzKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgICAgdGhpcy5tb2RpZmllcnMgPSBtb2RpZmllcnM7XG4gICAgICAgICAgaWYgKCFtb2RpZmllcnMpIHtcbiAgICAgICAgICAgICAgdGhpcy5tb2RpZmllcnMgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBBYnN0cmFjdENsYXNzUGFydC5wcm90b3R5cGUuaGFzTW9kaWZpZXIgPSBmdW5jdGlvbiAobW9kaWZpZXIpIHsgcmV0dXJuIHRoaXMubW9kaWZpZXJzLmluZGV4T2YobW9kaWZpZXIpICE9PSAtMTsgfTtcbiAgICAgIHJldHVybiBBYnN0cmFjdENsYXNzUGFydDtcbiAgfSgpKTtcbiAgdmFyIENsYXNzRmllbGQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDIoQ2xhc3NGaWVsZCwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIENsYXNzRmllbGQobmFtZSwgdHlwZSwgbW9kaWZpZXJzKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgICAgIGlmIChtb2RpZmllcnMgPT09IHZvaWQgMCkgeyBtb2RpZmllcnMgPSBudWxsOyB9XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgdHlwZSwgbW9kaWZpZXJzKTtcbiAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgfVxuICAgICAgcmV0dXJuIENsYXNzRmllbGQ7XG4gIH0oQWJzdHJhY3RDbGFzc1BhcnQpKTtcbiAgdmFyIENsYXNzTWV0aG9kID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQyKENsYXNzTWV0aG9kLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gQ2xhc3NNZXRob2QobmFtZSwgcGFyYW1zLCBib2R5LCB0eXBlLCBtb2RpZmllcnMpIHtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgICAgICAgaWYgKG1vZGlmaWVycyA9PT0gdm9pZCAwKSB7IG1vZGlmaWVycyA9IG51bGw7IH1cbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlLCBtb2RpZmllcnMpO1xuICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBDbGFzc01ldGhvZDtcbiAgfShBYnN0cmFjdENsYXNzUGFydCkpO1xuICB2YXIgQ2xhc3NHZXR0ZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDIoQ2xhc3NHZXR0ZXIsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBDbGFzc0dldHRlcihuYW1lLCBib2R5LCB0eXBlLCBtb2RpZmllcnMpIHtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgICAgICAgaWYgKG1vZGlmaWVycyA9PT0gdm9pZCAwKSB7IG1vZGlmaWVycyA9IG51bGw7IH1cbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlLCBtb2RpZmllcnMpO1xuICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBDbGFzc0dldHRlcjtcbiAgfShBYnN0cmFjdENsYXNzUGFydCkpO1xuICB2YXIgQ2xhc3NTdG10ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQyKENsYXNzU3RtdCwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIENsYXNzU3RtdChuYW1lLCBwYXJlbnQsIGZpZWxkcywgZ2V0dGVycywgY29uc3RydWN0b3JNZXRob2QsIG1ldGhvZHMsIG1vZGlmaWVycykge1xuICAgICAgICAgIGlmIChtb2RpZmllcnMgPT09IHZvaWQgMCkgeyBtb2RpZmllcnMgPSBudWxsOyB9XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgbW9kaWZpZXJzKTtcbiAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICAgIHRoaXMuZmllbGRzID0gZmllbGRzO1xuICAgICAgICAgIHRoaXMuZ2V0dGVycyA9IGdldHRlcnM7XG4gICAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvck1ldGhvZCA9IGNvbnN0cnVjdG9yTWV0aG9kO1xuICAgICAgICAgIHRoaXMubWV0aG9kcyA9IG1ldGhvZHM7XG4gICAgICB9XG4gICAgICBDbGFzc1N0bXQucHJvdG90eXBlLnZpc2l0U3RhdGVtZW50ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdERlY2xhcmVDbGFzc1N0bXQodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIENsYXNzU3RtdDtcbiAgfShTdGF0ZW1lbnQpKTtcbiAgdmFyIElmU3RtdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMihJZlN0bXQsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBJZlN0bXQoY29uZGl0aW9uLCB0cnVlQ2FzZSwgZmFsc2VDYXNlKSB7XG4gICAgICAgICAgaWYgKGZhbHNlQ2FzZSA9PT0gdm9pZCAwKSB7IGZhbHNlQ2FzZSA9IFtdOyB9XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgdGhpcy5jb25kaXRpb24gPSBjb25kaXRpb247XG4gICAgICAgICAgdGhpcy50cnVlQ2FzZSA9IHRydWVDYXNlO1xuICAgICAgICAgIHRoaXMuZmFsc2VDYXNlID0gZmFsc2VDYXNlO1xuICAgICAgfVxuICAgICAgSWZTdG10LnByb3RvdHlwZS52aXNpdFN0YXRlbWVudCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRJZlN0bXQodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIElmU3RtdDtcbiAgfShTdGF0ZW1lbnQpKTtcbiAgdmFyIENvbW1lbnRTdG10ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQyKENvbW1lbnRTdG10LCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gQ29tbWVudFN0bXQoY29tbWVudCkge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgIHRoaXMuY29tbWVudCA9IGNvbW1lbnQ7XG4gICAgICB9XG4gICAgICBDb21tZW50U3RtdC5wcm90b3R5cGUudmlzaXRTdGF0ZW1lbnQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q29tbWVudFN0bXQodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIENvbW1lbnRTdG10O1xuICB9KFN0YXRlbWVudCkpO1xuICB2YXIgVHJ5Q2F0Y2hTdG10ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQyKFRyeUNhdGNoU3RtdCwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIFRyeUNhdGNoU3RtdChib2R5U3RtdHMsIGNhdGNoU3RtdHMpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICB0aGlzLmJvZHlTdG10cyA9IGJvZHlTdG10cztcbiAgICAgICAgICB0aGlzLmNhdGNoU3RtdHMgPSBjYXRjaFN0bXRzO1xuICAgICAgfVxuICAgICAgVHJ5Q2F0Y2hTdG10LnByb3RvdHlwZS52aXNpdFN0YXRlbWVudCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRUcnlDYXRjaFN0bXQodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFRyeUNhdGNoU3RtdDtcbiAgfShTdGF0ZW1lbnQpKTtcbiAgdmFyIFRocm93U3RtdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMihUaHJvd1N0bXQsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBUaHJvd1N0bXQoZXJyb3IpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgICB9XG4gICAgICBUaHJvd1N0bXQucHJvdG90eXBlLnZpc2l0U3RhdGVtZW50ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFRocm93U3RtdCh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gVGhyb3dTdG10O1xuICB9KFN0YXRlbWVudCkpO1xuICB2YXIgRXhwcmVzc2lvblRyYW5zZm9ybWVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIEV4cHJlc3Npb25UcmFuc2Zvcm1lcigpIHtcbiAgICAgIH1cbiAgICAgIEV4cHJlc3Npb25UcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRSZWFkVmFyRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgcmV0dXJuIGFzdDsgfTtcbiAgICAgIEV4cHJlc3Npb25UcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRXcml0ZVZhckV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiBuZXcgV3JpdGVWYXJFeHByKGV4cHIubmFtZSwgZXhwci52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCkpO1xuICAgICAgfTtcbiAgICAgIEV4cHJlc3Npb25UcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRXcml0ZUtleUV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiBuZXcgV3JpdGVLZXlFeHByKGV4cHIucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCBleHByLmluZGV4LnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSwgZXhwci52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCkpO1xuICAgICAgfTtcbiAgICAgIEV4cHJlc3Npb25UcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRXcml0ZVByb3BFeHByID0gZnVuY3Rpb24gKGV4cHIsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFdyaXRlUHJvcEV4cHIoZXhwci5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIGV4cHIubmFtZSwgZXhwci52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCkpO1xuICAgICAgfTtcbiAgICAgIEV4cHJlc3Npb25UcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRJbnZva2VNZXRob2RFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIHZhciBtZXRob2QgPSBhc3QuYnVpbHRpbiB8fCBhc3QubmFtZTtcbiAgICAgICAgICByZXR1cm4gbmV3IEludm9rZU1ldGhvZEV4cHIoYXN0LnJlY2VpdmVyLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSwgbWV0aG9kLCB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoYXN0LmFyZ3MsIGNvbnRleHQpLCBhc3QudHlwZSk7XG4gICAgICB9O1xuICAgICAgRXhwcmVzc2lvblRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdEludm9rZUZ1bmN0aW9uRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEludm9rZUZ1bmN0aW9uRXhwcihhc3QuZm4udmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoYXN0LmFyZ3MsIGNvbnRleHQpLCBhc3QudHlwZSk7XG4gICAgICB9O1xuICAgICAgRXhwcmVzc2lvblRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdEluc3RhbnRpYXRlRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEluc3RhbnRpYXRlRXhwcihhc3QuY2xhc3NFeHByLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSwgdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5hcmdzLCBjb250ZXh0KSwgYXN0LnR5cGUpO1xuICAgICAgfTtcbiAgICAgIEV4cHJlc3Npb25UcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRMaXRlcmFsRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgcmV0dXJuIGFzdDsgfTtcbiAgICAgIEV4cHJlc3Npb25UcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRFeHRlcm5hbEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBhc3Q7IH07XG4gICAgICBFeHByZXNzaW9uVHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0Q29uZGl0aW9uYWxFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiBuZXcgQ29uZGl0aW9uYWxFeHByKGFzdC5jb25kaXRpb24udmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCBhc3QudHJ1ZUNhc2UudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCBhc3QuZmFsc2VDYXNlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSk7XG4gICAgICB9O1xuICAgICAgRXhwcmVzc2lvblRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdE5vdEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBOb3RFeHByKGFzdC5jb25kaXRpb24udmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpKTtcbiAgICAgIH07XG4gICAgICBFeHByZXNzaW9uVHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0Q2FzdEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBDYXN0RXhwcihhc3QudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICBFeHByZXNzaW9uVHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0RnVuY3Rpb25FeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIC8vIERvbid0IGRlc2NlbmQgaW50byBuZXN0ZWQgZnVuY3Rpb25zXG4gICAgICAgICAgcmV0dXJuIGFzdDtcbiAgICAgIH07XG4gICAgICBFeHByZXNzaW9uVHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0QmluYXJ5T3BlcmF0b3JFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKGFzdC5vcGVyYXRvciwgYXN0Lmxocy52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIGFzdC5yaHMudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCBhc3QudHlwZSk7XG4gICAgICB9O1xuICAgICAgRXhwcmVzc2lvblRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFJlYWRQcm9wRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFJlYWRQcm9wRXhwcihhc3QucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCBhc3QubmFtZSwgYXN0LnR5cGUpO1xuICAgICAgfTtcbiAgICAgIEV4cHJlc3Npb25UcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRSZWFkS2V5RXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFJlYWRLZXlFeHByKGFzdC5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIGFzdC5pbmRleC52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIGFzdC50eXBlKTtcbiAgICAgIH07XG4gICAgICBFeHByZXNzaW9uVHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0TGl0ZXJhbEFycmF5RXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxBcnJheUV4cHIodGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5lbnRyaWVzLCBjb250ZXh0KSk7XG4gICAgICB9O1xuICAgICAgRXhwcmVzc2lvblRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdExpdGVyYWxNYXBFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIGVudHJpZXMgPSBhc3QuZW50cmllcy5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7IHJldHVybiBbZW50cnlbMF0sIGVudHJ5WzFdLnZpc2l0RXhwcmVzc2lvbihfdGhpcywgY29udGV4dCksXTsgfSk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsTWFwRXhwcihlbnRyaWVzKTtcbiAgICAgIH07XG4gICAgICBFeHByZXNzaW9uVHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0QWxsRXhwcmVzc2lvbnMgPSBmdW5jdGlvbiAoZXhwcnMsIGNvbnRleHQpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHJldHVybiBleHBycy5tYXAoZnVuY3Rpb24gKGV4cHIpIHsgcmV0dXJuIGV4cHIudmlzaXRFeHByZXNzaW9uKF90aGlzLCBjb250ZXh0KTsgfSk7XG4gICAgICB9O1xuICAgICAgRXhwcmVzc2lvblRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdERlY2xhcmVWYXJTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IERlY2xhcmVWYXJTdG10KHN0bXQubmFtZSwgc3RtdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIHN0bXQudHlwZSwgc3RtdC5tb2RpZmllcnMpO1xuICAgICAgfTtcbiAgICAgIEV4cHJlc3Npb25UcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXREZWNsYXJlRnVuY3Rpb25TdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgICAvLyBEb24ndCBkZXNjZW5kIGludG8gbmVzdGVkIGZ1bmN0aW9uc1xuICAgICAgICAgIHJldHVybiBzdG10O1xuICAgICAgfTtcbiAgICAgIEV4cHJlc3Npb25UcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBFeHByZXNzaW9uU3RhdGVtZW50KHN0bXQuZXhwci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCkpO1xuICAgICAgfTtcbiAgICAgIEV4cHJlc3Npb25UcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRSZXR1cm5TdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFJldHVyblN0YXRlbWVudChzdG10LnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSk7XG4gICAgICB9O1xuICAgICAgRXhwcmVzc2lvblRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdERlY2xhcmVDbGFzc1N0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICAgIC8vIERvbid0IGRlc2NlbmQgaW50byBuZXN0ZWQgZnVuY3Rpb25zXG4gICAgICAgICAgcmV0dXJuIHN0bXQ7XG4gICAgICB9O1xuICAgICAgRXhwcmVzc2lvblRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdElmU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBJZlN0bXQoc3RtdC5jb25kaXRpb24udmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LnRydWVDYXNlLCBjb250ZXh0KSwgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5mYWxzZUNhc2UsIGNvbnRleHQpKTtcbiAgICAgIH07XG4gICAgICBFeHByZXNzaW9uVHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0VHJ5Q2F0Y2hTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFRyeUNhdGNoU3RtdCh0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LmJvZHlTdG10cywgY29udGV4dCksIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuY2F0Y2hTdG10cywgY29udGV4dCkpO1xuICAgICAgfTtcbiAgICAgIEV4cHJlc3Npb25UcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRUaHJvd1N0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiBuZXcgVGhyb3dTdG10KHN0bXQuZXJyb3IudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpKTtcbiAgICAgIH07XG4gICAgICBFeHByZXNzaW9uVHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0Q29tbWVudFN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkgeyByZXR1cm4gc3RtdDsgfTtcbiAgICAgIEV4cHJlc3Npb25UcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRBbGxTdGF0ZW1lbnRzID0gZnVuY3Rpb24gKHN0bXRzLCBjb250ZXh0KSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICByZXR1cm4gc3RtdHMubWFwKGZ1bmN0aW9uIChzdG10KSB7IHJldHVybiBzdG10LnZpc2l0U3RhdGVtZW50KF90aGlzLCBjb250ZXh0KTsgfSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIEV4cHJlc3Npb25UcmFuc2Zvcm1lcjtcbiAgfSgpKTtcbiAgdmFyIFJlY3Vyc2l2ZUV4cHJlc3Npb25WaXNpdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFJlY3Vyc2l2ZUV4cHJlc3Npb25WaXNpdG9yKCkge1xuICAgICAgfVxuICAgICAgUmVjdXJzaXZlRXhwcmVzc2lvblZpc2l0b3IucHJvdG90eXBlLnZpc2l0UmVhZFZhckV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBhc3Q7IH07XG4gICAgICBSZWN1cnNpdmVFeHByZXNzaW9uVmlzaXRvci5wcm90b3R5cGUudmlzaXRXcml0ZVZhckV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY29udGV4dCkge1xuICAgICAgICAgIGV4cHIudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICAgIHJldHVybiBleHByO1xuICAgICAgfTtcbiAgICAgIFJlY3Vyc2l2ZUV4cHJlc3Npb25WaXNpdG9yLnByb3RvdHlwZS52aXNpdFdyaXRlS2V5RXhwciA9IGZ1bmN0aW9uIChleHByLCBjb250ZXh0KSB7XG4gICAgICAgICAgZXhwci5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgICAgZXhwci5pbmRleC52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgICAgZXhwci52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgICB9O1xuICAgICAgUmVjdXJzaXZlRXhwcmVzc2lvblZpc2l0b3IucHJvdG90eXBlLnZpc2l0V3JpdGVQcm9wRXhwciA9IGZ1bmN0aW9uIChleHByLCBjb250ZXh0KSB7XG4gICAgICAgICAgZXhwci5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgICAgZXhwci52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgICB9O1xuICAgICAgUmVjdXJzaXZlRXhwcmVzc2lvblZpc2l0b3IucHJvdG90eXBlLnZpc2l0SW52b2tlTWV0aG9kRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICBhc3QucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICAgIHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhhc3QuYXJncywgY29udGV4dCk7XG4gICAgICAgICAgcmV0dXJuIGFzdDtcbiAgICAgIH07XG4gICAgICBSZWN1cnNpdmVFeHByZXNzaW9uVmlzaXRvci5wcm90b3R5cGUudmlzaXRJbnZva2VGdW5jdGlvbkV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgYXN0LmZuLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgICB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoYXN0LmFyZ3MsIGNvbnRleHQpO1xuICAgICAgICAgIHJldHVybiBhc3Q7XG4gICAgICB9O1xuICAgICAgUmVjdXJzaXZlRXhwcmVzc2lvblZpc2l0b3IucHJvdG90eXBlLnZpc2l0SW5zdGFudGlhdGVFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIGFzdC5jbGFzc0V4cHIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICAgIHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhhc3QuYXJncywgY29udGV4dCk7XG4gICAgICAgICAgcmV0dXJuIGFzdDtcbiAgICAgIH07XG4gICAgICBSZWN1cnNpdmVFeHByZXNzaW9uVmlzaXRvci5wcm90b3R5cGUudmlzaXRMaXRlcmFsRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgcmV0dXJuIGFzdDsgfTtcbiAgICAgIFJlY3Vyc2l2ZUV4cHJlc3Npb25WaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4dGVybmFsRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgcmV0dXJuIGFzdDsgfTtcbiAgICAgIFJlY3Vyc2l2ZUV4cHJlc3Npb25WaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbmRpdGlvbmFsRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICBhc3QuY29uZGl0aW9uLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgICBhc3QudHJ1ZUNhc2UudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICAgIGFzdC5mYWxzZUNhc2UudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICAgIHJldHVybiBhc3Q7XG4gICAgICB9O1xuICAgICAgUmVjdXJzaXZlRXhwcmVzc2lvblZpc2l0b3IucHJvdG90eXBlLnZpc2l0Tm90RXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICBhc3QuY29uZGl0aW9uLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgICByZXR1cm4gYXN0O1xuICAgICAgfTtcbiAgICAgIFJlY3Vyc2l2ZUV4cHJlc3Npb25WaXNpdG9yLnByb3RvdHlwZS52aXNpdENhc3RFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIGFzdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgICAgcmV0dXJuIGFzdDtcbiAgICAgIH07XG4gICAgICBSZWN1cnNpdmVFeHByZXNzaW9uVmlzaXRvci5wcm90b3R5cGUudmlzaXRGdW5jdGlvbkV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBhc3Q7IH07XG4gICAgICBSZWN1cnNpdmVFeHByZXNzaW9uVmlzaXRvci5wcm90b3R5cGUudmlzaXRCaW5hcnlPcGVyYXRvckV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgYXN0Lmxocy52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgICAgYXN0LnJocy52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgICAgcmV0dXJuIGFzdDtcbiAgICAgIH07XG4gICAgICBSZWN1cnNpdmVFeHByZXNzaW9uVmlzaXRvci5wcm90b3R5cGUudmlzaXRSZWFkUHJvcEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgYXN0LnJlY2VpdmVyLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgICByZXR1cm4gYXN0O1xuICAgICAgfTtcbiAgICAgIFJlY3Vyc2l2ZUV4cHJlc3Npb25WaXNpdG9yLnByb3RvdHlwZS52aXNpdFJlYWRLZXlFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIGFzdC5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgICAgYXN0LmluZGV4LnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgICByZXR1cm4gYXN0O1xuICAgICAgfTtcbiAgICAgIFJlY3Vyc2l2ZUV4cHJlc3Npb25WaXNpdG9yLnByb3RvdHlwZS52aXNpdExpdGVyYWxBcnJheUV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5lbnRyaWVzLCBjb250ZXh0KTtcbiAgICAgICAgICByZXR1cm4gYXN0O1xuICAgICAgfTtcbiAgICAgIFJlY3Vyc2l2ZUV4cHJlc3Npb25WaXNpdG9yLnByb3RvdHlwZS52aXNpdExpdGVyYWxNYXBFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgYXN0LmVudHJpZXMuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuIGVudHJ5WzFdLnZpc2l0RXhwcmVzc2lvbihfdGhpcywgY29udGV4dCk7IH0pO1xuICAgICAgICAgIHJldHVybiBhc3Q7XG4gICAgICB9O1xuICAgICAgUmVjdXJzaXZlRXhwcmVzc2lvblZpc2l0b3IucHJvdG90eXBlLnZpc2l0QWxsRXhwcmVzc2lvbnMgPSBmdW5jdGlvbiAoZXhwcnMsIGNvbnRleHQpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIGV4cHJzLmZvckVhY2goZnVuY3Rpb24gKGV4cHIpIHsgcmV0dXJuIGV4cHIudmlzaXRFeHByZXNzaW9uKF90aGlzLCBjb250ZXh0KTsgfSk7XG4gICAgICB9O1xuICAgICAgUmVjdXJzaXZlRXhwcmVzc2lvblZpc2l0b3IucHJvdG90eXBlLnZpc2l0RGVjbGFyZVZhclN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICAgIHN0bXQudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICAgIHJldHVybiBzdG10O1xuICAgICAgfTtcbiAgICAgIFJlY3Vyc2l2ZUV4cHJlc3Npb25WaXNpdG9yLnByb3RvdHlwZS52aXNpdERlY2xhcmVGdW5jdGlvblN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICAgIC8vIERvbid0IGRlc2NlbmQgaW50byBuZXN0ZWQgZnVuY3Rpb25zXG4gICAgICAgICAgcmV0dXJuIHN0bXQ7XG4gICAgICB9O1xuICAgICAgUmVjdXJzaXZlRXhwcmVzc2lvblZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvblN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICAgIHN0bXQuZXhwci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgICAgcmV0dXJuIHN0bXQ7XG4gICAgICB9O1xuICAgICAgUmVjdXJzaXZlRXhwcmVzc2lvblZpc2l0b3IucHJvdG90eXBlLnZpc2l0UmV0dXJuU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgICAgc3RtdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgICAgcmV0dXJuIHN0bXQ7XG4gICAgICB9O1xuICAgICAgUmVjdXJzaXZlRXhwcmVzc2lvblZpc2l0b3IucHJvdG90eXBlLnZpc2l0RGVjbGFyZUNsYXNzU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgICAgLy8gRG9uJ3QgZGVzY2VuZCBpbnRvIG5lc3RlZCBmdW5jdGlvbnNcbiAgICAgICAgICByZXR1cm4gc3RtdDtcbiAgICAgIH07XG4gICAgICBSZWN1cnNpdmVFeHByZXNzaW9uVmlzaXRvci5wcm90b3R5cGUudmlzaXRJZlN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICAgIHN0bXQuY29uZGl0aW9uLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LnRydWVDYXNlLCBjb250ZXh0KTtcbiAgICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LmZhbHNlQ2FzZSwgY29udGV4dCk7XG4gICAgICAgICAgcmV0dXJuIHN0bXQ7XG4gICAgICB9O1xuICAgICAgUmVjdXJzaXZlRXhwcmVzc2lvblZpc2l0b3IucHJvdG90eXBlLnZpc2l0VHJ5Q2F0Y2hTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LmJvZHlTdG10cywgY29udGV4dCk7XG4gICAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5jYXRjaFN0bXRzLCBjb250ZXh0KTtcbiAgICAgICAgICByZXR1cm4gc3RtdDtcbiAgICAgIH07XG4gICAgICBSZWN1cnNpdmVFeHByZXNzaW9uVmlzaXRvci5wcm90b3R5cGUudmlzaXRUaHJvd1N0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICAgIHN0bXQuZXJyb3IudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICAgIHJldHVybiBzdG10O1xuICAgICAgfTtcbiAgICAgIFJlY3Vyc2l2ZUV4cHJlc3Npb25WaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbW1lbnRTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHsgcmV0dXJuIHN0bXQ7IH07XG4gICAgICBSZWN1cnNpdmVFeHByZXNzaW9uVmlzaXRvci5wcm90b3R5cGUudmlzaXRBbGxTdGF0ZW1lbnRzID0gZnVuY3Rpb24gKHN0bXRzLCBjb250ZXh0KSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICBzdG10cy5mb3JFYWNoKGZ1bmN0aW9uIChzdG10KSB7IHJldHVybiBzdG10LnZpc2l0U3RhdGVtZW50KF90aGlzLCBjb250ZXh0KTsgfSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFJlY3Vyc2l2ZUV4cHJlc3Npb25WaXNpdG9yO1xuICB9KCkpO1xuICBmdW5jdGlvbiByZXBsYWNlVmFySW5FeHByZXNzaW9uKHZhck5hbWUsIG5ld1ZhbHVlLCBleHByZXNzaW9uKSB7XG4gICAgICB2YXIgdHJhbnNmb3JtZXIgPSBuZXcgX1JlcGxhY2VWYXJpYWJsZVRyYW5zZm9ybWVyKHZhck5hbWUsIG5ld1ZhbHVlKTtcbiAgICAgIHJldHVybiBleHByZXNzaW9uLnZpc2l0RXhwcmVzc2lvbih0cmFuc2Zvcm1lciwgbnVsbCk7XG4gIH1cbiAgdmFyIF9SZXBsYWNlVmFyaWFibGVUcmFuc2Zvcm1lciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMihfUmVwbGFjZVZhcmlhYmxlVHJhbnNmb3JtZXIsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBfUmVwbGFjZVZhcmlhYmxlVHJhbnNmb3JtZXIoX3Zhck5hbWUsIF9uZXdWYWx1ZSkge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgIHRoaXMuX3Zhck5hbWUgPSBfdmFyTmFtZTtcbiAgICAgICAgICB0aGlzLl9uZXdWYWx1ZSA9IF9uZXdWYWx1ZTtcbiAgICAgIH1cbiAgICAgIF9SZXBsYWNlVmFyaWFibGVUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRSZWFkVmFyRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gYXN0Lm5hbWUgPT0gdGhpcy5fdmFyTmFtZSA/IHRoaXMuX25ld1ZhbHVlIDogYXN0O1xuICAgICAgfTtcbiAgICAgIHJldHVybiBfUmVwbGFjZVZhcmlhYmxlVHJhbnNmb3JtZXI7XG4gIH0oRXhwcmVzc2lvblRyYW5zZm9ybWVyKSk7XG4gIGZ1bmN0aW9uIGZpbmRSZWFkVmFyTmFtZXMoc3RtdHMpIHtcbiAgICAgIHZhciBmaW5kZXIgPSBuZXcgX1ZhcmlhYmxlRmluZGVyKCk7XG4gICAgICBmaW5kZXIudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXRzLCBudWxsKTtcbiAgICAgIHJldHVybiBmaW5kZXIudmFyTmFtZXM7XG4gIH1cbiAgdmFyIF9WYXJpYWJsZUZpbmRlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMihfVmFyaWFibGVGaW5kZXIsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBfVmFyaWFibGVGaW5kZXIoKSB7XG4gICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgdGhpcy52YXJOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgIH1cbiAgICAgIF9WYXJpYWJsZUZpbmRlci5wcm90b3R5cGUudmlzaXRSZWFkVmFyRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICB0aGlzLnZhck5hbWVzLmFkZChhc3QubmFtZSk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIF9WYXJpYWJsZUZpbmRlcjtcbiAgfShSZWN1cnNpdmVFeHByZXNzaW9uVmlzaXRvcikpO1xuICBmdW5jdGlvbiB2YXJpYWJsZShuYW1lLCB0eXBlKSB7XG4gICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgICByZXR1cm4gbmV3IFJlYWRWYXJFeHByKG5hbWUsIHR5cGUpO1xuICB9XG4gIGZ1bmN0aW9uIGltcG9ydEV4cHIoaWQsIHR5cGVQYXJhbXMpIHtcbiAgICAgIGlmICh0eXBlUGFyYW1zID09PSB2b2lkIDApIHsgdHlwZVBhcmFtcyA9IG51bGw7IH1cbiAgICAgIHJldHVybiBuZXcgRXh0ZXJuYWxFeHByKGlkLCBudWxsLCB0eXBlUGFyYW1zKTtcbiAgfVxuICBmdW5jdGlvbiBpbXBvcnRUeXBlKGlkLCB0eXBlUGFyYW1zLCB0eXBlTW9kaWZpZXJzKSB7XG4gICAgICBpZiAodHlwZVBhcmFtcyA9PT0gdm9pZCAwKSB7IHR5cGVQYXJhbXMgPSBudWxsOyB9XG4gICAgICBpZiAodHlwZU1vZGlmaWVycyA9PT0gdm9pZCAwKSB7IHR5cGVNb2RpZmllcnMgPSBudWxsOyB9XG4gICAgICByZXR1cm4gaXNQcmVzZW50KGlkKSA/IG5ldyBFeHRlcm5hbFR5cGUoaWQsIHR5cGVQYXJhbXMsIHR5cGVNb2RpZmllcnMpIDogbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBsaXRlcmFsQXJyKHZhbHVlcywgdHlwZSkge1xuICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsQXJyYXlFeHByKHZhbHVlcywgdHlwZSk7XG4gIH1cbiAgZnVuY3Rpb24gbGl0ZXJhbE1hcCh2YWx1ZXMsIHR5cGUpIHtcbiAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICAgIHJldHVybiBuZXcgTGl0ZXJhbE1hcEV4cHIodmFsdWVzLCB0eXBlKTtcbiAgfVxuICBmdW5jdGlvbiBub3QoZXhwcikge1xuICAgICAgcmV0dXJuIG5ldyBOb3RFeHByKGV4cHIpO1xuICB9XG4gIGZ1bmN0aW9uIGZuKHBhcmFtcywgYm9keSwgdHlwZSkge1xuICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbkV4cHIocGFyYW1zLCBib2R5LCB0eXBlKTtcbiAgfVxuICBmdW5jdGlvbiBsaXRlcmFsKHZhbHVlLCB0eXBlKSB7XG4gICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgICByZXR1cm4gbmV3IExpdGVyYWxFeHByKHZhbHVlLCB0eXBlKTtcbiAgfVxuXG4gIHZhciBNT0RVTEVfU1VGRklYID0gJyc7XG4gIGZ1bmN0aW9uIHNwbGl0QXRDb2xvbihpbnB1dCwgZGVmYXVsdFZhbHVlcykge1xuICAgICAgcmV0dXJuIF9zcGxpdEF0KGlucHV0LCAnOicsIGRlZmF1bHRWYWx1ZXMpO1xuICB9XG4gIGZ1bmN0aW9uIHNwbGl0QXRQZXJpb2QoaW5wdXQsIGRlZmF1bHRWYWx1ZXMpIHtcbiAgICAgIHJldHVybiBfc3BsaXRBdChpbnB1dCwgJy4nLCBkZWZhdWx0VmFsdWVzKTtcbiAgfVxuICBmdW5jdGlvbiBfc3BsaXRBdChpbnB1dCwgY2hhcmFjdGVyLCBkZWZhdWx0VmFsdWVzKSB7XG4gICAgICB2YXIgY2hhcmFjdGVySW5kZXggPSBpbnB1dC5pbmRleE9mKGNoYXJhY3Rlcik7XG4gICAgICBpZiAoY2hhcmFjdGVySW5kZXggPT0gLTEpXG4gICAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZXM7XG4gICAgICByZXR1cm4gW2lucHV0LnNsaWNlKDAsIGNoYXJhY3RlckluZGV4KS50cmltKCksIGlucHV0LnNsaWNlKGNoYXJhY3RlckluZGV4ICsgMSkudHJpbSgpXTtcbiAgfVxuICBmdW5jdGlvbiBzYW5pdGl6ZUlkZW50aWZpZXIobmFtZSkge1xuICAgICAgcmV0dXJuIG5hbWUucmVwbGFjZSgvXFxXL2csICdfJyk7XG4gIH1cbiAgZnVuY3Rpb24gdmlzaXRWYWx1ZSh2YWx1ZSwgdmlzaXRvciwgY29udGV4dCkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRBcnJheSh2YWx1ZSwgY29udGV4dCk7XG4gICAgICB9XG4gICAgICBpZiAoaXNTdHJpY3RTdHJpbmdNYXAodmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRTdHJpbmdNYXAodmFsdWUsIGNvbnRleHQpO1xuICAgICAgfVxuICAgICAgaWYgKGlzQmxhbmsodmFsdWUpIHx8IGlzUHJpbWl0aXZlKHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0UHJpbWl0aXZlKHZhbHVlLCBjb250ZXh0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0T3RoZXIodmFsdWUsIGNvbnRleHQpO1xuICB9XG4gIHZhciBWYWx1ZVRyYW5zZm9ybWVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFZhbHVlVHJhbnNmb3JtZXIoKSB7XG4gICAgICB9XG4gICAgICBWYWx1ZVRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdEFycmF5ID0gZnVuY3Rpb24gKGFyciwgY29udGV4dCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgcmV0dXJuIGFyci5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2aXNpdFZhbHVlKHZhbHVlLCBfdGhpcywgY29udGV4dCk7IH0pO1xuICAgICAgfTtcbiAgICAgIFZhbHVlVHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0U3RyaW5nTWFwID0gZnVuY3Rpb24gKG1hcCwgY29udGV4dCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICAgIE9iamVjdC5rZXlzKG1hcCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IHJlc3VsdFtrZXldID0gdmlzaXRWYWx1ZShtYXBba2V5XSwgX3RoaXMsIGNvbnRleHQpOyB9KTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICAgIFZhbHVlVHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0UHJpbWl0aXZlID0gZnVuY3Rpb24gKHZhbHVlLCBjb250ZXh0KSB7IHJldHVybiB2YWx1ZTsgfTtcbiAgICAgIFZhbHVlVHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0T3RoZXIgPSBmdW5jdGlvbiAodmFsdWUsIGNvbnRleHQpIHsgcmV0dXJuIHZhbHVlOyB9O1xuICAgICAgcmV0dXJuIFZhbHVlVHJhbnNmb3JtZXI7XG4gIH0oKSk7XG4gIGZ1bmN0aW9uIGFzc2V0VXJsKHBrZywgcGF0aCwgdHlwZSkge1xuICAgICAgaWYgKHBhdGggPT09IHZvaWQgMCkgeyBwYXRoID0gbnVsbDsgfVxuICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gJ3NyYyc7IH1cbiAgICAgIGlmIChwYXRoID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gXCJhc3NldDpAYW5ndWxhci9saWIvXCIgKyBwa2cgKyBcIi9pbmRleFwiO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFwiYXNzZXQ6QGFuZ3VsYXIvbGliL1wiICsgcGtnICsgXCIvc3JjL1wiICsgcGF0aDtcbiAgICAgIH1cbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVEaVRva2VuRXhwcmVzc2lvbih0b2tlbikge1xuICAgICAgaWYgKGlzUHJlc2VudCh0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gbGl0ZXJhbCh0b2tlbi52YWx1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0b2tlbi5pZGVudGlmaWVySXNJbnN0YW5jZSkge1xuICAgICAgICAgIHJldHVybiBpbXBvcnRFeHByKHRva2VuLmlkZW50aWZpZXIpXG4gICAgICAgICAgICAgIC5pbnN0YW50aWF0ZShbXSwgaW1wb3J0VHlwZSh0b2tlbi5pZGVudGlmaWVyLCBbXSwgW1R5cGVNb2RpZmllci5Db25zdF0pKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBpbXBvcnRFeHByKHRva2VuLmlkZW50aWZpZXIpO1xuICAgICAgfVxuICB9XG4gIHZhciBTeW5jQXN5bmNSZXN1bHQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gU3luY0FzeW5jUmVzdWx0KHN5bmNSZXN1bHQsIGFzeW5jUmVzdWx0KSB7XG4gICAgICAgICAgaWYgKGFzeW5jUmVzdWx0ID09PSB2b2lkIDApIHsgYXN5bmNSZXN1bHQgPSBudWxsOyB9XG4gICAgICAgICAgdGhpcy5zeW5jUmVzdWx0ID0gc3luY1Jlc3VsdDtcbiAgICAgICAgICB0aGlzLmFzeW5jUmVzdWx0ID0gYXN5bmNSZXN1bHQ7XG4gICAgICAgICAgaWYgKCFhc3luY1Jlc3VsdCkge1xuICAgICAgICAgICAgICB0aGlzLmFzeW5jUmVzdWx0ID0gUHJvbWlzZS5yZXNvbHZlKHN5bmNSZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBTeW5jQXN5bmNSZXN1bHQ7XG4gIH0oKSk7XG5cbiAgLyoqXG4gICAqIEBsaWNlbnNlXG4gICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgKlxuICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAqL1xuICB2YXIgX19leHRlbmRzJDEgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gIH07XG4gIGZ1bmN0aW9uIHVuaW1wbGVtZW50ZWQoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuaW1wbGVtZW50ZWQnKTtcbiAgfVxuICAvLyBncm91cCAwOiBcIltwcm9wXSBvciAoZXZlbnQpIG9yIEB0cmlnZ2VyXCJcbiAgLy8gZ3JvdXAgMTogXCJwcm9wXCIgZnJvbSBcIltwcm9wXVwiXG4gIC8vIGdyb3VwIDI6IFwiZXZlbnRcIiBmcm9tIFwiKGV2ZW50KVwiXG4gIC8vIGdyb3VwIDM6IFwiQHRyaWdnZXJcIiBmcm9tIFwiQHRyaWdnZXJcIlxuICB2YXIgSE9TVF9SRUdfRVhQID0gL14oPzooPzpcXFsoW15cXF1dKylcXF0pfCg/OlxcKChbXlxcKV0rKVxcKSkpfChcXEBbLVxcd10rKSQvO1xuICB2YXIgQ29tcGlsZU1ldGFkYXRhV2l0aElkZW50aWZpZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQ29tcGlsZU1ldGFkYXRhV2l0aElkZW50aWZpZXIoKSB7XG4gICAgICB9XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcGlsZU1ldGFkYXRhV2l0aElkZW50aWZpZXIucHJvdG90eXBlLCBcImlkZW50aWZpZXJcIiwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBDb21waWxlTWV0YWRhdGFXaXRoSWRlbnRpZmllcjtcbiAgfSgpKTtcbiAgdmFyIENvbXBpbGVBbmltYXRpb25FbnRyeU1ldGFkYXRhID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIENvbXBpbGVBbmltYXRpb25FbnRyeU1ldGFkYXRhKG5hbWUsIGRlZmluaXRpb25zKSB7XG4gICAgICAgICAgaWYgKG5hbWUgPT09IHZvaWQgMCkgeyBuYW1lID0gbnVsbDsgfVxuICAgICAgICAgIGlmIChkZWZpbml0aW9ucyA9PT0gdm9pZCAwKSB7IGRlZmluaXRpb25zID0gbnVsbDsgfVxuICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgdGhpcy5kZWZpbml0aW9ucyA9IGRlZmluaXRpb25zO1xuICAgICAgfVxuICAgICAgcmV0dXJuIENvbXBpbGVBbmltYXRpb25FbnRyeU1ldGFkYXRhO1xuICB9KCkpO1xuICB2YXIgQ29tcGlsZUFuaW1hdGlvblN0YXRlTWV0YWRhdGEgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQ29tcGlsZUFuaW1hdGlvblN0YXRlTWV0YWRhdGEoKSB7XG4gICAgICB9XG4gICAgICByZXR1cm4gQ29tcGlsZUFuaW1hdGlvblN0YXRlTWV0YWRhdGE7XG4gIH0oKSk7XG4gIHZhciBDb21waWxlQW5pbWF0aW9uU3RhdGVEZWNsYXJhdGlvbk1ldGFkYXRhID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQxKENvbXBpbGVBbmltYXRpb25TdGF0ZURlY2xhcmF0aW9uTWV0YWRhdGEsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBDb21waWxlQW5pbWF0aW9uU3RhdGVEZWNsYXJhdGlvbk1ldGFkYXRhKHN0YXRlTmFtZUV4cHIsIHN0eWxlcykge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgIHRoaXMuc3RhdGVOYW1lRXhwciA9IHN0YXRlTmFtZUV4cHI7XG4gICAgICAgICAgdGhpcy5zdHlsZXMgPSBzdHlsZXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gQ29tcGlsZUFuaW1hdGlvblN0YXRlRGVjbGFyYXRpb25NZXRhZGF0YTtcbiAgfShDb21waWxlQW5pbWF0aW9uU3RhdGVNZXRhZGF0YSkpO1xuICB2YXIgQ29tcGlsZUFuaW1hdGlvblN0YXRlVHJhbnNpdGlvbk1ldGFkYXRhID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQxKENvbXBpbGVBbmltYXRpb25TdGF0ZVRyYW5zaXRpb25NZXRhZGF0YSwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIENvbXBpbGVBbmltYXRpb25TdGF0ZVRyYW5zaXRpb25NZXRhZGF0YShzdGF0ZUNoYW5nZUV4cHIsIHN0ZXBzKSB7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZUV4cHIgPSBzdGF0ZUNoYW5nZUV4cHI7XG4gICAgICAgICAgdGhpcy5zdGVwcyA9IHN0ZXBzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIENvbXBpbGVBbmltYXRpb25TdGF0ZVRyYW5zaXRpb25NZXRhZGF0YTtcbiAgfShDb21waWxlQW5pbWF0aW9uU3RhdGVNZXRhZGF0YSkpO1xuICB2YXIgQ29tcGlsZUFuaW1hdGlvbk1ldGFkYXRhID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIENvbXBpbGVBbmltYXRpb25NZXRhZGF0YSgpIHtcbiAgICAgIH1cbiAgICAgIHJldHVybiBDb21waWxlQW5pbWF0aW9uTWV0YWRhdGE7XG4gIH0oKSk7XG4gIHZhciBDb21waWxlQW5pbWF0aW9uS2V5ZnJhbWVzU2VxdWVuY2VNZXRhZGF0YSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMShDb21waWxlQW5pbWF0aW9uS2V5ZnJhbWVzU2VxdWVuY2VNZXRhZGF0YSwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIENvbXBpbGVBbmltYXRpb25LZXlmcmFtZXNTZXF1ZW5jZU1ldGFkYXRhKHN0ZXBzKSB7XG4gICAgICAgICAgaWYgKHN0ZXBzID09PSB2b2lkIDApIHsgc3RlcHMgPSBbXTsgfVxuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgIHRoaXMuc3RlcHMgPSBzdGVwcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBDb21waWxlQW5pbWF0aW9uS2V5ZnJhbWVzU2VxdWVuY2VNZXRhZGF0YTtcbiAgfShDb21waWxlQW5pbWF0aW9uTWV0YWRhdGEpKTtcbiAgdmFyIENvbXBpbGVBbmltYXRpb25TdHlsZU1ldGFkYXRhID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQxKENvbXBpbGVBbmltYXRpb25TdHlsZU1ldGFkYXRhLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gQ29tcGlsZUFuaW1hdGlvblN0eWxlTWV0YWRhdGEob2Zmc2V0LCBzdHlsZXMpIHtcbiAgICAgICAgICBpZiAoc3R5bGVzID09PSB2b2lkIDApIHsgc3R5bGVzID0gbnVsbDsgfVxuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgIHRoaXMuc3R5bGVzID0gc3R5bGVzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIENvbXBpbGVBbmltYXRpb25TdHlsZU1ldGFkYXRhO1xuICB9KENvbXBpbGVBbmltYXRpb25NZXRhZGF0YSkpO1xuICB2YXIgQ29tcGlsZUFuaW1hdGlvbkFuaW1hdGVNZXRhZGF0YSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMShDb21waWxlQW5pbWF0aW9uQW5pbWF0ZU1ldGFkYXRhLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gQ29tcGlsZUFuaW1hdGlvbkFuaW1hdGVNZXRhZGF0YSh0aW1pbmdzLCBzdHlsZXMpIHtcbiAgICAgICAgICBpZiAodGltaW5ncyA9PT0gdm9pZCAwKSB7IHRpbWluZ3MgPSAwOyB9XG4gICAgICAgICAgaWYgKHN0eWxlcyA9PT0gdm9pZCAwKSB7IHN0eWxlcyA9IG51bGw7IH1cbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICB0aGlzLnRpbWluZ3MgPSB0aW1pbmdzO1xuICAgICAgICAgIHRoaXMuc3R5bGVzID0gc3R5bGVzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIENvbXBpbGVBbmltYXRpb25BbmltYXRlTWV0YWRhdGE7XG4gIH0oQ29tcGlsZUFuaW1hdGlvbk1ldGFkYXRhKSk7XG4gIHZhciBDb21waWxlQW5pbWF0aW9uV2l0aFN0ZXBzTWV0YWRhdGEgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDEoQ29tcGlsZUFuaW1hdGlvbldpdGhTdGVwc01ldGFkYXRhLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gQ29tcGlsZUFuaW1hdGlvbldpdGhTdGVwc01ldGFkYXRhKHN0ZXBzKSB7XG4gICAgICAgICAgaWYgKHN0ZXBzID09PSB2b2lkIDApIHsgc3RlcHMgPSBudWxsOyB9XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgdGhpcy5zdGVwcyA9IHN0ZXBzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIENvbXBpbGVBbmltYXRpb25XaXRoU3RlcHNNZXRhZGF0YTtcbiAgfShDb21waWxlQW5pbWF0aW9uTWV0YWRhdGEpKTtcbiAgdmFyIENvbXBpbGVBbmltYXRpb25TZXF1ZW5jZU1ldGFkYXRhID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQxKENvbXBpbGVBbmltYXRpb25TZXF1ZW5jZU1ldGFkYXRhLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gQ29tcGlsZUFuaW1hdGlvblNlcXVlbmNlTWV0YWRhdGEoc3RlcHMpIHtcbiAgICAgICAgICBpZiAoc3RlcHMgPT09IHZvaWQgMCkgeyBzdGVwcyA9IG51bGw7IH1cbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBzdGVwcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gQ29tcGlsZUFuaW1hdGlvblNlcXVlbmNlTWV0YWRhdGE7XG4gIH0oQ29tcGlsZUFuaW1hdGlvbldpdGhTdGVwc01ldGFkYXRhKSk7XG4gIHZhciBDb21waWxlQW5pbWF0aW9uR3JvdXBNZXRhZGF0YSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMShDb21waWxlQW5pbWF0aW9uR3JvdXBNZXRhZGF0YSwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIENvbXBpbGVBbmltYXRpb25Hcm91cE1ldGFkYXRhKHN0ZXBzKSB7XG4gICAgICAgICAgaWYgKHN0ZXBzID09PSB2b2lkIDApIHsgc3RlcHMgPSBudWxsOyB9XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgc3RlcHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIENvbXBpbGVBbmltYXRpb25Hcm91cE1ldGFkYXRhO1xuICB9KENvbXBpbGVBbmltYXRpb25XaXRoU3RlcHNNZXRhZGF0YSkpO1xuICB2YXIgQ29tcGlsZUlkZW50aWZpZXJNZXRhZGF0YSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBDb21waWxlSWRlbnRpZmllck1ldGFkYXRhKF9hKSB7XG4gICAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIHJlZmVyZW5jZSA9IF9iLnJlZmVyZW5jZSwgbmFtZSA9IF9iLm5hbWUsIG1vZHVsZVVybCA9IF9iLm1vZHVsZVVybCwgcHJlZml4ID0gX2IucHJlZml4LCB2YWx1ZSA9IF9iLnZhbHVlO1xuICAgICAgICAgIHRoaXMucmVmZXJlbmNlID0gcmVmZXJlbmNlO1xuICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgdGhpcy5wcmVmaXggPSBwcmVmaXg7XG4gICAgICAgICAgdGhpcy5tb2R1bGVVcmwgPSBtb2R1bGVVcmw7XG4gICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBpbGVJZGVudGlmaWVyTWV0YWRhdGEucHJvdG90eXBlLCBcImlkZW50aWZpZXJcIiwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gQ29tcGlsZUlkZW50aWZpZXJNZXRhZGF0YTtcbiAgfSgpKTtcbiAgdmFyIENvbXBpbGVEaURlcGVuZGVuY3lNZXRhZGF0YSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBDb21waWxlRGlEZXBlbmRlbmN5TWV0YWRhdGEoX2EpIHtcbiAgICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgaXNBdHRyaWJ1dGUgPSBfYi5pc0F0dHJpYnV0ZSwgaXNTZWxmID0gX2IuaXNTZWxmLCBpc0hvc3QgPSBfYi5pc0hvc3QsIGlzU2tpcFNlbGYgPSBfYi5pc1NraXBTZWxmLCBpc09wdGlvbmFsID0gX2IuaXNPcHRpb25hbCwgaXNWYWx1ZSA9IF9iLmlzVmFsdWUsIHF1ZXJ5ID0gX2IucXVlcnksIHZpZXdRdWVyeSA9IF9iLnZpZXdRdWVyeSwgdG9rZW4gPSBfYi50b2tlbiwgdmFsdWUgPSBfYi52YWx1ZTtcbiAgICAgICAgICB0aGlzLmlzQXR0cmlidXRlID0gbm9ybWFsaXplQm9vbChpc0F0dHJpYnV0ZSk7XG4gICAgICAgICAgdGhpcy5pc1NlbGYgPSBub3JtYWxpemVCb29sKGlzU2VsZik7XG4gICAgICAgICAgdGhpcy5pc0hvc3QgPSBub3JtYWxpemVCb29sKGlzSG9zdCk7XG4gICAgICAgICAgdGhpcy5pc1NraXBTZWxmID0gbm9ybWFsaXplQm9vbChpc1NraXBTZWxmKTtcbiAgICAgICAgICB0aGlzLmlzT3B0aW9uYWwgPSBub3JtYWxpemVCb29sKGlzT3B0aW9uYWwpO1xuICAgICAgICAgIHRoaXMuaXNWYWx1ZSA9IG5vcm1hbGl6ZUJvb2woaXNWYWx1ZSk7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5O1xuICAgICAgICAgIHRoaXMudmlld1F1ZXJ5ID0gdmlld1F1ZXJ5O1xuICAgICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gQ29tcGlsZURpRGVwZW5kZW5jeU1ldGFkYXRhO1xuICB9KCkpO1xuICB2YXIgQ29tcGlsZVByb3ZpZGVyTWV0YWRhdGEgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQ29tcGlsZVByb3ZpZGVyTWV0YWRhdGEoX2EpIHtcbiAgICAgICAgICB2YXIgdG9rZW4gPSBfYS50b2tlbiwgdXNlQ2xhc3MgPSBfYS51c2VDbGFzcywgdXNlVmFsdWUgPSBfYS51c2VWYWx1ZSwgdXNlRXhpc3RpbmcgPSBfYS51c2VFeGlzdGluZywgdXNlRmFjdG9yeSA9IF9hLnVzZUZhY3RvcnksIGRlcHMgPSBfYS5kZXBzLCBtdWx0aSA9IF9hLm11bHRpO1xuICAgICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICB0aGlzLnVzZUNsYXNzID0gdXNlQ2xhc3M7XG4gICAgICAgICAgdGhpcy51c2VWYWx1ZSA9IHVzZVZhbHVlO1xuICAgICAgICAgIHRoaXMudXNlRXhpc3RpbmcgPSB1c2VFeGlzdGluZztcbiAgICAgICAgICB0aGlzLnVzZUZhY3RvcnkgPSB1c2VGYWN0b3J5O1xuICAgICAgICAgIHRoaXMuZGVwcyA9IG5vcm1hbGl6ZUJsYW5rKGRlcHMpO1xuICAgICAgICAgIHRoaXMubXVsdGkgPSBub3JtYWxpemVCb29sKG11bHRpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBDb21waWxlUHJvdmlkZXJNZXRhZGF0YTtcbiAgfSgpKTtcbiAgdmFyIENvbXBpbGVGYWN0b3J5TWV0YWRhdGEgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDEoQ29tcGlsZUZhY3RvcnlNZXRhZGF0YSwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIENvbXBpbGVGYWN0b3J5TWV0YWRhdGEoX2EpIHtcbiAgICAgICAgICB2YXIgcmVmZXJlbmNlID0gX2EucmVmZXJlbmNlLCBuYW1lID0gX2EubmFtZSwgbW9kdWxlVXJsID0gX2EubW9kdWxlVXJsLCBwcmVmaXggPSBfYS5wcmVmaXgsIGRpRGVwcyA9IF9hLmRpRGVwcywgdmFsdWUgPSBfYS52YWx1ZTtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCB7IHJlZmVyZW5jZTogcmVmZXJlbmNlLCBuYW1lOiBuYW1lLCBwcmVmaXg6IHByZWZpeCwgbW9kdWxlVXJsOiBtb2R1bGVVcmwsIHZhbHVlOiB2YWx1ZSB9KTtcbiAgICAgICAgICB0aGlzLmRpRGVwcyA9IF9ub3JtYWxpemVBcnJheShkaURlcHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIENvbXBpbGVGYWN0b3J5TWV0YWRhdGE7XG4gIH0oQ29tcGlsZUlkZW50aWZpZXJNZXRhZGF0YSkpO1xuICB2YXIgQ29tcGlsZVRva2VuTWV0YWRhdGEgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQ29tcGlsZVRva2VuTWV0YWRhdGEoX2EpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBfYS52YWx1ZSwgaWRlbnRpZmllciA9IF9hLmlkZW50aWZpZXIsIGlkZW50aWZpZXJJc0luc3RhbmNlID0gX2EuaWRlbnRpZmllcklzSW5zdGFuY2U7XG4gICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIHRoaXMuaWRlbnRpZmllciA9IGlkZW50aWZpZXI7XG4gICAgICAgICAgdGhpcy5pZGVudGlmaWVySXNJbnN0YW5jZSA9IG5vcm1hbGl6ZUJvb2woaWRlbnRpZmllcklzSW5zdGFuY2UpO1xuICAgICAgfVxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBpbGVUb2tlbk1ldGFkYXRhLnByb3RvdHlwZSwgXCJyZWZlcmVuY2VcIiwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuaWRlbnRpZmllcikpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmlkZW50aWZpZXIucmVmZXJlbmNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21waWxlVG9rZW5NZXRhZGF0YS5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy52YWx1ZSkgPyBzYW5pdGl6ZUlkZW50aWZpZXIodGhpcy52YWx1ZSkgOiB0aGlzLmlkZW50aWZpZXIubmFtZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBDb21waWxlVG9rZW5NZXRhZGF0YTtcbiAgfSgpKTtcbiAgLyoqXG4gICAqIE1ldGFkYXRhIHJlZ2FyZGluZyBjb21waWxhdGlvbiBvZiBhIHR5cGUuXG4gICAqL1xuICB2YXIgQ29tcGlsZVR5cGVNZXRhZGF0YSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMShDb21waWxlVHlwZU1ldGFkYXRhLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gQ29tcGlsZVR5cGVNZXRhZGF0YShfYSkge1xuICAgICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCByZWZlcmVuY2UgPSBfYi5yZWZlcmVuY2UsIG5hbWUgPSBfYi5uYW1lLCBtb2R1bGVVcmwgPSBfYi5tb2R1bGVVcmwsIHByZWZpeCA9IF9iLnByZWZpeCwgaXNIb3N0ID0gX2IuaXNIb3N0LCB2YWx1ZSA9IF9iLnZhbHVlLCBkaURlcHMgPSBfYi5kaURlcHMsIGxpZmVjeWNsZUhvb2tzID0gX2IubGlmZWN5Y2xlSG9va3M7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgeyByZWZlcmVuY2U6IHJlZmVyZW5jZSwgbmFtZTogbmFtZSwgbW9kdWxlVXJsOiBtb2R1bGVVcmwsIHByZWZpeDogcHJlZml4LCB2YWx1ZTogdmFsdWUgfSk7XG4gICAgICAgICAgdGhpcy5pc0hvc3QgPSBub3JtYWxpemVCb29sKGlzSG9zdCk7XG4gICAgICAgICAgdGhpcy5kaURlcHMgPSBfbm9ybWFsaXplQXJyYXkoZGlEZXBzKTtcbiAgICAgICAgICB0aGlzLmxpZmVjeWNsZUhvb2tzID0gX25vcm1hbGl6ZUFycmF5KGxpZmVjeWNsZUhvb2tzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBDb21waWxlVHlwZU1ldGFkYXRhO1xuICB9KENvbXBpbGVJZGVudGlmaWVyTWV0YWRhdGEpKTtcbiAgdmFyIENvbXBpbGVRdWVyeU1ldGFkYXRhID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIENvbXBpbGVRdWVyeU1ldGFkYXRhKF9hKSB7XG4gICAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIHNlbGVjdG9ycyA9IF9iLnNlbGVjdG9ycywgZGVzY2VuZGFudHMgPSBfYi5kZXNjZW5kYW50cywgZmlyc3QgPSBfYi5maXJzdCwgcHJvcGVydHlOYW1lID0gX2IucHJvcGVydHlOYW1lLCByZWFkID0gX2IucmVhZDtcbiAgICAgICAgICB0aGlzLnNlbGVjdG9ycyA9IHNlbGVjdG9ycztcbiAgICAgICAgICB0aGlzLmRlc2NlbmRhbnRzID0gbm9ybWFsaXplQm9vbChkZXNjZW5kYW50cyk7XG4gICAgICAgICAgdGhpcy5maXJzdCA9IG5vcm1hbGl6ZUJvb2woZmlyc3QpO1xuICAgICAgICAgIHRoaXMucHJvcGVydHlOYW1lID0gcHJvcGVydHlOYW1lO1xuICAgICAgICAgIHRoaXMucmVhZCA9IHJlYWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gQ29tcGlsZVF1ZXJ5TWV0YWRhdGE7XG4gIH0oKSk7XG4gIC8qKlxuICAgKiBNZXRhZGF0YSBhYm91dCBhIHN0eWxlc2hlZXRcbiAgICovXG4gIHZhciBDb21waWxlU3R5bGVzaGVldE1ldGFkYXRhID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIENvbXBpbGVTdHlsZXNoZWV0TWV0YWRhdGEoX2EpIHtcbiAgICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgbW9kdWxlVXJsID0gX2IubW9kdWxlVXJsLCBzdHlsZXMgPSBfYi5zdHlsZXMsIHN0eWxlVXJscyA9IF9iLnN0eWxlVXJscztcbiAgICAgICAgICB0aGlzLm1vZHVsZVVybCA9IG1vZHVsZVVybDtcbiAgICAgICAgICB0aGlzLnN0eWxlcyA9IF9ub3JtYWxpemVBcnJheShzdHlsZXMpO1xuICAgICAgICAgIHRoaXMuc3R5bGVVcmxzID0gX25vcm1hbGl6ZUFycmF5KHN0eWxlVXJscyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gQ29tcGlsZVN0eWxlc2hlZXRNZXRhZGF0YTtcbiAgfSgpKTtcbiAgLyoqXG4gICAqIE1ldGFkYXRhIHJlZ2FyZGluZyBjb21waWxhdGlvbiBvZiBhIHRlbXBsYXRlLlxuICAgKi9cbiAgdmFyIENvbXBpbGVUZW1wbGF0ZU1ldGFkYXRhID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIENvbXBpbGVUZW1wbGF0ZU1ldGFkYXRhKF9hKSB7XG4gICAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIGVuY2Fwc3VsYXRpb24gPSBfYi5lbmNhcHN1bGF0aW9uLCB0ZW1wbGF0ZSA9IF9iLnRlbXBsYXRlLCB0ZW1wbGF0ZVVybCA9IF9iLnRlbXBsYXRlVXJsLCBzdHlsZXMgPSBfYi5zdHlsZXMsIHN0eWxlVXJscyA9IF9iLnN0eWxlVXJscywgZXh0ZXJuYWxTdHlsZXNoZWV0cyA9IF9iLmV4dGVybmFsU3R5bGVzaGVldHMsIGFuaW1hdGlvbnMgPSBfYi5hbmltYXRpb25zLCBuZ0NvbnRlbnRTZWxlY3RvcnMgPSBfYi5uZ0NvbnRlbnRTZWxlY3RvcnMsIGludGVycG9sYXRpb24gPSBfYi5pbnRlcnBvbGF0aW9uO1xuICAgICAgICAgIHRoaXMuZW5jYXBzdWxhdGlvbiA9IGVuY2Fwc3VsYXRpb247XG4gICAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgICAgICAgIHRoaXMudGVtcGxhdGVVcmwgPSB0ZW1wbGF0ZVVybDtcbiAgICAgICAgICB0aGlzLnN0eWxlcyA9IF9ub3JtYWxpemVBcnJheShzdHlsZXMpO1xuICAgICAgICAgIHRoaXMuc3R5bGVVcmxzID0gX25vcm1hbGl6ZUFycmF5KHN0eWxlVXJscyk7XG4gICAgICAgICAgdGhpcy5leHRlcm5hbFN0eWxlc2hlZXRzID0gX25vcm1hbGl6ZUFycmF5KGV4dGVybmFsU3R5bGVzaGVldHMpO1xuICAgICAgICAgIHRoaXMuYW5pbWF0aW9ucyA9IGlzUHJlc2VudChhbmltYXRpb25zKSA/IExpc3RXcmFwcGVyLmZsYXR0ZW4oYW5pbWF0aW9ucykgOiBbXTtcbiAgICAgICAgICB0aGlzLm5nQ29udGVudFNlbGVjdG9ycyA9IG5nQ29udGVudFNlbGVjdG9ycyB8fCBbXTtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KGludGVycG9sYXRpb24pICYmIGludGVycG9sYXRpb24ubGVuZ3RoICE9IDIpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiJ2ludGVycG9sYXRpb24nIHNob3VsZCBoYXZlIGEgc3RhcnQgYW5kIGFuIGVuZCBzeW1ib2wuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmludGVycG9sYXRpb24gPSBpbnRlcnBvbGF0aW9uO1xuICAgICAgfVxuICAgICAgcmV0dXJuIENvbXBpbGVUZW1wbGF0ZU1ldGFkYXRhO1xuICB9KCkpO1xuICAvKipcbiAgICogTWV0YWRhdGEgcmVnYXJkaW5nIGNvbXBpbGF0aW9uIG9mIGEgZGlyZWN0aXZlLlxuICAgKi9cbiAgdmFyIENvbXBpbGVEaXJlY3RpdmVNZXRhZGF0YSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBDb21waWxlRGlyZWN0aXZlTWV0YWRhdGEoX2EpIHtcbiAgICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgdHlwZSA9IF9iLnR5cGUsIGlzQ29tcG9uZW50ID0gX2IuaXNDb21wb25lbnQsIHNlbGVjdG9yID0gX2Iuc2VsZWN0b3IsIGV4cG9ydEFzID0gX2IuZXhwb3J0QXMsIGNoYW5nZURldGVjdGlvbiA9IF9iLmNoYW5nZURldGVjdGlvbiwgaW5wdXRzID0gX2IuaW5wdXRzLCBvdXRwdXRzID0gX2Iub3V0cHV0cywgaG9zdExpc3RlbmVycyA9IF9iLmhvc3RMaXN0ZW5lcnMsIGhvc3RQcm9wZXJ0aWVzID0gX2IuaG9zdFByb3BlcnRpZXMsIGhvc3RBdHRyaWJ1dGVzID0gX2IuaG9zdEF0dHJpYnV0ZXMsIHByb3ZpZGVycyA9IF9iLnByb3ZpZGVycywgdmlld1Byb3ZpZGVycyA9IF9iLnZpZXdQcm92aWRlcnMsIHF1ZXJpZXMgPSBfYi5xdWVyaWVzLCB2aWV3UXVlcmllcyA9IF9iLnZpZXdRdWVyaWVzLCBlbnRyeUNvbXBvbmVudHMgPSBfYi5lbnRyeUNvbXBvbmVudHMsIHRlbXBsYXRlID0gX2IudGVtcGxhdGU7XG4gICAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgICB0aGlzLmlzQ29tcG9uZW50ID0gaXNDb21wb25lbnQ7XG4gICAgICAgICAgdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgICAgICAgIHRoaXMuZXhwb3J0QXMgPSBleHBvcnRBcztcbiAgICAgICAgICB0aGlzLmNoYW5nZURldGVjdGlvbiA9IGNoYW5nZURldGVjdGlvbjtcbiAgICAgICAgICB0aGlzLmlucHV0cyA9IGlucHV0cztcbiAgICAgICAgICB0aGlzLm91dHB1dHMgPSBvdXRwdXRzO1xuICAgICAgICAgIHRoaXMuaG9zdExpc3RlbmVycyA9IGhvc3RMaXN0ZW5lcnM7XG4gICAgICAgICAgdGhpcy5ob3N0UHJvcGVydGllcyA9IGhvc3RQcm9wZXJ0aWVzO1xuICAgICAgICAgIHRoaXMuaG9zdEF0dHJpYnV0ZXMgPSBob3N0QXR0cmlidXRlcztcbiAgICAgICAgICB0aGlzLnByb3ZpZGVycyA9IF9ub3JtYWxpemVBcnJheShwcm92aWRlcnMpO1xuICAgICAgICAgIHRoaXMudmlld1Byb3ZpZGVycyA9IF9ub3JtYWxpemVBcnJheSh2aWV3UHJvdmlkZXJzKTtcbiAgICAgICAgICB0aGlzLnF1ZXJpZXMgPSBfbm9ybWFsaXplQXJyYXkocXVlcmllcyk7XG4gICAgICAgICAgdGhpcy52aWV3UXVlcmllcyA9IF9ub3JtYWxpemVBcnJheSh2aWV3UXVlcmllcyk7XG4gICAgICAgICAgdGhpcy5lbnRyeUNvbXBvbmVudHMgPSBfbm9ybWFsaXplQXJyYXkoZW50cnlDb21wb25lbnRzKTtcbiAgICAgICAgICB0aGlzLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgICB9XG4gICAgICBDb21waWxlRGlyZWN0aXZlTWV0YWRhdGEuY3JlYXRlID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIHR5cGUgPSBfYi50eXBlLCBpc0NvbXBvbmVudCA9IF9iLmlzQ29tcG9uZW50LCBzZWxlY3RvciA9IF9iLnNlbGVjdG9yLCBleHBvcnRBcyA9IF9iLmV4cG9ydEFzLCBjaGFuZ2VEZXRlY3Rpb24gPSBfYi5jaGFuZ2VEZXRlY3Rpb24sIGlucHV0cyA9IF9iLmlucHV0cywgb3V0cHV0cyA9IF9iLm91dHB1dHMsIGhvc3QgPSBfYi5ob3N0LCBwcm92aWRlcnMgPSBfYi5wcm92aWRlcnMsIHZpZXdQcm92aWRlcnMgPSBfYi52aWV3UHJvdmlkZXJzLCBxdWVyaWVzID0gX2IucXVlcmllcywgdmlld1F1ZXJpZXMgPSBfYi52aWV3UXVlcmllcywgZW50cnlDb21wb25lbnRzID0gX2IuZW50cnlDb21wb25lbnRzLCB0ZW1wbGF0ZSA9IF9iLnRlbXBsYXRlO1xuICAgICAgICAgIHZhciBob3N0TGlzdGVuZXJzID0ge307XG4gICAgICAgICAgdmFyIGhvc3RQcm9wZXJ0aWVzID0ge307XG4gICAgICAgICAgdmFyIGhvc3RBdHRyaWJ1dGVzID0ge307XG4gICAgICAgICAgaWYgKGlzUHJlc2VudChob3N0KSkge1xuICAgICAgICAgICAgICBPYmplY3Qua2V5cyhob3N0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGhvc3Rba2V5XTtcbiAgICAgICAgICAgICAgICAgIHZhciBtYXRjaGVzID0ga2V5Lm1hdGNoKEhPU1RfUkVHX0VYUCk7XG4gICAgICAgICAgICAgICAgICBpZiAobWF0Y2hlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgIGhvc3RBdHRyaWJ1dGVzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzUHJlc2VudChtYXRjaGVzWzFdKSkge1xuICAgICAgICAgICAgICAgICAgICAgIGhvc3RQcm9wZXJ0aWVzW21hdGNoZXNbMV1dID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1ByZXNlbnQobWF0Y2hlc1syXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBob3N0TGlzdGVuZXJzW21hdGNoZXNbMl1dID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgaW5wdXRzTWFwID0ge307XG4gICAgICAgICAgaWYgKGlzUHJlc2VudChpbnB1dHMpKSB7XG4gICAgICAgICAgICAgIGlucHV0cy5mb3JFYWNoKGZ1bmN0aW9uIChiaW5kQ29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAvLyBjYW5vbmljYWwgc3ludGF4OiBgZGlyUHJvcDogZWxQcm9wYFxuICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gYDpgLCB1c2UgZGlyUHJvcCA9IGVsUHJvcFxuICAgICAgICAgICAgICAgICAgdmFyIHBhcnRzID0gc3BsaXRBdENvbG9uKGJpbmRDb25maWcsIFtiaW5kQ29uZmlnLCBiaW5kQ29uZmlnXSk7XG4gICAgICAgICAgICAgICAgICBpbnB1dHNNYXBbcGFydHNbMF1dID0gcGFydHNbMV07XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgb3V0cHV0c01hcCA9IHt9O1xuICAgICAgICAgIGlmIChpc1ByZXNlbnQob3V0cHV0cykpIHtcbiAgICAgICAgICAgICAgb3V0cHV0cy5mb3JFYWNoKGZ1bmN0aW9uIChiaW5kQ29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAvLyBjYW5vbmljYWwgc3ludGF4OiBgZGlyUHJvcDogZWxQcm9wYFxuICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gYDpgLCB1c2UgZGlyUHJvcCA9IGVsUHJvcFxuICAgICAgICAgICAgICAgICAgdmFyIHBhcnRzID0gc3BsaXRBdENvbG9uKGJpbmRDb25maWcsIFtiaW5kQ29uZmlnLCBiaW5kQ29uZmlnXSk7XG4gICAgICAgICAgICAgICAgICBvdXRwdXRzTWFwW3BhcnRzWzBdXSA9IHBhcnRzWzFdO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBDb21waWxlRGlyZWN0aXZlTWV0YWRhdGEoe1xuICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICBpc0NvbXBvbmVudDogbm9ybWFsaXplQm9vbChpc0NvbXBvbmVudCksIHNlbGVjdG9yOiBzZWxlY3RvciwgZXhwb3J0QXM6IGV4cG9ydEFzLCBjaGFuZ2VEZXRlY3Rpb246IGNoYW5nZURldGVjdGlvbixcbiAgICAgICAgICAgICAgaW5wdXRzOiBpbnB1dHNNYXAsXG4gICAgICAgICAgICAgIG91dHB1dHM6IG91dHB1dHNNYXAsXG4gICAgICAgICAgICAgIGhvc3RMaXN0ZW5lcnM6IGhvc3RMaXN0ZW5lcnMsXG4gICAgICAgICAgICAgIGhvc3RQcm9wZXJ0aWVzOiBob3N0UHJvcGVydGllcyxcbiAgICAgICAgICAgICAgaG9zdEF0dHJpYnV0ZXM6IGhvc3RBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICBwcm92aWRlcnM6IHByb3ZpZGVycyxcbiAgICAgICAgICAgICAgdmlld1Byb3ZpZGVyczogdmlld1Byb3ZpZGVycyxcbiAgICAgICAgICAgICAgcXVlcmllczogcXVlcmllcyxcbiAgICAgICAgICAgICAgdmlld1F1ZXJpZXM6IHZpZXdRdWVyaWVzLFxuICAgICAgICAgICAgICBlbnRyeUNvbXBvbmVudHM6IGVudHJ5Q29tcG9uZW50cyxcbiAgICAgICAgICAgICAgdGVtcGxhdGU6IHRlbXBsYXRlLFxuICAgICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21waWxlRGlyZWN0aXZlTWV0YWRhdGEucHJvdG90eXBlLCBcImlkZW50aWZpZXJcIiwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50eXBlOyB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBDb21waWxlRGlyZWN0aXZlTWV0YWRhdGE7XG4gIH0oKSk7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3Qge0BsaW5rIENvbXBpbGVEaXJlY3RpdmVNZXRhZGF0YX0gZnJvbSB7QGxpbmsgQ29tcG9uZW50VHlwZU1ldGFkYXRhfSBhbmQgYSBzZWxlY3Rvci5cbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZUhvc3RDb21wb25lbnRNZXRhKGNvbXBNZXRhKSB7XG4gICAgICB2YXIgdGVtcGxhdGUgPSBDc3NTZWxlY3Rvci5wYXJzZShjb21wTWV0YS5zZWxlY3RvcilbMF0uZ2V0TWF0Y2hpbmdFbGVtZW50VGVtcGxhdGUoKTtcbiAgICAgIHJldHVybiBDb21waWxlRGlyZWN0aXZlTWV0YWRhdGEuY3JlYXRlKHtcbiAgICAgICAgICB0eXBlOiBuZXcgQ29tcGlsZVR5cGVNZXRhZGF0YSh7XG4gICAgICAgICAgICAgIHJlZmVyZW5jZTogT2JqZWN0LFxuICAgICAgICAgICAgICBuYW1lOiBjb21wTWV0YS50eXBlLm5hbWUgKyBcIl9Ib3N0XCIsXG4gICAgICAgICAgICAgIG1vZHVsZVVybDogY29tcE1ldGEudHlwZS5tb2R1bGVVcmwsXG4gICAgICAgICAgICAgIGlzSG9zdDogdHJ1ZVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHRlbXBsYXRlOiBuZXcgQ29tcGlsZVRlbXBsYXRlTWV0YWRhdGEoe1xuICAgICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBfYW5ndWxhcl9jb3JlLlZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgICAgICAgICAgIHRlbXBsYXRlOiB0ZW1wbGF0ZSxcbiAgICAgICAgICAgICAgdGVtcGxhdGVVcmw6ICcnLFxuICAgICAgICAgICAgICBzdHlsZXM6IFtdLFxuICAgICAgICAgICAgICBzdHlsZVVybHM6IFtdLFxuICAgICAgICAgICAgICBuZ0NvbnRlbnRTZWxlY3RvcnM6IFtdLFxuICAgICAgICAgICAgICBhbmltYXRpb25zOiBbXVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogX2FuZ3VsYXJfY29yZS5DaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5EZWZhdWx0LFxuICAgICAgICAgIGlucHV0czogW10sXG4gICAgICAgICAgb3V0cHV0czogW10sXG4gICAgICAgICAgaG9zdDoge30sXG4gICAgICAgICAgaXNDb21wb25lbnQ6IHRydWUsXG4gICAgICAgICAgc2VsZWN0b3I6ICcqJyxcbiAgICAgICAgICBwcm92aWRlcnM6IFtdLFxuICAgICAgICAgIHZpZXdQcm92aWRlcnM6IFtdLFxuICAgICAgICAgIHF1ZXJpZXM6IFtdLFxuICAgICAgICAgIHZpZXdRdWVyaWVzOiBbXVxuICAgICAgfSk7XG4gIH1cbiAgdmFyIENvbXBpbGVQaXBlTWV0YWRhdGEgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQ29tcGlsZVBpcGVNZXRhZGF0YShfYSkge1xuICAgICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCB0eXBlID0gX2IudHlwZSwgbmFtZSA9IF9iLm5hbWUsIHB1cmUgPSBfYi5wdXJlO1xuICAgICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICB0aGlzLnB1cmUgPSBub3JtYWxpemVCb29sKHB1cmUpO1xuICAgICAgfVxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBpbGVQaXBlTWV0YWRhdGEucHJvdG90eXBlLCBcImlkZW50aWZpZXJcIiwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50eXBlOyB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBDb21waWxlUGlwZU1ldGFkYXRhO1xuICB9KCkpO1xuICAvKipcbiAgICogTWV0YWRhdGEgcmVnYXJkaW5nIGNvbXBpbGF0aW9uIG9mIGEgZGlyZWN0aXZlLlxuICAgKi9cbiAgdmFyIENvbXBpbGVOZ01vZHVsZU1ldGFkYXRhID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIENvbXBpbGVOZ01vZHVsZU1ldGFkYXRhKF9hKSB7XG4gICAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIHR5cGUgPSBfYi50eXBlLCBwcm92aWRlcnMgPSBfYi5wcm92aWRlcnMsIGRlY2xhcmVkRGlyZWN0aXZlcyA9IF9iLmRlY2xhcmVkRGlyZWN0aXZlcywgZXhwb3J0ZWREaXJlY3RpdmVzID0gX2IuZXhwb3J0ZWREaXJlY3RpdmVzLCBkZWNsYXJlZFBpcGVzID0gX2IuZGVjbGFyZWRQaXBlcywgZXhwb3J0ZWRQaXBlcyA9IF9iLmV4cG9ydGVkUGlwZXMsIGVudHJ5Q29tcG9uZW50cyA9IF9iLmVudHJ5Q29tcG9uZW50cywgYm9vdHN0cmFwQ29tcG9uZW50cyA9IF9iLmJvb3RzdHJhcENvbXBvbmVudHMsIGltcG9ydGVkTW9kdWxlcyA9IF9iLmltcG9ydGVkTW9kdWxlcywgZXhwb3J0ZWRNb2R1bGVzID0gX2IuZXhwb3J0ZWRNb2R1bGVzLCBzY2hlbWFzID0gX2Iuc2NoZW1hcywgdHJhbnNpdGl2ZU1vZHVsZSA9IF9iLnRyYW5zaXRpdmVNb2R1bGUsIGlkID0gX2IuaWQ7XG4gICAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgICB0aGlzLmRlY2xhcmVkRGlyZWN0aXZlcyA9IF9ub3JtYWxpemVBcnJheShkZWNsYXJlZERpcmVjdGl2ZXMpO1xuICAgICAgICAgIHRoaXMuZXhwb3J0ZWREaXJlY3RpdmVzID0gX25vcm1hbGl6ZUFycmF5KGV4cG9ydGVkRGlyZWN0aXZlcyk7XG4gICAgICAgICAgdGhpcy5kZWNsYXJlZFBpcGVzID0gX25vcm1hbGl6ZUFycmF5KGRlY2xhcmVkUGlwZXMpO1xuICAgICAgICAgIHRoaXMuZXhwb3J0ZWRQaXBlcyA9IF9ub3JtYWxpemVBcnJheShleHBvcnRlZFBpcGVzKTtcbiAgICAgICAgICB0aGlzLnByb3ZpZGVycyA9IF9ub3JtYWxpemVBcnJheShwcm92aWRlcnMpO1xuICAgICAgICAgIHRoaXMuZW50cnlDb21wb25lbnRzID0gX25vcm1hbGl6ZUFycmF5KGVudHJ5Q29tcG9uZW50cyk7XG4gICAgICAgICAgdGhpcy5ib290c3RyYXBDb21wb25lbnRzID0gX25vcm1hbGl6ZUFycmF5KGJvb3RzdHJhcENvbXBvbmVudHMpO1xuICAgICAgICAgIHRoaXMuaW1wb3J0ZWRNb2R1bGVzID0gX25vcm1hbGl6ZUFycmF5KGltcG9ydGVkTW9kdWxlcyk7XG4gICAgICAgICAgdGhpcy5leHBvcnRlZE1vZHVsZXMgPSBfbm9ybWFsaXplQXJyYXkoZXhwb3J0ZWRNb2R1bGVzKTtcbiAgICAgICAgICB0aGlzLnNjaGVtYXMgPSBfbm9ybWFsaXplQXJyYXkoc2NoZW1hcyk7XG4gICAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICAgIHRoaXMudHJhbnNpdGl2ZU1vZHVsZSA9IHRyYW5zaXRpdmVNb2R1bGU7XG4gICAgICB9XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGEucHJvdG90eXBlLCBcImlkZW50aWZpZXJcIiwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50eXBlOyB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBDb21waWxlTmdNb2R1bGVNZXRhZGF0YTtcbiAgfSgpKTtcbiAgdmFyIFRyYW5zaXRpdmVDb21waWxlTmdNb2R1bGVNZXRhZGF0YSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBUcmFuc2l0aXZlQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGEobW9kdWxlcywgcHJvdmlkZXJzLCBlbnRyeUNvbXBvbmVudHMsIGRpcmVjdGl2ZXMsIHBpcGVzKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB0aGlzLm1vZHVsZXMgPSBtb2R1bGVzO1xuICAgICAgICAgIHRoaXMucHJvdmlkZXJzID0gcHJvdmlkZXJzO1xuICAgICAgICAgIHRoaXMuZW50cnlDb21wb25lbnRzID0gZW50cnlDb21wb25lbnRzO1xuICAgICAgICAgIHRoaXMuZGlyZWN0aXZlcyA9IGRpcmVjdGl2ZXM7XG4gICAgICAgICAgdGhpcy5waXBlcyA9IHBpcGVzO1xuICAgICAgICAgIHRoaXMuZGlyZWN0aXZlc1NldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgICB0aGlzLnBpcGVzU2V0ID0gbmV3IFNldCgpO1xuICAgICAgICAgIGRpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlyKSB7IHJldHVybiBfdGhpcy5kaXJlY3RpdmVzU2V0LmFkZChkaXIudHlwZS5yZWZlcmVuY2UpOyB9KTtcbiAgICAgICAgICBwaXBlcy5mb3JFYWNoKGZ1bmN0aW9uIChwaXBlKSB7IHJldHVybiBfdGhpcy5waXBlc1NldC5hZGQocGlwZS50eXBlLnJlZmVyZW5jZSk7IH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFRyYW5zaXRpdmVDb21waWxlTmdNb2R1bGVNZXRhZGF0YTtcbiAgfSgpKTtcbiAgZnVuY3Rpb24gcmVtb3ZlSWRlbnRpZmllckR1cGxpY2F0ZXMoaXRlbXMpIHtcbiAgICAgIHZhciBtYXAgPSBuZXcgTWFwKCk7XG4gICAgICBpdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgaWYgKCFtYXAuZ2V0KGl0ZW0uaWRlbnRpZmllci5yZWZlcmVuY2UpKSB7XG4gICAgICAgICAgICAgIG1hcC5zZXQoaXRlbS5pZGVudGlmaWVyLnJlZmVyZW5jZSwgaXRlbSk7XG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gTWFwV3JhcHBlci52YWx1ZXMobWFwKTtcbiAgfVxuICBmdW5jdGlvbiBfbm9ybWFsaXplQXJyYXkob2JqKSB7XG4gICAgICByZXR1cm4gb2JqIHx8IFtdO1xuICB9XG4gIGZ1bmN0aW9uIGlzU3RhdGljU3ltYm9sKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZVsnbmFtZSddICYmIHZhbHVlWydmaWxlUGF0aCddO1xuICB9XG4gIHZhciBQcm92aWRlck1ldGEgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gUHJvdmlkZXJNZXRhKHRva2VuLCBfYSkge1xuICAgICAgICAgIHZhciB1c2VDbGFzcyA9IF9hLnVzZUNsYXNzLCB1c2VWYWx1ZSA9IF9hLnVzZVZhbHVlLCB1c2VFeGlzdGluZyA9IF9hLnVzZUV4aXN0aW5nLCB1c2VGYWN0b3J5ID0gX2EudXNlRmFjdG9yeSwgZGVwcyA9IF9hLmRlcHMsIG11bHRpID0gX2EubXVsdGk7XG4gICAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgICAgIHRoaXMudXNlQ2xhc3MgPSB1c2VDbGFzcztcbiAgICAgICAgICB0aGlzLnVzZVZhbHVlID0gdXNlVmFsdWU7XG4gICAgICAgICAgdGhpcy51c2VFeGlzdGluZyA9IHVzZUV4aXN0aW5nO1xuICAgICAgICAgIHRoaXMudXNlRmFjdG9yeSA9IHVzZUZhY3Rvcnk7XG4gICAgICAgICAgdGhpcy5kZXBlbmRlbmNpZXMgPSBkZXBzO1xuICAgICAgICAgIHRoaXMubXVsdGkgPSAhIW11bHRpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFByb3ZpZGVyTWV0YTtcbiAgfSgpKTtcblxuICAvKipcbiAgICogQGxpY2Vuc2VcbiAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAqXG4gICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICovXG4gIHZhciBfX2V4dGVuZHMkMyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgfTtcbiAgdmFyIFBhcnNlckVycm9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFBhcnNlckVycm9yKG1lc3NhZ2UsIGlucHV0LCBlcnJMb2NhdGlvbiwgY3R4TG9jYXRpb24pIHtcbiAgICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgICAgdGhpcy5lcnJMb2NhdGlvbiA9IGVyckxvY2F0aW9uO1xuICAgICAgICAgIHRoaXMuY3R4TG9jYXRpb24gPSBjdHhMb2NhdGlvbjtcbiAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBcIlBhcnNlciBFcnJvcjogXCIgKyBtZXNzYWdlICsgXCIgXCIgKyBlcnJMb2NhdGlvbiArIFwiIFtcIiArIGlucHV0ICsgXCJdIGluIFwiICsgY3R4TG9jYXRpb247XG4gICAgICB9XG4gICAgICByZXR1cm4gUGFyc2VyRXJyb3I7XG4gIH0oKSk7XG4gIHZhciBQYXJzZVNwYW4gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gUGFyc2VTcGFuKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgdGhpcy5lbmQgPSBlbmQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gUGFyc2VTcGFuO1xuICB9KCkpO1xuICB2YXIgQVNUID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIEFTVChzcGFuKSB7XG4gICAgICAgICAgdGhpcy5zcGFuID0gc3BhbjtcbiAgICAgIH1cbiAgICAgIEFTVC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBBU1QucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJ0FTVCc7IH07XG4gICAgICByZXR1cm4gQVNUO1xuICB9KCkpO1xuICAvKipcbiAgICogUmVwcmVzZW50cyBhIHF1b3RlZCBleHByZXNzaW9uIG9mIHRoZSBmb3JtOlxuICAgKlxuICAgKiBxdW90ZSA9IHByZWZpeCBgOmAgdW5pbnRlcnByZXRlZEV4cHJlc3Npb25cbiAgICogcHJlZml4ID0gaWRlbnRpZmllclxuICAgKiB1bmludGVycHJldGVkRXhwcmVzc2lvbiA9IGFyYml0cmFyeSBzdHJpbmdcbiAgICpcbiAgICogQSBxdW90ZWQgZXhwcmVzc2lvbiBpcyBtZWFudCB0byBiZSBwcmUtcHJvY2Vzc2VkIGJ5IGFuIEFTVCB0cmFuc2Zvcm1lciB0aGF0XG4gICAqIGNvbnZlcnRzIGl0IGludG8gYW5vdGhlciBBU1QgdGhhdCBubyBsb25nZXIgY29udGFpbnMgcXVvdGVkIGV4cHJlc3Npb25zLlxuICAgKiBJdCBpcyBtZWFudCB0byBhbGxvdyB0aGlyZC1wYXJ0eSBkZXZlbG9wZXJzIHRvIGV4dGVuZCBBbmd1bGFyIHRlbXBsYXRlXG4gICAqIGV4cHJlc3Npb24gbGFuZ3VhZ2UuIFRoZSBgdW5pbnRlcnByZXRlZEV4cHJlc3Npb25gIHBhcnQgb2YgdGhlIHF1b3RlIGlzXG4gICAqIHRoZXJlZm9yZSBub3QgaW50ZXJwcmV0ZWQgYnkgdGhlIEFuZ3VsYXIncyBvd24gZXhwcmVzc2lvbiBwYXJzZXIuXG4gICAqL1xuICB2YXIgUXVvdGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDMoUXVvdGUsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBRdW90ZShzcGFuLCBwcmVmaXgsIHVuaW50ZXJwcmV0ZWRFeHByZXNzaW9uLCBsb2NhdGlvbikge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHNwYW4pO1xuICAgICAgICAgIHRoaXMucHJlZml4ID0gcHJlZml4O1xuICAgICAgICAgIHRoaXMudW5pbnRlcnByZXRlZEV4cHJlc3Npb24gPSB1bmludGVycHJldGVkRXhwcmVzc2lvbjtcbiAgICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICB9XG4gICAgICBRdW90ZS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFF1b3RlKHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIFF1b3RlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdRdW90ZSc7IH07XG4gICAgICByZXR1cm4gUXVvdGU7XG4gIH0oQVNUKSk7XG4gIHZhciBFbXB0eUV4cHIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDMoRW1wdHlFeHByLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gRW1wdHlFeHByKCkge1xuICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgRW1wdHlFeHByLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICAgIH07XG4gICAgICByZXR1cm4gRW1wdHlFeHByO1xuICB9KEFTVCkpO1xuICB2YXIgSW1wbGljaXRSZWNlaXZlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMyhJbXBsaWNpdFJlY2VpdmVyLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gSW1wbGljaXRSZWNlaXZlcigpIHtcbiAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIEltcGxpY2l0UmVjZWl2ZXIucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRJbXBsaWNpdFJlY2VpdmVyKHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBJbXBsaWNpdFJlY2VpdmVyO1xuICB9KEFTVCkpO1xuICAvKipcbiAgICogTXVsdGlwbGUgZXhwcmVzc2lvbnMgc2VwYXJhdGVkIGJ5IGEgc2VtaWNvbG9uLlxuICAgKi9cbiAgdmFyIENoYWluID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQzKENoYWluLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gQ2hhaW4oc3BhbiwgZXhwcmVzc2lvbnMpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuKTtcbiAgICAgICAgICB0aGlzLmV4cHJlc3Npb25zID0gZXhwcmVzc2lvbnM7XG4gICAgICB9XG4gICAgICBDaGFpbi5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoYWluKHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBDaGFpbjtcbiAgfShBU1QpKTtcbiAgdmFyIENvbmRpdGlvbmFsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQzKENvbmRpdGlvbmFsLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gQ29uZGl0aW9uYWwoc3BhbiwgY29uZGl0aW9uLCB0cnVlRXhwLCBmYWxzZUV4cCkge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHNwYW4pO1xuICAgICAgICAgIHRoaXMuY29uZGl0aW9uID0gY29uZGl0aW9uO1xuICAgICAgICAgIHRoaXMudHJ1ZUV4cCA9IHRydWVFeHA7XG4gICAgICAgICAgdGhpcy5mYWxzZUV4cCA9IGZhbHNlRXhwO1xuICAgICAgfVxuICAgICAgQ29uZGl0aW9uYWwucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDb25kaXRpb25hbCh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gQ29uZGl0aW9uYWw7XG4gIH0oQVNUKSk7XG4gIHZhciBQcm9wZXJ0eVJlYWQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDMoUHJvcGVydHlSZWFkLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gUHJvcGVydHlSZWFkKHNwYW4sIHJlY2VpdmVyLCBuYW1lKSB7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgc3Bhbik7XG4gICAgICAgICAgdGhpcy5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICB9XG4gICAgICBQcm9wZXJ0eVJlYWQucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRQcm9wZXJ0eVJlYWQodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFByb3BlcnR5UmVhZDtcbiAgfShBU1QpKTtcbiAgdmFyIFByb3BlcnR5V3JpdGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDMoUHJvcGVydHlXcml0ZSwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIFByb3BlcnR5V3JpdGUoc3BhbiwgcmVjZWl2ZXIsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgc3Bhbik7XG4gICAgICAgICAgdGhpcy5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgUHJvcGVydHlXcml0ZS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFByb3BlcnR5V3JpdGUodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFByb3BlcnR5V3JpdGU7XG4gIH0oQVNUKSk7XG4gIHZhciBTYWZlUHJvcGVydHlSZWFkID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQzKFNhZmVQcm9wZXJ0eVJlYWQsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBTYWZlUHJvcGVydHlSZWFkKHNwYW4sIHJlY2VpdmVyLCBuYW1lKSB7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgc3Bhbik7XG4gICAgICAgICAgdGhpcy5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICB9XG4gICAgICBTYWZlUHJvcGVydHlSZWFkLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0U2FmZVByb3BlcnR5UmVhZCh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gU2FmZVByb3BlcnR5UmVhZDtcbiAgfShBU1QpKTtcbiAgdmFyIEtleWVkUmVhZCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMyhLZXllZFJlYWQsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBLZXllZFJlYWQoc3Bhbiwgb2JqLCBrZXkpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuKTtcbiAgICAgICAgICB0aGlzLm9iaiA9IG9iajtcbiAgICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgIH1cbiAgICAgIEtleWVkUmVhZC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEtleWVkUmVhZCh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gS2V5ZWRSZWFkO1xuICB9KEFTVCkpO1xuICB2YXIgS2V5ZWRXcml0ZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMyhLZXllZFdyaXRlLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gS2V5ZWRXcml0ZShzcGFuLCBvYmosIGtleSwgdmFsdWUpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuKTtcbiAgICAgICAgICB0aGlzLm9iaiA9IG9iajtcbiAgICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBLZXllZFdyaXRlLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0S2V5ZWRXcml0ZSh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gS2V5ZWRXcml0ZTtcbiAgfShBU1QpKTtcbiAgdmFyIEJpbmRpbmdQaXBlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQzKEJpbmRpbmdQaXBlLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gQmluZGluZ1BpcGUoc3BhbiwgZXhwLCBuYW1lLCBhcmdzKSB7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgc3Bhbik7XG4gICAgICAgICAgdGhpcy5leHAgPSBleHA7XG4gICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgICAgfVxuICAgICAgQmluZGluZ1BpcGUucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRQaXBlKHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBCaW5kaW5nUGlwZTtcbiAgfShBU1QpKTtcbiAgdmFyIExpdGVyYWxQcmltaXRpdmUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDMoTGl0ZXJhbFByaW1pdGl2ZSwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIExpdGVyYWxQcmltaXRpdmUoc3BhbiwgdmFsdWUpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuKTtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBMaXRlcmFsUHJpbWl0aXZlLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0TGl0ZXJhbFByaW1pdGl2ZSh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gTGl0ZXJhbFByaW1pdGl2ZTtcbiAgfShBU1QpKTtcbiAgdmFyIExpdGVyYWxBcnJheSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMyhMaXRlcmFsQXJyYXksIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBMaXRlcmFsQXJyYXkoc3BhbiwgZXhwcmVzc2lvbnMpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuKTtcbiAgICAgICAgICB0aGlzLmV4cHJlc3Npb25zID0gZXhwcmVzc2lvbnM7XG4gICAgICB9XG4gICAgICBMaXRlcmFsQXJyYXkucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRMaXRlcmFsQXJyYXkodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIExpdGVyYWxBcnJheTtcbiAgfShBU1QpKTtcbiAgdmFyIExpdGVyYWxNYXAgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDMoTGl0ZXJhbE1hcCwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIExpdGVyYWxNYXAoc3Bhbiwga2V5cywgdmFsdWVzKSB7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgc3Bhbik7XG4gICAgICAgICAgdGhpcy5rZXlzID0ga2V5cztcbiAgICAgICAgICB0aGlzLnZhbHVlcyA9IHZhbHVlcztcbiAgICAgIH1cbiAgICAgIExpdGVyYWxNYXAucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRMaXRlcmFsTWFwKHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBMaXRlcmFsTWFwO1xuICB9KEFTVCkpO1xuICB2YXIgSW50ZXJwb2xhdGlvbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMyhJbnRlcnBvbGF0aW9uLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gSW50ZXJwb2xhdGlvbihzcGFuLCBzdHJpbmdzLCBleHByZXNzaW9ucykge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHNwYW4pO1xuICAgICAgICAgIHRoaXMuc3RyaW5ncyA9IHN0cmluZ3M7XG4gICAgICAgICAgdGhpcy5leHByZXNzaW9ucyA9IGV4cHJlc3Npb25zO1xuICAgICAgfVxuICAgICAgSW50ZXJwb2xhdGlvbi5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEludGVycG9sYXRpb24odGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIEludGVycG9sYXRpb247XG4gIH0oQVNUKSk7XG4gIHZhciBCaW5hcnkgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDMoQmluYXJ5LCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gQmluYXJ5KHNwYW4sIG9wZXJhdGlvbiwgbGVmdCwgcmlnaHQpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuKTtcbiAgICAgICAgICB0aGlzLm9wZXJhdGlvbiA9IG9wZXJhdGlvbjtcbiAgICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgICAgIHRoaXMucmlnaHQgPSByaWdodDtcbiAgICAgIH1cbiAgICAgIEJpbmFyeS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEJpbmFyeSh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gQmluYXJ5O1xuICB9KEFTVCkpO1xuICB2YXIgUHJlZml4Tm90ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQzKFByZWZpeE5vdCwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIFByZWZpeE5vdChzcGFuLCBleHByZXNzaW9uKSB7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgc3Bhbik7XG4gICAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgICAgIH1cbiAgICAgIFByZWZpeE5vdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFByZWZpeE5vdCh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gUHJlZml4Tm90O1xuICB9KEFTVCkpO1xuICB2YXIgTWV0aG9kQ2FsbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMyhNZXRob2RDYWxsLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gTWV0aG9kQ2FsbChzcGFuLCByZWNlaXZlciwgbmFtZSwgYXJncykge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHNwYW4pO1xuICAgICAgICAgIHRoaXMucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgICB9XG4gICAgICBNZXRob2RDYWxsLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0TWV0aG9kQ2FsbCh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gTWV0aG9kQ2FsbDtcbiAgfShBU1QpKTtcbiAgdmFyIFNhZmVNZXRob2RDYWxsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQzKFNhZmVNZXRob2RDYWxsLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gU2FmZU1ldGhvZENhbGwoc3BhbiwgcmVjZWl2ZXIsIG5hbWUsIGFyZ3MpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuKTtcbiAgICAgICAgICB0aGlzLnJlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgICAgfVxuICAgICAgU2FmZU1ldGhvZENhbGwucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRTYWZlTWV0aG9kQ2FsbCh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gU2FmZU1ldGhvZENhbGw7XG4gIH0oQVNUKSk7XG4gIHZhciBGdW5jdGlvbkNhbGwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDMoRnVuY3Rpb25DYWxsLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gRnVuY3Rpb25DYWxsKHNwYW4sIHRhcmdldCwgYXJncykge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHNwYW4pO1xuICAgICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgICB9XG4gICAgICBGdW5jdGlvbkNhbGwucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRGdW5jdGlvbkNhbGwodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIEZ1bmN0aW9uQ2FsbDtcbiAgfShBU1QpKTtcbiAgdmFyIEFTVFdpdGhTb3VyY2UgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDMoQVNUV2l0aFNvdXJjZSwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIEFTVFdpdGhTb3VyY2UoYXN0LCBzb3VyY2UsIGxvY2F0aW9uLCBlcnJvcnMpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBuZXcgUGFyc2VTcGFuKDAsIGlzQmxhbmsoc291cmNlKSA/IDAgOiBzb3VyY2UubGVuZ3RoKSk7XG4gICAgICAgICAgdGhpcy5hc3QgPSBhc3Q7XG4gICAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgfVxuICAgICAgQVNUV2l0aFNvdXJjZS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgICByZXR1cm4gdGhpcy5hc3QudmlzaXQodmlzaXRvciwgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgQVNUV2l0aFNvdXJjZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnNvdXJjZSArIFwiIGluIFwiICsgdGhpcy5sb2NhdGlvbjsgfTtcbiAgICAgIHJldHVybiBBU1RXaXRoU291cmNlO1xuICB9KEFTVCkpO1xuICB2YXIgVGVtcGxhdGVCaW5kaW5nID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFRlbXBsYXRlQmluZGluZyhrZXksIGtleUlzVmFyLCBuYW1lLCBleHByZXNzaW9uKSB7XG4gICAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgICAgdGhpcy5rZXlJc1ZhciA9IGtleUlzVmFyO1xuICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBUZW1wbGF0ZUJpbmRpbmc7XG4gIH0oKSk7XG4gIHZhciBSZWN1cnNpdmVBc3RWaXNpdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFJlY3Vyc2l2ZUFzdFZpc2l0b3IoKSB7XG4gICAgICB9XG4gICAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdEJpbmFyeSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICBhc3QubGVmdC52aXNpdCh0aGlzKTtcbiAgICAgICAgICBhc3QucmlnaHQudmlzaXQodGhpcyk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRDaGFpbiA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgcmV0dXJuIHRoaXMudmlzaXRBbGwoYXN0LmV4cHJlc3Npb25zLCBjb250ZXh0KTsgfTtcbiAgICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q29uZGl0aW9uYWwgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgYXN0LmNvbmRpdGlvbi52aXNpdCh0aGlzKTtcbiAgICAgICAgICBhc3QudHJ1ZUV4cC52aXNpdCh0aGlzKTtcbiAgICAgICAgICBhc3QuZmFsc2VFeHAudmlzaXQodGhpcyk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRQaXBlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIGFzdC5leHAudmlzaXQodGhpcyk7XG4gICAgICAgICAgdGhpcy52aXNpdEFsbChhc3QuYXJncywgY29udGV4dCk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRGdW5jdGlvbkNhbGwgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgYXN0LnRhcmdldC52aXNpdCh0aGlzKTtcbiAgICAgICAgICB0aGlzLnZpc2l0QWxsKGFzdC5hcmdzLCBjb250ZXh0KTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdEltcGxpY2l0UmVjZWl2ZXIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRJbnRlcnBvbGF0aW9uID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnZpc2l0QWxsKGFzdC5leHByZXNzaW9ucywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRLZXllZFJlYWQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgYXN0Lm9iai52aXNpdCh0aGlzKTtcbiAgICAgICAgICBhc3Qua2V5LnZpc2l0KHRoaXMpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0S2V5ZWRXcml0ZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICBhc3Qub2JqLnZpc2l0KHRoaXMpO1xuICAgICAgICAgIGFzdC5rZXkudmlzaXQodGhpcyk7XG4gICAgICAgICAgYXN0LnZhbHVlLnZpc2l0KHRoaXMpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0TGl0ZXJhbEFycmF5ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnZpc2l0QWxsKGFzdC5leHByZXNzaW9ucywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRMaXRlcmFsTWFwID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyByZXR1cm4gdGhpcy52aXNpdEFsbChhc3QudmFsdWVzLCBjb250ZXh0KTsgfTtcbiAgICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0TGl0ZXJhbFByaW1pdGl2ZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdE1ldGhvZENhbGwgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgYXN0LnJlY2VpdmVyLnZpc2l0KHRoaXMpO1xuICAgICAgICAgIHJldHVybiB0aGlzLnZpc2l0QWxsKGFzdC5hcmdzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdFByZWZpeE5vdCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICBhc3QuZXhwcmVzc2lvbi52aXNpdCh0aGlzKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdFByb3BlcnR5UmVhZCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICBhc3QucmVjZWl2ZXIudmlzaXQodGhpcyk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRQcm9wZXJ0eVdyaXRlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIGFzdC5yZWNlaXZlci52aXNpdCh0aGlzKTtcbiAgICAgICAgICBhc3QudmFsdWUudmlzaXQodGhpcyk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRTYWZlUHJvcGVydHlSZWFkID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIGFzdC5yZWNlaXZlci52aXNpdCh0aGlzKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdFNhZmVNZXRob2RDYWxsID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIGFzdC5yZWNlaXZlci52aXNpdCh0aGlzKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy52aXNpdEFsbChhc3QuYXJncywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRBbGwgPSBmdW5jdGlvbiAoYXN0cywgY29udGV4dCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgYXN0cy5mb3JFYWNoKGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIGFzdC52aXNpdChfdGhpcywgY29udGV4dCk7IH0pO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0UXVvdGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgcmV0dXJuIFJlY3Vyc2l2ZUFzdFZpc2l0b3I7XG4gIH0oKSk7XG5cbiAgLyoqXG4gICAqIEBsaWNlbnNlXG4gICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgKlxuICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAqL1xuICB2YXIgJEVPRiA9IDA7XG4gIHZhciAkVEFCID0gOTtcbiAgdmFyICRMRiA9IDEwO1xuICB2YXIgJFZUQUIgPSAxMTtcbiAgdmFyICRGRiA9IDEyO1xuICB2YXIgJENSID0gMTM7XG4gIHZhciAkU1BBQ0UgPSAzMjtcbiAgdmFyICRCQU5HID0gMzM7XG4gIHZhciAkRFEgPSAzNDtcbiAgdmFyICRIQVNIID0gMzU7XG4gIHZhciAkJCA9IDM2O1xuICB2YXIgJFBFUkNFTlQgPSAzNztcbiAgdmFyICRBTVBFUlNBTkQgPSAzODtcbiAgdmFyICRTUSA9IDM5O1xuICB2YXIgJExQQVJFTiA9IDQwO1xuICB2YXIgJFJQQVJFTiA9IDQxO1xuICB2YXIgJFNUQVIgPSA0MjtcbiAgdmFyICRQTFVTID0gNDM7XG4gIHZhciAkQ09NTUEgPSA0NDtcbiAgdmFyICRNSU5VUyA9IDQ1O1xuICB2YXIgJFBFUklPRCA9IDQ2O1xuICB2YXIgJFNMQVNIID0gNDc7XG4gIHZhciAkQ09MT04gPSA1ODtcbiAgdmFyICRTRU1JQ09MT04gPSA1OTtcbiAgdmFyICRMVCA9IDYwO1xuICB2YXIgJEVRID0gNjE7XG4gIHZhciAkR1QgPSA2MjtcbiAgdmFyICRRVUVTVElPTiA9IDYzO1xuICB2YXIgJDAgPSA0ODtcbiAgdmFyICQ5ID0gNTc7XG4gIHZhciAkQSA9IDY1O1xuICB2YXIgJEUgPSA2OTtcbiAgdmFyICRGID0gNzA7XG4gIHZhciAkWCA9IDg4O1xuICB2YXIgJFogPSA5MDtcbiAgdmFyICRMQlJBQ0tFVCA9IDkxO1xuICB2YXIgJEJBQ0tTTEFTSCA9IDkyO1xuICB2YXIgJFJCUkFDS0VUID0gOTM7XG4gIHZhciAkQ0FSRVQgPSA5NDtcbiAgdmFyICRfID0gOTU7XG4gIHZhciAkYSA9IDk3O1xuICB2YXIgJGUgPSAxMDE7XG4gIHZhciAkZiA9IDEwMjtcbiAgdmFyICRuID0gMTEwO1xuICB2YXIgJHIgPSAxMTQ7XG4gIHZhciAkdCA9IDExNjtcbiAgdmFyICR1ID0gMTE3O1xuICB2YXIgJHYgPSAxMTg7XG4gIHZhciAkeCA9IDEyMDtcbiAgdmFyICR6ID0gMTIyO1xuICB2YXIgJExCUkFDRSA9IDEyMztcbiAgdmFyICRCQVIgPSAxMjQ7XG4gIHZhciAkUkJSQUNFID0gMTI1O1xuICB2YXIgJE5CU1AgPSAxNjA7XG4gIHZhciAkQlQgPSA5NjtcbiAgZnVuY3Rpb24gaXNXaGl0ZXNwYWNlKGNvZGUpIHtcbiAgICAgIHJldHVybiAoY29kZSA+PSAkVEFCICYmIGNvZGUgPD0gJFNQQUNFKSB8fCAoY29kZSA9PSAkTkJTUCk7XG4gIH1cbiAgZnVuY3Rpb24gaXNEaWdpdChjb2RlKSB7XG4gICAgICByZXR1cm4gJDAgPD0gY29kZSAmJiBjb2RlIDw9ICQ5O1xuICB9XG4gIGZ1bmN0aW9uIGlzQXNjaWlMZXR0ZXIoY29kZSkge1xuICAgICAgcmV0dXJuIGNvZGUgPj0gJGEgJiYgY29kZSA8PSAkeiB8fCBjb2RlID49ICRBICYmIGNvZGUgPD0gJFo7XG4gIH1cbiAgZnVuY3Rpb24gaXNBc2NpaUhleERpZ2l0KGNvZGUpIHtcbiAgICAgIHJldHVybiBjb2RlID49ICRhICYmIGNvZGUgPD0gJGYgfHwgY29kZSA+PSAkQSAmJiBjb2RlIDw9ICRGIHx8IGlzRGlnaXQoY29kZSk7XG4gIH1cblxuICBmdW5jdGlvbiBhc3NlcnRBcnJheU9mU3RyaW5ncyhpZGVudGlmaWVyLCB2YWx1ZSkge1xuICAgICAgaWYgKCFfYW5ndWxhcl9jb3JlLmlzRGV2TW9kZSgpIHx8IGlzQmxhbmsodmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkICdcIiArIGlkZW50aWZpZXIgKyBcIicgdG8gYmUgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cIik7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZVtpXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgJ1wiICsgaWRlbnRpZmllciArIFwiJyB0byBiZSBhbiBhcnJheSBvZiBzdHJpbmdzLlwiKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gIH1cbiAgdmFyIElOVEVSUE9MQVRJT05fQkxBQ0tMSVNUX1JFR0VYUFMgPSBbXG4gICAgICAvXlxccyokLyxcbiAgICAgIC9bPD5dLyxcbiAgICAgIC9eW3t9XSQvLFxuICAgICAgLyYoI3xbYS16XSkvaSxcbiAgICAgIC9eXFwvXFwvLyxcbiAgXTtcbiAgZnVuY3Rpb24gYXNzZXJ0SW50ZXJwb2xhdGlvblN5bWJvbHMoaWRlbnRpZmllciwgdmFsdWUpIHtcbiAgICAgIGlmIChpc1ByZXNlbnQodmFsdWUpICYmICEoQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09IDIpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgJ1wiICsgaWRlbnRpZmllciArIFwiJyB0byBiZSBhbiBhcnJheSwgW3N0YXJ0LCBlbmRdLlwiKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKF9hbmd1bGFyX2NvcmUuaXNEZXZNb2RlKCkgJiYgIWlzQmxhbmsodmFsdWUpKSB7XG4gICAgICAgICAgdmFyIHN0YXJ0XzEgPSB2YWx1ZVswXTtcbiAgICAgICAgICB2YXIgZW5kXzEgPSB2YWx1ZVsxXTtcbiAgICAgICAgICAvLyBibGFjayBsaXN0IGNoZWNraW5nXG4gICAgICAgICAgSU5URVJQT0xBVElPTl9CTEFDS0xJU1RfUkVHRVhQUy5mb3JFYWNoKGZ1bmN0aW9uIChyZWdleHApIHtcbiAgICAgICAgICAgICAgaWYgKHJlZ2V4cC50ZXN0KHN0YXJ0XzEpIHx8IHJlZ2V4cC50ZXN0KGVuZF8xKSkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWydcIiArIHN0YXJ0XzEgKyBcIicsICdcIiArIGVuZF8xICsgXCInXSBjb250YWlucyB1bnVzYWJsZSBpbnRlcnBvbGF0aW9uIHN5bWJvbC5cIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgfVxuXG4gIHZhciBJbnRlcnBvbGF0aW9uQ29uZmlnID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIEludGVycG9sYXRpb25Db25maWcoc3RhcnQsIGVuZCkge1xuICAgICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICB0aGlzLmVuZCA9IGVuZDtcbiAgICAgIH1cbiAgICAgIEludGVycG9sYXRpb25Db25maWcuZnJvbUFycmF5ID0gZnVuY3Rpb24gKG1hcmtlcnMpIHtcbiAgICAgICAgICBpZiAoIW1hcmtlcnMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIERFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFzc2VydEludGVycG9sYXRpb25TeW1ib2xzKCdpbnRlcnBvbGF0aW9uJywgbWFya2Vycyk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBJbnRlcnBvbGF0aW9uQ29uZmlnKG1hcmtlcnNbMF0sIG1hcmtlcnNbMV0pO1xuICAgICAgfTtcbiAgICAgIDtcbiAgICAgIHJldHVybiBJbnRlcnBvbGF0aW9uQ29uZmlnO1xuICB9KCkpO1xuICB2YXIgREVGQVVMVF9JTlRFUlBPTEFUSU9OX0NPTkZJRyA9IG5ldyBJbnRlcnBvbGF0aW9uQ29uZmlnKCd7eycsICd9fScpO1xuXG4gIGV4cG9ydHMuVG9rZW5UeXBlO1xuICAoZnVuY3Rpb24gKFRva2VuVHlwZSkge1xuICAgICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIkNoYXJhY3RlclwiXSA9IDBdID0gXCJDaGFyYWN0ZXJcIjtcbiAgICAgIFRva2VuVHlwZVtUb2tlblR5cGVbXCJJZGVudGlmaWVyXCJdID0gMV0gPSBcIklkZW50aWZpZXJcIjtcbiAgICAgIFRva2VuVHlwZVtUb2tlblR5cGVbXCJLZXl3b3JkXCJdID0gMl0gPSBcIktleXdvcmRcIjtcbiAgICAgIFRva2VuVHlwZVtUb2tlblR5cGVbXCJTdHJpbmdcIl0gPSAzXSA9IFwiU3RyaW5nXCI7XG4gICAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiT3BlcmF0b3JcIl0gPSA0XSA9IFwiT3BlcmF0b3JcIjtcbiAgICAgIFRva2VuVHlwZVtUb2tlblR5cGVbXCJOdW1iZXJcIl0gPSA1XSA9IFwiTnVtYmVyXCI7XG4gICAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiRXJyb3JcIl0gPSA2XSA9IFwiRXJyb3JcIjtcbiAgfSkoZXhwb3J0cy5Ub2tlblR5cGUgfHwgKGV4cG9ydHMuVG9rZW5UeXBlID0ge30pKTtcbiAgdmFyIEtFWVdPUkRTID0gWyd2YXInLCAnbGV0JywgJ251bGwnLCAndW5kZWZpbmVkJywgJ3RydWUnLCAnZmFsc2UnLCAnaWYnLCAnZWxzZScsICd0aGlzJ107XG4gIHZhciBMZXhlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBMZXhlcigpIHtcbiAgICAgIH1cbiAgICAgIExleGVyLnByb3RvdHlwZS50b2tlbml6ZSA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgICAgdmFyIHNjYW5uZXIgPSBuZXcgX1NjYW5uZXIodGV4dCk7XG4gICAgICAgICAgdmFyIHRva2VucyA9IFtdO1xuICAgICAgICAgIHZhciB0b2tlbiA9IHNjYW5uZXIuc2NhblRva2VuKCk7XG4gICAgICAgICAgd2hpbGUgKHRva2VuICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICB0b2tlbiA9IHNjYW5uZXIuc2NhblRva2VuKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgICB9O1xuICAgICAgTGV4ZXIuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuICAgICAgXTtcbiAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgTGV4ZXIuY3RvclBhcmFtZXRlcnMgPSBbXTtcbiAgICAgIHJldHVybiBMZXhlcjtcbiAgfSgpKTtcbiAgdmFyIFRva2VuID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFRva2VuKGluZGV4LCB0eXBlLCBudW1WYWx1ZSwgc3RyVmFsdWUpIHtcbiAgICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgICB0aGlzLm51bVZhbHVlID0gbnVtVmFsdWU7XG4gICAgICAgICAgdGhpcy5zdHJWYWx1ZSA9IHN0clZhbHVlO1xuICAgICAgfVxuICAgICAgVG9rZW4ucHJvdG90eXBlLmlzQ2hhcmFjdGVyID0gZnVuY3Rpb24gKGNvZGUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50eXBlID09IGV4cG9ydHMuVG9rZW5UeXBlLkNoYXJhY3RlciAmJiB0aGlzLm51bVZhbHVlID09IGNvZGU7XG4gICAgICB9O1xuICAgICAgVG9rZW4ucHJvdG90eXBlLmlzTnVtYmVyID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50eXBlID09IGV4cG9ydHMuVG9rZW5UeXBlLk51bWJlcjsgfTtcbiAgICAgIFRva2VuLnByb3RvdHlwZS5pc1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudHlwZSA9PSBleHBvcnRzLlRva2VuVHlwZS5TdHJpbmc7IH07XG4gICAgICBUb2tlbi5wcm90b3R5cGUuaXNPcGVyYXRvciA9IGZ1bmN0aW9uIChvcGVyYXRlcikge1xuICAgICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT0gZXhwb3J0cy5Ub2tlblR5cGUuT3BlcmF0b3IgJiYgdGhpcy5zdHJWYWx1ZSA9PSBvcGVyYXRlcjtcbiAgICAgIH07XG4gICAgICBUb2tlbi5wcm90b3R5cGUuaXNJZGVudGlmaWVyID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50eXBlID09IGV4cG9ydHMuVG9rZW5UeXBlLklkZW50aWZpZXI7IH07XG4gICAgICBUb2tlbi5wcm90b3R5cGUuaXNLZXl3b3JkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50eXBlID09IGV4cG9ydHMuVG9rZW5UeXBlLktleXdvcmQ7IH07XG4gICAgICBUb2tlbi5wcm90b3R5cGUuaXNLZXl3b3JkTGV0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50eXBlID09IGV4cG9ydHMuVG9rZW5UeXBlLktleXdvcmQgJiYgdGhpcy5zdHJWYWx1ZSA9PSAnbGV0JzsgfTtcbiAgICAgIFRva2VuLnByb3RvdHlwZS5pc0tleXdvcmROdWxsID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50eXBlID09IGV4cG9ydHMuVG9rZW5UeXBlLktleXdvcmQgJiYgdGhpcy5zdHJWYWx1ZSA9PSAnbnVsbCc7IH07XG4gICAgICBUb2tlbi5wcm90b3R5cGUuaXNLZXl3b3JkVW5kZWZpbmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT0gZXhwb3J0cy5Ub2tlblR5cGUuS2V5d29yZCAmJiB0aGlzLnN0clZhbHVlID09ICd1bmRlZmluZWQnO1xuICAgICAgfTtcbiAgICAgIFRva2VuLnByb3RvdHlwZS5pc0tleXdvcmRUcnVlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50eXBlID09IGV4cG9ydHMuVG9rZW5UeXBlLktleXdvcmQgJiYgdGhpcy5zdHJWYWx1ZSA9PSAndHJ1ZSc7IH07XG4gICAgICBUb2tlbi5wcm90b3R5cGUuaXNLZXl3b3JkRmFsc2UgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnR5cGUgPT0gZXhwb3J0cy5Ub2tlblR5cGUuS2V5d29yZCAmJiB0aGlzLnN0clZhbHVlID09ICdmYWxzZSc7IH07XG4gICAgICBUb2tlbi5wcm90b3R5cGUuaXNLZXl3b3JkVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudHlwZSA9PSBleHBvcnRzLlRva2VuVHlwZS5LZXl3b3JkICYmIHRoaXMuc3RyVmFsdWUgPT0gJ3RoaXMnOyB9O1xuICAgICAgVG9rZW4ucHJvdG90eXBlLmlzRXJyb3IgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnR5cGUgPT0gZXhwb3J0cy5Ub2tlblR5cGUuRXJyb3I7IH07XG4gICAgICBUb2tlbi5wcm90b3R5cGUudG9OdW1iZXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnR5cGUgPT0gZXhwb3J0cy5Ub2tlblR5cGUuTnVtYmVyID8gdGhpcy5udW1WYWx1ZSA6IC0xOyB9O1xuICAgICAgVG9rZW4ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5Ub2tlblR5cGUuQ2hhcmFjdGVyOlxuICAgICAgICAgICAgICBjYXNlIGV4cG9ydHMuVG9rZW5UeXBlLklkZW50aWZpZXI6XG4gICAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5Ub2tlblR5cGUuS2V5d29yZDpcbiAgICAgICAgICAgICAgY2FzZSBleHBvcnRzLlRva2VuVHlwZS5PcGVyYXRvcjpcbiAgICAgICAgICAgICAgY2FzZSBleHBvcnRzLlRva2VuVHlwZS5TdHJpbmc6XG4gICAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5Ub2tlblR5cGUuRXJyb3I6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJWYWx1ZTtcbiAgICAgICAgICAgICAgY2FzZSBleHBvcnRzLlRva2VuVHlwZS5OdW1iZXI6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5udW1WYWx1ZS50b1N0cmluZygpO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiBUb2tlbjtcbiAgfSgpKTtcbiAgZnVuY3Rpb24gbmV3Q2hhcmFjdGVyVG9rZW4oaW5kZXgsIGNvZGUpIHtcbiAgICAgIHJldHVybiBuZXcgVG9rZW4oaW5kZXgsIGV4cG9ydHMuVG9rZW5UeXBlLkNoYXJhY3RlciwgY29kZSwgU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSk7XG4gIH1cbiAgZnVuY3Rpb24gbmV3SWRlbnRpZmllclRva2VuKGluZGV4LCB0ZXh0KSB7XG4gICAgICByZXR1cm4gbmV3IFRva2VuKGluZGV4LCBleHBvcnRzLlRva2VuVHlwZS5JZGVudGlmaWVyLCAwLCB0ZXh0KTtcbiAgfVxuICBmdW5jdGlvbiBuZXdLZXl3b3JkVG9rZW4oaW5kZXgsIHRleHQpIHtcbiAgICAgIHJldHVybiBuZXcgVG9rZW4oaW5kZXgsIGV4cG9ydHMuVG9rZW5UeXBlLktleXdvcmQsIDAsIHRleHQpO1xuICB9XG4gIGZ1bmN0aW9uIG5ld09wZXJhdG9yVG9rZW4oaW5kZXgsIHRleHQpIHtcbiAgICAgIHJldHVybiBuZXcgVG9rZW4oaW5kZXgsIGV4cG9ydHMuVG9rZW5UeXBlLk9wZXJhdG9yLCAwLCB0ZXh0KTtcbiAgfVxuICBmdW5jdGlvbiBuZXdTdHJpbmdUb2tlbihpbmRleCwgdGV4dCkge1xuICAgICAgcmV0dXJuIG5ldyBUb2tlbihpbmRleCwgZXhwb3J0cy5Ub2tlblR5cGUuU3RyaW5nLCAwLCB0ZXh0KTtcbiAgfVxuICBmdW5jdGlvbiBuZXdOdW1iZXJUb2tlbihpbmRleCwgbikge1xuICAgICAgcmV0dXJuIG5ldyBUb2tlbihpbmRleCwgZXhwb3J0cy5Ub2tlblR5cGUuTnVtYmVyLCBuLCAnJyk7XG4gIH1cbiAgZnVuY3Rpb24gbmV3RXJyb3JUb2tlbihpbmRleCwgbWVzc2FnZSkge1xuICAgICAgcmV0dXJuIG5ldyBUb2tlbihpbmRleCwgZXhwb3J0cy5Ub2tlblR5cGUuRXJyb3IsIDAsIG1lc3NhZ2UpO1xuICB9XG4gIHZhciBFT0YgPSBuZXcgVG9rZW4oLTEsIGV4cG9ydHMuVG9rZW5UeXBlLkNoYXJhY3RlciwgMCwgJycpO1xuICB2YXIgX1NjYW5uZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gX1NjYW5uZXIoaW5wdXQpIHtcbiAgICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgICAgdGhpcy5wZWVrID0gMDtcbiAgICAgICAgICB0aGlzLmluZGV4ID0gLTE7XG4gICAgICAgICAgdGhpcy5sZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICB9XG4gICAgICBfU2Nhbm5lci5wcm90b3R5cGUuYWR2YW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLnBlZWsgPSArK3RoaXMuaW5kZXggPj0gdGhpcy5sZW5ndGggPyAkRU9GIDogdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpO1xuICAgICAgfTtcbiAgICAgIF9TY2FubmVyLnByb3RvdHlwZS5zY2FuVG9rZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGlucHV0ID0gdGhpcy5pbnB1dCwgbGVuZ3RoID0gdGhpcy5sZW5ndGgsIHBlZWsgPSB0aGlzLnBlZWssIGluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgICAgICAvLyBTa2lwIHdoaXRlc3BhY2UuXG4gICAgICAgICAgd2hpbGUgKHBlZWsgPD0gJFNQQUNFKSB7XG4gICAgICAgICAgICAgIGlmICgrK2luZGV4ID49IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgcGVlayA9ICRFT0Y7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHBlZWsgPSBpbnB1dC5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnBlZWsgPSBwZWVrO1xuICAgICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgICBpZiAoaW5kZXggPj0gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBIYW5kbGUgaWRlbnRpZmllcnMgYW5kIG51bWJlcnMuXG4gICAgICAgICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KHBlZWspKVxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuSWRlbnRpZmllcigpO1xuICAgICAgICAgIGlmIChpc0RpZ2l0KHBlZWspKVxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuTnVtYmVyKGluZGV4KTtcbiAgICAgICAgICB2YXIgc3RhcnQgPSBpbmRleDtcbiAgICAgICAgICBzd2l0Y2ggKHBlZWspIHtcbiAgICAgICAgICAgICAgY2FzZSAkUEVSSU9EOlxuICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gaXNEaWdpdCh0aGlzLnBlZWspID8gdGhpcy5zY2FuTnVtYmVyKHN0YXJ0KSA6XG4gICAgICAgICAgICAgICAgICAgICAgbmV3Q2hhcmFjdGVyVG9rZW4oc3RhcnQsICRQRVJJT0QpO1xuICAgICAgICAgICAgICBjYXNlICRMUEFSRU46XG4gICAgICAgICAgICAgIGNhc2UgJFJQQVJFTjpcbiAgICAgICAgICAgICAgY2FzZSAkTEJSQUNFOlxuICAgICAgICAgICAgICBjYXNlICRSQlJBQ0U6XG4gICAgICAgICAgICAgIGNhc2UgJExCUkFDS0VUOlxuICAgICAgICAgICAgICBjYXNlICRSQlJBQ0tFVDpcbiAgICAgICAgICAgICAgY2FzZSAkQ09NTUE6XG4gICAgICAgICAgICAgIGNhc2UgJENPTE9OOlxuICAgICAgICAgICAgICBjYXNlICRTRU1JQ09MT046XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuQ2hhcmFjdGVyKHN0YXJ0LCBwZWVrKTtcbiAgICAgICAgICAgICAgY2FzZSAkU1E6XG4gICAgICAgICAgICAgIGNhc2UgJERROlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhblN0cmluZygpO1xuICAgICAgICAgICAgICBjYXNlICRIQVNIOlxuICAgICAgICAgICAgICBjYXNlICRQTFVTOlxuICAgICAgICAgICAgICBjYXNlICRNSU5VUzpcbiAgICAgICAgICAgICAgY2FzZSAkU1RBUjpcbiAgICAgICAgICAgICAgY2FzZSAkU0xBU0g6XG4gICAgICAgICAgICAgIGNhc2UgJFBFUkNFTlQ6XG4gICAgICAgICAgICAgIGNhc2UgJENBUkVUOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2Nhbk9wZXJhdG9yKHN0YXJ0LCBTdHJpbmcuZnJvbUNoYXJDb2RlKHBlZWspKTtcbiAgICAgICAgICAgICAgY2FzZSAkUVVFU1RJT046XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuQ29tcGxleE9wZXJhdG9yKHN0YXJ0LCAnPycsICRQRVJJT0QsICcuJyk7XG4gICAgICAgICAgICAgIGNhc2UgJExUOlxuICAgICAgICAgICAgICBjYXNlICRHVDpcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5Db21wbGV4T3BlcmF0b3Ioc3RhcnQsIFN0cmluZy5mcm9tQ2hhckNvZGUocGVlayksICRFUSwgJz0nKTtcbiAgICAgICAgICAgICAgY2FzZSAkQkFORzpcbiAgICAgICAgICAgICAgY2FzZSAkRVE6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuQ29tcGxleE9wZXJhdG9yKHN0YXJ0LCBTdHJpbmcuZnJvbUNoYXJDb2RlKHBlZWspLCAkRVEsICc9JywgJEVRLCAnPScpO1xuICAgICAgICAgICAgICBjYXNlICRBTVBFUlNBTkQ6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuQ29tcGxleE9wZXJhdG9yKHN0YXJ0LCAnJicsICRBTVBFUlNBTkQsICcmJyk7XG4gICAgICAgICAgICAgIGNhc2UgJEJBUjpcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5Db21wbGV4T3BlcmF0b3Ioc3RhcnQsICd8JywgJEJBUiwgJ3wnKTtcbiAgICAgICAgICAgICAgY2FzZSAkTkJTUDpcbiAgICAgICAgICAgICAgICAgIHdoaWxlIChpc1doaXRlc3BhY2UodGhpcy5wZWVrKSlcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5Ub2tlbigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvcihcIlVuZXhwZWN0ZWQgY2hhcmFjdGVyIFtcIiArIFN0cmluZy5mcm9tQ2hhckNvZGUocGVlaykgKyBcIl1cIiwgMCk7XG4gICAgICB9O1xuICAgICAgX1NjYW5uZXIucHJvdG90eXBlLnNjYW5DaGFyYWN0ZXIgPSBmdW5jdGlvbiAoc3RhcnQsIGNvZGUpIHtcbiAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICByZXR1cm4gbmV3Q2hhcmFjdGVyVG9rZW4oc3RhcnQsIGNvZGUpO1xuICAgICAgfTtcbiAgICAgIF9TY2FubmVyLnByb3RvdHlwZS5zY2FuT3BlcmF0b3IgPSBmdW5jdGlvbiAoc3RhcnQsIHN0cikge1xuICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgIHJldHVybiBuZXdPcGVyYXRvclRva2VuKHN0YXJ0LCBzdHIpO1xuICAgICAgfTtcbiAgICAgIC8qKlxuICAgICAgICogVG9rZW5pemUgYSAyLzMgY2hhciBsb25nIG9wZXJhdG9yXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHN0YXJ0IHN0YXJ0IGluZGV4IGluIHRoZSBleHByZXNzaW9uXG4gICAgICAgKiBAcGFyYW0gb25lIGZpcnN0IHN5bWJvbCAoYWx3YXlzIHBhcnQgb2YgdGhlIG9wZXJhdG9yKVxuICAgICAgICogQHBhcmFtIHR3b0NvZGUgY29kZSBwb2ludCBmb3IgdGhlIHNlY29uZCBzeW1ib2xcbiAgICAgICAqIEBwYXJhbSB0d28gc2Vjb25kIHN5bWJvbCAocGFydCBvZiB0aGUgb3BlcmF0b3Igd2hlbiB0aGUgc2Vjb25kIGNvZGUgcG9pbnQgbWF0Y2hlcylcbiAgICAgICAqIEBwYXJhbSB0aHJlZUNvZGUgY29kZSBwb2ludCBmb3IgdGhlIHRoaXJkIHN5bWJvbFxuICAgICAgICogQHBhcmFtIHRocmVlIHRoaXJkIHN5bWJvbCAocGFydCBvZiB0aGUgb3BlcmF0b3Igd2hlbiBwcm92aWRlZCBhbmQgbWF0Y2hlcyBzb3VyY2UgZXhwcmVzc2lvbilcbiAgICAgICAqIEByZXR1cm5zIHtUb2tlbn1cbiAgICAgICAqL1xuICAgICAgX1NjYW5uZXIucHJvdG90eXBlLnNjYW5Db21wbGV4T3BlcmF0b3IgPSBmdW5jdGlvbiAoc3RhcnQsIG9uZSwgdHdvQ29kZSwgdHdvLCB0aHJlZUNvZGUsIHRocmVlKSB7XG4gICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgdmFyIHN0ciA9IG9uZTtcbiAgICAgICAgICBpZiAodGhpcy5wZWVrID09IHR3b0NvZGUpIHtcbiAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgIHN0ciArPSB0d287XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1ByZXNlbnQodGhyZWVDb2RlKSAmJiB0aGlzLnBlZWsgPT0gdGhyZWVDb2RlKSB7XG4gICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICBzdHIgKz0gdGhyZWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXdPcGVyYXRvclRva2VuKHN0YXJ0LCBzdHIpO1xuICAgICAgfTtcbiAgICAgIF9TY2FubmVyLnByb3RvdHlwZS5zY2FuSWRlbnRpZmllciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmluZGV4O1xuICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgIHdoaWxlIChpc0lkZW50aWZpZXJQYXJ0KHRoaXMucGVlaykpXG4gICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgIHZhciBzdHIgPSB0aGlzLmlucHV0LnN1YnN0cmluZyhzdGFydCwgdGhpcy5pbmRleCk7XG4gICAgICAgICAgcmV0dXJuIEtFWVdPUkRTLmluZGV4T2Yoc3RyKSA+IC0xID8gbmV3S2V5d29yZFRva2VuKHN0YXJ0LCBzdHIpIDpcbiAgICAgICAgICAgICAgbmV3SWRlbnRpZmllclRva2VuKHN0YXJ0LCBzdHIpO1xuICAgICAgfTtcbiAgICAgIF9TY2FubmVyLnByb3RvdHlwZS5zY2FuTnVtYmVyID0gZnVuY3Rpb24gKHN0YXJ0KSB7XG4gICAgICAgICAgdmFyIHNpbXBsZSA9ICh0aGlzLmluZGV4ID09PSBzdGFydCk7XG4gICAgICAgICAgdGhpcy5hZHZhbmNlKCk7IC8vIFNraXAgaW5pdGlhbCBkaWdpdC5cbiAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICBpZiAoaXNEaWdpdCh0aGlzLnBlZWspKSB7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5wZWVrID09ICRQRVJJT0QpIHtcbiAgICAgICAgICAgICAgICAgIHNpbXBsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKGlzRXhwb25lbnRTdGFydCh0aGlzLnBlZWspKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICAgIGlmIChpc0V4cG9uZW50U2lnbih0aGlzLnBlZWspKVxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgaWYgKCFpc0RpZ2l0KHRoaXMucGVlaykpXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoJ0ludmFsaWQgZXhwb25lbnQnLCAtMSk7XG4gICAgICAgICAgICAgICAgICBzaW1wbGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgc3RyID0gdGhpcy5pbnB1dC5zdWJzdHJpbmcoc3RhcnQsIHRoaXMuaW5kZXgpO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHNpbXBsZSA/IE51bWJlcldyYXBwZXIucGFyc2VJbnRBdXRvUmFkaXgoc3RyKSA6IHBhcnNlRmxvYXQoc3RyKTtcbiAgICAgICAgICByZXR1cm4gbmV3TnVtYmVyVG9rZW4oc3RhcnQsIHZhbHVlKTtcbiAgICAgIH07XG4gICAgICBfU2Nhbm5lci5wcm90b3R5cGUuc2NhblN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmluZGV4O1xuICAgICAgICAgIHZhciBxdW90ZSA9IHRoaXMucGVlaztcbiAgICAgICAgICB0aGlzLmFkdmFuY2UoKTsgLy8gU2tpcCBpbml0aWFsIHF1b3RlLlxuICAgICAgICAgIHZhciBidWZmZXIgPSAnJztcbiAgICAgICAgICB2YXIgbWFya2VyID0gdGhpcy5pbmRleDtcbiAgICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLmlucHV0O1xuICAgICAgICAgIHdoaWxlICh0aGlzLnBlZWsgIT0gcXVvdGUpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMucGVlayA9PSAkQkFDS1NMQVNIKSB7XG4gICAgICAgICAgICAgICAgICBidWZmZXIgKz0gaW5wdXQuc3Vic3RyaW5nKG1hcmtlciwgdGhpcy5pbmRleCk7XG4gICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICAgIHZhciB1bmVzY2FwZWRDb2RlID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGVlayA9PSAkdSkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIDQgY2hhcmFjdGVyIGhleCBjb2RlIGZvciB1bmljb2RlIGNoYXJhY3Rlci5cbiAgICAgICAgICAgICAgICAgICAgICB2YXIgaGV4ID0gaW5wdXQuc3Vic3RyaW5nKHRoaXMuaW5kZXggKyAxLCB0aGlzLmluZGV4ICsgNSk7XG4gICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdW5lc2NhcGVkQ29kZSA9IE51bWJlcldyYXBwZXIucGFyc2VJbnQoaGV4LCAxNik7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yKFwiSW52YWxpZCB1bmljb2RlIGVzY2FwZSBbXFxcXHVcIiArIGhleCArIFwiXVwiLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgdW5lc2NhcGVkQ29kZSA9IHVuZXNjYXBlKHRoaXMucGVlayk7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBidWZmZXIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh1bmVzY2FwZWRDb2RlKTtcbiAgICAgICAgICAgICAgICAgIG1hcmtlciA9IHRoaXMuaW5kZXg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5wZWVrID09ICRFT0YpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yKCdVbnRlcm1pbmF0ZWQgcXVvdGUnLCAwKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBsYXN0ID0gaW5wdXQuc3Vic3RyaW5nKG1hcmtlciwgdGhpcy5pbmRleCk7XG4gICAgICAgICAgdGhpcy5hZHZhbmNlKCk7IC8vIFNraXAgdGVybWluYXRpbmcgcXVvdGUuXG4gICAgICAgICAgcmV0dXJuIG5ld1N0cmluZ1Rva2VuKHN0YXJ0LCBidWZmZXIgKyBsYXN0KTtcbiAgICAgIH07XG4gICAgICBfU2Nhbm5lci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZSwgb2Zmc2V0KSB7XG4gICAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5pbmRleCArIG9mZnNldDtcbiAgICAgICAgICByZXR1cm4gbmV3RXJyb3JUb2tlbihwb3NpdGlvbiwgXCJMZXhlciBFcnJvcjogXCIgKyBtZXNzYWdlICsgXCIgYXQgY29sdW1uIFwiICsgcG9zaXRpb24gKyBcIiBpbiBleHByZXNzaW9uIFtcIiArIHRoaXMuaW5wdXQgKyBcIl1cIik7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIF9TY2FubmVyO1xuICB9KCkpO1xuICBmdW5jdGlvbiBpc0lkZW50aWZpZXJTdGFydChjb2RlKSB7XG4gICAgICByZXR1cm4gKCRhIDw9IGNvZGUgJiYgY29kZSA8PSAkeikgfHwgKCRBIDw9IGNvZGUgJiYgY29kZSA8PSAkWikgfHxcbiAgICAgICAgICAoY29kZSA9PSAkXykgfHwgKGNvZGUgPT0gJCQpO1xuICB9XG4gIGZ1bmN0aW9uIGlzSWRlbnRpZmllcihpbnB1dCkge1xuICAgICAgaWYgKGlucHV0Lmxlbmd0aCA9PSAwKVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIHZhciBzY2FubmVyID0gbmV3IF9TY2FubmVyKGlucHV0KTtcbiAgICAgIGlmICghaXNJZGVudGlmaWVyU3RhcnQoc2Nhbm5lci5wZWVrKSlcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICBzY2FubmVyLmFkdmFuY2UoKTtcbiAgICAgIHdoaWxlIChzY2FubmVyLnBlZWsgIT09ICRFT0YpIHtcbiAgICAgICAgICBpZiAoIWlzSWRlbnRpZmllclBhcnQoc2Nhbm5lci5wZWVrKSlcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIHNjYW5uZXIuYWR2YW5jZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZnVuY3Rpb24gaXNJZGVudGlmaWVyUGFydChjb2RlKSB7XG4gICAgICByZXR1cm4gaXNBc2NpaUxldHRlcihjb2RlKSB8fCBpc0RpZ2l0KGNvZGUpIHx8IChjb2RlID09ICRfKSB8fFxuICAgICAgICAgIChjb2RlID09ICQkKTtcbiAgfVxuICBmdW5jdGlvbiBpc0V4cG9uZW50U3RhcnQoY29kZSkge1xuICAgICAgcmV0dXJuIGNvZGUgPT0gJGUgfHwgY29kZSA9PSAkRTtcbiAgfVxuICBmdW5jdGlvbiBpc0V4cG9uZW50U2lnbihjb2RlKSB7XG4gICAgICByZXR1cm4gY29kZSA9PSAkTUlOVVMgfHwgY29kZSA9PSAkUExVUztcbiAgfVxuICBmdW5jdGlvbiBpc1F1b3RlKGNvZGUpIHtcbiAgICAgIHJldHVybiBjb2RlID09PSAkU1EgfHwgY29kZSA9PT0gJERRIHx8IGNvZGUgPT09ICRCVDtcbiAgfVxuICBmdW5jdGlvbiB1bmVzY2FwZShjb2RlKSB7XG4gICAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgICBjYXNlICRuOlxuICAgICAgICAgICAgICByZXR1cm4gJExGO1xuICAgICAgICAgIGNhc2UgJGY6XG4gICAgICAgICAgICAgIHJldHVybiAkRkY7XG4gICAgICAgICAgY2FzZSAkcjpcbiAgICAgICAgICAgICAgcmV0dXJuICRDUjtcbiAgICAgICAgICBjYXNlICR0OlxuICAgICAgICAgICAgICByZXR1cm4gJFRBQjtcbiAgICAgICAgICBjYXNlICR2OlxuICAgICAgICAgICAgICByZXR1cm4gJFZUQUI7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmV0dXJuIGNvZGU7XG4gICAgICB9XG4gIH1cblxuICB2YXIgU3BsaXRJbnRlcnBvbGF0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFNwbGl0SW50ZXJwb2xhdGlvbihzdHJpbmdzLCBleHByZXNzaW9ucywgb2Zmc2V0cykge1xuICAgICAgICAgIHRoaXMuc3RyaW5ncyA9IHN0cmluZ3M7XG4gICAgICAgICAgdGhpcy5leHByZXNzaW9ucyA9IGV4cHJlc3Npb25zO1xuICAgICAgICAgIHRoaXMub2Zmc2V0cyA9IG9mZnNldHM7XG4gICAgICB9XG4gICAgICByZXR1cm4gU3BsaXRJbnRlcnBvbGF0aW9uO1xuICB9KCkpO1xuICB2YXIgVGVtcGxhdGVCaW5kaW5nUGFyc2VSZXN1bHQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gVGVtcGxhdGVCaW5kaW5nUGFyc2VSZXN1bHQodGVtcGxhdGVCaW5kaW5ncywgd2FybmluZ3MsIGVycm9ycykge1xuICAgICAgICAgIHRoaXMudGVtcGxhdGVCaW5kaW5ncyA9IHRlbXBsYXRlQmluZGluZ3M7XG4gICAgICAgICAgdGhpcy53YXJuaW5ncyA9IHdhcm5pbmdzO1xuICAgICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFRlbXBsYXRlQmluZGluZ1BhcnNlUmVzdWx0O1xuICB9KCkpO1xuICBmdW5jdGlvbiBfY3JlYXRlSW50ZXJwb2xhdGVSZWdFeHAoY29uZmlnKSB7XG4gICAgICB2YXIgcGF0dGVybiA9IGVzY2FwZVJlZ0V4cChjb25maWcuc3RhcnQpICsgJyhbXFxcXHNcXFxcU10qPyknICsgZXNjYXBlUmVnRXhwKGNvbmZpZy5lbmQpO1xuICAgICAgcmV0dXJuIG5ldyBSZWdFeHAocGF0dGVybiwgJ2cnKTtcbiAgfVxuICB2YXIgUGFyc2VyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFBhcnNlcihfbGV4ZXIpIHtcbiAgICAgICAgICB0aGlzLl9sZXhlciA9IF9sZXhlcjtcbiAgICAgICAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgICAgfVxuICAgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUFjdGlvbiA9IGZ1bmN0aW9uIChpbnB1dCwgbG9jYXRpb24sIGludGVycG9sYXRpb25Db25maWcpIHtcbiAgICAgICAgICBpZiAoaW50ZXJwb2xhdGlvbkNvbmZpZyA9PT0gdm9pZCAwKSB7IGludGVycG9sYXRpb25Db25maWcgPSBERUZBVUxUX0lOVEVSUE9MQVRJT05fQ09ORklHOyB9XG4gICAgICAgICAgdGhpcy5fY2hlY2tOb0ludGVycG9sYXRpb24oaW5wdXQsIGxvY2F0aW9uLCBpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgICB2YXIgc291cmNlVG9MZXggPSB0aGlzLl9zdHJpcENvbW1lbnRzKGlucHV0KTtcbiAgICAgICAgICB2YXIgdG9rZW5zID0gdGhpcy5fbGV4ZXIudG9rZW5pemUodGhpcy5fc3RyaXBDb21tZW50cyhpbnB1dCkpO1xuICAgICAgICAgIHZhciBhc3QgPSBuZXcgX1BhcnNlQVNUKGlucHV0LCBsb2NhdGlvbiwgdG9rZW5zLCBzb3VyY2VUb0xleC5sZW5ndGgsIHRydWUsIHRoaXMuZXJyb3JzLCBpbnB1dC5sZW5ndGggLSBzb3VyY2VUb0xleC5sZW5ndGgpXG4gICAgICAgICAgICAgIC5wYXJzZUNoYWluKCk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBBU1RXaXRoU291cmNlKGFzdCwgaW5wdXQsIGxvY2F0aW9uLCB0aGlzLmVycm9ycyk7XG4gICAgICB9O1xuICAgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUJpbmRpbmcgPSBmdW5jdGlvbiAoaW5wdXQsIGxvY2F0aW9uLCBpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgICAgaWYgKGludGVycG9sYXRpb25Db25maWcgPT09IHZvaWQgMCkgeyBpbnRlcnBvbGF0aW9uQ29uZmlnID0gREVGQVVMVF9JTlRFUlBPTEFUSU9OX0NPTkZJRzsgfVxuICAgICAgICAgIHZhciBhc3QgPSB0aGlzLl9wYXJzZUJpbmRpbmdBc3QoaW5wdXQsIGxvY2F0aW9uLCBpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgICByZXR1cm4gbmV3IEFTVFdpdGhTb3VyY2UoYXN0LCBpbnB1dCwgbG9jYXRpb24sIHRoaXMuZXJyb3JzKTtcbiAgICAgIH07XG4gICAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlU2ltcGxlQmluZGluZyA9IGZ1bmN0aW9uIChpbnB1dCwgbG9jYXRpb24sIGludGVycG9sYXRpb25Db25maWcpIHtcbiAgICAgICAgICBpZiAoaW50ZXJwb2xhdGlvbkNvbmZpZyA9PT0gdm9pZCAwKSB7IGludGVycG9sYXRpb25Db25maWcgPSBERUZBVUxUX0lOVEVSUE9MQVRJT05fQ09ORklHOyB9XG4gICAgICAgICAgdmFyIGFzdCA9IHRoaXMuX3BhcnNlQmluZGluZ0FzdChpbnB1dCwgbG9jYXRpb24sIGludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICAgIGlmICghU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIuY2hlY2soYXN0KSkge1xuICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcignSG9zdCBiaW5kaW5nIGV4cHJlc3Npb24gY2FuIG9ubHkgY29udGFpbiBmaWVsZCBhY2Nlc3MgYW5kIGNvbnN0YW50cycsIGlucHV0LCBsb2NhdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgQVNUV2l0aFNvdXJjZShhc3QsIGlucHV0LCBsb2NhdGlvbiwgdGhpcy5lcnJvcnMpO1xuICAgICAgfTtcbiAgICAgIFBhcnNlci5wcm90b3R5cGUuX3JlcG9ydEVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UsIGlucHV0LCBlcnJMb2NhdGlvbiwgY3R4TG9jYXRpb24pIHtcbiAgICAgICAgICB0aGlzLmVycm9ycy5wdXNoKG5ldyBQYXJzZXJFcnJvcihtZXNzYWdlLCBpbnB1dCwgZXJyTG9jYXRpb24sIGN0eExvY2F0aW9uKSk7XG4gICAgICB9O1xuICAgICAgUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VCaW5kaW5nQXN0ID0gZnVuY3Rpb24gKGlucHV0LCBsb2NhdGlvbiwgaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgICAgICAgIC8vIFF1b3RlcyBleHByZXNzaW9ucyB1c2UgM3JkLXBhcnR5IGV4cHJlc3Npb24gbGFuZ3VhZ2UuIFdlIGRvbid0IHdhbnQgdG8gdXNlXG4gICAgICAgICAgLy8gb3VyIGxleGVyIG9yIHBhcnNlciBmb3IgdGhhdCwgc28gd2UgY2hlY2sgZm9yIHRoYXQgYWhlYWQgb2YgdGltZS5cbiAgICAgICAgICB2YXIgcXVvdGUgPSB0aGlzLl9wYXJzZVF1b3RlKGlucHV0LCBsb2NhdGlvbik7XG4gICAgICAgICAgaWYgKGlzUHJlc2VudChxdW90ZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHF1b3RlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9jaGVja05vSW50ZXJwb2xhdGlvbihpbnB1dCwgbG9jYXRpb24sIGludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICAgIHZhciBzb3VyY2VUb0xleCA9IHRoaXMuX3N0cmlwQ29tbWVudHMoaW5wdXQpO1xuICAgICAgICAgIHZhciB0b2tlbnMgPSB0aGlzLl9sZXhlci50b2tlbml6ZShzb3VyY2VUb0xleCk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBfUGFyc2VBU1QoaW5wdXQsIGxvY2F0aW9uLCB0b2tlbnMsIHNvdXJjZVRvTGV4Lmxlbmd0aCwgZmFsc2UsIHRoaXMuZXJyb3JzLCBpbnB1dC5sZW5ndGggLSBzb3VyY2VUb0xleC5sZW5ndGgpXG4gICAgICAgICAgICAgIC5wYXJzZUNoYWluKCk7XG4gICAgICB9O1xuICAgICAgUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VRdW90ZSA9IGZ1bmN0aW9uIChpbnB1dCwgbG9jYXRpb24pIHtcbiAgICAgICAgICBpZiAoaXNCbGFuayhpbnB1dCkpXG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIHZhciBwcmVmaXhTZXBhcmF0b3JJbmRleCA9IGlucHV0LmluZGV4T2YoJzonKTtcbiAgICAgICAgICBpZiAocHJlZml4U2VwYXJhdG9ySW5kZXggPT0gLTEpXG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIHZhciBwcmVmaXggPSBpbnB1dC5zdWJzdHJpbmcoMCwgcHJlZml4U2VwYXJhdG9ySW5kZXgpLnRyaW0oKTtcbiAgICAgICAgICBpZiAoIWlzSWRlbnRpZmllcihwcmVmaXgpKVxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB2YXIgdW5pbnRlcnByZXRlZEV4cHJlc3Npb24gPSBpbnB1dC5zdWJzdHJpbmcocHJlZml4U2VwYXJhdG9ySW5kZXggKyAxKTtcbiAgICAgICAgICByZXR1cm4gbmV3IFF1b3RlKG5ldyBQYXJzZVNwYW4oMCwgaW5wdXQubGVuZ3RoKSwgcHJlZml4LCB1bmludGVycHJldGVkRXhwcmVzc2lvbiwgbG9jYXRpb24pO1xuICAgICAgfTtcbiAgICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VUZW1wbGF0ZUJpbmRpbmdzID0gZnVuY3Rpb24gKGlucHV0LCBsb2NhdGlvbikge1xuICAgICAgICAgIHZhciB0b2tlbnMgPSB0aGlzLl9sZXhlci50b2tlbml6ZShpbnB1dCk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBfUGFyc2VBU1QoaW5wdXQsIGxvY2F0aW9uLCB0b2tlbnMsIGlucHV0Lmxlbmd0aCwgZmFsc2UsIHRoaXMuZXJyb3JzLCAwKVxuICAgICAgICAgICAgICAucGFyc2VUZW1wbGF0ZUJpbmRpbmdzKCk7XG4gICAgICB9O1xuICAgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUludGVycG9sYXRpb24gPSBmdW5jdGlvbiAoaW5wdXQsIGxvY2F0aW9uLCBpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgICAgaWYgKGludGVycG9sYXRpb25Db25maWcgPT09IHZvaWQgMCkgeyBpbnRlcnBvbGF0aW9uQ29uZmlnID0gREVGQVVMVF9JTlRFUlBPTEFUSU9OX0NPTkZJRzsgfVxuICAgICAgICAgIHZhciBzcGxpdCA9IHRoaXMuc3BsaXRJbnRlcnBvbGF0aW9uKGlucHV0LCBsb2NhdGlvbiwgaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICAgICAgaWYgKHNwbGl0ID09IG51bGwpXG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIHZhciBleHByZXNzaW9ucyA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3BsaXQuZXhwcmVzc2lvbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgdmFyIGV4cHJlc3Npb25UZXh0ID0gc3BsaXQuZXhwcmVzc2lvbnNbaV07XG4gICAgICAgICAgICAgIHZhciBzb3VyY2VUb0xleCA9IHRoaXMuX3N0cmlwQ29tbWVudHMoZXhwcmVzc2lvblRleHQpO1xuICAgICAgICAgICAgICB2YXIgdG9rZW5zID0gdGhpcy5fbGV4ZXIudG9rZW5pemUodGhpcy5fc3RyaXBDb21tZW50cyhzcGxpdC5leHByZXNzaW9uc1tpXSkpO1xuICAgICAgICAgICAgICB2YXIgYXN0ID0gbmV3IF9QYXJzZUFTVChpbnB1dCwgbG9jYXRpb24sIHRva2Vucywgc291cmNlVG9MZXgubGVuZ3RoLCBmYWxzZSwgdGhpcy5lcnJvcnMsIHNwbGl0Lm9mZnNldHNbaV0gKyAoZXhwcmVzc2lvblRleHQubGVuZ3RoIC0gc291cmNlVG9MZXgubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgIC5wYXJzZUNoYWluKCk7XG4gICAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2goYXN0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBBU1RXaXRoU291cmNlKG5ldyBJbnRlcnBvbGF0aW9uKG5ldyBQYXJzZVNwYW4oMCwgaXNCbGFuayhpbnB1dCkgPyAwIDogaW5wdXQubGVuZ3RoKSwgc3BsaXQuc3RyaW5ncywgZXhwcmVzc2lvbnMpLCBpbnB1dCwgbG9jYXRpb24sIHRoaXMuZXJyb3JzKTtcbiAgICAgIH07XG4gICAgICBQYXJzZXIucHJvdG90eXBlLnNwbGl0SW50ZXJwb2xhdGlvbiA9IGZ1bmN0aW9uIChpbnB1dCwgbG9jYXRpb24sIGludGVycG9sYXRpb25Db25maWcpIHtcbiAgICAgICAgICBpZiAoaW50ZXJwb2xhdGlvbkNvbmZpZyA9PT0gdm9pZCAwKSB7IGludGVycG9sYXRpb25Db25maWcgPSBERUZBVUxUX0lOVEVSUE9MQVRJT05fQ09ORklHOyB9XG4gICAgICAgICAgdmFyIHJlZ2V4cCA9IF9jcmVhdGVJbnRlcnBvbGF0ZVJlZ0V4cChpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgICB2YXIgcGFydHMgPSBpbnB1dC5zcGxpdChyZWdleHApO1xuICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHN0cmluZ3MgPSBbXTtcbiAgICAgICAgICB2YXIgZXhwcmVzc2lvbnMgPSBbXTtcbiAgICAgICAgICB2YXIgb2Zmc2V0cyA9IFtdO1xuICAgICAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIHBhcnQgPSBwYXJ0c1tpXTtcbiAgICAgICAgICAgICAgaWYgKGkgJSAyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAvLyBmaXhlZCBzdHJpbmdcbiAgICAgICAgICAgICAgICAgIHN0cmluZ3MucHVzaChwYXJ0KTtcbiAgICAgICAgICAgICAgICAgIG9mZnNldCArPSBwYXJ0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmIChwYXJ0LnRyaW0oKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gaW50ZXJwb2xhdGlvbkNvbmZpZy5zdGFydC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKHBhcnQpO1xuICAgICAgICAgICAgICAgICAgb2Zmc2V0cy5wdXNoKG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gcGFydC5sZW5ndGggKyBpbnRlcnBvbGF0aW9uQ29uZmlnLmVuZC5sZW5ndGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcignQmxhbmsgZXhwcmVzc2lvbnMgYXJlIG5vdCBhbGxvd2VkIGluIGludGVycG9sYXRlZCBzdHJpbmdzJywgaW5wdXQsIFwiYXQgY29sdW1uIFwiICsgdGhpcy5fZmluZEludGVycG9sYXRpb25FcnJvckNvbHVtbihwYXJ0cywgaSwgaW50ZXJwb2xhdGlvbkNvbmZpZykgKyBcIiBpblwiLCBsb2NhdGlvbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBTcGxpdEludGVycG9sYXRpb24oc3RyaW5ncywgZXhwcmVzc2lvbnMsIG9mZnNldHMpO1xuICAgICAgfTtcbiAgICAgIFBhcnNlci5wcm90b3R5cGUud3JhcExpdGVyYWxQcmltaXRpdmUgPSBmdW5jdGlvbiAoaW5wdXQsIGxvY2F0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBBU1RXaXRoU291cmNlKG5ldyBMaXRlcmFsUHJpbWl0aXZlKG5ldyBQYXJzZVNwYW4oMCwgaXNCbGFuayhpbnB1dCkgPyAwIDogaW5wdXQubGVuZ3RoKSwgaW5wdXQpLCBpbnB1dCwgbG9jYXRpb24sIHRoaXMuZXJyb3JzKTtcbiAgICAgIH07XG4gICAgICBQYXJzZXIucHJvdG90eXBlLl9zdHJpcENvbW1lbnRzID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgdmFyIGkgPSB0aGlzLl9jb21tZW50U3RhcnQoaW5wdXQpO1xuICAgICAgICAgIHJldHVybiBpc1ByZXNlbnQoaSkgPyBpbnB1dC5zdWJzdHJpbmcoMCwgaSkudHJpbSgpIDogaW5wdXQ7XG4gICAgICB9O1xuICAgICAgUGFyc2VyLnByb3RvdHlwZS5fY29tbWVudFN0YXJ0ID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgdmFyIG91dGVyUXVvdGUgPSBudWxsO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBjaGFyID0gaW5wdXQuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgICAgdmFyIG5leHRDaGFyID0gaW5wdXQuY2hhckNvZGVBdChpICsgMSk7XG4gICAgICAgICAgICAgIGlmIChjaGFyID09PSAkU0xBU0ggJiYgbmV4dENoYXIgPT0gJFNMQVNIICYmIGlzQmxhbmsob3V0ZXJRdW90ZSkpXG4gICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgaWYgKG91dGVyUXVvdGUgPT09IGNoYXIpIHtcbiAgICAgICAgICAgICAgICAgIG91dGVyUXVvdGUgPSBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKGlzQmxhbmsob3V0ZXJRdW90ZSkgJiYgaXNRdW90ZShjaGFyKSkge1xuICAgICAgICAgICAgICAgICAgb3V0ZXJRdW90ZSA9IGNoYXI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgUGFyc2VyLnByb3RvdHlwZS5fY2hlY2tOb0ludGVycG9sYXRpb24gPSBmdW5jdGlvbiAoaW5wdXQsIGxvY2F0aW9uLCBpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgICAgdmFyIHJlZ2V4cCA9IF9jcmVhdGVJbnRlcnBvbGF0ZVJlZ0V4cChpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgICB2YXIgcGFydHMgPSBpbnB1dC5zcGxpdChyZWdleHApO1xuICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKFwiR290IGludGVycG9sYXRpb24gKFwiICsgaW50ZXJwb2xhdGlvbkNvbmZpZy5zdGFydCArIGludGVycG9sYXRpb25Db25maWcuZW5kICsgXCIpIHdoZXJlIGV4cHJlc3Npb24gd2FzIGV4cGVjdGVkXCIsIGlucHV0LCBcImF0IGNvbHVtbiBcIiArIHRoaXMuX2ZpbmRJbnRlcnBvbGF0aW9uRXJyb3JDb2x1bW4ocGFydHMsIDEsIGludGVycG9sYXRpb25Db25maWcpICsgXCIgaW5cIiwgbG9jYXRpb24pO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBQYXJzZXIucHJvdG90eXBlLl9maW5kSW50ZXJwb2xhdGlvbkVycm9yQ29sdW1uID0gZnVuY3Rpb24gKHBhcnRzLCBwYXJ0SW5FcnJJZHgsIGludGVycG9sYXRpb25Db25maWcpIHtcbiAgICAgICAgICB2YXIgZXJyTG9jYXRpb24gPSAnJztcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBhcnRJbkVycklkeDsgaisrKSB7XG4gICAgICAgICAgICAgIGVyckxvY2F0aW9uICs9IGogJSAyID09PSAwID9cbiAgICAgICAgICAgICAgICAgIHBhcnRzW2pdIDpcbiAgICAgICAgICAgICAgICAgIFwiXCIgKyBpbnRlcnBvbGF0aW9uQ29uZmlnLnN0YXJ0ICsgcGFydHNbal0gKyBpbnRlcnBvbGF0aW9uQ29uZmlnLmVuZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGVyckxvY2F0aW9uLmxlbmd0aDtcbiAgICAgIH07XG4gICAgICBQYXJzZXIuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuICAgICAgXTtcbiAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgUGFyc2VyLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgIHsgdHlwZTogTGV4ZXIsIH0sXG4gICAgICBdO1xuICAgICAgcmV0dXJuIFBhcnNlcjtcbiAgfSgpKTtcbiAgdmFyIF9QYXJzZUFTVCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBfUGFyc2VBU1QoaW5wdXQsIGxvY2F0aW9uLCB0b2tlbnMsIGlucHV0TGVuZ3RoLCBwYXJzZUFjdGlvbiwgZXJyb3JzLCBvZmZzZXQpIHtcbiAgICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICAgIHRoaXMudG9rZW5zID0gdG9rZW5zO1xuICAgICAgICAgIHRoaXMuaW5wdXRMZW5ndGggPSBpbnB1dExlbmd0aDtcbiAgICAgICAgICB0aGlzLnBhcnNlQWN0aW9uID0gcGFyc2VBY3Rpb247XG4gICAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgdGhpcy5ycGFyZW5zRXhwZWN0ZWQgPSAwO1xuICAgICAgICAgIHRoaXMucmJyYWNrZXRzRXhwZWN0ZWQgPSAwO1xuICAgICAgICAgIHRoaXMucmJyYWNlc0V4cGVjdGVkID0gMDtcbiAgICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgIH1cbiAgICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgICB2YXIgaSA9IHRoaXMuaW5kZXggKyBvZmZzZXQ7XG4gICAgICAgICAgcmV0dXJuIGkgPCB0aGlzLnRva2Vucy5sZW5ndGggPyB0aGlzLnRva2Vuc1tpXSA6IEVPRjtcbiAgICAgIH07XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX1BhcnNlQVNULnByb3RvdHlwZSwgXCJuZXh0XCIsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucGVlaygwKTsgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX1BhcnNlQVNULnByb3RvdHlwZSwgXCJpbnB1dEluZGV4XCIsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLmluZGV4IDwgdGhpcy50b2tlbnMubGVuZ3RoKSA/IHRoaXMubmV4dC5pbmRleCArIHRoaXMub2Zmc2V0IDpcbiAgICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRMZW5ndGggKyB0aGlzLm9mZnNldDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIF9QYXJzZUFTVC5wcm90b3R5cGUuc3BhbiA9IGZ1bmN0aW9uIChzdGFydCkgeyByZXR1cm4gbmV3IFBhcnNlU3BhbihzdGFydCwgdGhpcy5pbnB1dEluZGV4KTsgfTtcbiAgICAgIF9QYXJzZUFTVC5wcm90b3R5cGUuYWR2YW5jZSA9IGZ1bmN0aW9uICgpIHsgdGhpcy5pbmRleCsrOyB9O1xuICAgICAgX1BhcnNlQVNULnByb3RvdHlwZS5vcHRpb25hbENoYXJhY3RlciA9IGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgICAgICAgaWYgKHRoaXMubmV4dC5pc0NoYXJhY3Rlcihjb2RlKSkge1xuICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGVla0tleXdvcmRMZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLm5leHQuaXNLZXl3b3JkTGV0KCk7IH07XG4gICAgICBfUGFyc2VBU1QucHJvdG90eXBlLmV4cGVjdENoYXJhY3RlciA9IGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxDaGFyYWN0ZXIoY29kZSkpXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB0aGlzLmVycm9yKFwiTWlzc2luZyBleHBlY3RlZCBcIiArIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkpO1xuICAgICAgfTtcbiAgICAgIF9QYXJzZUFTVC5wcm90b3R5cGUub3B0aW9uYWxPcGVyYXRvciA9IGZ1bmN0aW9uIChvcCkge1xuICAgICAgICAgIGlmICh0aGlzLm5leHQuaXNPcGVyYXRvcihvcCkpIHtcbiAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfUGFyc2VBU1QucHJvdG90eXBlLmV4cGVjdE9wZXJhdG9yID0gZnVuY3Rpb24gKG9wZXJhdG9yKSB7XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxPcGVyYXRvcihvcGVyYXRvcikpXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB0aGlzLmVycm9yKFwiTWlzc2luZyBleHBlY3RlZCBvcGVyYXRvciBcIiArIG9wZXJhdG9yKTtcbiAgICAgIH07XG4gICAgICBfUGFyc2VBU1QucHJvdG90eXBlLmV4cGVjdElkZW50aWZpZXJPcktleXdvcmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIG4gPSB0aGlzLm5leHQ7XG4gICAgICAgICAgaWYgKCFuLmlzSWRlbnRpZmllcigpICYmICFuLmlzS2V5d29yZCgpKSB7XG4gICAgICAgICAgICAgIHRoaXMuZXJyb3IoXCJVbmV4cGVjdGVkIHRva2VuIFwiICsgbiArIFwiLCBleHBlY3RlZCBpZGVudGlmaWVyIG9yIGtleXdvcmRcIik7XG4gICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgcmV0dXJuIG4udG9TdHJpbmcoKTtcbiAgICAgIH07XG4gICAgICBfUGFyc2VBU1QucHJvdG90eXBlLmV4cGVjdElkZW50aWZpZXJPcktleXdvcmRPclN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgbiA9IHRoaXMubmV4dDtcbiAgICAgICAgICBpZiAoIW4uaXNJZGVudGlmaWVyKCkgJiYgIW4uaXNLZXl3b3JkKCkgJiYgIW4uaXNTdHJpbmcoKSkge1xuICAgICAgICAgICAgICB0aGlzLmVycm9yKFwiVW5leHBlY3RlZCB0b2tlbiBcIiArIG4gKyBcIiwgZXhwZWN0ZWQgaWRlbnRpZmllciwga2V5d29yZCwgb3Igc3RyaW5nXCIpO1xuICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgIHJldHVybiBuLnRvU3RyaW5nKCk7XG4gICAgICB9O1xuICAgICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZUNoYWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBleHBycyA9IFtdO1xuICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMuaW5wdXRJbmRleDtcbiAgICAgICAgICB3aGlsZSAodGhpcy5pbmRleCA8IHRoaXMudG9rZW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgICB2YXIgZXhwciA9IHRoaXMucGFyc2VQaXBlKCk7XG4gICAgICAgICAgICAgIGV4cHJzLnB1c2goZXhwcik7XG4gICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKCRTRU1JQ09MT04pKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIXRoaXMucGFyc2VBY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yKCdCaW5kaW5nIGV4cHJlc3Npb24gY2Fubm90IGNvbnRhaW4gY2hhaW5lZCBleHByZXNzaW9uJyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5vcHRpb25hbENoYXJhY3RlcigkU0VNSUNPTE9OKSkge1xuICAgICAgICAgICAgICAgICAgfSAvLyByZWFkIGFsbCBzZW1pY29sb25zXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5pbmRleCA8IHRoaXMudG9rZW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcihcIlVuZXhwZWN0ZWQgdG9rZW4gJ1wiICsgdGhpcy5uZXh0ICsgXCInXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChleHBycy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFbXB0eUV4cHIodGhpcy5zcGFuKHN0YXJ0KSk7XG4gICAgICAgICAgaWYgKGV4cHJzLmxlbmd0aCA9PSAxKVxuICAgICAgICAgICAgICByZXR1cm4gZXhwcnNbMF07XG4gICAgICAgICAgcmV0dXJuIG5ldyBDaGFpbih0aGlzLnNwYW4oc3RhcnQpLCBleHBycyk7XG4gICAgICB9O1xuICAgICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZVBpcGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxPcGVyYXRvcignfCcpKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLnBhcnNlQWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmVycm9yKCdDYW5ub3QgaGF2ZSBhIHBpcGUgaW4gYW4gYWN0aW9uIGV4cHJlc3Npb24nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IHRoaXMuZXhwZWN0SWRlbnRpZmllck9yS2V5d29yZCgpO1xuICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKCRDT0xPTikpIHtcbiAgICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2godGhpcy5wYXJzZUV4cHJlc3Npb24oKSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgQmluZGluZ1BpcGUodGhpcy5zcGFuKHJlc3VsdC5zcGFuLnN0YXJ0IC0gdGhpcy5vZmZzZXQpLCByZXN1bHQsIG5hbWUsIGFyZ3MpO1xuICAgICAgICAgICAgICB9IHdoaWxlICh0aGlzLm9wdGlvbmFsT3BlcmF0b3IoJ3wnKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZUV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnBhcnNlQ29uZGl0aW9uYWwoKTsgfTtcbiAgICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VDb25kaXRpb25hbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmlucHV0SW5kZXg7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucGFyc2VMb2dpY2FsT3IoKTtcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25hbE9wZXJhdG9yKCc/JykpIHtcbiAgICAgICAgICAgICAgdmFyIHllcyA9IHRoaXMucGFyc2VQaXBlKCk7XG4gICAgICAgICAgICAgIHZhciBubyA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKCRDT0xPTikpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBlbmQgPSB0aGlzLmlucHV0SW5kZXg7XG4gICAgICAgICAgICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IHRoaXMuaW5wdXQuc3Vic3RyaW5nKHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcihcIkNvbmRpdGlvbmFsIGV4cHJlc3Npb24gXCIgKyBleHByZXNzaW9uICsgXCIgcmVxdWlyZXMgYWxsIDMgZXhwcmVzc2lvbnNcIik7XG4gICAgICAgICAgICAgICAgICBubyA9IG5ldyBFbXB0eUV4cHIodGhpcy5zcGFuKHN0YXJ0KSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICBubyA9IHRoaXMucGFyc2VQaXBlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb25kaXRpb25hbCh0aGlzLnNwYW4oc3RhcnQpLCByZXN1bHQsIHllcywgbm8pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZUxvZ2ljYWxPciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyAnfHwnXG4gICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucGFyc2VMb2dpY2FsQW5kKCk7XG4gICAgICAgICAgd2hpbGUgKHRoaXMub3B0aW9uYWxPcGVyYXRvcignfHwnKSkge1xuICAgICAgICAgICAgICB2YXIgcmlnaHQgPSB0aGlzLnBhcnNlTG9naWNhbEFuZCgpO1xuICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgQmluYXJ5KHRoaXMuc3BhbihyZXN1bHQuc3Bhbi5zdGFydCksICd8fCcsIHJlc3VsdCwgcmlnaHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VMb2dpY2FsQW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vICcmJidcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5wYXJzZUVxdWFsaXR5KCk7XG4gICAgICAgICAgd2hpbGUgKHRoaXMub3B0aW9uYWxPcGVyYXRvcignJiYnKSkge1xuICAgICAgICAgICAgICB2YXIgcmlnaHQgPSB0aGlzLnBhcnNlRXF1YWxpdHkoKTtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEJpbmFyeSh0aGlzLnNwYW4ocmVzdWx0LnNwYW4uc3RhcnQpLCAnJiYnLCByZXN1bHQsIHJpZ2h0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlRXF1YWxpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gJz09JywnIT0nLCc9PT0nLCchPT0nXG4gICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucGFyc2VSZWxhdGlvbmFsKCk7XG4gICAgICAgICAgd2hpbGUgKHRoaXMubmV4dC50eXBlID09IGV4cG9ydHMuVG9rZW5UeXBlLk9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgIHZhciBvcGVyYXRvciA9IHRoaXMubmV4dC5zdHJWYWx1ZTtcbiAgICAgICAgICAgICAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgICAgICAgICAgICAgICAgY2FzZSAnPT0nOlxuICAgICAgICAgICAgICAgICAgY2FzZSAnPT09JzpcbiAgICAgICAgICAgICAgICAgIGNhc2UgJyE9JzpcbiAgICAgICAgICAgICAgICAgIGNhc2UgJyE9PSc6XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5wYXJzZVJlbGF0aW9uYWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgQmluYXJ5KHRoaXMuc3BhbihyZXN1bHQuc3Bhbi5zdGFydCksIG9wZXJhdG9yLCByZXN1bHQsIHJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlUmVsYXRpb25hbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyAnPCcsICc+JywgJzw9JywgJz49J1xuICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnBhcnNlQWRkaXRpdmUoKTtcbiAgICAgICAgICB3aGlsZSAodGhpcy5uZXh0LnR5cGUgPT0gZXhwb3J0cy5Ub2tlblR5cGUuT3BlcmF0b3IpIHtcbiAgICAgICAgICAgICAgdmFyIG9wZXJhdG9yID0gdGhpcy5uZXh0LnN0clZhbHVlO1xuICAgICAgICAgICAgICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgICAgICAgICAgIGNhc2UgJz4nOlxuICAgICAgICAgICAgICAgICAgY2FzZSAnPD0nOlxuICAgICAgICAgICAgICAgICAgY2FzZSAnPj0nOlxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciByaWdodCA9IHRoaXMucGFyc2VBZGRpdGl2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBCaW5hcnkodGhpcy5zcGFuKHJlc3VsdC5zcGFuLnN0YXJ0KSwgb3BlcmF0b3IsIHJlc3VsdCwgcmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VBZGRpdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyAnKycsICctJ1xuICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnBhcnNlTXVsdGlwbGljYXRpdmUoKTtcbiAgICAgICAgICB3aGlsZSAodGhpcy5uZXh0LnR5cGUgPT0gZXhwb3J0cy5Ub2tlblR5cGUuT3BlcmF0b3IpIHtcbiAgICAgICAgICAgICAgdmFyIG9wZXJhdG9yID0gdGhpcy5uZXh0LnN0clZhbHVlO1xuICAgICAgICAgICAgICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlICcrJzpcbiAgICAgICAgICAgICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciByaWdodCA9IHRoaXMucGFyc2VNdWx0aXBsaWNhdGl2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBCaW5hcnkodGhpcy5zcGFuKHJlc3VsdC5zcGFuLnN0YXJ0KSwgb3BlcmF0b3IsIHJlc3VsdCwgcmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VNdWx0aXBsaWNhdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyAnKicsICclJywgJy8nXG4gICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucGFyc2VQcmVmaXgoKTtcbiAgICAgICAgICB3aGlsZSAodGhpcy5uZXh0LnR5cGUgPT0gZXhwb3J0cy5Ub2tlblR5cGUuT3BlcmF0b3IpIHtcbiAgICAgICAgICAgICAgdmFyIG9wZXJhdG9yID0gdGhpcy5uZXh0LnN0clZhbHVlO1xuICAgICAgICAgICAgICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlICcqJzpcbiAgICAgICAgICAgICAgICAgIGNhc2UgJyUnOlxuICAgICAgICAgICAgICAgICAgY2FzZSAnLyc6XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5wYXJzZVByZWZpeCgpO1xuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBCaW5hcnkodGhpcy5zcGFuKHJlc3VsdC5zcGFuLnN0YXJ0KSwgb3BlcmF0b3IsIHJlc3VsdCwgcmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VQcmVmaXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKHRoaXMubmV4dC50eXBlID09IGV4cG9ydHMuVG9rZW5UeXBlLk9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMuaW5wdXRJbmRleDtcbiAgICAgICAgICAgICAgdmFyIG9wZXJhdG9yID0gdGhpcy5uZXh0LnN0clZhbHVlO1xuICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdm9pZCAwO1xuICAgICAgICAgICAgICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlICcrJzpcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVByZWZpeCgpO1xuICAgICAgICAgICAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wYXJzZVByZWZpeCgpO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQmluYXJ5KHRoaXMuc3BhbihzdGFydCksIG9wZXJhdG9yLCBuZXcgTGl0ZXJhbFByaW1pdGl2ZShuZXcgUGFyc2VTcGFuKHN0YXJ0LCBzdGFydCksIDApLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgY2FzZSAnISc6XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wYXJzZVByZWZpeCgpO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJlZml4Tm90KHRoaXMuc3BhbihzdGFydCksIHJlc3VsdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VDYWxsQ2hhaW4oKTtcbiAgICAgIH07XG4gICAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlQ2FsbENoYWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnBhcnNlUHJpbWFyeSgpO1xuICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKCRQRVJJT0QpKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLnBhcnNlQWNjZXNzTWVtYmVyT3JNZXRob2RDYWxsKHJlc3VsdCwgZmFsc2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMub3B0aW9uYWxPcGVyYXRvcignPy4nKSkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wYXJzZUFjY2Vzc01lbWJlck9yTWV0aG9kQ2FsbChyZXN1bHQsIHRydWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMub3B0aW9uYWxDaGFyYWN0ZXIoJExCUkFDS0VUKSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5yYnJhY2tldHNFeHBlY3RlZCsrO1xuICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IHRoaXMucGFyc2VQaXBlKCk7XG4gICAgICAgICAgICAgICAgICB0aGlzLnJicmFja2V0c0V4cGVjdGVkLS07XG4gICAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdENoYXJhY3RlcigkUkJSQUNLRVQpO1xuICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxPcGVyYXRvcignPScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5wYXJzZUNvbmRpdGlvbmFsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEtleWVkV3JpdGUodGhpcy5zcGFuKHJlc3VsdC5zcGFuLnN0YXJ0KSwgcmVzdWx0LCBrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBLZXllZFJlYWQodGhpcy5zcGFuKHJlc3VsdC5zcGFuLnN0YXJ0KSwgcmVzdWx0LCBrZXkpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMub3B0aW9uYWxDaGFyYWN0ZXIoJExQQVJFTikpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMucnBhcmVuc0V4cGVjdGVkKys7XG4gICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IHRoaXMucGFyc2VDYWxsQXJndW1lbnRzKCk7XG4gICAgICAgICAgICAgICAgICB0aGlzLnJwYXJlbnNFeHBlY3RlZC0tO1xuICAgICAgICAgICAgICAgICAgdGhpcy5leHBlY3RDaGFyYWN0ZXIoJFJQQVJFTik7XG4gICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgRnVuY3Rpb25DYWxsKHRoaXMuc3BhbihyZXN1bHQuc3Bhbi5zdGFydCksIHJlc3VsdCwgYXJncyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VQcmltYXJ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMuaW5wdXRJbmRleDtcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25hbENoYXJhY3RlcigkTFBBUkVOKSkge1xuICAgICAgICAgICAgICB0aGlzLnJwYXJlbnNFeHBlY3RlZCsrO1xuICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5wYXJzZVBpcGUoKTtcbiAgICAgICAgICAgICAgdGhpcy5ycGFyZW5zRXhwZWN0ZWQtLTtcbiAgICAgICAgICAgICAgdGhpcy5leHBlY3RDaGFyYWN0ZXIoJFJQQVJFTik7XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKHRoaXMubmV4dC5pc0tleXdvcmROdWxsKCkpIHtcbiAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbFByaW1pdGl2ZSh0aGlzLnNwYW4oc3RhcnQpLCBudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAodGhpcy5uZXh0LmlzS2V5d29yZFVuZGVmaW5lZCgpKSB7XG4gICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxQcmltaXRpdmUodGhpcy5zcGFuKHN0YXJ0KSwgdm9pZCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAodGhpcy5uZXh0LmlzS2V5d29yZFRydWUoKSkge1xuICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsUHJpbWl0aXZlKHRoaXMuc3BhbihzdGFydCksIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICh0aGlzLm5leHQuaXNLZXl3b3JkRmFsc2UoKSkge1xuICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsUHJpbWl0aXZlKHRoaXMuc3BhbihzdGFydCksIGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAodGhpcy5uZXh0LmlzS2V5d29yZFRoaXMoKSkge1xuICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbXBsaWNpdFJlY2VpdmVyKHRoaXMuc3BhbihzdGFydCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICh0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKCRMQlJBQ0tFVCkpIHtcbiAgICAgICAgICAgICAgdGhpcy5yYnJhY2tldHNFeHBlY3RlZCsrO1xuICAgICAgICAgICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbkxpc3QoJFJCUkFDS0VUKTtcbiAgICAgICAgICAgICAgdGhpcy5yYnJhY2tldHNFeHBlY3RlZC0tO1xuICAgICAgICAgICAgICB0aGlzLmV4cGVjdENoYXJhY3RlcigkUkJSQUNLRVQpO1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxBcnJheSh0aGlzLnNwYW4oc3RhcnQpLCBlbGVtZW50cyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKHRoaXMubmV4dC5pc0NoYXJhY3RlcigkTEJSQUNFKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUxpdGVyYWxNYXAoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAodGhpcy5uZXh0LmlzSWRlbnRpZmllcigpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlQWNjZXNzTWVtYmVyT3JNZXRob2RDYWxsKG5ldyBJbXBsaWNpdFJlY2VpdmVyKHRoaXMuc3BhbihzdGFydCkpLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKHRoaXMubmV4dC5pc051bWJlcigpKSB7XG4gICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMubmV4dC50b051bWJlcigpO1xuICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsUHJpbWl0aXZlKHRoaXMuc3BhbihzdGFydCksIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAodGhpcy5uZXh0LmlzU3RyaW5nKCkpIHtcbiAgICAgICAgICAgICAgdmFyIGxpdGVyYWxWYWx1ZSA9IHRoaXMubmV4dC50b1N0cmluZygpO1xuICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsUHJpbWl0aXZlKHRoaXMuc3BhbihzdGFydCksIGxpdGVyYWxWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKHRoaXMuaW5kZXggPj0gdGhpcy50b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHRoaXMuZXJyb3IoXCJVbmV4cGVjdGVkIGVuZCBvZiBleHByZXNzaW9uOiBcIiArIHRoaXMuaW5wdXQpO1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IEVtcHR5RXhwcih0aGlzLnNwYW4oc3RhcnQpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuZXJyb3IoXCJVbmV4cGVjdGVkIHRva2VuIFwiICsgdGhpcy5uZXh0KTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFbXB0eUV4cHIodGhpcy5zcGFuKHN0YXJ0KSk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VFeHByZXNzaW9uTGlzdCA9IGZ1bmN0aW9uICh0ZXJtaW5hdG9yKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgIGlmICghdGhpcy5uZXh0LmlzQ2hhcmFjdGVyKHRlcm1pbmF0b3IpKSB7XG4gICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMucGFyc2VQaXBlKCkpO1xuICAgICAgICAgICAgICB9IHdoaWxlICh0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKCRDT01NQSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VMaXRlcmFsTWFwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBrZXlzID0gW107XG4gICAgICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMuaW5wdXRJbmRleDtcbiAgICAgICAgICB0aGlzLmV4cGVjdENoYXJhY3RlcigkTEJSQUNFKTtcbiAgICAgICAgICBpZiAoIXRoaXMub3B0aW9uYWxDaGFyYWN0ZXIoJFJCUkFDRSkpIHtcbiAgICAgICAgICAgICAgdGhpcy5yYnJhY2VzRXhwZWN0ZWQrKztcbiAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IHRoaXMuZXhwZWN0SWRlbnRpZmllck9yS2V5d29yZE9yU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0Q2hhcmFjdGVyKCRDT0xPTik7XG4gICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaCh0aGlzLnBhcnNlUGlwZSgpKTtcbiAgICAgICAgICAgICAgfSB3aGlsZSAodGhpcy5vcHRpb25hbENoYXJhY3RlcigkQ09NTUEpKTtcbiAgICAgICAgICAgICAgdGhpcy5yYnJhY2VzRXhwZWN0ZWQtLTtcbiAgICAgICAgICAgICAgdGhpcy5leHBlY3RDaGFyYWN0ZXIoJFJCUkFDRSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbE1hcCh0aGlzLnNwYW4oc3RhcnQpLCBrZXlzLCB2YWx1ZXMpO1xuICAgICAgfTtcbiAgICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VBY2Nlc3NNZW1iZXJPck1ldGhvZENhbGwgPSBmdW5jdGlvbiAocmVjZWl2ZXIsIGlzU2FmZSkge1xuICAgICAgICAgIGlmIChpc1NhZmUgPT09IHZvaWQgMCkgeyBpc1NhZmUgPSBmYWxzZTsgfVxuICAgICAgICAgIHZhciBzdGFydCA9IHJlY2VpdmVyLnNwYW4uc3RhcnQ7XG4gICAgICAgICAgdmFyIGlkID0gdGhpcy5leHBlY3RJZGVudGlmaWVyT3JLZXl3b3JkKCk7XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxDaGFyYWN0ZXIoJExQQVJFTikpIHtcbiAgICAgICAgICAgICAgdGhpcy5ycGFyZW5zRXhwZWN0ZWQrKztcbiAgICAgICAgICAgICAgdmFyIGFyZ3MgPSB0aGlzLnBhcnNlQ2FsbEFyZ3VtZW50cygpO1xuICAgICAgICAgICAgICB0aGlzLmV4cGVjdENoYXJhY3RlcigkUlBBUkVOKTtcbiAgICAgICAgICAgICAgdGhpcy5ycGFyZW5zRXhwZWN0ZWQtLTtcbiAgICAgICAgICAgICAgdmFyIHNwYW4gPSB0aGlzLnNwYW4oc3RhcnQpO1xuICAgICAgICAgICAgICByZXR1cm4gaXNTYWZlID8gbmV3IFNhZmVNZXRob2RDYWxsKHNwYW4sIHJlY2VpdmVyLCBpZCwgYXJncykgOlxuICAgICAgICAgICAgICAgICAgbmV3IE1ldGhvZENhbGwoc3BhbiwgcmVjZWl2ZXIsIGlkLCBhcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChpc1NhZmUpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbmFsT3BlcmF0b3IoJz0nKSkge1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoJ1RoZSBcXCc/LlxcJyBvcGVyYXRvciBjYW5ub3QgYmUgdXNlZCBpbiB0aGUgYXNzaWdubWVudCcpO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRW1wdHlFeHByKHRoaXMuc3BhbihzdGFydCkpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTYWZlUHJvcGVydHlSZWFkKHRoaXMuc3BhbihzdGFydCksIHJlY2VpdmVyLCBpZCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25hbE9wZXJhdG9yKCc9JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMucGFyc2VBY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcignQmluZGluZ3MgY2Fubm90IGNvbnRhaW4gYXNzaWdubWVudHMnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFbXB0eUV4cHIodGhpcy5zcGFuKHN0YXJ0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMucGFyc2VDb25kaXRpb25hbCgpO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvcGVydHlXcml0ZSh0aGlzLnNwYW4oc3RhcnQpLCByZWNlaXZlciwgaWQsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvcGVydHlSZWFkKHRoaXMuc3BhbihzdGFydCksIHJlY2VpdmVyLCBpZCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZUNhbGxBcmd1bWVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKHRoaXMubmV4dC5pc0NoYXJhY3RlcigkUlBBUkVOKSlcbiAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIHZhciBwb3NpdGlvbmFscyA9IFtdO1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcG9zaXRpb25hbHMucHVzaCh0aGlzLnBhcnNlUGlwZSgpKTtcbiAgICAgICAgICB9IHdoaWxlICh0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKCRDT01NQSkpO1xuICAgICAgICAgIHJldHVybiBwb3NpdGlvbmFscztcbiAgICAgIH07XG4gICAgICAvKipcbiAgICAgICAqIEFuIGlkZW50aWZpZXIsIGEga2V5d29yZCwgYSBzdHJpbmcgd2l0aCBhbiBvcHRpb25hbCBgLWAgaW5iZXR3ZWVuLlxuICAgICAgICovXG4gICAgICBfUGFyc2VBU1QucHJvdG90eXBlLmV4cGVjdFRlbXBsYXRlQmluZGluZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICAgICAgdmFyIG9wZXJhdG9yRm91bmQgPSBmYWxzZTtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLmV4cGVjdElkZW50aWZpZXJPcktleXdvcmRPclN0cmluZygpO1xuICAgICAgICAgICAgICBvcGVyYXRvckZvdW5kID0gdGhpcy5vcHRpb25hbE9wZXJhdG9yKCctJyk7XG4gICAgICAgICAgICAgIGlmIChvcGVyYXRvckZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJy0nO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSB3aGlsZSAob3BlcmF0b3JGb3VuZCk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC50b1N0cmluZygpO1xuICAgICAgfTtcbiAgICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VUZW1wbGF0ZUJpbmRpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBiaW5kaW5ncyA9IFtdO1xuICAgICAgICAgIHZhciBwcmVmaXggPSBudWxsO1xuICAgICAgICAgIHZhciB3YXJuaW5ncyA9IFtdO1xuICAgICAgICAgIHdoaWxlICh0aGlzLmluZGV4IDwgdGhpcy50b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHZhciBrZXlJc1ZhciA9IHRoaXMucGVla0tleXdvcmRMZXQoKTtcbiAgICAgICAgICAgICAgaWYgKGtleUlzVmFyKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIga2V5ID0gdGhpcy5leHBlY3RUZW1wbGF0ZUJpbmRpbmdLZXkoKTtcbiAgICAgICAgICAgICAgaWYgKCFrZXlJc1Zhcikge1xuICAgICAgICAgICAgICAgICAgaWYgKHByZWZpeCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcHJlZml4ID0ga2V5O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAga2V5ID0gcHJlZml4ICsga2V5WzBdLnRvVXBwZXJDYXNlKCkgKyBrZXkuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMub3B0aW9uYWxDaGFyYWN0ZXIoJENPTE9OKTtcbiAgICAgICAgICAgICAgdmFyIG5hbWUgPSBudWxsO1xuICAgICAgICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IG51bGw7XG4gICAgICAgICAgICAgIGlmIChrZXlJc1Zhcikge1xuICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxPcGVyYXRvcignPScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IHRoaXMuZXhwZWN0VGVtcGxhdGVCaW5kaW5nS2V5KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gJ1xcJGltcGxpY2l0JztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLm5leHQgIT09IEVPRiAmJiAhdGhpcy5wZWVrS2V5d29yZExldCgpKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmlucHV0SW5kZXg7XG4gICAgICAgICAgICAgICAgICB2YXIgYXN0ID0gdGhpcy5wYXJzZVBpcGUoKTtcbiAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLmlucHV0LnN1YnN0cmluZyhzdGFydCwgdGhpcy5pbnB1dEluZGV4KTtcbiAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gPSBuZXcgQVNUV2l0aFNvdXJjZShhc3QsIHNvdXJjZSwgdGhpcy5sb2NhdGlvbiwgdGhpcy5lcnJvcnMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJpbmRpbmdzLnB1c2gobmV3IFRlbXBsYXRlQmluZGluZyhrZXksIGtleUlzVmFyLCBuYW1lLCBleHByZXNzaW9uKSk7XG4gICAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25hbENoYXJhY3RlcigkU0VNSUNPTE9OKSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25hbENoYXJhY3RlcigkQ09NTUEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgVGVtcGxhdGVCaW5kaW5nUGFyc2VSZXN1bHQoYmluZGluZ3MsIHdhcm5pbmdzLCB0aGlzLmVycm9ycyk7XG4gICAgICB9O1xuICAgICAgX1BhcnNlQVNULnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlLCBpbmRleCkge1xuICAgICAgICAgIGlmIChpbmRleCA9PT0gdm9pZCAwKSB7IGluZGV4ID0gbnVsbDsgfVxuICAgICAgICAgIHRoaXMuZXJyb3JzLnB1c2gobmV3IFBhcnNlckVycm9yKG1lc3NhZ2UsIHRoaXMuaW5wdXQsIHRoaXMubG9jYXRpb25UZXh0KGluZGV4KSwgdGhpcy5sb2NhdGlvbikpO1xuICAgICAgICAgIHRoaXMuc2tpcCgpO1xuICAgICAgfTtcbiAgICAgIF9QYXJzZUFTVC5wcm90b3R5cGUubG9jYXRpb25UZXh0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgaWYgKGluZGV4ID09PSB2b2lkIDApIHsgaW5kZXggPSBudWxsOyB9XG4gICAgICAgICAgaWYgKGlzQmxhbmsoaW5kZXgpKVxuICAgICAgICAgICAgICBpbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICAgICAgcmV0dXJuIChpbmRleCA8IHRoaXMudG9rZW5zLmxlbmd0aCkgPyBcImF0IGNvbHVtbiBcIiArICh0aGlzLnRva2Vuc1tpbmRleF0uaW5kZXggKyAxKSArIFwiIGluXCIgOlxuICAgICAgICAgICAgICBcImF0IHRoZSBlbmQgb2YgdGhlIGV4cHJlc3Npb25cIjtcbiAgICAgIH07XG4gICAgICAvLyBFcnJvciByZWNvdmVyeSBzaG91bGQgc2tpcCB0b2tlbnMgdW50aWwgaXQgZW5jb3VudGVycyBhIHJlY292ZXJ5IHBvaW50LiBza2lwKCkgdHJlYXRzXG4gICAgICAvLyB0aGUgZW5kIG9mIGlucHV0IGFuZCBhICc7JyBhcyB1bmNvbmRpdGlvbmFsbHkgYSByZWNvdmVyeSBwb2ludC4gSXQgYWxzbyB0cmVhdHMgJyknLFxuICAgICAgLy8gJ30nIGFuZCAnXScgYXMgY29uZGl0aW9uYWwgcmVjb3ZlcnkgcG9pbnRzIGlmIG9uZSBvZiBjYWxsaW5nIHByb2R1Y3Rpb25zIGlzIGV4cGVjdGluZ1xuICAgICAgLy8gb25lIG9mIHRoZXNlIHN5bWJvbHMuIFRoaXMgYWxsb3dzIHNraXAoKSB0byByZWNvdmVyIGZyb20gZXJyb3JzIHN1Y2ggYXMgJyhhLikgKyAxJyBhbGxvd2luZ1xuICAgICAgLy8gbW9yZSBvZiB0aGUgQVNUIHRvIGJlIHJldGFpbmVkIChpdCBkb2Vzbid0IHNraXAgYW55IHRva2VucyBhcyB0aGUgJyknIGlzIHJldGFpbmVkIGJlY2F1c2VcbiAgICAgIC8vIG9mIHRoZSAnKCcgYmVnaW5zIGFuICcoJyA8ZXhwcj4gJyknIHByb2R1Y3Rpb24pLiBUaGUgcmVjb3ZlcnkgcG9pbnRzIG9mIGdyb3VwaW5nIHN5bWJvbHNcbiAgICAgIC8vIG11c3QgYmUgY29uZGl0aW9uYWwgYXMgdGhleSBtdXN0IGJlIHNraXBwZWQgaWYgbm9uZSBvZiB0aGUgY2FsbGluZyBwcm9kdWN0aW9ucyBhcmUgbm90XG4gICAgICAvLyBleHBlY3RpbmcgdGhlIGNsb3NpbmcgdG9rZW4gZWxzZSB3ZSB3aWxsIG5ldmVyIG1ha2UgcHJvZ3Jlc3MgaW4gdGhlIGNhc2Ugb2YgYW5cbiAgICAgIC8vIGV4dHJhbmVvdXMgZ3JvdXAgY2xvc2luZyBzeW1ib2wgKHN1Y2ggYXMgYSBzdHJheSAnKScpLiBUaGlzIGlzIG5vdCB0aGUgY2FzZSBmb3IgJzsnIGJlY2F1c2VcbiAgICAgIC8vIHBhcnNlQ2hhaW4oKSBpcyBhbHdheXMgdGhlIHJvb3QgcHJvZHVjdGlvbiBhbmQgaXQgZXhwZWN0cyBhICc7Jy5cbiAgICAgIC8vIElmIGEgcHJvZHVjdGlvbiBleHBlY3RzIG9uZSBvZiB0aGVzZSB0b2tlbiBpdCBpbmNyZW1lbnRzIHRoZSBjb3JyZXNwb25kaW5nIG5lc3RpbmcgY291bnQsXG4gICAgICAvLyBhbmQgdGhlbiBkZWNyZW1lbnRzIGl0IGp1c3QgcHJpb3IgdG8gY2hlY2tpbmcgaWYgdGhlIHRva2VuIGlzIGluIHRoZSBpbnB1dC5cbiAgICAgIF9QYXJzZUFTVC5wcm90b3R5cGUuc2tpcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgbiA9IHRoaXMubmV4dDtcbiAgICAgICAgICB3aGlsZSAodGhpcy5pbmRleCA8IHRoaXMudG9rZW5zLmxlbmd0aCAmJiAhbi5pc0NoYXJhY3RlcigkU0VNSUNPTE9OKSAmJlxuICAgICAgICAgICAgICAodGhpcy5ycGFyZW5zRXhwZWN0ZWQgPD0gMCB8fCAhbi5pc0NoYXJhY3RlcigkUlBBUkVOKSkgJiZcbiAgICAgICAgICAgICAgKHRoaXMucmJyYWNlc0V4cGVjdGVkIDw9IDAgfHwgIW4uaXNDaGFyYWN0ZXIoJFJCUkFDRSkpICYmXG4gICAgICAgICAgICAgICh0aGlzLnJicmFja2V0c0V4cGVjdGVkIDw9IDAgfHwgIW4uaXNDaGFyYWN0ZXIoJFJCUkFDS0VUKSkpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMubmV4dC5pc0Vycm9yKCkpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JzLnB1c2gobmV3IFBhcnNlckVycm9yKHRoaXMubmV4dC50b1N0cmluZygpLCB0aGlzLmlucHV0LCB0aGlzLmxvY2F0aW9uVGV4dCgpLCB0aGlzLmxvY2F0aW9uKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgIG4gPSB0aGlzLm5leHQ7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiBfUGFyc2VBU1Q7XG4gIH0oKSk7XG4gIHZhciBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlcigpIHtcbiAgICAgICAgICB0aGlzLnNpbXBsZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5jaGVjayA9IGZ1bmN0aW9uIChhc3QpIHtcbiAgICAgICAgICB2YXIgcyA9IG5ldyBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlcigpO1xuICAgICAgICAgIGFzdC52aXNpdChzKTtcbiAgICAgICAgICByZXR1cm4gcy5zaW1wbGU7XG4gICAgICB9O1xuICAgICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0SW1wbGljaXRSZWNlaXZlciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdEludGVycG9sYXRpb24gPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHRoaXMuc2ltcGxlID0gZmFsc2U7IH07XG4gICAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRMaXRlcmFsUHJpbWl0aXZlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0UHJvcGVydHlSZWFkID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0UHJvcGVydHlXcml0ZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgdGhpcy5zaW1wbGUgPSBmYWxzZTsgfTtcbiAgICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdFNhZmVQcm9wZXJ0eVJlYWQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHRoaXMuc2ltcGxlID0gZmFsc2U7IH07XG4gICAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRNZXRob2RDYWxsID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB0aGlzLnNpbXBsZSA9IGZhbHNlOyB9O1xuICAgICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0U2FmZU1ldGhvZENhbGwgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHRoaXMuc2ltcGxlID0gZmFsc2U7IH07XG4gICAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRGdW5jdGlvbkNhbGwgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHRoaXMuc2ltcGxlID0gZmFsc2U7IH07XG4gICAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRMaXRlcmFsQXJyYXkgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHRoaXMudmlzaXRBbGwoYXN0LmV4cHJlc3Npb25zKTsgfTtcbiAgICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdExpdGVyYWxNYXAgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHRoaXMudmlzaXRBbGwoYXN0LnZhbHVlcyk7IH07XG4gICAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRCaW5hcnkgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHRoaXMuc2ltcGxlID0gZmFsc2U7IH07XG4gICAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRQcmVmaXhOb3QgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHRoaXMuc2ltcGxlID0gZmFsc2U7IH07XG4gICAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRDb25kaXRpb25hbCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgdGhpcy5zaW1wbGUgPSBmYWxzZTsgfTtcbiAgICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdFBpcGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHRoaXMuc2ltcGxlID0gZmFsc2U7IH07XG4gICAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRLZXllZFJlYWQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHRoaXMuc2ltcGxlID0gZmFsc2U7IH07XG4gICAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRLZXllZFdyaXRlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB0aGlzLnNpbXBsZSA9IGZhbHNlOyB9O1xuICAgICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0QWxsID0gZnVuY3Rpb24gKGFzdHMpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHJldHVybiBhc3RzLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS52aXNpdChfdGhpcyk7IH0pO1xuICAgICAgfTtcbiAgICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdENoYWluID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB0aGlzLnNpbXBsZSA9IGZhbHNlOyB9O1xuICAgICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0UXVvdGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHRoaXMuc2ltcGxlID0gZmFsc2U7IH07XG4gICAgICByZXR1cm4gU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXI7XG4gIH0oKSk7XG5cbiAgdmFyIFBhcnNlTG9jYXRpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gUGFyc2VMb2NhdGlvbihmaWxlLCBvZmZzZXQsIGxpbmUsIGNvbCkge1xuICAgICAgICAgIHRoaXMuZmlsZSA9IGZpbGU7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgdGhpcy5saW5lID0gbGluZTtcbiAgICAgICAgICB0aGlzLmNvbCA9IGNvbDtcbiAgICAgIH1cbiAgICAgIFBhcnNlTG9jYXRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5vZmZzZXQpID8gdGhpcy5maWxlLnVybCArIFwiQFwiICsgdGhpcy5saW5lICsgXCI6XCIgKyB0aGlzLmNvbCA6IHRoaXMuZmlsZS51cmw7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFBhcnNlTG9jYXRpb247XG4gIH0oKSk7XG4gIHZhciBQYXJzZVNvdXJjZUZpbGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gUGFyc2VTb3VyY2VGaWxlKGNvbnRlbnQsIHVybCkge1xuICAgICAgICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgICB9XG4gICAgICByZXR1cm4gUGFyc2VTb3VyY2VGaWxlO1xuICB9KCkpO1xuICB2YXIgUGFyc2VTb3VyY2VTcGFuID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFBhcnNlU291cmNlU3BhbihzdGFydCwgZW5kLCBkZXRhaWxzKSB7XG4gICAgICAgICAgaWYgKGRldGFpbHMgPT09IHZvaWQgMCkgeyBkZXRhaWxzID0gbnVsbDsgfVxuICAgICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICB0aGlzLmVuZCA9IGVuZDtcbiAgICAgICAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xuICAgICAgfVxuICAgICAgUGFyc2VTb3VyY2VTcGFuLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zdGFydC5maWxlLmNvbnRlbnQuc3Vic3RyaW5nKHRoaXMuc3RhcnQub2Zmc2V0LCB0aGlzLmVuZC5vZmZzZXQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBQYXJzZVNvdXJjZVNwYW47XG4gIH0oKSk7XG4gIGV4cG9ydHMuUGFyc2VFcnJvckxldmVsO1xuICAoZnVuY3Rpb24gKFBhcnNlRXJyb3JMZXZlbCkge1xuICAgICAgUGFyc2VFcnJvckxldmVsW1BhcnNlRXJyb3JMZXZlbFtcIldBUk5JTkdcIl0gPSAwXSA9IFwiV0FSTklOR1wiO1xuICAgICAgUGFyc2VFcnJvckxldmVsW1BhcnNlRXJyb3JMZXZlbFtcIkZBVEFMXCJdID0gMV0gPSBcIkZBVEFMXCI7XG4gIH0pKGV4cG9ydHMuUGFyc2VFcnJvckxldmVsIHx8IChleHBvcnRzLlBhcnNlRXJyb3JMZXZlbCA9IHt9KSk7XG4gIHZhciBQYXJzZUVycm9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFBhcnNlRXJyb3Ioc3BhbiwgbXNnLCBsZXZlbCkge1xuICAgICAgICAgIGlmIChsZXZlbCA9PT0gdm9pZCAwKSB7IGxldmVsID0gZXhwb3J0cy5QYXJzZUVycm9yTGV2ZWwuRkFUQUw7IH1cbiAgICAgICAgICB0aGlzLnNwYW4gPSBzcGFuO1xuICAgICAgICAgIHRoaXMubXNnID0gbXNnO1xuICAgICAgICAgIHRoaXMubGV2ZWwgPSBsZXZlbDtcbiAgICAgIH1cbiAgICAgIFBhcnNlRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLnNwYW4uc3RhcnQuZmlsZS5jb250ZW50O1xuICAgICAgICAgIHZhciBjdHhTdGFydCA9IHRoaXMuc3Bhbi5zdGFydC5vZmZzZXQ7XG4gICAgICAgICAgdmFyIGNvbnRleHRTdHIgPSAnJztcbiAgICAgICAgICB2YXIgZGV0YWlscyA9ICcnO1xuICAgICAgICAgIGlmIChpc1ByZXNlbnQoY3R4U3RhcnQpKSB7XG4gICAgICAgICAgICAgIGlmIChjdHhTdGFydCA+IHNvdXJjZS5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICBjdHhTdGFydCA9IHNvdXJjZS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBjdHhFbmQgPSBjdHhTdGFydDtcbiAgICAgICAgICAgICAgdmFyIGN0eExlbiA9IDA7XG4gICAgICAgICAgICAgIHZhciBjdHhMaW5lcyA9IDA7XG4gICAgICAgICAgICAgIHdoaWxlIChjdHhMZW4gPCAxMDAgJiYgY3R4U3RhcnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICBjdHhTdGFydC0tO1xuICAgICAgICAgICAgICAgICAgY3R4TGVuKys7XG4gICAgICAgICAgICAgICAgICBpZiAoc291cmNlW2N0eFN0YXJ0XSA9PSAnXFxuJykge1xuICAgICAgICAgICAgICAgICAgICAgIGlmICgrK2N0eExpbmVzID09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGN0eExlbiA9IDA7XG4gICAgICAgICAgICAgIGN0eExpbmVzID0gMDtcbiAgICAgICAgICAgICAgd2hpbGUgKGN0eExlbiA8IDEwMCAmJiBjdHhFbmQgPCBzb3VyY2UubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgY3R4RW5kKys7XG4gICAgICAgICAgICAgICAgICBjdHhMZW4rKztcbiAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2VbY3R4RW5kXSA9PSAnXFxuJykge1xuICAgICAgICAgICAgICAgICAgICAgIGlmICgrK2N0eExpbmVzID09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBjb250ZXh0ID0gc291cmNlLnN1YnN0cmluZyhjdHhTdGFydCwgdGhpcy5zcGFuLnN0YXJ0Lm9mZnNldCkgKyAnW0VSUk9SIC0+XScgK1xuICAgICAgICAgICAgICAgICAgc291cmNlLnN1YnN0cmluZyh0aGlzLnNwYW4uc3RhcnQub2Zmc2V0LCBjdHhFbmQgKyAxKTtcbiAgICAgICAgICAgICAgY29udGV4dFN0ciA9IFwiIChcXFwiXCIgKyBjb250ZXh0ICsgXCJcXFwiKVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5zcGFuLmRldGFpbHMpIHtcbiAgICAgICAgICAgICAgZGV0YWlscyA9IFwiLCBcIiArIHRoaXMuc3Bhbi5kZXRhaWxzO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gXCJcIiArIHRoaXMubXNnICsgY29udGV4dFN0ciArIFwiOiBcIiArIHRoaXMuc3Bhbi5zdGFydCArIGRldGFpbHM7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFBhcnNlRXJyb3I7XG4gIH0oKSk7XG5cbiAgLyoqXG4gICAqIEBsaWNlbnNlXG4gICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgKlxuICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAqL1xuICB2YXIgVGV4dCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBUZXh0KHZhbHVlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICB9XG4gICAgICBUZXh0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7IHJldHVybiB2aXNpdG9yLnZpc2l0VGV4dCh0aGlzLCBjb250ZXh0KTsgfTtcbiAgICAgIHJldHVybiBUZXh0O1xuICB9KCkpO1xuICB2YXIgRXhwYW5zaW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIEV4cGFuc2lvbihzd2l0Y2hWYWx1ZSwgdHlwZSwgY2FzZXMsIHNvdXJjZVNwYW4sIHN3aXRjaFZhbHVlU291cmNlU3Bhbikge1xuICAgICAgICAgIHRoaXMuc3dpdGNoVmFsdWUgPSBzd2l0Y2hWYWx1ZTtcbiAgICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICAgIHRoaXMuY2FzZXMgPSBjYXNlcztcbiAgICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgICAgIHRoaXMuc3dpdGNoVmFsdWVTb3VyY2VTcGFuID0gc3dpdGNoVmFsdWVTb3VyY2VTcGFuO1xuICAgICAgfVxuICAgICAgRXhwYW5zaW9uLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7IHJldHVybiB2aXNpdG9yLnZpc2l0RXhwYW5zaW9uKHRoaXMsIGNvbnRleHQpOyB9O1xuICAgICAgcmV0dXJuIEV4cGFuc2lvbjtcbiAgfSgpKTtcbiAgdmFyIEV4cGFuc2lvbkNhc2UgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gRXhwYW5zaW9uQ2FzZSh2YWx1ZSwgZXhwcmVzc2lvbiwgc291cmNlU3BhbiwgdmFsdWVTb3VyY2VTcGFuLCBleHBTb3VyY2VTcGFuKSB7XG4gICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgICAgICB0aGlzLnZhbHVlU291cmNlU3BhbiA9IHZhbHVlU291cmNlU3BhbjtcbiAgICAgICAgICB0aGlzLmV4cFNvdXJjZVNwYW4gPSBleHBTb3VyY2VTcGFuO1xuICAgICAgfVxuICAgICAgRXhwYW5zaW9uQ2FzZS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdEV4cGFuc2lvbkNhc2UodGhpcywgY29udGV4dCk7IH07XG4gICAgICByZXR1cm4gRXhwYW5zaW9uQ2FzZTtcbiAgfSgpKTtcbiAgdmFyIEF0dHJpYnV0ZSQxID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSwgc291cmNlU3BhbiwgdmFsdWVTcGFuKSB7XG4gICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgICAgICB0aGlzLnZhbHVlU3BhbiA9IHZhbHVlU3BhbjtcbiAgICAgIH1cbiAgICAgIEF0dHJpYnV0ZS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdEF0dHJpYnV0ZSh0aGlzLCBjb250ZXh0KTsgfTtcbiAgICAgIHJldHVybiBBdHRyaWJ1dGU7XG4gIH0oKSk7XG4gIHZhciBFbGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIEVsZW1lbnQobmFtZSwgYXR0cnMsIGNoaWxkcmVuLCBzb3VyY2VTcGFuLCBzdGFydFNvdXJjZVNwYW4sIGVuZFNvdXJjZVNwYW4pIHtcbiAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgICAgICB0aGlzLnN0YXJ0U291cmNlU3BhbiA9IHN0YXJ0U291cmNlU3BhbjtcbiAgICAgICAgICB0aGlzLmVuZFNvdXJjZVNwYW4gPSBlbmRTb3VyY2VTcGFuO1xuICAgICAgfVxuICAgICAgRWxlbWVudC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdEVsZW1lbnQodGhpcywgY29udGV4dCk7IH07XG4gICAgICByZXR1cm4gRWxlbWVudDtcbiAgfSgpKTtcbiAgdmFyIENvbW1lbnQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQ29tbWVudCh2YWx1ZSwgc291cmNlU3Bhbikge1xuICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgfVxuICAgICAgQ29tbWVudC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdENvbW1lbnQodGhpcywgY29udGV4dCk7IH07XG4gICAgICByZXR1cm4gQ29tbWVudDtcbiAgfSgpKTtcbiAgZnVuY3Rpb24gdmlzaXRBbGwodmlzaXRvciwgbm9kZXMsIGNvbnRleHQpIHtcbiAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIHZhciB2aXNpdCA9IHZpc2l0b3IudmlzaXQgP1xuICAgICAgICAgIGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXQoYXN0LCBjb250ZXh0KSB8fCBhc3QudmlzaXQodmlzaXRvciwgY29udGV4dCk7IH0gOlxuICAgICAgICAgIGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIGFzdC52aXNpdCh2aXNpdG9yLCBjb250ZXh0KTsgfTtcbiAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGFzdCkge1xuICAgICAgICAgIHZhciBhc3RSZXN1bHQgPSB2aXNpdChhc3QpO1xuICAgICAgICAgIGlmIChhc3RSZXN1bHQpIHtcbiAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYXN0UmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQGxpY2Vuc2VcbiAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAqXG4gICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICovXG4gIHZhciBfX2V4dGVuZHMkNSA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgfTtcbiAgdmFyIFRva2VuVHlwZSQxO1xuICAoZnVuY3Rpb24gKFRva2VuVHlwZSkge1xuICAgICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIlRBR19PUEVOX1NUQVJUXCJdID0gMF0gPSBcIlRBR19PUEVOX1NUQVJUXCI7XG4gICAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiVEFHX09QRU5fRU5EXCJdID0gMV0gPSBcIlRBR19PUEVOX0VORFwiO1xuICAgICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIlRBR19PUEVOX0VORF9WT0lEXCJdID0gMl0gPSBcIlRBR19PUEVOX0VORF9WT0lEXCI7XG4gICAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiVEFHX0NMT1NFXCJdID0gM10gPSBcIlRBR19DTE9TRVwiO1xuICAgICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIlRFWFRcIl0gPSA0XSA9IFwiVEVYVFwiO1xuICAgICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIkVTQ0FQQUJMRV9SQVdfVEVYVFwiXSA9IDVdID0gXCJFU0NBUEFCTEVfUkFXX1RFWFRcIjtcbiAgICAgIFRva2VuVHlwZVtUb2tlblR5cGVbXCJSQVdfVEVYVFwiXSA9IDZdID0gXCJSQVdfVEVYVFwiO1xuICAgICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIkNPTU1FTlRfU1RBUlRcIl0gPSA3XSA9IFwiQ09NTUVOVF9TVEFSVFwiO1xuICAgICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIkNPTU1FTlRfRU5EXCJdID0gOF0gPSBcIkNPTU1FTlRfRU5EXCI7XG4gICAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiQ0RBVEFfU1RBUlRcIl0gPSA5XSA9IFwiQ0RBVEFfU1RBUlRcIjtcbiAgICAgIFRva2VuVHlwZVtUb2tlblR5cGVbXCJDREFUQV9FTkRcIl0gPSAxMF0gPSBcIkNEQVRBX0VORFwiO1xuICAgICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIkFUVFJfTkFNRVwiXSA9IDExXSA9IFwiQVRUUl9OQU1FXCI7XG4gICAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiQVRUUl9WQUxVRVwiXSA9IDEyXSA9IFwiQVRUUl9WQUxVRVwiO1xuICAgICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIkRPQ19UWVBFXCJdID0gMTNdID0gXCJET0NfVFlQRVwiO1xuICAgICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIkVYUEFOU0lPTl9GT1JNX1NUQVJUXCJdID0gMTRdID0gXCJFWFBBTlNJT05fRk9STV9TVEFSVFwiO1xuICAgICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIkVYUEFOU0lPTl9DQVNFX1ZBTFVFXCJdID0gMTVdID0gXCJFWFBBTlNJT05fQ0FTRV9WQUxVRVwiO1xuICAgICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIkVYUEFOU0lPTl9DQVNFX0VYUF9TVEFSVFwiXSA9IDE2XSA9IFwiRVhQQU5TSU9OX0NBU0VfRVhQX1NUQVJUXCI7XG4gICAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiRVhQQU5TSU9OX0NBU0VfRVhQX0VORFwiXSA9IDE3XSA9IFwiRVhQQU5TSU9OX0NBU0VfRVhQX0VORFwiO1xuICAgICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIkVYUEFOU0lPTl9GT1JNX0VORFwiXSA9IDE4XSA9IFwiRVhQQU5TSU9OX0ZPUk1fRU5EXCI7XG4gICAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiRU9GXCJdID0gMTldID0gXCJFT0ZcIjtcbiAgfSkoVG9rZW5UeXBlJDEgfHwgKFRva2VuVHlwZSQxID0ge30pKTtcbiAgdmFyIFRva2VuJDEgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gVG9rZW4odHlwZSwgcGFydHMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICAgIHRoaXMucGFydHMgPSBwYXJ0cztcbiAgICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFRva2VuO1xuICB9KCkpO1xuICB2YXIgVG9rZW5FcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkNShUb2tlbkVycm9yLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gVG9rZW5FcnJvcihlcnJvck1zZywgdG9rZW5UeXBlLCBzcGFuKSB7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgc3BhbiwgZXJyb3JNc2cpO1xuICAgICAgICAgIHRoaXMudG9rZW5UeXBlID0gdG9rZW5UeXBlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFRva2VuRXJyb3I7XG4gIH0oUGFyc2VFcnJvcikpO1xuICB2YXIgVG9rZW5pemVSZXN1bHQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gVG9rZW5pemVSZXN1bHQodG9rZW5zLCBlcnJvcnMpIHtcbiAgICAgICAgICB0aGlzLnRva2VucyA9IHRva2VucztcbiAgICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICAgIH1cbiAgICAgIHJldHVybiBUb2tlbml6ZVJlc3VsdDtcbiAgfSgpKTtcbiAgZnVuY3Rpb24gdG9rZW5pemUoc291cmNlLCB1cmwsIGdldFRhZ0RlZmluaXRpb24sIHRva2VuaXplRXhwYW5zaW9uRm9ybXMsIGludGVycG9sYXRpb25Db25maWcpIHtcbiAgICAgIGlmICh0b2tlbml6ZUV4cGFuc2lvbkZvcm1zID09PSB2b2lkIDApIHsgdG9rZW5pemVFeHBhbnNpb25Gb3JtcyA9IGZhbHNlOyB9XG4gICAgICBpZiAoaW50ZXJwb2xhdGlvbkNvbmZpZyA9PT0gdm9pZCAwKSB7IGludGVycG9sYXRpb25Db25maWcgPSBERUZBVUxUX0lOVEVSUE9MQVRJT05fQ09ORklHOyB9XG4gICAgICByZXR1cm4gbmV3IF9Ub2tlbml6ZXIobmV3IFBhcnNlU291cmNlRmlsZShzb3VyY2UsIHVybCksIGdldFRhZ0RlZmluaXRpb24sIHRva2VuaXplRXhwYW5zaW9uRm9ybXMsIGludGVycG9sYXRpb25Db25maWcpXG4gICAgICAgICAgLnRva2VuaXplKCk7XG4gIH1cbiAgdmFyIF9DUl9PUl9DUkxGX1JFR0VYUCA9IC9cXHJcXG4/L2c7XG4gIGZ1bmN0aW9uIF91bmV4cGVjdGVkQ2hhcmFjdGVyRXJyb3JNc2coY2hhckNvZGUpIHtcbiAgICAgIHZhciBjaGFyID0gY2hhckNvZGUgPT09ICRFT0YgPyAnRU9GJyA6IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xuICAgICAgcmV0dXJuIFwiVW5leHBlY3RlZCBjaGFyYWN0ZXIgXFxcIlwiICsgY2hhciArIFwiXFxcIlwiO1xuICB9XG4gIGZ1bmN0aW9uIF91bmtub3duRW50aXR5RXJyb3JNc2coZW50aXR5U3JjKSB7XG4gICAgICByZXR1cm4gXCJVbmtub3duIGVudGl0eSBcXFwiXCIgKyBlbnRpdHlTcmMgKyBcIlxcXCIgLSB1c2UgdGhlIFxcXCImIzxkZWNpbWFsPjtcXFwiIG9yICBcXFwiJiN4PGhleD47XFxcIiBzeW50YXhcIjtcbiAgfVxuICB2YXIgX0NvbnRyb2xGbG93RXJyb3IgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gX0NvbnRyb2xGbG93RXJyb3IoZXJyb3IpIHtcbiAgICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgICB9XG4gICAgICByZXR1cm4gX0NvbnRyb2xGbG93RXJyb3I7XG4gIH0oKSk7XG4gIC8vIFNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNTEvc3ludGF4Lmh0bWwjd3JpdGluZ1xuICB2YXIgX1Rva2VuaXplciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSBfZmlsZSBUaGUgaHRtbCBzb3VyY2VcbiAgICAgICAqIEBwYXJhbSBfZ2V0VGFnRGVmaW5pdGlvblxuICAgICAgICogQHBhcmFtIF90b2tlbml6ZUljdSBXaGV0aGVyIHRvIHRva2VuaXplIElDVSBtZXNzYWdlcyAoY29uc2lkZXJlZCBhcyB0ZXh0IG5vZGVzIHdoZW4gZmFsc2UpXG4gICAgICAgKiBAcGFyYW0gX2ludGVycG9sYXRpb25Db25maWdcbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gX1Rva2VuaXplcihfZmlsZSwgX2dldFRhZ0RlZmluaXRpb24sIF90b2tlbml6ZUljdSwgX2ludGVycG9sYXRpb25Db25maWcpIHtcbiAgICAgICAgICBpZiAoX2ludGVycG9sYXRpb25Db25maWcgPT09IHZvaWQgMCkgeyBfaW50ZXJwb2xhdGlvbkNvbmZpZyA9IERFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUc7IH1cbiAgICAgICAgICB0aGlzLl9maWxlID0gX2ZpbGU7XG4gICAgICAgICAgdGhpcy5fZ2V0VGFnRGVmaW5pdGlvbiA9IF9nZXRUYWdEZWZpbml0aW9uO1xuICAgICAgICAgIHRoaXMuX3Rva2VuaXplSWN1ID0gX3Rva2VuaXplSWN1O1xuICAgICAgICAgIHRoaXMuX2ludGVycG9sYXRpb25Db25maWcgPSBfaW50ZXJwb2xhdGlvbkNvbmZpZztcbiAgICAgICAgICAvLyBOb3RlOiB0aGlzIGlzIGFsd2F5cyBsb3dlcmNhc2UhXG4gICAgICAgICAgdGhpcy5fcGVlayA9IC0xO1xuICAgICAgICAgIHRoaXMuX25leHRQZWVrID0gLTE7XG4gICAgICAgICAgdGhpcy5faW5kZXggPSAtMTtcbiAgICAgICAgICB0aGlzLl9saW5lID0gMDtcbiAgICAgICAgICB0aGlzLl9jb2x1bW4gPSAtMTtcbiAgICAgICAgICB0aGlzLl9leHBhbnNpb25DYXNlU3RhY2sgPSBbXTtcbiAgICAgICAgICB0aGlzLl9pbkludGVycG9sYXRpb24gPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLnRva2VucyA9IFtdO1xuICAgICAgICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgICAgICAgdGhpcy5faW5wdXQgPSBfZmlsZS5jb250ZW50O1xuICAgICAgICAgIHRoaXMuX2xlbmd0aCA9IF9maWxlLmNvbnRlbnQubGVuZ3RoO1xuICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgIH1cbiAgICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9wcm9jZXNzQ2FycmlhZ2VSZXR1cm5zID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgICAgICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zeW50YXguaHRtbCNwcmVwcm9jZXNzaW5nLXRoZS1pbnB1dC1zdHJlYW1cbiAgICAgICAgICAvLyBJbiBvcmRlciB0byBrZWVwIHRoZSBvcmlnaW5hbCBwb3NpdGlvbiBpbiB0aGUgc291cmNlLCB3ZSBjYW4gbm90XG4gICAgICAgICAgLy8gcHJlLXByb2Nlc3MgaXQuXG4gICAgICAgICAgLy8gSW5zdGVhZCBDUnMgYXJlIHByb2Nlc3NlZCByaWdodCBiZWZvcmUgaW5zdGFudGlhdGluZyB0aGUgdG9rZW5zLlxuICAgICAgICAgIHJldHVybiBjb250ZW50LnJlcGxhY2UoX0NSX09SX0NSTEZfUkVHRVhQLCAnXFxuJyk7XG4gICAgICB9O1xuICAgICAgX1Rva2VuaXplci5wcm90b3R5cGUudG9rZW5pemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgd2hpbGUgKHRoaXMuX3BlZWsgIT09ICRFT0YpIHtcbiAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5fZ2V0TG9jYXRpb24oKTtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hdHRlbXB0Q2hhckNvZGUoJExUKSkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hdHRlbXB0Q2hhckNvZGUoJEJBTkcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hdHRlbXB0Q2hhckNvZGUoJExCUkFDS0VUKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZUNkYXRhKHN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9hdHRlbXB0Q2hhckNvZGUoJE1JTlVTKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZUNvbW1lbnQoc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZURvY1R5cGUoc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2F0dGVtcHRDaGFyQ29kZSgkU0xBU0gpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVUYWdDbG9zZShzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lVGFnT3BlbihzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMuX3Rva2VuaXplSWN1IHx8ICF0aGlzLl90b2tlbml6ZUV4cGFuc2lvbkZvcm0oKSkge1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVUZXh0KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgX0NvbnRyb2xGbG93RXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9ycy5wdXNoKGUuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZSQxLkVPRik7XG4gICAgICAgICAgdGhpcy5fZW5kVG9rZW4oW10pO1xuICAgICAgICAgIHJldHVybiBuZXcgVG9rZW5pemVSZXN1bHQobWVyZ2VUZXh0VG9rZW5zKHRoaXMudG9rZW5zKSwgdGhpcy5lcnJvcnMpO1xuICAgICAgfTtcbiAgICAgIC8qKlxuICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgYW4gSUNVIHRva2VuIGhhcyBiZWVuIGNyZWF0ZWRcbiAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICovXG4gICAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fdG9rZW5pemVFeHBhbnNpb25Gb3JtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChpc0V4cGFuc2lvbkZvcm1TdGFydCh0aGlzLl9pbnB1dCwgdGhpcy5faW5kZXgsIHRoaXMuX2ludGVycG9sYXRpb25Db25maWcpKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVFeHBhbnNpb25Gb3JtU3RhcnQoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0V4cGFuc2lvbkNhc2VTdGFydCh0aGlzLl9wZWVrKSAmJiB0aGlzLl9pc0luRXhwYW5zaW9uRm9ybSgpKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVFeHBhbnNpb25DYXNlU3RhcnQoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLl9wZWVrID09PSAkUkJSQUNFKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9pc0luRXhwYW5zaW9uQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lRXhwYW5zaW9uQ2FzZUVuZCgpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzSW5FeHBhbnNpb25Gb3JtKCkpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVFeHBhbnNpb25Gb3JtRW5kKCk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuICAgICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2dldExvY2F0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBuZXcgUGFyc2VMb2NhdGlvbih0aGlzLl9maWxlLCB0aGlzLl9pbmRleCwgdGhpcy5fbGluZSwgdGhpcy5fY29sdW1uKTtcbiAgICAgIH07XG4gICAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fZ2V0U3BhbiA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgICAgICAgaWYgKHN0YXJ0ID09PSB2b2lkIDApIHsgc3RhcnQgPSB0aGlzLl9nZXRMb2NhdGlvbigpOyB9XG4gICAgICAgICAgaWYgKGVuZCA9PT0gdm9pZCAwKSB7IGVuZCA9IHRoaXMuX2dldExvY2F0aW9uKCk7IH1cbiAgICAgICAgICByZXR1cm4gbmV3IFBhcnNlU291cmNlU3BhbihzdGFydCwgZW5kKTtcbiAgICAgIH07XG4gICAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fYmVnaW5Ub2tlbiA9IGZ1bmN0aW9uICh0eXBlLCBzdGFydCkge1xuICAgICAgICAgIGlmIChzdGFydCA9PT0gdm9pZCAwKSB7IHN0YXJ0ID0gdGhpcy5fZ2V0TG9jYXRpb24oKTsgfVxuICAgICAgICAgIHRoaXMuX2N1cnJlbnRUb2tlblN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgdGhpcy5fY3VycmVudFRva2VuVHlwZSA9IHR5cGU7XG4gICAgICB9O1xuICAgICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2VuZFRva2VuID0gZnVuY3Rpb24gKHBhcnRzLCBlbmQpIHtcbiAgICAgICAgICBpZiAoZW5kID09PSB2b2lkIDApIHsgZW5kID0gdGhpcy5fZ2V0TG9jYXRpb24oKTsgfVxuICAgICAgICAgIHZhciB0b2tlbiA9IG5ldyBUb2tlbiQxKHRoaXMuX2N1cnJlbnRUb2tlblR5cGUsIHBhcnRzLCBuZXcgUGFyc2VTb3VyY2VTcGFuKHRoaXMuX2N1cnJlbnRUb2tlblN0YXJ0LCBlbmQpKTtcbiAgICAgICAgICB0aGlzLnRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICB0aGlzLl9jdXJyZW50VG9rZW5TdGFydCA9IG51bGw7XG4gICAgICAgICAgdGhpcy5fY3VycmVudFRva2VuVHlwZSA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgfTtcbiAgICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9jcmVhdGVFcnJvciA9IGZ1bmN0aW9uIChtc2csIHNwYW4pIHtcbiAgICAgICAgICBpZiAodGhpcy5faXNJbkV4cGFuc2lvbkZvcm0oKSkge1xuICAgICAgICAgICAgICBtc2cgKz0gXCIgKERvIHlvdSBoYXZlIGFuIHVuZXNjYXBlZCBcXFwie1xcXCIgaW4geW91ciB0ZW1wbGF0ZT8gVXNlIFxcXCJ7eyAneycgfX1cXFwiKSB0byBlc2NhcGUgaXQuKVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgVG9rZW5FcnJvcihtc2csIHRoaXMuX2N1cnJlbnRUb2tlblR5cGUsIHNwYW4pO1xuICAgICAgICAgIHRoaXMuX2N1cnJlbnRUb2tlblN0YXJ0ID0gbnVsbDtcbiAgICAgICAgICB0aGlzLl9jdXJyZW50VG9rZW5UeXBlID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gbmV3IF9Db250cm9sRmxvd0Vycm9yKGVycm9yKTtcbiAgICAgIH07XG4gICAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fYWR2YW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAodGhpcy5faW5kZXggPj0gdGhpcy5fbGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHRocm93IHRoaXMuX2NyZWF0ZUVycm9yKF91bmV4cGVjdGVkQ2hhcmFjdGVyRXJyb3JNc2coJEVPRiksIHRoaXMuX2dldFNwYW4oKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLl9wZWVrID09PSAkTEYpIHtcbiAgICAgICAgICAgICAgdGhpcy5fbGluZSsrO1xuICAgICAgICAgICAgICB0aGlzLl9jb2x1bW4gPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICh0aGlzLl9wZWVrICE9PSAkTEYgJiYgdGhpcy5fcGVlayAhPT0gJENSKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2NvbHVtbisrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9pbmRleCsrO1xuICAgICAgICAgIHRoaXMuX3BlZWsgPSB0aGlzLl9pbmRleCA+PSB0aGlzLl9sZW5ndGggPyAkRU9GIDogdGhpcy5faW5wdXQuY2hhckNvZGVBdCh0aGlzLl9pbmRleCk7XG4gICAgICAgICAgdGhpcy5fbmV4dFBlZWsgPVxuICAgICAgICAgICAgICB0aGlzLl9pbmRleCArIDEgPj0gdGhpcy5fbGVuZ3RoID8gJEVPRiA6IHRoaXMuX2lucHV0LmNoYXJDb2RlQXQodGhpcy5faW5kZXggKyAxKTtcbiAgICAgIH07XG4gICAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fYXR0ZW1wdENoYXJDb2RlID0gZnVuY3Rpb24gKGNoYXJDb2RlKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX3BlZWsgPT09IGNoYXJDb2RlKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG4gICAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fYXR0ZW1wdENoYXJDb2RlQ2FzZUluc2Vuc2l0aXZlID0gZnVuY3Rpb24gKGNoYXJDb2RlKSB7XG4gICAgICAgICAgaWYgKGNvbXBhcmVDaGFyQ29kZUNhc2VJbnNlbnNpdGl2ZSh0aGlzLl9wZWVrLCBjaGFyQ29kZSkpIHtcbiAgICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcbiAgICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9yZXF1aXJlQ2hhckNvZGUgPSBmdW5jdGlvbiAoY2hhckNvZGUpIHtcbiAgICAgICAgICB2YXIgbG9jYXRpb24gPSB0aGlzLl9nZXRMb2NhdGlvbigpO1xuICAgICAgICAgIGlmICghdGhpcy5fYXR0ZW1wdENoYXJDb2RlKGNoYXJDb2RlKSkge1xuICAgICAgICAgICAgICB0aHJvdyB0aGlzLl9jcmVhdGVFcnJvcihfdW5leHBlY3RlZENoYXJhY3RlckVycm9yTXNnKHRoaXMuX3BlZWspLCB0aGlzLl9nZXRTcGFuKGxvY2F0aW9uLCBsb2NhdGlvbikpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fYXR0ZW1wdFN0ciA9IGZ1bmN0aW9uIChjaGFycykge1xuICAgICAgICAgIHZhciBsZW4gPSBjaGFycy5sZW5ndGg7XG4gICAgICAgICAgaWYgKHRoaXMuX2luZGV4ICsgbGVuID4gdGhpcy5fbGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGluaXRpYWxQb3NpdGlvbiA9IHRoaXMuX3NhdmVQb3NpdGlvbigpO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgaWYgKCF0aGlzLl9hdHRlbXB0Q2hhckNvZGUoY2hhcnMuY2hhckNvZGVBdChpKSkpIHtcbiAgICAgICAgICAgICAgICAgIC8vIElmIGF0dGVtcHRpbmcgdG8gcGFyc2UgdGhlIHN0cmluZyBmYWlscywgd2Ugd2FudCB0byByZXNldCB0aGUgcGFyc2VyXG4gICAgICAgICAgICAgICAgICAvLyB0byB3aGVyZSBpdCB3YXMgYmVmb3JlIHRoZSBhdHRlbXB0XG4gICAgICAgICAgICAgICAgICB0aGlzLl9yZXN0b3JlUG9zaXRpb24oaW5pdGlhbFBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG4gICAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fYXR0ZW1wdFN0ckNhc2VJbnNlbnNpdGl2ZSA9IGZ1bmN0aW9uIChjaGFycykge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgaWYgKCF0aGlzLl9hdHRlbXB0Q2hhckNvZGVDYXNlSW5zZW5zaXRpdmUoY2hhcnMuY2hhckNvZGVBdChpKSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG4gICAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fcmVxdWlyZVN0ciA9IGZ1bmN0aW9uIChjaGFycykge1xuICAgICAgICAgIHZhciBsb2NhdGlvbiA9IHRoaXMuX2dldExvY2F0aW9uKCk7XG4gICAgICAgICAgaWYgKCF0aGlzLl9hdHRlbXB0U3RyKGNoYXJzKSkge1xuICAgICAgICAgICAgICB0aHJvdyB0aGlzLl9jcmVhdGVFcnJvcihfdW5leHBlY3RlZENoYXJhY3RlckVycm9yTXNnKHRoaXMuX3BlZWspLCB0aGlzLl9nZXRTcGFuKGxvY2F0aW9uKSk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuID0gZnVuY3Rpb24gKHByZWRpY2F0ZSkge1xuICAgICAgICAgIHdoaWxlICghcHJlZGljYXRlKHRoaXMuX3BlZWspKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgX1Rva2VuaXplci5wcm90b3R5cGUuX3JlcXVpcmVDaGFyQ29kZVVudGlsRm4gPSBmdW5jdGlvbiAocHJlZGljYXRlLCBsZW4pIHtcbiAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLl9nZXRMb2NhdGlvbigpO1xuICAgICAgICAgIHRoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4ocHJlZGljYXRlKTtcbiAgICAgICAgICBpZiAodGhpcy5faW5kZXggLSBzdGFydC5vZmZzZXQgPCBsZW4pIHtcbiAgICAgICAgICAgICAgdGhyb3cgdGhpcy5fY3JlYXRlRXJyb3IoX3VuZXhwZWN0ZWRDaGFyYWN0ZXJFcnJvck1zZyh0aGlzLl9wZWVrKSwgdGhpcy5fZ2V0U3BhbihzdGFydCwgc3RhcnQpKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2F0dGVtcHRVbnRpbENoYXIgPSBmdW5jdGlvbiAoY2hhcikge1xuICAgICAgICAgIHdoaWxlICh0aGlzLl9wZWVrICE9PSBjaGFyKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgX1Rva2VuaXplci5wcm90b3R5cGUuX3JlYWRDaGFyID0gZnVuY3Rpb24gKGRlY29kZUVudGl0aWVzKSB7XG4gICAgICAgICAgaWYgKGRlY29kZUVudGl0aWVzICYmIHRoaXMuX3BlZWsgPT09ICRBTVBFUlNBTkQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlY29kZUVudGl0eSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5faW5kZXg7XG4gICAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lucHV0W2luZGV4XTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2RlY29kZUVudGl0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLl9nZXRMb2NhdGlvbigpO1xuICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICBpZiAodGhpcy5fYXR0ZW1wdENoYXJDb2RlKCRIQVNIKSkge1xuICAgICAgICAgICAgICB2YXIgaXNIZXggPSB0aGlzLl9hdHRlbXB0Q2hhckNvZGUoJHgpIHx8IHRoaXMuX2F0dGVtcHRDaGFyQ29kZSgkWCk7XG4gICAgICAgICAgICAgIHZhciBudW1iZXJTdGFydCA9IHRoaXMuX2dldExvY2F0aW9uKCkub2Zmc2V0O1xuICAgICAgICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzRGlnaXRFbnRpdHlFbmQpO1xuICAgICAgICAgICAgICBpZiAodGhpcy5fcGVlayAhPSAkU0VNSUNPTE9OKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLl9jcmVhdGVFcnJvcihfdW5leHBlY3RlZENoYXJhY3RlckVycm9yTXNnKHRoaXMuX3BlZWspLCB0aGlzLl9nZXRTcGFuKCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgICAgdmFyIHN0ck51bSA9IHRoaXMuX2lucHV0LnN1YnN0cmluZyhudW1iZXJTdGFydCwgdGhpcy5faW5kZXggLSAxKTtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHZhciBjaGFyQ29kZSA9IHBhcnNlSW50KHN0ck51bSwgaXNIZXggPyAxNiA6IDEwKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgdmFyIGVudGl0eSA9IHRoaXMuX2lucHV0LnN1YnN0cmluZyhzdGFydC5vZmZzZXQgKyAxLCB0aGlzLl9pbmRleCAtIDEpO1xuICAgICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5fY3JlYXRlRXJyb3IoX3Vua25vd25FbnRpdHlFcnJvck1zZyhlbnRpdHkpLCB0aGlzLl9nZXRTcGFuKHN0YXJ0KSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBzdGFydFBvc2l0aW9uID0gdGhpcy5fc2F2ZVBvc2l0aW9uKCk7XG4gICAgICAgICAgICAgIHRoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNOYW1lZEVudGl0eUVuZCk7XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9wZWVrICE9ICRTRU1JQ09MT04pIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX3Jlc3RvcmVQb3NpdGlvbihzdGFydFBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAnJic7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgICB2YXIgbmFtZV8xID0gdGhpcy5faW5wdXQuc3Vic3RyaW5nKHN0YXJ0Lm9mZnNldCArIDEsIHRoaXMuX2luZGV4IC0gMSk7XG4gICAgICAgICAgICAgIHZhciBjaGFyID0gTkFNRURfRU5USVRJRVNbbmFtZV8xXTtcbiAgICAgICAgICAgICAgaWYgKCFjaGFyKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLl9jcmVhdGVFcnJvcihfdW5rbm93bkVudGl0eUVycm9yTXNnKG5hbWVfMSksIHRoaXMuX2dldFNwYW4oc3RhcnQpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gY2hhcjtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2NvbnN1bWVSYXdUZXh0ID0gZnVuY3Rpb24gKGRlY29kZUVudGl0aWVzLCBmaXJzdENoYXJPZkVuZCwgYXR0ZW1wdEVuZFJlc3QpIHtcbiAgICAgICAgICB2YXIgdGFnQ2xvc2VTdGFydDtcbiAgICAgICAgICB2YXIgdGV4dFN0YXJ0ID0gdGhpcy5fZ2V0TG9jYXRpb24oKTtcbiAgICAgICAgICB0aGlzLl9iZWdpblRva2VuKGRlY29kZUVudGl0aWVzID8gVG9rZW5UeXBlJDEuRVNDQVBBQkxFX1JBV19URVhUIDogVG9rZW5UeXBlJDEuUkFXX1RFWFQsIHRleHRTdGFydCk7XG4gICAgICAgICAgdmFyIHBhcnRzID0gW107XG4gICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgdGFnQ2xvc2VTdGFydCA9IHRoaXMuX2dldExvY2F0aW9uKCk7XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9hdHRlbXB0Q2hhckNvZGUoZmlyc3RDaGFyT2ZFbmQpICYmIGF0dGVtcHRFbmRSZXN0KCkpIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9pbmRleCA+IHRhZ0Nsb3NlU3RhcnQub2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAvLyBhZGQgdGhlIGNoYXJhY3RlcnMgY29uc3VtZWQgYnkgdGhlIHByZXZpb3VzIGlmIHN0YXRlbWVudCB0byB0aGUgb3V0cHV0XG4gICAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHRoaXMuX2lucHV0LnN1YnN0cmluZyh0YWdDbG9zZVN0YXJ0Lm9mZnNldCwgdGhpcy5faW5kZXgpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB3aGlsZSAodGhpcy5fcGVlayAhPT0gZmlyc3RDaGFyT2ZFbmQpIHtcbiAgICAgICAgICAgICAgICAgIHBhcnRzLnB1c2godGhpcy5fcmVhZENoYXIoZGVjb2RlRW50aXRpZXMpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcy5fZW5kVG9rZW4oW3RoaXMuX3Byb2Nlc3NDYXJyaWFnZVJldHVybnMocGFydHMuam9pbignJykpXSwgdGFnQ2xvc2VTdGFydCk7XG4gICAgICB9O1xuICAgICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2NvbnN1bWVDb21tZW50ID0gZnVuY3Rpb24gKHN0YXJ0KSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZSQxLkNPTU1FTlRfU1RBUlQsIHN0YXJ0KTtcbiAgICAgICAgICB0aGlzLl9yZXF1aXJlQ2hhckNvZGUoJE1JTlVTKTtcbiAgICAgICAgICB0aGlzLl9lbmRUb2tlbihbXSk7XG4gICAgICAgICAgdmFyIHRleHRUb2tlbiA9IHRoaXMuX2NvbnN1bWVSYXdUZXh0KGZhbHNlLCAkTUlOVVMsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9hdHRlbXB0U3RyKCctPicpOyB9KTtcbiAgICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZSQxLkNPTU1FTlRfRU5ELCB0ZXh0VG9rZW4uc291cmNlU3Bhbi5lbmQpO1xuICAgICAgICAgIHRoaXMuX2VuZFRva2VuKFtdKTtcbiAgICAgIH07XG4gICAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZUNkYXRhID0gZnVuY3Rpb24gKHN0YXJ0KSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZSQxLkNEQVRBX1NUQVJULCBzdGFydCk7XG4gICAgICAgICAgdGhpcy5fcmVxdWlyZVN0cignQ0RBVEFbJyk7XG4gICAgICAgICAgdGhpcy5fZW5kVG9rZW4oW10pO1xuICAgICAgICAgIHZhciB0ZXh0VG9rZW4gPSB0aGlzLl9jb25zdW1lUmF3VGV4dChmYWxzZSwgJFJCUkFDS0VULCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fYXR0ZW1wdFN0cignXT4nKTsgfSk7XG4gICAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihUb2tlblR5cGUkMS5DREFUQV9FTkQsIHRleHRUb2tlbi5zb3VyY2VTcGFuLmVuZCk7XG4gICAgICAgICAgdGhpcy5fZW5kVG9rZW4oW10pO1xuICAgICAgfTtcbiAgICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lRG9jVHlwZSA9IGZ1bmN0aW9uIChzdGFydCkge1xuICAgICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oVG9rZW5UeXBlJDEuRE9DX1RZUEUsIHN0YXJ0KTtcbiAgICAgICAgICB0aGlzLl9hdHRlbXB0VW50aWxDaGFyKCRHVCk7XG4gICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgIHRoaXMuX2VuZFRva2VuKFt0aGlzLl9pbnB1dC5zdWJzdHJpbmcoc3RhcnQub2Zmc2V0ICsgMiwgdGhpcy5faW5kZXggLSAxKV0pO1xuICAgICAgfTtcbiAgICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lUHJlZml4QW5kTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgbmFtZU9yUHJlZml4U3RhcnQgPSB0aGlzLl9pbmRleDtcbiAgICAgICAgICB2YXIgcHJlZml4ID0gbnVsbDtcbiAgICAgICAgICB3aGlsZSAodGhpcy5fcGVlayAhPT0gJENPTE9OICYmICFpc1ByZWZpeEVuZCh0aGlzLl9wZWVrKSkge1xuICAgICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBuYW1lU3RhcnQ7XG4gICAgICAgICAgaWYgKHRoaXMuX3BlZWsgPT09ICRDT0xPTikge1xuICAgICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICAgIHByZWZpeCA9IHRoaXMuX2lucHV0LnN1YnN0cmluZyhuYW1lT3JQcmVmaXhTdGFydCwgdGhpcy5faW5kZXggLSAxKTtcbiAgICAgICAgICAgICAgbmFtZVN0YXJ0ID0gdGhpcy5faW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBuYW1lU3RhcnQgPSBuYW1lT3JQcmVmaXhTdGFydDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fcmVxdWlyZUNoYXJDb2RlVW50aWxGbihpc05hbWVFbmQsIHRoaXMuX2luZGV4ID09PSBuYW1lU3RhcnQgPyAxIDogMCk7XG4gICAgICAgICAgdmFyIG5hbWUgPSB0aGlzLl9pbnB1dC5zdWJzdHJpbmcobmFtZVN0YXJ0LCB0aGlzLl9pbmRleCk7XG4gICAgICAgICAgcmV0dXJuIFtwcmVmaXgsIG5hbWVdO1xuICAgICAgfTtcbiAgICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lVGFnT3BlbiA9IGZ1bmN0aW9uIChzdGFydCkge1xuICAgICAgICAgIHZhciBzYXZlZFBvcyA9IHRoaXMuX3NhdmVQb3NpdGlvbigpO1xuICAgICAgICAgIHZhciB0YWdOYW1lO1xuICAgICAgICAgIHZhciBsb3dlcmNhc2VUYWdOYW1lO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGlmICghaXNBc2NpaUxldHRlcih0aGlzLl9wZWVrKSkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5fY3JlYXRlRXJyb3IoX3VuZXhwZWN0ZWRDaGFyYWN0ZXJFcnJvck1zZyh0aGlzLl9wZWVrKSwgdGhpcy5fZ2V0U3BhbigpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgbmFtZVN0YXJ0ID0gdGhpcy5faW5kZXg7XG4gICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVUYWdPcGVuU3RhcnQoc3RhcnQpO1xuICAgICAgICAgICAgICB0YWdOYW1lID0gdGhpcy5faW5wdXQuc3Vic3RyaW5nKG5hbWVTdGFydCwgdGhpcy5faW5kZXgpO1xuICAgICAgICAgICAgICBsb3dlcmNhc2VUYWdOYW1lID0gdGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzTm90V2hpdGVzcGFjZSk7XG4gICAgICAgICAgICAgIHdoaWxlICh0aGlzLl9wZWVrICE9PSAkU0xBU0ggJiYgdGhpcy5fcGVlayAhPT0gJEdUKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lQXR0cmlidXRlTmFtZSgpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05vdFdoaXRlc3BhY2UpO1xuICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2F0dGVtcHRDaGFyQ29kZSgkRVEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05vdFdoaXRlc3BhY2UpO1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVBdHRyaWJ1dGVWYWx1ZSgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05vdFdoaXRlc3BhY2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVUYWdPcGVuRW5kKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgX0NvbnRyb2xGbG93RXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlIHN0YXJ0IHRhZyBpcyBpbnZhbGlkLCBhc3N1bWUgd2Ugd2FudCBhIFwiPFwiXG4gICAgICAgICAgICAgICAgICB0aGlzLl9yZXN0b3JlUG9zaXRpb24oc2F2ZWRQb3MpO1xuICAgICAgICAgICAgICAgICAgLy8gQmFjayB0byBiYWNrIHRleHQgdG9rZW5zIGFyZSBtZXJnZWQgYXQgdGhlIGVuZFxuICAgICAgICAgICAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihUb2tlblR5cGUkMS5URVhULCBzdGFydCk7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9lbmRUb2tlbihbJzwnXSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGNvbnRlbnRUb2tlblR5cGUgPSB0aGlzLl9nZXRUYWdEZWZpbml0aW9uKHRhZ05hbWUpLmNvbnRlbnRUeXBlO1xuICAgICAgICAgIGlmIChjb250ZW50VG9rZW5UeXBlID09PSBUYWdDb250ZW50VHlwZS5SQVdfVEVYVCkge1xuICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lUmF3VGV4dFdpdGhUYWdDbG9zZShsb3dlcmNhc2VUYWdOYW1lLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGNvbnRlbnRUb2tlblR5cGUgPT09IFRhZ0NvbnRlbnRUeXBlLkVTQ0FQQUJMRV9SQVdfVEVYVCkge1xuICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lUmF3VGV4dFdpdGhUYWdDbG9zZShsb3dlcmNhc2VUYWdOYW1lLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2NvbnN1bWVSYXdUZXh0V2l0aFRhZ0Nsb3NlID0gZnVuY3Rpb24gKGxvd2VyY2FzZVRhZ05hbWUsIGRlY29kZUVudGl0aWVzKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgdGV4dFRva2VuID0gdGhpcy5fY29uc3VtZVJhd1RleHQoZGVjb2RlRW50aXRpZXMsICRMVCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAoIV90aGlzLl9hdHRlbXB0Q2hhckNvZGUoJFNMQVNIKSlcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgX3RoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNOb3RXaGl0ZXNwYWNlKTtcbiAgICAgICAgICAgICAgaWYgKCFfdGhpcy5fYXR0ZW1wdFN0ckNhc2VJbnNlbnNpdGl2ZShsb3dlcmNhc2VUYWdOYW1lKSlcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgX3RoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNOb3RXaGl0ZXNwYWNlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9hdHRlbXB0Q2hhckNvZGUoJEdUKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZSQxLlRBR19DTE9TRSwgdGV4dFRva2VuLnNvdXJjZVNwYW4uZW5kKTtcbiAgICAgICAgICB0aGlzLl9lbmRUb2tlbihbbnVsbCwgbG93ZXJjYXNlVGFnTmFtZV0pO1xuICAgICAgfTtcbiAgICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lVGFnT3BlblN0YXJ0ID0gZnVuY3Rpb24gKHN0YXJ0KSB7XG4gICAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihUb2tlblR5cGUkMS5UQUdfT1BFTl9TVEFSVCwgc3RhcnQpO1xuICAgICAgICAgIHZhciBwYXJ0cyA9IHRoaXMuX2NvbnN1bWVQcmVmaXhBbmROYW1lKCk7XG4gICAgICAgICAgdGhpcy5fZW5kVG9rZW4ocGFydHMpO1xuICAgICAgfTtcbiAgICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lQXR0cmlidXRlTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZSQxLkFUVFJfTkFNRSk7XG4gICAgICAgICAgdmFyIHByZWZpeEFuZE5hbWUgPSB0aGlzLl9jb25zdW1lUHJlZml4QW5kTmFtZSgpO1xuICAgICAgICAgIHRoaXMuX2VuZFRva2VuKHByZWZpeEFuZE5hbWUpO1xuICAgICAgfTtcbiAgICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lQXR0cmlidXRlVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihUb2tlblR5cGUkMS5BVFRSX1ZBTFVFKTtcbiAgICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgICAgaWYgKHRoaXMuX3BlZWsgPT09ICRTUSB8fCB0aGlzLl9wZWVrID09PSAkRFEpIHtcbiAgICAgICAgICAgICAgdmFyIHF1b3RlQ2hhciA9IHRoaXMuX3BlZWs7XG4gICAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgICAgdmFyIHBhcnRzID0gW107XG4gICAgICAgICAgICAgIHdoaWxlICh0aGlzLl9wZWVrICE9PSBxdW90ZUNoYXIpIHtcbiAgICAgICAgICAgICAgICAgIHBhcnRzLnB1c2godGhpcy5fcmVhZENoYXIodHJ1ZSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhbHVlID0gcGFydHMuam9pbignJyk7XG4gICAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHZhciB2YWx1ZVN0YXJ0ID0gdGhpcy5faW5kZXg7XG4gICAgICAgICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZVVudGlsRm4oaXNOYW1lRW5kLCAxKTtcbiAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLl9pbnB1dC5zdWJzdHJpbmcodmFsdWVTdGFydCwgdGhpcy5faW5kZXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9lbmRUb2tlbihbdGhpcy5fcHJvY2Vzc0NhcnJpYWdlUmV0dXJucyh2YWx1ZSldKTtcbiAgICAgIH07XG4gICAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZVRhZ09wZW5FbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHRva2VuVHlwZSA9IHRoaXMuX2F0dGVtcHRDaGFyQ29kZSgkU0xBU0gpID8gVG9rZW5UeXBlJDEuVEFHX09QRU5fRU5EX1ZPSUQgOiBUb2tlblR5cGUkMS5UQUdfT1BFTl9FTkQ7XG4gICAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbih0b2tlblR5cGUpO1xuICAgICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZSgkR1QpO1xuICAgICAgICAgIHRoaXMuX2VuZFRva2VuKFtdKTtcbiAgICAgIH07XG4gICAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZVRhZ0Nsb3NlID0gZnVuY3Rpb24gKHN0YXJ0KSB7XG4gICAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihUb2tlblR5cGUkMS5UQUdfQ0xPU0UsIHN0YXJ0KTtcbiAgICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzTm90V2hpdGVzcGFjZSk7XG4gICAgICAgICAgdmFyIHByZWZpeEFuZE5hbWUgPSB0aGlzLl9jb25zdW1lUHJlZml4QW5kTmFtZSgpO1xuICAgICAgICAgIHRoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNOb3RXaGl0ZXNwYWNlKTtcbiAgICAgICAgICB0aGlzLl9yZXF1aXJlQ2hhckNvZGUoJEdUKTtcbiAgICAgICAgICB0aGlzLl9lbmRUb2tlbihwcmVmaXhBbmROYW1lKTtcbiAgICAgIH07XG4gICAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZUV4cGFuc2lvbkZvcm1TdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZSQxLkVYUEFOU0lPTl9GT1JNX1NUQVJULCB0aGlzLl9nZXRMb2NhdGlvbigpKTtcbiAgICAgICAgICB0aGlzLl9yZXF1aXJlQ2hhckNvZGUoJExCUkFDRSk7XG4gICAgICAgICAgdGhpcy5fZW5kVG9rZW4oW10pO1xuICAgICAgICAgIHRoaXMuX2V4cGFuc2lvbkNhc2VTdGFjay5wdXNoKFRva2VuVHlwZSQxLkVYUEFOU0lPTl9GT1JNX1NUQVJUKTtcbiAgICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZSQxLlJBV19URVhULCB0aGlzLl9nZXRMb2NhdGlvbigpKTtcbiAgICAgICAgICB2YXIgY29uZGl0aW9uID0gdGhpcy5fcmVhZFVudGlsKCRDT01NQSk7XG4gICAgICAgICAgdGhpcy5fZW5kVG9rZW4oW2NvbmRpdGlvbl0sIHRoaXMuX2dldExvY2F0aW9uKCkpO1xuICAgICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZSgkQ09NTUEpO1xuICAgICAgICAgIHRoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNOb3RXaGl0ZXNwYWNlKTtcbiAgICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZSQxLlJBV19URVhULCB0aGlzLl9nZXRMb2NhdGlvbigpKTtcbiAgICAgICAgICB2YXIgdHlwZSA9IHRoaXMuX3JlYWRVbnRpbCgkQ09NTUEpO1xuICAgICAgICAgIHRoaXMuX2VuZFRva2VuKFt0eXBlXSwgdGhpcy5fZ2V0TG9jYXRpb24oKSk7XG4gICAgICAgICAgdGhpcy5fcmVxdWlyZUNoYXJDb2RlKCRDT01NQSk7XG4gICAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05vdFdoaXRlc3BhY2UpO1xuICAgICAgfTtcbiAgICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lRXhwYW5zaW9uQ2FzZVN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0NBU0VfVkFMVUUsIHRoaXMuX2dldExvY2F0aW9uKCkpO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX3JlYWRVbnRpbCgkTEJSQUNFKS50cmltKCk7XG4gICAgICAgICAgdGhpcy5fZW5kVG9rZW4oW3ZhbHVlXSwgdGhpcy5fZ2V0TG9jYXRpb24oKSk7XG4gICAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05vdFdoaXRlc3BhY2UpO1xuICAgICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0NBU0VfRVhQX1NUQVJULCB0aGlzLl9nZXRMb2NhdGlvbigpKTtcbiAgICAgICAgICB0aGlzLl9yZXF1aXJlQ2hhckNvZGUoJExCUkFDRSk7XG4gICAgICAgICAgdGhpcy5fZW5kVG9rZW4oW10sIHRoaXMuX2dldExvY2F0aW9uKCkpO1xuICAgICAgICAgIHRoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNOb3RXaGl0ZXNwYWNlKTtcbiAgICAgICAgICB0aGlzLl9leHBhbnNpb25DYXNlU3RhY2sucHVzaChUb2tlblR5cGUkMS5FWFBBTlNJT05fQ0FTRV9FWFBfU1RBUlQpO1xuICAgICAgfTtcbiAgICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lRXhwYW5zaW9uQ2FzZUVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZSQxLkVYUEFOU0lPTl9DQVNFX0VYUF9FTkQsIHRoaXMuX2dldExvY2F0aW9uKCkpO1xuICAgICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZSgkUkJSQUNFKTtcbiAgICAgICAgICB0aGlzLl9lbmRUb2tlbihbXSwgdGhpcy5fZ2V0TG9jYXRpb24oKSk7XG4gICAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05vdFdoaXRlc3BhY2UpO1xuICAgICAgICAgIHRoaXMuX2V4cGFuc2lvbkNhc2VTdGFjay5wb3AoKTtcbiAgICAgIH07XG4gICAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZUV4cGFuc2lvbkZvcm1FbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihUb2tlblR5cGUkMS5FWFBBTlNJT05fRk9STV9FTkQsIHRoaXMuX2dldExvY2F0aW9uKCkpO1xuICAgICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZSgkUkJSQUNFKTtcbiAgICAgICAgICB0aGlzLl9lbmRUb2tlbihbXSk7XG4gICAgICAgICAgdGhpcy5fZXhwYW5zaW9uQ2FzZVN0YWNrLnBvcCgpO1xuICAgICAgfTtcbiAgICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lVGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLl9nZXRMb2NhdGlvbigpO1xuICAgICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oVG9rZW5UeXBlJDEuVEVYVCwgc3RhcnQpO1xuICAgICAgICAgIHZhciBwYXJ0cyA9IFtdO1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX2ludGVycG9sYXRpb25Db25maWcgJiYgdGhpcy5fYXR0ZW1wdFN0cih0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnLnN0YXJ0KSkge1xuICAgICAgICAgICAgICAgICAgcGFydHMucHVzaCh0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnLnN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2luSW50ZXJwb2xhdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZyAmJiB0aGlzLl9hdHRlbXB0U3RyKHRoaXMuX2ludGVycG9sYXRpb25Db25maWcuZW5kKSAmJlxuICAgICAgICAgICAgICAgICAgdGhpcy5faW5JbnRlcnBvbGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHRoaXMuX2ludGVycG9sYXRpb25Db25maWcuZW5kKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2luSW50ZXJwb2xhdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcGFydHMucHVzaCh0aGlzLl9yZWFkQ2hhcih0cnVlKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IHdoaWxlICghdGhpcy5faXNUZXh0RW5kKCkpO1xuICAgICAgICAgIHRoaXMuX2VuZFRva2VuKFt0aGlzLl9wcm9jZXNzQ2FycmlhZ2VSZXR1cm5zKHBhcnRzLmpvaW4oJycpKV0pO1xuICAgICAgfTtcbiAgICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9pc1RleHRFbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX3BlZWsgPT09ICRMVCB8fCB0aGlzLl9wZWVrID09PSAkRU9GKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5fdG9rZW5pemVJY3UgJiYgIXRoaXMuX2luSW50ZXJwb2xhdGlvbikge1xuICAgICAgICAgICAgICBpZiAoaXNFeHBhbnNpb25Gb3JtU3RhcnQodGhpcy5faW5wdXQsIHRoaXMuX2luZGV4LCB0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnKSkge1xuICAgICAgICAgICAgICAgICAgLy8gc3RhcnQgb2YgYW4gZXhwYW5zaW9uIGZvcm1cbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9wZWVrID09PSAkUkJSQUNFICYmIHRoaXMuX2lzSW5FeHBhbnNpb25DYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAgIC8vIGVuZCBvZiBhbmQgZXhwYW5zaW9uIGNhc2VcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG4gICAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fc2F2ZVBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBbdGhpcy5fcGVlaywgdGhpcy5faW5kZXgsIHRoaXMuX2NvbHVtbiwgdGhpcy5fbGluZSwgdGhpcy50b2tlbnMubGVuZ3RoXTtcbiAgICAgIH07XG4gICAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fcmVhZFVudGlsID0gZnVuY3Rpb24gKGNoYXIpIHtcbiAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLl9pbmRleDtcbiAgICAgICAgICB0aGlzLl9hdHRlbXB0VW50aWxDaGFyKGNoYXIpO1xuICAgICAgICAgIHJldHVybiB0aGlzLl9pbnB1dC5zdWJzdHJpbmcoc3RhcnQsIHRoaXMuX2luZGV4KTtcbiAgICAgIH07XG4gICAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fcmVzdG9yZVBvc2l0aW9uID0gZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG4gICAgICAgICAgdGhpcy5fcGVlayA9IHBvc2l0aW9uWzBdO1xuICAgICAgICAgIHRoaXMuX2luZGV4ID0gcG9zaXRpb25bMV07XG4gICAgICAgICAgdGhpcy5fY29sdW1uID0gcG9zaXRpb25bMl07XG4gICAgICAgICAgdGhpcy5fbGluZSA9IHBvc2l0aW9uWzNdO1xuICAgICAgICAgIHZhciBuYlRva2VucyA9IHBvc2l0aW9uWzRdO1xuICAgICAgICAgIGlmIChuYlRva2VucyA8IHRoaXMudG9rZW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAvLyByZW1vdmUgYW55IGV4dHJhIHRva2Vuc1xuICAgICAgICAgICAgICB0aGlzLnRva2VucyA9IHRoaXMudG9rZW5zLnNsaWNlKDAsIG5iVG9rZW5zKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2lzSW5FeHBhbnNpb25DYXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9leHBhbnNpb25DYXNlU3RhY2subGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgICB0aGlzLl9leHBhbnNpb25DYXNlU3RhY2tbdGhpcy5fZXhwYW5zaW9uQ2FzZVN0YWNrLmxlbmd0aCAtIDFdID09PVxuICAgICAgICAgICAgICAgICAgVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0NBU0VfRVhQX1NUQVJUO1xuICAgICAgfTtcbiAgICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9pc0luRXhwYW5zaW9uRm9ybSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZXhwYW5zaW9uQ2FzZVN0YWNrLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgICAgdGhpcy5fZXhwYW5zaW9uQ2FzZVN0YWNrW3RoaXMuX2V4cGFuc2lvbkNhc2VTdGFjay5sZW5ndGggLSAxXSA9PT1cbiAgICAgICAgICAgICAgICAgIFRva2VuVHlwZSQxLkVYUEFOU0lPTl9GT1JNX1NUQVJUO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBfVG9rZW5pemVyO1xuICB9KCkpO1xuICBmdW5jdGlvbiBpc05vdFdoaXRlc3BhY2UoY29kZSkge1xuICAgICAgcmV0dXJuICFpc1doaXRlc3BhY2UoY29kZSkgfHwgY29kZSA9PT0gJEVPRjtcbiAgfVxuICBmdW5jdGlvbiBpc05hbWVFbmQoY29kZSkge1xuICAgICAgcmV0dXJuIGlzV2hpdGVzcGFjZShjb2RlKSB8fCBjb2RlID09PSAkR1QgfHwgY29kZSA9PT0gJFNMQVNIIHx8XG4gICAgICAgICAgY29kZSA9PT0gJFNRIHx8IGNvZGUgPT09ICREUSB8fCBjb2RlID09PSAkRVE7XG4gIH1cbiAgZnVuY3Rpb24gaXNQcmVmaXhFbmQoY29kZSkge1xuICAgICAgcmV0dXJuIChjb2RlIDwgJGEgfHwgJHogPCBjb2RlKSAmJiAoY29kZSA8ICRBIHx8ICRaIDwgY29kZSkgJiZcbiAgICAgICAgICAoY29kZSA8ICQwIHx8IGNvZGUgPiAkOSk7XG4gIH1cbiAgZnVuY3Rpb24gaXNEaWdpdEVudGl0eUVuZChjb2RlKSB7XG4gICAgICByZXR1cm4gY29kZSA9PSAkU0VNSUNPTE9OIHx8IGNvZGUgPT0gJEVPRiB8fCAhaXNBc2NpaUhleERpZ2l0KGNvZGUpO1xuICB9XG4gIGZ1bmN0aW9uIGlzTmFtZWRFbnRpdHlFbmQoY29kZSkge1xuICAgICAgcmV0dXJuIGNvZGUgPT0gJFNFTUlDT0xPTiB8fCBjb2RlID09ICRFT0YgfHwgIWlzQXNjaWlMZXR0ZXIoY29kZSk7XG4gIH1cbiAgZnVuY3Rpb24gaXNFeHBhbnNpb25Gb3JtU3RhcnQoaW5wdXQsIG9mZnNldCwgaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgICAgdmFyIGlzSW50ZXJwb2xhdGlvblN0YXJ0ID0gaW50ZXJwb2xhdGlvbkNvbmZpZyA/IGlucHV0LmluZGV4T2YoaW50ZXJwb2xhdGlvbkNvbmZpZy5zdGFydCwgb2Zmc2V0KSA9PSBvZmZzZXQgOiBmYWxzZTtcbiAgICAgIHJldHVybiBpbnB1dC5jaGFyQ29kZUF0KG9mZnNldCkgPT0gJExCUkFDRSAmJiAhaXNJbnRlcnBvbGF0aW9uU3RhcnQ7XG4gIH1cbiAgZnVuY3Rpb24gaXNFeHBhbnNpb25DYXNlU3RhcnQocGVlaykge1xuICAgICAgcmV0dXJuIHBlZWsgPT09ICRFUSB8fCBpc0FzY2lpTGV0dGVyKHBlZWspO1xuICB9XG4gIGZ1bmN0aW9uIGNvbXBhcmVDaGFyQ29kZUNhc2VJbnNlbnNpdGl2ZShjb2RlMSwgY29kZTIpIHtcbiAgICAgIHJldHVybiB0b1VwcGVyQ2FzZUNoYXJDb2RlKGNvZGUxKSA9PSB0b1VwcGVyQ2FzZUNoYXJDb2RlKGNvZGUyKTtcbiAgfVxuICBmdW5jdGlvbiB0b1VwcGVyQ2FzZUNoYXJDb2RlKGNvZGUpIHtcbiAgICAgIHJldHVybiBjb2RlID49ICRhICYmIGNvZGUgPD0gJHogPyBjb2RlIC0gJGEgKyAkQSA6IGNvZGU7XG4gIH1cbiAgZnVuY3Rpb24gbWVyZ2VUZXh0VG9rZW5zKHNyY1Rva2Vucykge1xuICAgICAgdmFyIGRzdFRva2VucyA9IFtdO1xuICAgICAgdmFyIGxhc3REc3RUb2tlbjtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3JjVG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHRva2VuID0gc3JjVG9rZW5zW2ldO1xuICAgICAgICAgIGlmIChsYXN0RHN0VG9rZW4gJiYgbGFzdERzdFRva2VuLnR5cGUgPT0gVG9rZW5UeXBlJDEuVEVYVCAmJiB0b2tlbi50eXBlID09IFRva2VuVHlwZSQxLlRFWFQpIHtcbiAgICAgICAgICAgICAgbGFzdERzdFRva2VuLnBhcnRzWzBdICs9IHRva2VuLnBhcnRzWzBdO1xuICAgICAgICAgICAgICBsYXN0RHN0VG9rZW4uc291cmNlU3Bhbi5lbmQgPSB0b2tlbi5zb3VyY2VTcGFuLmVuZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGxhc3REc3RUb2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgICBkc3RUb2tlbnMucHVzaChsYXN0RHN0VG9rZW4pO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBkc3RUb2tlbnM7XG4gIH1cblxuICAvKipcbiAgICogQGxpY2Vuc2VcbiAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAqXG4gICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICovXG4gIHZhciBfX2V4dGVuZHMkNCA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgfTtcbiAgdmFyIFRyZWVFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkNChUcmVlRXJyb3IsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBUcmVlRXJyb3IoZWxlbWVudE5hbWUsIHNwYW4sIG1zZykge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHNwYW4sIG1zZyk7XG4gICAgICAgICAgdGhpcy5lbGVtZW50TmFtZSA9IGVsZW1lbnROYW1lO1xuICAgICAgfVxuICAgICAgVHJlZUVycm9yLmNyZWF0ZSA9IGZ1bmN0aW9uIChlbGVtZW50TmFtZSwgc3BhbiwgbXNnKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBUcmVlRXJyb3IoZWxlbWVudE5hbWUsIHNwYW4sIG1zZyk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFRyZWVFcnJvcjtcbiAgfShQYXJzZUVycm9yKSk7XG4gIHZhciBQYXJzZVRyZWVSZXN1bHQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gUGFyc2VUcmVlUmVzdWx0KHJvb3ROb2RlcywgZXJyb3JzKSB7XG4gICAgICAgICAgdGhpcy5yb290Tm9kZXMgPSByb290Tm9kZXM7XG4gICAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICB9XG4gICAgICByZXR1cm4gUGFyc2VUcmVlUmVzdWx0O1xuICB9KCkpO1xuICB2YXIgUGFyc2VyJDEgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gUGFyc2VyKGdldFRhZ0RlZmluaXRpb24pIHtcbiAgICAgICAgICB0aGlzLmdldFRhZ0RlZmluaXRpb24gPSBnZXRUYWdEZWZpbml0aW9uO1xuICAgICAgfVxuICAgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChzb3VyY2UsIHVybCwgcGFyc2VFeHBhbnNpb25Gb3JtcywgaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgICAgICAgIGlmIChwYXJzZUV4cGFuc2lvbkZvcm1zID09PSB2b2lkIDApIHsgcGFyc2VFeHBhbnNpb25Gb3JtcyA9IGZhbHNlOyB9XG4gICAgICAgICAgaWYgKGludGVycG9sYXRpb25Db25maWcgPT09IHZvaWQgMCkgeyBpbnRlcnBvbGF0aW9uQ29uZmlnID0gREVGQVVMVF9JTlRFUlBPTEFUSU9OX0NPTkZJRzsgfVxuICAgICAgICAgIHZhciB0b2tlbnNBbmRFcnJvcnMgPSB0b2tlbml6ZShzb3VyY2UsIHVybCwgdGhpcy5nZXRUYWdEZWZpbml0aW9uLCBwYXJzZUV4cGFuc2lvbkZvcm1zLCBpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgICB2YXIgdHJlZUFuZEVycm9ycyA9IG5ldyBfVHJlZUJ1aWxkZXIodG9rZW5zQW5kRXJyb3JzLnRva2VucywgdGhpcy5nZXRUYWdEZWZpbml0aW9uKS5idWlsZCgpO1xuICAgICAgICAgIHJldHVybiBuZXcgUGFyc2VUcmVlUmVzdWx0KHRyZWVBbmRFcnJvcnMucm9vdE5vZGVzLCB0b2tlbnNBbmRFcnJvcnMuZXJyb3JzLmNvbmNhdCh0cmVlQW5kRXJyb3JzLmVycm9ycykpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBQYXJzZXI7XG4gIH0oKSk7XG4gIHZhciBfVHJlZUJ1aWxkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gX1RyZWVCdWlsZGVyKHRva2VucywgZ2V0VGFnRGVmaW5pdGlvbikge1xuICAgICAgICAgIHRoaXMudG9rZW5zID0gdG9rZW5zO1xuICAgICAgICAgIHRoaXMuZ2V0VGFnRGVmaW5pdGlvbiA9IGdldFRhZ0RlZmluaXRpb247XG4gICAgICAgICAgdGhpcy5faW5kZXggPSAtMTtcbiAgICAgICAgICB0aGlzLl9yb290Tm9kZXMgPSBbXTtcbiAgICAgICAgICB0aGlzLl9lcnJvcnMgPSBbXTtcbiAgICAgICAgICB0aGlzLl9lbGVtZW50U3RhY2sgPSBbXTtcbiAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICB9XG4gICAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHdoaWxlICh0aGlzLl9wZWVrLnR5cGUgIT09IFRva2VuVHlwZSQxLkVPRikge1xuICAgICAgICAgICAgICBpZiAodGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUkMS5UQUdfT1BFTl9TVEFSVCkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZVN0YXJ0VGFnKHRoaXMuX2FkdmFuY2UoKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUkMS5UQUdfQ0xPU0UpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVFbmRUYWcodGhpcy5fYWR2YW5jZSgpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9wZWVrLnR5cGUgPT09IFRva2VuVHlwZSQxLkNEQVRBX1NUQVJUKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9jbG9zZVZvaWRFbGVtZW50KCk7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lQ2RhdGEodGhpcy5fYWR2YW5jZSgpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9wZWVrLnR5cGUgPT09IFRva2VuVHlwZSQxLkNPTU1FTlRfU1RBUlQpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2Nsb3NlVm9pZEVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVDb21tZW50KHRoaXMuX2FkdmFuY2UoKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUkMS5URVhUIHx8IHRoaXMuX3BlZWsudHlwZSA9PT0gVG9rZW5UeXBlJDEuUkFXX1RFWFQgfHxcbiAgICAgICAgICAgICAgICAgIHRoaXMuX3BlZWsudHlwZSA9PT0gVG9rZW5UeXBlJDEuRVNDQVBBQkxFX1JBV19URVhUKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9jbG9zZVZvaWRFbGVtZW50KCk7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lVGV4dCh0aGlzLl9hZHZhbmNlKCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3BlZWsudHlwZSA9PT0gVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0ZPUk1fU1RBUlQpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVFeHBhbnNpb24odGhpcy5fYWR2YW5jZSgpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIFNraXAgYWxsIG90aGVyIHRva2Vucy4uLlxuICAgICAgICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgUGFyc2VUcmVlUmVzdWx0KHRoaXMuX3Jvb3ROb2RlcywgdGhpcy5fZXJyb3JzKTtcbiAgICAgIH07XG4gICAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9hZHZhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBwcmV2ID0gdGhpcy5fcGVlaztcbiAgICAgICAgICBpZiAodGhpcy5faW5kZXggPCB0aGlzLnRva2Vucy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgIC8vIE5vdGU6IHRoZXJlIGlzIGFsd2F5cyBhbiBFT0YgdG9rZW4gYXQgdGhlIGVuZFxuICAgICAgICAgICAgICB0aGlzLl9pbmRleCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9wZWVrID0gdGhpcy50b2tlbnNbdGhpcy5faW5kZXhdO1xuICAgICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgfTtcbiAgICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX2FkdmFuY2VJZiA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX3BlZWsudHlwZSA9PT0gdHlwZSkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9jb25zdW1lQ2RhdGEgPSBmdW5jdGlvbiAoc3RhcnRUb2tlbikge1xuICAgICAgICAgIHRoaXMuX2NvbnN1bWVUZXh0KHRoaXMuX2FkdmFuY2UoKSk7XG4gICAgICAgICAgdGhpcy5fYWR2YW5jZUlmKFRva2VuVHlwZSQxLkNEQVRBX0VORCk7XG4gICAgICB9O1xuICAgICAgX1RyZWVCdWlsZGVyLnByb3RvdHlwZS5fY29uc3VtZUNvbW1lbnQgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgICB2YXIgdGV4dCA9IHRoaXMuX2FkdmFuY2VJZihUb2tlblR5cGUkMS5SQVdfVEVYVCk7XG4gICAgICAgICAgdGhpcy5fYWR2YW5jZUlmKFRva2VuVHlwZSQxLkNPTU1FTlRfRU5EKTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBpc1ByZXNlbnQodGV4dCkgPyB0ZXh0LnBhcnRzWzBdLnRyaW0oKSA6IG51bGw7XG4gICAgICAgICAgdGhpcy5fYWRkVG9QYXJlbnQobmV3IENvbW1lbnQodmFsdWUsIHRva2VuLnNvdXJjZVNwYW4pKTtcbiAgICAgIH07XG4gICAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9jb25zdW1lRXhwYW5zaW9uID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgICAgdmFyIHN3aXRjaFZhbHVlID0gdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgIHZhciB0eXBlID0gdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgIHZhciBjYXNlcyA9IFtdO1xuICAgICAgICAgIC8vIHJlYWQgPVxuICAgICAgICAgIHdoaWxlICh0aGlzLl9wZWVrLnR5cGUgPT09IFRva2VuVHlwZSQxLkVYUEFOU0lPTl9DQVNFX1ZBTFVFKSB7XG4gICAgICAgICAgICAgIHZhciBleHBDYXNlID0gdGhpcy5fcGFyc2VFeHBhbnNpb25DYXNlKCk7XG4gICAgICAgICAgICAgIGlmICghZXhwQ2FzZSlcbiAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gZXJyb3JcbiAgICAgICAgICAgICAgY2FzZXMucHVzaChleHBDYXNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gcmVhZCB0aGUgZmluYWwgfVxuICAgICAgICAgIGlmICh0aGlzLl9wZWVrLnR5cGUgIT09IFRva2VuVHlwZSQxLkVYUEFOU0lPTl9GT1JNX0VORCkge1xuICAgICAgICAgICAgICB0aGlzLl9lcnJvcnMucHVzaChUcmVlRXJyb3IuY3JlYXRlKG51bGwsIHRoaXMuX3BlZWsuc291cmNlU3BhbiwgXCJJbnZhbGlkIElDVSBtZXNzYWdlLiBNaXNzaW5nICd9Jy5cIikpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBzb3VyY2VTcGFuID0gbmV3IFBhcnNlU291cmNlU3Bhbih0b2tlbi5zb3VyY2VTcGFuLnN0YXJ0LCB0aGlzLl9wZWVrLnNvdXJjZVNwYW4uZW5kKTtcbiAgICAgICAgICB0aGlzLl9hZGRUb1BhcmVudChuZXcgRXhwYW5zaW9uKHN3aXRjaFZhbHVlLnBhcnRzWzBdLCB0eXBlLnBhcnRzWzBdLCBjYXNlcywgc291cmNlU3Bhbiwgc3dpdGNoVmFsdWUuc291cmNlU3BhbikpO1xuICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgIH07XG4gICAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9wYXJzZUV4cGFuc2lvbkNhc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgIC8vIHJlYWQge1xuICAgICAgICAgIGlmICh0aGlzLl9wZWVrLnR5cGUgIT09IFRva2VuVHlwZSQxLkVYUEFOU0lPTl9DQVNFX0VYUF9TVEFSVCkge1xuICAgICAgICAgICAgICB0aGlzLl9lcnJvcnMucHVzaChUcmVlRXJyb3IuY3JlYXRlKG51bGwsIHRoaXMuX3BlZWsuc291cmNlU3BhbiwgXCJJbnZhbGlkIElDVSBtZXNzYWdlLiBNaXNzaW5nICd7Jy5cIikpO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gcmVhZCB1bnRpbCB9XG4gICAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgIHZhciBleHAgPSB0aGlzLl9jb2xsZWN0RXhwYW5zaW9uRXhwVG9rZW5zKHN0YXJ0KTtcbiAgICAgICAgICBpZiAoIWV4cClcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgdmFyIGVuZCA9IHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICBleHAucHVzaChuZXcgVG9rZW4kMShUb2tlblR5cGUkMS5FT0YsIFtdLCBlbmQuc291cmNlU3BhbikpO1xuICAgICAgICAgIC8vIHBhcnNlIGV2ZXJ5dGhpbmcgaW4gYmV0d2VlbiB7IGFuZCB9XG4gICAgICAgICAgdmFyIHBhcnNlZEV4cCA9IG5ldyBfVHJlZUJ1aWxkZXIoZXhwLCB0aGlzLmdldFRhZ0RlZmluaXRpb24pLmJ1aWxkKCk7XG4gICAgICAgICAgaWYgKHBhcnNlZEV4cC5lcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICB0aGlzLl9lcnJvcnMgPSB0aGlzLl9lcnJvcnMuY29uY2F0KHBhcnNlZEV4cC5lcnJvcnMpO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHNvdXJjZVNwYW4gPSBuZXcgUGFyc2VTb3VyY2VTcGFuKHZhbHVlLnNvdXJjZVNwYW4uc3RhcnQsIGVuZC5zb3VyY2VTcGFuLmVuZCk7XG4gICAgICAgICAgdmFyIGV4cFNvdXJjZVNwYW4gPSBuZXcgUGFyc2VTb3VyY2VTcGFuKHN0YXJ0LnNvdXJjZVNwYW4uc3RhcnQsIGVuZC5zb3VyY2VTcGFuLmVuZCk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBFeHBhbnNpb25DYXNlKHZhbHVlLnBhcnRzWzBdLCBwYXJzZWRFeHAucm9vdE5vZGVzLCBzb3VyY2VTcGFuLCB2YWx1ZS5zb3VyY2VTcGFuLCBleHBTb3VyY2VTcGFuKTtcbiAgICAgIH07XG4gICAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9jb2xsZWN0RXhwYW5zaW9uRXhwVG9rZW5zID0gZnVuY3Rpb24gKHN0YXJ0KSB7XG4gICAgICAgICAgdmFyIGV4cCA9IFtdO1xuICAgICAgICAgIHZhciBleHBhbnNpb25Gb3JtU3RhY2sgPSBbVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0NBU0VfRVhQX1NUQVJUXTtcbiAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUkMS5FWFBBTlNJT05fRk9STV9TVEFSVCB8fFxuICAgICAgICAgICAgICAgICAgdGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUkMS5FWFBBTlNJT05fQ0FTRV9FWFBfU1RBUlQpIHtcbiAgICAgICAgICAgICAgICAgIGV4cGFuc2lvbkZvcm1TdGFjay5wdXNoKHRoaXMuX3BlZWsudHlwZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHRoaXMuX3BlZWsudHlwZSA9PT0gVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0NBU0VfRVhQX0VORCkge1xuICAgICAgICAgICAgICAgICAgaWYgKGxhc3RPblN0YWNrKGV4cGFuc2lvbkZvcm1TdGFjaywgVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0NBU0VfRVhQX1NUQVJUKSkge1xuICAgICAgICAgICAgICAgICAgICAgIGV4cGFuc2lvbkZvcm1TdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhwYW5zaW9uRm9ybVN0YWNrLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXhwO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2goVHJlZUVycm9yLmNyZWF0ZShudWxsLCBzdGFydC5zb3VyY2VTcGFuLCBcIkludmFsaWQgSUNVIG1lc3NhZ2UuIE1pc3NpbmcgJ30nLlwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHRoaXMuX3BlZWsudHlwZSA9PT0gVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0ZPUk1fRU5EKSB7XG4gICAgICAgICAgICAgICAgICBpZiAobGFzdE9uU3RhY2soZXhwYW5zaW9uRm9ybVN0YWNrLCBUb2tlblR5cGUkMS5FWFBBTlNJT05fRk9STV9TVEFSVCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBleHBhbnNpb25Gb3JtU3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9lcnJvcnMucHVzaChUcmVlRXJyb3IuY3JlYXRlKG51bGwsIHN0YXJ0LnNvdXJjZVNwYW4sIFwiSW52YWxpZCBJQ1UgbWVzc2FnZS4gTWlzc2luZyAnfScuXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUkMS5FT0YpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2Vycm9ycy5wdXNoKFRyZWVFcnJvci5jcmVhdGUobnVsbCwgc3RhcnQuc291cmNlU3BhbiwgXCJJbnZhbGlkIElDVSBtZXNzYWdlLiBNaXNzaW5nICd9Jy5cIikpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZXhwLnB1c2godGhpcy5fYWR2YW5jZSgpKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgX1RyZWVCdWlsZGVyLnByb3RvdHlwZS5fY29uc3VtZVRleHQgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgICB2YXIgdGV4dCA9IHRva2VuLnBhcnRzWzBdO1xuICAgICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA+IDAgJiYgdGV4dFswXSA9PSAnXFxuJykge1xuICAgICAgICAgICAgICB2YXIgcGFyZW50XzEgPSB0aGlzLl9nZXRQYXJlbnRFbGVtZW50KCk7XG4gICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQocGFyZW50XzEpICYmIHBhcmVudF8xLmNoaWxkcmVuLmxlbmd0aCA9PSAwICYmXG4gICAgICAgICAgICAgICAgICB0aGlzLmdldFRhZ0RlZmluaXRpb24ocGFyZW50XzEubmFtZSkuaWdub3JlRmlyc3RMZikge1xuICAgICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5fYWRkVG9QYXJlbnQobmV3IFRleHQodGV4dCwgdG9rZW4uc291cmNlU3BhbikpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9jbG9zZVZvaWRFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICh0aGlzLl9lbGVtZW50U3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICB2YXIgZWwgPSBMaXN0V3JhcHBlci5sYXN0KHRoaXMuX2VsZW1lbnRTdGFjayk7XG4gICAgICAgICAgICAgIGlmICh0aGlzLmdldFRhZ0RlZmluaXRpb24oZWwubmFtZSkuaXNWb2lkKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9lbGVtZW50U3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgX1RyZWVCdWlsZGVyLnByb3RvdHlwZS5fY29uc3VtZVN0YXJ0VGFnID0gZnVuY3Rpb24gKHN0YXJ0VGFnVG9rZW4pIHtcbiAgICAgICAgICB2YXIgcHJlZml4ID0gc3RhcnRUYWdUb2tlbi5wYXJ0c1swXTtcbiAgICAgICAgICB2YXIgbmFtZSA9IHN0YXJ0VGFnVG9rZW4ucGFydHNbMV07XG4gICAgICAgICAgdmFyIGF0dHJzID0gW107XG4gICAgICAgICAgd2hpbGUgKHRoaXMuX3BlZWsudHlwZSA9PT0gVG9rZW5UeXBlJDEuQVRUUl9OQU1FKSB7XG4gICAgICAgICAgICAgIGF0dHJzLnB1c2godGhpcy5fY29uc3VtZUF0dHIodGhpcy5fYWR2YW5jZSgpKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBmdWxsTmFtZSA9IHRoaXMuX2dldEVsZW1lbnRGdWxsTmFtZShwcmVmaXgsIG5hbWUsIHRoaXMuX2dldFBhcmVudEVsZW1lbnQoKSk7XG4gICAgICAgICAgdmFyIHNlbGZDbG9zaW5nID0gZmFsc2U7XG4gICAgICAgICAgLy8gTm90ZTogVGhlcmUgY291bGQgaGF2ZSBiZWVuIGEgdG9rZW5pemVyIGVycm9yXG4gICAgICAgICAgLy8gc28gdGhhdCB3ZSBkb24ndCBnZXQgYSB0b2tlbiBmb3IgdGhlIGVuZCB0YWcuLi5cbiAgICAgICAgICBpZiAodGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUkMS5UQUdfT1BFTl9FTkRfVk9JRCkge1xuICAgICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICAgIHNlbGZDbG9zaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgdmFyIHRhZ0RlZiA9IHRoaXMuZ2V0VGFnRGVmaW5pdGlvbihmdWxsTmFtZSk7XG4gICAgICAgICAgICAgIGlmICghKHRhZ0RlZi5jYW5TZWxmQ2xvc2UgfHwgZ2V0TnNQcmVmaXgoZnVsbE5hbWUpICE9PSBudWxsIHx8IHRhZ0RlZi5pc1ZvaWQpKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9lcnJvcnMucHVzaChUcmVlRXJyb3IuY3JlYXRlKGZ1bGxOYW1lLCBzdGFydFRhZ1Rva2VuLnNvdXJjZVNwYW4sIFwiT25seSB2b2lkIGFuZCBmb3JlaWduIGVsZW1lbnRzIGNhbiBiZSBzZWxmIGNsb3NlZCBcXFwiXCIgKyBzdGFydFRhZ1Rva2VuLnBhcnRzWzFdICsgXCJcXFwiXCIpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICh0aGlzLl9wZWVrLnR5cGUgPT09IFRva2VuVHlwZSQxLlRBR19PUEVOX0VORCkge1xuICAgICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICAgIHNlbGZDbG9zaW5nID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBlbmQgPSB0aGlzLl9wZWVrLnNvdXJjZVNwYW4uc3RhcnQ7XG4gICAgICAgICAgdmFyIHNwYW4gPSBuZXcgUGFyc2VTb3VyY2VTcGFuKHN0YXJ0VGFnVG9rZW4uc291cmNlU3Bhbi5zdGFydCwgZW5kKTtcbiAgICAgICAgICB2YXIgZWwgPSBuZXcgRWxlbWVudChmdWxsTmFtZSwgYXR0cnMsIFtdLCBzcGFuLCBzcGFuLCBudWxsKTtcbiAgICAgICAgICB0aGlzLl9wdXNoRWxlbWVudChlbCk7XG4gICAgICAgICAgaWYgKHNlbGZDbG9zaW5nKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3BvcEVsZW1lbnQoZnVsbE5hbWUpO1xuICAgICAgICAgICAgICBlbC5lbmRTb3VyY2VTcGFuID0gc3BhbjtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgX1RyZWVCdWlsZGVyLnByb3RvdHlwZS5fcHVzaEVsZW1lbnQgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICBpZiAodGhpcy5fZWxlbWVudFN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgdmFyIHBhcmVudEVsID0gTGlzdFdyYXBwZXIubGFzdCh0aGlzLl9lbGVtZW50U3RhY2spO1xuICAgICAgICAgICAgICBpZiAodGhpcy5nZXRUYWdEZWZpbml0aW9uKHBhcmVudEVsLm5hbWUpLmlzQ2xvc2VkQnlDaGlsZChlbC5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fZWxlbWVudFN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB0YWdEZWYgPSB0aGlzLmdldFRhZ0RlZmluaXRpb24oZWwubmFtZSk7XG4gICAgICAgICAgdmFyIF9hID0gdGhpcy5fZ2V0UGFyZW50RWxlbWVudFNraXBwaW5nQ29udGFpbmVycygpLCBwYXJlbnQgPSBfYS5wYXJlbnQsIGNvbnRhaW5lciA9IF9hLmNvbnRhaW5lcjtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KHBhcmVudCkgJiYgdGFnRGVmLnJlcXVpcmVFeHRyYVBhcmVudChwYXJlbnQubmFtZSkpIHtcbiAgICAgICAgICAgICAgdmFyIG5ld1BhcmVudCA9IG5ldyBFbGVtZW50KHRhZ0RlZi5wYXJlbnRUb0FkZCwgW10sIFtdLCBlbC5zb3VyY2VTcGFuLCBlbC5zdGFydFNvdXJjZVNwYW4sIGVsLmVuZFNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICB0aGlzLl9pbnNlcnRCZWZvcmVDb250YWluZXIocGFyZW50LCBjb250YWluZXIsIG5ld1BhcmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX2FkZFRvUGFyZW50KGVsKTtcbiAgICAgICAgICB0aGlzLl9lbGVtZW50U3RhY2sucHVzaChlbCk7XG4gICAgICB9O1xuICAgICAgX1RyZWVCdWlsZGVyLnByb3RvdHlwZS5fY29uc3VtZUVuZFRhZyA9IGZ1bmN0aW9uIChlbmRUYWdUb2tlbikge1xuICAgICAgICAgIHZhciBmdWxsTmFtZSA9IHRoaXMuX2dldEVsZW1lbnRGdWxsTmFtZShlbmRUYWdUb2tlbi5wYXJ0c1swXSwgZW5kVGFnVG9rZW4ucGFydHNbMV0sIHRoaXMuX2dldFBhcmVudEVsZW1lbnQoKSk7XG4gICAgICAgICAgaWYgKHRoaXMuX2dldFBhcmVudEVsZW1lbnQoKSkge1xuICAgICAgICAgICAgICB0aGlzLl9nZXRQYXJlbnRFbGVtZW50KCkuZW5kU291cmNlU3BhbiA9IGVuZFRhZ1Rva2VuLnNvdXJjZVNwYW47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLmdldFRhZ0RlZmluaXRpb24oZnVsbE5hbWUpLmlzVm9pZCkge1xuICAgICAgICAgICAgICB0aGlzLl9lcnJvcnMucHVzaChUcmVlRXJyb3IuY3JlYXRlKGZ1bGxOYW1lLCBlbmRUYWdUb2tlbi5zb3VyY2VTcGFuLCBcIlZvaWQgZWxlbWVudHMgZG8gbm90IGhhdmUgZW5kIHRhZ3MgXFxcIlwiICsgZW5kVGFnVG9rZW4ucGFydHNbMV0gKyBcIlxcXCJcIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICghdGhpcy5fcG9wRWxlbWVudChmdWxsTmFtZSkpIHtcbiAgICAgICAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2goVHJlZUVycm9yLmNyZWF0ZShmdWxsTmFtZSwgZW5kVGFnVG9rZW4uc291cmNlU3BhbiwgXCJVbmV4cGVjdGVkIGNsb3NpbmcgdGFnIFxcXCJcIiArIGVuZFRhZ1Rva2VuLnBhcnRzWzFdICsgXCJcXFwiXCIpKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgX1RyZWVCdWlsZGVyLnByb3RvdHlwZS5fcG9wRWxlbWVudCA9IGZ1bmN0aW9uIChmdWxsTmFtZSkge1xuICAgICAgICAgIGZvciAodmFyIHN0YWNrSW5kZXggPSB0aGlzLl9lbGVtZW50U3RhY2subGVuZ3RoIC0gMTsgc3RhY2tJbmRleCA+PSAwOyBzdGFja0luZGV4LS0pIHtcbiAgICAgICAgICAgICAgdmFyIGVsID0gdGhpcy5fZWxlbWVudFN0YWNrW3N0YWNrSW5kZXhdO1xuICAgICAgICAgICAgICBpZiAoZWwubmFtZSA9PSBmdWxsTmFtZSkge1xuICAgICAgICAgICAgICAgICAgTGlzdFdyYXBwZXIuc3BsaWNlKHRoaXMuX2VsZW1lbnRTdGFjaywgc3RhY2tJbmRleCwgdGhpcy5fZWxlbWVudFN0YWNrLmxlbmd0aCAtIHN0YWNrSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCF0aGlzLmdldFRhZ0RlZmluaXRpb24oZWwubmFtZSkuY2xvc2VkQnlQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuICAgICAgX1RyZWVCdWlsZGVyLnByb3RvdHlwZS5fY29uc3VtZUF0dHIgPSBmdW5jdGlvbiAoYXR0ck5hbWUpIHtcbiAgICAgICAgICB2YXIgZnVsbE5hbWUgPSBtZXJnZU5zQW5kTmFtZShhdHRyTmFtZS5wYXJ0c1swXSwgYXR0ck5hbWUucGFydHNbMV0pO1xuICAgICAgICAgIHZhciBlbmQgPSBhdHRyTmFtZS5zb3VyY2VTcGFuLmVuZDtcbiAgICAgICAgICB2YXIgdmFsdWUgPSAnJztcbiAgICAgICAgICB2YXIgdmFsdWVTcGFuO1xuICAgICAgICAgIGlmICh0aGlzLl9wZWVrLnR5cGUgPT09IFRva2VuVHlwZSQxLkFUVFJfVkFMVUUpIHtcbiAgICAgICAgICAgICAgdmFyIHZhbHVlVG9rZW4gPSB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWVUb2tlbi5wYXJ0c1swXTtcbiAgICAgICAgICAgICAgZW5kID0gdmFsdWVUb2tlbi5zb3VyY2VTcGFuLmVuZDtcbiAgICAgICAgICAgICAgdmFsdWVTcGFuID0gdmFsdWVUb2tlbi5zb3VyY2VTcGFuO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IEF0dHJpYnV0ZSQxKGZ1bGxOYW1lLCB2YWx1ZSwgbmV3IFBhcnNlU291cmNlU3BhbihhdHRyTmFtZS5zb3VyY2VTcGFuLnN0YXJ0LCBlbmQpLCB2YWx1ZVNwYW4pO1xuICAgICAgfTtcbiAgICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX2dldFBhcmVudEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnRTdGFjay5sZW5ndGggPiAwID8gTGlzdFdyYXBwZXIubGFzdCh0aGlzLl9lbGVtZW50U3RhY2spIDogbnVsbDtcbiAgICAgIH07XG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgdGhlIHBhcmVudCBpbiB0aGUgRE9NIGFuZCB0aGUgY29udGFpbmVyLlxuICAgICAgICpcbiAgICAgICAqIGA8bmctY29udGFpbmVyPmAgZWxlbWVudHMgYXJlIHNraXBwZWQgYXMgdGhleSBhcmUgbm90IHJlbmRlcmVkIGFzIERPTSBlbGVtZW50LlxuICAgICAgICovXG4gICAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9nZXRQYXJlbnRFbGVtZW50U2tpcHBpbmdDb250YWluZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBjb250YWluZXIgPSBudWxsO1xuICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLl9lbGVtZW50U3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX2VsZW1lbnRTdGFja1tpXS5uYW1lICE9PSAnbmctY29udGFpbmVyJykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgcGFyZW50OiB0aGlzLl9lbGVtZW50U3RhY2tbaV0sIGNvbnRhaW5lcjogY29udGFpbmVyIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29udGFpbmVyID0gdGhpcy5fZWxlbWVudFN0YWNrW2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4geyBwYXJlbnQ6IExpc3RXcmFwcGVyLmxhc3QodGhpcy5fZWxlbWVudFN0YWNrKSwgY29udGFpbmVyOiBjb250YWluZXIgfTtcbiAgICAgIH07XG4gICAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9hZGRUb1BhcmVudCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMuX2dldFBhcmVudEVsZW1lbnQoKTtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KHBhcmVudCkpIHtcbiAgICAgICAgICAgICAgcGFyZW50LmNoaWxkcmVuLnB1c2gobm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLl9yb290Tm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgLyoqXG4gICAgICAgKiBJbnNlcnQgYSBub2RlIGJldHdlZW4gdGhlIHBhcmVudCBhbmQgdGhlIGNvbnRhaW5lci5cbiAgICAgICAqIFdoZW4gbm8gY29udGFpbmVyIGlzIGdpdmVuLCB0aGUgbm9kZSBpcyBhcHBlbmRlZCBhcyBhIGNoaWxkIG9mIHRoZSBwYXJlbnQuXG4gICAgICAgKiBBbHNvIHVwZGF0ZXMgdGhlIGVsZW1lbnQgc3RhY2sgYWNjb3JkaW5nbHkuXG4gICAgICAgKlxuICAgICAgICogQGludGVybmFsXG4gICAgICAgKi9cbiAgICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX2luc2VydEJlZm9yZUNvbnRhaW5lciA9IGZ1bmN0aW9uIChwYXJlbnQsIGNvbnRhaW5lciwgbm9kZSkge1xuICAgICAgICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2FkZFRvUGFyZW50KG5vZGUpO1xuICAgICAgICAgICAgICB0aGlzLl9lbGVtZW50U3RhY2sucHVzaChub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgIC8vIHJlcGxhY2UgdGhlIGNvbnRhaW5lciB3aXRoIHRoZSBuZXcgbm9kZSBpbiB0aGUgY2hpbGRyZW5cbiAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHBhcmVudC5jaGlsZHJlbi5pbmRleE9mKGNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgICBwYXJlbnQuY2hpbGRyZW5baW5kZXhdID0gbm9kZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX3Jvb3ROb2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4ucHVzaChjb250YWluZXIpO1xuICAgICAgICAgICAgICB0aGlzLl9lbGVtZW50U3RhY2suc3BsaWNlKHRoaXMuX2VsZW1lbnRTdGFjay5pbmRleE9mKGNvbnRhaW5lciksIDAsIG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9nZXRFbGVtZW50RnVsbE5hbWUgPSBmdW5jdGlvbiAocHJlZml4LCBsb2NhbE5hbWUsIHBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgICBpZiAoaXNCbGFuayhwcmVmaXgpKSB7XG4gICAgICAgICAgICAgIHByZWZpeCA9IHRoaXMuZ2V0VGFnRGVmaW5pdGlvbihsb2NhbE5hbWUpLmltcGxpY2l0TmFtZXNwYWNlUHJlZml4O1xuICAgICAgICAgICAgICBpZiAoaXNCbGFuayhwcmVmaXgpICYmIGlzUHJlc2VudChwYXJlbnRFbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgcHJlZml4ID0gZ2V0TnNQcmVmaXgocGFyZW50RWxlbWVudC5uYW1lKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWVyZ2VOc0FuZE5hbWUocHJlZml4LCBsb2NhbE5hbWUpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBfVHJlZUJ1aWxkZXI7XG4gIH0oKSk7XG4gIGZ1bmN0aW9uIGxhc3RPblN0YWNrKHN0YWNrLCBlbGVtZW50KSB7XG4gICAgICByZXR1cm4gc3RhY2subGVuZ3RoID4gMCAmJiBzdGFja1tzdGFjay5sZW5ndGggLSAxXSA9PT0gZWxlbWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbGljZW5zZVxuICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICpcbiAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgKi9cbiAgZnVuY3Rpb24gZGlnZXN0TWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICByZXR1cm4gc2hhMShzZXJpYWxpemVOb2RlcyhtZXNzYWdlLm5vZGVzKS5qb2luKCcnKSArIChcIltcIiArIG1lc3NhZ2UubWVhbmluZyArIFwiXVwiKSk7XG4gIH1cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZSB0aGUgaTE4biBhc3QgdG8gc29tZXRoaW5nIHhtbC1saWtlIGluIG9yZGVyIHRvIGdlbmVyYXRlIGFuIFVJRC5cbiAgICpcbiAgICogVGhlIHZpc2l0b3IgaXMgYWxzbyB1c2VkIGluIHRoZSBpMThuIHBhcnNlciB0ZXN0c1xuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHZhciBfU2VyaWFsaXplclZpc2l0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gX1NlcmlhbGl6ZXJWaXNpdG9yKCkge1xuICAgICAgfVxuICAgICAgX1NlcmlhbGl6ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAodGV4dCwgY29udGV4dCkgeyByZXR1cm4gdGV4dC52YWx1ZTsgfTtcbiAgICAgIF9TZXJpYWxpemVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb250YWluZXIgPSBmdW5jdGlvbiAoY29udGFpbmVyLCBjb250ZXh0KSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICByZXR1cm4gXCJbXCIgKyBjb250YWluZXIuY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChjaGlsZCkgeyByZXR1cm4gY2hpbGQudmlzaXQoX3RoaXMpOyB9KS5qb2luKCcsICcpICsgXCJdXCI7XG4gICAgICB9O1xuICAgICAgX1NlcmlhbGl6ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEljdSA9IGZ1bmN0aW9uIChpY3UsIGNvbnRleHQpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBzdHJDYXNlcyA9IE9iamVjdC5rZXlzKGljdS5jYXNlcykubWFwKGZ1bmN0aW9uIChrKSB7IHJldHVybiAoayArIFwiIHtcIiArIGljdS5jYXNlc1trXS52aXNpdChfdGhpcykgKyBcIn1cIik7IH0pO1xuICAgICAgICAgIHJldHVybiBcIntcIiArIGljdS5leHByZXNzaW9uICsgXCIsIFwiICsgaWN1LnR5cGUgKyBcIiwgXCIgKyBzdHJDYXNlcy5qb2luKCcsICcpICsgXCJ9XCI7XG4gICAgICB9O1xuICAgICAgX1NlcmlhbGl6ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRhZ1BsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHBoLCBjb250ZXh0KSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICByZXR1cm4gcGguaXNWb2lkID9cbiAgICAgICAgICAgICAgXCI8cGggdGFnIG5hbWU9XFxcIlwiICsgcGguc3RhcnROYW1lICsgXCJcXFwiLz5cIiA6XG4gICAgICAgICAgICAgIFwiPHBoIHRhZyBuYW1lPVxcXCJcIiArIHBoLnN0YXJ0TmFtZSArIFwiXFxcIj5cIiArIHBoLmNoaWxkcmVuLm1hcChmdW5jdGlvbiAoY2hpbGQpIHsgcmV0dXJuIGNoaWxkLnZpc2l0KF90aGlzKTsgfSkuam9pbignLCAnKSArIFwiPC9waCBuYW1lPVxcXCJcIiArIHBoLmNsb3NlTmFtZSArIFwiXFxcIj5cIjtcbiAgICAgIH07XG4gICAgICBfU2VyaWFsaXplclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gXCI8cGggbmFtZT1cXFwiXCIgKyBwaC5uYW1lICsgXCJcXFwiPlwiICsgcGgudmFsdWUgKyBcIjwvcGg+XCI7XG4gICAgICB9O1xuICAgICAgX1NlcmlhbGl6ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEljdVBsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHBoLCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIFwiPHBoIGljdSBuYW1lPVxcXCJcIiArIHBoLm5hbWUgKyBcIlxcXCI+XCIgKyBwaC52YWx1ZS52aXNpdCh0aGlzKSArIFwiPC9waD5cIjtcbiAgICAgIH07XG4gICAgICByZXR1cm4gX1NlcmlhbGl6ZXJWaXNpdG9yO1xuICB9KCkpO1xuICB2YXIgc2VyaWFsaXplclZpc2l0b3IgPSBuZXcgX1NlcmlhbGl6ZXJWaXNpdG9yKCk7XG4gIGZ1bmN0aW9uIHNlcmlhbGl6ZU5vZGVzKG5vZGVzKSB7XG4gICAgICByZXR1cm4gbm9kZXMubWFwKGZ1bmN0aW9uIChhKSB7IHJldHVybiBhLnZpc2l0KHNlcmlhbGl6ZXJWaXNpdG9yLCBudWxsKTsgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENvbXB1dGUgdGhlIFNIQTEgb2YgdGhlIGdpdmVuIHN0cmluZ1xuICAgKlxuICAgKiBzZWUgaHR0cDovL2NzcmMubmlzdC5nb3YvcHVibGljYXRpb25zL2ZpcHMvZmlwczE4MC00L2ZpcHMtMTgwLTQucGRmXG4gICAqXG4gICAqIFdBUk5JTkc6IHRoaXMgZnVuY3Rpb24gaGFzIG5vdCBiZWVuIGRlc2lnbmVkIG5vdCB0ZXN0ZWQgd2l0aCBzZWN1cml0eSBpbiBtaW5kLlxuICAgKiAgICAgICAgICBETyBOT1QgVVNFIElUIElOIEEgU0VDVVJJVFkgU0VOU0lUSVZFIENPTlRFWFQuXG4gICAqL1xuICBmdW5jdGlvbiBzaGExKHN0cikge1xuICAgICAgdmFyIHV0ZjggPSB1dGY4RW5jb2RlKHN0cik7XG4gICAgICB2YXIgd29yZHMzMiA9IHN0cmluZ1RvV29yZHMzMih1dGY4KTtcbiAgICAgIHZhciBsZW4gPSB1dGY4Lmxlbmd0aCAqIDg7XG4gICAgICB2YXIgdyA9IG5ldyBBcnJheSg4MCk7XG4gICAgICB2YXIgX2EgPSBbMHg2NzQ1MjMwMSwgMHhlZmNkYWI4OSwgMHg5OGJhZGNmZSwgMHgxMDMyNTQ3NiwgMHhjM2QyZTFmMF0sIGEgPSBfYVswXSwgYiA9IF9hWzFdLCBjID0gX2FbMl0sIGQgPSBfYVszXSwgZSA9IF9hWzRdO1xuICAgICAgd29yZHMzMltsZW4gPj4gNV0gfD0gMHg4MCA8PCAoMjQgLSBsZW4gJSAzMik7XG4gICAgICB3b3JkczMyWygobGVuICsgNjQgPj4gOSkgPDwgNCkgKyAxNV0gPSBsZW47XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdvcmRzMzIubGVuZ3RoOyBpICs9IDE2KSB7XG4gICAgICAgICAgdmFyIF9iID0gW2EsIGIsIGMsIGQsIGVdLCBoMCA9IF9iWzBdLCBoMSA9IF9iWzFdLCBoMiA9IF9iWzJdLCBoMyA9IF9iWzNdLCBoNCA9IF9iWzRdO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgODA7IGorKykge1xuICAgICAgICAgICAgICBpZiAoaiA8IDE2KSB7XG4gICAgICAgICAgICAgICAgICB3W2pdID0gd29yZHMzMltpICsgal07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICB3W2pdID0gcm9sMzIod1tqIC0gM10gXiB3W2ogLSA4XSBeIHdbaiAtIDE0XSBeIHdbaiAtIDE2XSwgMSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIF9jID0gZmsoaiwgYiwgYywgZCksIGYgPSBfY1swXSwgayA9IF9jWzFdO1xuICAgICAgICAgICAgICB2YXIgdGVtcCA9IFtyb2wzMihhLCA1KSwgZiwgZSwgaywgd1tqXV0ucmVkdWNlKGFkZDMyKTtcbiAgICAgICAgICAgICAgX2QgPSBbZCwgYywgcm9sMzIoYiwgMzApLCBhLCB0ZW1wXSwgZSA9IF9kWzBdLCBkID0gX2RbMV0sIGMgPSBfZFsyXSwgYiA9IF9kWzNdLCBhID0gX2RbNF07XG4gICAgICAgICAgfVxuICAgICAgICAgIF9lID0gW2FkZDMyKGEsIGgwKSwgYWRkMzIoYiwgaDEpLCBhZGQzMihjLCBoMiksIGFkZDMyKGQsIGgzKSwgYWRkMzIoZSwgaDQpXSwgYSA9IF9lWzBdLCBiID0gX2VbMV0sIGMgPSBfZVsyXSwgZCA9IF9lWzNdLCBlID0gX2VbNF07XG4gICAgICB9XG4gICAgICB2YXIgc2hhMSA9IHdvcmRzMzJUb1N0cmluZyhbYSwgYiwgYywgZCwgZV0pO1xuICAgICAgdmFyIGhleCA9ICcnO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaGExLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGJfMSA9IHNoYTEuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICBoZXggKz0gKGJfMSA+Pj4gNCAmIDB4MGYpLnRvU3RyaW5nKDE2KSArIChiXzEgJiAweDBmKS50b1N0cmluZygxNik7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGV4LnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YXIgX2QsIF9lO1xuICB9XG4gIGZ1bmN0aW9uIHV0ZjhFbmNvZGUoc3RyKSB7XG4gICAgICB2YXIgZW5jb2RlZCA9ICcnO1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHN0ci5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICB2YXIgY29kZVBvaW50ID0gZGVjb2RlU3Vycm9nYXRlUGFpcnMoc3RyLCBpbmRleCk7XG4gICAgICAgICAgaWYgKGNvZGVQb2ludCA8PSAweDdmKSB7XG4gICAgICAgICAgICAgIGVuY29kZWQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChjb2RlUG9pbnQgPD0gMHg3ZmYpIHtcbiAgICAgICAgICAgICAgZW5jb2RlZCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4YzAgfCBjb2RlUG9pbnQgPj4+IDYsIDB4ODAgfCBjb2RlUG9pbnQgJiAweDNmKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoY29kZVBvaW50IDw9IDB4ZmZmZikge1xuICAgICAgICAgICAgICBlbmNvZGVkICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhlMCB8IGNvZGVQb2ludCA+Pj4gMTIsIDB4ODAgfCBjb2RlUG9pbnQgPj4+IDYgJiAweDNmLCAweDgwIHwgY29kZVBvaW50ICYgMHgzZik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGNvZGVQb2ludCA8PSAweDFmZmZmZikge1xuICAgICAgICAgICAgICBlbmNvZGVkICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhmMCB8IGNvZGVQb2ludCA+Pj4gMTgsIDB4ODAgfCBjb2RlUG9pbnQgPj4+IDEyICYgMHgzZiwgMHg4MCB8IGNvZGVQb2ludCA+Pj4gNiAmIDB4M2YsIDB4ODAgfCBjb2RlUG9pbnQgJiAweDNmKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZW5jb2RlZDtcbiAgfVxuICAvLyBzZWUgaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmcjc3Vycm9nYXRlLWZvcm11bGFlXG4gIGZ1bmN0aW9uIGRlY29kZVN1cnJvZ2F0ZVBhaXJzKHN0ciwgaW5kZXgpIHtcbiAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gc3RyLmxlbmd0aCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImluZGV4PVwiICsgaW5kZXggKyBcIiBpcyBvdXQgb2YgcmFuZ2UgaW4gXFxcIlwiICsgc3RyICsgXCJcXFwiXCIpO1xuICAgICAgfVxuICAgICAgdmFyIGhpZ2ggPSBzdHIuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICB2YXIgbG93O1xuICAgICAgaWYgKGhpZ2ggPj0gMHhkODAwICYmIGhpZ2ggPD0gMHhkZmZmICYmIHN0ci5sZW5ndGggPiBpbmRleCArIDEpIHtcbiAgICAgICAgICBsb3cgPSBzdHIuY2hhckNvZGVBdChpbmRleCArIDEpO1xuICAgICAgICAgIGlmIChsb3cgPj0gMHhkYzAwICYmIGxvdyA8PSAweGRmZmYpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIChoaWdoIC0gMHhkODAwKSAqIDB4NDAwICsgbG93IC0gMHhkYzAwICsgMHgxMDAwMDtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaGlnaDtcbiAgfVxuICBmdW5jdGlvbiBzdHJpbmdUb1dvcmRzMzIoc3RyKSB7XG4gICAgICB2YXIgd29yZHMzMiA9IEFycmF5KHN0ci5sZW5ndGggPj4+IDIpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3b3JkczMyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgd29yZHMzMltpXSA9IDA7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHdvcmRzMzJbaSA+Pj4gMl0gfD0gKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhmZikgPDwgOCAqICgzIC0gaSAmIDB4Myk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd29yZHMzMjtcbiAgfVxuICBmdW5jdGlvbiB3b3JkczMyVG9TdHJpbmcod29yZHMzMikge1xuICAgICAgdmFyIHN0ciA9ICcnO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3b3JkczMyLmxlbmd0aCAqIDQ7IGkrKykge1xuICAgICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCh3b3JkczMyW2kgPj4+IDJdID4+PiA4ICogKDMgLSBpICYgMHgzKSkgJiAweGZmKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHI7XG4gIH1cbiAgZnVuY3Rpb24gZmsoaW5kZXgsIGIsIGMsIGQpIHtcbiAgICAgIGlmIChpbmRleCA8IDIwKSB7XG4gICAgICAgICAgcmV0dXJuIFsoYiAmIGMpIHwgKH5iICYgZCksIDB4NWE4Mjc5OTldO1xuICAgICAgfVxuICAgICAgaWYgKGluZGV4IDwgNDApIHtcbiAgICAgICAgICByZXR1cm4gW2IgXiBjIF4gZCwgMHg2ZWQ5ZWJhMV07XG4gICAgICB9XG4gICAgICBpZiAoaW5kZXggPCA2MCkge1xuICAgICAgICAgIHJldHVybiBbKGIgJiBjKSB8IChiICYgZCkgfCAoYyAmIGQpLCAweDhmMWJiY2RjXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbYiBeIGMgXiBkLCAweGNhNjJjMWQ2XTtcbiAgfVxuICBmdW5jdGlvbiBhZGQzMihhLCBiKSB7XG4gICAgICB2YXIgbG93ID0gKGEgJiAweGZmZmYpICsgKGIgJiAweGZmZmYpO1xuICAgICAgdmFyIGhpZ2ggPSAoYSA+PiAxNikgKyAoYiA+PiAxNikgKyAobG93ID4+IDE2KTtcbiAgICAgIHJldHVybiAoaGlnaCA8PCAxNikgfCAobG93ICYgMHhmZmZmKTtcbiAgfVxuICBmdW5jdGlvbiByb2wzMihhLCBjb3VudCkge1xuICAgICAgcmV0dXJuIChhIDw8IGNvdW50KSB8IChhID4+PiAoMzIgLSBjb3VudCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBsaWNlbnNlXG4gICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgKlxuICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAqL1xuICB2YXIgTWVzc2FnZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSBub2RlcyBtZXNzYWdlIEFTVFxuICAgICAgICogQHBhcmFtIHBsYWNlaG9sZGVycyBtYXBzIHBsYWNlaG9sZGVyIG5hbWVzIHRvIHN0YXRpYyBjb250ZW50XG4gICAgICAgKiBAcGFyYW0gcGxhY2Vob2xkZXJUb01zZ0lkcyBtYXBzIHBsYWNlaG9sZGVyIG5hbWVzIHRvIHRyYW5zbGF0YWJsZSBtZXNzYWdlIElEcyAodXNlZCBmb3IgSUNVXG4gICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlcylcbiAgICAgICAqIEBwYXJhbSBtZWFuaW5nXG4gICAgICAgKiBAcGFyYW0gZGVzY3JpcHRpb25cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gTWVzc2FnZShub2RlcywgcGxhY2Vob2xkZXJzLCBwbGFjZWhvbGRlclRvTXNnSWRzLCBtZWFuaW5nLCBkZXNjcmlwdGlvbikge1xuICAgICAgICAgIHRoaXMubm9kZXMgPSBub2RlcztcbiAgICAgICAgICB0aGlzLnBsYWNlaG9sZGVycyA9IHBsYWNlaG9sZGVycztcbiAgICAgICAgICB0aGlzLnBsYWNlaG9sZGVyVG9Nc2dJZHMgPSBwbGFjZWhvbGRlclRvTXNnSWRzO1xuICAgICAgICAgIHRoaXMubWVhbmluZyA9IG1lYW5pbmc7XG4gICAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE1lc3NhZ2U7XG4gIH0oKSk7XG4gIHZhciBUZXh0JDEgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gVGV4dCh2YWx1ZSwgc291cmNlU3Bhbikge1xuICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgfVxuICAgICAgVGV4dC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdFRleHQodGhpcywgY29udGV4dCk7IH07XG4gICAgICByZXR1cm4gVGV4dDtcbiAgfSgpKTtcbiAgdmFyIENvbnRhaW5lciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBDb250YWluZXIoY2hpbGRyZW4sIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgIH1cbiAgICAgIENvbnRhaW5lci5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdENvbnRhaW5lcih0aGlzLCBjb250ZXh0KTsgfTtcbiAgICAgIHJldHVybiBDb250YWluZXI7XG4gIH0oKSk7XG4gIHZhciBJY3UgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gSWN1KGV4cHJlc3Npb24sIHR5cGUsIGNhc2VzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICAgIHRoaXMuY2FzZXMgPSBjYXNlcztcbiAgICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgfVxuICAgICAgSWN1LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7IHJldHVybiB2aXNpdG9yLnZpc2l0SWN1KHRoaXMsIGNvbnRleHQpOyB9O1xuICAgICAgcmV0dXJuIEljdTtcbiAgfSgpKTtcbiAgdmFyIFRhZ1BsYWNlaG9sZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFRhZ1BsYWNlaG9sZGVyKHRhZywgYXR0cnMsIHN0YXJ0TmFtZSwgY2xvc2VOYW1lLCBjaGlsZHJlbiwgaXNWb2lkLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgICAgdGhpcy50YWcgPSB0YWc7XG4gICAgICAgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgICAgICAgIHRoaXMuc3RhcnROYW1lID0gc3RhcnROYW1lO1xuICAgICAgICAgIHRoaXMuY2xvc2VOYW1lID0gY2xvc2VOYW1lO1xuICAgICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgICB0aGlzLmlzVm9pZCA9IGlzVm9pZDtcbiAgICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgfVxuICAgICAgVGFnUGxhY2Vob2xkZXIucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRUYWdQbGFjZWhvbGRlcih0aGlzLCBjb250ZXh0KTsgfTtcbiAgICAgIHJldHVybiBUYWdQbGFjZWhvbGRlcjtcbiAgfSgpKTtcbiAgdmFyIFBsYWNlaG9sZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFBsYWNlaG9sZGVyKHZhbHVlLCBuYW1lLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgICAgaWYgKG5hbWUgPT09IHZvaWQgMCkgeyBuYW1lID0gJyc7IH1cbiAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgfVxuICAgICAgUGxhY2Vob2xkZXIucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRQbGFjZWhvbGRlcih0aGlzLCBjb250ZXh0KTsgfTtcbiAgICAgIHJldHVybiBQbGFjZWhvbGRlcjtcbiAgfSgpKTtcbiAgdmFyIEljdVBsYWNlaG9sZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIEljdVBsYWNlaG9sZGVyKHZhbHVlLCBuYW1lLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgICAgaWYgKG5hbWUgPT09IHZvaWQgMCkgeyBuYW1lID0gJyc7IH1cbiAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgfVxuICAgICAgSWN1UGxhY2Vob2xkZXIucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRJY3VQbGFjZWhvbGRlcih0aGlzLCBjb250ZXh0KTsgfTtcbiAgICAgIHJldHVybiBJY3VQbGFjZWhvbGRlcjtcbiAgfSgpKTtcblxuICAvKipcbiAgICogQGxpY2Vuc2VcbiAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAqXG4gICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICovXG4gIHZhciBUQUdfVE9fUExBQ0VIT0xERVJfTkFNRVMgPSB7XG4gICAgICAnQSc6ICdMSU5LJyxcbiAgICAgICdCJzogJ0JPTERfVEVYVCcsXG4gICAgICAnQlInOiAnTElORV9CUkVBSycsXG4gICAgICAnRU0nOiAnRU1QSEFTSVNFRF9URVhUJyxcbiAgICAgICdIMSc6ICdIRUFESU5HX0xFVkVMMScsXG4gICAgICAnSDInOiAnSEVBRElOR19MRVZFTDInLFxuICAgICAgJ0gzJzogJ0hFQURJTkdfTEVWRUwzJyxcbiAgICAgICdINCc6ICdIRUFESU5HX0xFVkVMNCcsXG4gICAgICAnSDUnOiAnSEVBRElOR19MRVZFTDUnLFxuICAgICAgJ0g2JzogJ0hFQURJTkdfTEVWRUw2JyxcbiAgICAgICdIUic6ICdIT1JJWk9OVEFMX1JVTEUnLFxuICAgICAgJ0knOiAnSVRBTElDX1RFWFQnLFxuICAgICAgJ0xJJzogJ0xJU1RfSVRFTScsXG4gICAgICAnTElOSyc6ICdNRURJQV9MSU5LJyxcbiAgICAgICdPTCc6ICdPUkRFUkVEX0xJU1QnLFxuICAgICAgJ1AnOiAnUEFSQUdSQVBIJyxcbiAgICAgICdRJzogJ1FVT1RBVElPTicsXG4gICAgICAnUyc6ICdTVFJJS0VUSFJPVUdIX1RFWFQnLFxuICAgICAgJ1NNQUxMJzogJ1NNQUxMX1RFWFQnLFxuICAgICAgJ1NVQic6ICdTVUJTVFJJUFQnLFxuICAgICAgJ1NVUCc6ICdTVVBFUlNDUklQVCcsXG4gICAgICAnVEJPRFknOiAnVEFCTEVfQk9EWScsXG4gICAgICAnVEQnOiAnVEFCTEVfQ0VMTCcsXG4gICAgICAnVEZPT1QnOiAnVEFCTEVfRk9PVEVSJyxcbiAgICAgICdUSCc6ICdUQUJMRV9IRUFERVJfQ0VMTCcsXG4gICAgICAnVEhFQUQnOiAnVEFCTEVfSEVBREVSJyxcbiAgICAgICdUUic6ICdUQUJMRV9ST1cnLFxuICAgICAgJ1RUJzogJ01PTk9TUEFDRURfVEVYVCcsXG4gICAgICAnVSc6ICdVTkRFUkxJTkVEX1RFWFQnLFxuICAgICAgJ1VMJzogJ1VOT1JERVJFRF9MSVNUJyxcbiAgfTtcbiAgLyoqXG4gICAqIENyZWF0ZXMgdW5pcXVlIG5hbWVzIGZvciBwbGFjZWhvbGRlciB3aXRoIGRpZmZlcmVudCBjb250ZW50XG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdmFyIFBsYWNlaG9sZGVyUmVnaXN0cnkgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gUGxhY2Vob2xkZXJSZWdpc3RyeSgpIHtcbiAgICAgICAgICAvLyBDb3VudCB0aGUgb2NjdXJyZW5jZSBvZiB0aGUgYmFzZSBuYW1lIHRvcCBnZW5lcmF0ZSBhIHVuaXF1ZSBuYW1lXG4gICAgICAgICAgdGhpcy5fcGxhY2VIb2xkZXJOYW1lQ291bnRzID0ge307XG4gICAgICAgICAgLy8gTWFwcyBzaWduYXR1cmUgdG8gcGxhY2Vob2xkZXIgbmFtZXNcbiAgICAgICAgICB0aGlzLl9zaWduYXR1cmVUb05hbWUgPSB7fTtcbiAgICAgIH1cbiAgICAgIFBsYWNlaG9sZGVyUmVnaXN0cnkucHJvdG90eXBlLmdldFN0YXJ0VGFnUGxhY2Vob2xkZXJOYW1lID0gZnVuY3Rpb24gKHRhZywgYXR0cnMsIGlzVm9pZCkge1xuICAgICAgICAgIHZhciBzaWduYXR1cmUgPSB0aGlzLl9oYXNoVGFnKHRhZywgYXR0cnMsIGlzVm9pZCk7XG4gICAgICAgICAgaWYgKHRoaXMuX3NpZ25hdHVyZVRvTmFtZVtzaWduYXR1cmVdKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaWduYXR1cmVUb05hbWVbc2lnbmF0dXJlXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHVwcGVyVGFnID0gdGFnLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgdmFyIGJhc2VOYW1lID0gVEFHX1RPX1BMQUNFSE9MREVSX05BTUVTW3VwcGVyVGFnXSB8fCBcIlRBR19cIiArIHVwcGVyVGFnO1xuICAgICAgICAgIHZhciBuYW1lID0gdGhpcy5fZ2VuZXJhdGVVbmlxdWVOYW1lKGlzVm9pZCA/IGJhc2VOYW1lIDogXCJTVEFSVF9cIiArIGJhc2VOYW1lKTtcbiAgICAgICAgICB0aGlzLl9zaWduYXR1cmVUb05hbWVbc2lnbmF0dXJlXSA9IG5hbWU7XG4gICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICB9O1xuICAgICAgUGxhY2Vob2xkZXJSZWdpc3RyeS5wcm90b3R5cGUuZ2V0Q2xvc2VUYWdQbGFjZWhvbGRlck5hbWUgPSBmdW5jdGlvbiAodGFnKSB7XG4gICAgICAgICAgdmFyIHNpZ25hdHVyZSA9IHRoaXMuX2hhc2hDbG9zaW5nVGFnKHRhZyk7XG4gICAgICAgICAgaWYgKHRoaXMuX3NpZ25hdHVyZVRvTmFtZVtzaWduYXR1cmVdKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaWduYXR1cmVUb05hbWVbc2lnbmF0dXJlXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHVwcGVyVGFnID0gdGFnLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgdmFyIGJhc2VOYW1lID0gVEFHX1RPX1BMQUNFSE9MREVSX05BTUVTW3VwcGVyVGFnXSB8fCBcIlRBR19cIiArIHVwcGVyVGFnO1xuICAgICAgICAgIHZhciBuYW1lID0gdGhpcy5fZ2VuZXJhdGVVbmlxdWVOYW1lKFwiQ0xPU0VfXCIgKyBiYXNlTmFtZSk7XG4gICAgICAgICAgdGhpcy5fc2lnbmF0dXJlVG9OYW1lW3NpZ25hdHVyZV0gPSBuYW1lO1xuICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgfTtcbiAgICAgIFBsYWNlaG9sZGVyUmVnaXN0cnkucHJvdG90eXBlLmdldFBsYWNlaG9sZGVyTmFtZSA9IGZ1bmN0aW9uIChuYW1lLCBjb250ZW50KSB7XG4gICAgICAgICAgdmFyIHVwcGVyTmFtZSA9IG5hbWUudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICB2YXIgc2lnbmF0dXJlID0gXCJQSDogXCIgKyB1cHBlck5hbWUgKyBcIj1cIiArIGNvbnRlbnQ7XG4gICAgICAgICAgaWYgKHRoaXMuX3NpZ25hdHVyZVRvTmFtZVtzaWduYXR1cmVdKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaWduYXR1cmVUb05hbWVbc2lnbmF0dXJlXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHVuaXF1ZU5hbWUgPSB0aGlzLl9nZW5lcmF0ZVVuaXF1ZU5hbWUodXBwZXJOYW1lKTtcbiAgICAgICAgICB0aGlzLl9zaWduYXR1cmVUb05hbWVbc2lnbmF0dXJlXSA9IHVuaXF1ZU5hbWU7XG4gICAgICAgICAgcmV0dXJuIHVuaXF1ZU5hbWU7XG4gICAgICB9O1xuICAgICAgLy8gR2VuZXJhdGUgYSBoYXNoIGZvciBhIHRhZyAtIGRvZXMgbm90IHRha2UgYXR0cmlidXRlIG9yZGVyIGludG8gYWNjb3VudFxuICAgICAgUGxhY2Vob2xkZXJSZWdpc3RyeS5wcm90b3R5cGUuX2hhc2hUYWcgPSBmdW5jdGlvbiAodGFnLCBhdHRycywgaXNWb2lkKSB7XG4gICAgICAgICAgdmFyIHN0YXJ0ID0gXCI8XCIgKyB0YWc7XG4gICAgICAgICAgdmFyIHN0ckF0dHJzID0gT2JqZWN0LmtleXMoYXR0cnMpLnNvcnQoKS5tYXAoZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIChcIiBcIiArIG5hbWUgKyBcIj1cIiArIGF0dHJzW25hbWVdKTsgfSkuam9pbignJyk7XG4gICAgICAgICAgdmFyIGVuZCA9IGlzVm9pZCA/ICcvPicgOiBcIj48L1wiICsgdGFnICsgXCI+XCI7XG4gICAgICAgICAgcmV0dXJuIHN0YXJ0ICsgc3RyQXR0cnMgKyBlbmQ7XG4gICAgICB9O1xuICAgICAgUGxhY2Vob2xkZXJSZWdpc3RyeS5wcm90b3R5cGUuX2hhc2hDbG9zaW5nVGFnID0gZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gdGhpcy5faGFzaFRhZyhcIi9cIiArIHRhZywge30sIGZhbHNlKTsgfTtcbiAgICAgIFBsYWNlaG9sZGVyUmVnaXN0cnkucHJvdG90eXBlLl9nZW5lcmF0ZVVuaXF1ZU5hbWUgPSBmdW5jdGlvbiAoYmFzZSkge1xuICAgICAgICAgIHZhciBuYW1lID0gYmFzZTtcbiAgICAgICAgICB2YXIgbmV4dCA9IHRoaXMuX3BsYWNlSG9sZGVyTmFtZUNvdW50c1tuYW1lXTtcbiAgICAgICAgICBpZiAoIW5leHQpIHtcbiAgICAgICAgICAgICAgbmV4dCA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBuYW1lICs9IFwiX1wiICsgbmV4dDtcbiAgICAgICAgICAgICAgbmV4dCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9wbGFjZUhvbGRlck5hbWVDb3VudHNbYmFzZV0gPSBuZXh0O1xuICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBQbGFjZWhvbGRlclJlZ2lzdHJ5O1xuICB9KCkpO1xuXG4gIHZhciBfZXhwUGFyc2VyID0gbmV3IFBhcnNlcihuZXcgTGV4ZXIoKSk7XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgZnVuY3Rpb24gY29udmVydGluZyBodG1sIG5vZGVzIHRvIGFuIGkxOG4gTWVzc2FnZSBnaXZlbiBhbiBpbnRlcnBvbGF0aW9uQ29uZmlnXG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVJMThuTWVzc2FnZUZhY3RvcnkoaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgICAgdmFyIHZpc2l0b3IgPSBuZXcgX0kxOG5WaXNpdG9yKF9leHBQYXJzZXIsIGludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChub2RlcywgbWVhbmluZywgZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci50b0kxOG5NZXNzYWdlKG5vZGVzLCBtZWFuaW5nLCBkZXNjcmlwdGlvbik7XG4gICAgICB9O1xuICB9XG4gIHZhciBfSTE4blZpc2l0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gX0kxOG5WaXNpdG9yKF9leHByZXNzaW9uUGFyc2VyLCBfaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgICAgICAgIHRoaXMuX2V4cHJlc3Npb25QYXJzZXIgPSBfZXhwcmVzc2lvblBhcnNlcjtcbiAgICAgICAgICB0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnID0gX2ludGVycG9sYXRpb25Db25maWc7XG4gICAgICB9XG4gICAgICBfSTE4blZpc2l0b3IucHJvdG90eXBlLnRvSTE4bk1lc3NhZ2UgPSBmdW5jdGlvbiAobm9kZXMsIG1lYW5pbmcsIGRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgdGhpcy5faXNJY3UgPSBub2Rlcy5sZW5ndGggPT0gMSAmJiBub2Rlc1swXSBpbnN0YW5jZW9mIEV4cGFuc2lvbjtcbiAgICAgICAgICB0aGlzLl9pY3VEZXB0aCA9IDA7XG4gICAgICAgICAgdGhpcy5fcGxhY2Vob2xkZXJSZWdpc3RyeSA9IG5ldyBQbGFjZWhvbGRlclJlZ2lzdHJ5KCk7XG4gICAgICAgICAgdGhpcy5fcGxhY2Vob2xkZXJUb0NvbnRlbnQgPSB7fTtcbiAgICAgICAgICB0aGlzLl9wbGFjZWhvbGRlclRvSWRzID0ge307XG4gICAgICAgICAgdmFyIGkxOG5vZGVzID0gdmlzaXRBbGwodGhpcywgbm9kZXMsIHt9KTtcbiAgICAgICAgICByZXR1cm4gbmV3IE1lc3NhZ2UoaTE4bm9kZXMsIHRoaXMuX3BsYWNlaG9sZGVyVG9Db250ZW50LCB0aGlzLl9wbGFjZWhvbGRlclRvSWRzLCBtZWFuaW5nLCBkZXNjcmlwdGlvbik7XG4gICAgICB9O1xuICAgICAgX0kxOG5WaXNpdG9yLnByb3RvdHlwZS52aXNpdEVsZW1lbnQgPSBmdW5jdGlvbiAoZWwsIGNvbnRleHQpIHtcbiAgICAgICAgICB2YXIgY2hpbGRyZW4gPSB2aXNpdEFsbCh0aGlzLCBlbC5jaGlsZHJlbik7XG4gICAgICAgICAgdmFyIGF0dHJzID0ge307XG4gICAgICAgICAgZWwuYXR0cnMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgICAgICAvLyBEbyBub3QgdmlzaXQgdGhlIGF0dHJpYnV0ZXMsIHRyYW5zbGF0YWJsZSBvbmVzIGFyZSB0b3AtbGV2ZWwgQVNUc1xuICAgICAgICAgICAgICBhdHRyc1thdHRyLm5hbWVdID0gYXR0ci52YWx1ZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgaXNWb2lkID0gZ2V0SHRtbFRhZ0RlZmluaXRpb24oZWwubmFtZSkuaXNWb2lkO1xuICAgICAgICAgIHZhciBzdGFydFBoTmFtZSA9IHRoaXMuX3BsYWNlaG9sZGVyUmVnaXN0cnkuZ2V0U3RhcnRUYWdQbGFjZWhvbGRlck5hbWUoZWwubmFtZSwgYXR0cnMsIGlzVm9pZCk7XG4gICAgICAgICAgdGhpcy5fcGxhY2Vob2xkZXJUb0NvbnRlbnRbc3RhcnRQaE5hbWVdID0gZWwuc291cmNlU3Bhbi50b1N0cmluZygpO1xuICAgICAgICAgIHZhciBjbG9zZVBoTmFtZSA9ICcnO1xuICAgICAgICAgIGlmICghaXNWb2lkKSB7XG4gICAgICAgICAgICAgIGNsb3NlUGhOYW1lID0gdGhpcy5fcGxhY2Vob2xkZXJSZWdpc3RyeS5nZXRDbG9zZVRhZ1BsYWNlaG9sZGVyTmFtZShlbC5uYW1lKTtcbiAgICAgICAgICAgICAgdGhpcy5fcGxhY2Vob2xkZXJUb0NvbnRlbnRbY2xvc2VQaE5hbWVdID0gXCI8L1wiICsgZWwubmFtZSArIFwiPlwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IFRhZ1BsYWNlaG9sZGVyKGVsLm5hbWUsIGF0dHJzLCBzdGFydFBoTmFtZSwgY2xvc2VQaE5hbWUsIGNoaWxkcmVuLCBpc1ZvaWQsIGVsLnNvdXJjZVNwYW4pO1xuICAgICAgfTtcbiAgICAgIF9JMThuVmlzaXRvci5wcm90b3R5cGUudmlzaXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXR0cmlidXRlLCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2l0VGV4dFdpdGhJbnRlcnBvbGF0aW9uKGF0dHJpYnV0ZS52YWx1ZSwgYXR0cmlidXRlLnNvdXJjZVNwYW4pO1xuICAgICAgfTtcbiAgICAgIF9JMThuVmlzaXRvci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKHRleHQsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fdmlzaXRUZXh0V2l0aEludGVycG9sYXRpb24odGV4dC52YWx1ZSwgdGV4dC5zb3VyY2VTcGFuKTtcbiAgICAgIH07XG4gICAgICBfSTE4blZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q29tbWVudCA9IGZ1bmN0aW9uIChjb21tZW50LCBjb250ZXh0KSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgX0kxOG5WaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbiA9IGZ1bmN0aW9uIChpY3UsIGNvbnRleHQpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHRoaXMuX2ljdURlcHRoKys7XG4gICAgICAgICAgdmFyIGkxOG5JY3VDYXNlcyA9IHt9O1xuICAgICAgICAgIHZhciBpMThuSWN1ID0gbmV3IEljdShpY3Uuc3dpdGNoVmFsdWUsIGljdS50eXBlLCBpMThuSWN1Q2FzZXMsIGljdS5zb3VyY2VTcGFuKTtcbiAgICAgICAgICBpY3UuY2FzZXMuZm9yRWFjaChmdW5jdGlvbiAoY2F6ZSkge1xuICAgICAgICAgICAgICBpMThuSWN1Q2FzZXNbY2F6ZS52YWx1ZV0gPSBuZXcgQ29udGFpbmVyKGNhemUuZXhwcmVzc2lvbi5tYXAoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUudmlzaXQoX3RoaXMsIHt9KTsgfSksIGNhemUuZXhwU291cmNlU3Bhbik7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5faWN1RGVwdGgtLTtcbiAgICAgICAgICBpZiAodGhpcy5faXNJY3UgfHwgdGhpcy5faWN1RGVwdGggPiAwKSB7XG4gICAgICAgICAgICAgIC8vIElmIHRoZSBtZXNzYWdlICh2cyBhIHBhcnQgb2YgdGhlIG1lc3NhZ2UpIGlzIGFuIElDVSBtZXNzYWdlIHJldHVybnMgaXRcbiAgICAgICAgICAgICAgcmV0dXJuIGkxOG5JY3U7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEVsc2UgcmV0dXJucyBhIHBsYWNlaG9sZGVyXG4gICAgICAgICAgLy8gSUNVIHBsYWNlaG9sZGVycyBzaG91bGQgbm90IGJlIHJlcGxhY2VkIHdpdGggdGhlaXIgb3JpZ2luYWwgY29udGVudCBidXQgd2l0aCB0aGUgdGhlaXJcbiAgICAgICAgICAvLyB0cmFuc2xhdGlvbnMuIFdlIG5lZWQgdG8gY3JlYXRlIGEgbmV3IHZpc2l0b3IgKHRoZXkgYXJlIG5vdCByZS1lbnRyYW50KSB0byBjb21wdXRlIHRoZVxuICAgICAgICAgIC8vIG1lc3NhZ2UgaWQuXG4gICAgICAgICAgLy8gVE9ETyh2aWNiKTogYWRkIGEgaHRtbC5Ob2RlIC0+IGkxOG4uTWVzc2FnZSBjYWNoZSB0byBhdm9pZCBoYXZpbmcgdG8gcmUtY3JlYXRlIHRoZSBtc2dcbiAgICAgICAgICB2YXIgcGhOYW1lID0gdGhpcy5fcGxhY2Vob2xkZXJSZWdpc3RyeS5nZXRQbGFjZWhvbGRlck5hbWUoJ0lDVScsIGljdS5zb3VyY2VTcGFuLnRvU3RyaW5nKCkpO1xuICAgICAgICAgIHZhciB2aXNpdG9yID0gbmV3IF9JMThuVmlzaXRvcih0aGlzLl9leHByZXNzaW9uUGFyc2VyLCB0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgICB0aGlzLl9wbGFjZWhvbGRlclRvSWRzW3BoTmFtZV0gPSBkaWdlc3RNZXNzYWdlKHZpc2l0b3IudG9JMThuTWVzc2FnZShbaWN1XSwgJycsICcnKSk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBJY3VQbGFjZWhvbGRlcihpMThuSWN1LCBwaE5hbWUsIGljdS5zb3VyY2VTcGFuKTtcbiAgICAgIH07XG4gICAgICBfSTE4blZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uQ2FzZSA9IGZ1bmN0aW9uIChpY3VDYXNlLCBjb250ZXh0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnJlYWNoYWJsZSBjb2RlJyk7XG4gICAgICB9O1xuICAgICAgX0kxOG5WaXNpdG9yLnByb3RvdHlwZS5fdmlzaXRUZXh0V2l0aEludGVycG9sYXRpb24gPSBmdW5jdGlvbiAodGV4dCwgc291cmNlU3Bhbikge1xuICAgICAgICAgIHZhciBzcGxpdEludGVycG9sYXRpb24gPSB0aGlzLl9leHByZXNzaW9uUGFyc2VyLnNwbGl0SW50ZXJwb2xhdGlvbih0ZXh0LCBzb3VyY2VTcGFuLnN0YXJ0LnRvU3RyaW5nKCksIHRoaXMuX2ludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICAgIGlmICghc3BsaXRJbnRlcnBvbGF0aW9uKSB7XG4gICAgICAgICAgICAgIC8vIE5vIGV4cHJlc3Npb24sIHJldHVybiBhIHNpbmdsZSB0ZXh0XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgVGV4dCQxKHRleHQsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBSZXR1cm4gYSBncm91cCBvZiB0ZXh0ICsgZXhwcmVzc2lvbnNcbiAgICAgICAgICB2YXIgbm9kZXMgPSBbXTtcbiAgICAgICAgICB2YXIgY29udGFpbmVyID0gbmV3IENvbnRhaW5lcihub2Rlcywgc291cmNlU3Bhbik7XG4gICAgICAgICAgdmFyIF9hID0gdGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZywgc0RlbGltaXRlciA9IF9hLnN0YXJ0LCBlRGVsaW1pdGVyID0gX2EuZW5kO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3BsaXRJbnRlcnBvbGF0aW9uLnN0cmluZ3MubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBleHByZXNzaW9uID0gc3BsaXRJbnRlcnBvbGF0aW9uLmV4cHJlc3Npb25zW2ldO1xuICAgICAgICAgICAgICB2YXIgYmFzZU5hbWUgPSBfZXh0cmFjdFBsYWNlaG9sZGVyTmFtZShleHByZXNzaW9uKSB8fCAnSU5URVJQT0xBVElPTic7XG4gICAgICAgICAgICAgIHZhciBwaE5hbWUgPSB0aGlzLl9wbGFjZWhvbGRlclJlZ2lzdHJ5LmdldFBsYWNlaG9sZGVyTmFtZShiYXNlTmFtZSwgZXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgIGlmIChzcGxpdEludGVycG9sYXRpb24uc3RyaW5nc1tpXS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIC8vIE5vIG5lZWQgdG8gYWRkIGVtcHR5IHN0cmluZ3NcbiAgICAgICAgICAgICAgICAgIG5vZGVzLnB1c2gobmV3IFRleHQkMShzcGxpdEludGVycG9sYXRpb24uc3RyaW5nc1tpXSwgc291cmNlU3BhbikpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG5vZGVzLnB1c2gobmV3IFBsYWNlaG9sZGVyKGV4cHJlc3Npb24sIHBoTmFtZSwgc291cmNlU3BhbikpO1xuICAgICAgICAgICAgICB0aGlzLl9wbGFjZWhvbGRlclRvQ29udGVudFtwaE5hbWVdID0gc0RlbGltaXRlciArIGV4cHJlc3Npb24gKyBlRGVsaW1pdGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBUaGUgbGFzdCBpbmRleCBjb250YWlucyBubyBleHByZXNzaW9uXG4gICAgICAgICAgdmFyIGxhc3RTdHJpbmdJZHggPSBzcGxpdEludGVycG9sYXRpb24uc3RyaW5ncy5sZW5ndGggLSAxO1xuICAgICAgICAgIGlmIChzcGxpdEludGVycG9sYXRpb24uc3RyaW5nc1tsYXN0U3RyaW5nSWR4XS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgbm9kZXMucHVzaChuZXcgVGV4dCQxKHNwbGl0SW50ZXJwb2xhdGlvbi5zdHJpbmdzW2xhc3RTdHJpbmdJZHhdLCBzb3VyY2VTcGFuKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjb250YWluZXI7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIF9JMThuVmlzaXRvcjtcbiAgfSgpKTtcbiAgdmFyIF9DVVNUT01fUEhfRVhQID0gL1xcL1xcL1tcXHNcXFNdKmkxOG5bXFxzXFxTXSpcXChbXFxzXFxTXSpwaFtcXHNcXFNdKj1bXFxzXFxTXSpcIihbXFxzXFxTXSo/KVwiW1xcc1xcU10qXFwpL2c7XG4gIGZ1bmN0aW9uIF9leHRyYWN0UGxhY2Vob2xkZXJOYW1lKGlucHV0KSB7XG4gICAgICByZXR1cm4gaW5wdXQuc3BsaXQoX0NVU1RPTV9QSF9FWFApWzFdO1xuICB9XG5cbiAgLyoqXG4gICAqIEBsaWNlbnNlXG4gICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgKlxuICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAqL1xuICB2YXIgX19leHRlbmRzJDYgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gIH07XG4gIC8qKlxuICAgKiBBbiBpMThuIGVycm9yLlxuICAgKi9cbiAgdmFyIEkxOG5FcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkNihJMThuRXJyb3IsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBJMThuRXJyb3Ioc3BhbiwgbXNnKSB7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgc3BhbiwgbXNnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBJMThuRXJyb3I7XG4gIH0oUGFyc2VFcnJvcikpO1xuXG4gIHZhciBfSTE4Tl9BVFRSID0gJ2kxOG4nO1xuICB2YXIgX0kxOE5fQVRUUl9QUkVGSVggPSAnaTE4bi0nO1xuICB2YXIgX0kxOE5fQ09NTUVOVF9QUkVGSVhfUkVHRVhQID0gL15pMThuOj8vO1xuICAvKipcbiAgICogRXh0cmFjdCB0cmFuc2xhdGFibGUgbWVzc2FnZXMgZnJvbSBhbiBodG1sIEFTVFxuICAgKi9cbiAgZnVuY3Rpb24gZXh0cmFjdE1lc3NhZ2VzKG5vZGVzLCBpbnRlcnBvbGF0aW9uQ29uZmlnLCBpbXBsaWNpdFRhZ3MsIGltcGxpY2l0QXR0cnMpIHtcbiAgICAgIHZhciB2aXNpdG9yID0gbmV3IF9WaXNpdG9yKGltcGxpY2l0VGFncywgaW1wbGljaXRBdHRycyk7XG4gICAgICByZXR1cm4gdmlzaXRvci5leHRyYWN0KG5vZGVzLCBpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgfVxuICBmdW5jdGlvbiBtZXJnZVRyYW5zbGF0aW9ucyhub2RlcywgdHJhbnNsYXRpb25zLCBpbnRlcnBvbGF0aW9uQ29uZmlnLCBpbXBsaWNpdFRhZ3MsIGltcGxpY2l0QXR0cnMpIHtcbiAgICAgIHZhciB2aXNpdG9yID0gbmV3IF9WaXNpdG9yKGltcGxpY2l0VGFncywgaW1wbGljaXRBdHRycyk7XG4gICAgICByZXR1cm4gdmlzaXRvci5tZXJnZShub2RlcywgdHJhbnNsYXRpb25zLCBpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgfVxuICB2YXIgRXh0cmFjdGlvblJlc3VsdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBFeHRyYWN0aW9uUmVzdWx0KG1lc3NhZ2VzLCBlcnJvcnMpIHtcbiAgICAgICAgICB0aGlzLm1lc3NhZ2VzID0gbWVzc2FnZXM7XG4gICAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICB9XG4gICAgICByZXR1cm4gRXh0cmFjdGlvblJlc3VsdDtcbiAgfSgpKTtcbiAgdmFyIF9WaXNpdG9yTW9kZTtcbiAgKGZ1bmN0aW9uIChfVmlzaXRvck1vZGUpIHtcbiAgICAgIF9WaXNpdG9yTW9kZVtfVmlzaXRvck1vZGVbXCJFeHRyYWN0XCJdID0gMF0gPSBcIkV4dHJhY3RcIjtcbiAgICAgIF9WaXNpdG9yTW9kZVtfVmlzaXRvck1vZGVbXCJNZXJnZVwiXSA9IDFdID0gXCJNZXJnZVwiO1xuICB9KShfVmlzaXRvck1vZGUgfHwgKF9WaXNpdG9yTW9kZSA9IHt9KSk7XG4gIC8qKlxuICAgKiBUaGlzIFZpc2l0b3IgaXMgdXNlZDpcbiAgICogMS4gdG8gZXh0cmFjdCBhbGwgdGhlIHRyYW5zbGF0YWJsZSBzdHJpbmdzIGZyb20gYW4gaHRtbCBBU1QgKHNlZSBgZXh0cmFjdCgpYCksXG4gICAqIDIuIHRvIHJlcGxhY2UgdGhlIHRyYW5zbGF0YWJsZSBzdHJpbmdzIHdpdGggdGhlIGFjdHVhbCB0cmFuc2xhdGlvbnMgKHNlZSBgbWVyZ2UoKWApXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdmFyIF9WaXNpdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIF9WaXNpdG9yKF9pbXBsaWNpdFRhZ3MsIF9pbXBsaWNpdEF0dHJzKSB7XG4gICAgICAgICAgdGhpcy5faW1wbGljaXRUYWdzID0gX2ltcGxpY2l0VGFncztcbiAgICAgICAgICB0aGlzLl9pbXBsaWNpdEF0dHJzID0gX2ltcGxpY2l0QXR0cnM7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIEV4dHJhY3RzIHRoZSBtZXNzYWdlcyBmcm9tIHRoZSB0cmVlXG4gICAgICAgKi9cbiAgICAgIF9WaXNpdG9yLnByb3RvdHlwZS5leHRyYWN0ID0gZnVuY3Rpb24gKG5vZGVzLCBpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB0aGlzLl9pbml0KF9WaXNpdG9yTW9kZS5FeHRyYWN0LCBpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLnZpc2l0KF90aGlzLCBudWxsKTsgfSk7XG4gICAgICAgICAgaWYgKHRoaXMuX2luSTE4bkJsb2NrKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdLCAnVW5jbG9zZWQgYmxvY2snKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBFeHRyYWN0aW9uUmVzdWx0KHRoaXMuX21lc3NhZ2VzLCB0aGlzLl9lcnJvcnMpO1xuICAgICAgfTtcbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyBhIHRyZWUgd2hlcmUgYWxsIHRyYW5zbGF0YWJsZSBub2RlcyBhcmUgdHJhbnNsYXRlZFxuICAgICAgICovXG4gICAgICBfVmlzaXRvci5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbiAobm9kZXMsIHRyYW5zbGF0aW9ucywgaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgICAgICAgIHRoaXMuX2luaXQoX1Zpc2l0b3JNb2RlLk1lcmdlLCBpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgICB0aGlzLl90cmFuc2xhdGlvbnMgPSB0cmFuc2xhdGlvbnM7XG4gICAgICAgICAgLy8gQ29uc3RydWN0IGEgc2luZ2xlIGZha2Ugcm9vdCBlbGVtZW50XG4gICAgICAgICAgdmFyIHdyYXBwZXIgPSBuZXcgRWxlbWVudCgnd3JhcHBlcicsIFtdLCBub2RlcywgbnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgICAgICAgdmFyIHRyYW5zbGF0ZWROb2RlID0gd3JhcHBlci52aXNpdCh0aGlzLCBudWxsKTtcbiAgICAgICAgICBpZiAodGhpcy5faW5JMThuQmxvY2spIHtcbiAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3Iobm9kZXNbbm9kZXMubGVuZ3RoIC0gMV0sICdVbmNsb3NlZCBibG9jaycpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IFBhcnNlVHJlZVJlc3VsdCh0cmFuc2xhdGVkTm9kZS5jaGlsZHJlbiwgdGhpcy5fZXJyb3JzKTtcbiAgICAgIH07XG4gICAgICBfVmlzaXRvci5wcm90b3R5cGUudmlzaXRFeHBhbnNpb25DYXNlID0gZnVuY3Rpb24gKGljdUNhc2UsIGNvbnRleHQpIHtcbiAgICAgICAgICAvLyBQYXJzZSBjYXNlcyBmb3IgdHJhbnNsYXRhYmxlIGh0bWwgYXR0cmlidXRlc1xuICAgICAgICAgIHZhciBleHByZXNzaW9uID0gdmlzaXRBbGwodGhpcywgaWN1Q2FzZS5leHByZXNzaW9uLCBjb250ZXh0KTtcbiAgICAgICAgICBpZiAodGhpcy5fbW9kZSA9PT0gX1Zpc2l0b3JNb2RlLk1lcmdlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgRXhwYW5zaW9uQ2FzZShpY3VDYXNlLnZhbHVlLCBleHByZXNzaW9uLCBpY3VDYXNlLnNvdXJjZVNwYW4sIGljdUNhc2UudmFsdWVTb3VyY2VTcGFuLCBpY3VDYXNlLmV4cFNvdXJjZVNwYW4pO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfVmlzaXRvci5wcm90b3R5cGUudmlzaXRFeHBhbnNpb24gPSBmdW5jdGlvbiAoaWN1LCBjb250ZXh0KSB7XG4gICAgICAgICAgdGhpcy5fbWF5QmVBZGRCbG9ja0NoaWxkcmVuKGljdSk7XG4gICAgICAgICAgdmFyIHdhc0luSWN1ID0gdGhpcy5faW5JY3U7XG4gICAgICAgICAgaWYgKCF0aGlzLl9pbkljdSkge1xuICAgICAgICAgICAgICAvLyBuZXN0ZWQgSUNVIG1lc3NhZ2VzIHNob3VsZCBub3QgYmUgZXh0cmFjdGVkIGJ1dCB0b3AtbGV2ZWwgdHJhbnNsYXRlZCBhcyBhIHdob2xlXG4gICAgICAgICAgICAgIGlmICh0aGlzLl9pc0luVHJhbnNsYXRhYmxlU2VjdGlvbikge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkTWVzc2FnZShbaWN1XSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5faW5JY3UgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgY2FzZXMgPSB2aXNpdEFsbCh0aGlzLCBpY3UuY2FzZXMsIGNvbnRleHQpO1xuICAgICAgICAgIGlmICh0aGlzLl9tb2RlID09PSBfVmlzaXRvck1vZGUuTWVyZ2UpIHtcbiAgICAgICAgICAgICAgaWN1ID0gbmV3IEV4cGFuc2lvbihpY3Uuc3dpdGNoVmFsdWUsIGljdS50eXBlLCBjYXNlcywgaWN1LnNvdXJjZVNwYW4sIGljdS5zd2l0Y2hWYWx1ZVNvdXJjZVNwYW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9pbkljdSA9IHdhc0luSWN1O1xuICAgICAgICAgIHJldHVybiBpY3U7XG4gICAgICB9O1xuICAgICAgX1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0Q29tbWVudCA9IGZ1bmN0aW9uIChjb21tZW50LCBjb250ZXh0KSB7XG4gICAgICAgICAgdmFyIGlzT3BlbmluZyA9IF9pc09wZW5pbmdDb21tZW50KGNvbW1lbnQpO1xuICAgICAgICAgIGlmIChpc09wZW5pbmcgJiYgdGhpcy5faXNJblRyYW5zbGF0YWJsZVNlY3Rpb24pIHtcbiAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoY29tbWVudCwgJ0NvdWxkIG5vdCBzdGFydCBhIGJsb2NrIGluc2lkZSBhIHRyYW5zbGF0YWJsZSBzZWN0aW9uJyk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGlzQ2xvc2luZyA9IF9pc0Nsb3NpbmdDb21tZW50KGNvbW1lbnQpO1xuICAgICAgICAgIGlmIChpc0Nsb3NpbmcgJiYgIXRoaXMuX2luSTE4bkJsb2NrKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKGNvbW1lbnQsICdUcnlpbmcgdG8gY2xvc2UgYW4gdW5vcGVuZWQgYmxvY2snKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXRoaXMuX2luSTE4bk5vZGUgJiYgIXRoaXMuX2luSWN1KSB7XG4gICAgICAgICAgICAgIGlmICghdGhpcy5faW5JMThuQmxvY2spIHtcbiAgICAgICAgICAgICAgICAgIGlmIChpc09wZW5pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbkkxOG5CbG9jayA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYmxvY2tTdGFydERlcHRoID0gdGhpcy5fZGVwdGg7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYmxvY2tDaGlsZHJlbiA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Jsb2NrTWVhbmluZ0FuZERlc2MgPSBjb21tZW50LnZhbHVlLnJlcGxhY2UoX0kxOE5fQ09NTUVOVF9QUkVGSVhfUkVHRVhQLCAnJykudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29wZW5UcmFuc2xhdGFibGVTZWN0aW9uKGNvbW1lbnQpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaWYgKGlzQ2xvc2luZykge1xuICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9kZXB0aCA9PSB0aGlzLl9ibG9ja1N0YXJ0RGVwdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2xvc2VUcmFuc2xhdGFibGVTZWN0aW9uKGNvbW1lbnQsIHRoaXMuX2Jsb2NrQ2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbkkxOG5CbG9jayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IHRoaXMuX2FkZE1lc3NhZ2UodGhpcy5fYmxvY2tDaGlsZHJlbiwgdGhpcy5fYmxvY2tNZWFuaW5nQW5kRGVzYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1lcmdlIGF0dHJpYnV0ZXMgaW4gc2VjdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVzID0gdGhpcy5fdHJhbnNsYXRlTWVzc2FnZShjb21tZW50LCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZpc2l0QWxsKHRoaXMsIG5vZGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKGNvbW1lbnQsICdJMThOIGJsb2NrcyBzaG91bGQgbm90IGNyb3NzIGVsZW1lbnQgYm91bmRhcmllcycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIF9WaXNpdG9yLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAodGV4dCwgY29udGV4dCkge1xuICAgICAgICAgIGlmICh0aGlzLl9pc0luVHJhbnNsYXRhYmxlU2VjdGlvbikge1xuICAgICAgICAgICAgICB0aGlzLl9tYXlCZUFkZEJsb2NrQ2hpbGRyZW4odGV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgfTtcbiAgICAgIF9WaXNpdG9yLnByb3RvdHlwZS52aXNpdEVsZW1lbnQgPSBmdW5jdGlvbiAoZWwsIGNvbnRleHQpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHRoaXMuX21heUJlQWRkQmxvY2tDaGlsZHJlbihlbCk7XG4gICAgICAgICAgdGhpcy5fZGVwdGgrKztcbiAgICAgICAgICB2YXIgd2FzSW5JMThuTm9kZSA9IHRoaXMuX2luSTE4bk5vZGU7XG4gICAgICAgICAgdmFyIHdhc0luSW1wbGljaXROb2RlID0gdGhpcy5faW5JbXBsaWNpdE5vZGU7XG4gICAgICAgICAgdmFyIGNoaWxkTm9kZXM7XG4gICAgICAgICAgLy8gRXh0cmFjdCBvbmx5IHRvcCBsZXZlbCBub2RlcyB3aXRoIHRoZSAoaW1wbGljaXQpIFwiaTE4blwiIGF0dHJpYnV0ZSBpZiBub3QgaW4gYSBibG9jayBvciBhbiBJQ1VcbiAgICAgICAgICAvLyBtZXNzYWdlXG4gICAgICAgICAgdmFyIGkxOG5BdHRyID0gX2dldEkxOG5BdHRyKGVsKTtcbiAgICAgICAgICB2YXIgaXNJbXBsaWNpdCA9IHRoaXMuX2ltcGxpY2l0VGFncy5zb21lKGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIGVsLm5hbWUgPT09IHRhZzsgfSkgJiZcbiAgICAgICAgICAgICAgIXRoaXMuX2luSWN1ICYmICF0aGlzLl9pc0luVHJhbnNsYXRhYmxlU2VjdGlvbjtcbiAgICAgICAgICB2YXIgaXNUb3BMZXZlbEltcGxpY2l0ID0gIXdhc0luSW1wbGljaXROb2RlICYmIGlzSW1wbGljaXQ7XG4gICAgICAgICAgdGhpcy5faW5JbXBsaWNpdE5vZGUgPSB0aGlzLl9pbkltcGxpY2l0Tm9kZSB8fCBpc0ltcGxpY2l0O1xuICAgICAgICAgIGlmICghdGhpcy5faXNJblRyYW5zbGF0YWJsZVNlY3Rpb24gJiYgIXRoaXMuX2luSWN1KSB7XG4gICAgICAgICAgICAgIGlmIChpMThuQXR0cikge1xuICAgICAgICAgICAgICAgICAgLy8gZXhwbGljaXQgdHJhbnNsYXRpb25cbiAgICAgICAgICAgICAgICAgIHRoaXMuX2luSTE4bk5vZGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSB0aGlzLl9hZGRNZXNzYWdlKGVsLmNoaWxkcmVuLCBpMThuQXR0ci52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICBjaGlsZE5vZGVzID0gdGhpcy5fdHJhbnNsYXRlTWVzc2FnZShlbCwgbWVzc2FnZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAoaXNUb3BMZXZlbEltcGxpY2l0KSB7XG4gICAgICAgICAgICAgICAgICAvLyBpbXBsaWNpdCB0cmFuc2xhdGlvblxuICAgICAgICAgICAgICAgICAgdGhpcy5faW5JMThuTm9kZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IHRoaXMuX2FkZE1lc3NhZ2UoZWwuY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgICAgY2hpbGROb2RlcyA9IHRoaXMuX3RyYW5zbGF0ZU1lc3NhZ2UoZWwsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9tb2RlID09IF9WaXNpdG9yTW9kZS5FeHRyYWN0KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgaXNUcmFuc2xhdGFibGUgPSBpMThuQXR0ciB8fCBpc1RvcExldmVsSW1wbGljaXQ7XG4gICAgICAgICAgICAgICAgICBpZiAoaXNUcmFuc2xhdGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vcGVuVHJhbnNsYXRhYmxlU2VjdGlvbihlbCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB2aXNpdEFsbCh0aGlzLCBlbC5jaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgICBpZiAoaXNUcmFuc2xhdGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jbG9zZVRyYW5zbGF0YWJsZVNlY3Rpb24oZWwsIGVsLmNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodGhpcy5fbW9kZSA9PT0gX1Zpc2l0b3JNb2RlLk1lcmdlICYmICFpMThuQXR0ciAmJiAhaXNUb3BMZXZlbEltcGxpY2l0KSB7XG4gICAgICAgICAgICAgICAgICBjaGlsZE5vZGVzID0gW107XG4gICAgICAgICAgICAgICAgICBlbC5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciB2aXNpdGVkID0gY2hpbGQudmlzaXQoX3RoaXMsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgIGlmICh2aXNpdGVkICYmICFfdGhpcy5faXNJblRyYW5zbGF0YWJsZVNlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG8gbm90IGFkZCB0aGUgY2hpbGRyZW4gZnJvbSB0cmFuc2xhdGFibGUgc2VjdGlvbnMgKD0gaTE4biBibG9ja3MgaGVyZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhleSB3aWxsIGJlIGFkZGVkIHdoZW4gdGhlIHNlY3Rpb24gaXMgY2xvc2UgKGkuZS4gb24gYDwhLS0gL2kxOG4gLS0+YClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGROb2RlcyA9IGNoaWxkTm9kZXMuY29uY2F0KHZpc2l0ZWQpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoaTE4bkF0dHIgfHwgaXNUb3BMZXZlbEltcGxpY2l0KSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihlbCwgJ0NvdWxkIG5vdCBtYXJrIGFuIGVsZW1lbnQgYXMgdHJhbnNsYXRhYmxlIGluc2lkZSBhIHRyYW5zbGF0YWJsZSBzZWN0aW9uJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHRoaXMuX21vZGUgPT0gX1Zpc2l0b3JNb2RlLkV4dHJhY3QpIHtcbiAgICAgICAgICAgICAgICAgIC8vIERlc2NlbmQgaW50byBjaGlsZCBub2RlcyBmb3IgZXh0cmFjdGlvblxuICAgICAgICAgICAgICAgICAgdmlzaXRBbGwodGhpcywgZWwuY2hpbGRyZW4pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9tb2RlID09IF9WaXNpdG9yTW9kZS5NZXJnZSkge1xuICAgICAgICAgICAgICAgICAgLy8gVHJhbnNsYXRlIGF0dHJpYnV0ZXMgaW4gSUNVIG1lc3NhZ2VzXG4gICAgICAgICAgICAgICAgICBjaGlsZE5vZGVzID0gW107XG4gICAgICAgICAgICAgICAgICBlbC5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciB2aXNpdGVkID0gY2hpbGQudmlzaXQoX3RoaXMsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgIGlmICh2aXNpdGVkICYmICFfdGhpcy5faXNJblRyYW5zbGF0YWJsZVNlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG8gbm90IGFkZCB0aGUgY2hpbGRyZW4gZnJvbSB0cmFuc2xhdGFibGUgc2VjdGlvbnMgKD0gaTE4biBibG9ja3MgaGVyZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhleSB3aWxsIGJlIGFkZGVkIHdoZW4gdGhlIHNlY3Rpb24gaXMgY2xvc2UgKGkuZS4gb24gYDwhLS0gL2kxOG4gLS0+YClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGROb2RlcyA9IGNoaWxkTm9kZXMuY29uY2F0KHZpc2l0ZWQpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3Zpc2l0QXR0cmlidXRlc09mKGVsKTtcbiAgICAgICAgICB0aGlzLl9kZXB0aC0tO1xuICAgICAgICAgIHRoaXMuX2luSTE4bk5vZGUgPSB3YXNJbkkxOG5Ob2RlO1xuICAgICAgICAgIHRoaXMuX2luSW1wbGljaXROb2RlID0gd2FzSW5JbXBsaWNpdE5vZGU7XG4gICAgICAgICAgaWYgKHRoaXMuX21vZGUgPT09IF9WaXNpdG9yTW9kZS5NZXJnZSkge1xuICAgICAgICAgICAgICAvLyBUaGVyZSBhcmUgbm8gY2hpbGROb2RlcyBpbiB0cmFuc2xhdGFibGUgc2VjdGlvbnMgLSB0aG9zZSBub2RlcyB3aWxsIGJlIHJlcGxhY2UgYW55d2F5XG4gICAgICAgICAgICAgIHZhciB0cmFuc2xhdGVkQXR0cnMgPSB0aGlzLl90cmFuc2xhdGVBdHRyaWJ1dGVzKGVsKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFbGVtZW50KGVsLm5hbWUsIHRyYW5zbGF0ZWRBdHRycywgY2hpbGROb2RlcywgZWwuc291cmNlU3BhbiwgZWwuc3RhcnRTb3VyY2VTcGFuLCBlbC5lbmRTb3VyY2VTcGFuKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgX1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0QXR0cmlidXRlID0gZnVuY3Rpb24gKGF0dHJpYnV0ZSwgY29udGV4dCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5yZWFjaGFibGUgY29kZScpO1xuICAgICAgfTtcbiAgICAgIF9WaXNpdG9yLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIChtb2RlLCBpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgICAgdGhpcy5fbW9kZSA9IG1vZGU7XG4gICAgICAgICAgdGhpcy5faW5JMThuQmxvY2sgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLl9pbkkxOG5Ob2RlID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5fZGVwdGggPSAwO1xuICAgICAgICAgIHRoaXMuX2luSWN1ID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5fbXNnQ291bnRBdFNlY3Rpb25TdGFydCA9IHZvaWQgMDtcbiAgICAgICAgICB0aGlzLl9lcnJvcnMgPSBbXTtcbiAgICAgICAgICB0aGlzLl9tZXNzYWdlcyA9IFtdO1xuICAgICAgICAgIHRoaXMuX2luSW1wbGljaXROb2RlID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5fY3JlYXRlSTE4bk1lc3NhZ2UgPSBjcmVhdGVJMThuTWVzc2FnZUZhY3RvcnkoaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICB9O1xuICAgICAgLy8gbG9va3MgZm9yIHRyYW5zbGF0YWJsZSBhdHRyaWJ1dGVzXG4gICAgICBfVmlzaXRvci5wcm90b3R5cGUuX3Zpc2l0QXR0cmlidXRlc09mID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgZXhwbGljaXRBdHRyTmFtZVRvVmFsdWUgPSB7fTtcbiAgICAgICAgICB2YXIgaW1wbGljaXRBdHRyTmFtZXMgPSB0aGlzLl9pbXBsaWNpdEF0dHJzW2VsLm5hbWVdIHx8IFtdO1xuICAgICAgICAgIGVsLmF0dHJzLmZpbHRlcihmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gYXR0ci5uYW1lLnN0YXJ0c1dpdGgoX0kxOE5fQVRUUl9QUkVGSVgpOyB9KVxuICAgICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gZXhwbGljaXRBdHRyTmFtZVRvVmFsdWVbYXR0ci5uYW1lLnNsaWNlKF9JMThOX0FUVFJfUFJFRklYLmxlbmd0aCldID1cbiAgICAgICAgICAgICAgYXR0ci52YWx1ZTsgfSk7XG4gICAgICAgICAgZWwuYXR0cnMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgICAgICBpZiAoYXR0ci5uYW1lIGluIGV4cGxpY2l0QXR0ck5hbWVUb1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICBfdGhpcy5fYWRkTWVzc2FnZShbYXR0cl0sIGV4cGxpY2l0QXR0ck5hbWVUb1ZhbHVlW2F0dHIubmFtZV0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKGltcGxpY2l0QXR0ck5hbWVzLnNvbWUoZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIGF0dHIubmFtZSA9PT0gbmFtZTsgfSkpIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzLl9hZGRNZXNzYWdlKFthdHRyXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICAvLyBhZGQgYSB0cmFuc2xhdGFibGUgbWVzc2FnZVxuICAgICAgX1Zpc2l0b3IucHJvdG90eXBlLl9hZGRNZXNzYWdlID0gZnVuY3Rpb24gKGFzdCwgbWVhbmluZ0FuZERlc2MpIHtcbiAgICAgICAgICBpZiAoYXN0Lmxlbmd0aCA9PSAwIHx8XG4gICAgICAgICAgICAgIGFzdC5sZW5ndGggPT0gMSAmJiBhc3RbMF0gaW5zdGFuY2VvZiBBdHRyaWJ1dGUkMSAmJiAhYXN0WzBdLnZhbHVlKSB7XG4gICAgICAgICAgICAgIC8vIERvIG5vdCBjcmVhdGUgZW1wdHkgbWVzc2FnZXNcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgX2EgPSBfc3BsaXRNZWFuaW5nQW5kRGVzYyhtZWFuaW5nQW5kRGVzYyksIG1lYW5pbmcgPSBfYVswXSwgZGVzY3JpcHRpb24gPSBfYVsxXTtcbiAgICAgICAgICB2YXIgbWVzc2FnZSA9IHRoaXMuX2NyZWF0ZUkxOG5NZXNzYWdlKGFzdCwgbWVhbmluZywgZGVzY3JpcHRpb24pO1xuICAgICAgICAgIHRoaXMuX21lc3NhZ2VzLnB1c2gobWVzc2FnZSk7XG4gICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICB9O1xuICAgICAgLy8gVHJhbnNsYXRlcyB0aGUgZ2l2ZW4gbWVzc2FnZSBnaXZlbiB0aGUgYFRyYW5zbGF0aW9uQnVuZGxlYFxuICAgICAgLy8gbm8tb3Agd2hlbiBjYWxsZWQgaW4gZXh0cmFjdGlvbiBtb2RlIChyZXR1cm5zIFtdKVxuICAgICAgX1Zpc2l0b3IucHJvdG90eXBlLl90cmFuc2xhdGVNZXNzYWdlID0gZnVuY3Rpb24gKGVsLCBtZXNzYWdlKSB7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UgJiYgdGhpcy5fbW9kZSA9PT0gX1Zpc2l0b3JNb2RlLk1lcmdlKSB7XG4gICAgICAgICAgICAgIHZhciBpZCA9IGRpZ2VzdE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgICAgIHZhciBub2RlcyA9IHRoaXMuX3RyYW5zbGF0aW9ucy5nZXQoaWQpO1xuICAgICAgICAgICAgICBpZiAobm9kZXMpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlcztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihlbCwgXCJUcmFuc2xhdGlvbiB1bmF2YWlsYWJsZSBmb3IgbWVzc2FnZSBpZD1cXFwiXCIgKyBpZCArIFwiXFxcIlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfTtcbiAgICAgIC8vIHRyYW5zbGF0ZSB0aGUgYXR0cmlidXRlcyBvZiBhbiBlbGVtZW50IGFuZCByZW1vdmUgaTE4biBzcGVjaWZpYyBhdHRyaWJ1dGVzXG4gICAgICBfVmlzaXRvci5wcm90b3R5cGUuX3RyYW5zbGF0ZUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBhdHRyaWJ1dGVzID0gZWwuYXR0cnM7XG4gICAgICAgICAgdmFyIGkxOG5BdHRyaWJ1dGVNZWFuaW5ncyA9IHt9O1xuICAgICAgICAgIGF0dHJpYnV0ZXMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgICAgICBpZiAoYXR0ci5uYW1lLnN0YXJ0c1dpdGgoX0kxOE5fQVRUUl9QUkVGSVgpKSB7XG4gICAgICAgICAgICAgICAgICBpMThuQXR0cmlidXRlTWVhbmluZ3NbYXR0ci5uYW1lLnNsaWNlKF9JMThOX0FUVFJfUFJFRklYLmxlbmd0aCldID1cbiAgICAgICAgICAgICAgICAgICAgICBfc3BsaXRNZWFuaW5nQW5kRGVzYyhhdHRyLnZhbHVlKVswXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciB0cmFuc2xhdGVkQXR0cmlidXRlcyA9IFtdO1xuICAgICAgICAgIGF0dHJpYnV0ZXMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgICAgICBpZiAoYXR0ci5uYW1lID09PSBfSTE4Tl9BVFRSIHx8IGF0dHIubmFtZS5zdGFydHNXaXRoKF9JMThOX0FUVFJfUFJFRklYKSkge1xuICAgICAgICAgICAgICAgICAgLy8gc3RyaXAgaTE4biBzcGVjaWZpYyBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGF0dHIudmFsdWUgJiYgYXR0ci52YWx1ZSAhPSAnJyAmJiBpMThuQXR0cmlidXRlTWVhbmluZ3MuaGFzT3duUHJvcGVydHkoYXR0ci5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgdmFyIG1lYW5pbmcgPSBpMThuQXR0cmlidXRlTWVhbmluZ3NbYXR0ci5uYW1lXTtcbiAgICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gX3RoaXMuX2NyZWF0ZUkxOG5NZXNzYWdlKFthdHRyXSwgbWVhbmluZywgJycpO1xuICAgICAgICAgICAgICAgICAgdmFyIGlkID0gZGlnZXN0TWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgIHZhciBub2RlcyA9IF90aGlzLl90cmFuc2xhdGlvbnMuZ2V0KGlkKTtcbiAgICAgICAgICAgICAgICAgIGlmIChub2Rlcykge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChub2Rlc1swXSBpbnN0YW5jZW9mIFRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gbm9kZXNbMF0udmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZWRBdHRyaWJ1dGVzLnB1c2gobmV3IEF0dHJpYnV0ZSQxKGF0dHIubmFtZSwgdmFsdWUsIGF0dHIuc291cmNlU3BhbikpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlcG9ydEVycm9yKGVsLCBcIlVuZXhwZWN0ZWQgdHJhbnNsYXRpb24gZm9yIGF0dHJpYnV0ZSBcXFwiXCIgKyBhdHRyLm5hbWUgKyBcIlxcXCIgKGlkPVxcXCJcIiArIGlkICsgXCJcXFwiKVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVwb3J0RXJyb3IoZWwsIFwiVHJhbnNsYXRpb24gdW5hdmFpbGFibGUgZm9yIGF0dHJpYnV0ZSBcXFwiXCIgKyBhdHRyLm5hbWUgKyBcIlxcXCIgKGlkPVxcXCJcIiArIGlkICsgXCJcXFwiKVwiKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZWRBdHRyaWJ1dGVzLnB1c2goYXR0cik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gdHJhbnNsYXRlZEF0dHJpYnV0ZXM7XG4gICAgICB9O1xuICAgICAgLyoqXG4gICAgICAgKiBBZGQgdGhlIG5vZGUgYXMgYSBjaGlsZCBvZiB0aGUgYmxvY2sgd2hlbjpcbiAgICAgICAqIC0gd2UgYXJlIGluIGEgYmxvY2ssXG4gICAgICAgKiAtIHdlIGFyZSBub3QgaW5zaWRlIGEgSUNVIG1lc3NhZ2UgKHRob3NlIGFyZSBoYW5kbGVkIHNlcGFyYXRlbHkpLFxuICAgICAgICogLSB0aGUgbm9kZSBpcyBhIFwiZGlyZWN0IGNoaWxkXCIgb2YgdGhlIGJsb2NrXG4gICAgICAgKi9cbiAgICAgIF9WaXNpdG9yLnByb3RvdHlwZS5fbWF5QmVBZGRCbG9ja0NoaWxkcmVuID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICBpZiAodGhpcy5faW5JMThuQmxvY2sgJiYgIXRoaXMuX2luSWN1ICYmIHRoaXMuX2RlcHRoID09IHRoaXMuX2Jsb2NrU3RhcnREZXB0aCkge1xuICAgICAgICAgICAgICB0aGlzLl9ibG9ja0NoaWxkcmVuLnB1c2gobm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIC8qKlxuICAgICAgICogTWFya3MgdGhlIHN0YXJ0IG9mIGEgc2VjdGlvbiwgc2VlIGBfZW5kU2VjdGlvbmBcbiAgICAgICAqL1xuICAgICAgX1Zpc2l0b3IucHJvdG90eXBlLl9vcGVuVHJhbnNsYXRhYmxlU2VjdGlvbiA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2lzSW5UcmFuc2xhdGFibGVTZWN0aW9uKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKG5vZGUsICdVbmV4cGVjdGVkIHNlY3Rpb24gc3RhcnQnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuX21zZ0NvdW50QXRTZWN0aW9uU3RhcnQgPSB0aGlzLl9tZXNzYWdlcy5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfVmlzaXRvci5wcm90b3R5cGUsIFwiX2lzSW5UcmFuc2xhdGFibGVTZWN0aW9uXCIsIHtcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBBIHRyYW5zbGF0YWJsZSBzZWN0aW9uIGNvdWxkIGJlOlxuICAgICAgICAgICAqIC0gYSB0cmFuc2xhdGFibGUgZWxlbWVudCxcbiAgICAgICAgICAgKiAtIG5vZGVzIGJldHdlZW4gYDwhLS0gaTE4biAtLT5gIGFuZCBgPCEtLSAvaTE4biAtLT5gIGNvbW1lbnRzXG4gICAgICAgICAgICovXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tc2dDb3VudEF0U2VjdGlvblN0YXJ0ICE9PSB2b2lkIDA7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICAvKipcbiAgICAgICAqIFRlcm1pbmF0ZXMgYSBzZWN0aW9uLlxuICAgICAgICpcbiAgICAgICAqIElmIGEgc2VjdGlvbiBoYXMgb25seSBvbmUgc2lnbmlmaWNhbnQgY2hpbGRyZW4gKGNvbW1lbnRzIG5vdCBzaWduaWZpY2FudCkgdGhlbiB3ZSBzaG91bGQgbm90XG4gICAgICAgKiBrZWVwIHRoZSBtZXNzYWdlIGZyb20gdGhpcyBjaGlsZHJlbjpcbiAgICAgICAqXG4gICAgICAgKiBgPHAgaTE4bj1cIm1lYW5pbmd8ZGVzY3JpcHRpb25cIj57SUNVIG1lc3NhZ2V9PC9wPmAgd291bGQgcHJvZHVjZSB0d28gbWVzc2FnZXM6XG4gICAgICAgKiAtIG9uZSBmb3IgdGhlIDxwPiBjb250ZW50IHdpdGggbWVhbmluZyBhbmQgZGVzY3JpcHRpb24sXG4gICAgICAgKiAtIGFub3RoZXIgb25lIGZvciB0aGUgSUNVIG1lc3NhZ2UuXG4gICAgICAgKlxuICAgICAgICogSW4gdGhpcyBjYXNlIHRoZSBsYXN0IG1lc3NhZ2UgaXMgZGlzY2FyZGVkIGFzIGl0IGNvbnRhaW5zIGxlc3MgaW5mb3JtYXRpb24gKHRoZSBBU1QgaXNcbiAgICAgICAqIG90aGVyd2lzZSBpZGVudGljYWwpLlxuICAgICAgICpcbiAgICAgICAqIE5vdGUgdGhhdCB3ZSBzaG91bGQgc3RpbGwga2VlcCBtZXNzYWdlcyBleHRyYWN0ZWQgZnJvbSBhdHRyaWJ1dGVzIGluc2lkZSB0aGUgc2VjdGlvbiAoaWUgaW4gdGhlXG4gICAgICAgKiBJQ1UgbWVzc2FnZSBoZXJlKVxuICAgICAgICovXG4gICAgICBfVmlzaXRvci5wcm90b3R5cGUuX2Nsb3NlVHJhbnNsYXRhYmxlU2VjdGlvbiA9IGZ1bmN0aW9uIChub2RlLCBkaXJlY3RDaGlsZHJlbikge1xuICAgICAgICAgIGlmICghdGhpcy5faXNJblRyYW5zbGF0YWJsZVNlY3Rpb24pIHtcbiAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3Iobm9kZSwgJ1VuZXhwZWN0ZWQgc2VjdGlvbiBlbmQnKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgc3RhcnRJbmRleCA9IHRoaXMuX21zZ0NvdW50QXRTZWN0aW9uU3RhcnQ7XG4gICAgICAgICAgdmFyIHNpZ25pZmljYW50Q2hpbGRyZW4gPSBkaXJlY3RDaGlsZHJlbi5yZWR1Y2UoZnVuY3Rpb24gKGNvdW50LCBub2RlKSB7IHJldHVybiBjb3VudCArIChub2RlIGluc3RhbmNlb2YgQ29tbWVudCA/IDAgOiAxKTsgfSwgMCk7XG4gICAgICAgICAgaWYgKHNpZ25pZmljYW50Q2hpbGRyZW4gPT0gMSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5fbWVzc2FnZXMubGVuZ3RoIC0gMTsgaSA+PSBzdGFydEluZGV4OyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgIHZhciBhc3QgPSB0aGlzLl9tZXNzYWdlc1tpXS5ub2RlcztcbiAgICAgICAgICAgICAgICAgIGlmICghKGFzdC5sZW5ndGggPT0gMSAmJiBhc3RbMF0gaW5zdGFuY2VvZiBUZXh0JDEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVzc2FnZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX21zZ0NvdW50QXRTZWN0aW9uU3RhcnQgPSB2b2lkIDA7XG4gICAgICB9O1xuICAgICAgX1Zpc2l0b3IucHJvdG90eXBlLl9yZXBvcnRFcnJvciA9IGZ1bmN0aW9uIChub2RlLCBtc2cpIHtcbiAgICAgICAgICB0aGlzLl9lcnJvcnMucHVzaChuZXcgSTE4bkVycm9yKG5vZGUuc291cmNlU3BhbiwgbXNnKSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIF9WaXNpdG9yO1xuICB9KCkpO1xuICBmdW5jdGlvbiBfaXNPcGVuaW5nQ29tbWVudChuKSB7XG4gICAgICByZXR1cm4gbiBpbnN0YW5jZW9mIENvbW1lbnQgJiYgbi52YWx1ZSAmJiBuLnZhbHVlLnN0YXJ0c1dpdGgoJ2kxOG4nKTtcbiAgfVxuICBmdW5jdGlvbiBfaXNDbG9zaW5nQ29tbWVudChuKSB7XG4gICAgICByZXR1cm4gbiBpbnN0YW5jZW9mIENvbW1lbnQgJiYgbi52YWx1ZSAmJiBuLnZhbHVlID09PSAnL2kxOG4nO1xuICB9XG4gIGZ1bmN0aW9uIF9nZXRJMThuQXR0cihwKSB7XG4gICAgICByZXR1cm4gcC5hdHRycy5maW5kKGZ1bmN0aW9uIChhdHRyKSB7IHJldHVybiBhdHRyLm5hbWUgPT09IF9JMThOX0FUVFI7IH0pIHx8IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gX3NwbGl0TWVhbmluZ0FuZERlc2MoaTE4bikge1xuICAgICAgaWYgKCFpMThuKVxuICAgICAgICAgIHJldHVybiBbJycsICcnXTtcbiAgICAgIHZhciBwaXBlSW5kZXggPSBpMThuLmluZGV4T2YoJ3wnKTtcbiAgICAgIHJldHVybiBwaXBlSW5kZXggPT0gLTEgPyBbJycsIGkxOG5dIDogW2kxOG4uc2xpY2UoMCwgcGlwZUluZGV4KSwgaTE4bi5zbGljZShwaXBlSW5kZXggKyAxKV07XG4gIH1cblxuICAvKipcbiAgICogQSBjb250YWluZXIgZm9yIG1lc3NhZ2UgZXh0cmFjdGVkIGZyb20gdGhlIHRlbXBsYXRlcy5cbiAgICovXG4gIHZhciBNZXNzYWdlQnVuZGxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIE1lc3NhZ2VCdW5kbGUoX2h0bWxQYXJzZXIsIF9pbXBsaWNpdFRhZ3MsIF9pbXBsaWNpdEF0dHJzKSB7XG4gICAgICAgICAgdGhpcy5faHRtbFBhcnNlciA9IF9odG1sUGFyc2VyO1xuICAgICAgICAgIHRoaXMuX2ltcGxpY2l0VGFncyA9IF9pbXBsaWNpdFRhZ3M7XG4gICAgICAgICAgdGhpcy5faW1wbGljaXRBdHRycyA9IF9pbXBsaWNpdEF0dHJzO1xuICAgICAgICAgIHRoaXMuX21lc3NhZ2VNYXAgPSB7fTtcbiAgICAgIH1cbiAgICAgIE1lc3NhZ2VCdW5kbGUucHJvdG90eXBlLnVwZGF0ZUZyb21UZW1wbGF0ZSA9IGZ1bmN0aW9uIChodG1sLCB1cmwsIGludGVycG9sYXRpb25Db25maWcpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBodG1sUGFyc2VyUmVzdWx0ID0gdGhpcy5faHRtbFBhcnNlci5wYXJzZShodG1sLCB1cmwsIHRydWUsIGludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICAgIGlmIChodG1sUGFyc2VyUmVzdWx0LmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGh0bWxQYXJzZXJSZXN1bHQuZXJyb3JzO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgaTE4blBhcnNlclJlc3VsdCA9IGV4dHJhY3RNZXNzYWdlcyhodG1sUGFyc2VyUmVzdWx0LnJvb3ROb2RlcywgaW50ZXJwb2xhdGlvbkNvbmZpZywgdGhpcy5faW1wbGljaXRUYWdzLCB0aGlzLl9pbXBsaWNpdEF0dHJzKTtcbiAgICAgICAgICBpZiAoaTE4blBhcnNlclJlc3VsdC5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpMThuUGFyc2VyUmVzdWx0LmVycm9ycztcbiAgICAgICAgICB9XG4gICAgICAgICAgaTE4blBhcnNlclJlc3VsdC5tZXNzYWdlcy5mb3JFYWNoKGZ1bmN0aW9uIChtZXNzYWdlKSB7IF90aGlzLl9tZXNzYWdlTWFwW2RpZ2VzdE1lc3NhZ2UobWVzc2FnZSldID0gbWVzc2FnZTsgfSk7XG4gICAgICB9O1xuICAgICAgTWVzc2FnZUJ1bmRsZS5wcm90b3R5cGUuZ2V0TWVzc2FnZU1hcCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX21lc3NhZ2VNYXA7IH07XG4gICAgICBNZXNzYWdlQnVuZGxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChzZXJpYWxpemVyKSB7IHJldHVybiBzZXJpYWxpemVyLndyaXRlKHRoaXMuX21lc3NhZ2VNYXApOyB9O1xuICAgICAgcmV0dXJuIE1lc3NhZ2VCdW5kbGU7XG4gIH0oKSk7XG5cbiAgdmFyIFhtbFRhZ0RlZmluaXRpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gWG1sVGFnRGVmaW5pdGlvbigpIHtcbiAgICAgICAgICB0aGlzLmNsb3NlZEJ5UGFyZW50ID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5jb250ZW50VHlwZSA9IFRhZ0NvbnRlbnRUeXBlLlBBUlNBQkxFX0RBVEE7XG4gICAgICAgICAgdGhpcy5pc1ZvaWQgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmlnbm9yZUZpcnN0TGYgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmNhblNlbGZDbG9zZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBYbWxUYWdEZWZpbml0aW9uLnByb3RvdHlwZS5yZXF1aXJlRXh0cmFQYXJlbnQgPSBmdW5jdGlvbiAoY3VycmVudFBhcmVudCkgeyByZXR1cm4gZmFsc2U7IH07XG4gICAgICBYbWxUYWdEZWZpbml0aW9uLnByb3RvdHlwZS5pc0Nsb3NlZEJ5Q2hpbGQgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gZmFsc2U7IH07XG4gICAgICByZXR1cm4gWG1sVGFnRGVmaW5pdGlvbjtcbiAgfSgpKTtcbiAgdmFyIF9UQUdfREVGSU5JVElPTiA9IG5ldyBYbWxUYWdEZWZpbml0aW9uKCk7XG4gIGZ1bmN0aW9uIGdldFhtbFRhZ0RlZmluaXRpb24odGFnTmFtZSkge1xuICAgICAgcmV0dXJuIF9UQUdfREVGSU5JVElPTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbGljZW5zZVxuICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICpcbiAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgKi9cbiAgdmFyIF9fZXh0ZW5kcyQ3ID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICB9O1xuICB2YXIgWG1sUGFyc2VyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQ3KFhtbFBhcnNlciwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIFhtbFBhcnNlcigpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBnZXRYbWxUYWdEZWZpbml0aW9uKTtcbiAgICAgIH1cbiAgICAgIFhtbFBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoc291cmNlLCB1cmwsIHBhcnNlRXhwYW5zaW9uRm9ybXMpIHtcbiAgICAgICAgICBpZiAocGFyc2VFeHBhbnNpb25Gb3JtcyA9PT0gdm9pZCAwKSB7IHBhcnNlRXhwYW5zaW9uRm9ybXMgPSBmYWxzZTsgfVxuICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnBhcnNlLmNhbGwodGhpcywgc291cmNlLCB1cmwsIHBhcnNlRXhwYW5zaW9uRm9ybXMsIG51bGwpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBYbWxQYXJzZXI7XG4gIH0oUGFyc2VyJDEpKTtcblxuICAvKipcbiAgICogQGxpY2Vuc2VcbiAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAqXG4gICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICovXG4gIC8vIEdlbmVyYXRlIGEgbWFwIG9mIHBsYWNlaG9sZGVyIHRvIGNvbnRlbnQgaW5kZXhlZCBieSBtZXNzYWdlIGlkc1xuICBmdW5jdGlvbiBleHRyYWN0UGxhY2Vob2xkZXJzKG1lc3NhZ2VCdW5kbGUpIHtcbiAgICAgIHZhciBtZXNzYWdlTWFwID0gbWVzc2FnZUJ1bmRsZS5nZXRNZXNzYWdlTWFwKCk7XG4gICAgICB2YXIgcGxhY2Vob2xkZXJzID0ge307XG4gICAgICBPYmplY3Qua2V5cyhtZXNzYWdlTWFwKS5mb3JFYWNoKGZ1bmN0aW9uIChtc2dJZCkge1xuICAgICAgICAgIHBsYWNlaG9sZGVyc1ttc2dJZF0gPSBtZXNzYWdlTWFwW21zZ0lkXS5wbGFjZWhvbGRlcnM7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwbGFjZWhvbGRlcnM7XG4gIH1cbiAgLy8gR2VuZXJhdGUgYSBtYXAgb2YgcGxhY2Vob2xkZXIgdG8gbWVzc2FnZSBpZHMgaW5kZXhlZCBieSBtZXNzYWdlIGlkc1xuICBmdW5jdGlvbiBleHRyYWN0UGxhY2Vob2xkZXJUb0lkcyhtZXNzYWdlQnVuZGxlKSB7XG4gICAgICB2YXIgbWVzc2FnZU1hcCA9IG1lc3NhZ2VCdW5kbGUuZ2V0TWVzc2FnZU1hcCgpO1xuICAgICAgdmFyIHBsYWNlaG9sZGVyVG9JZHMgPSB7fTtcbiAgICAgIE9iamVjdC5rZXlzKG1lc3NhZ2VNYXApLmZvckVhY2goZnVuY3Rpb24gKG1zZ0lkKSB7XG4gICAgICAgICAgcGxhY2Vob2xkZXJUb0lkc1ttc2dJZF0gPSBtZXNzYWdlTWFwW21zZ0lkXS5wbGFjZWhvbGRlclRvTXNnSWRzO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcGxhY2Vob2xkZXJUb0lkcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAbGljZW5zZVxuICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICpcbiAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgKi9cbiAgdmFyIF9fZXh0ZW5kcyQ4ID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICB9O1xuICB2YXIgX1Zpc2l0b3IkMSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBfVmlzaXRvcigpIHtcbiAgICAgIH1cbiAgICAgIF9WaXNpdG9yLnByb3RvdHlwZS52aXNpdFRhZyA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBzdHJBdHRycyA9IHRoaXMuX3NlcmlhbGl6ZUF0dHJpYnV0ZXModGFnLmF0dHJzKTtcbiAgICAgICAgICBpZiAodGFnLmNoaWxkcmVuLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiBcIjxcIiArIHRhZy5uYW1lICsgc3RyQXR0cnMgKyBcIi8+XCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBzdHJDaGlsZHJlbiA9IHRhZy5jaGlsZHJlbi5tYXAoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUudmlzaXQoX3RoaXMpOyB9KTtcbiAgICAgICAgICByZXR1cm4gXCI8XCIgKyB0YWcubmFtZSArIHN0ckF0dHJzICsgXCI+XCIgKyBzdHJDaGlsZHJlbi5qb2luKCcnKSArIFwiPC9cIiArIHRhZy5uYW1lICsgXCI+XCI7XG4gICAgICB9O1xuICAgICAgX1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0KSB7IHJldHVybiB0ZXh0LnZhbHVlOyB9O1xuICAgICAgX1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0RGVjbGFyYXRpb24gPSBmdW5jdGlvbiAoZGVjbCkge1xuICAgICAgICAgIHJldHVybiBcIjw/eG1sXCIgKyB0aGlzLl9zZXJpYWxpemVBdHRyaWJ1dGVzKGRlY2wuYXR0cnMpICsgXCIgPz5cIjtcbiAgICAgIH07XG4gICAgICBfVmlzaXRvci5wcm90b3R5cGUuX3NlcmlhbGl6ZUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoYXR0cnMpIHtcbiAgICAgICAgICB2YXIgc3RyQXR0cnMgPSBPYmplY3Qua2V5cyhhdHRycykubWFwKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiAobmFtZSArIFwiPVxcXCJcIiArIGF0dHJzW25hbWVdICsgXCJcXFwiXCIpOyB9KS5qb2luKCcgJyk7XG4gICAgICAgICAgcmV0dXJuIHN0ckF0dHJzLmxlbmd0aCA+IDAgPyAnICcgKyBzdHJBdHRycyA6ICcnO1xuICAgICAgfTtcbiAgICAgIF9WaXNpdG9yLnByb3RvdHlwZS52aXNpdERvY3R5cGUgPSBmdW5jdGlvbiAoZG9jdHlwZSkge1xuICAgICAgICAgIHJldHVybiBcIjwhRE9DVFlQRSBcIiArIGRvY3R5cGUucm9vdFRhZyArIFwiIFtcXG5cIiArIGRvY3R5cGUuZHRkICsgXCJcXG5dPlwiO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBfVmlzaXRvcjtcbiAgfSgpKTtcbiAgdmFyIF92aXNpdG9yID0gbmV3IF9WaXNpdG9yJDEoKTtcbiAgZnVuY3Rpb24gc2VyaWFsaXplKG5vZGVzKSB7XG4gICAgICByZXR1cm4gbm9kZXMubWFwKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLnZpc2l0KF92aXNpdG9yKTsgfSkuam9pbignJyk7XG4gIH1cbiAgdmFyIERlY2xhcmF0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIERlY2xhcmF0aW9uKHVuZXNjYXBlZEF0dHJzKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB0aGlzLmF0dHJzID0ge307XG4gICAgICAgICAgT2JqZWN0LmtleXModW5lc2NhcGVkQXR0cnMpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgICAgX3RoaXMuYXR0cnNba10gPSBfZXNjYXBlWG1sKHVuZXNjYXBlZEF0dHJzW2tdKTtcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIERlY2xhcmF0aW9uLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7IHJldHVybiB2aXNpdG9yLnZpc2l0RGVjbGFyYXRpb24odGhpcyk7IH07XG4gICAgICByZXR1cm4gRGVjbGFyYXRpb247XG4gIH0oKSk7XG4gIHZhciBEb2N0eXBlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIERvY3R5cGUocm9vdFRhZywgZHRkKSB7XG4gICAgICAgICAgdGhpcy5yb290VGFnID0gcm9vdFRhZztcbiAgICAgICAgICB0aGlzLmR0ZCA9IGR0ZDtcbiAgICAgIH1cbiAgICAgIDtcbiAgICAgIERvY3R5cGUucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXREb2N0eXBlKHRoaXMpOyB9O1xuICAgICAgcmV0dXJuIERvY3R5cGU7XG4gIH0oKSk7XG4gIHZhciBUYWcgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gVGFnKG5hbWUsIHVuZXNjYXBlZEF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgaWYgKHVuZXNjYXBlZEF0dHJzID09PSB2b2lkIDApIHsgdW5lc2NhcGVkQXR0cnMgPSB7fTsgfVxuICAgICAgICAgIGlmIChjaGlsZHJlbiA9PT0gdm9pZCAwKSB7IGNoaWxkcmVuID0gW107IH1cbiAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgICB0aGlzLmF0dHJzID0ge307XG4gICAgICAgICAgT2JqZWN0LmtleXModW5lc2NhcGVkQXR0cnMpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgICAgX3RoaXMuYXR0cnNba10gPSBfZXNjYXBlWG1sKHVuZXNjYXBlZEF0dHJzW2tdKTtcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIFRhZy5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvcikgeyByZXR1cm4gdmlzaXRvci52aXNpdFRhZyh0aGlzKTsgfTtcbiAgICAgIHJldHVybiBUYWc7XG4gIH0oKSk7XG4gIHZhciBUZXh0JDIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gVGV4dCh1bmVzY2FwZWRWYWx1ZSkge1xuICAgICAgICAgIHRoaXMudmFsdWUgPSBfZXNjYXBlWG1sKHVuZXNjYXBlZFZhbHVlKTtcbiAgICAgIH1cbiAgICAgIDtcbiAgICAgIFRleHQucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRUZXh0KHRoaXMpOyB9O1xuICAgICAgcmV0dXJuIFRleHQ7XG4gIH0oKSk7XG4gIHZhciBDUiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkOChDUiwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIENSKHdzKSB7XG4gICAgICAgICAgaWYgKHdzID09PSB2b2lkIDApIHsgd3MgPSAwOyB9XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgXCJcXG5cIiArIG5ldyBBcnJheSh3cyArIDEpLmpvaW4oJyAnKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gQ1I7XG4gIH0oVGV4dCQyKSk7XG4gIHZhciBfRVNDQVBFRF9DSEFSUyA9IFtcbiAgICAgIFsvJi9nLCAnJmFtcDsnXSxcbiAgICAgIFsvXCIvZywgJyZxdW90OyddLFxuICAgICAgWy8nL2csICcmYXBvczsnXSxcbiAgICAgIFsvPC9nLCAnJmx0OyddLFxuICAgICAgWy8+L2csICcmZ3Q7J10sXG4gIF07XG4gIGZ1bmN0aW9uIF9lc2NhcGVYbWwodGV4dCkge1xuICAgICAgcmV0dXJuIF9FU0NBUEVEX0NIQVJTLnJlZHVjZShmdW5jdGlvbiAodGV4dCwgZW50cnkpIHsgcmV0dXJuIHRleHQucmVwbGFjZShlbnRyeVswXSwgZW50cnlbMV0pOyB9LCB0ZXh0KTtcbiAgfVxuXG4gIHZhciBfVkVSU0lPTiA9ICcxLjInO1xuICB2YXIgX1hNTE5TID0gJ3VybjpvYXNpczpuYW1lczp0Yzp4bGlmZjpkb2N1bWVudDoxLjInO1xuICAvLyBUT0RPKHZpY2IpOiBtYWtlIHRoaXMgYSBwYXJhbSAocy9fLy0vKVxuICB2YXIgX1NPVVJDRV9MQU5HID0gJ2VuJztcbiAgdmFyIF9QTEFDRUhPTERFUl9UQUcgPSAneCc7XG4gIHZhciBfU09VUkNFX1RBRyA9ICdzb3VyY2UnO1xuICB2YXIgX1RBUkdFVF9UQUcgPSAndGFyZ2V0JztcbiAgdmFyIF9VTklUX1RBRyA9ICd0cmFucy11bml0JztcbiAgLy8gaHR0cDovL2RvY3Mub2FzaXMtb3Blbi5vcmcveGxpZmYvdjEuMi9vcy94bGlmZi1jb3JlLmh0bWxcbiAgLy8gaHR0cDovL2RvY3Mub2FzaXMtb3Blbi5vcmcveGxpZmYvdjEuMi94bGlmZi1wcm9maWxlLWh0bWwveGxpZmYtcHJvZmlsZS1odG1sLTEuMi5odG1sXG4gIHZhciBYbGlmZiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBYbGlmZihfaHRtbFBhcnNlciwgX2ludGVycG9sYXRpb25Db25maWcpIHtcbiAgICAgICAgICB0aGlzLl9odG1sUGFyc2VyID0gX2h0bWxQYXJzZXI7XG4gICAgICAgICAgdGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZyA9IF9pbnRlcnBvbGF0aW9uQ29uZmlnO1xuICAgICAgfVxuICAgICAgWGxpZmYucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKG1lc3NhZ2VNYXApIHtcbiAgICAgICAgICB2YXIgdmlzaXRvciA9IG5ldyBfV3JpdGVWaXNpdG9yKCk7XG4gICAgICAgICAgdmFyIHRyYW5zVW5pdHMgPSBbXTtcbiAgICAgICAgICBPYmplY3Qua2V5cyhtZXNzYWdlTWFwKS5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IG1lc3NhZ2VNYXBbaWRdO1xuICAgICAgICAgICAgICB2YXIgdHJhbnNVbml0ID0gbmV3IFRhZyhfVU5JVF9UQUcsIHsgaWQ6IGlkLCBkYXRhdHlwZTogJ2h0bWwnIH0pO1xuICAgICAgICAgICAgICB0cmFuc1VuaXQuY2hpbGRyZW4ucHVzaChuZXcgQ1IoOCksIG5ldyBUYWcoX1NPVVJDRV9UQUcsIHt9LCB2aXNpdG9yLnNlcmlhbGl6ZShtZXNzYWdlLm5vZGVzKSksIG5ldyBDUig4KSwgbmV3IFRhZyhfVEFSR0VUX1RBRykpO1xuICAgICAgICAgICAgICBpZiAobWVzc2FnZS5kZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgICAgdHJhbnNVbml0LmNoaWxkcmVuLnB1c2gobmV3IENSKDgpLCBuZXcgVGFnKCdub3RlJywgeyBwcmlvcml0eTogJzEnLCBmcm9tOiAnZGVzY3JpcHRpb24nIH0sIFtuZXcgVGV4dCQyKG1lc3NhZ2UuZGVzY3JpcHRpb24pXSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChtZXNzYWdlLm1lYW5pbmcpIHtcbiAgICAgICAgICAgICAgICAgIHRyYW5zVW5pdC5jaGlsZHJlbi5wdXNoKG5ldyBDUig4KSwgbmV3IFRhZygnbm90ZScsIHsgcHJpb3JpdHk6ICcxJywgZnJvbTogJ21lYW5pbmcnIH0sIFtuZXcgVGV4dCQyKG1lc3NhZ2UubWVhbmluZyldKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdHJhbnNVbml0LmNoaWxkcmVuLnB1c2gobmV3IENSKDYpKTtcbiAgICAgICAgICAgICAgdHJhbnNVbml0cy5wdXNoKG5ldyBDUig2KSwgdHJhbnNVbml0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgYm9keSA9IG5ldyBUYWcoJ2JvZHknLCB7fSwgdHJhbnNVbml0cy5jb25jYXQoW25ldyBDUig0KV0pKTtcbiAgICAgICAgICB2YXIgZmlsZSA9IG5ldyBUYWcoJ2ZpbGUnLCB7ICdzb3VyY2UtbGFuZ3VhZ2UnOiBfU09VUkNFX0xBTkcsIGRhdGF0eXBlOiAncGxhaW50ZXh0Jywgb3JpZ2luYWw6ICduZzIudGVtcGxhdGUnIH0sIFtuZXcgQ1IoNCksIGJvZHksIG5ldyBDUigyKV0pO1xuICAgICAgICAgIHZhciB4bGlmZiA9IG5ldyBUYWcoJ3hsaWZmJywgeyB2ZXJzaW9uOiBfVkVSU0lPTiwgeG1sbnM6IF9YTUxOUyB9LCBbbmV3IENSKDIpLCBmaWxlLCBuZXcgQ1IoKV0pO1xuICAgICAgICAgIHJldHVybiBzZXJpYWxpemUoW1xuICAgICAgICAgICAgICBuZXcgRGVjbGFyYXRpb24oeyB2ZXJzaW9uOiAnMS4wJywgZW5jb2Rpbmc6ICdVVEYtOCcgfSksIG5ldyBDUigpLCB4bGlmZiwgbmV3IENSKClcbiAgICAgICAgICBdKTtcbiAgICAgIH07XG4gICAgICBYbGlmZi5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChjb250ZW50LCB1cmwsIG1lc3NhZ2VCdW5kbGUpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIC8vIFBhcnNlIHRoZSB4dGIgZmlsZSBpbnRvIHhtbCBub2Rlc1xuICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgWG1sUGFyc2VyKCkucGFyc2UoY29udGVudCwgdXJsKTtcbiAgICAgICAgICBpZiAocmVzdWx0LmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwieHRiIHBhcnNlIGVycm9yczpcXG5cIiArIHJlc3VsdC5lcnJvcnMuam9pbignXFxuJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBSZXBsYWNlIHRoZSBwbGFjZWhvbGRlcnMsIG1lc3NhZ2VzIGFyZSBub3cgc3RyaW5nXG4gICAgICAgICAgdmFyIF9hID0gbmV3IF9Mb2FkVmlzaXRvcigpLnBhcnNlKHJlc3VsdC5yb290Tm9kZXMsIG1lc3NhZ2VCdW5kbGUpLCBtZXNzYWdlcyA9IF9hLm1lc3NhZ2VzLCBlcnJvcnMgPSBfYS5lcnJvcnM7XG4gICAgICAgICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwieHRiIHBhcnNlIGVycm9yczpcXG5cIiArIGVycm9ycy5qb2luKCdcXG4nKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIENvbnZlcnQgdGhlIHN0cmluZyBtZXNzYWdlcyB0byBodG1sIGFzdFxuICAgICAgICAgIC8vIFRPRE8odmljYik6IG1hcCBlcnJvciBtZXNzYWdlIGJhY2sgdG8gdGhlIG9yaWdpbmFsIG1lc3NhZ2UgaW4geHRiXG4gICAgICAgICAgdmFyIG1lc3NhZ2VNYXAgPSB7fTtcbiAgICAgICAgICB2YXIgcGFyc2VFcnJvcnMgPSBbXTtcbiAgICAgICAgICBPYmplY3Qua2V5cyhtZXNzYWdlcykuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgICAgdmFyIHJlcyA9IF90aGlzLl9odG1sUGFyc2VyLnBhcnNlKG1lc3NhZ2VzW2lkXSwgdXJsLCB0cnVlLCBfdGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICAgICAgICAgIHBhcnNlRXJyb3JzLnB1c2guYXBwbHkocGFyc2VFcnJvcnMsIHJlcy5lcnJvcnMpO1xuICAgICAgICAgICAgICBtZXNzYWdlTWFwW2lkXSA9IHJlcy5yb290Tm9kZXM7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHBhcnNlRXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ4dGIgcGFyc2UgZXJyb3JzOlxcblwiICsgcGFyc2VFcnJvcnMuam9pbignXFxuJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWVzc2FnZU1hcDtcbiAgICAgIH07XG4gICAgICByZXR1cm4gWGxpZmY7XG4gIH0oKSk7XG4gIHZhciBfV3JpdGVWaXNpdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIF9Xcml0ZVZpc2l0b3IoKSB7XG4gICAgICB9XG4gICAgICBfV3JpdGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAodGV4dCwgY29udGV4dCkgeyByZXR1cm4gW25ldyBUZXh0JDIodGV4dC52YWx1ZSldOyB9O1xuICAgICAgX1dyaXRlVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb250YWluZXIgPSBmdW5jdGlvbiAoY29udGFpbmVyLCBjb250ZXh0KSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgbm9kZXMgPSBbXTtcbiAgICAgICAgICBjb250YWluZXIuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZXMucHVzaC5hcHBseShub2Rlcywgbm9kZS52aXNpdChfdGhpcykpOyB9KTtcbiAgICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgICB9O1xuICAgICAgX1dyaXRlVmlzaXRvci5wcm90b3R5cGUudmlzaXRJY3UgPSBmdW5jdGlvbiAoaWN1LCBjb250ZXh0KSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2lzSW5JY3UpIHtcbiAgICAgICAgICAgICAgLy8gbmVzdGVkIElDVSBpcyBub3Qgc3VwcG9ydGVkXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneGxpZmYgZG9lcyBub3Qgc3VwcG9ydCBuZXN0ZWQgSUNVIG1lc3NhZ2VzJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX2lzSW5JY3UgPSB0cnVlO1xuICAgICAgICAgIC8vIFRPRE8odmljYik6IHN1cHBvcnQgSUNVIG1lc3NhZ2VzXG4gICAgICAgICAgLy8gaHR0cHM6Ly9saXN0cy5vYXNpcy1vcGVuLm9yZy9hcmNoaXZlcy94bGlmZi8yMDEyMDEvbXNnMDAwMjguaHRtbFxuICAgICAgICAgIC8vIGh0dHA6Ly9kb2NzLm9hc2lzLW9wZW4ub3JnL3hsaWZmL3YxLjIveGxpZmYtcHJvZmlsZS1wby94bGlmZi1wcm9maWxlLXBvLTEuMi1jZDAyLmh0bWxcbiAgICAgICAgICB2YXIgbm9kZXMgPSBbXTtcbiAgICAgICAgICB0aGlzLl9pc0luSWN1ID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgICAgfTtcbiAgICAgIF9Xcml0ZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGFnUGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHtcbiAgICAgICAgICB2YXIgY3R5cGUgPSBnZXRDdHlwZUZvclRhZyhwaC50YWcpO1xuICAgICAgICAgIHZhciBzdGFydFRhZ1BoID0gbmV3IFRhZyhfUExBQ0VIT0xERVJfVEFHLCB7IGlkOiBwaC5zdGFydE5hbWUsIGN0eXBlOiBjdHlwZSB9KTtcbiAgICAgICAgICBpZiAocGguaXNWb2lkKSB7XG4gICAgICAgICAgICAgIC8vIHZvaWQgdGFncyBoYXZlIG5vIGNoaWxkcmVuIG5vciBjbG9zaW5nIHRhZ3NcbiAgICAgICAgICAgICAgcmV0dXJuIFtzdGFydFRhZ1BoXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGNsb3NlVGFnUGggPSBuZXcgVGFnKF9QTEFDRUhPTERFUl9UQUcsIHsgaWQ6IHBoLmNsb3NlTmFtZSwgY3R5cGU6IGN0eXBlIH0pO1xuICAgICAgICAgIHJldHVybiBbc3RhcnRUYWdQaF0uY29uY2F0KHRoaXMuc2VyaWFsaXplKHBoLmNoaWxkcmVuKSwgW2Nsb3NlVGFnUGhdKTtcbiAgICAgIH07XG4gICAgICBfV3JpdGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdFBsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHBoLCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIFtuZXcgVGFnKF9QTEFDRUhPTERFUl9UQUcsIHsgaWQ6IHBoLm5hbWUgfSldO1xuICAgICAgfTtcbiAgICAgIF9Xcml0ZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0SWN1UGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gW25ldyBUYWcoX1BMQUNFSE9MREVSX1RBRywgeyBpZDogcGgubmFtZSB9KV07XG4gICAgICB9O1xuICAgICAgX1dyaXRlVmlzaXRvci5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKG5vZGVzKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB0aGlzLl9pc0luSWN1ID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIExpc3RXcmFwcGVyLmZsYXR0ZW4obm9kZXMubWFwKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLnZpc2l0KF90aGlzKTsgfSkpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBfV3JpdGVWaXNpdG9yO1xuICB9KCkpO1xuICAvLyBUT0RPKHZpY2IpOiBhZGQgZXJyb3IgbWFuYWdlbWVudCAoc3RydWN0dXJlKVxuICAvLyBUT0RPKHZpY2IpOiBmYWN0b3JpemUgKHh0YikgP1xuICB2YXIgX0xvYWRWaXNpdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIF9Mb2FkVmlzaXRvcigpIHtcbiAgICAgIH1cbiAgICAgIF9Mb2FkVmlzaXRvci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAobm9kZXMsIG1lc3NhZ2VCdW5kbGUpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHRoaXMuX21lc3NhZ2VOb2RlcyA9IFtdO1xuICAgICAgICAgIHRoaXMuX3RyYW5zbGF0ZWRNZXNzYWdlcyA9IHt9O1xuICAgICAgICAgIHRoaXMuX21zZ0lkID0gJyc7XG4gICAgICAgICAgdGhpcy5fdGFyZ2V0ID0gW107XG4gICAgICAgICAgdGhpcy5fZXJyb3JzID0gW107XG4gICAgICAgICAgLy8gRmluZCBhbGwgbWVzc2FnZXNcbiAgICAgICAgICB2aXNpdEFsbCh0aGlzLCBub2RlcywgbnVsbCk7XG4gICAgICAgICAgdmFyIG1lc3NhZ2VNYXAgPSBtZXNzYWdlQnVuZGxlLmdldE1lc3NhZ2VNYXAoKTtcbiAgICAgICAgICB2YXIgcGxhY2Vob2xkZXJzID0gZXh0cmFjdFBsYWNlaG9sZGVycyhtZXNzYWdlQnVuZGxlKTtcbiAgICAgICAgICB2YXIgcGxhY2Vob2xkZXJUb0lkcyA9IGV4dHJhY3RQbGFjZWhvbGRlclRvSWRzKG1lc3NhZ2VCdW5kbGUpO1xuICAgICAgICAgIHRoaXMuX21lc3NhZ2VOb2Rlc1xuICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICAgIC8vIFJlbW92ZSBhbnkgbWVzc2FnZXMgdGhhdCBpcyBub3QgcHJlc2VudCBpbiB0aGUgc291cmNlIG1lc3NhZ2UgYnVuZGxlLlxuICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZU1hcC5oYXNPd25Qcm9wZXJ0eShtZXNzYWdlWzBdKTtcbiAgICAgICAgICB9KVxuICAgICAgICAgICAgICAuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAvLyBCZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG5vIElDVSBwbGFjZWhvbGRlcnMgaW5zaWRlIGFuIElDVSBtZXNzYWdlLFxuICAgICAgICAgICAgICAvLyB3ZSBkbyBub3QgbmVlZCB0byB0YWtlIGludG8gYWNjb3VudCB0aGUgYHBsYWNlaG9sZGVyVG9Nc2dJZHNgIG9mIHRoZSByZWZlcmVuY2VkXG4gICAgICAgICAgICAgIC8vIG1lc3NhZ2VzLCB0aG9zZSB3b3VsZCBhbHdheXMgYmUgZW1wdHlcbiAgICAgICAgICAgICAgLy8gVE9ETyh2aWNiKTogb3ZlcmtpbGwgLSBjcmVhdGUgMiBidWNrZXRzIGFuZCBbLi4ud29EZXBzLCAuLi53RGVwc10ucHJvY2VzcygpXG4gICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhtZXNzYWdlTWFwW2FbMF1dLnBsYWNlaG9sZGVyVG9Nc2dJZHMpLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKG1lc3NhZ2VNYXBbYlswXV0ucGxhY2Vob2xkZXJUb01zZ0lkcykubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICAgIHZhciBpZCA9IG1lc3NhZ2VbMF07XG4gICAgICAgICAgICAgIF90aGlzLl9wbGFjZWhvbGRlcnMgPSBwbGFjZWhvbGRlcnNbaWRdIHx8IHt9O1xuICAgICAgICAgICAgICBfdGhpcy5fcGxhY2Vob2xkZXJUb0lkcyA9IHBsYWNlaG9sZGVyVG9JZHNbaWRdIHx8IHt9O1xuICAgICAgICAgICAgICAvLyBUT0RPKHZpY2IpOiBtYWtlIHN1cmUgdGhlcmUgaXMgbm8gYF9UUkFOU0xBVElPTlNfVEFHYCBub3IgYF9UUkFOU0xBVElPTl9UQUdgXG4gICAgICAgICAgICAgIF90aGlzLl90cmFuc2xhdGVkTWVzc2FnZXNbaWRdID0gdmlzaXRBbGwoX3RoaXMsIG1lc3NhZ2VbMV0pLmpvaW4oJycpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiB7IG1lc3NhZ2VzOiB0aGlzLl90cmFuc2xhdGVkTWVzc2FnZXMsIGVycm9yczogdGhpcy5fZXJyb3JzIH07XG4gICAgICB9O1xuICAgICAgX0xvYWRWaXNpdG9yLnByb3RvdHlwZS52aXNpdEVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCwgY29udGV4dCkge1xuICAgICAgICAgIHN3aXRjaCAoZWxlbWVudC5uYW1lKSB7XG4gICAgICAgICAgICAgIGNhc2UgX1VOSVRfVEFHOlxuICAgICAgICAgICAgICAgICAgdGhpcy5fdGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIHZhciBtc2dJZCA9IGVsZW1lbnQuYXR0cnMuZmluZChmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gYXR0ci5uYW1lID09PSAnaWQnOyB9KTtcbiAgICAgICAgICAgICAgICAgIGlmICghbXNnSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbGVtZW50LCBcIjxcIiArIF9VTklUX1RBRyArIFwiPiBtaXNzZXMgdGhlIFxcXCJpZFxcXCIgYXR0cmlidXRlXCIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbXNnSWQgPSBtc2dJZC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHZpc2l0QWxsKHRoaXMsIGVsZW1lbnQuY2hpbGRyZW4sIG51bGwpO1xuICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX21zZ0lkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVzc2FnZU5vZGVzLnB1c2goW3RoaXMuX21zZ0lkLCB0aGlzLl90YXJnZXRdKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIF9TT1VSQ0VfVEFHOlxuICAgICAgICAgICAgICAgICAgLy8gaWdub3JlIHNvdXJjZSBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBfVEFSR0VUX1RBRzpcbiAgICAgICAgICAgICAgICAgIHRoaXMuX3RhcmdldCA9IGVsZW1lbnQuY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBfUExBQ0VIT0xERVJfVEFHOlxuICAgICAgICAgICAgICAgICAgdmFyIGlkQXR0ciA9IGVsZW1lbnQuYXR0cnMuZmluZChmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gYXR0ci5uYW1lID09PSAnaWQnOyB9KTtcbiAgICAgICAgICAgICAgICAgIGlmICghaWRBdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3IoZWxlbWVudCwgXCI8XCIgKyBfUExBQ0VIT0xERVJfVEFHICsgXCI+IG1pc3NlcyB0aGUgXFxcImlkXFxcIiBhdHRyaWJ1dGVcIik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgaWQgPSBpZEF0dHIudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3BsYWNlaG9sZGVycy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BsYWNlaG9sZGVyc1tpZF07XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9wbGFjZWhvbGRlclRvSWRzLmhhc093blByb3BlcnR5KGlkKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90cmFuc2xhdGVkTWVzc2FnZXMuaGFzT3duUHJvcGVydHkodGhpcy5fcGxhY2Vob2xkZXJUb0lkc1tpZF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl90cmFuc2xhdGVkTWVzc2FnZXNbdGhpcy5fcGxhY2Vob2xkZXJUb0lkc1tpZF1dO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPKHZpY2IpOiBiZXR0ZXIgZXJyb3IgbWVzc2FnZSBmb3Igd2hlblxuICAgICAgICAgICAgICAgICAgICAgIC8vICF0aGlzLl90cmFuc2xhdGVkTWVzc2FnZXMuaGFzT3duUHJvcGVydHkodGhpcy5fcGxhY2Vob2xkZXJUb0lkc1tpZF0pXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3IoZWxlbWVudCwgXCJUaGUgcGxhY2Vob2xkZXIgXFxcIlwiICsgaWQgKyBcIlxcXCIgZG9lcyBub3QgZXhpc3RzIGluIHRoZSBzb3VyY2UgbWVzc2FnZVwiKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgdmlzaXRBbGwodGhpcywgZWxlbWVudC5jaGlsZHJlbiwgbnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIF9Mb2FkVmlzaXRvci5wcm90b3R5cGUudmlzaXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXR0cmlidXRlLCBjb250ZXh0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnJlYWNoYWJsZSBjb2RlJyk7XG4gICAgICB9O1xuICAgICAgX0xvYWRWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAodGV4dCwgY29udGV4dCkgeyByZXR1cm4gdGV4dC52YWx1ZTsgfTtcbiAgICAgIF9Mb2FkVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb21tZW50ID0gZnVuY3Rpb24gKGNvbW1lbnQsIGNvbnRleHQpIHsgcmV0dXJuICcnOyB9O1xuICAgICAgX0xvYWRWaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbiA9IGZ1bmN0aW9uIChleHBhbnNpb24sIGNvbnRleHQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VucmVhY2hhYmxlIGNvZGUnKTtcbiAgICAgIH07XG4gICAgICBfTG9hZFZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uQ2FzZSA9IGZ1bmN0aW9uIChleHBhbnNpb25DYXNlLCBjb250ZXh0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnJlYWNoYWJsZSBjb2RlJyk7XG4gICAgICB9O1xuICAgICAgX0xvYWRWaXNpdG9yLnByb3RvdHlwZS5fYWRkRXJyb3IgPSBmdW5jdGlvbiAobm9kZSwgbWVzc2FnZSkge1xuICAgICAgICAgIHRoaXMuX2Vycm9ycy5wdXNoKG5ldyBJMThuRXJyb3Iobm9kZS5zb3VyY2VTcGFuLCBtZXNzYWdlKSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIF9Mb2FkVmlzaXRvcjtcbiAgfSgpKTtcbiAgZnVuY3Rpb24gZ2V0Q3R5cGVGb3JUYWcodGFnKSB7XG4gICAgICBzd2l0Y2ggKHRhZy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgY2FzZSAnYnInOlxuICAgICAgICAgICAgICByZXR1cm4gJ2xiJztcbiAgICAgICAgICBjYXNlICdpbWcnOlxuICAgICAgICAgICAgICByZXR1cm4gJ2ltYWdlJztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICByZXR1cm4gXCJ4LVwiICsgdGFnO1xuICAgICAgfVxuICB9XG5cbiAgdmFyIF9NRVNTQUdFU19UQUcgPSAnbWVzc2FnZWJ1bmRsZSc7XG4gIHZhciBfTUVTU0FHRV9UQUcgPSAnbXNnJztcbiAgdmFyIF9QTEFDRUhPTERFUl9UQUckMSA9ICdwaCc7XG4gIHZhciBfRVhFTVBMRV9UQUcgPSAnZXgnO1xuICB2YXIgX0RPQ1RZUEUgPSBcIjwhRUxFTUVOVCBtZXNzYWdlYnVuZGxlIChtc2cpKj5cXG48IUFUVExJU1QgbWVzc2FnZWJ1bmRsZSBjbGFzcyBDREFUQSAjSU1QTElFRD5cXG5cXG48IUVMRU1FTlQgbXNnICgjUENEQVRBfHBofHNvdXJjZSkqPlxcbjwhQVRUTElTVCBtc2cgaWQgQ0RBVEEgI0lNUExJRUQ+XFxuPCFBVFRMSVNUIG1zZyBzZXEgQ0RBVEEgI0lNUExJRUQ+XFxuPCFBVFRMSVNUIG1zZyBuYW1lIENEQVRBICNJTVBMSUVEPlxcbjwhQVRUTElTVCBtc2cgZGVzYyBDREFUQSAjSU1QTElFRD5cXG48IUFUVExJU1QgbXNnIG1lYW5pbmcgQ0RBVEEgI0lNUExJRUQ+XFxuPCFBVFRMSVNUIG1zZyBvYnNvbGV0ZSAob2Jzb2xldGUpICNJTVBMSUVEPlxcbjwhQVRUTElTVCBtc2cgeG1sOnNwYWNlIChkZWZhdWx0fHByZXNlcnZlKSBcXFwiZGVmYXVsdFxcXCI+XFxuPCFBVFRMSVNUIG1zZyBpc19oaWRkZW4gQ0RBVEEgI0lNUExJRUQ+XFxuXFxuPCFFTEVNRU5UIHNvdXJjZSAoI1BDREFUQSk+XFxuXFxuPCFFTEVNRU5UIHBoICgjUENEQVRBfGV4KSo+XFxuPCFBVFRMSVNUIHBoIG5hbWUgQ0RBVEEgI1JFUVVJUkVEPlxcblxcbjwhRUxFTUVOVCBleCAoI1BDREFUQSk+XCI7XG4gIHZhciBYbWIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gWG1iKCkge1xuICAgICAgfVxuICAgICAgWG1iLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChtZXNzYWdlTWFwKSB7XG4gICAgICAgICAgdmFyIHZpc2l0b3IgPSBuZXcgX1Zpc2l0b3IkMigpO1xuICAgICAgICAgIHZhciByb290Tm9kZSA9IG5ldyBUYWcoX01FU1NBR0VTX1RBRyk7XG4gICAgICAgICAgT2JqZWN0LmtleXMobWVzc2FnZU1hcCkuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBtZXNzYWdlTWFwW2lkXTtcbiAgICAgICAgICAgICAgdmFyIGF0dHJzID0geyBpZDogaWQgfTtcbiAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgIGF0dHJzWydkZXNjJ10gPSBtZXNzYWdlLmRlc2NyaXB0aW9uO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChtZXNzYWdlLm1lYW5pbmcpIHtcbiAgICAgICAgICAgICAgICAgIGF0dHJzWydtZWFuaW5nJ10gPSBtZXNzYWdlLm1lYW5pbmc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcm9vdE5vZGUuY2hpbGRyZW4ucHVzaChuZXcgQ1IoMiksIG5ldyBUYWcoX01FU1NBR0VfVEFHLCBhdHRycywgdmlzaXRvci5zZXJpYWxpemUobWVzc2FnZS5ub2RlcykpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByb290Tm9kZS5jaGlsZHJlbi5wdXNoKG5ldyBDUigpKTtcbiAgICAgICAgICByZXR1cm4gc2VyaWFsaXplKFtcbiAgICAgICAgICAgICAgbmV3IERlY2xhcmF0aW9uKHsgdmVyc2lvbjogJzEuMCcsIGVuY29kaW5nOiAnVVRGLTgnIH0pLFxuICAgICAgICAgICAgICBuZXcgQ1IoKSxcbiAgICAgICAgICAgICAgbmV3IERvY3R5cGUoX01FU1NBR0VTX1RBRywgX0RPQ1RZUEUpLFxuICAgICAgICAgICAgICBuZXcgQ1IoKSxcbiAgICAgICAgICAgICAgcm9vdE5vZGUsXG4gICAgICAgICAgICAgIG5ldyBDUigpLFxuICAgICAgICAgIF0pO1xuICAgICAgfTtcbiAgICAgIFhtYi5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChjb250ZW50LCB1cmwsIG1lc3NhZ2VCdW5kbGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkJyk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFhtYjtcbiAgfSgpKTtcbiAgdmFyIF9WaXNpdG9yJDIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gX1Zpc2l0b3IoKSB7XG4gICAgICB9XG4gICAgICBfVmlzaXRvci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKHRleHQsIGNvbnRleHQpIHsgcmV0dXJuIFtuZXcgVGV4dCQyKHRleHQudmFsdWUpXTsgfTtcbiAgICAgIF9WaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbnRhaW5lciA9IGZ1bmN0aW9uIChjb250YWluZXIsIGNvbnRleHQpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBub2RlcyA9IFtdO1xuICAgICAgICAgIGNvbnRhaW5lci5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2Rlcy5wdXNoLmFwcGx5KG5vZGVzLCBub2RlLnZpc2l0KF90aGlzKSk7IH0pO1xuICAgICAgICAgIHJldHVybiBub2RlcztcbiAgICAgIH07XG4gICAgICBfVmlzaXRvci5wcm90b3R5cGUudmlzaXRJY3UgPSBmdW5jdGlvbiAoaWN1LCBjb250ZXh0KSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgbm9kZXMgPSBbbmV3IFRleHQkMihcIntcIiArIGljdS5leHByZXNzaW9uICsgXCIsIFwiICsgaWN1LnR5cGUgKyBcIiwgXCIpXTtcbiAgICAgICAgICBPYmplY3Qua2V5cyhpY3UuY2FzZXMpLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgbm9kZXMucHVzaC5hcHBseShub2RlcywgW25ldyBUZXh0JDIoYyArIFwiIHtcIildLmNvbmNhdChpY3UuY2FzZXNbY10udmlzaXQoX3RoaXMpLCBbbmV3IFRleHQkMihcIn0gXCIpXSkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIG5vZGVzLnB1c2gobmV3IFRleHQkMihcIn1cIikpO1xuICAgICAgICAgIHJldHVybiBub2RlcztcbiAgICAgIH07XG4gICAgICBfVmlzaXRvci5wcm90b3R5cGUudmlzaXRUYWdQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCwgY29udGV4dCkge1xuICAgICAgICAgIHZhciBzdGFydEV4ID0gbmV3IFRhZyhfRVhFTVBMRV9UQUcsIHt9LCBbbmV3IFRleHQkMihcIjxcIiArIHBoLnRhZyArIFwiPlwiKV0pO1xuICAgICAgICAgIHZhciBzdGFydFRhZ1BoID0gbmV3IFRhZyhfUExBQ0VIT0xERVJfVEFHJDEsIHsgbmFtZTogcGguc3RhcnROYW1lIH0sIFtzdGFydEV4XSk7XG4gICAgICAgICAgaWYgKHBoLmlzVm9pZCkge1xuICAgICAgICAgICAgICAvLyB2b2lkIHRhZ3MgaGF2ZSBubyBjaGlsZHJlbiBub3IgY2xvc2luZyB0YWdzXG4gICAgICAgICAgICAgIHJldHVybiBbc3RhcnRUYWdQaF07XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBjbG9zZUV4ID0gbmV3IFRhZyhfRVhFTVBMRV9UQUcsIHt9LCBbbmV3IFRleHQkMihcIjwvXCIgKyBwaC50YWcgKyBcIj5cIildKTtcbiAgICAgICAgICB2YXIgY2xvc2VUYWdQaCA9IG5ldyBUYWcoX1BMQUNFSE9MREVSX1RBRyQxLCB7IG5hbWU6IHBoLmNsb3NlTmFtZSB9LCBbY2xvc2VFeF0pO1xuICAgICAgICAgIHJldHVybiBbc3RhcnRUYWdQaF0uY29uY2F0KHRoaXMuc2VyaWFsaXplKHBoLmNoaWxkcmVuKSwgW2Nsb3NlVGFnUGhdKTtcbiAgICAgIH07XG4gICAgICBfVmlzaXRvci5wcm90b3R5cGUudmlzaXRQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiBbbmV3IFRhZyhfUExBQ0VIT0xERVJfVEFHJDEsIHsgbmFtZTogcGgubmFtZSB9KV07XG4gICAgICB9O1xuICAgICAgX1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0SWN1UGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gW25ldyBUYWcoX1BMQUNFSE9MREVSX1RBRyQxLCB7IG5hbWU6IHBoLm5hbWUgfSldO1xuICAgICAgfTtcbiAgICAgIF9WaXNpdG9yLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAobm9kZXMpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHJldHVybiBMaXN0V3JhcHBlci5mbGF0dGVuKG5vZGVzLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS52aXNpdChfdGhpcyk7IH0pKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gX1Zpc2l0b3I7XG4gIH0oKSk7XG5cbiAgdmFyIF9UUkFOU0xBVElPTlNfVEFHID0gJ3RyYW5zbGF0aW9uYnVuZGxlJztcbiAgdmFyIF9UUkFOU0xBVElPTl9UQUcgPSAndHJhbnNsYXRpb24nO1xuICB2YXIgX1BMQUNFSE9MREVSX1RBRyQyID0gJ3BoJztcbiAgdmFyIFh0YiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBYdGIoX2h0bWxQYXJzZXIsIF9pbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgICAgdGhpcy5faHRtbFBhcnNlciA9IF9odG1sUGFyc2VyO1xuICAgICAgICAgIHRoaXMuX2ludGVycG9sYXRpb25Db25maWcgPSBfaW50ZXJwb2xhdGlvbkNvbmZpZztcbiAgICAgIH1cbiAgICAgIFh0Yi5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAobWVzc2FnZU1hcCkgeyB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkJyk7IH07XG4gICAgICBYdGIucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoY29udGVudCwgdXJsLCBtZXNzYWdlQnVuZGxlKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAvLyBQYXJzZSB0aGUgeHRiIGZpbGUgaW50byB4bWwgbm9kZXNcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IFhtbFBhcnNlcigpLnBhcnNlKGNvbnRlbnQsIHVybCk7XG4gICAgICAgICAgaWYgKHJlc3VsdC5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInh0YiBwYXJzZSBlcnJvcnM6XFxuXCIgKyByZXN1bHQuZXJyb3JzLmpvaW4oJ1xcbicpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUmVwbGFjZSB0aGUgcGxhY2Vob2xkZXJzLCBtZXNzYWdlcyBhcmUgbm93IHN0cmluZ1xuICAgICAgICAgIHZhciBfYSA9IG5ldyBfVmlzaXRvciQzKCkucGFyc2UocmVzdWx0LnJvb3ROb2RlcywgbWVzc2FnZUJ1bmRsZSksIG1lc3NhZ2VzID0gX2EubWVzc2FnZXMsIGVycm9ycyA9IF9hLmVycm9ycztcbiAgICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ4dGIgcGFyc2UgZXJyb3JzOlxcblwiICsgZXJyb3JzLmpvaW4oJ1xcbicpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQ29udmVydCB0aGUgc3RyaW5nIG1lc3NhZ2VzIHRvIGh0bWwgYXN0XG4gICAgICAgICAgLy8gVE9ETyh2aWNiKTogbWFwIGVycm9yIG1lc3NhZ2UgYmFjayB0byB0aGUgb3JpZ2luYWwgbWVzc2FnZSBpbiB4dGJcbiAgICAgICAgICB2YXIgbWVzc2FnZU1hcCA9IHt9O1xuICAgICAgICAgIHZhciBwYXJzZUVycm9ycyA9IFtdO1xuICAgICAgICAgIE9iamVjdC5rZXlzKG1lc3NhZ2VzKS5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgICB2YXIgcmVzID0gX3RoaXMuX2h0bWxQYXJzZXIucGFyc2UobWVzc2FnZXNbaWRdLCB1cmwsIHRydWUsIF90aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgICAgICAgcGFyc2VFcnJvcnMucHVzaC5hcHBseShwYXJzZUVycm9ycywgcmVzLmVycm9ycyk7XG4gICAgICAgICAgICAgIG1lc3NhZ2VNYXBbaWRdID0gcmVzLnJvb3ROb2RlcztcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAocGFyc2VFcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInh0YiBwYXJzZSBlcnJvcnM6XFxuXCIgKyBwYXJzZUVycm9ycy5qb2luKCdcXG4nKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtZXNzYWdlTWFwO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBYdGI7XG4gIH0oKSk7XG4gIHZhciBfVmlzaXRvciQzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIF9WaXNpdG9yKCkge1xuICAgICAgfVxuICAgICAgX1Zpc2l0b3IucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKG5vZGVzLCBtZXNzYWdlQnVuZGxlKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB0aGlzLl9tZXNzYWdlTm9kZXMgPSBbXTtcbiAgICAgICAgICB0aGlzLl90cmFuc2xhdGVkTWVzc2FnZXMgPSB7fTtcbiAgICAgICAgICB0aGlzLl9idW5kbGVEZXB0aCA9IDA7XG4gICAgICAgICAgdGhpcy5fdHJhbnNsYXRpb25EZXB0aCA9IDA7XG4gICAgICAgICAgdGhpcy5fZXJyb3JzID0gW107XG4gICAgICAgICAgLy8gRmluZCBhbGwgbWVzc2FnZXNcbiAgICAgICAgICB2aXNpdEFsbCh0aGlzLCBub2RlcywgbnVsbCk7XG4gICAgICAgICAgdmFyIG1lc3NhZ2VNYXAgPSBtZXNzYWdlQnVuZGxlLmdldE1lc3NhZ2VNYXAoKTtcbiAgICAgICAgICB2YXIgcGxhY2Vob2xkZXJzID0gZXh0cmFjdFBsYWNlaG9sZGVycyhtZXNzYWdlQnVuZGxlKTtcbiAgICAgICAgICB2YXIgcGxhY2Vob2xkZXJUb0lkcyA9IGV4dHJhY3RQbGFjZWhvbGRlclRvSWRzKG1lc3NhZ2VCdW5kbGUpO1xuICAgICAgICAgIHRoaXMuX21lc3NhZ2VOb2Rlc1xuICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICAgIC8vIFJlbW92ZSBhbnkgbWVzc2FnZXMgdGhhdCBpcyBub3QgcHJlc2VudCBpbiB0aGUgc291cmNlIG1lc3NhZ2UgYnVuZGxlLlxuICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZU1hcC5oYXNPd25Qcm9wZXJ0eShtZXNzYWdlWzBdKTtcbiAgICAgICAgICB9KVxuICAgICAgICAgICAgICAuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAvLyBCZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG5vIElDVSBwbGFjZWhvbGRlcnMgaW5zaWRlIGFuIElDVSBtZXNzYWdlLFxuICAgICAgICAgICAgICAvLyB3ZSBkbyBub3QgbmVlZCB0byB0YWtlIGludG8gYWNjb3VudCB0aGUgYHBsYWNlaG9sZGVyVG9Nc2dJZHNgIG9mIHRoZSByZWZlcmVuY2VkXG4gICAgICAgICAgICAgIC8vIG1lc3NhZ2VzLCB0aG9zZSB3b3VsZCBhbHdheXMgYmUgZW1wdHlcbiAgICAgICAgICAgICAgLy8gVE9ETyh2aWNiKTogb3ZlcmtpbGwgLSBjcmVhdGUgMiBidWNrZXRzIGFuZCBbLi4ud29EZXBzLCAuLi53RGVwc10ucHJvY2VzcygpXG4gICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhtZXNzYWdlTWFwW2FbMF1dLnBsYWNlaG9sZGVyVG9Nc2dJZHMpLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKG1lc3NhZ2VNYXBbYlswXV0ucGxhY2Vob2xkZXJUb01zZ0lkcykubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICAgIHZhciBpZCA9IG1lc3NhZ2VbMF07XG4gICAgICAgICAgICAgIF90aGlzLl9wbGFjZWhvbGRlcnMgPSBwbGFjZWhvbGRlcnNbaWRdIHx8IHt9O1xuICAgICAgICAgICAgICBfdGhpcy5fcGxhY2Vob2xkZXJUb0lkcyA9IHBsYWNlaG9sZGVyVG9JZHNbaWRdIHx8IHt9O1xuICAgICAgICAgICAgICAvLyBUT0RPKHZpY2IpOiBtYWtlIHN1cmUgdGhlcmUgaXMgbm8gYF9UUkFOU0xBVElPTlNfVEFHYCBub3IgYF9UUkFOU0xBVElPTl9UQUdgXG4gICAgICAgICAgICAgIF90aGlzLl90cmFuc2xhdGVkTWVzc2FnZXNbaWRdID0gdmlzaXRBbGwoX3RoaXMsIG1lc3NhZ2VbMV0pLmpvaW4oJycpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiB7IG1lc3NhZ2VzOiB0aGlzLl90cmFuc2xhdGVkTWVzc2FnZXMsIGVycm9yczogdGhpcy5fZXJyb3JzIH07XG4gICAgICB9O1xuICAgICAgX1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50LCBjb250ZXh0KSB7XG4gICAgICAgICAgc3dpdGNoIChlbGVtZW50Lm5hbWUpIHtcbiAgICAgICAgICAgICAgY2FzZSBfVFJBTlNMQVRJT05TX1RBRzpcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2J1bmRsZURlcHRoKys7XG4gICAgICAgICAgICAgICAgICBpZiAodGhpcy5fYnVuZGxlRGVwdGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3IoZWxlbWVudCwgXCI8XCIgKyBfVFJBTlNMQVRJT05TX1RBRyArIFwiPiBlbGVtZW50cyBjYW4gbm90IGJlIG5lc3RlZFwiKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHZpc2l0QWxsKHRoaXMsIGVsZW1lbnQuY2hpbGRyZW4sIG51bGwpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5fYnVuZGxlRGVwdGgtLTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIF9UUkFOU0xBVElPTl9UQUc6XG4gICAgICAgICAgICAgICAgICB0aGlzLl90cmFuc2xhdGlvbkRlcHRoKys7XG4gICAgICAgICAgICAgICAgICBpZiAodGhpcy5fdHJhbnNsYXRpb25EZXB0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbGVtZW50LCBcIjxcIiArIF9UUkFOU0xBVElPTl9UQUcgKyBcIj4gZWxlbWVudHMgY2FuIG5vdCBiZSBuZXN0ZWRcIik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB2YXIgaWRBdHRyID0gZWxlbWVudC5hdHRycy5maW5kKGZ1bmN0aW9uIChhdHRyKSB7IHJldHVybiBhdHRyLm5hbWUgPT09ICdpZCc7IH0pO1xuICAgICAgICAgICAgICAgICAgaWYgKCFpZEF0dHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbGVtZW50LCBcIjxcIiArIF9UUkFOU0xBVElPTl9UQUcgKyBcIj4gbWlzc2VzIHRoZSBcXFwiaWRcXFwiIGF0dHJpYnV0ZVwiKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIElDVSBwbGFjZWhvbGRlcnMgYXJlIHJlZmVyZW5jZSB0byBvdGhlciBtZXNzYWdlcy5cbiAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcmVmZXJlbmNlZCBtZXNzYWdlIG1pZ2h0IG5vdCBoYXZlIGJlZW4gZGVjb2RlZCB5ZXQuXG4gICAgICAgICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBoYXZlIGFsbCBtZXNzYWdlcyBhdmFpbGFibGUgdG8gbWFrZSBzdXJlIGRlcHMgYXJlIGRlY29kZWQgZmlyc3QuXG4gICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyh2aWNiKTogcmVwb3J0IGFuIGVycm9yIG9uIGR1cGxpY2F0ZSBpZFxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21lc3NhZ2VOb2Rlcy5wdXNoKFtpZEF0dHIudmFsdWUsIGVsZW1lbnQuY2hpbGRyZW5dKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zbGF0aW9uRGVwdGgtLTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIF9QTEFDRUhPTERFUl9UQUckMjpcbiAgICAgICAgICAgICAgICAgIHZhciBuYW1lQXR0ciA9IGVsZW1lbnQuYXR0cnMuZmluZChmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gYXR0ci5uYW1lID09PSAnbmFtZSc7IH0pO1xuICAgICAgICAgICAgICAgICAgaWYgKCFuYW1lQXR0cikge1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZEVycm9yKGVsZW1lbnQsIFwiPFwiICsgX1BMQUNFSE9MREVSX1RBRyQyICsgXCI+IG1pc3NlcyB0aGUgXFxcIm5hbWVcXFwiIGF0dHJpYnV0ZVwiKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBuYW1lXzEgPSBuYW1lQXR0ci52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fcGxhY2Vob2xkZXJzLmhhc093blByb3BlcnR5KG5hbWVfMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BsYWNlaG9sZGVyc1tuYW1lXzFdO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fcGxhY2Vob2xkZXJUb0lkcy5oYXNPd25Qcm9wZXJ0eShuYW1lXzEpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zbGF0ZWRNZXNzYWdlcy5oYXNPd25Qcm9wZXJ0eSh0aGlzLl9wbGFjZWhvbGRlclRvSWRzW25hbWVfMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl90cmFuc2xhdGVkTWVzc2FnZXNbdGhpcy5fcGxhY2Vob2xkZXJUb0lkc1tuYW1lXzFdXTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyh2aWNiKTogYmV0dGVyIGVycm9yIG1lc3NhZ2UgZm9yIHdoZW5cbiAgICAgICAgICAgICAgICAgICAgICAvLyAhdGhpcy5fdHJhbnNsYXRlZE1lc3NhZ2VzLmhhc093blByb3BlcnR5KHRoaXMuX3BsYWNlaG9sZGVyVG9JZHNbbmFtZV0pXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3IoZWxlbWVudCwgXCJUaGUgcGxhY2Vob2xkZXIgXFxcIlwiICsgbmFtZV8xICsgXCJcXFwiIGRvZXMgbm90IGV4aXN0cyBpbiB0aGUgc291cmNlIG1lc3NhZ2VcIik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZEVycm9yKGVsZW1lbnQsICdVbmV4cGVjdGVkIHRhZycpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfVmlzaXRvci5wcm90b3R5cGUudmlzaXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXR0cmlidXRlLCBjb250ZXh0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnJlYWNoYWJsZSBjb2RlJyk7XG4gICAgICB9O1xuICAgICAgX1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCBjb250ZXh0KSB7IHJldHVybiB0ZXh0LnZhbHVlOyB9O1xuICAgICAgX1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0Q29tbWVudCA9IGZ1bmN0aW9uIChjb21tZW50LCBjb250ZXh0KSB7IHJldHVybiAnJzsgfTtcbiAgICAgIF9WaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbiA9IGZ1bmN0aW9uIChleHBhbnNpb24sIGNvbnRleHQpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBzdHJDYXNlcyA9IGV4cGFuc2lvbi5jYXNlcy5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMudmlzaXQoX3RoaXMsIG51bGwpOyB9KTtcbiAgICAgICAgICByZXR1cm4gXCJ7XCIgKyBleHBhbnNpb24uc3dpdGNoVmFsdWUgKyBcIiwgXCIgKyBleHBhbnNpb24udHlwZSArIFwiLCBzdHJDYXNlcy5qb2luKCcgJyl9XCI7XG4gICAgICB9O1xuICAgICAgX1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uQ2FzZSA9IGZ1bmN0aW9uIChleHBhbnNpb25DYXNlLCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIGV4cGFuc2lvbkNhc2UudmFsdWUgKyBcIiB7XCIgKyB2aXNpdEFsbCh0aGlzLCBleHBhbnNpb25DYXNlLmV4cHJlc3Npb24sIG51bGwpICsgXCJ9XCI7XG4gICAgICB9O1xuICAgICAgX1Zpc2l0b3IucHJvdG90eXBlLl9hZGRFcnJvciA9IGZ1bmN0aW9uIChub2RlLCBtZXNzYWdlKSB7XG4gICAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2gobmV3IEkxOG5FcnJvcihub2RlLnNvdXJjZVNwYW4sIG1lc3NhZ2UpKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gX1Zpc2l0b3I7XG4gIH0oKSk7XG5cbiAgLyoqXG4gICAqIEBsaWNlbnNlXG4gICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgKlxuICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAqL1xuICAvKipcbiAgICogQSBjb250YWluZXIgZm9yIHRyYW5zbGF0ZWQgbWVzc2FnZXNcbiAgICovXG4gIHZhciBUcmFuc2xhdGlvbkJ1bmRsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBUcmFuc2xhdGlvbkJ1bmRsZShfbWVzc2FnZU1hcCkge1xuICAgICAgICAgIGlmIChfbWVzc2FnZU1hcCA9PT0gdm9pZCAwKSB7IF9tZXNzYWdlTWFwID0ge307IH1cbiAgICAgICAgICB0aGlzLl9tZXNzYWdlTWFwID0gX21lc3NhZ2VNYXA7XG4gICAgICB9XG4gICAgICBUcmFuc2xhdGlvbkJ1bmRsZS5sb2FkID0gZnVuY3Rpb24gKGNvbnRlbnQsIHVybCwgbWVzc2FnZUJ1bmRsZSwgc2VyaWFsaXplcikge1xuICAgICAgICAgIHJldHVybiBuZXcgVHJhbnNsYXRpb25CdW5kbGUoc2VyaWFsaXplci5sb2FkKGNvbnRlbnQsIHVybCwgbWVzc2FnZUJ1bmRsZSkpO1xuICAgICAgfTtcbiAgICAgIFRyYW5zbGF0aW9uQnVuZGxlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoaWQpIHsgcmV0dXJuIHRoaXMuX21lc3NhZ2VNYXBbaWRdOyB9O1xuICAgICAgVHJhbnNsYXRpb25CdW5kbGUucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gaWQgaW4gdGhpcy5fbWVzc2FnZU1hcDsgfTtcbiAgICAgIHJldHVybiBUcmFuc2xhdGlvbkJ1bmRsZTtcbiAgfSgpKTtcblxuICB2YXIgSTE4Tkh0bWxQYXJzZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgLy8gVE9ETyh2aWNiKTogdHJhbnNCLmxvYWQoKSBzaG91bGQgbm90IG5lZWQgYSBtc2dCICYgYWRkIHRyYW5zQi5yZXNvbHZlKG1zZ0IsXG4gICAgICAvLyBpbnRlcnBvbGF0aW9uQ29uZmlnKVxuICAgICAgLy8gVE9ETyh2aWNiKTogcmVtb3ZlIHRoZSBpbnRlcnBvbGF0aW9uQ29uZmlnIGZyb20gdGhlIFh0YiBzZXJpYWxpemVyXG4gICAgICBmdW5jdGlvbiBJMThOSHRtbFBhcnNlcihfaHRtbFBhcnNlciwgX3RyYW5zbGF0aW9ucywgX3RyYW5zbGF0aW9uc0Zvcm1hdCkge1xuICAgICAgICAgIHRoaXMuX2h0bWxQYXJzZXIgPSBfaHRtbFBhcnNlcjtcbiAgICAgICAgICB0aGlzLl90cmFuc2xhdGlvbnMgPSBfdHJhbnNsYXRpb25zO1xuICAgICAgICAgIHRoaXMuX3RyYW5zbGF0aW9uc0Zvcm1hdCA9IF90cmFuc2xhdGlvbnNGb3JtYXQ7XG4gICAgICB9XG4gICAgICBJMThOSHRtbFBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoc291cmNlLCB1cmwsIHBhcnNlRXhwYW5zaW9uRm9ybXMsIGludGVycG9sYXRpb25Db25maWcpIHtcbiAgICAgICAgICBpZiAocGFyc2VFeHBhbnNpb25Gb3JtcyA9PT0gdm9pZCAwKSB7IHBhcnNlRXhwYW5zaW9uRm9ybXMgPSBmYWxzZTsgfVxuICAgICAgICAgIGlmIChpbnRlcnBvbGF0aW9uQ29uZmlnID09PSB2b2lkIDApIHsgaW50ZXJwb2xhdGlvbkNvbmZpZyA9IERFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUc7IH1cbiAgICAgICAgICB2YXIgcGFyc2VSZXN1bHQgPSB0aGlzLl9odG1sUGFyc2VyLnBhcnNlKHNvdXJjZSwgdXJsLCBwYXJzZUV4cGFuc2lvbkZvcm1zLCBpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgICBpZiAoIXRoaXMuX3RyYW5zbGF0aW9ucyB8fCB0aGlzLl90cmFuc2xhdGlvbnMgPT09ICcnKSB7XG4gICAgICAgICAgICAgIC8vIERvIG5vdCBlbmFibGUgaTE4biB3aGVuIG5vIHRyYW5zbGF0aW9uIGJ1bmRsZSBpcyBwcm92aWRlZFxuICAgICAgICAgICAgICByZXR1cm4gcGFyc2VSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFRPRE8odmljYik6IGFkZCBzdXBwb3J0IGZvciBpbXBsaWNpdCB0YWdzIC8gYXR0cmlidXRlc1xuICAgICAgICAgIHZhciBtZXNzYWdlQnVuZGxlID0gbmV3IE1lc3NhZ2VCdW5kbGUodGhpcy5faHRtbFBhcnNlciwgW10sIHt9KTtcbiAgICAgICAgICB2YXIgZXJyb3JzID0gbWVzc2FnZUJ1bmRsZS51cGRhdGVGcm9tVGVtcGxhdGUoc291cmNlLCB1cmwsIGludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICAgIGlmIChlcnJvcnMgJiYgZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IFBhcnNlVHJlZVJlc3VsdChwYXJzZVJlc3VsdC5yb290Tm9kZXMsIHBhcnNlUmVzdWx0LmVycm9ycy5jb25jYXQoZXJyb3JzKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBzZXJpYWxpemVyID0gdGhpcy5fY3JlYXRlU2VyaWFsaXplcihpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgICB2YXIgdHJhbnNsYXRpb25CdW5kbGUgPSBUcmFuc2xhdGlvbkJ1bmRsZS5sb2FkKHRoaXMuX3RyYW5zbGF0aW9ucywgdXJsLCBtZXNzYWdlQnVuZGxlLCBzZXJpYWxpemVyKTtcbiAgICAgICAgICByZXR1cm4gbWVyZ2VUcmFuc2xhdGlvbnMocGFyc2VSZXN1bHQucm9vdE5vZGVzLCB0cmFuc2xhdGlvbkJ1bmRsZSwgaW50ZXJwb2xhdGlvbkNvbmZpZywgW10sIHt9KTtcbiAgICAgIH07XG4gICAgICBJMThOSHRtbFBhcnNlci5wcm90b3R5cGUuX2NyZWF0ZVNlcmlhbGl6ZXIgPSBmdW5jdGlvbiAoaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgICAgICAgIHZhciBmb3JtYXQgPSAodGhpcy5fdHJhbnNsYXRpb25zRm9ybWF0IHx8ICd4bGYnKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgICAgICAgICAgIGNhc2UgJ3htYic6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFhtYigpO1xuICAgICAgICAgICAgICBjYXNlICd4dGInOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBYdGIodGhpcy5faHRtbFBhcnNlciwgaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICAgICAgICAgIGNhc2UgJ3hsaWZmJzpcbiAgICAgICAgICAgICAgY2FzZSAneGxmJzpcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgWGxpZmYodGhpcy5faHRtbFBhcnNlciwgaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiBJMThOSHRtbFBhcnNlcjtcbiAgfSgpKTtcblxuICB2YXIgaXNEZWZhdWx0Q2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kgPSBfYW5ndWxhcl9jb3JlLl9fY29yZV9wcml2YXRlX18uaXNEZWZhdWx0Q2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3k7XG4gIHZhciBDaGFuZ2VEZXRlY3RvclN0YXR1cyA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5DaGFuZ2VEZXRlY3RvclN0YXR1cztcbiAgdmFyIExpZmVjeWNsZUhvb2tzID0gX2FuZ3VsYXJfY29yZS5fX2NvcmVfcHJpdmF0ZV9fLkxpZmVjeWNsZUhvb2tzO1xuICB2YXIgTElGRUNZQ0xFX0hPT0tTX1ZBTFVFUyA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5MSUZFQ1lDTEVfSE9PS1NfVkFMVUVTO1xuICB2YXIgUmVmbGVjdG9yUmVhZGVyID0gX2FuZ3VsYXJfY29yZS5fX2NvcmVfcHJpdmF0ZV9fLlJlZmxlY3RvclJlYWRlcjtcbiAgdmFyIEFwcEVsZW1lbnQgPSBfYW5ndWxhcl9jb3JlLl9fY29yZV9wcml2YXRlX18uQXBwRWxlbWVudDtcbiAgdmFyIENvZGVnZW5Db21wb25lbnRGYWN0b3J5UmVzb2x2ZXIgPSBfYW5ndWxhcl9jb3JlLl9fY29yZV9wcml2YXRlX18uQ29kZWdlbkNvbXBvbmVudEZhY3RvcnlSZXNvbHZlcjtcbiAgdmFyIEFwcFZpZXcgPSBfYW5ndWxhcl9jb3JlLl9fY29yZV9wcml2YXRlX18uQXBwVmlldztcbiAgdmFyIERlYnVnQXBwVmlldyA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5EZWJ1Z0FwcFZpZXc7XG4gIHZhciBOZ01vZHVsZUluamVjdG9yID0gX2FuZ3VsYXJfY29yZS5fX2NvcmVfcHJpdmF0ZV9fLk5nTW9kdWxlSW5qZWN0b3I7XG4gIHZhciByZWdpc3Rlck1vZHVsZUZhY3RvcnkgPSBfYW5ndWxhcl9jb3JlLl9fY29yZV9wcml2YXRlX18ucmVnaXN0ZXJNb2R1bGVGYWN0b3J5O1xuICB2YXIgVmlld1R5cGUgPSBfYW5ndWxhcl9jb3JlLl9fY29yZV9wcml2YXRlX18uVmlld1R5cGU7XG4gIHZhciB2aWV3X3V0aWxzID0gX2FuZ3VsYXJfY29yZS5fX2NvcmVfcHJpdmF0ZV9fLnZpZXdfdXRpbHM7XG4gIHZhciBEZWJ1Z0NvbnRleHQgPSBfYW5ndWxhcl9jb3JlLl9fY29yZV9wcml2YXRlX18uRGVidWdDb250ZXh0O1xuICB2YXIgU3RhdGljTm9kZURlYnVnSW5mbyA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5TdGF0aWNOb2RlRGVidWdJbmZvO1xuICB2YXIgZGV2TW9kZUVxdWFsID0gX2FuZ3VsYXJfY29yZS5fX2NvcmVfcHJpdmF0ZV9fLmRldk1vZGVFcXVhbDtcbiAgdmFyIFVOSU5JVElBTElaRUQgPSBfYW5ndWxhcl9jb3JlLl9fY29yZV9wcml2YXRlX18uVU5JTklUSUFMSVpFRDtcbiAgdmFyIFZhbHVlVW53cmFwcGVyID0gX2FuZ3VsYXJfY29yZS5fX2NvcmVfcHJpdmF0ZV9fLlZhbHVlVW53cmFwcGVyO1xuICB2YXIgVGVtcGxhdGVSZWZfID0gX2FuZ3VsYXJfY29yZS5fX2NvcmVfcHJpdmF0ZV9fLlRlbXBsYXRlUmVmXztcbiAgdmFyIENvbnNvbGUgPSBfYW5ndWxhcl9jb3JlLl9fY29yZV9wcml2YXRlX18uQ29uc29sZTtcbiAgdmFyIHJlZmxlY3RvciA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5yZWZsZWN0b3I7XG4gIHZhciBSZWZsZWN0b3IgPSBfYW5ndWxhcl9jb3JlLl9fY29yZV9wcml2YXRlX18uUmVmbGVjdG9yO1xuICB2YXIgUmVmbGVjdGlvbkNhcGFiaWxpdGllcyA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5SZWZsZWN0aW9uQ2FwYWJpbGl0aWVzO1xuICB2YXIgTm9PcEFuaW1hdGlvblBsYXllciA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5Ob09wQW5pbWF0aW9uUGxheWVyO1xuICB2YXIgQW5pbWF0aW9uU2VxdWVuY2VQbGF5ZXIgPSBfYW5ndWxhcl9jb3JlLl9fY29yZV9wcml2YXRlX18uQW5pbWF0aW9uU2VxdWVuY2VQbGF5ZXI7XG4gIHZhciBBbmltYXRpb25Hcm91cFBsYXllciA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5BbmltYXRpb25Hcm91cFBsYXllcjtcbiAgdmFyIEFuaW1hdGlvbktleWZyYW1lID0gX2FuZ3VsYXJfY29yZS5fX2NvcmVfcHJpdmF0ZV9fLkFuaW1hdGlvbktleWZyYW1lO1xuICB2YXIgQW5pbWF0aW9uU3R5bGVzID0gX2FuZ3VsYXJfY29yZS5fX2NvcmVfcHJpdmF0ZV9fLkFuaW1hdGlvblN0eWxlcztcbiAgdmFyIEFOWV9TVEFURSA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5BTllfU1RBVEU7XG4gIHZhciBERUZBVUxUX1NUQVRFID0gX2FuZ3VsYXJfY29yZS5fX2NvcmVfcHJpdmF0ZV9fLkRFRkFVTFRfU1RBVEU7XG4gIHZhciBFTVBUWV9BTklNQVRJT05fU1RBVEUgPSBfYW5ndWxhcl9jb3JlLl9fY29yZV9wcml2YXRlX18uRU1QVFlfU1RBVEU7XG4gIHZhciBGSUxMX1NUWUxFX0ZMQUcgPSBfYW5ndWxhcl9jb3JlLl9fY29yZV9wcml2YXRlX18uRklMTF9TVFlMRV9GTEFHO1xuICB2YXIgcHJlcGFyZUZpbmFsQW5pbWF0aW9uU3R5bGVzID0gX2FuZ3VsYXJfY29yZS5fX2NvcmVfcHJpdmF0ZV9fLnByZXBhcmVGaW5hbEFuaW1hdGlvblN0eWxlcztcbiAgdmFyIGJhbGFuY2VBbmltYXRpb25LZXlmcmFtZXMgPSBfYW5ndWxhcl9jb3JlLl9fY29yZV9wcml2YXRlX18uYmFsYW5jZUFuaW1hdGlvbktleWZyYW1lcztcbiAgdmFyIGNsZWFyU3R5bGVzID0gX2FuZ3VsYXJfY29yZS5fX2NvcmVfcHJpdmF0ZV9fLmNsZWFyU3R5bGVzO1xuICB2YXIgY29sbGVjdEFuZFJlc29sdmVTdHlsZXMgPSBfYW5ndWxhcl9jb3JlLl9fY29yZV9wcml2YXRlX18uY29sbGVjdEFuZFJlc29sdmVTdHlsZXM7XG4gIHZhciByZW5kZXJTdHlsZXMgPSBfYW5ndWxhcl9jb3JlLl9fY29yZV9wcml2YXRlX18ucmVuZGVyU3R5bGVzO1xuICB2YXIgQ29tcG9uZW50U3RpbGxMb2FkaW5nRXJyb3IgPSBfYW5ndWxhcl9jb3JlLl9fY29yZV9wcml2YXRlX18uQ29tcG9uZW50U3RpbGxMb2FkaW5nRXJyb3I7XG4gIHZhciBBbmltYXRpb25UcmFuc2l0aW9uID0gX2FuZ3VsYXJfY29yZS5fX2NvcmVfcHJpdmF0ZV9fLkFuaW1hdGlvblRyYW5zaXRpb247XG5cbiAgdmFyIEFQUF9WSUVXX01PRFVMRV9VUkwgPSBhc3NldFVybCgnY29yZScsICdsaW5rZXIvdmlldycpO1xuICB2YXIgVklFV19VVElMU19NT0RVTEVfVVJMID0gYXNzZXRVcmwoJ2NvcmUnLCAnbGlua2VyL3ZpZXdfdXRpbHMnKTtcbiAgdmFyIENEX01PRFVMRV9VUkwgPSBhc3NldFVybCgnY29yZScsICdjaGFuZ2VfZGV0ZWN0aW9uL2NoYW5nZV9kZXRlY3Rpb24nKTtcbiAgdmFyIEFOSU1BVElPTl9TVFlMRV9VVElMX0FTU0VUX1VSTCA9IGFzc2V0VXJsKCdjb3JlJywgJ2FuaW1hdGlvbi9hbmltYXRpb25fc3R5bGVfdXRpbCcpO1xuICB2YXIgSWRlbnRpZmllcnMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gSWRlbnRpZmllcnMoKSB7XG4gICAgICB9XG4gICAgICBJZGVudGlmaWVycy5BTkFMWVpFX0ZPUl9FTlRSWV9DT01QT05FTlRTID0ge1xuICAgICAgICAgIG5hbWU6ICdBTkFMWVpFX0ZPUl9FTlRSWV9DT01QT05FTlRTJyxcbiAgICAgICAgICBtb2R1bGVVcmw6IGFzc2V0VXJsKCdjb3JlJywgJ21ldGFkYXRhL2RpJyksXG4gICAgICAgICAgcnVudGltZTogX2FuZ3VsYXJfY29yZS5BTkFMWVpFX0ZPUl9FTlRSWV9DT01QT05FTlRTXG4gICAgICB9O1xuICAgICAgSWRlbnRpZmllcnMuVmlld1V0aWxzID0ge1xuICAgICAgICAgIG5hbWU6ICdWaWV3VXRpbHMnLFxuICAgICAgICAgIG1vZHVsZVVybDogYXNzZXRVcmwoJ2NvcmUnLCAnbGlua2VyL3ZpZXdfdXRpbHMnKSxcbiAgICAgICAgICBydW50aW1lOiB2aWV3X3V0aWxzLlZpZXdVdGlsc1xuICAgICAgfTtcbiAgICAgIElkZW50aWZpZXJzLkFwcFZpZXcgPSB7IG5hbWU6ICdBcHBWaWV3JywgbW9kdWxlVXJsOiBBUFBfVklFV19NT0RVTEVfVVJMLCBydW50aW1lOiBBcHBWaWV3IH07XG4gICAgICBJZGVudGlmaWVycy5EZWJ1Z0FwcFZpZXcgPSB7XG4gICAgICAgICAgbmFtZTogJ0RlYnVnQXBwVmlldycsXG4gICAgICAgICAgbW9kdWxlVXJsOiBBUFBfVklFV19NT0RVTEVfVVJMLFxuICAgICAgICAgIHJ1bnRpbWU6IERlYnVnQXBwVmlld1xuICAgICAgfTtcbiAgICAgIElkZW50aWZpZXJzLkFwcEVsZW1lbnQgPSB7XG4gICAgICAgICAgbmFtZTogJ0FwcEVsZW1lbnQnLFxuICAgICAgICAgIG1vZHVsZVVybDogYXNzZXRVcmwoJ2NvcmUnLCAnbGlua2VyL2VsZW1lbnQnKSxcbiAgICAgICAgICBydW50aW1lOiBBcHBFbGVtZW50XG4gICAgICB9O1xuICAgICAgSWRlbnRpZmllcnMuRWxlbWVudFJlZiA9IHtcbiAgICAgICAgICBuYW1lOiAnRWxlbWVudFJlZicsXG4gICAgICAgICAgbW9kdWxlVXJsOiBhc3NldFVybCgnY29yZScsICdsaW5rZXIvZWxlbWVudF9yZWYnKSxcbiAgICAgICAgICBydW50aW1lOiBfYW5ndWxhcl9jb3JlLkVsZW1lbnRSZWZcbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5WaWV3Q29udGFpbmVyUmVmID0ge1xuICAgICAgICAgIG5hbWU6ICdWaWV3Q29udGFpbmVyUmVmJyxcbiAgICAgICAgICBtb2R1bGVVcmw6IGFzc2V0VXJsKCdjb3JlJywgJ2xpbmtlci92aWV3X2NvbnRhaW5lcl9yZWYnKSxcbiAgICAgICAgICBydW50aW1lOiBfYW5ndWxhcl9jb3JlLlZpZXdDb250YWluZXJSZWZcbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5DaGFuZ2VEZXRlY3RvclJlZiA9IHtcbiAgICAgICAgICBuYW1lOiAnQ2hhbmdlRGV0ZWN0b3JSZWYnLFxuICAgICAgICAgIG1vZHVsZVVybDogYXNzZXRVcmwoJ2NvcmUnLCAnY2hhbmdlX2RldGVjdGlvbi9jaGFuZ2VfZGV0ZWN0b3JfcmVmJyksXG4gICAgICAgICAgcnVudGltZTogX2FuZ3VsYXJfY29yZS5DaGFuZ2VEZXRlY3RvclJlZlxuICAgICAgfTtcbiAgICAgIElkZW50aWZpZXJzLlJlbmRlckNvbXBvbmVudFR5cGUgPSB7XG4gICAgICAgICAgbmFtZTogJ1JlbmRlckNvbXBvbmVudFR5cGUnLFxuICAgICAgICAgIG1vZHVsZVVybDogYXNzZXRVcmwoJ2NvcmUnLCAncmVuZGVyL2FwaScpLFxuICAgICAgICAgIHJ1bnRpbWU6IF9hbmd1bGFyX2NvcmUuUmVuZGVyQ29tcG9uZW50VHlwZVxuICAgICAgfTtcbiAgICAgIElkZW50aWZpZXJzLlF1ZXJ5TGlzdCA9IHtcbiAgICAgICAgICBuYW1lOiAnUXVlcnlMaXN0JyxcbiAgICAgICAgICBtb2R1bGVVcmw6IGFzc2V0VXJsKCdjb3JlJywgJ2xpbmtlci9xdWVyeV9saXN0JyksXG4gICAgICAgICAgcnVudGltZTogX2FuZ3VsYXJfY29yZS5RdWVyeUxpc3RcbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5UZW1wbGF0ZVJlZiA9IHtcbiAgICAgICAgICBuYW1lOiAnVGVtcGxhdGVSZWYnLFxuICAgICAgICAgIG1vZHVsZVVybDogYXNzZXRVcmwoJ2NvcmUnLCAnbGlua2VyL3RlbXBsYXRlX3JlZicpLFxuICAgICAgICAgIHJ1bnRpbWU6IF9hbmd1bGFyX2NvcmUuVGVtcGxhdGVSZWZcbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5UZW1wbGF0ZVJlZl8gPSB7XG4gICAgICAgICAgbmFtZTogJ1RlbXBsYXRlUmVmXycsXG4gICAgICAgICAgbW9kdWxlVXJsOiBhc3NldFVybCgnY29yZScsICdsaW5rZXIvdGVtcGxhdGVfcmVmJyksXG4gICAgICAgICAgcnVudGltZTogVGVtcGxhdGVSZWZfXG4gICAgICB9O1xuICAgICAgSWRlbnRpZmllcnMuQ29kZWdlbkNvbXBvbmVudEZhY3RvcnlSZXNvbHZlciA9IHtcbiAgICAgICAgICBuYW1lOiAnQ29kZWdlbkNvbXBvbmVudEZhY3RvcnlSZXNvbHZlcicsXG4gICAgICAgICAgbW9kdWxlVXJsOiBhc3NldFVybCgnY29yZScsICdsaW5rZXIvY29tcG9uZW50X2ZhY3RvcnlfcmVzb2x2ZXInKSxcbiAgICAgICAgICBydW50aW1lOiBDb2RlZ2VuQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyXG4gICAgICB9O1xuICAgICAgSWRlbnRpZmllcnMuQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyID0ge1xuICAgICAgICAgIG5hbWU6ICdDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXInLFxuICAgICAgICAgIG1vZHVsZVVybDogYXNzZXRVcmwoJ2NvcmUnLCAnbGlua2VyL2NvbXBvbmVudF9mYWN0b3J5X3Jlc29sdmVyJyksXG4gICAgICAgICAgcnVudGltZTogX2FuZ3VsYXJfY29yZS5Db21wb25lbnRGYWN0b3J5UmVzb2x2ZXJcbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5Db21wb25lbnRGYWN0b3J5ID0ge1xuICAgICAgICAgIG5hbWU6ICdDb21wb25lbnRGYWN0b3J5JyxcbiAgICAgICAgICBydW50aW1lOiBfYW5ndWxhcl9jb3JlLkNvbXBvbmVudEZhY3RvcnksXG4gICAgICAgICAgbW9kdWxlVXJsOiBhc3NldFVybCgnY29yZScsICdsaW5rZXIvY29tcG9uZW50X2ZhY3RvcnknKVxuICAgICAgfTtcbiAgICAgIElkZW50aWZpZXJzLk5nTW9kdWxlRmFjdG9yeSA9IHtcbiAgICAgICAgICBuYW1lOiAnTmdNb2R1bGVGYWN0b3J5JyxcbiAgICAgICAgICBydW50aW1lOiBfYW5ndWxhcl9jb3JlLk5nTW9kdWxlRmFjdG9yeSxcbiAgICAgICAgICBtb2R1bGVVcmw6IGFzc2V0VXJsKCdjb3JlJywgJ2xpbmtlci9uZ19tb2R1bGVfZmFjdG9yeScpXG4gICAgICB9O1xuICAgICAgSWRlbnRpZmllcnMuTmdNb2R1bGVJbmplY3RvciA9IHtcbiAgICAgICAgICBuYW1lOiAnTmdNb2R1bGVJbmplY3RvcicsXG4gICAgICAgICAgcnVudGltZTogTmdNb2R1bGVJbmplY3RvcixcbiAgICAgICAgICBtb2R1bGVVcmw6IGFzc2V0VXJsKCdjb3JlJywgJ2xpbmtlci9uZ19tb2R1bGVfZmFjdG9yeScpXG4gICAgICB9O1xuICAgICAgSWRlbnRpZmllcnMuUmVnaXN0ZXJNb2R1bGVGYWN0b3J5Rm4gPSB7XG4gICAgICAgICAgbmFtZTogJ3JlZ2lzdGVyTW9kdWxlRmFjdG9yeScsXG4gICAgICAgICAgcnVudGltZTogcmVnaXN0ZXJNb2R1bGVGYWN0b3J5LFxuICAgICAgICAgIG1vZHVsZVVybDogYXNzZXRVcmwoJ2NvcmUnLCAnbGlua2VyL25nX21vZHVsZV9mYWN0b3J5X2xvYWRlcicpXG4gICAgICB9O1xuICAgICAgSWRlbnRpZmllcnMuVmFsdWVVbndyYXBwZXIgPSB7IG5hbWU6ICdWYWx1ZVVud3JhcHBlcicsIG1vZHVsZVVybDogQ0RfTU9EVUxFX1VSTCwgcnVudGltZTogVmFsdWVVbndyYXBwZXIgfTtcbiAgICAgIElkZW50aWZpZXJzLkluamVjdG9yID0ge1xuICAgICAgICAgIG5hbWU6ICdJbmplY3RvcicsXG4gICAgICAgICAgbW9kdWxlVXJsOiBhc3NldFVybCgnY29yZScsICdkaS9pbmplY3RvcicpLFxuICAgICAgICAgIHJ1bnRpbWU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0b3JcbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5WaWV3RW5jYXBzdWxhdGlvbiA9IHtcbiAgICAgICAgICBuYW1lOiAnVmlld0VuY2Fwc3VsYXRpb24nLFxuICAgICAgICAgIG1vZHVsZVVybDogYXNzZXRVcmwoJ2NvcmUnLCAnbWV0YWRhdGEvdmlldycpLFxuICAgICAgICAgIHJ1bnRpbWU6IF9hbmd1bGFyX2NvcmUuVmlld0VuY2Fwc3VsYXRpb25cbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5WaWV3VHlwZSA9IHtcbiAgICAgICAgICBuYW1lOiAnVmlld1R5cGUnLFxuICAgICAgICAgIG1vZHVsZVVybDogYXNzZXRVcmwoJ2NvcmUnLCAnbGlua2VyL3ZpZXdfdHlwZScpLFxuICAgICAgICAgIHJ1bnRpbWU6IFZpZXdUeXBlXG4gICAgICB9O1xuICAgICAgSWRlbnRpZmllcnMuQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kgPSB7XG4gICAgICAgICAgbmFtZTogJ0NoYW5nZURldGVjdGlvblN0cmF0ZWd5JyxcbiAgICAgICAgICBtb2R1bGVVcmw6IENEX01PRFVMRV9VUkwsXG4gICAgICAgICAgcnVudGltZTogX2FuZ3VsYXJfY29yZS5DaGFuZ2VEZXRlY3Rpb25TdHJhdGVneVxuICAgICAgfTtcbiAgICAgIElkZW50aWZpZXJzLlN0YXRpY05vZGVEZWJ1Z0luZm8gPSB7XG4gICAgICAgICAgbmFtZTogJ1N0YXRpY05vZGVEZWJ1Z0luZm8nLFxuICAgICAgICAgIG1vZHVsZVVybDogYXNzZXRVcmwoJ2NvcmUnLCAnbGlua2VyL2RlYnVnX2NvbnRleHQnKSxcbiAgICAgICAgICBydW50aW1lOiBTdGF0aWNOb2RlRGVidWdJbmZvXG4gICAgICB9O1xuICAgICAgSWRlbnRpZmllcnMuRGVidWdDb250ZXh0ID0ge1xuICAgICAgICAgIG5hbWU6ICdEZWJ1Z0NvbnRleHQnLFxuICAgICAgICAgIG1vZHVsZVVybDogYXNzZXRVcmwoJ2NvcmUnLCAnbGlua2VyL2RlYnVnX2NvbnRleHQnKSxcbiAgICAgICAgICBydW50aW1lOiBEZWJ1Z0NvbnRleHRcbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5SZW5kZXJlciA9IHtcbiAgICAgICAgICBuYW1lOiAnUmVuZGVyZXInLFxuICAgICAgICAgIG1vZHVsZVVybDogYXNzZXRVcmwoJ2NvcmUnLCAncmVuZGVyL2FwaScpLFxuICAgICAgICAgIHJ1bnRpbWU6IF9hbmd1bGFyX2NvcmUuUmVuZGVyZXJcbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5TaW1wbGVDaGFuZ2UgPSB7IG5hbWU6ICdTaW1wbGVDaGFuZ2UnLCBtb2R1bGVVcmw6IENEX01PRFVMRV9VUkwsIHJ1bnRpbWU6IF9hbmd1bGFyX2NvcmUuU2ltcGxlQ2hhbmdlIH07XG4gICAgICBJZGVudGlmaWVycy5VTklOSVRJQUxJWkVEID0geyBuYW1lOiAnVU5JTklUSUFMSVpFRCcsIG1vZHVsZVVybDogQ0RfTU9EVUxFX1VSTCwgcnVudGltZTogVU5JTklUSUFMSVpFRCB9O1xuICAgICAgSWRlbnRpZmllcnMuQ2hhbmdlRGV0ZWN0b3JTdGF0dXMgPSB7XG4gICAgICAgICAgbmFtZTogJ0NoYW5nZURldGVjdG9yU3RhdHVzJyxcbiAgICAgICAgICBtb2R1bGVVcmw6IENEX01PRFVMRV9VUkwsXG4gICAgICAgICAgcnVudGltZTogQ2hhbmdlRGV0ZWN0b3JTdGF0dXNcbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5jaGVja0JpbmRpbmcgPSB7XG4gICAgICAgICAgbmFtZTogJ2NoZWNrQmluZGluZycsXG4gICAgICAgICAgbW9kdWxlVXJsOiBWSUVXX1VUSUxTX01PRFVMRV9VUkwsXG4gICAgICAgICAgcnVudGltZTogdmlld191dGlscy5jaGVja0JpbmRpbmdcbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5mbGF0dGVuTmVzdGVkVmlld1JlbmRlck5vZGVzID0ge1xuICAgICAgICAgIG5hbWU6ICdmbGF0dGVuTmVzdGVkVmlld1JlbmRlck5vZGVzJyxcbiAgICAgICAgICBtb2R1bGVVcmw6IFZJRVdfVVRJTFNfTU9EVUxFX1VSTCxcbiAgICAgICAgICBydW50aW1lOiB2aWV3X3V0aWxzLmZsYXR0ZW5OZXN0ZWRWaWV3UmVuZGVyTm9kZXNcbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5kZXZNb2RlRXF1YWwgPSB7IG5hbWU6ICdkZXZNb2RlRXF1YWwnLCBtb2R1bGVVcmw6IENEX01PRFVMRV9VUkwsIHJ1bnRpbWU6IGRldk1vZGVFcXVhbCB9O1xuICAgICAgSWRlbnRpZmllcnMuaW50ZXJwb2xhdGUgPSB7XG4gICAgICAgICAgbmFtZTogJ2ludGVycG9sYXRlJyxcbiAgICAgICAgICBtb2R1bGVVcmw6IFZJRVdfVVRJTFNfTU9EVUxFX1VSTCxcbiAgICAgICAgICBydW50aW1lOiB2aWV3X3V0aWxzLmludGVycG9sYXRlXG4gICAgICB9O1xuICAgICAgSWRlbnRpZmllcnMuY2FzdEJ5VmFsdWUgPSB7XG4gICAgICAgICAgbmFtZTogJ2Nhc3RCeVZhbHVlJyxcbiAgICAgICAgICBtb2R1bGVVcmw6IFZJRVdfVVRJTFNfTU9EVUxFX1VSTCxcbiAgICAgICAgICBydW50aW1lOiB2aWV3X3V0aWxzLmNhc3RCeVZhbHVlXG4gICAgICB9O1xuICAgICAgSWRlbnRpZmllcnMuRU1QVFlfQVJSQVkgPSB7XG4gICAgICAgICAgbmFtZTogJ0VNUFRZX0FSUkFZJyxcbiAgICAgICAgICBtb2R1bGVVcmw6IFZJRVdfVVRJTFNfTU9EVUxFX1VSTCxcbiAgICAgICAgICBydW50aW1lOiB2aWV3X3V0aWxzLkVNUFRZX0FSUkFZXG4gICAgICB9O1xuICAgICAgSWRlbnRpZmllcnMuRU1QVFlfTUFQID0ge1xuICAgICAgICAgIG5hbWU6ICdFTVBUWV9NQVAnLFxuICAgICAgICAgIG1vZHVsZVVybDogVklFV19VVElMU19NT0RVTEVfVVJMLFxuICAgICAgICAgIHJ1bnRpbWU6IHZpZXdfdXRpbHMuRU1QVFlfTUFQXG4gICAgICB9O1xuICAgICAgSWRlbnRpZmllcnMucHVyZVByb3hpZXMgPSBbXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICB7IG5hbWU6ICdwdXJlUHJveHkxJywgbW9kdWxlVXJsOiBWSUVXX1VUSUxTX01PRFVMRV9VUkwsIHJ1bnRpbWU6IHZpZXdfdXRpbHMucHVyZVByb3h5MSB9LFxuICAgICAgICAgIHsgbmFtZTogJ3B1cmVQcm94eTInLCBtb2R1bGVVcmw6IFZJRVdfVVRJTFNfTU9EVUxFX1VSTCwgcnVudGltZTogdmlld191dGlscy5wdXJlUHJveHkyIH0sXG4gICAgICAgICAgeyBuYW1lOiAncHVyZVByb3h5MycsIG1vZHVsZVVybDogVklFV19VVElMU19NT0RVTEVfVVJMLCBydW50aW1lOiB2aWV3X3V0aWxzLnB1cmVQcm94eTMgfSxcbiAgICAgICAgICB7IG5hbWU6ICdwdXJlUHJveHk0JywgbW9kdWxlVXJsOiBWSUVXX1VUSUxTX01PRFVMRV9VUkwsIHJ1bnRpbWU6IHZpZXdfdXRpbHMucHVyZVByb3h5NCB9LFxuICAgICAgICAgIHsgbmFtZTogJ3B1cmVQcm94eTUnLCBtb2R1bGVVcmw6IFZJRVdfVVRJTFNfTU9EVUxFX1VSTCwgcnVudGltZTogdmlld191dGlscy5wdXJlUHJveHk1IH0sXG4gICAgICAgICAgeyBuYW1lOiAncHVyZVByb3h5NicsIG1vZHVsZVVybDogVklFV19VVElMU19NT0RVTEVfVVJMLCBydW50aW1lOiB2aWV3X3V0aWxzLnB1cmVQcm94eTYgfSxcbiAgICAgICAgICB7IG5hbWU6ICdwdXJlUHJveHk3JywgbW9kdWxlVXJsOiBWSUVXX1VUSUxTX01PRFVMRV9VUkwsIHJ1bnRpbWU6IHZpZXdfdXRpbHMucHVyZVByb3h5NyB9LFxuICAgICAgICAgIHsgbmFtZTogJ3B1cmVQcm94eTgnLCBtb2R1bGVVcmw6IFZJRVdfVVRJTFNfTU9EVUxFX1VSTCwgcnVudGltZTogdmlld191dGlscy5wdXJlUHJveHk4IH0sXG4gICAgICAgICAgeyBuYW1lOiAncHVyZVByb3h5OScsIG1vZHVsZVVybDogVklFV19VVElMU19NT0RVTEVfVVJMLCBydW50aW1lOiB2aWV3X3V0aWxzLnB1cmVQcm94eTkgfSxcbiAgICAgICAgICB7IG5hbWU6ICdwdXJlUHJveHkxMCcsIG1vZHVsZVVybDogVklFV19VVElMU19NT0RVTEVfVVJMLCBydW50aW1lOiB2aWV3X3V0aWxzLnB1cmVQcm94eTEwIH0sXG4gICAgICBdO1xuICAgICAgSWRlbnRpZmllcnMuU2VjdXJpdHlDb250ZXh0ID0ge1xuICAgICAgICAgIG5hbWU6ICdTZWN1cml0eUNvbnRleHQnLFxuICAgICAgICAgIG1vZHVsZVVybDogYXNzZXRVcmwoJ2NvcmUnLCAnc2VjdXJpdHknKSxcbiAgICAgICAgICBydW50aW1lOiBfYW5ndWxhcl9jb3JlLlNlY3VyaXR5Q29udGV4dCxcbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5BbmltYXRpb25LZXlmcmFtZSA9IHtcbiAgICAgICAgICBuYW1lOiAnQW5pbWF0aW9uS2V5ZnJhbWUnLFxuICAgICAgICAgIG1vZHVsZVVybDogYXNzZXRVcmwoJ2NvcmUnLCAnYW5pbWF0aW9uL2FuaW1hdGlvbl9rZXlmcmFtZScpLFxuICAgICAgICAgIHJ1bnRpbWU6IEFuaW1hdGlvbktleWZyYW1lXG4gICAgICB9O1xuICAgICAgSWRlbnRpZmllcnMuQW5pbWF0aW9uU3R5bGVzID0ge1xuICAgICAgICAgIG5hbWU6ICdBbmltYXRpb25TdHlsZXMnLFxuICAgICAgICAgIG1vZHVsZVVybDogYXNzZXRVcmwoJ2NvcmUnLCAnYW5pbWF0aW9uL2FuaW1hdGlvbl9zdHlsZXMnKSxcbiAgICAgICAgICBydW50aW1lOiBBbmltYXRpb25TdHlsZXNcbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5Ob09wQW5pbWF0aW9uUGxheWVyID0ge1xuICAgICAgICAgIG5hbWU6ICdOb09wQW5pbWF0aW9uUGxheWVyJyxcbiAgICAgICAgICBtb2R1bGVVcmw6IGFzc2V0VXJsKCdjb3JlJywgJ2FuaW1hdGlvbi9hbmltYXRpb25fcGxheWVyJyksXG4gICAgICAgICAgcnVudGltZTogTm9PcEFuaW1hdGlvblBsYXllclxuICAgICAgfTtcbiAgICAgIElkZW50aWZpZXJzLkFuaW1hdGlvbkdyb3VwUGxheWVyID0ge1xuICAgICAgICAgIG5hbWU6ICdBbmltYXRpb25Hcm91cFBsYXllcicsXG4gICAgICAgICAgbW9kdWxlVXJsOiBhc3NldFVybCgnY29yZScsICdhbmltYXRpb24vYW5pbWF0aW9uX2dyb3VwX3BsYXllcicpLFxuICAgICAgICAgIHJ1bnRpbWU6IEFuaW1hdGlvbkdyb3VwUGxheWVyXG4gICAgICB9O1xuICAgICAgSWRlbnRpZmllcnMuQW5pbWF0aW9uU2VxdWVuY2VQbGF5ZXIgPSB7XG4gICAgICAgICAgbmFtZTogJ0FuaW1hdGlvblNlcXVlbmNlUGxheWVyJyxcbiAgICAgICAgICBtb2R1bGVVcmw6IGFzc2V0VXJsKCdjb3JlJywgJ2FuaW1hdGlvbi9hbmltYXRpb25fc2VxdWVuY2VfcGxheWVyJyksXG4gICAgICAgICAgcnVudGltZTogQW5pbWF0aW9uU2VxdWVuY2VQbGF5ZXJcbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5wcmVwYXJlRmluYWxBbmltYXRpb25TdHlsZXMgPSB7XG4gICAgICAgICAgbmFtZTogJ3ByZXBhcmVGaW5hbEFuaW1hdGlvblN0eWxlcycsXG4gICAgICAgICAgbW9kdWxlVXJsOiBBTklNQVRJT05fU1RZTEVfVVRJTF9BU1NFVF9VUkwsXG4gICAgICAgICAgcnVudGltZTogcHJlcGFyZUZpbmFsQW5pbWF0aW9uU3R5bGVzXG4gICAgICB9O1xuICAgICAgSWRlbnRpZmllcnMuYmFsYW5jZUFuaW1hdGlvbktleWZyYW1lcyA9IHtcbiAgICAgICAgICBuYW1lOiAnYmFsYW5jZUFuaW1hdGlvbktleWZyYW1lcycsXG4gICAgICAgICAgbW9kdWxlVXJsOiBBTklNQVRJT05fU1RZTEVfVVRJTF9BU1NFVF9VUkwsXG4gICAgICAgICAgcnVudGltZTogYmFsYW5jZUFuaW1hdGlvbktleWZyYW1lc1xuICAgICAgfTtcbiAgICAgIElkZW50aWZpZXJzLmNsZWFyU3R5bGVzID0ge1xuICAgICAgICAgIG5hbWU6ICdjbGVhclN0eWxlcycsXG4gICAgICAgICAgbW9kdWxlVXJsOiBBTklNQVRJT05fU1RZTEVfVVRJTF9BU1NFVF9VUkwsXG4gICAgICAgICAgcnVudGltZTogY2xlYXJTdHlsZXNcbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5yZW5kZXJTdHlsZXMgPSB7XG4gICAgICAgICAgbmFtZTogJ3JlbmRlclN0eWxlcycsXG4gICAgICAgICAgbW9kdWxlVXJsOiBBTklNQVRJT05fU1RZTEVfVVRJTF9BU1NFVF9VUkwsXG4gICAgICAgICAgcnVudGltZTogcmVuZGVyU3R5bGVzXG4gICAgICB9O1xuICAgICAgSWRlbnRpZmllcnMuY29sbGVjdEFuZFJlc29sdmVTdHlsZXMgPSB7XG4gICAgICAgICAgbmFtZTogJ2NvbGxlY3RBbmRSZXNvbHZlU3R5bGVzJyxcbiAgICAgICAgICBtb2R1bGVVcmw6IEFOSU1BVElPTl9TVFlMRV9VVElMX0FTU0VUX1VSTCxcbiAgICAgICAgICBydW50aW1lOiBjb2xsZWN0QW5kUmVzb2x2ZVN0eWxlc1xuICAgICAgfTtcbiAgICAgIElkZW50aWZpZXJzLkxPQ0FMRV9JRCA9IHtcbiAgICAgICAgICBuYW1lOiAnTE9DQUxFX0lEJyxcbiAgICAgICAgICBtb2R1bGVVcmw6IGFzc2V0VXJsKCdjb3JlJywgJ2kxOG4vdG9rZW5zJyksXG4gICAgICAgICAgcnVudGltZTogX2FuZ3VsYXJfY29yZS5MT0NBTEVfSURcbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5UUkFOU0xBVElPTlNfRk9STUFUID0ge1xuICAgICAgICAgIG5hbWU6ICdUUkFOU0xBVElPTlNfRk9STUFUJyxcbiAgICAgICAgICBtb2R1bGVVcmw6IGFzc2V0VXJsKCdjb3JlJywgJ2kxOG4vdG9rZW5zJyksXG4gICAgICAgICAgcnVudGltZTogX2FuZ3VsYXJfY29yZS5UUkFOU0xBVElPTlNfRk9STUFUXG4gICAgICB9O1xuICAgICAgSWRlbnRpZmllcnMuc2V0QmluZGluZ0RlYnVnSW5mbyA9IHtcbiAgICAgICAgICBuYW1lOiAnc2V0QmluZGluZ0RlYnVnSW5mbycsXG4gICAgICAgICAgbW9kdWxlVXJsOiBWSUVXX1VUSUxTX01PRFVMRV9VUkwsXG4gICAgICAgICAgcnVudGltZTogdmlld191dGlscy5zZXRCaW5kaW5nRGVidWdJbmZvXG4gICAgICB9O1xuICAgICAgSWRlbnRpZmllcnMuc2V0QmluZGluZ0RlYnVnSW5mb0ZvckNoYW5nZXMgPSB7XG4gICAgICAgICAgbmFtZTogJ3NldEJpbmRpbmdEZWJ1Z0luZm9Gb3JDaGFuZ2VzJyxcbiAgICAgICAgICBtb2R1bGVVcmw6IFZJRVdfVVRJTFNfTU9EVUxFX1VSTCxcbiAgICAgICAgICBydW50aW1lOiB2aWV3X3V0aWxzLnNldEJpbmRpbmdEZWJ1Z0luZm9Gb3JDaGFuZ2VzXG4gICAgICB9O1xuICAgICAgSWRlbnRpZmllcnMuQW5pbWF0aW9uVHJhbnNpdGlvbiA9IHtcbiAgICAgICAgICBuYW1lOiAnQW5pbWF0aW9uVHJhbnNpdGlvbicsXG4gICAgICAgICAgbW9kdWxlVXJsOiBhc3NldFVybCgnY29yZScsICdhbmltYXRpb24vYW5pbWF0aW9uX3RyYW5zaXRpb24nKSxcbiAgICAgICAgICBydW50aW1lOiBBbmltYXRpb25UcmFuc2l0aW9uXG4gICAgICB9O1xuICAgICAgcmV0dXJuIElkZW50aWZpZXJzO1xuICB9KCkpO1xuICBmdW5jdGlvbiByZXNvbHZlSWRlbnRpZmllcihpZGVudGlmaWVyKSB7XG4gICAgICByZXR1cm4gbmV3IENvbXBpbGVJZGVudGlmaWVyTWV0YWRhdGEoe1xuICAgICAgICAgIG5hbWU6IGlkZW50aWZpZXIubmFtZSxcbiAgICAgICAgICBtb2R1bGVVcmw6IGlkZW50aWZpZXIubW9kdWxlVXJsLFxuICAgICAgICAgIHJlZmVyZW5jZTogcmVmbGVjdG9yLnJlc29sdmVJZGVudGlmaWVyKGlkZW50aWZpZXIubmFtZSwgaWRlbnRpZmllci5tb2R1bGVVcmwsIGlkZW50aWZpZXIucnVudGltZSlcbiAgICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGlkZW50aWZpZXJUb2tlbihpZGVudGlmaWVyKSB7XG4gICAgICByZXR1cm4gbmV3IENvbXBpbGVUb2tlbk1ldGFkYXRhKHsgaWRlbnRpZmllcjogaWRlbnRpZmllciB9KTtcbiAgfVxuICBmdW5jdGlvbiByZXNvbHZlSWRlbnRpZmllclRva2VuKGlkZW50aWZpZXIpIHtcbiAgICAgIHJldHVybiBpZGVudGlmaWVyVG9rZW4ocmVzb2x2ZUlkZW50aWZpZXIoaWRlbnRpZmllcikpO1xuICB9XG4gIGZ1bmN0aW9uIHJlc29sdmVFbnVtSWRlbnRpZmllcihlbnVtVHlwZSwgbmFtZSkge1xuICAgICAgdmFyIHJlc29sdmVkRW51bSA9IHJlZmxlY3Rvci5yZXNvbHZlRW51bShlbnVtVHlwZS5yZWZlcmVuY2UsIG5hbWUpO1xuICAgICAgcmV0dXJuIG5ldyBDb21waWxlSWRlbnRpZmllck1ldGFkYXRhKHsgbmFtZTogZW51bVR5cGUubmFtZSArIFwiLlwiICsgbmFtZSwgbW9kdWxlVXJsOiBlbnVtVHlwZS5tb2R1bGVVcmwsIHJlZmVyZW5jZTogcmVzb2x2ZWRFbnVtIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBsaWNlbnNlXG4gICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgKlxuICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAqL1xuICB2YXIgX19leHRlbmRzJDkgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gIH07XG4gIHZhciBIdG1sUGFyc2VyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQ5KEh0bWxQYXJzZXIsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBIdG1sUGFyc2VyKCkge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGdldEh0bWxUYWdEZWZpbml0aW9uKTtcbiAgICAgIH1cbiAgICAgIEh0bWxQYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHNvdXJjZSwgdXJsLCBwYXJzZUV4cGFuc2lvbkZvcm1zLCBpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgICAgaWYgKHBhcnNlRXhwYW5zaW9uRm9ybXMgPT09IHZvaWQgMCkgeyBwYXJzZUV4cGFuc2lvbkZvcm1zID0gZmFsc2U7IH1cbiAgICAgICAgICBpZiAoaW50ZXJwb2xhdGlvbkNvbmZpZyA9PT0gdm9pZCAwKSB7IGludGVycG9sYXRpb25Db25maWcgPSBERUZBVUxUX0lOVEVSUE9MQVRJT05fQ09ORklHOyB9XG4gICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUucGFyc2UuY2FsbCh0aGlzLCBzb3VyY2UsIHVybCwgcGFyc2VFeHBhbnNpb25Gb3JtcywgaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICB9O1xuICAgICAgSHRtbFBhcnNlci5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG4gICAgICBdO1xuICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICBIdG1sUGFyc2VyLmN0b3JQYXJhbWV0ZXJzID0gW107XG4gICAgICByZXR1cm4gSHRtbFBhcnNlcjtcbiAgfShQYXJzZXIkMSkpO1xuXG4gIC8qKlxuICAgKiBAbGljZW5zZVxuICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICpcbiAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgKi9cbiAgdmFyIF9fZXh0ZW5kcyQxMCA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgfTtcbiAgLy8gaHR0cDovL2NsZHIudW5pY29kZS5vcmcvaW5kZXgvY2xkci1zcGVjL3BsdXJhbC1ydWxlc1xuICB2YXIgUExVUkFMX0NBU0VTID0gWyd6ZXJvJywgJ29uZScsICd0d28nLCAnZmV3JywgJ21hbnknLCAnb3RoZXInXTtcbiAgLyoqXG4gICAqIEV4cGFuZHMgc3BlY2lhbCBmb3JtcyBpbnRvIGVsZW1lbnRzLlxuICAgKlxuICAgKiBGb3IgZXhhbXBsZSxcbiAgICpcbiAgICogYGBgXG4gICAqIHsgbWVzc2FnZXMubGVuZ3RoLCBwbHVyYWwsXG4gICAqICAgPTAge3plcm99XG4gICAqICAgPTEge29uZX1cbiAgICogICBvdGhlciB7bW9yZSB0aGFuIG9uZX1cbiAgICogfVxuICAgKiBgYGBcbiAgICpcbiAgICogd2lsbCBiZSBleHBhbmRlZCBpbnRvXG4gICAqXG4gICAqIGBgYFxuICAgKiA8bmctY29udGFpbmVyIFtuZ1BsdXJhbF09XCJtZXNzYWdlcy5sZW5ndGhcIj5cbiAgICogICA8dGVtcGxhdGUgbmdQbHVyYWxDYXNlPVwiPTBcIj56ZXJvPC9uZy1jb250YWluZXI+XG4gICAqICAgPHRlbXBsYXRlIG5nUGx1cmFsQ2FzZT1cIj0xXCI+b25lPC9uZy1jb250YWluZXI+XG4gICAqICAgPHRlbXBsYXRlIG5nUGx1cmFsQ2FzZT1cIm90aGVyXCI+bW9yZSB0aGFuIG9uZTwvbmctY29udGFpbmVyPlxuICAgKiA8L25nLWNvbnRhaW5lcj5cbiAgICogYGBgXG4gICAqL1xuICBmdW5jdGlvbiBleHBhbmROb2Rlcyhub2Rlcykge1xuICAgICAgdmFyIGV4cGFuZGVyID0gbmV3IF9FeHBhbmRlcigpO1xuICAgICAgcmV0dXJuIG5ldyBFeHBhbnNpb25SZXN1bHQodmlzaXRBbGwoZXhwYW5kZXIsIG5vZGVzKSwgZXhwYW5kZXIuaXNFeHBhbmRlZCwgZXhwYW5kZXIuZXJyb3JzKTtcbiAgfVxuICB2YXIgRXhwYW5zaW9uUmVzdWx0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIEV4cGFuc2lvblJlc3VsdChub2RlcywgZXhwYW5kZWQsIGVycm9ycykge1xuICAgICAgICAgIHRoaXMubm9kZXMgPSBub2RlcztcbiAgICAgICAgICB0aGlzLmV4cGFuZGVkID0gZXhwYW5kZWQ7XG4gICAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICB9XG4gICAgICByZXR1cm4gRXhwYW5zaW9uUmVzdWx0O1xuICB9KCkpO1xuICB2YXIgRXhwYW5zaW9uRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDEwKEV4cGFuc2lvbkVycm9yLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gRXhwYW5zaW9uRXJyb3Ioc3BhbiwgZXJyb3JNc2cpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuLCBlcnJvck1zZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gRXhwYW5zaW9uRXJyb3I7XG4gIH0oUGFyc2VFcnJvcikpO1xuICAvKipcbiAgICogRXhwYW5kIGV4cGFuc2lvbiBmb3JtcyAocGx1cmFsLCBzZWxlY3QpIHRvIGRpcmVjdGl2ZXNcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICB2YXIgX0V4cGFuZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIF9FeHBhbmRlcigpIHtcbiAgICAgICAgICB0aGlzLmlzRXhwYW5kZWQgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgICAgfVxuICAgICAgX0V4cGFuZGVyLnByb3RvdHlwZS52aXNpdEVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiBuZXcgRWxlbWVudChlbGVtZW50Lm5hbWUsIGVsZW1lbnQuYXR0cnMsIHZpc2l0QWxsKHRoaXMsIGVsZW1lbnQuY2hpbGRyZW4pLCBlbGVtZW50LnNvdXJjZVNwYW4sIGVsZW1lbnQuc3RhcnRTb3VyY2VTcGFuLCBlbGVtZW50LmVuZFNvdXJjZVNwYW4pO1xuICAgICAgfTtcbiAgICAgIF9FeHBhbmRlci5wcm90b3R5cGUudmlzaXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXR0cmlidXRlLCBjb250ZXh0KSB7IHJldHVybiBhdHRyaWJ1dGU7IH07XG4gICAgICBfRXhwYW5kZXIucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCBjb250ZXh0KSB7IHJldHVybiB0ZXh0OyB9O1xuICAgICAgX0V4cGFuZGVyLnByb3RvdHlwZS52aXNpdENvbW1lbnQgPSBmdW5jdGlvbiAoY29tbWVudCwgY29udGV4dCkgeyByZXR1cm4gY29tbWVudDsgfTtcbiAgICAgIF9FeHBhbmRlci5wcm90b3R5cGUudmlzaXRFeHBhbnNpb24gPSBmdW5jdGlvbiAoaWN1LCBjb250ZXh0KSB7XG4gICAgICAgICAgdGhpcy5pc0V4cGFuZGVkID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gaWN1LnR5cGUgPT0gJ3BsdXJhbCcgPyBfZXhwYW5kUGx1cmFsRm9ybShpY3UsIHRoaXMuZXJyb3JzKSA6XG4gICAgICAgICAgICAgIF9leHBhbmREZWZhdWx0Rm9ybShpY3UsIHRoaXMuZXJyb3JzKTtcbiAgICAgIH07XG4gICAgICBfRXhwYW5kZXIucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uQ2FzZSA9IGZ1bmN0aW9uIChpY3VDYXNlLCBjb250ZXh0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaG91bGQgbm90IGJlIHJlYWNoZWQnKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gX0V4cGFuZGVyO1xuICB9KCkpO1xuICBmdW5jdGlvbiBfZXhwYW5kUGx1cmFsRm9ybShhc3QsIGVycm9ycykge1xuICAgICAgdmFyIGNoaWxkcmVuID0gYXN0LmNhc2VzLm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgICAgIGlmIChQTFVSQUxfQ0FTRVMuaW5kZXhPZihjLnZhbHVlKSA9PSAtMSAmJiAhYy52YWx1ZS5tYXRjaCgvXj1cXGQrJC8pKSB7XG4gICAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBFeHBhbnNpb25FcnJvcihjLnZhbHVlU291cmNlU3BhbiwgXCJQbHVyYWwgY2FzZXMgc2hvdWxkIGJlIFxcXCI9PG51bWJlcj5cXFwiIG9yIG9uZSBvZiBcIiArIFBMVVJBTF9DQVNFUy5qb2luKFwiLCBcIikpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGV4cGFuc2lvblJlc3VsdCA9IGV4cGFuZE5vZGVzKGMuZXhwcmVzc2lvbik7XG4gICAgICAgICAgZXJyb3JzLnB1c2guYXBwbHkoZXJyb3JzLCBleHBhbnNpb25SZXN1bHQuZXJyb3JzKTtcbiAgICAgICAgICByZXR1cm4gbmV3IEVsZW1lbnQoXCJ0ZW1wbGF0ZVwiLCBbbmV3IEF0dHJpYnV0ZSQxKCduZ1BsdXJhbENhc2UnLCBcIlwiICsgYy52YWx1ZSwgYy52YWx1ZVNvdXJjZVNwYW4pXSwgZXhwYW5zaW9uUmVzdWx0Lm5vZGVzLCBjLnNvdXJjZVNwYW4sIGMuc291cmNlU3BhbiwgYy5zb3VyY2VTcGFuKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIHN3aXRjaEF0dHIgPSBuZXcgQXR0cmlidXRlJDEoJ1tuZ1BsdXJhbF0nLCBhc3Quc3dpdGNoVmFsdWUsIGFzdC5zd2l0Y2hWYWx1ZVNvdXJjZVNwYW4pO1xuICAgICAgcmV0dXJuIG5ldyBFbGVtZW50KCduZy1jb250YWluZXInLCBbc3dpdGNoQXR0cl0sIGNoaWxkcmVuLCBhc3Quc291cmNlU3BhbiwgYXN0LnNvdXJjZVNwYW4sIGFzdC5zb3VyY2VTcGFuKTtcbiAgfVxuICBmdW5jdGlvbiBfZXhwYW5kRGVmYXVsdEZvcm0oYXN0LCBlcnJvcnMpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IGFzdC5jYXNlcy5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICB2YXIgZXhwYW5zaW9uUmVzdWx0ID0gZXhwYW5kTm9kZXMoYy5leHByZXNzaW9uKTtcbiAgICAgICAgICBlcnJvcnMucHVzaC5hcHBseShlcnJvcnMsIGV4cGFuc2lvblJlc3VsdC5lcnJvcnMpO1xuICAgICAgICAgIHJldHVybiBuZXcgRWxlbWVudChcInRlbXBsYXRlXCIsIFtuZXcgQXR0cmlidXRlJDEoJ25nU3dpdGNoQ2FzZScsIFwiXCIgKyBjLnZhbHVlLCBjLnZhbHVlU291cmNlU3BhbildLCBleHBhbnNpb25SZXN1bHQubm9kZXMsIGMuc291cmNlU3BhbiwgYy5zb3VyY2VTcGFuLCBjLnNvdXJjZVNwYW4pO1xuICAgICAgfSk7XG4gICAgICB2YXIgc3dpdGNoQXR0ciA9IG5ldyBBdHRyaWJ1dGUkMSgnW25nU3dpdGNoXScsIGFzdC5zd2l0Y2hWYWx1ZSwgYXN0LnN3aXRjaFZhbHVlU291cmNlU3Bhbik7XG4gICAgICByZXR1cm4gbmV3IEVsZW1lbnQoJ25nLWNvbnRhaW5lcicsIFtzd2l0Y2hBdHRyXSwgY2hpbGRyZW4sIGFzdC5zb3VyY2VTcGFuLCBhc3Quc291cmNlU3BhbiwgYXN0LnNvdXJjZVNwYW4pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBsaWNlbnNlXG4gICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgKlxuICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAqL1xuICB2YXIgX19leHRlbmRzJDExID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICB9O1xuICB2YXIgUHJvdmlkZXJFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMTEoUHJvdmlkZXJFcnJvciwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIFByb3ZpZGVyRXJyb3IobWVzc2FnZSwgc3Bhbikge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHNwYW4sIG1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFByb3ZpZGVyRXJyb3I7XG4gIH0oUGFyc2VFcnJvcikpO1xuICB2YXIgUHJvdmlkZXJWaWV3Q29udGV4dCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBQcm92aWRlclZpZXdDb250ZXh0KGNvbXBvbmVudCwgc291cmNlU3Bhbikge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XG4gICAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgICAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgICAgICAgIHRoaXMudmlld1F1ZXJpZXMgPSBfZ2V0Vmlld1F1ZXJpZXMoY29tcG9uZW50KTtcbiAgICAgICAgICB0aGlzLnZpZXdQcm92aWRlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgX25vcm1hbGl6ZVByb3ZpZGVycyhjb21wb25lbnQudmlld1Byb3ZpZGVycywgc291cmNlU3BhbiwgdGhpcy5lcnJvcnMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ZpZGVyKSB7XG4gICAgICAgICAgICAgIGlmIChpc0JsYW5rKF90aGlzLnZpZXdQcm92aWRlcnMuZ2V0KHByb3ZpZGVyLnRva2VuLnJlZmVyZW5jZSkpKSB7XG4gICAgICAgICAgICAgICAgICBfdGhpcy52aWV3UHJvdmlkZXJzLnNldChwcm92aWRlci50b2tlbi5yZWZlcmVuY2UsIHRydWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gUHJvdmlkZXJWaWV3Q29udGV4dDtcbiAgfSgpKTtcbiAgdmFyIFByb3ZpZGVyRWxlbWVudENvbnRleHQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gUHJvdmlkZXJFbGVtZW50Q29udGV4dCh2aWV3Q29udGV4dCwgX3BhcmVudCwgX2lzVmlld1Jvb3QsIF9kaXJlY3RpdmVBc3RzLCBhdHRycywgcmVmcywgX3NvdXJjZVNwYW4pIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHRoaXMudmlld0NvbnRleHQgPSB2aWV3Q29udGV4dDtcbiAgICAgICAgICB0aGlzLl9wYXJlbnQgPSBfcGFyZW50O1xuICAgICAgICAgIHRoaXMuX2lzVmlld1Jvb3QgPSBfaXNWaWV3Um9vdDtcbiAgICAgICAgICB0aGlzLl9kaXJlY3RpdmVBc3RzID0gX2RpcmVjdGl2ZUFzdHM7XG4gICAgICAgICAgdGhpcy5fc291cmNlU3BhbiA9IF9zb3VyY2VTcGFuO1xuICAgICAgICAgIHRoaXMuX3RyYW5zZm9ybWVkUHJvdmlkZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICAgIHRoaXMuX3NlZW5Qcm92aWRlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgdGhpcy5faGFzVmlld0NvbnRhaW5lciA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuX2F0dHJzID0ge307XG4gICAgICAgICAgYXR0cnMuZm9yRWFjaChmdW5jdGlvbiAoYXR0ckFzdCkgeyByZXR1cm4gX3RoaXMuX2F0dHJzW2F0dHJBc3QubmFtZV0gPSBhdHRyQXN0LnZhbHVlOyB9KTtcbiAgICAgICAgICB2YXIgZGlyZWN0aXZlc01ldGEgPSBfZGlyZWN0aXZlQXN0cy5tYXAoZnVuY3Rpb24gKGRpcmVjdGl2ZUFzdCkgeyByZXR1cm4gZGlyZWN0aXZlQXN0LmRpcmVjdGl2ZTsgfSk7XG4gICAgICAgICAgdGhpcy5fYWxsUHJvdmlkZXJzID1cbiAgICAgICAgICAgICAgX3Jlc29sdmVQcm92aWRlcnNGcm9tRGlyZWN0aXZlcyhkaXJlY3RpdmVzTWV0YSwgX3NvdXJjZVNwYW4sIHZpZXdDb250ZXh0LmVycm9ycyk7XG4gICAgICAgICAgdGhpcy5fY29udGVudFF1ZXJpZXMgPSBfZ2V0Q29udGVudFF1ZXJpZXMoZGlyZWN0aXZlc01ldGEpO1xuICAgICAgICAgIHZhciBxdWVyaWVkVG9rZW5zID0gbmV3IE1hcCgpO1xuICAgICAgICAgIE1hcFdyYXBwZXIudmFsdWVzKHRoaXMuX2FsbFByb3ZpZGVycykuZm9yRWFjaChmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgX3RoaXMuX2FkZFF1ZXJ5UmVhZHNUbyhwcm92aWRlci50b2tlbiwgcXVlcmllZFRva2Vucyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmVmcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWZBc3QpIHtcbiAgICAgICAgICAgICAgX3RoaXMuX2FkZFF1ZXJ5UmVhZHNUbyhuZXcgQ29tcGlsZVRva2VuTWV0YWRhdGEoeyB2YWx1ZTogcmVmQXN0Lm5hbWUgfSksIHF1ZXJpZWRUb2tlbnMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChpc1ByZXNlbnQocXVlcmllZFRva2Vucy5nZXQocmVzb2x2ZUlkZW50aWZpZXJUb2tlbihJZGVudGlmaWVycy5WaWV3Q29udGFpbmVyUmVmKS5yZWZlcmVuY2UpKSkge1xuICAgICAgICAgICAgICB0aGlzLl9oYXNWaWV3Q29udGFpbmVyID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gY3JlYXRlIHRoZSBwcm92aWRlcnMgdGhhdCB3ZSBrbm93IGFyZSBlYWdlciBmaXJzdFxuICAgICAgICAgIE1hcFdyYXBwZXIudmFsdWVzKHRoaXMuX2FsbFByb3ZpZGVycykuZm9yRWFjaChmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgdmFyIGVhZ2VyID0gcHJvdmlkZXIuZWFnZXIgfHwgaXNQcmVzZW50KHF1ZXJpZWRUb2tlbnMuZ2V0KHByb3ZpZGVyLnRva2VuLnJlZmVyZW5jZSkpO1xuICAgICAgICAgICAgICBpZiAoZWFnZXIpIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzLl9nZXRPckNyZWF0ZUxvY2FsUHJvdmlkZXIocHJvdmlkZXIucHJvdmlkZXJUeXBlLCBwcm92aWRlci50b2tlbiwgdHJ1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIFByb3ZpZGVyRWxlbWVudENvbnRleHQucHJvdG90eXBlLmFmdGVyRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIC8vIGNvbGxlY3QgbGF6eSBwcm92aWRlcnNcbiAgICAgICAgICBNYXBXcmFwcGVyLnZhbHVlcyh0aGlzLl9hbGxQcm92aWRlcnMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ZpZGVyKSB7XG4gICAgICAgICAgICAgIF90aGlzLl9nZXRPckNyZWF0ZUxvY2FsUHJvdmlkZXIocHJvdmlkZXIucHJvdmlkZXJUeXBlLCBwcm92aWRlci50b2tlbiwgZmFsc2UpO1xuICAgICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQcm92aWRlckVsZW1lbnRDb250ZXh0LnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1Qcm92aWRlcnNcIiwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gTWFwV3JhcHBlci52YWx1ZXModGhpcy5fdHJhbnNmb3JtZWRQcm92aWRlcnMpOyB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQcm92aWRlckVsZW1lbnRDb250ZXh0LnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1lZERpcmVjdGl2ZUFzdHNcIiwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgc29ydGVkUHJvdmlkZXJUeXBlcyA9IHRoaXMudHJhbnNmb3JtUHJvdmlkZXJzLm1hcChmdW5jdGlvbiAocHJvdmlkZXIpIHsgcmV0dXJuIHByb3ZpZGVyLnRva2VuLmlkZW50aWZpZXI7IH0pO1xuICAgICAgICAgICAgICB2YXIgc29ydGVkRGlyZWN0aXZlcyA9IExpc3RXcmFwcGVyLmNsb25lKHRoaXMuX2RpcmVjdGl2ZUFzdHMpO1xuICAgICAgICAgICAgICBMaXN0V3JhcHBlci5zb3J0KHNvcnRlZERpcmVjdGl2ZXMsIGZ1bmN0aW9uIChkaXIxLCBkaXIyKSB7IHJldHVybiBzb3J0ZWRQcm92aWRlclR5cGVzLmluZGV4T2YoZGlyMS5kaXJlY3RpdmUudHlwZSkgLVxuICAgICAgICAgICAgICAgICAgc29ydGVkUHJvdmlkZXJUeXBlcy5pbmRleE9mKGRpcjIuZGlyZWN0aXZlLnR5cGUpOyB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuIHNvcnRlZERpcmVjdGl2ZXM7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUHJvdmlkZXJFbGVtZW50Q29udGV4dC5wcm90b3R5cGUsIFwidHJhbnNmb3JtZWRIYXNWaWV3Q29udGFpbmVyXCIsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2hhc1ZpZXdDb250YWluZXI7IH0sXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgUHJvdmlkZXJFbGVtZW50Q29udGV4dC5wcm90b3R5cGUuX2FkZFF1ZXJ5UmVhZHNUbyA9IGZ1bmN0aW9uICh0b2tlbiwgcXVlcnlSZWFkVG9rZW5zKSB7XG4gICAgICAgICAgdGhpcy5fZ2V0UXVlcmllc0Zvcih0b2tlbikuZm9yRWFjaChmdW5jdGlvbiAocXVlcnkpIHtcbiAgICAgICAgICAgICAgdmFyIHF1ZXJ5UmVhZFRva2VuID0gcXVlcnkucmVhZCB8fCB0b2tlbjtcbiAgICAgICAgICAgICAgaWYgKGlzQmxhbmsocXVlcnlSZWFkVG9rZW5zLmdldChxdWVyeVJlYWRUb2tlbi5yZWZlcmVuY2UpKSkge1xuICAgICAgICAgICAgICAgICAgcXVlcnlSZWFkVG9rZW5zLnNldChxdWVyeVJlYWRUb2tlbi5yZWZlcmVuY2UsIHRydWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgUHJvdmlkZXJFbGVtZW50Q29udGV4dC5wcm90b3R5cGUuX2dldFF1ZXJpZXNGb3IgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgdmFyIGN1cnJlbnRFbCA9IHRoaXM7XG4gICAgICAgICAgdmFyIGRpc3RhbmNlID0gMDtcbiAgICAgICAgICB2YXIgcXVlcmllcztcbiAgICAgICAgICB3aGlsZSAoY3VycmVudEVsICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHF1ZXJpZXMgPSBjdXJyZW50RWwuX2NvbnRlbnRRdWVyaWVzLmdldCh0b2tlbi5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KHF1ZXJpZXMpKSB7XG4gICAgICAgICAgICAgICAgICBMaXN0V3JhcHBlci5hZGRBbGwocmVzdWx0LCBxdWVyaWVzLmZpbHRlcihmdW5jdGlvbiAocXVlcnkpIHsgcmV0dXJuIHF1ZXJ5LmRlc2NlbmRhbnRzIHx8IGRpc3RhbmNlIDw9IDE7IH0pKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoY3VycmVudEVsLl9kaXJlY3RpdmVBc3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIGRpc3RhbmNlKys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY3VycmVudEVsID0gY3VycmVudEVsLl9wYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHF1ZXJpZXMgPSB0aGlzLnZpZXdDb250ZXh0LnZpZXdRdWVyaWVzLmdldCh0b2tlbi5yZWZlcmVuY2UpO1xuICAgICAgICAgIGlmIChpc1ByZXNlbnQocXVlcmllcykpIHtcbiAgICAgICAgICAgICAgTGlzdFdyYXBwZXIuYWRkQWxsKHJlc3VsdCwgcXVlcmllcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgICAgUHJvdmlkZXJFbGVtZW50Q29udGV4dC5wcm90b3R5cGUuX2dldE9yQ3JlYXRlTG9jYWxQcm92aWRlciA9IGZ1bmN0aW9uIChyZXF1ZXN0aW5nUHJvdmlkZXJUeXBlLCB0b2tlbiwgZWFnZXIpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciByZXNvbHZlZFByb3ZpZGVyID0gdGhpcy5fYWxsUHJvdmlkZXJzLmdldCh0b2tlbi5yZWZlcmVuY2UpO1xuICAgICAgICAgIGlmICghcmVzb2x2ZWRQcm92aWRlciB8fCAoKHJlcXVlc3RpbmdQcm92aWRlclR5cGUgPT09IGV4cG9ydHMuUHJvdmlkZXJBc3RUeXBlLkRpcmVjdGl2ZSB8fFxuICAgICAgICAgICAgICByZXF1ZXN0aW5nUHJvdmlkZXJUeXBlID09PSBleHBvcnRzLlByb3ZpZGVyQXN0VHlwZS5QdWJsaWNTZXJ2aWNlKSAmJlxuICAgICAgICAgICAgICByZXNvbHZlZFByb3ZpZGVyLnByb3ZpZGVyVHlwZSA9PT0gZXhwb3J0cy5Qcm92aWRlckFzdFR5cGUuUHJpdmF0ZVNlcnZpY2UpIHx8XG4gICAgICAgICAgICAgICgocmVxdWVzdGluZ1Byb3ZpZGVyVHlwZSA9PT0gZXhwb3J0cy5Qcm92aWRlckFzdFR5cGUuUHJpdmF0ZVNlcnZpY2UgfHxcbiAgICAgICAgICAgICAgICAgIHJlcXVlc3RpbmdQcm92aWRlclR5cGUgPT09IGV4cG9ydHMuUHJvdmlkZXJBc3RUeXBlLlB1YmxpY1NlcnZpY2UpICYmXG4gICAgICAgICAgICAgICAgICByZXNvbHZlZFByb3ZpZGVyLnByb3ZpZGVyVHlwZSA9PT0gZXhwb3J0cy5Qcm92aWRlckFzdFR5cGUuQnVpbHRpbikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB0cmFuc2Zvcm1lZFByb3ZpZGVyQXN0ID0gdGhpcy5fdHJhbnNmb3JtZWRQcm92aWRlcnMuZ2V0KHRva2VuLnJlZmVyZW5jZSk7XG4gICAgICAgICAgaWYgKGlzUHJlc2VudCh0cmFuc2Zvcm1lZFByb3ZpZGVyQXN0KSkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtZWRQcm92aWRlckFzdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLl9zZWVuUHJvdmlkZXJzLmdldCh0b2tlbi5yZWZlcmVuY2UpKSkge1xuICAgICAgICAgICAgICB0aGlzLnZpZXdDb250ZXh0LmVycm9ycy5wdXNoKG5ldyBQcm92aWRlckVycm9yKFwiQ2Fubm90IGluc3RhbnRpYXRlIGN5Y2xpYyBkZXBlbmRlbmN5ISBcIiArIHRva2VuLm5hbWUsIHRoaXMuX3NvdXJjZVNwYW4pKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3NlZW5Qcm92aWRlcnMuc2V0KHRva2VuLnJlZmVyZW5jZSwgdHJ1ZSk7XG4gICAgICAgICAgdmFyIHRyYW5zZm9ybWVkUHJvdmlkZXJzID0gcmVzb2x2ZWRQcm92aWRlci5wcm92aWRlcnMubWFwKGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtZWRVc2VWYWx1ZSA9IHByb3ZpZGVyLnVzZVZhbHVlO1xuICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtZWRVc2VFeGlzdGluZyA9IHByb3ZpZGVyLnVzZUV4aXN0aW5nO1xuICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtZWREZXBzO1xuICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KHByb3ZpZGVyLnVzZUV4aXN0aW5nKSkge1xuICAgICAgICAgICAgICAgICAgdmFyIGV4aXN0aW5nRGlEZXAgPSBfdGhpcy5fZ2V0RGVwZW5kZW5jeShyZXNvbHZlZFByb3ZpZGVyLnByb3ZpZGVyVHlwZSwgbmV3IENvbXBpbGVEaURlcGVuZGVuY3lNZXRhZGF0YSh7IHRva2VuOiBwcm92aWRlci51c2VFeGlzdGluZyB9KSwgZWFnZXIpO1xuICAgICAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudChleGlzdGluZ0RpRGVwLnRva2VuKSkge1xuICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkVXNlRXhpc3RpbmcgPSBleGlzdGluZ0RpRGVwLnRva2VuO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtZWRVc2VFeGlzdGluZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtZWRVc2VWYWx1ZSA9IGV4aXN0aW5nRGlEZXAudmFsdWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAoaXNQcmVzZW50KHByb3ZpZGVyLnVzZUZhY3RvcnkpKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZGVwcyA9IHByb3ZpZGVyLmRlcHMgfHwgcHJvdmlkZXIudXNlRmFjdG9yeS5kaURlcHM7XG4gICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZERlcHMgPVxuICAgICAgICAgICAgICAgICAgICAgIGRlcHMubWFwKGZ1bmN0aW9uIChkZXApIHsgcmV0dXJuIF90aGlzLl9nZXREZXBlbmRlbmN5KHJlc29sdmVkUHJvdmlkZXIucHJvdmlkZXJUeXBlLCBkZXAsIGVhZ2VyKTsgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAoaXNQcmVzZW50KHByb3ZpZGVyLnVzZUNsYXNzKSkge1xuICAgICAgICAgICAgICAgICAgdmFyIGRlcHMgPSBwcm92aWRlci5kZXBzIHx8IHByb3ZpZGVyLnVzZUNsYXNzLmRpRGVwcztcbiAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkRGVwcyA9XG4gICAgICAgICAgICAgICAgICAgICAgZGVwcy5tYXAoZnVuY3Rpb24gKGRlcCkgeyByZXR1cm4gX3RoaXMuX2dldERlcGVuZGVuY3kocmVzb2x2ZWRQcm92aWRlci5wcm92aWRlclR5cGUsIGRlcCwgZWFnZXIpOyB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gX3RyYW5zZm9ybVByb3ZpZGVyKHByb3ZpZGVyLCB7XG4gICAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogdHJhbnNmb3JtZWRVc2VFeGlzdGluZyxcbiAgICAgICAgICAgICAgICAgIHVzZVZhbHVlOiB0cmFuc2Zvcm1lZFVzZVZhbHVlLFxuICAgICAgICAgICAgICAgICAgZGVwczogdHJhbnNmb3JtZWREZXBzXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRyYW5zZm9ybWVkUHJvdmlkZXJBc3QgPVxuICAgICAgICAgICAgICBfdHJhbnNmb3JtUHJvdmlkZXJBc3QocmVzb2x2ZWRQcm92aWRlciwgeyBlYWdlcjogZWFnZXIsIHByb3ZpZGVyczogdHJhbnNmb3JtZWRQcm92aWRlcnMgfSk7XG4gICAgICAgICAgdGhpcy5fdHJhbnNmb3JtZWRQcm92aWRlcnMuc2V0KHRva2VuLnJlZmVyZW5jZSwgdHJhbnNmb3JtZWRQcm92aWRlckFzdCk7XG4gICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVkUHJvdmlkZXJBc3Q7XG4gICAgICB9O1xuICAgICAgUHJvdmlkZXJFbGVtZW50Q29udGV4dC5wcm90b3R5cGUuX2dldExvY2FsRGVwZW5kZW5jeSA9IGZ1bmN0aW9uIChyZXF1ZXN0aW5nUHJvdmlkZXJUeXBlLCBkZXAsIGVhZ2VyKSB7XG4gICAgICAgICAgaWYgKGVhZ2VyID09PSB2b2lkIDApIHsgZWFnZXIgPSBudWxsOyB9XG4gICAgICAgICAgaWYgKGRlcC5pc0F0dHJpYnV0ZSkge1xuICAgICAgICAgICAgICB2YXIgYXR0clZhbHVlID0gdGhpcy5fYXR0cnNbZGVwLnRva2VuLnZhbHVlXTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21waWxlRGlEZXBlbmRlbmN5TWV0YWRhdGEoeyBpc1ZhbHVlOiB0cnVlLCB2YWx1ZTogbm9ybWFsaXplQmxhbmsoYXR0clZhbHVlKSB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzUHJlc2VudChkZXAucXVlcnkpIHx8IGlzUHJlc2VudChkZXAudmlld1F1ZXJ5KSkge1xuICAgICAgICAgICAgICByZXR1cm4gZGVwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNQcmVzZW50KGRlcC50b2tlbikpIHtcbiAgICAgICAgICAgICAgLy8gYWNjZXNzIGJ1aWx0aW50c1xuICAgICAgICAgICAgICBpZiAoKHJlcXVlc3RpbmdQcm92aWRlclR5cGUgPT09IGV4cG9ydHMuUHJvdmlkZXJBc3RUeXBlLkRpcmVjdGl2ZSB8fFxuICAgICAgICAgICAgICAgICAgcmVxdWVzdGluZ1Byb3ZpZGVyVHlwZSA9PT0gZXhwb3J0cy5Qcm92aWRlckFzdFR5cGUuQ29tcG9uZW50KSkge1xuICAgICAgICAgICAgICAgICAgaWYgKGRlcC50b2tlbi5yZWZlcmVuY2UgPT09IHJlc29sdmVJZGVudGlmaWVyVG9rZW4oSWRlbnRpZmllcnMuUmVuZGVyZXIpLnJlZmVyZW5jZSB8fFxuICAgICAgICAgICAgICAgICAgICAgIGRlcC50b2tlbi5yZWZlcmVuY2UgPT09IHJlc29sdmVJZGVudGlmaWVyVG9rZW4oSWRlbnRpZmllcnMuRWxlbWVudFJlZikucmVmZXJlbmNlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgZGVwLnRva2VuLnJlZmVyZW5jZSA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZUlkZW50aWZpZXJUb2tlbihJZGVudGlmaWVycy5DaGFuZ2VEZXRlY3RvclJlZikucmVmZXJlbmNlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgZGVwLnRva2VuLnJlZmVyZW5jZSA9PT0gcmVzb2x2ZUlkZW50aWZpZXJUb2tlbihJZGVudGlmaWVycy5UZW1wbGF0ZVJlZikucmVmZXJlbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlcDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChkZXAudG9rZW4ucmVmZXJlbmNlID09PVxuICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVJZGVudGlmaWVyVG9rZW4oSWRlbnRpZmllcnMuVmlld0NvbnRhaW5lclJlZikucmVmZXJlbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFzVmlld0NvbnRhaW5lciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gYWNjZXNzIHRoZSBpbmplY3RvclxuICAgICAgICAgICAgICBpZiAoZGVwLnRva2VuLnJlZmVyZW5jZSA9PT0gcmVzb2x2ZUlkZW50aWZpZXJUb2tlbihJZGVudGlmaWVycy5JbmplY3RvcikucmVmZXJlbmNlKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZGVwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIGFjY2VzcyBwcm92aWRlcnNcbiAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLl9nZXRPckNyZWF0ZUxvY2FsUHJvdmlkZXIocmVxdWVzdGluZ1Byb3ZpZGVyVHlwZSwgZGVwLnRva2VuLCBlYWdlcikpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZGVwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIFByb3ZpZGVyRWxlbWVudENvbnRleHQucHJvdG90eXBlLl9nZXREZXBlbmRlbmN5ID0gZnVuY3Rpb24gKHJlcXVlc3RpbmdQcm92aWRlclR5cGUsIGRlcCwgZWFnZXIpIHtcbiAgICAgICAgICBpZiAoZWFnZXIgPT09IHZvaWQgMCkgeyBlYWdlciA9IG51bGw7IH1cbiAgICAgICAgICB2YXIgY3VyckVsZW1lbnQgPSB0aGlzO1xuICAgICAgICAgIHZhciBjdXJyRWFnZXIgPSBlYWdlcjtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICBpZiAoIWRlcC5pc1NraXBTZWxmKSB7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuX2dldExvY2FsRGVwZW5kZW5jeShyZXF1ZXN0aW5nUHJvdmlkZXJUeXBlLCBkZXAsIGVhZ2VyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRlcC5pc1NlbGYpIHtcbiAgICAgICAgICAgICAgaWYgKCFyZXN1bHQgJiYgZGVwLmlzT3B0aW9uYWwpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBDb21waWxlRGlEZXBlbmRlbmN5TWV0YWRhdGEoeyBpc1ZhbHVlOiB0cnVlLCB2YWx1ZTogbnVsbCB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gY2hlY2sgcGFyZW50IGVsZW1lbnRzXG4gICAgICAgICAgICAgIHdoaWxlICghcmVzdWx0ICYmIGlzUHJlc2VudChjdXJyRWxlbWVudC5fcGFyZW50KSkge1xuICAgICAgICAgICAgICAgICAgdmFyIHByZXZFbGVtZW50ID0gY3VyckVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICBjdXJyRWxlbWVudCA9IGN1cnJFbGVtZW50Ll9wYXJlbnQ7XG4gICAgICAgICAgICAgICAgICBpZiAocHJldkVsZW1lbnQuX2lzVmlld1Jvb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjdXJyRWFnZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGN1cnJFbGVtZW50Ll9nZXRMb2NhbERlcGVuZGVuY3koZXhwb3J0cy5Qcm92aWRlckFzdFR5cGUuUHVibGljU2VydmljZSwgZGVwLCBjdXJyRWFnZXIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIGNoZWNrIEBIb3N0IHJlc3RyaWN0aW9uXG4gICAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIWRlcC5pc0hvc3QgfHwgdGhpcy52aWV3Q29udGV4dC5jb21wb25lbnQudHlwZS5pc0hvc3QgfHxcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdDb250ZXh0LmNvbXBvbmVudC50eXBlLnJlZmVyZW5jZSA9PT0gZGVwLnRva2VuLnJlZmVyZW5jZSB8fFxuICAgICAgICAgICAgICAgICAgICAgIGlzUHJlc2VudCh0aGlzLnZpZXdDb250ZXh0LnZpZXdQcm92aWRlcnMuZ2V0KGRlcC50b2tlbi5yZWZlcmVuY2UpKSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGRlcDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGRlcC5pc09wdGlvbmFsID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IENvbXBpbGVEaURlcGVuZGVuY3lNZXRhZGF0YSh7IGlzVmFsdWU6IHRydWUsIHZhbHVlOiBudWxsIH0pIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICB0aGlzLnZpZXdDb250ZXh0LmVycm9ycy5wdXNoKG5ldyBQcm92aWRlckVycm9yKFwiTm8gcHJvdmlkZXIgZm9yIFwiICsgZGVwLnRva2VuLm5hbWUsIHRoaXMuX3NvdXJjZVNwYW4pKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgICByZXR1cm4gUHJvdmlkZXJFbGVtZW50Q29udGV4dDtcbiAgfSgpKTtcbiAgdmFyIE5nTW9kdWxlUHJvdmlkZXJBbmFseXplciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBOZ01vZHVsZVByb3ZpZGVyQW5hbHl6ZXIobmdNb2R1bGUsIGV4dHJhUHJvdmlkZXJzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB0aGlzLl90cmFuc2Zvcm1lZFByb3ZpZGVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICB0aGlzLl9zZWVuUHJvdmlkZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICAgIHRoaXMuX2Vycm9ycyA9IFtdO1xuICAgICAgICAgIHRoaXMuX2FsbFByb3ZpZGVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICB2YXIgbmdNb2R1bGVUeXBlcyA9IG5nTW9kdWxlLnRyYW5zaXRpdmVNb2R1bGUubW9kdWxlcy5tYXAoZnVuY3Rpb24gKG1vZHVsZU1ldGEpIHsgcmV0dXJuIG1vZHVsZU1ldGEudHlwZTsgfSk7XG4gICAgICAgICAgbmdNb2R1bGVUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uIChuZ01vZHVsZVR5cGUpIHtcbiAgICAgICAgICAgICAgdmFyIG5nTW9kdWxlUHJvdmlkZXIgPSBuZXcgQ29tcGlsZVByb3ZpZGVyTWV0YWRhdGEoeyB0b2tlbjogbmV3IENvbXBpbGVUb2tlbk1ldGFkYXRhKHsgaWRlbnRpZmllcjogbmdNb2R1bGVUeXBlIH0pLCB1c2VDbGFzczogbmdNb2R1bGVUeXBlIH0pO1xuICAgICAgICAgICAgICBfcmVzb2x2ZVByb3ZpZGVycyhbbmdNb2R1bGVQcm92aWRlcl0sIGV4cG9ydHMuUHJvdmlkZXJBc3RUeXBlLlB1YmxpY1NlcnZpY2UsIHRydWUsIHNvdXJjZVNwYW4sIF90aGlzLl9lcnJvcnMsIF90aGlzLl9hbGxQcm92aWRlcnMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIF9yZXNvbHZlUHJvdmlkZXJzKF9ub3JtYWxpemVQcm92aWRlcnMobmdNb2R1bGUudHJhbnNpdGl2ZU1vZHVsZS5wcm92aWRlcnMuY29uY2F0KGV4dHJhUHJvdmlkZXJzKSwgc291cmNlU3BhbiwgdGhpcy5fZXJyb3JzKSwgZXhwb3J0cy5Qcm92aWRlckFzdFR5cGUuUHVibGljU2VydmljZSwgZmFsc2UsIHNvdXJjZVNwYW4sIHRoaXMuX2Vycm9ycywgdGhpcy5fYWxsUHJvdmlkZXJzKTtcbiAgICAgIH1cbiAgICAgIE5nTW9kdWxlUHJvdmlkZXJBbmFseXplci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICBNYXBXcmFwcGVyLnZhbHVlcyh0aGlzLl9hbGxQcm92aWRlcnMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ZpZGVyKSB7XG4gICAgICAgICAgICAgIF90aGlzLl9nZXRPckNyZWF0ZUxvY2FsUHJvdmlkZXIocHJvdmlkZXIudG9rZW4sIHByb3ZpZGVyLmVhZ2VyKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAodGhpcy5fZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgdmFyIGVycm9yU3RyaW5nID0gdGhpcy5fZXJyb3JzLmpvaW4oJ1xcbicpO1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcm92aWRlciBwYXJzZSBlcnJvcnM6XFxuXCIgKyBlcnJvclN0cmluZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBNYXBXcmFwcGVyLnZhbHVlcyh0aGlzLl90cmFuc2Zvcm1lZFByb3ZpZGVycyk7XG4gICAgICB9O1xuICAgICAgTmdNb2R1bGVQcm92aWRlckFuYWx5emVyLnByb3RvdHlwZS5fZ2V0T3JDcmVhdGVMb2NhbFByb3ZpZGVyID0gZnVuY3Rpb24gKHRva2VuLCBlYWdlcikge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIHJlc29sdmVkUHJvdmlkZXIgPSB0aGlzLl9hbGxQcm92aWRlcnMuZ2V0KHRva2VuLnJlZmVyZW5jZSk7XG4gICAgICAgICAgaWYgKCFyZXNvbHZlZFByb3ZpZGVyKSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdHJhbnNmb3JtZWRQcm92aWRlckFzdCA9IHRoaXMuX3RyYW5zZm9ybWVkUHJvdmlkZXJzLmdldCh0b2tlbi5yZWZlcmVuY2UpO1xuICAgICAgICAgIGlmIChpc1ByZXNlbnQodHJhbnNmb3JtZWRQcm92aWRlckFzdCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVkUHJvdmlkZXJBc3Q7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5fc2VlblByb3ZpZGVycy5nZXQodG9rZW4ucmVmZXJlbmNlKSkpIHtcbiAgICAgICAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2gobmV3IFByb3ZpZGVyRXJyb3IoXCJDYW5ub3QgaW5zdGFudGlhdGUgY3ljbGljIGRlcGVuZGVuY3khIFwiICsgdG9rZW4ubmFtZSwgcmVzb2x2ZWRQcm92aWRlci5zb3VyY2VTcGFuKSk7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9zZWVuUHJvdmlkZXJzLnNldCh0b2tlbi5yZWZlcmVuY2UsIHRydWUpO1xuICAgICAgICAgIHZhciB0cmFuc2Zvcm1lZFByb3ZpZGVycyA9IHJlc29sdmVkUHJvdmlkZXIucHJvdmlkZXJzLm1hcChmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWVkVXNlVmFsdWUgPSBwcm92aWRlci51c2VWYWx1ZTtcbiAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWVkVXNlRXhpc3RpbmcgPSBwcm92aWRlci51c2VFeGlzdGluZztcbiAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWVkRGVwcztcbiAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudChwcm92aWRlci51c2VFeGlzdGluZykpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBleGlzdGluZ0RpRGVwID0gX3RoaXMuX2dldERlcGVuZGVuY3kobmV3IENvbXBpbGVEaURlcGVuZGVuY3lNZXRhZGF0YSh7IHRva2VuOiBwcm92aWRlci51c2VFeGlzdGluZyB9KSwgZWFnZXIsIHJlc29sdmVkUHJvdmlkZXIuc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KGV4aXN0aW5nRGlEZXAudG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtZWRVc2VFeGlzdGluZyA9IGV4aXN0aW5nRGlEZXAudG9rZW47XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZFVzZUV4aXN0aW5nID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZFVzZVZhbHVlID0gZXhpc3RpbmdEaURlcC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmIChpc1ByZXNlbnQocHJvdmlkZXIudXNlRmFjdG9yeSkpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBkZXBzID0gcHJvdmlkZXIuZGVwcyB8fCBwcm92aWRlci51c2VGYWN0b3J5LmRpRGVwcztcbiAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkRGVwcyA9XG4gICAgICAgICAgICAgICAgICAgICAgZGVwcy5tYXAoZnVuY3Rpb24gKGRlcCkgeyByZXR1cm4gX3RoaXMuX2dldERlcGVuZGVuY3koZGVwLCBlYWdlciwgcmVzb2x2ZWRQcm92aWRlci5zb3VyY2VTcGFuKTsgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAoaXNQcmVzZW50KHByb3ZpZGVyLnVzZUNsYXNzKSkge1xuICAgICAgICAgICAgICAgICAgdmFyIGRlcHMgPSBwcm92aWRlci5kZXBzIHx8IHByb3ZpZGVyLnVzZUNsYXNzLmRpRGVwcztcbiAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkRGVwcyA9XG4gICAgICAgICAgICAgICAgICAgICAgZGVwcy5tYXAoZnVuY3Rpb24gKGRlcCkgeyByZXR1cm4gX3RoaXMuX2dldERlcGVuZGVuY3koZGVwLCBlYWdlciwgcmVzb2x2ZWRQcm92aWRlci5zb3VyY2VTcGFuKTsgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIF90cmFuc2Zvcm1Qcm92aWRlcihwcm92aWRlciwge1xuICAgICAgICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IHRyYW5zZm9ybWVkVXNlRXhpc3RpbmcsXG4gICAgICAgICAgICAgICAgICB1c2VWYWx1ZTogdHJhbnNmb3JtZWRVc2VWYWx1ZSxcbiAgICAgICAgICAgICAgICAgIGRlcHM6IHRyYW5zZm9ybWVkRGVwc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0cmFuc2Zvcm1lZFByb3ZpZGVyQXN0ID1cbiAgICAgICAgICAgICAgX3RyYW5zZm9ybVByb3ZpZGVyQXN0KHJlc29sdmVkUHJvdmlkZXIsIHsgZWFnZXI6IGVhZ2VyLCBwcm92aWRlcnM6IHRyYW5zZm9ybWVkUHJvdmlkZXJzIH0pO1xuICAgICAgICAgIHRoaXMuX3RyYW5zZm9ybWVkUHJvdmlkZXJzLnNldCh0b2tlbi5yZWZlcmVuY2UsIHRyYW5zZm9ybWVkUHJvdmlkZXJBc3QpO1xuICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm1lZFByb3ZpZGVyQXN0O1xuICAgICAgfTtcbiAgICAgIE5nTW9kdWxlUHJvdmlkZXJBbmFseXplci5wcm90b3R5cGUuX2dldERlcGVuZGVuY3kgPSBmdW5jdGlvbiAoZGVwLCBlYWdlciwgcmVxdWVzdG9yU291cmNlU3Bhbikge1xuICAgICAgICAgIGlmIChlYWdlciA9PT0gdm9pZCAwKSB7IGVhZ2VyID0gbnVsbDsgfVxuICAgICAgICAgIHZhciBmb3VuZExvY2FsID0gZmFsc2U7XG4gICAgICAgICAgaWYgKCFkZXAuaXNTa2lwU2VsZiAmJiBpc1ByZXNlbnQoZGVwLnRva2VuKSkge1xuICAgICAgICAgICAgICAvLyBhY2Nlc3MgdGhlIGluamVjdG9yXG4gICAgICAgICAgICAgIGlmIChkZXAudG9rZW4ucmVmZXJlbmNlID09PSByZXNvbHZlSWRlbnRpZmllclRva2VuKElkZW50aWZpZXJzLkluamVjdG9yKS5yZWZlcmVuY2UgfHxcbiAgICAgICAgICAgICAgICAgIGRlcC50b2tlbi5yZWZlcmVuY2UgPT09XG4gICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZUlkZW50aWZpZXJUb2tlbihJZGVudGlmaWVycy5Db21wb25lbnRGYWN0b3J5UmVzb2x2ZXIpLnJlZmVyZW5jZSkge1xuICAgICAgICAgICAgICAgICAgZm91bmRMb2NhbCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAoaXNQcmVzZW50KHRoaXMuX2dldE9yQ3JlYXRlTG9jYWxQcm92aWRlcihkZXAudG9rZW4sIGVhZ2VyKSkpIHtcbiAgICAgICAgICAgICAgICAgIGZvdW5kTG9jYWwgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByZXN1bHQgPSBkZXA7XG4gICAgICAgICAgaWYgKGRlcC5pc1NlbGYgJiYgIWZvdW5kTG9jYWwpIHtcbiAgICAgICAgICAgICAgaWYgKGRlcC5pc09wdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgQ29tcGlsZURpRGVwZW5kZW5jeU1ldGFkYXRhKHsgaXNWYWx1ZTogdHJ1ZSwgdmFsdWU6IG51bGwgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9lcnJvcnMucHVzaChuZXcgUHJvdmlkZXJFcnJvcihcIk5vIHByb3ZpZGVyIGZvciBcIiArIGRlcC50b2tlbi5uYW1lLCByZXF1ZXN0b3JTb3VyY2VTcGFuKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgICByZXR1cm4gTmdNb2R1bGVQcm92aWRlckFuYWx5emVyO1xuICB9KCkpO1xuICBmdW5jdGlvbiBfdHJhbnNmb3JtUHJvdmlkZXIocHJvdmlkZXIsIF9hKSB7XG4gICAgICB2YXIgdXNlRXhpc3RpbmcgPSBfYS51c2VFeGlzdGluZywgdXNlVmFsdWUgPSBfYS51c2VWYWx1ZSwgZGVwcyA9IF9hLmRlcHM7XG4gICAgICByZXR1cm4gbmV3IENvbXBpbGVQcm92aWRlck1ldGFkYXRhKHtcbiAgICAgICAgICB0b2tlbjogcHJvdmlkZXIudG9rZW4sXG4gICAgICAgICAgdXNlQ2xhc3M6IHByb3ZpZGVyLnVzZUNsYXNzLFxuICAgICAgICAgIHVzZUV4aXN0aW5nOiB1c2VFeGlzdGluZyxcbiAgICAgICAgICB1c2VGYWN0b3J5OiBwcm92aWRlci51c2VGYWN0b3J5LFxuICAgICAgICAgIHVzZVZhbHVlOiB1c2VWYWx1ZSxcbiAgICAgICAgICBkZXBzOiBkZXBzLFxuICAgICAgICAgIG11bHRpOiBwcm92aWRlci5tdWx0aVxuICAgICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gX3RyYW5zZm9ybVByb3ZpZGVyQXN0KHByb3ZpZGVyLCBfYSkge1xuICAgICAgdmFyIGVhZ2VyID0gX2EuZWFnZXIsIHByb3ZpZGVycyA9IF9hLnByb3ZpZGVycztcbiAgICAgIHJldHVybiBuZXcgUHJvdmlkZXJBc3QocHJvdmlkZXIudG9rZW4sIHByb3ZpZGVyLm11bHRpUHJvdmlkZXIsIHByb3ZpZGVyLmVhZ2VyIHx8IGVhZ2VyLCBwcm92aWRlcnMsIHByb3ZpZGVyLnByb3ZpZGVyVHlwZSwgcHJvdmlkZXIubGlmZWN5Y2xlSG9va3MsIHByb3ZpZGVyLnNvdXJjZVNwYW4pO1xuICB9XG4gIGZ1bmN0aW9uIF9ub3JtYWxpemVQcm92aWRlcnMocHJvdmlkZXJzLCBzb3VyY2VTcGFuLCB0YXJnZXRFcnJvcnMsIHRhcmdldFByb3ZpZGVycykge1xuICAgICAgaWYgKHRhcmdldFByb3ZpZGVycyA9PT0gdm9pZCAwKSB7IHRhcmdldFByb3ZpZGVycyA9IG51bGw7IH1cbiAgICAgIGlmICghdGFyZ2V0UHJvdmlkZXJzKSB7XG4gICAgICAgICAgdGFyZ2V0UHJvdmlkZXJzID0gW107XG4gICAgICB9XG4gICAgICBpZiAoaXNQcmVzZW50KHByb3ZpZGVycykpIHtcbiAgICAgICAgICBwcm92aWRlcnMuZm9yRWFjaChmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvdmlkZXIpKSB7XG4gICAgICAgICAgICAgICAgICBfbm9ybWFsaXplUHJvdmlkZXJzKHByb3ZpZGVyLCBzb3VyY2VTcGFuLCB0YXJnZXRFcnJvcnMsIHRhcmdldFByb3ZpZGVycyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICB2YXIgbm9ybWFsaXplUHJvdmlkZXIgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICBpZiAocHJvdmlkZXIgaW5zdGFuY2VvZiBDb21waWxlUHJvdmlkZXJNZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZVByb3ZpZGVyID0gcHJvdmlkZXI7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIGlmIChwcm92aWRlciBpbnN0YW5jZW9mIENvbXBpbGVUeXBlTWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVQcm92aWRlciA9IG5ldyBDb21waWxlUHJvdmlkZXJNZXRhZGF0YSh7IHRva2VuOiBuZXcgQ29tcGlsZVRva2VuTWV0YWRhdGEoeyBpZGVudGlmaWVyOiBwcm92aWRlciB9KSwgdXNlQ2xhc3M6IHByb3ZpZGVyIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RXJyb3JzLnB1c2gobmV3IFByb3ZpZGVyRXJyb3IoXCJVbmtub3duIHByb3ZpZGVyIHR5cGUgXCIgKyBwcm92aWRlciwgc291cmNlU3BhbikpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudChub3JtYWxpemVQcm92aWRlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRQcm92aWRlcnMucHVzaChub3JtYWxpemVQcm92aWRlcik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXRQcm92aWRlcnM7XG4gIH1cbiAgZnVuY3Rpb24gX3Jlc29sdmVQcm92aWRlcnNGcm9tRGlyZWN0aXZlcyhkaXJlY3RpdmVzLCBzb3VyY2VTcGFuLCB0YXJnZXRFcnJvcnMpIHtcbiAgICAgIHZhciBwcm92aWRlcnNCeVRva2VuID0gbmV3IE1hcCgpO1xuICAgICAgZGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChkaXJlY3RpdmUpIHtcbiAgICAgICAgICB2YXIgZGlyUHJvdmlkZXIgPSBuZXcgQ29tcGlsZVByb3ZpZGVyTWV0YWRhdGEoeyB0b2tlbjogbmV3IENvbXBpbGVUb2tlbk1ldGFkYXRhKHsgaWRlbnRpZmllcjogZGlyZWN0aXZlLnR5cGUgfSksIHVzZUNsYXNzOiBkaXJlY3RpdmUudHlwZSB9KTtcbiAgICAgICAgICBfcmVzb2x2ZVByb3ZpZGVycyhbZGlyUHJvdmlkZXJdLCBkaXJlY3RpdmUuaXNDb21wb25lbnQgPyBleHBvcnRzLlByb3ZpZGVyQXN0VHlwZS5Db21wb25lbnQgOiBleHBvcnRzLlByb3ZpZGVyQXN0VHlwZS5EaXJlY3RpdmUsIHRydWUsIHNvdXJjZVNwYW4sIHRhcmdldEVycm9ycywgcHJvdmlkZXJzQnlUb2tlbik7XG4gICAgICB9KTtcbiAgICAgIC8vIE5vdGU6IGRpcmVjdGl2ZXMgbmVlZCB0byBiZSBhYmxlIHRvIG92ZXJ3cml0ZSBwcm92aWRlcnMgb2YgYSBjb21wb25lbnQhXG4gICAgICB2YXIgZGlyZWN0aXZlc1dpdGhDb21wb25lbnRGaXJzdCA9IGRpcmVjdGl2ZXMuZmlsdGVyKGZ1bmN0aW9uIChkaXIpIHsgcmV0dXJuIGRpci5pc0NvbXBvbmVudDsgfSkuY29uY2F0KGRpcmVjdGl2ZXMuZmlsdGVyKGZ1bmN0aW9uIChkaXIpIHsgcmV0dXJuICFkaXIuaXNDb21wb25lbnQ7IH0pKTtcbiAgICAgIGRpcmVjdGl2ZXNXaXRoQ29tcG9uZW50Rmlyc3QuZm9yRWFjaChmdW5jdGlvbiAoZGlyZWN0aXZlKSB7XG4gICAgICAgICAgX3Jlc29sdmVQcm92aWRlcnMoX25vcm1hbGl6ZVByb3ZpZGVycyhkaXJlY3RpdmUucHJvdmlkZXJzLCBzb3VyY2VTcGFuLCB0YXJnZXRFcnJvcnMpLCBleHBvcnRzLlByb3ZpZGVyQXN0VHlwZS5QdWJsaWNTZXJ2aWNlLCBmYWxzZSwgc291cmNlU3BhbiwgdGFyZ2V0RXJyb3JzLCBwcm92aWRlcnNCeVRva2VuKTtcbiAgICAgICAgICBfcmVzb2x2ZVByb3ZpZGVycyhfbm9ybWFsaXplUHJvdmlkZXJzKGRpcmVjdGl2ZS52aWV3UHJvdmlkZXJzLCBzb3VyY2VTcGFuLCB0YXJnZXRFcnJvcnMpLCBleHBvcnRzLlByb3ZpZGVyQXN0VHlwZS5Qcml2YXRlU2VydmljZSwgZmFsc2UsIHNvdXJjZVNwYW4sIHRhcmdldEVycm9ycywgcHJvdmlkZXJzQnlUb2tlbik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwcm92aWRlcnNCeVRva2VuO1xuICB9XG4gIGZ1bmN0aW9uIF9yZXNvbHZlUHJvdmlkZXJzKHByb3ZpZGVycywgcHJvdmlkZXJUeXBlLCBlYWdlciwgc291cmNlU3BhbiwgdGFyZ2V0RXJyb3JzLCB0YXJnZXRQcm92aWRlcnNCeVRva2VuKSB7XG4gICAgICBwcm92aWRlcnMuZm9yRWFjaChmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgICAgICB2YXIgcmVzb2x2ZWRQcm92aWRlciA9IHRhcmdldFByb3ZpZGVyc0J5VG9rZW4uZ2V0KHByb3ZpZGVyLnRva2VuLnJlZmVyZW5jZSk7XG4gICAgICAgICAgaWYgKGlzUHJlc2VudChyZXNvbHZlZFByb3ZpZGVyKSAmJiByZXNvbHZlZFByb3ZpZGVyLm11bHRpUHJvdmlkZXIgIT09IHByb3ZpZGVyLm11bHRpKSB7XG4gICAgICAgICAgICAgIHRhcmdldEVycm9ycy5wdXNoKG5ldyBQcm92aWRlckVycm9yKFwiTWl4aW5nIG11bHRpIGFuZCBub24gbXVsdGkgcHJvdmlkZXIgaXMgbm90IHBvc3NpYmxlIGZvciB0b2tlbiBcIiArIHJlc29sdmVkUHJvdmlkZXIudG9rZW4ubmFtZSwgc291cmNlU3BhbikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXJlc29sdmVkUHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgdmFyIGxpZmVjeWNsZUhvb2tzID0gcHJvdmlkZXIudG9rZW4uaWRlbnRpZmllciAmJiBwcm92aWRlci50b2tlbi5pZGVudGlmaWVyIGluc3RhbmNlb2YgQ29tcGlsZVR5cGVNZXRhZGF0YSA/XG4gICAgICAgICAgICAgICAgICBwcm92aWRlci50b2tlbi5pZGVudGlmaWVyLmxpZmVjeWNsZUhvb2tzIDpcbiAgICAgICAgICAgICAgICAgIFtdO1xuICAgICAgICAgICAgICByZXNvbHZlZFByb3ZpZGVyID0gbmV3IFByb3ZpZGVyQXN0KHByb3ZpZGVyLnRva2VuLCBwcm92aWRlci5tdWx0aSwgZWFnZXIgfHwgbGlmZWN5Y2xlSG9va3MubGVuZ3RoID4gMCwgW3Byb3ZpZGVyXSwgcHJvdmlkZXJUeXBlLCBsaWZlY3ljbGVIb29rcywgc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgIHRhcmdldFByb3ZpZGVyc0J5VG9rZW4uc2V0KHByb3ZpZGVyLnRva2VuLnJlZmVyZW5jZSwgcmVzb2x2ZWRQcm92aWRlcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoIXByb3ZpZGVyLm11bHRpKSB7XG4gICAgICAgICAgICAgICAgICBMaXN0V3JhcHBlci5jbGVhcihyZXNvbHZlZFByb3ZpZGVyLnByb3ZpZGVycyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzb2x2ZWRQcm92aWRlci5wcm92aWRlcnMucHVzaChwcm92aWRlcik7XG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gX2dldFZpZXdRdWVyaWVzKGNvbXBvbmVudCkge1xuICAgICAgdmFyIHZpZXdRdWVyaWVzID0gbmV3IE1hcCgpO1xuICAgICAgaWYgKGlzUHJlc2VudChjb21wb25lbnQudmlld1F1ZXJpZXMpKSB7XG4gICAgICAgICAgY29tcG9uZW50LnZpZXdRdWVyaWVzLmZvckVhY2goZnVuY3Rpb24gKHF1ZXJ5KSB7IHJldHVybiBfYWRkUXVlcnlUb1Rva2VuTWFwKHZpZXdRdWVyaWVzLCBxdWVyeSk7IH0pO1xuICAgICAgfVxuICAgICAgY29tcG9uZW50LnR5cGUuZGlEZXBzLmZvckVhY2goZnVuY3Rpb24gKGRlcCkge1xuICAgICAgICAgIGlmIChpc1ByZXNlbnQoZGVwLnZpZXdRdWVyeSkpIHtcbiAgICAgICAgICAgICAgX2FkZFF1ZXJ5VG9Ub2tlbk1hcCh2aWV3UXVlcmllcywgZGVwLnZpZXdRdWVyeSk7XG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdmlld1F1ZXJpZXM7XG4gIH1cbiAgZnVuY3Rpb24gX2dldENvbnRlbnRRdWVyaWVzKGRpcmVjdGl2ZXMpIHtcbiAgICAgIHZhciBjb250ZW50UXVlcmllcyA9IG5ldyBNYXAoKTtcbiAgICAgIGRpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlyZWN0aXZlKSB7XG4gICAgICAgICAgaWYgKGlzUHJlc2VudChkaXJlY3RpdmUucXVlcmllcykpIHtcbiAgICAgICAgICAgICAgZGlyZWN0aXZlLnF1ZXJpZXMuZm9yRWFjaChmdW5jdGlvbiAocXVlcnkpIHsgcmV0dXJuIF9hZGRRdWVyeVRvVG9rZW5NYXAoY29udGVudFF1ZXJpZXMsIHF1ZXJ5KTsgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRpcmVjdGl2ZS50eXBlLmRpRGVwcy5mb3JFYWNoKGZ1bmN0aW9uIChkZXApIHtcbiAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudChkZXAucXVlcnkpKSB7XG4gICAgICAgICAgICAgICAgICBfYWRkUXVlcnlUb1Rva2VuTWFwKGNvbnRlbnRRdWVyaWVzLCBkZXAucXVlcnkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjb250ZW50UXVlcmllcztcbiAgfVxuICBmdW5jdGlvbiBfYWRkUXVlcnlUb1Rva2VuTWFwKG1hcCwgcXVlcnkpIHtcbiAgICAgIHF1ZXJ5LnNlbGVjdG9ycy5mb3JFYWNoKGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICAgIHZhciBlbnRyeSA9IG1hcC5nZXQodG9rZW4ucmVmZXJlbmNlKTtcbiAgICAgICAgICBpZiAoIWVudHJ5KSB7XG4gICAgICAgICAgICAgIGVudHJ5ID0gW107XG4gICAgICAgICAgICAgIG1hcC5zZXQodG9rZW4ucmVmZXJlbmNlLCBlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVudHJ5LnB1c2gocXVlcnkpO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQGxpY2Vuc2VcbiAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAqXG4gICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICovXG4gIHZhciBFbGVtZW50U2NoZW1hUmVnaXN0cnkgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gRWxlbWVudFNjaGVtYVJlZ2lzdHJ5KCkge1xuICAgICAgfVxuICAgICAgcmV0dXJuIEVsZW1lbnRTY2hlbWFSZWdpc3RyeTtcbiAgfSgpKTtcblxuICB2YXIgU3R5bGVXaXRoSW1wb3J0cyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBTdHlsZVdpdGhJbXBvcnRzKHN0eWxlLCBzdHlsZVVybHMpIHtcbiAgICAgICAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gICAgICAgICAgdGhpcy5zdHlsZVVybHMgPSBzdHlsZVVybHM7XG4gICAgICB9XG4gICAgICByZXR1cm4gU3R5bGVXaXRoSW1wb3J0cztcbiAgfSgpKTtcbiAgZnVuY3Rpb24gaXNTdHlsZVVybFJlc29sdmFibGUodXJsKSB7XG4gICAgICBpZiAoaXNCbGFuayh1cmwpIHx8IHVybC5sZW5ndGggPT09IDAgfHwgdXJsWzBdID09ICcvJylcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB2YXIgc2NoZW1lTWF0Y2ggPSB1cmwubWF0Y2goX3VybFdpdGhTY2hlbWFSZSk7XG4gICAgICByZXR1cm4gc2NoZW1lTWF0Y2ggPT09IG51bGwgfHwgc2NoZW1lTWF0Y2hbMV0gPT0gJ3BhY2thZ2UnIHx8IHNjaGVtZU1hdGNoWzFdID09ICdhc3NldCc7XG4gIH1cbiAgLyoqXG4gICAqIFJld3JpdGVzIHN0eWxlc2hlZXRzIGJ5IHJlc29sdmluZyBhbmQgcmVtb3ZpbmcgdGhlIEBpbXBvcnQgdXJscyB0aGF0XG4gICAqIGFyZSBlaXRoZXIgcmVsYXRpdmUgb3IgZG9uJ3QgaGF2ZSBhIGBwYWNrYWdlOmAgc2NoZW1lXG4gICAqL1xuICBmdW5jdGlvbiBleHRyYWN0U3R5bGVVcmxzKHJlc29sdmVyLCBiYXNlVXJsLCBjc3NUZXh0KSB7XG4gICAgICB2YXIgZm91bmRVcmxzID0gW107XG4gICAgICB2YXIgbW9kaWZpZWRDc3NUZXh0ID0gY3NzVGV4dC5yZXBsYWNlKF9jc3NJbXBvcnRSZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBtID0gW107XG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgbVtfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHVybCA9IG1bMV0gfHwgbVsyXTtcbiAgICAgICAgICBpZiAoIWlzU3R5bGVVcmxSZXNvbHZhYmxlKHVybCkpIHtcbiAgICAgICAgICAgICAgLy8gRG8gbm90IGF0dGVtcHQgdG8gcmVzb2x2ZSBub24tcGFja2FnZSBhYnNvbHV0ZSBVUkxzIHdpdGggVVJJIHNjaGVtZVxuICAgICAgICAgICAgICByZXR1cm4gbVswXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm91bmRVcmxzLnB1c2gocmVzb2x2ZXIucmVzb2x2ZShiYXNlVXJsLCB1cmwpKTtcbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuZXcgU3R5bGVXaXRoSW1wb3J0cyhtb2RpZmllZENzc1RleHQsIGZvdW5kVXJscyk7XG4gIH1cbiAgdmFyIF9jc3NJbXBvcnRSZSA9IC9AaW1wb3J0XFxzKyg/OnVybFxcKCk/XFxzKig/Oig/OlsnXCJdKFteJ1wiXSopKXwoW147XFwpXFxzXSopKVteO10qOz8vZztcbiAgdmFyIF91cmxXaXRoU2NoZW1hUmUgPSAvXihbXjovPyNdKyk6LztcblxuICB2YXIgTkdfQ09OVEVOVF9TRUxFQ1RfQVRUUiA9ICdzZWxlY3QnO1xuICB2YXIgTkdfQ09OVEVOVF9FTEVNRU5UID0gJ25nLWNvbnRlbnQnO1xuICB2YXIgTElOS19FTEVNRU5UID0gJ2xpbmsnO1xuICB2YXIgTElOS19TVFlMRV9SRUxfQVRUUiA9ICdyZWwnO1xuICB2YXIgTElOS19TVFlMRV9IUkVGX0FUVFIgPSAnaHJlZic7XG4gIHZhciBMSU5LX1NUWUxFX1JFTF9WQUxVRSA9ICdzdHlsZXNoZWV0JztcbiAgdmFyIFNUWUxFX0VMRU1FTlQgPSAnc3R5bGUnO1xuICB2YXIgU0NSSVBUX0VMRU1FTlQgPSAnc2NyaXB0JztcbiAgdmFyIE5HX05PTl9CSU5EQUJMRV9BVFRSID0gJ25nTm9uQmluZGFibGUnO1xuICB2YXIgTkdfUFJPSkVDVF9BUyA9ICduZ1Byb2plY3RBcyc7XG4gIGZ1bmN0aW9uIHByZXBhcnNlRWxlbWVudChhc3QpIHtcbiAgICAgIHZhciBzZWxlY3RBdHRyID0gbnVsbDtcbiAgICAgIHZhciBocmVmQXR0ciA9IG51bGw7XG4gICAgICB2YXIgcmVsQXR0ciA9IG51bGw7XG4gICAgICB2YXIgbm9uQmluZGFibGUgPSBmYWxzZTtcbiAgICAgIHZhciBwcm9qZWN0QXMgPSBudWxsO1xuICAgICAgYXN0LmF0dHJzLmZvckVhY2goZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgICB2YXIgbGNBdHRyTmFtZSA9IGF0dHIubmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIGlmIChsY0F0dHJOYW1lID09IE5HX0NPTlRFTlRfU0VMRUNUX0FUVFIpIHtcbiAgICAgICAgICAgICAgc2VsZWN0QXR0ciA9IGF0dHIudmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGxjQXR0ck5hbWUgPT0gTElOS19TVFlMRV9IUkVGX0FUVFIpIHtcbiAgICAgICAgICAgICAgaHJlZkF0dHIgPSBhdHRyLnZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChsY0F0dHJOYW1lID09IExJTktfU1RZTEVfUkVMX0FUVFIpIHtcbiAgICAgICAgICAgICAgcmVsQXR0ciA9IGF0dHIudmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGF0dHIubmFtZSA9PSBOR19OT05fQklOREFCTEVfQVRUUikge1xuICAgICAgICAgICAgICBub25CaW5kYWJsZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGF0dHIubmFtZSA9PSBOR19QUk9KRUNUX0FTKSB7XG4gICAgICAgICAgICAgIGlmIChhdHRyLnZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIHByb2plY3RBcyA9IGF0dHIudmFsdWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHNlbGVjdEF0dHIgPSBub3JtYWxpemVOZ0NvbnRlbnRTZWxlY3Qoc2VsZWN0QXR0cik7XG4gICAgICB2YXIgbm9kZU5hbWUgPSBhc3QubmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIHR5cGUgPSBQcmVwYXJzZWRFbGVtZW50VHlwZS5PVEhFUjtcbiAgICAgIGlmIChzcGxpdE5zTmFtZShub2RlTmFtZSlbMV0gPT0gTkdfQ09OVEVOVF9FTEVNRU5UKSB7XG4gICAgICAgICAgdHlwZSA9IFByZXBhcnNlZEVsZW1lbnRUeXBlLk5HX0NPTlRFTlQ7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChub2RlTmFtZSA9PSBTVFlMRV9FTEVNRU5UKSB7XG4gICAgICAgICAgdHlwZSA9IFByZXBhcnNlZEVsZW1lbnRUeXBlLlNUWUxFO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAobm9kZU5hbWUgPT0gU0NSSVBUX0VMRU1FTlQpIHtcbiAgICAgICAgICB0eXBlID0gUHJlcGFyc2VkRWxlbWVudFR5cGUuU0NSSVBUO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAobm9kZU5hbWUgPT0gTElOS19FTEVNRU5UICYmIHJlbEF0dHIgPT0gTElOS19TVFlMRV9SRUxfVkFMVUUpIHtcbiAgICAgICAgICB0eXBlID0gUHJlcGFyc2VkRWxlbWVudFR5cGUuU1RZTEVTSEVFVDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgUHJlcGFyc2VkRWxlbWVudCh0eXBlLCBzZWxlY3RBdHRyLCBocmVmQXR0ciwgbm9uQmluZGFibGUsIHByb2plY3RBcyk7XG4gIH1cbiAgdmFyIFByZXBhcnNlZEVsZW1lbnRUeXBlO1xuICAoZnVuY3Rpb24gKFByZXBhcnNlZEVsZW1lbnRUeXBlKSB7XG4gICAgICBQcmVwYXJzZWRFbGVtZW50VHlwZVtQcmVwYXJzZWRFbGVtZW50VHlwZVtcIk5HX0NPTlRFTlRcIl0gPSAwXSA9IFwiTkdfQ09OVEVOVFwiO1xuICAgICAgUHJlcGFyc2VkRWxlbWVudFR5cGVbUHJlcGFyc2VkRWxlbWVudFR5cGVbXCJTVFlMRVwiXSA9IDFdID0gXCJTVFlMRVwiO1xuICAgICAgUHJlcGFyc2VkRWxlbWVudFR5cGVbUHJlcGFyc2VkRWxlbWVudFR5cGVbXCJTVFlMRVNIRUVUXCJdID0gMl0gPSBcIlNUWUxFU0hFRVRcIjtcbiAgICAgIFByZXBhcnNlZEVsZW1lbnRUeXBlW1ByZXBhcnNlZEVsZW1lbnRUeXBlW1wiU0NSSVBUXCJdID0gM10gPSBcIlNDUklQVFwiO1xuICAgICAgUHJlcGFyc2VkRWxlbWVudFR5cGVbUHJlcGFyc2VkRWxlbWVudFR5cGVbXCJPVEhFUlwiXSA9IDRdID0gXCJPVEhFUlwiO1xuICB9KShQcmVwYXJzZWRFbGVtZW50VHlwZSB8fCAoUHJlcGFyc2VkRWxlbWVudFR5cGUgPSB7fSkpO1xuICB2YXIgUHJlcGFyc2VkRWxlbWVudCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBQcmVwYXJzZWRFbGVtZW50KHR5cGUsIHNlbGVjdEF0dHIsIGhyZWZBdHRyLCBub25CaW5kYWJsZSwgcHJvamVjdEFzKSB7XG4gICAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgICB0aGlzLnNlbGVjdEF0dHIgPSBzZWxlY3RBdHRyO1xuICAgICAgICAgIHRoaXMuaHJlZkF0dHIgPSBocmVmQXR0cjtcbiAgICAgICAgICB0aGlzLm5vbkJpbmRhYmxlID0gbm9uQmluZGFibGU7XG4gICAgICAgICAgdGhpcy5wcm9qZWN0QXMgPSBwcm9qZWN0QXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gUHJlcGFyc2VkRWxlbWVudDtcbiAgfSgpKTtcbiAgZnVuY3Rpb24gbm9ybWFsaXplTmdDb250ZW50U2VsZWN0KHNlbGVjdEF0dHIpIHtcbiAgICAgIGlmIChzZWxlY3RBdHRyID09PSBudWxsIHx8IHNlbGVjdEF0dHIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuICcqJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxlY3RBdHRyO1xuICB9XG5cbiAgLyoqXG4gICAqIEBsaWNlbnNlXG4gICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgKlxuICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAqL1xuICB2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICB9O1xuICAvLyBHcm91cCAxID0gXCJiaW5kLVwiXG4gIC8vIEdyb3VwIDIgPSBcImxldC1cIlxuICAvLyBHcm91cCAzID0gXCJyZWYtLyNcIlxuICAvLyBHcm91cCA0ID0gXCJvbi1cIlxuICAvLyBHcm91cCA1ID0gXCJiaW5kb24tXCJcbiAgLy8gR3JvdXAgNiA9IFwiQFwiXG4gIC8vIEdyb3VwIDcgPSB0aGUgaWRlbnRpZmllciBhZnRlciBcImJpbmQtXCIsIFwibGV0LVwiLCBcInJlZi0vI1wiLCBcIm9uLVwiLCBcImJpbmRvbi1cIiBvciBcIkBcIlxuICAvLyBHcm91cCA4ID0gaWRlbnRpZmllciBpbnNpZGUgWygpXVxuICAvLyBHcm91cCA5ID0gaWRlbnRpZmllciBpbnNpZGUgW11cbiAgLy8gR3JvdXAgMTAgPSBpZGVudGlmaWVyIGluc2lkZSAoKVxuICB2YXIgQklORF9OQU1FX1JFR0VYUCA9IC9eKD86KD86KD86KGJpbmQtKXwobGV0LSl8KHJlZi18Iyl8KG9uLSl8KGJpbmRvbi0pfChAKSkoLispKXxcXFtcXCgoW15cXCldKylcXClcXF18XFxbKFteXFxdXSspXFxdfFxcKChbXlxcKV0rKVxcKSkkLztcbiAgdmFyIEtXX0JJTkRfSURYID0gMTtcbiAgdmFyIEtXX0xFVF9JRFggPSAyO1xuICB2YXIgS1dfUkVGX0lEWCA9IDM7XG4gIHZhciBLV19PTl9JRFggPSA0O1xuICB2YXIgS1dfQklORE9OX0lEWCA9IDU7XG4gIHZhciBLV19BVF9JRFggPSA2O1xuICB2YXIgSURFTlRfS1dfSURYID0gNztcbiAgdmFyIElERU5UX0JBTkFOQV9CT1hfSURYID0gODtcbiAgdmFyIElERU5UX1BST1BFUlRZX0lEWCA9IDk7XG4gIHZhciBJREVOVF9FVkVOVF9JRFggPSAxMDtcbiAgdmFyIEFOSU1BVEVfUFJPUF9QUkVGSVggPSAnYW5pbWF0ZS0nO1xuICB2YXIgVEVNUExBVEVfRUxFTUVOVCA9ICd0ZW1wbGF0ZSc7XG4gIHZhciBURU1QTEFURV9BVFRSID0gJ3RlbXBsYXRlJztcbiAgdmFyIFRFTVBMQVRFX0FUVFJfUFJFRklYID0gJyonO1xuICB2YXIgQ0xBU1NfQVRUUiA9ICdjbGFzcyc7XG4gIHZhciBQUk9QRVJUWV9QQVJUU19TRVBBUkFUT1IgPSAnLic7XG4gIHZhciBBVFRSSUJVVEVfUFJFRklYID0gJ2F0dHInO1xuICB2YXIgQ0xBU1NfUFJFRklYID0gJ2NsYXNzJztcbiAgdmFyIFNUWUxFX1BSRUZJWCA9ICdzdHlsZSc7XG4gIHZhciBURVhUX0NTU19TRUxFQ1RPUiA9IENzc1NlbGVjdG9yLnBhcnNlKCcqJylbMF07XG4gIC8qKlxuICAgKiBQcm92aWRlcyBhbiBhcnJheSBvZiB7QGxpbmsgVGVtcGxhdGVBc3RWaXNpdG9yfXMgd2hpY2ggd2lsbCBiZSB1c2VkIHRvIHRyYW5zZm9ybVxuICAgKiBwYXJzZWQgdGVtcGxhdGVzIGJlZm9yZSBjb21waWxhdGlvbiBpcyBpbnZva2VkLCBhbGxvd2luZyBjdXN0b20gZXhwcmVzc2lvbiBzeW50YXhcbiAgICogYW5kIG90aGVyIGFkdmFuY2VkIHRyYW5zZm9ybWF0aW9ucy5cbiAgICpcbiAgICogVGhpcyBpcyBjdXJyZW50bHkgYW4gaW50ZXJuYWwtb25seSBmZWF0dXJlIGFuZCBub3QgbWVhbnQgZm9yIGdlbmVyYWwgdXNlLlxuICAgKi9cbiAgdmFyIFRFTVBMQVRFX1RSQU5TRk9STVMgPSBuZXcgX2FuZ3VsYXJfY29yZS5PcGFxdWVUb2tlbignVGVtcGxhdGVUcmFuc2Zvcm1zJyk7XG4gIHZhciBUZW1wbGF0ZVBhcnNlRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzKFRlbXBsYXRlUGFyc2VFcnJvciwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIFRlbXBsYXRlUGFyc2VFcnJvcihtZXNzYWdlLCBzcGFuLCBsZXZlbCkge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHNwYW4sIG1lc3NhZ2UsIGxldmVsKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBUZW1wbGF0ZVBhcnNlRXJyb3I7XG4gIH0oUGFyc2VFcnJvcikpO1xuICB2YXIgVGVtcGxhdGVQYXJzZVJlc3VsdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBUZW1wbGF0ZVBhcnNlUmVzdWx0KHRlbXBsYXRlQXN0LCBlcnJvcnMpIHtcbiAgICAgICAgICB0aGlzLnRlbXBsYXRlQXN0ID0gdGVtcGxhdGVBc3Q7XG4gICAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICB9XG4gICAgICByZXR1cm4gVGVtcGxhdGVQYXJzZVJlc3VsdDtcbiAgfSgpKTtcbiAgdmFyIFRlbXBsYXRlUGFyc2VyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFRlbXBsYXRlUGFyc2VyKF9leHByUGFyc2VyLCBfc2NoZW1hUmVnaXN0cnksIF9odG1sUGFyc2VyLCBfY29uc29sZSwgdHJhbnNmb3Jtcykge1xuICAgICAgICAgIHRoaXMuX2V4cHJQYXJzZXIgPSBfZXhwclBhcnNlcjtcbiAgICAgICAgICB0aGlzLl9zY2hlbWFSZWdpc3RyeSA9IF9zY2hlbWFSZWdpc3RyeTtcbiAgICAgICAgICB0aGlzLl9odG1sUGFyc2VyID0gX2h0bWxQYXJzZXI7XG4gICAgICAgICAgdGhpcy5fY29uc29sZSA9IF9jb25zb2xlO1xuICAgICAgICAgIHRoaXMudHJhbnNmb3JtcyA9IHRyYW5zZm9ybXM7XG4gICAgICB9XG4gICAgICBUZW1wbGF0ZVBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoY29tcG9uZW50LCB0ZW1wbGF0ZSwgZGlyZWN0aXZlcywgcGlwZXMsIHNjaGVtYXMsIHRlbXBsYXRlVXJsKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMudHJ5UGFyc2UoY29tcG9uZW50LCB0ZW1wbGF0ZSwgZGlyZWN0aXZlcywgcGlwZXMsIHNjaGVtYXMsIHRlbXBsYXRlVXJsKTtcbiAgICAgICAgICB2YXIgd2FybmluZ3MgPSByZXN1bHQuZXJyb3JzLmZpbHRlcihmdW5jdGlvbiAoZXJyb3IpIHsgcmV0dXJuIGVycm9yLmxldmVsID09PSBleHBvcnRzLlBhcnNlRXJyb3JMZXZlbC5XQVJOSU5HOyB9KTtcbiAgICAgICAgICB2YXIgZXJyb3JzID0gcmVzdWx0LmVycm9ycy5maWx0ZXIoZnVuY3Rpb24gKGVycm9yKSB7IHJldHVybiBlcnJvci5sZXZlbCA9PT0gZXhwb3J0cy5QYXJzZUVycm9yTGV2ZWwuRkFUQUw7IH0pO1xuICAgICAgICAgIGlmICh3YXJuaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2NvbnNvbGUud2FybihcIlRlbXBsYXRlIHBhcnNlIHdhcm5pbmdzOlxcblwiICsgd2FybmluZ3Muam9pbignXFxuJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgdmFyIGVycm9yU3RyaW5nID0gZXJyb3JzLmpvaW4oJ1xcbicpO1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUZW1wbGF0ZSBwYXJzZSBlcnJvcnM6XFxuXCIgKyBlcnJvclN0cmluZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQudGVtcGxhdGVBc3Q7XG4gICAgICB9O1xuICAgICAgVGVtcGxhdGVQYXJzZXIucHJvdG90eXBlLnRyeVBhcnNlID0gZnVuY3Rpb24gKGNvbXBvbmVudCwgdGVtcGxhdGUsIGRpcmVjdGl2ZXMsIHBpcGVzLCBzY2hlbWFzLCB0ZW1wbGF0ZVVybCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnRyeVBhcnNlSHRtbCh0aGlzLmV4cGFuZEh0bWwodGhpcy5faHRtbFBhcnNlci5wYXJzZSh0ZW1wbGF0ZSwgdGVtcGxhdGVVcmwsIHRydWUsIHRoaXMuZ2V0SW50ZXJwb2xhdGlvbkNvbmZpZyhjb21wb25lbnQpKSksIGNvbXBvbmVudCwgdGVtcGxhdGUsIGRpcmVjdGl2ZXMsIHBpcGVzLCBzY2hlbWFzLCB0ZW1wbGF0ZVVybCk7XG4gICAgICB9O1xuICAgICAgVGVtcGxhdGVQYXJzZXIucHJvdG90eXBlLnRyeVBhcnNlSHRtbCA9IGZ1bmN0aW9uIChodG1sQXN0V2l0aEVycm9ycywgY29tcG9uZW50LCB0ZW1wbGF0ZSwgZGlyZWN0aXZlcywgcGlwZXMsIHNjaGVtYXMsIHRlbXBsYXRlVXJsKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICB2YXIgZXJyb3JzID0gaHRtbEFzdFdpdGhFcnJvcnMuZXJyb3JzO1xuICAgICAgICAgIGlmIChodG1sQXN0V2l0aEVycm9ycy5yb290Tm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICB2YXIgdW5pcURpcmVjdGl2ZXMgPSByZW1vdmVJZGVudGlmaWVyRHVwbGljYXRlcyhkaXJlY3RpdmVzKTtcbiAgICAgICAgICAgICAgdmFyIHVuaXFQaXBlcyA9IHJlbW92ZUlkZW50aWZpZXJEdXBsaWNhdGVzKHBpcGVzKTtcbiAgICAgICAgICAgICAgdmFyIHByb3ZpZGVyVmlld0NvbnRleHQgPSBuZXcgUHJvdmlkZXJWaWV3Q29udGV4dChjb21wb25lbnQsIGh0bWxBc3RXaXRoRXJyb3JzLnJvb3ROb2Rlc1swXS5zb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgdmFyIHBhcnNlVmlzaXRvciA9IG5ldyBUZW1wbGF0ZVBhcnNlVmlzaXRvcihwcm92aWRlclZpZXdDb250ZXh0LCB1bmlxRGlyZWN0aXZlcywgdW5pcVBpcGVzLCBzY2hlbWFzLCB0aGlzLl9leHByUGFyc2VyLCB0aGlzLl9zY2hlbWFSZWdpc3RyeSk7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHZpc2l0QWxsKHBhcnNlVmlzaXRvciwgaHRtbEFzdFdpdGhFcnJvcnMucm9vdE5vZGVzLCBFTVBUWV9FTEVNRU5UX0NPTlRFWFQpO1xuICAgICAgICAgICAgICBlcnJvcnMucHVzaC5hcHBseShlcnJvcnMsIHBhcnNlVmlzaXRvci5lcnJvcnMuY29uY2F0KHByb3ZpZGVyVmlld0NvbnRleHQuZXJyb3JzKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fYXNzZXJ0Tm9SZWZlcmVuY2VEdXBsaWNhdGlvbk9uVGVtcGxhdGUocmVzdWx0LCBlcnJvcnMpO1xuICAgICAgICAgIGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IFRlbXBsYXRlUGFyc2VSZXN1bHQocmVzdWx0LCBlcnJvcnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMudHJhbnNmb3JtcykpIHtcbiAgICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm1zLmZvckVhY2goZnVuY3Rpb24gKHRyYW5zZm9ybSkgeyByZXN1bHQgPSB0ZW1wbGF0ZVZpc2l0QWxsKHRyYW5zZm9ybSwgcmVzdWx0KTsgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgVGVtcGxhdGVQYXJzZVJlc3VsdChyZXN1bHQsIGVycm9ycyk7XG4gICAgICB9O1xuICAgICAgVGVtcGxhdGVQYXJzZXIucHJvdG90eXBlLmV4cGFuZEh0bWwgPSBmdW5jdGlvbiAoaHRtbEFzdFdpdGhFcnJvcnMsIGZvcmNlZCkge1xuICAgICAgICAgIGlmIChmb3JjZWQgPT09IHZvaWQgMCkgeyBmb3JjZWQgPSBmYWxzZTsgfVxuICAgICAgICAgIHZhciBlcnJvcnMgPSBodG1sQXN0V2l0aEVycm9ycy5lcnJvcnM7XG4gICAgICAgICAgaWYgKGVycm9ycy5sZW5ndGggPT0gMCB8fCBmb3JjZWQpIHtcbiAgICAgICAgICAgICAgLy8gVHJhbnNmb3JtIElDVSBtZXNzYWdlcyB0byBhbmd1bGFyIGRpcmVjdGl2ZXNcbiAgICAgICAgICAgICAgdmFyIGV4cGFuZGVkSHRtbEFzdCA9IGV4cGFuZE5vZGVzKGh0bWxBc3RXaXRoRXJyb3JzLnJvb3ROb2Rlcyk7XG4gICAgICAgICAgICAgIGVycm9ycy5wdXNoLmFwcGx5KGVycm9ycywgZXhwYW5kZWRIdG1sQXN0LmVycm9ycyk7XG4gICAgICAgICAgICAgIGh0bWxBc3RXaXRoRXJyb3JzID0gbmV3IFBhcnNlVHJlZVJlc3VsdChleHBhbmRlZEh0bWxBc3Qubm9kZXMsIGVycm9ycyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBodG1sQXN0V2l0aEVycm9ycztcbiAgICAgIH07XG4gICAgICBUZW1wbGF0ZVBhcnNlci5wcm90b3R5cGUuZ2V0SW50ZXJwb2xhdGlvbkNvbmZpZyA9IGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgICAgICBpZiAoY29tcG9uZW50LnRlbXBsYXRlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBJbnRlcnBvbGF0aW9uQ29uZmlnLmZyb21BcnJheShjb21wb25lbnQudGVtcGxhdGUuaW50ZXJwb2xhdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgIFRlbXBsYXRlUGFyc2VyLnByb3RvdHlwZS5fYXNzZXJ0Tm9SZWZlcmVuY2VEdXBsaWNhdGlvbk9uVGVtcGxhdGUgPSBmdW5jdGlvbiAocmVzdWx0LCBlcnJvcnMpIHtcbiAgICAgICAgICB2YXIgZXhpc3RpbmdSZWZlcmVuY2VzID0gW107XG4gICAgICAgICAgcmVzdWx0LmZpbHRlcihmdW5jdGlvbiAoZWxlbWVudCkgeyByZXR1cm4gISFlbGVtZW50LnJlZmVyZW5jZXM7IH0pXG4gICAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7IHJldHVybiBlbGVtZW50LnJlZmVyZW5jZXMuZm9yRWFjaChmdW5jdGlvbiAocmVmZXJlbmNlKSB7XG4gICAgICAgICAgICAgIHZhciBuYW1lID0gcmVmZXJlbmNlLm5hbWU7XG4gICAgICAgICAgICAgIGlmIChleGlzdGluZ1JlZmVyZW5jZXMuaW5kZXhPZihuYW1lKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgIGV4aXN0aW5nUmVmZXJlbmNlcy5wdXNoKG5hbWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gbmV3IFRlbXBsYXRlUGFyc2VFcnJvcihcIlJlZmVyZW5jZSBcXFwiI1wiICsgbmFtZSArIFwiXFxcIiBpcyBkZWZpbmVkIHNldmVyYWwgdGltZXNcIiwgcmVmZXJlbmNlLnNvdXJjZVNwYW4sIGV4cG9ydHMuUGFyc2VFcnJvckxldmVsLkZBVEFMKTtcbiAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0pOyB9KTtcbiAgICAgIH07XG4gICAgICBUZW1wbGF0ZVBhcnNlci5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG4gICAgICBdO1xuICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICBUZW1wbGF0ZVBhcnNlci5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICB7IHR5cGU6IFBhcnNlciwgfSxcbiAgICAgICAgICB7IHR5cGU6IEVsZW1lbnRTY2hlbWFSZWdpc3RyeSwgfSxcbiAgICAgICAgICB7IHR5cGU6IEkxOE5IdG1sUGFyc2VyLCB9LFxuICAgICAgICAgIHsgdHlwZTogQ29uc29sZSwgfSxcbiAgICAgICAgICB7IHR5cGU6IEFycmF5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtURU1QTEFURV9UUkFOU0ZPUk1TLF0gfSxdIH0sXG4gICAgICBdO1xuICAgICAgcmV0dXJuIFRlbXBsYXRlUGFyc2VyO1xuICB9KCkpO1xuICB2YXIgVGVtcGxhdGVQYXJzZVZpc2l0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gVGVtcGxhdGVQYXJzZVZpc2l0b3IocHJvdmlkZXJWaWV3Q29udGV4dCwgZGlyZWN0aXZlcywgcGlwZXMsIF9zY2hlbWFzLCBfZXhwclBhcnNlciwgX3NjaGVtYVJlZ2lzdHJ5KSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB0aGlzLnByb3ZpZGVyVmlld0NvbnRleHQgPSBwcm92aWRlclZpZXdDb250ZXh0O1xuICAgICAgICAgIHRoaXMuX3NjaGVtYXMgPSBfc2NoZW1hcztcbiAgICAgICAgICB0aGlzLl9leHByUGFyc2VyID0gX2V4cHJQYXJzZXI7XG4gICAgICAgICAgdGhpcy5fc2NoZW1hUmVnaXN0cnkgPSBfc2NoZW1hUmVnaXN0cnk7XG4gICAgICAgICAgdGhpcy5zZWxlY3Rvck1hdGNoZXIgPSBuZXcgU2VsZWN0b3JNYXRjaGVyKCk7XG4gICAgICAgICAgdGhpcy5lcnJvcnMgPSBbXTtcbiAgICAgICAgICB0aGlzLmRpcmVjdGl2ZXNJbmRleCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICB0aGlzLm5nQ29udGVudENvdW50ID0gMDtcbiAgICAgICAgICB0aGlzLnBpcGVzQnlOYW1lID0gbmV3IE1hcCgpO1xuICAgICAgICAgIHZhciB0ZW1wTWV0YSA9IHByb3ZpZGVyVmlld0NvbnRleHQuY29tcG9uZW50LnRlbXBsYXRlO1xuICAgICAgICAgIGlmICh0ZW1wTWV0YSAmJiB0ZW1wTWV0YS5pbnRlcnBvbGF0aW9uKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2ludGVycG9sYXRpb25Db25maWcgPSB7XG4gICAgICAgICAgICAgICAgICBzdGFydDogdGVtcE1ldGEuaW50ZXJwb2xhdGlvblswXSxcbiAgICAgICAgICAgICAgICAgIGVuZDogdGVtcE1ldGEuaW50ZXJwb2xhdGlvblsxXVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBkaXJlY3RpdmVzLmZvckVhY2goZnVuY3Rpb24gKGRpcmVjdGl2ZSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgdmFyIHNlbGVjdG9yID0gQ3NzU2VsZWN0b3IucGFyc2UoZGlyZWN0aXZlLnNlbGVjdG9yKTtcbiAgICAgICAgICAgICAgX3RoaXMuc2VsZWN0b3JNYXRjaGVyLmFkZFNlbGVjdGFibGVzKHNlbGVjdG9yLCBkaXJlY3RpdmUpO1xuICAgICAgICAgICAgICBfdGhpcy5kaXJlY3RpdmVzSW5kZXguc2V0KGRpcmVjdGl2ZSwgaW5kZXgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHBpcGVzLmZvckVhY2goZnVuY3Rpb24gKHBpcGUpIHsgcmV0dXJuIF90aGlzLnBpcGVzQnlOYW1lLnNldChwaXBlLm5hbWUsIHBpcGUpOyB9KTtcbiAgICAgIH1cbiAgICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fcmVwb3J0RXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZSwgc291cmNlU3BhbiwgbGV2ZWwpIHtcbiAgICAgICAgICBpZiAobGV2ZWwgPT09IHZvaWQgMCkgeyBsZXZlbCA9IGV4cG9ydHMuUGFyc2VFcnJvckxldmVsLkZBVEFMOyB9XG4gICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChuZXcgVGVtcGxhdGVQYXJzZUVycm9yKG1lc3NhZ2UsIHNvdXJjZVNwYW4sIGxldmVsKSk7XG4gICAgICB9O1xuICAgICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9yZXBvcnRQYXJzZXJFcnJvcnMgPSBmdW5jdGlvbiAoZXJyb3JzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBlcnJvcnNfMSA9IGVycm9yczsgX2kgPCBlcnJvcnNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgdmFyIGVycm9yID0gZXJyb3JzXzFbX2ldO1xuICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihlcnJvci5tZXNzYWdlLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9wYXJzZUludGVycG9sYXRpb24gPSBmdW5jdGlvbiAodmFsdWUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgICB2YXIgc291cmNlSW5mbyA9IHNvdXJjZVNwYW4uc3RhcnQudG9TdHJpbmcoKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB2YXIgYXN0ID0gdGhpcy5fZXhwclBhcnNlci5wYXJzZUludGVycG9sYXRpb24odmFsdWUsIHNvdXJjZUluZm8sIHRoaXMuX2ludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICAgICAgICBpZiAoYXN0KVxuICAgICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0UGFyc2VyRXJyb3JzKGFzdC5lcnJvcnMsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICB0aGlzLl9jaGVja1BpcGVzKGFzdCwgc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoYXN0KSAmJlxuICAgICAgICAgICAgICAgICAgYXN0LmFzdC5leHByZXNzaW9ucy5sZW5ndGggPiB2aWV3X3V0aWxzLk1BWF9JTlRFUlBPTEFUSU9OX1ZBTFVFUykge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT25seSBzdXBwb3J0IGF0IG1vc3QgXCIgKyB2aWV3X3V0aWxzLk1BWF9JTlRFUlBPTEFUSU9OX1ZBTFVFUyArIFwiIGludGVycG9sYXRpb24gdmFsdWVzIVwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gYXN0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIlwiICsgZSwgc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9leHByUGFyc2VyLndyYXBMaXRlcmFsUHJpbWl0aXZlKCdFUlJPUicsIHNvdXJjZUluZm8pO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX3BhcnNlQWN0aW9uID0gZnVuY3Rpb24gKHZhbHVlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgICAgdmFyIHNvdXJjZUluZm8gPSBzb3VyY2VTcGFuLnN0YXJ0LnRvU3RyaW5nKCk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdmFyIGFzdCA9IHRoaXMuX2V4cHJQYXJzZXIucGFyc2VBY3Rpb24odmFsdWUsIHNvdXJjZUluZm8sIHRoaXMuX2ludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICAgICAgICBpZiAoYXN0KSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRQYXJzZXJFcnJvcnMoYXN0LmVycm9ycywgc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFhc3QgfHwgYXN0LmFzdCBpbnN0YW5jZW9mIEVtcHR5RXhwcikge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCJFbXB0eSBleHByZXNzaW9ucyBhcmUgbm90IGFsbG93ZWRcIiwgc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZXhwclBhcnNlci53cmFwTGl0ZXJhbFByaW1pdGl2ZSgnRVJST1InLCBzb3VyY2VJbmZvKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLl9jaGVja1BpcGVzKGFzdCwgc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgIHJldHVybiBhc3Q7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKFwiXCIgKyBlLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V4cHJQYXJzZXIud3JhcExpdGVyYWxQcmltaXRpdmUoJ0VSUk9SJywgc291cmNlSW5mbyk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fcGFyc2VCaW5kaW5nID0gZnVuY3Rpb24gKHZhbHVlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgICAgdmFyIHNvdXJjZUluZm8gPSBzb3VyY2VTcGFuLnN0YXJ0LnRvU3RyaW5nKCk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdmFyIGFzdCA9IHRoaXMuX2V4cHJQYXJzZXIucGFyc2VCaW5kaW5nKHZhbHVlLCBzb3VyY2VJbmZvLCB0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgICAgICAgaWYgKGFzdClcbiAgICAgICAgICAgICAgICAgIHRoaXMuX3JlcG9ydFBhcnNlckVycm9ycyhhc3QuZXJyb3JzLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgdGhpcy5fY2hlY2tQaXBlcyhhc3QsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICByZXR1cm4gYXN0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIlwiICsgZSwgc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9leHByUGFyc2VyLndyYXBMaXRlcmFsUHJpbWl0aXZlKCdFUlJPUicsIHNvdXJjZUluZm8pO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX3BhcnNlVGVtcGxhdGVCaW5kaW5ncyA9IGZ1bmN0aW9uICh2YWx1ZSwgc291cmNlU3Bhbikge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIHNvdXJjZUluZm8gPSBzb3VyY2VTcGFuLnN0YXJ0LnRvU3RyaW5nKCk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdmFyIGJpbmRpbmdzUmVzdWx0ID0gdGhpcy5fZXhwclBhcnNlci5wYXJzZVRlbXBsYXRlQmluZGluZ3ModmFsdWUsIHNvdXJjZUluZm8pO1xuICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRQYXJzZXJFcnJvcnMoYmluZGluZ3NSZXN1bHQuZXJyb3JzLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgYmluZGluZ3NSZXN1bHQudGVtcGxhdGVCaW5kaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChiaW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KGJpbmRpbmcuZXhwcmVzc2lvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fY2hlY2tQaXBlcyhiaW5kaW5nLmV4cHJlc3Npb24sIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYmluZGluZ3NSZXN1bHQud2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAod2FybmluZykgeyBfdGhpcy5fcmVwb3J0RXJyb3Iod2FybmluZywgc291cmNlU3BhbiwgZXhwb3J0cy5QYXJzZUVycm9yTGV2ZWwuV0FSTklORyk7IH0pO1xuICAgICAgICAgICAgICByZXR1cm4gYmluZGluZ3NSZXN1bHQudGVtcGxhdGVCaW5kaW5ncztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCJcIiArIGUsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fY2hlY2tQaXBlcyA9IGZ1bmN0aW9uIChhc3QsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIGlmIChpc1ByZXNlbnQoYXN0KSkge1xuICAgICAgICAgICAgICB2YXIgY29sbGVjdG9yID0gbmV3IFBpcGVDb2xsZWN0b3IoKTtcbiAgICAgICAgICAgICAgYXN0LnZpc2l0KGNvbGxlY3Rvcik7XG4gICAgICAgICAgICAgIGNvbGxlY3Rvci5waXBlcy5mb3JFYWNoKGZ1bmN0aW9uIChwaXBlTmFtZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5waXBlc0J5TmFtZS5oYXMocGlwZU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlcG9ydEVycm9yKFwiVGhlIHBpcGUgJ1wiICsgcGlwZU5hbWUgKyBcIicgY291bGQgbm90IGJlIGZvdW5kXCIsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uID0gZnVuY3Rpb24gKGV4cGFuc2lvbiwgY29udGV4dCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbkNhc2UgPSBmdW5jdGlvbiAoZXhwYW5zaW9uQ2FzZSwgY29udGV4dCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAodGV4dCwgcGFyZW50KSB7XG4gICAgICAgICAgdmFyIG5nQ29udGVudEluZGV4ID0gcGFyZW50LmZpbmROZ0NvbnRlbnRJbmRleChURVhUX0NTU19TRUxFQ1RPUik7XG4gICAgICAgICAgdmFyIGV4cHIgPSB0aGlzLl9wYXJzZUludGVycG9sYXRpb24odGV4dC52YWx1ZSwgdGV4dC5zb3VyY2VTcGFuKTtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KGV4cHIpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgQm91bmRUZXh0QXN0KGV4cHIsIG5nQ29udGVudEluZGV4LCB0ZXh0LnNvdXJjZVNwYW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUZXh0QXN0KHRleHQudmFsdWUsIG5nQ29udGVudEluZGV4LCB0ZXh0LnNvdXJjZVNwYW4pO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUudmlzaXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXR0cmlidXRlLCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBBdHRyQXN0KGF0dHJpYnV0ZS5uYW1lLCBhdHRyaWJ1dGUudmFsdWUsIGF0dHJpYnV0ZS5zb3VyY2VTcGFuKTtcbiAgICAgIH07XG4gICAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb21tZW50ID0gZnVuY3Rpb24gKGNvbW1lbnQsIGNvbnRleHQpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUudmlzaXRFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQsIHBhcmVudCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5uYW1lO1xuICAgICAgICAgIHZhciBwcmVwYXJzZWRFbGVtZW50ID0gcHJlcGFyc2VFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICAgIGlmIChwcmVwYXJzZWRFbGVtZW50LnR5cGUgPT09IFByZXBhcnNlZEVsZW1lbnRUeXBlLlNDUklQVCB8fFxuICAgICAgICAgICAgICBwcmVwYXJzZWRFbGVtZW50LnR5cGUgPT09IFByZXBhcnNlZEVsZW1lbnRUeXBlLlNUWUxFKSB7XG4gICAgICAgICAgICAgIC8vIFNraXBwaW5nIDxzY3JpcHQ+IGZvciBzZWN1cml0eSByZWFzb25zXG4gICAgICAgICAgICAgIC8vIFNraXBwaW5nIDxzdHlsZT4gYXMgd2UgYWxyZWFkeSBwcm9jZXNzZWQgdGhlbVxuICAgICAgICAgICAgICAvLyBpbiB0aGUgU3R5bGVDb21waWxlclxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHByZXBhcnNlZEVsZW1lbnQudHlwZSA9PT0gUHJlcGFyc2VkRWxlbWVudFR5cGUuU1RZTEVTSEVFVCAmJlxuICAgICAgICAgICAgICBpc1N0eWxlVXJsUmVzb2x2YWJsZShwcmVwYXJzZWRFbGVtZW50LmhyZWZBdHRyKSkge1xuICAgICAgICAgICAgICAvLyBTa2lwcGluZyBzdHlsZXNoZWV0cyB3aXRoIGVpdGhlciByZWxhdGl2ZSB1cmxzIG9yIHBhY2thZ2Ugc2NoZW1lIGFzIHdlIGFscmVhZHkgcHJvY2Vzc2VkXG4gICAgICAgICAgICAgIC8vIHRoZW0gaW4gdGhlIFN0eWxlQ29tcGlsZXJcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBtYXRjaGFibGVBdHRycyA9IFtdO1xuICAgICAgICAgIHZhciBlbGVtZW50T3JEaXJlY3RpdmVQcm9wcyA9IFtdO1xuICAgICAgICAgIHZhciBlbGVtZW50T3JEaXJlY3RpdmVSZWZzID0gW107XG4gICAgICAgICAgdmFyIGVsZW1lbnRWYXJzID0gW107XG4gICAgICAgICAgdmFyIGFuaW1hdGlvblByb3BzID0gW107XG4gICAgICAgICAgdmFyIGV2ZW50cyA9IFtdO1xuICAgICAgICAgIHZhciB0ZW1wbGF0ZUVsZW1lbnRPckRpcmVjdGl2ZVByb3BzID0gW107XG4gICAgICAgICAgdmFyIHRlbXBsYXRlTWF0Y2hhYmxlQXR0cnMgPSBbXTtcbiAgICAgICAgICB2YXIgdGVtcGxhdGVFbGVtZW50VmFycyA9IFtdO1xuICAgICAgICAgIHZhciBoYXNJbmxpbmVUZW1wbGF0ZXMgPSBmYWxzZTtcbiAgICAgICAgICB2YXIgYXR0cnMgPSBbXTtcbiAgICAgICAgICB2YXIgbGNFbE5hbWUgPSBzcGxpdE5zTmFtZShub2RlTmFtZS50b0xvd2VyQ2FzZSgpKVsxXTtcbiAgICAgICAgICB2YXIgaXNUZW1wbGF0ZUVsZW1lbnQgPSBsY0VsTmFtZSA9PSBURU1QTEFURV9FTEVNRU5UO1xuICAgICAgICAgIGVsZW1lbnQuYXR0cnMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgICAgICB2YXIgaGFzQmluZGluZyA9IF90aGlzLl9wYXJzZUF0dHIoaXNUZW1wbGF0ZUVsZW1lbnQsIGF0dHIsIG1hdGNoYWJsZUF0dHJzLCBlbGVtZW50T3JEaXJlY3RpdmVQcm9wcywgYW5pbWF0aW9uUHJvcHMsIGV2ZW50cywgZWxlbWVudE9yRGlyZWN0aXZlUmVmcywgZWxlbWVudFZhcnMpO1xuICAgICAgICAgICAgICB2YXIgaGFzVGVtcGxhdGVCaW5kaW5nID0gX3RoaXMuX3BhcnNlSW5saW5lVGVtcGxhdGVCaW5kaW5nKGF0dHIsIHRlbXBsYXRlTWF0Y2hhYmxlQXR0cnMsIHRlbXBsYXRlRWxlbWVudE9yRGlyZWN0aXZlUHJvcHMsIHRlbXBsYXRlRWxlbWVudFZhcnMpO1xuICAgICAgICAgICAgICBpZiAoaGFzVGVtcGxhdGVCaW5kaW5nICYmIGhhc0lubGluZVRlbXBsYXRlcykge1xuICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlcG9ydEVycm9yKFwiQ2FuJ3QgaGF2ZSBtdWx0aXBsZSB0ZW1wbGF0ZSBiaW5kaW5ncyBvbiBvbmUgZWxlbWVudC4gVXNlIG9ubHkgb25lIGF0dHJpYnV0ZSBuYW1lZCAndGVtcGxhdGUnIG9yIHByZWZpeGVkIHdpdGggKlwiLCBhdHRyLnNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghaGFzQmluZGluZyAmJiAhaGFzVGVtcGxhdGVCaW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgICAvLyBkb24ndCBpbmNsdWRlIHRoZSBiaW5kaW5ncyBhcyBhdHRyaWJ1dGVzIGFzIHdlbGwgaW4gdGhlIEFTVFxuICAgICAgICAgICAgICAgICAgYXR0cnMucHVzaChfdGhpcy52aXNpdEF0dHJpYnV0ZShhdHRyLCBudWxsKSk7XG4gICAgICAgICAgICAgICAgICBtYXRjaGFibGVBdHRycy5wdXNoKFthdHRyLm5hbWUsIGF0dHIudmFsdWVdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaGFzVGVtcGxhdGVCaW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgICBoYXNJbmxpbmVUZW1wbGF0ZXMgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIGVsZW1lbnRDc3NTZWxlY3RvciA9IGNyZWF0ZUVsZW1lbnRDc3NTZWxlY3Rvcihub2RlTmFtZSwgbWF0Y2hhYmxlQXR0cnMpO1xuICAgICAgICAgIHZhciBfYSA9IHRoaXMuX3BhcnNlRGlyZWN0aXZlcyh0aGlzLnNlbGVjdG9yTWF0Y2hlciwgZWxlbWVudENzc1NlbGVjdG9yKSwgZGlyZWN0aXZlTWV0YXMgPSBfYS5kaXJlY3RpdmVzLCBtYXRjaEVsZW1lbnQgPSBfYS5tYXRjaEVsZW1lbnQ7XG4gICAgICAgICAgdmFyIHJlZmVyZW5jZXMgPSBbXTtcbiAgICAgICAgICB2YXIgZGlyZWN0aXZlQXN0cyA9IHRoaXMuX2NyZWF0ZURpcmVjdGl2ZUFzdHMoaXNUZW1wbGF0ZUVsZW1lbnQsIGVsZW1lbnQubmFtZSwgZGlyZWN0aXZlTWV0YXMsIGVsZW1lbnRPckRpcmVjdGl2ZVByb3BzLCBlbGVtZW50T3JEaXJlY3RpdmVSZWZzLCBlbGVtZW50LnNvdXJjZVNwYW4sIHJlZmVyZW5jZXMpO1xuICAgICAgICAgIHZhciBlbGVtZW50UHJvcHMgPSB0aGlzLl9jcmVhdGVFbGVtZW50UHJvcGVydHlBc3RzKGVsZW1lbnQubmFtZSwgZWxlbWVudE9yRGlyZWN0aXZlUHJvcHMsIGRpcmVjdGl2ZUFzdHMpXG4gICAgICAgICAgICAgIC5jb25jYXQoYW5pbWF0aW9uUHJvcHMpO1xuICAgICAgICAgIHZhciBpc1ZpZXdSb290ID0gcGFyZW50LmlzVGVtcGxhdGVFbGVtZW50IHx8IGhhc0lubGluZVRlbXBsYXRlcztcbiAgICAgICAgICB2YXIgcHJvdmlkZXJDb250ZXh0ID0gbmV3IFByb3ZpZGVyRWxlbWVudENvbnRleHQodGhpcy5wcm92aWRlclZpZXdDb250ZXh0LCBwYXJlbnQucHJvdmlkZXJDb250ZXh0LCBpc1ZpZXdSb290LCBkaXJlY3RpdmVBc3RzLCBhdHRycywgcmVmZXJlbmNlcywgZWxlbWVudC5zb3VyY2VTcGFuKTtcbiAgICAgICAgICB2YXIgY2hpbGRyZW4gPSB2aXNpdEFsbChwcmVwYXJzZWRFbGVtZW50Lm5vbkJpbmRhYmxlID8gTk9OX0JJTkRBQkxFX1ZJU0lUT1IgOiB0aGlzLCBlbGVtZW50LmNoaWxkcmVuLCBFbGVtZW50Q29udGV4dC5jcmVhdGUoaXNUZW1wbGF0ZUVsZW1lbnQsIGRpcmVjdGl2ZUFzdHMsIGlzVGVtcGxhdGVFbGVtZW50ID8gcGFyZW50LnByb3ZpZGVyQ29udGV4dCA6IHByb3ZpZGVyQ29udGV4dCkpO1xuICAgICAgICAgIHByb3ZpZGVyQ29udGV4dC5hZnRlckVsZW1lbnQoKTtcbiAgICAgICAgICAvLyBPdmVycmlkZSB0aGUgYWN0dWFsIHNlbGVjdG9yIHdoZW4gdGhlIGBuZ1Byb2plY3RBc2AgYXR0cmlidXRlIGlzIHByb3ZpZGVkXG4gICAgICAgICAgdmFyIHByb2plY3Rpb25TZWxlY3RvciA9IGlzUHJlc2VudChwcmVwYXJzZWRFbGVtZW50LnByb2plY3RBcykgP1xuICAgICAgICAgICAgICBDc3NTZWxlY3Rvci5wYXJzZShwcmVwYXJzZWRFbGVtZW50LnByb2plY3RBcylbMF0gOlxuICAgICAgICAgICAgICBlbGVtZW50Q3NzU2VsZWN0b3I7XG4gICAgICAgICAgdmFyIG5nQ29udGVudEluZGV4ID0gcGFyZW50LmZpbmROZ0NvbnRlbnRJbmRleChwcm9qZWN0aW9uU2VsZWN0b3IpO1xuICAgICAgICAgIHZhciBwYXJzZWRFbGVtZW50O1xuICAgICAgICAgIGlmIChwcmVwYXJzZWRFbGVtZW50LnR5cGUgPT09IFByZXBhcnNlZEVsZW1lbnRUeXBlLk5HX0NPTlRFTlQpIHtcbiAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuY2hpbGRyZW4gJiYgIWVsZW1lbnQuY2hpbGRyZW4uZXZlcnkoX2lzRW1wdHlUZXh0Tm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKFwiPG5nLWNvbnRlbnQ+IGVsZW1lbnQgY2Fubm90IGhhdmUgY29udGVudC5cIiwgZWxlbWVudC5zb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwYXJzZWRFbGVtZW50ID0gbmV3IE5nQ29udGVudEFzdCh0aGlzLm5nQ29udGVudENvdW50KyssIGhhc0lubGluZVRlbXBsYXRlcyA/IG51bGwgOiBuZ0NvbnRlbnRJbmRleCwgZWxlbWVudC5zb3VyY2VTcGFuKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoaXNUZW1wbGF0ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgdGhpcy5fYXNzZXJ0QWxsRXZlbnRzUHVibGlzaGVkQnlEaXJlY3RpdmVzKGRpcmVjdGl2ZUFzdHMsIGV2ZW50cyk7XG4gICAgICAgICAgICAgIHRoaXMuX2Fzc2VydE5vQ29tcG9uZW50c05vckVsZW1lbnRCaW5kaW5nc09uVGVtcGxhdGUoZGlyZWN0aXZlQXN0cywgZWxlbWVudFByb3BzLCBlbGVtZW50LnNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICBwYXJzZWRFbGVtZW50ID0gbmV3IEVtYmVkZGVkVGVtcGxhdGVBc3QoYXR0cnMsIGV2ZW50cywgcmVmZXJlbmNlcywgZWxlbWVudFZhcnMsIHByb3ZpZGVyQ29udGV4dC50cmFuc2Zvcm1lZERpcmVjdGl2ZUFzdHMsIHByb3ZpZGVyQ29udGV4dC50cmFuc2Zvcm1Qcm92aWRlcnMsIHByb3ZpZGVyQ29udGV4dC50cmFuc2Zvcm1lZEhhc1ZpZXdDb250YWluZXIsIGNoaWxkcmVuLCBoYXNJbmxpbmVUZW1wbGF0ZXMgPyBudWxsIDogbmdDb250ZW50SW5kZXgsIGVsZW1lbnQuc291cmNlU3Bhbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLl9hc3NlcnRFbGVtZW50RXhpc3RzKG1hdGNoRWxlbWVudCwgZWxlbWVudCk7XG4gICAgICAgICAgICAgIHRoaXMuX2Fzc2VydE9ubHlPbmVDb21wb25lbnQoZGlyZWN0aXZlQXN0cywgZWxlbWVudC5zb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgdmFyIG5nQ29udGVudEluZGV4XzEgPSBoYXNJbmxpbmVUZW1wbGF0ZXMgPyBudWxsIDogcGFyZW50LmZpbmROZ0NvbnRlbnRJbmRleChwcm9qZWN0aW9uU2VsZWN0b3IpO1xuICAgICAgICAgICAgICBwYXJzZWRFbGVtZW50ID0gbmV3IEVsZW1lbnRBc3Qobm9kZU5hbWUsIGF0dHJzLCBlbGVtZW50UHJvcHMsIGV2ZW50cywgcmVmZXJlbmNlcywgcHJvdmlkZXJDb250ZXh0LnRyYW5zZm9ybWVkRGlyZWN0aXZlQXN0cywgcHJvdmlkZXJDb250ZXh0LnRyYW5zZm9ybVByb3ZpZGVycywgcHJvdmlkZXJDb250ZXh0LnRyYW5zZm9ybWVkSGFzVmlld0NvbnRhaW5lciwgY2hpbGRyZW4sIGhhc0lubGluZVRlbXBsYXRlcyA/IG51bGwgOiBuZ0NvbnRlbnRJbmRleF8xLCBlbGVtZW50LnNvdXJjZVNwYW4sIGVsZW1lbnQuZW5kU291cmNlU3Bhbik7XG4gICAgICAgICAgICAgIHRoaXMuX2ZpbmRDb21wb25lbnREaXJlY3RpdmVzKGRpcmVjdGl2ZUFzdHMpXG4gICAgICAgICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAoY29tcG9uZW50RGlyZWN0aXZlQXN0KSB7IHJldHVybiBfdGhpcy5fdmFsaWRhdGVFbGVtZW50QW5pbWF0aW9uSW5wdXRPdXRwdXRzKGNvbXBvbmVudERpcmVjdGl2ZUFzdC5ob3N0UHJvcGVydGllcywgY29tcG9uZW50RGlyZWN0aXZlQXN0Lmhvc3RFdmVudHMsIGNvbXBvbmVudERpcmVjdGl2ZUFzdC5kaXJlY3RpdmUudGVtcGxhdGUpOyB9KTtcbiAgICAgICAgICAgICAgdmFyIGNvbXBvbmVudFRlbXBsYXRlID0gcHJvdmlkZXJDb250ZXh0LnZpZXdDb250ZXh0LmNvbXBvbmVudC50ZW1wbGF0ZTtcbiAgICAgICAgICAgICAgdGhpcy5fdmFsaWRhdGVFbGVtZW50QW5pbWF0aW9uSW5wdXRPdXRwdXRzKGVsZW1lbnRQcm9wcywgZXZlbnRzLCBjb21wb25lbnRUZW1wbGF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChoYXNJbmxpbmVUZW1wbGF0ZXMpIHtcbiAgICAgICAgICAgICAgdmFyIHRlbXBsYXRlQ3NzU2VsZWN0b3IgPSBjcmVhdGVFbGVtZW50Q3NzU2VsZWN0b3IoVEVNUExBVEVfRUxFTUVOVCwgdGVtcGxhdGVNYXRjaGFibGVBdHRycyk7XG4gICAgICAgICAgICAgIHZhciB0ZW1wbGF0ZURpcmVjdGl2ZU1ldGFzID0gdGhpcy5fcGFyc2VEaXJlY3RpdmVzKHRoaXMuc2VsZWN0b3JNYXRjaGVyLCB0ZW1wbGF0ZUNzc1NlbGVjdG9yKS5kaXJlY3RpdmVzO1xuICAgICAgICAgICAgICB2YXIgdGVtcGxhdGVEaXJlY3RpdmVBc3RzID0gdGhpcy5fY3JlYXRlRGlyZWN0aXZlQXN0cyh0cnVlLCBlbGVtZW50Lm5hbWUsIHRlbXBsYXRlRGlyZWN0aXZlTWV0YXMsIHRlbXBsYXRlRWxlbWVudE9yRGlyZWN0aXZlUHJvcHMsIFtdLCBlbGVtZW50LnNvdXJjZVNwYW4sIFtdKTtcbiAgICAgICAgICAgICAgdmFyIHRlbXBsYXRlRWxlbWVudFByb3BzID0gdGhpcy5fY3JlYXRlRWxlbWVudFByb3BlcnR5QXN0cyhlbGVtZW50Lm5hbWUsIHRlbXBsYXRlRWxlbWVudE9yRGlyZWN0aXZlUHJvcHMsIHRlbXBsYXRlRGlyZWN0aXZlQXN0cyk7XG4gICAgICAgICAgICAgIHRoaXMuX2Fzc2VydE5vQ29tcG9uZW50c05vckVsZW1lbnRCaW5kaW5nc09uVGVtcGxhdGUodGVtcGxhdGVEaXJlY3RpdmVBc3RzLCB0ZW1wbGF0ZUVsZW1lbnRQcm9wcywgZWxlbWVudC5zb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgdmFyIHRlbXBsYXRlUHJvdmlkZXJDb250ZXh0ID0gbmV3IFByb3ZpZGVyRWxlbWVudENvbnRleHQodGhpcy5wcm92aWRlclZpZXdDb250ZXh0LCBwYXJlbnQucHJvdmlkZXJDb250ZXh0LCBwYXJlbnQuaXNUZW1wbGF0ZUVsZW1lbnQsIHRlbXBsYXRlRGlyZWN0aXZlQXN0cywgW10sIFtdLCBlbGVtZW50LnNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICB0ZW1wbGF0ZVByb3ZpZGVyQ29udGV4dC5hZnRlckVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgcGFyc2VkRWxlbWVudCA9IG5ldyBFbWJlZGRlZFRlbXBsYXRlQXN0KFtdLCBbXSwgW10sIHRlbXBsYXRlRWxlbWVudFZhcnMsIHRlbXBsYXRlUHJvdmlkZXJDb250ZXh0LnRyYW5zZm9ybWVkRGlyZWN0aXZlQXN0cywgdGVtcGxhdGVQcm92aWRlckNvbnRleHQudHJhbnNmb3JtUHJvdmlkZXJzLCB0ZW1wbGF0ZVByb3ZpZGVyQ29udGV4dC50cmFuc2Zvcm1lZEhhc1ZpZXdDb250YWluZXIsIFtwYXJzZWRFbGVtZW50XSwgbmdDb250ZW50SW5kZXgsIGVsZW1lbnQuc291cmNlU3Bhbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBwYXJzZWRFbGVtZW50O1xuICAgICAgfTtcbiAgICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fdmFsaWRhdGVFbGVtZW50QW5pbWF0aW9uSW5wdXRPdXRwdXRzID0gZnVuY3Rpb24gKGlucHV0cywgb3V0cHV0cywgdGVtcGxhdGUpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciB0cmlnZ2VyTG9va3VwID0gbmV3IFNldCgpO1xuICAgICAgICAgIHRlbXBsYXRlLmFuaW1hdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHsgdHJpZ2dlckxvb2t1cC5hZGQoZW50cnkubmFtZSk7IH0pO1xuICAgICAgICAgIHZhciBhbmltYXRpb25JbnB1dHMgPSBpbnB1dHMuZmlsdGVyKGZ1bmN0aW9uIChpbnB1dCkgeyByZXR1cm4gaW5wdXQuaXNBbmltYXRpb247IH0pO1xuICAgICAgICAgIGFuaW1hdGlvbklucHV0cy5mb3JFYWNoKGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgICB2YXIgbmFtZSA9IGlucHV0Lm5hbWU7XG4gICAgICAgICAgICAgIGlmICghdHJpZ2dlckxvb2t1cC5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzLl9yZXBvcnRFcnJvcihcIkNvdWxkbid0IGZpbmQgYW4gYW5pbWF0aW9uIGVudHJ5IGZvciBcXFwiXCIgKyBuYW1lICsgXCJcXFwiXCIsIGlucHV0LnNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgb3V0cHV0cy5mb3JFYWNoKGZ1bmN0aW9uIChvdXRwdXQpIHtcbiAgICAgICAgICAgICAgaWYgKG91dHB1dC5pc0FuaW1hdGlvbikge1xuICAgICAgICAgICAgICAgICAgdmFyIGZvdW5kID0gYW5pbWF0aW9uSW5wdXRzLmZpbmQoZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBpbnB1dC5uYW1lID09IG91dHB1dC5uYW1lOyB9KTtcbiAgICAgICAgICAgICAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVwb3J0RXJyb3IoXCJVbmFibGUgdG8gbGlzdGVuIG9uIChAXCIgKyBvdXRwdXQubmFtZSArIFwiLlwiICsgb3V0cHV0LnBoYXNlICsgXCIpIGJlY2F1c2UgdGhlIGFuaW1hdGlvbiB0cmlnZ2VyIFtAXCIgKyBvdXRwdXQubmFtZSArIFwiXSBpc24ndCBiZWluZyB1c2VkIG9uIHRoZSBzYW1lIGVsZW1lbnRcIiwgb3V0cHV0LnNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9wYXJzZUlubGluZVRlbXBsYXRlQmluZGluZyA9IGZ1bmN0aW9uIChhdHRyLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMsIHRhcmdldFZhcnMpIHtcbiAgICAgICAgICB2YXIgdGVtcGxhdGVCaW5kaW5nc1NvdXJjZSA9IG51bGw7XG4gICAgICAgICAgaWYgKHRoaXMuX25vcm1hbGl6ZUF0dHJpYnV0ZU5hbWUoYXR0ci5uYW1lKSA9PSBURU1QTEFURV9BVFRSKSB7XG4gICAgICAgICAgICAgIHRlbXBsYXRlQmluZGluZ3NTb3VyY2UgPSBhdHRyLnZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChhdHRyLm5hbWUuc3RhcnRzV2l0aChURU1QTEFURV9BVFRSX1BSRUZJWCkpIHtcbiAgICAgICAgICAgICAgdmFyIGtleSA9IGF0dHIubmFtZS5zdWJzdHJpbmcoVEVNUExBVEVfQVRUUl9QUkVGSVgubGVuZ3RoKTsgLy8gcmVtb3ZlIHRoZSBzdGFyXG4gICAgICAgICAgICAgIHRlbXBsYXRlQmluZGluZ3NTb3VyY2UgPSAoYXR0ci52YWx1ZS5sZW5ndGggPT0gMCkgPyBrZXkgOiBrZXkgKyAnICcgKyBhdHRyLnZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNQcmVzZW50KHRlbXBsYXRlQmluZGluZ3NTb3VyY2UpKSB7XG4gICAgICAgICAgICAgIHZhciBiaW5kaW5ncyA9IHRoaXMuX3BhcnNlVGVtcGxhdGVCaW5kaW5ncyh0ZW1wbGF0ZUJpbmRpbmdzU291cmNlLCBhdHRyLnNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJpbmRpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgYmluZGluZyA9IGJpbmRpbmdzW2ldO1xuICAgICAgICAgICAgICAgICAgaWYgKGJpbmRpbmcua2V5SXNWYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRWYXJzLnB1c2gobmV3IFZhcmlhYmxlQXN0KGJpbmRpbmcua2V5LCBiaW5kaW5nLm5hbWUsIGF0dHIuc291cmNlU3BhbikpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNQcmVzZW50KGJpbmRpbmcuZXhwcmVzc2lvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZVByb3BlcnR5QXN0KGJpbmRpbmcua2V5LCBiaW5kaW5nLmV4cHJlc3Npb24sIGF0dHIuc291cmNlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHRhcmdldE1hdGNoYWJsZUF0dHJzLnB1c2goW2JpbmRpbmcua2V5LCAnJ10pO1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlTGl0ZXJhbEF0dHIoYmluZGluZy5rZXksIG51bGwsIGF0dHIuc291cmNlU3BhbiwgdGFyZ2V0UHJvcHMpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuICAgICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9wYXJzZUF0dHIgPSBmdW5jdGlvbiAoaXNUZW1wbGF0ZUVsZW1lbnQsIGF0dHIsIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcywgdGFyZ2V0QW5pbWF0aW9uUHJvcHMsIHRhcmdldEV2ZW50cywgdGFyZ2V0UmVmcywgdGFyZ2V0VmFycykge1xuICAgICAgICAgIHZhciBuYW1lID0gdGhpcy5fbm9ybWFsaXplQXR0cmlidXRlTmFtZShhdHRyLm5hbWUpO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGF0dHIudmFsdWU7XG4gICAgICAgICAgdmFyIHNyY1NwYW4gPSBhdHRyLnNvdXJjZVNwYW47XG4gICAgICAgICAgdmFyIGJpbmRQYXJ0cyA9IG5hbWUubWF0Y2goQklORF9OQU1FX1JFR0VYUCk7XG4gICAgICAgICAgdmFyIGhhc0JpbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgICBpZiAoYmluZFBhcnRzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGhhc0JpbmRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KGJpbmRQYXJ0c1tLV19CSU5EX0lEWF0pKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZVByb3BlcnR5T3JBbmltYXRpb24oYmluZFBhcnRzW0lERU5UX0tXX0lEWF0sIHZhbHVlLCBzcmNTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMsIHRhcmdldEFuaW1hdGlvblByb3BzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmIChiaW5kUGFydHNbS1dfTEVUX0lEWF0pIHtcbiAgICAgICAgICAgICAgICAgIGlmIChpc1RlbXBsYXRlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBpZGVudGlmaWVyID0gYmluZFBhcnRzW0lERU5UX0tXX0lEWF07XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VWYXJpYWJsZShpZGVudGlmaWVyLCB2YWx1ZSwgc3JjU3BhbiwgdGFyZ2V0VmFycyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIlxcXCJsZXQtXFxcIiBpcyBvbmx5IHN1cHBvcnRlZCBvbiB0ZW1wbGF0ZSBlbGVtZW50cy5cIiwgc3JjU3Bhbik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAoYmluZFBhcnRzW0tXX1JFRl9JRFhdKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgaWRlbnRpZmllciA9IGJpbmRQYXJ0c1tJREVOVF9LV19JRFhdO1xuICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VSZWZlcmVuY2UoaWRlbnRpZmllciwgdmFsdWUsIHNyY1NwYW4sIHRhcmdldFJlZnMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKGJpbmRQYXJ0c1tLV19PTl9JRFhdKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZUV2ZW50T3JBbmltYXRpb25FdmVudChiaW5kUGFydHNbSURFTlRfS1dfSURYXSwgdmFsdWUsIHNyY1NwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRFdmVudHMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKGJpbmRQYXJ0c1tLV19CSU5ET05fSURYXSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VQcm9wZXJ0eU9yQW5pbWF0aW9uKGJpbmRQYXJ0c1tJREVOVF9LV19JRFhdLCB2YWx1ZSwgc3JjU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzLCB0YXJnZXRBbmltYXRpb25Qcm9wcyk7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZUFzc2lnbm1lbnRFdmVudChiaW5kUGFydHNbSURFTlRfS1dfSURYXSwgdmFsdWUsIHNyY1NwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRFdmVudHMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKGJpbmRQYXJ0c1tLV19BVF9JRFhdKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoX2lzQW5pbWF0aW9uTGFiZWwobmFtZSkgJiYgaXNQcmVzZW50KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCJBc3NpZ25pbmcgYW5pbWF0aW9uIHRyaWdnZXJzIHZpYSBAcHJvcD1cXFwiZXhwXFxcIiBhdHRyaWJ1dGVzIHdpdGggYW4gZXhwcmVzc2lvbiBpcyBpbnZhbGlkLlwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgVXNlIHByb3BlcnR5IGJpbmRpbmdzIChlLmcuIFtAcHJvcF09XFxcImV4cFxcXCIpIG9yIHVzZSBhbiBhdHRyaWJ1dGUgd2l0aG91dCBhIHZhbHVlIChlLmcuIEBwcm9wKSBpbnN0ZWFkLlwiLCBzcmNTcGFuLCBleHBvcnRzLlBhcnNlRXJyb3JMZXZlbC5GQVRBTCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZUFuaW1hdGlvbihiaW5kUGFydHNbSURFTlRfS1dfSURYXSwgdmFsdWUsIHNyY1NwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRBbmltYXRpb25Qcm9wcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAoYmluZFBhcnRzW0lERU5UX0JBTkFOQV9CT1hfSURYXSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VQcm9wZXJ0eU9yQW5pbWF0aW9uKGJpbmRQYXJ0c1tJREVOVF9CQU5BTkFfQk9YX0lEWF0sIHZhbHVlLCBzcmNTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMsIHRhcmdldEFuaW1hdGlvblByb3BzKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlQXNzaWdubWVudEV2ZW50KGJpbmRQYXJ0c1tJREVOVF9CQU5BTkFfQk9YX0lEWF0sIHZhbHVlLCBzcmNTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0RXZlbnRzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmIChiaW5kUGFydHNbSURFTlRfUFJPUEVSVFlfSURYXSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VQcm9wZXJ0eU9yQW5pbWF0aW9uKGJpbmRQYXJ0c1tJREVOVF9QUk9QRVJUWV9JRFhdLCB2YWx1ZSwgc3JjU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzLCB0YXJnZXRBbmltYXRpb25Qcm9wcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAoYmluZFBhcnRzW0lERU5UX0VWRU5UX0lEWF0pIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlRXZlbnRPckFuaW1hdGlvbkV2ZW50KGJpbmRQYXJ0c1tJREVOVF9FVkVOVF9JRFhdLCB2YWx1ZSwgc3JjU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldEV2ZW50cyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGhhc0JpbmRpbmcgPVxuICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VQcm9wZXJ0eUludGVycG9sYXRpb24obmFtZSwgdmFsdWUsIHNyY1NwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaGFzQmluZGluZykge1xuICAgICAgICAgICAgICB0aGlzLl9wYXJzZUxpdGVyYWxBdHRyKG5hbWUsIHZhbHVlLCBzcmNTcGFuLCB0YXJnZXRQcm9wcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBoYXNCaW5kaW5nO1xuICAgICAgfTtcbiAgICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fbm9ybWFsaXplQXR0cmlidXRlTmFtZSA9IGZ1bmN0aW9uIChhdHRyTmFtZSkge1xuICAgICAgICAgIHJldHVybiAvXmRhdGEtL2kudGVzdChhdHRyTmFtZSkgPyBhdHRyTmFtZS5zdWJzdHJpbmcoNSkgOiBhdHRyTmFtZTtcbiAgICAgIH07XG4gICAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX3BhcnNlVmFyaWFibGUgPSBmdW5jdGlvbiAoaWRlbnRpZmllciwgdmFsdWUsIHNvdXJjZVNwYW4sIHRhcmdldFZhcnMpIHtcbiAgICAgICAgICBpZiAoaWRlbnRpZmllci5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIlxcXCItXFxcIiBpcyBub3QgYWxsb3dlZCBpbiB2YXJpYWJsZSBuYW1lc1wiLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGFyZ2V0VmFycy5wdXNoKG5ldyBWYXJpYWJsZUFzdChpZGVudGlmaWVyLCB2YWx1ZSwgc291cmNlU3BhbikpO1xuICAgICAgfTtcbiAgICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fcGFyc2VSZWZlcmVuY2UgPSBmdW5jdGlvbiAoaWRlbnRpZmllciwgdmFsdWUsIHNvdXJjZVNwYW4sIHRhcmdldFJlZnMpIHtcbiAgICAgICAgICBpZiAoaWRlbnRpZmllci5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIlxcXCItXFxcIiBpcyBub3QgYWxsb3dlZCBpbiByZWZlcmVuY2UgbmFtZXNcIiwgc291cmNlU3Bhbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRhcmdldFJlZnMucHVzaChuZXcgRWxlbWVudE9yRGlyZWN0aXZlUmVmKGlkZW50aWZpZXIsIHZhbHVlLCBzb3VyY2VTcGFuKSk7XG4gICAgICB9O1xuICAgICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9wYXJzZVByb3BlcnR5T3JBbmltYXRpb24gPSBmdW5jdGlvbiAobmFtZSwgZXhwcmVzc2lvbiwgc291cmNlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzLCB0YXJnZXRBbmltYXRpb25Qcm9wcykge1xuICAgICAgICAgIHZhciBhbmltYXRlUHJvcExlbmd0aCA9IEFOSU1BVEVfUFJPUF9QUkVGSVgubGVuZ3RoO1xuICAgICAgICAgIHZhciBpc0FuaW1hdGlvblByb3AgPSBfaXNBbmltYXRpb25MYWJlbChuYW1lKTtcbiAgICAgICAgICB2YXIgYW5pbWF0aW9uUHJlZml4TGVuZ3RoID0gMTtcbiAgICAgICAgICBpZiAobmFtZS5zdWJzdHJpbmcoMCwgYW5pbWF0ZVByb3BMZW5ndGgpID09IEFOSU1BVEVfUFJPUF9QUkVGSVgpIHtcbiAgICAgICAgICAgICAgaXNBbmltYXRpb25Qcm9wID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYW5pbWF0aW9uUHJlZml4TGVuZ3RoID0gYW5pbWF0ZVByb3BMZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0FuaW1hdGlvblByb3ApIHtcbiAgICAgICAgICAgICAgdGhpcy5fcGFyc2VBbmltYXRpb24obmFtZS5zdWJzdHIoYW5pbWF0aW9uUHJlZml4TGVuZ3RoKSwgZXhwcmVzc2lvbiwgc291cmNlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldEFuaW1hdGlvblByb3BzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuX3BhcnNlUHJvcGVydHlBc3QobmFtZSwgdGhpcy5fcGFyc2VCaW5kaW5nKGV4cHJlc3Npb24sIHNvdXJjZVNwYW4pLCBzb3VyY2VTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX3BhcnNlQW5pbWF0aW9uID0gZnVuY3Rpb24gKG5hbWUsIGV4cHJlc3Npb24sIHNvdXJjZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRBbmltYXRpb25Qcm9wcykge1xuICAgICAgICAgIC8vIFRoaXMgd2lsbCBvY2N1ciB3aGVuIGEgQHRyaWdnZXIgaXMgbm90IHBhaXJlZCB3aXRoIGFuIGV4cHJlc3Npb24uXG4gICAgICAgICAgLy8gRm9yIGFuaW1hdGlvbnMgaXQgaXMgdmFsaWQgdG8gbm90IGhhdmUgYW4gZXhwcmVzc2lvbiBzaW5jZSAqL3ZvaWRcbiAgICAgICAgICAvLyBzdGF0ZXMgd2lsbCBiZSBhcHBsaWVkIGJ5IGFuZ3VsYXIgd2hlbiB0aGUgZWxlbWVudCBpcyBhdHRhY2hlZC9kZXRhY2hlZFxuICAgICAgICAgIGlmICghaXNQcmVzZW50KGV4cHJlc3Npb24pIHx8IGV4cHJlc3Npb24ubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgZXhwcmVzc2lvbiA9ICdudWxsJztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGFzdCA9IHRoaXMuX3BhcnNlQmluZGluZyhleHByZXNzaW9uLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICB0YXJnZXRNYXRjaGFibGVBdHRycy5wdXNoKFtuYW1lLCBhc3Quc291cmNlXSk7XG4gICAgICAgICAgdGFyZ2V0QW5pbWF0aW9uUHJvcHMucHVzaChuZXcgQm91bmRFbGVtZW50UHJvcGVydHlBc3QobmFtZSwgZXhwb3J0cy5Qcm9wZXJ0eUJpbmRpbmdUeXBlLkFuaW1hdGlvbiwgX2FuZ3VsYXJfY29yZS5TZWN1cml0eUNvbnRleHQuTk9ORSwgYXN0LCBudWxsLCBzb3VyY2VTcGFuKSk7XG4gICAgICB9O1xuICAgICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9wYXJzZVByb3BlcnR5SW50ZXJwb2xhdGlvbiA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgc291cmNlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKSB7XG4gICAgICAgICAgdmFyIGV4cHIgPSB0aGlzLl9wYXJzZUludGVycG9sYXRpb24odmFsdWUsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgIGlmIChpc1ByZXNlbnQoZXhwcikpIHtcbiAgICAgICAgICAgICAgdGhpcy5fcGFyc2VQcm9wZXJ0eUFzdChuYW1lLCBleHByLCBzb3VyY2VTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpO1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcbiAgICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fcGFyc2VQcm9wZXJ0eUFzdCA9IGZ1bmN0aW9uIChuYW1lLCBhc3QsIHNvdXJjZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcykge1xuICAgICAgICAgIHRhcmdldE1hdGNoYWJsZUF0dHJzLnB1c2goW25hbWUsIGFzdC5zb3VyY2VdKTtcbiAgICAgICAgICB0YXJnZXRQcm9wcy5wdXNoKG5ldyBCb3VuZEVsZW1lbnRPckRpcmVjdGl2ZVByb3BlcnR5KG5hbWUsIGFzdCwgZmFsc2UsIHNvdXJjZVNwYW4pKTtcbiAgICAgIH07XG4gICAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX3BhcnNlQXNzaWdubWVudEV2ZW50ID0gZnVuY3Rpb24gKG5hbWUsIGV4cHJlc3Npb24sIHNvdXJjZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRFdmVudHMpIHtcbiAgICAgICAgICB0aGlzLl9wYXJzZUV2ZW50T3JBbmltYXRpb25FdmVudChuYW1lICsgXCJDaGFuZ2VcIiwgZXhwcmVzc2lvbiArIFwiPSRldmVudFwiLCBzb3VyY2VTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0RXZlbnRzKTtcbiAgICAgIH07XG4gICAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX3BhcnNlRXZlbnRPckFuaW1hdGlvbkV2ZW50ID0gZnVuY3Rpb24gKG5hbWUsIGV4cHJlc3Npb24sIHNvdXJjZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRFdmVudHMpIHtcbiAgICAgICAgICBpZiAoX2lzQW5pbWF0aW9uTGFiZWwobmFtZSkpIHtcbiAgICAgICAgICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEpO1xuICAgICAgICAgICAgICB0aGlzLl9wYXJzZUFuaW1hdGlvbkV2ZW50KG5hbWUsIGV4cHJlc3Npb24sIHNvdXJjZVNwYW4sIHRhcmdldEV2ZW50cyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLl9wYXJzZUV2ZW50KG5hbWUsIGV4cHJlc3Npb24sIHNvdXJjZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRFdmVudHMpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX3BhcnNlQW5pbWF0aW9uRXZlbnQgPSBmdW5jdGlvbiAobmFtZSwgZXhwcmVzc2lvbiwgc291cmNlU3BhbiwgdGFyZ2V0RXZlbnRzKSB7XG4gICAgICAgICAgdmFyIG1hdGNoZXMgPSBzcGxpdEF0UGVyaW9kKG5hbWUsIFtuYW1lLCAnJ10pO1xuICAgICAgICAgIHZhciBldmVudE5hbWUgPSBtYXRjaGVzWzBdO1xuICAgICAgICAgIHZhciBwaGFzZSA9IG1hdGNoZXNbMV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBpZiAocGhhc2UpIHtcbiAgICAgICAgICAgICAgc3dpdGNoIChwaGFzZSkge1xuICAgICAgICAgICAgICAgICAgY2FzZSAnc3RhcnQnOlxuICAgICAgICAgICAgICAgICAgY2FzZSAnZG9uZSc6XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGFzdCA9IHRoaXMuX3BhcnNlQWN0aW9uKGV4cHJlc3Npb24sIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEV2ZW50cy5wdXNoKG5ldyBCb3VuZEV2ZW50QXN0KGV2ZW50TmFtZSwgbnVsbCwgcGhhc2UsIGFzdCwgc291cmNlU3BhbikpO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIlRoZSBwcm92aWRlZCBhbmltYXRpb24gb3V0cHV0IHBoYXNlIHZhbHVlIFxcXCJcIiArIHBoYXNlICsgXCJcXFwiIGZvciBcXFwiQFwiICsgZXZlbnROYW1lICsgXCJcXFwiIGlzIG5vdCBzdXBwb3J0ZWQgKHVzZSBzdGFydCBvciBkb25lKVwiLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCJUaGUgYW5pbWF0aW9uIHRyaWdnZXIgb3V0cHV0IGV2ZW50IChAXCIgKyBldmVudE5hbWUgKyBcIikgaXMgbWlzc2luZyBpdHMgcGhhc2UgdmFsdWUgbmFtZSAoc3RhcnQgb3IgZG9uZSBhcmUgY3VycmVudGx5IHN1cHBvcnRlZClcIiwgc291cmNlU3Bhbik7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fcGFyc2VFdmVudCA9IGZ1bmN0aW9uIChuYW1lLCBleHByZXNzaW9uLCBzb3VyY2VTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0RXZlbnRzKSB7XG4gICAgICAgICAgLy8gbG9uZyBmb3JtYXQ6ICd0YXJnZXQ6IGV2ZW50TmFtZSdcbiAgICAgICAgICB2YXIgX2EgPSBzcGxpdEF0Q29sb24obmFtZSwgW251bGwsIG5hbWVdKSwgdGFyZ2V0ID0gX2FbMF0sIGV2ZW50TmFtZSA9IF9hWzFdO1xuICAgICAgICAgIHZhciBhc3QgPSB0aGlzLl9wYXJzZUFjdGlvbihleHByZXNzaW9uLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICB0YXJnZXRNYXRjaGFibGVBdHRycy5wdXNoKFtuYW1lLCBhc3Quc291cmNlXSk7XG4gICAgICAgICAgdGFyZ2V0RXZlbnRzLnB1c2gobmV3IEJvdW5kRXZlbnRBc3QoZXZlbnROYW1lLCB0YXJnZXQsIG51bGwsIGFzdCwgc291cmNlU3BhbikpO1xuICAgICAgICAgIC8vIERvbid0IGRldGVjdCBkaXJlY3RpdmVzIGZvciBldmVudCBuYW1lcyBmb3Igbm93LFxuICAgICAgICAgIC8vIHNvIGRvbid0IGFkZCB0aGUgZXZlbnQgbmFtZSB0byB0aGUgbWF0Y2hhYmxlQXR0cnNcbiAgICAgIH07XG4gICAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX3BhcnNlTGl0ZXJhbEF0dHIgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIHNvdXJjZVNwYW4sIHRhcmdldFByb3BzKSB7XG4gICAgICAgICAgdGFyZ2V0UHJvcHMucHVzaChuZXcgQm91bmRFbGVtZW50T3JEaXJlY3RpdmVQcm9wZXJ0eShuYW1lLCB0aGlzLl9leHByUGFyc2VyLndyYXBMaXRlcmFsUHJpbWl0aXZlKHZhbHVlLCAnJyksIHRydWUsIHNvdXJjZVNwYW4pKTtcbiAgICAgIH07XG4gICAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX3BhcnNlRGlyZWN0aXZlcyA9IGZ1bmN0aW9uIChzZWxlY3Rvck1hdGNoZXIsIGVsZW1lbnRDc3NTZWxlY3Rvcikge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgLy8gTmVlZCB0byBzb3J0IHRoZSBkaXJlY3RpdmVzIHNvIHRoYXQgd2UgZ2V0IGNvbnNpc3RlbnQgcmVzdWx0cyB0aHJvdWdob3V0LFxuICAgICAgICAgIC8vIGFzIHNlbGVjdG9yTWF0Y2hlciB1c2VzIE1hcHMgaW5zaWRlLlxuICAgICAgICAgIC8vIEFsc28gZGVkdXBsaWNhdGUgZGlyZWN0aXZlcyBhcyB0aGV5IG1pZ2h0IG1hdGNoIG1vcmUgdGhhbiBvbmUgdGltZSFcbiAgICAgICAgICB2YXIgZGlyZWN0aXZlcyA9IG5ldyBBcnJheSh0aGlzLmRpcmVjdGl2ZXNJbmRleC5zaXplKTtcbiAgICAgICAgICAvLyBXaGV0aGVyIGFueSBkaXJlY3RpdmUgc2VsZWN0b3IgbWF0Y2hlcyBvbiB0aGUgZWxlbWVudCBuYW1lXG4gICAgICAgICAgdmFyIG1hdGNoRWxlbWVudCA9IGZhbHNlO1xuICAgICAgICAgIHNlbGVjdG9yTWF0Y2hlci5tYXRjaChlbGVtZW50Q3NzU2VsZWN0b3IsIGZ1bmN0aW9uIChzZWxlY3RvciwgZGlyZWN0aXZlKSB7XG4gICAgICAgICAgICAgIGRpcmVjdGl2ZXNbX3RoaXMuZGlyZWN0aXZlc0luZGV4LmdldChkaXJlY3RpdmUpXSA9IGRpcmVjdGl2ZTtcbiAgICAgICAgICAgICAgbWF0Y2hFbGVtZW50ID0gbWF0Y2hFbGVtZW50IHx8IHNlbGVjdG9yLmhhc0VsZW1lbnRTZWxlY3RvcigpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGRpcmVjdGl2ZXM6IGRpcmVjdGl2ZXMuZmlsdGVyKGZ1bmN0aW9uIChkaXIpIHsgcmV0dXJuICEhZGlyOyB9KSxcbiAgICAgICAgICAgICAgbWF0Y2hFbGVtZW50OiBtYXRjaEVsZW1lbnQsXG4gICAgICAgICAgfTtcbiAgICAgIH07XG4gICAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX2NyZWF0ZURpcmVjdGl2ZUFzdHMgPSBmdW5jdGlvbiAoaXNUZW1wbGF0ZUVsZW1lbnQsIGVsZW1lbnROYW1lLCBkaXJlY3RpdmVzLCBwcm9wcywgZWxlbWVudE9yRGlyZWN0aXZlUmVmcywgZWxlbWVudFNvdXJjZVNwYW4sIHRhcmdldFJlZmVyZW5jZXMpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBtYXRjaGVkUmVmZXJlbmNlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICB2YXIgY29tcG9uZW50ID0gbnVsbDtcbiAgICAgICAgICB2YXIgZGlyZWN0aXZlQXN0cyA9IGRpcmVjdGl2ZXMubWFwKGZ1bmN0aW9uIChkaXJlY3RpdmUpIHtcbiAgICAgICAgICAgICAgdmFyIHNvdXJjZVNwYW4gPSBuZXcgUGFyc2VTb3VyY2VTcGFuKGVsZW1lbnRTb3VyY2VTcGFuLnN0YXJ0LCBlbGVtZW50U291cmNlU3Bhbi5lbmQsIFwiRGlyZWN0aXZlIFwiICsgZGlyZWN0aXZlLnR5cGUubmFtZSk7XG4gICAgICAgICAgICAgIGlmIChkaXJlY3RpdmUuaXNDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgIGNvbXBvbmVudCA9IGRpcmVjdGl2ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgaG9zdFByb3BlcnRpZXMgPSBbXTtcbiAgICAgICAgICAgICAgdmFyIGhvc3RFdmVudHMgPSBbXTtcbiAgICAgICAgICAgICAgdmFyIGRpcmVjdGl2ZVByb3BlcnRpZXMgPSBbXTtcbiAgICAgICAgICAgICAgX3RoaXMuX2NyZWF0ZURpcmVjdGl2ZUhvc3RQcm9wZXJ0eUFzdHMoZWxlbWVudE5hbWUsIGRpcmVjdGl2ZS5ob3N0UHJvcGVydGllcywgc291cmNlU3BhbiwgaG9zdFByb3BlcnRpZXMpO1xuICAgICAgICAgICAgICBfdGhpcy5fY3JlYXRlRGlyZWN0aXZlSG9zdEV2ZW50QXN0cyhkaXJlY3RpdmUuaG9zdExpc3RlbmVycywgc291cmNlU3BhbiwgaG9zdEV2ZW50cyk7XG4gICAgICAgICAgICAgIF90aGlzLl9jcmVhdGVEaXJlY3RpdmVQcm9wZXJ0eUFzdHMoZGlyZWN0aXZlLmlucHV0cywgcHJvcHMsIGRpcmVjdGl2ZVByb3BlcnRpZXMpO1xuICAgICAgICAgICAgICBlbGVtZW50T3JEaXJlY3RpdmVSZWZzLmZvckVhY2goZnVuY3Rpb24gKGVsT3JEaXJSZWYpIHtcbiAgICAgICAgICAgICAgICAgIGlmICgoZWxPckRpclJlZi52YWx1ZS5sZW5ndGggPT09IDAgJiYgZGlyZWN0aXZlLmlzQ29tcG9uZW50KSB8fFxuICAgICAgICAgICAgICAgICAgICAgIChkaXJlY3RpdmUuZXhwb3J0QXMgPT0gZWxPckRpclJlZi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRSZWZlcmVuY2VzLnB1c2gobmV3IFJlZmVyZW5jZUFzdChlbE9yRGlyUmVmLm5hbWUsIGlkZW50aWZpZXJUb2tlbihkaXJlY3RpdmUudHlwZSksIGVsT3JEaXJSZWYuc291cmNlU3BhbikpO1xuICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWRSZWZlcmVuY2VzLmFkZChlbE9yRGlyUmVmLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEaXJlY3RpdmVBc3QoZGlyZWN0aXZlLCBkaXJlY3RpdmVQcm9wZXJ0aWVzLCBob3N0UHJvcGVydGllcywgaG9zdEV2ZW50cywgc291cmNlU3Bhbik7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZWxlbWVudE9yRGlyZWN0aXZlUmVmcy5mb3JFYWNoKGZ1bmN0aW9uIChlbE9yRGlyUmVmKSB7XG4gICAgICAgICAgICAgIGlmIChlbE9yRGlyUmVmLnZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIGlmICghbWF0Y2hlZFJlZmVyZW5jZXMuaGFzKGVsT3JEaXJSZWYubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVwb3J0RXJyb3IoXCJUaGVyZSBpcyBubyBkaXJlY3RpdmUgd2l0aCBcXFwiZXhwb3J0QXNcXFwiIHNldCB0byBcXFwiXCIgKyBlbE9yRGlyUmVmLnZhbHVlICsgXCJcXFwiXCIsIGVsT3JEaXJSZWYuc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAoIWNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgdmFyIHJlZlRva2VuID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIGlmIChpc1RlbXBsYXRlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJlZlRva2VuID0gcmVzb2x2ZUlkZW50aWZpZXJUb2tlbihJZGVudGlmaWVycy5UZW1wbGF0ZVJlZik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB0YXJnZXRSZWZlcmVuY2VzLnB1c2gobmV3IFJlZmVyZW5jZUFzdChlbE9yRGlyUmVmLm5hbWUsIHJlZlRva2VuLCBlbE9yRGlyUmVmLnNvdXJjZVNwYW4pKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0pOyAvLyBmaXggc3ludGF4IGhpZ2hsaWdodGluZyBpc3N1ZTogYFxuICAgICAgICAgIHJldHVybiBkaXJlY3RpdmVBc3RzO1xuICAgICAgfTtcbiAgICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fY3JlYXRlRGlyZWN0aXZlSG9zdFByb3BlcnR5QXN0cyA9IGZ1bmN0aW9uIChlbGVtZW50TmFtZSwgaG9zdFByb3BzLCBzb3VyY2VTcGFuLCB0YXJnZXRQcm9wZXJ0eUFzdHMpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIGlmIChob3N0UHJvcHMpIHtcbiAgICAgICAgICAgICAgT2JqZWN0LmtleXMoaG9zdFByb3BzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICAgICAgICAgICAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBob3N0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBleHByZXNzaW9uID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBleHByQXN0ID0gX3RoaXMuX3BhcnNlQmluZGluZyhleHByZXNzaW9uLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRQcm9wZXJ0eUFzdHMucHVzaChfdGhpcy5fY3JlYXRlRWxlbWVudFByb3BlcnR5QXN0KGVsZW1lbnROYW1lLCBwcm9wTmFtZSwgZXhwckFzdCwgc291cmNlU3BhbikpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlcG9ydEVycm9yKFwiVmFsdWUgb2YgdGhlIGhvc3QgcHJvcGVydHkgYmluZGluZyBcXFwiXCIgKyBwcm9wTmFtZSArIFwiXFxcIiBuZWVkcyB0byBiZSBhIHN0cmluZyByZXByZXNlbnRpbmcgYW4gZXhwcmVzc2lvbiBidXQgZ290IFxcXCJcIiArIGV4cHJlc3Npb24gKyBcIlxcXCIgKFwiICsgdHlwZW9mIGV4cHJlc3Npb24gKyBcIilcIiwgc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX2NyZWF0ZURpcmVjdGl2ZUhvc3RFdmVudEFzdHMgPSBmdW5jdGlvbiAoaG9zdExpc3RlbmVycywgc291cmNlU3BhbiwgdGFyZ2V0RXZlbnRBc3RzKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICBpZiAoaG9zdExpc3RlbmVycykge1xuICAgICAgICAgICAgICBPYmplY3Qua2V5cyhob3N0TGlzdGVuZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICAgICAgICAgICAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBob3N0TGlzdGVuZXJzW3Byb3BOYW1lXTtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZXhwcmVzc2lvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcGFyc2VFdmVudE9yQW5pbWF0aW9uRXZlbnQocHJvcE5hbWUsIGV4cHJlc3Npb24sIHNvdXJjZVNwYW4sIFtdLCB0YXJnZXRFdmVudEFzdHMpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlcG9ydEVycm9yKFwiVmFsdWUgb2YgdGhlIGhvc3QgbGlzdGVuZXIgXFxcIlwiICsgcHJvcE5hbWUgKyBcIlxcXCIgbmVlZHMgdG8gYmUgYSBzdHJpbmcgcmVwcmVzZW50aW5nIGFuIGV4cHJlc3Npb24gYnV0IGdvdCBcXFwiXCIgKyBleHByZXNzaW9uICsgXCJcXFwiIChcIiArIHR5cGVvZiBleHByZXNzaW9uICsgXCIpXCIsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9jcmVhdGVEaXJlY3RpdmVQcm9wZXJ0eUFzdHMgPSBmdW5jdGlvbiAoZGlyZWN0aXZlUHJvcGVydGllcywgYm91bmRQcm9wcywgdGFyZ2V0Qm91bmREaXJlY3RpdmVQcm9wcykge1xuICAgICAgICAgIGlmIChkaXJlY3RpdmVQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgIHZhciBib3VuZFByb3BzQnlOYW1lXzEgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgIGJvdW5kUHJvcHMuZm9yRWFjaChmdW5jdGlvbiAoYm91bmRQcm9wKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcHJldlZhbHVlID0gYm91bmRQcm9wc0J5TmFtZV8xLmdldChib3VuZFByb3AubmFtZSk7XG4gICAgICAgICAgICAgICAgICBpZiAoIXByZXZWYWx1ZSB8fCBwcmV2VmFsdWUuaXNMaXRlcmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gZ2l2ZSBbYV09XCJiXCIgYSBoaWdoZXIgcHJlY2VkZW5jZSB0aGFuIGE9XCJiXCIgb24gdGhlIHNhbWUgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgIGJvdW5kUHJvcHNCeU5hbWVfMS5zZXQoYm91bmRQcm9wLm5hbWUsIGJvdW5kUHJvcCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBPYmplY3Qua2V5cyhkaXJlY3RpdmVQcm9wZXJ0aWVzKS5mb3JFYWNoKGZ1bmN0aW9uIChkaXJQcm9wKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZWxQcm9wID0gZGlyZWN0aXZlUHJvcGVydGllc1tkaXJQcm9wXTtcbiAgICAgICAgICAgICAgICAgIHZhciBib3VuZFByb3AgPSBib3VuZFByb3BzQnlOYW1lXzEuZ2V0KGVsUHJvcCk7XG4gICAgICAgICAgICAgICAgICAvLyBCaW5kaW5ncyBhcmUgb3B0aW9uYWwsIHNvIHRoaXMgYmluZGluZyBvbmx5IG5lZWRzIHRvIGJlIHNldCB1cCBpZiBhbiBleHByZXNzaW9uIGlzIGdpdmVuLlxuICAgICAgICAgICAgICAgICAgaWYgKGJvdW5kUHJvcCkge1xuICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEJvdW5kRGlyZWN0aXZlUHJvcHMucHVzaChuZXcgQm91bmREaXJlY3RpdmVQcm9wZXJ0eUFzdChkaXJQcm9wLCBib3VuZFByb3AubmFtZSwgYm91bmRQcm9wLmV4cHJlc3Npb24sIGJvdW5kUHJvcC5zb3VyY2VTcGFuKSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX2NyZWF0ZUVsZW1lbnRQcm9wZXJ0eUFzdHMgPSBmdW5jdGlvbiAoZWxlbWVudE5hbWUsIHByb3BzLCBkaXJlY3RpdmVzKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgYm91bmRFbGVtZW50UHJvcHMgPSBbXTtcbiAgICAgICAgICB2YXIgYm91bmREaXJlY3RpdmVQcm9wc0luZGV4ID0gbmV3IE1hcCgpO1xuICAgICAgICAgIGRpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlyZWN0aXZlKSB7XG4gICAgICAgICAgICAgIGRpcmVjdGl2ZS5pbnB1dHMuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgICAgICAgYm91bmREaXJlY3RpdmVQcm9wc0luZGV4LnNldChwcm9wLnRlbXBsYXRlTmFtZSwgcHJvcCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHByb3BzLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgICAgaWYgKCFwcm9wLmlzTGl0ZXJhbCAmJiAhYm91bmREaXJlY3RpdmVQcm9wc0luZGV4LmdldChwcm9wLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICBib3VuZEVsZW1lbnRQcm9wcy5wdXNoKF90aGlzLl9jcmVhdGVFbGVtZW50UHJvcGVydHlBc3QoZWxlbWVudE5hbWUsIHByb3AubmFtZSwgcHJvcC5leHByZXNzaW9uLCBwcm9wLnNvdXJjZVNwYW4pKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBib3VuZEVsZW1lbnRQcm9wcztcbiAgICAgIH07XG4gICAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX2NyZWF0ZUVsZW1lbnRQcm9wZXJ0eUFzdCA9IGZ1bmN0aW9uIChlbGVtZW50TmFtZSwgbmFtZSwgYXN0LCBzb3VyY2VTcGFuKSB7XG4gICAgICAgICAgdmFyIHVuaXQgPSBudWxsO1xuICAgICAgICAgIHZhciBiaW5kaW5nVHlwZTtcbiAgICAgICAgICB2YXIgYm91bmRQcm9wZXJ0eU5hbWU7XG4gICAgICAgICAgdmFyIHBhcnRzID0gbmFtZS5zcGxpdChQUk9QRVJUWV9QQVJUU19TRVBBUkFUT1IpO1xuICAgICAgICAgIHZhciBzZWN1cml0eUNvbnRleHQ7XG4gICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICB2YXIgcGFydFZhbHVlID0gcGFydHNbMF07XG4gICAgICAgICAgICAgIGlmIChfaXNBbmltYXRpb25MYWJlbChwYXJ0VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICBib3VuZFByb3BlcnR5TmFtZSA9IHBhcnRWYWx1ZS5zdWJzdHIoMSk7XG4gICAgICAgICAgICAgICAgICBiaW5kaW5nVHlwZSA9IGV4cG9ydHMuUHJvcGVydHlCaW5kaW5nVHlwZS5BbmltYXRpb247XG4gICAgICAgICAgICAgICAgICBzZWN1cml0eUNvbnRleHQgPSBfYW5ndWxhcl9jb3JlLlNlY3VyaXR5Q29udGV4dC5OT05FO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgYm91bmRQcm9wZXJ0eU5hbWUgPSB0aGlzLl9zY2hlbWFSZWdpc3RyeS5nZXRNYXBwZWRQcm9wTmFtZShwYXJ0VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgc2VjdXJpdHlDb250ZXh0ID0gdGhpcy5fc2NoZW1hUmVnaXN0cnkuc2VjdXJpdHlDb250ZXh0KGVsZW1lbnROYW1lLCBib3VuZFByb3BlcnR5TmFtZSk7XG4gICAgICAgICAgICAgICAgICBiaW5kaW5nVHlwZSA9IGV4cG9ydHMuUHJvcGVydHlCaW5kaW5nVHlwZS5Qcm9wZXJ0eTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbGlkYXRlUHJvcGVydHlPckF0dHJpYnV0ZU5hbWUoYm91bmRQcm9wZXJ0eU5hbWUsIHNvdXJjZVNwYW4sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fc2NoZW1hUmVnaXN0cnkuaGFzUHJvcGVydHkoZWxlbWVudE5hbWUsIGJvdW5kUHJvcGVydHlOYW1lLCB0aGlzLl9zY2hlbWFzKSkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnJvck1zZyA9IFwiQ2FuJ3QgYmluZCB0byAnXCIgKyBib3VuZFByb3BlcnR5TmFtZSArIFwiJyBzaW5jZSBpdCBpc24ndCBhIGtub3duIHByb3BlcnR5IG9mICdcIiArIGVsZW1lbnROYW1lICsgXCInLlwiO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50TmFtZS5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvck1zZyArPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwiXFxuMS4gSWYgJ1wiICsgZWxlbWVudE5hbWUgKyBcIicgaXMgYW4gQW5ndWxhciBjb21wb25lbnQgYW5kIGl0IGhhcyAnXCIgKyBib3VuZFByb3BlcnR5TmFtZSArIFwiJyBpbnB1dCwgdGhlbiB2ZXJpZnkgdGhhdCBpdCBpcyBwYXJ0IG9mIHRoaXMgbW9kdWxlLlwiKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwiXFxuMi4gSWYgJ1wiICsgZWxlbWVudE5hbWUgKyBcIicgaXMgYSBXZWIgQ29tcG9uZW50IHRoZW4gYWRkIFxcXCJDVVNUT01fRUxFTUVOVFNfU0NIRU1BXFxcIiB0byB0aGUgJ0BOZ01vZHVsZS5zY2hlbWFzJyBvZiB0aGlzIGNvbXBvbmVudCB0byBzdXBwcmVzcyB0aGlzIG1lc3NhZ2UuXFxuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihlcnJvck1zZywgc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChwYXJ0c1swXSA9PSBBVFRSSUJVVEVfUFJFRklYKSB7XG4gICAgICAgICAgICAgICAgICBib3VuZFByb3BlcnR5TmFtZSA9IHBhcnRzWzFdO1xuICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsaWRhdGVQcm9wZXJ0eU9yQXR0cmlidXRlTmFtZShib3VuZFByb3BlcnR5TmFtZSwgc291cmNlU3BhbiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAvLyBOQjogRm9yIHNlY3VyaXR5IHB1cnBvc2VzLCB1c2UgdGhlIG1hcHBlZCBwcm9wZXJ0eSBuYW1lLCBub3QgdGhlIGF0dHJpYnV0ZSBuYW1lLlxuICAgICAgICAgICAgICAgICAgdmFyIG1hcFByb3BOYW1lID0gdGhpcy5fc2NoZW1hUmVnaXN0cnkuZ2V0TWFwcGVkUHJvcE5hbWUoYm91bmRQcm9wZXJ0eU5hbWUpO1xuICAgICAgICAgICAgICAgICAgc2VjdXJpdHlDb250ZXh0ID0gdGhpcy5fc2NoZW1hUmVnaXN0cnkuc2VjdXJpdHlDb250ZXh0KGVsZW1lbnROYW1lLCBtYXBQcm9wTmFtZSk7XG4gICAgICAgICAgICAgICAgICB2YXIgbnNTZXBhcmF0b3JJZHggPSBib3VuZFByb3BlcnR5TmFtZS5pbmRleE9mKCc6Jyk7XG4gICAgICAgICAgICAgICAgICBpZiAobnNTZXBhcmF0b3JJZHggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBucyA9IGJvdW5kUHJvcGVydHlOYW1lLnN1YnN0cmluZygwLCBuc1NlcGFyYXRvcklkeCk7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWVfMSA9IGJvdW5kUHJvcGVydHlOYW1lLnN1YnN0cmluZyhuc1NlcGFyYXRvcklkeCArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgIGJvdW5kUHJvcGVydHlOYW1lID0gbWVyZ2VOc0FuZE5hbWUobnMsIG5hbWVfMSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBiaW5kaW5nVHlwZSA9IGV4cG9ydHMuUHJvcGVydHlCaW5kaW5nVHlwZS5BdHRyaWJ1dGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAocGFydHNbMF0gPT0gQ0xBU1NfUFJFRklYKSB7XG4gICAgICAgICAgICAgICAgICBib3VuZFByb3BlcnR5TmFtZSA9IHBhcnRzWzFdO1xuICAgICAgICAgICAgICAgICAgYmluZGluZ1R5cGUgPSBleHBvcnRzLlByb3BlcnR5QmluZGluZ1R5cGUuQ2xhc3M7XG4gICAgICAgICAgICAgICAgICBzZWN1cml0eUNvbnRleHQgPSBfYW5ndWxhcl9jb3JlLlNlY3VyaXR5Q29udGV4dC5OT05FO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKHBhcnRzWzBdID09IFNUWUxFX1BSRUZJWCkge1xuICAgICAgICAgICAgICAgICAgdW5pdCA9IHBhcnRzLmxlbmd0aCA+IDIgPyBwYXJ0c1syXSA6IG51bGw7XG4gICAgICAgICAgICAgICAgICBib3VuZFByb3BlcnR5TmFtZSA9IHBhcnRzWzFdO1xuICAgICAgICAgICAgICAgICAgYmluZGluZ1R5cGUgPSBleHBvcnRzLlByb3BlcnR5QmluZGluZ1R5cGUuU3R5bGU7XG4gICAgICAgICAgICAgICAgICBzZWN1cml0eUNvbnRleHQgPSBfYW5ndWxhcl9jb3JlLlNlY3VyaXR5Q29udGV4dC5TVFlMRTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKFwiSW52YWxpZCBwcm9wZXJ0eSBuYW1lICdcIiArIG5hbWUgKyBcIidcIiwgc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgICAgICBiaW5kaW5nVHlwZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICBzZWN1cml0eUNvbnRleHQgPSBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgQm91bmRFbGVtZW50UHJvcGVydHlBc3QoYm91bmRQcm9wZXJ0eU5hbWUsIGJpbmRpbmdUeXBlLCBzZWN1cml0eUNvbnRleHQsIGFzdCwgdW5pdCwgc291cmNlU3Bhbik7XG4gICAgICB9O1xuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0gcHJvcE5hbWUgdGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IC8gYXR0cmlidXRlXG4gICAgICAgKiBAcGFyYW0gc291cmNlU3BhblxuICAgICAgICogQHBhcmFtIGlzQXR0ciB0cnVlIHdoZW4gYmluZGluZyB0byBhbiBhdHRyaWJ1dGVcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cbiAgICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fdmFsaWRhdGVQcm9wZXJ0eU9yQXR0cmlidXRlTmFtZSA9IGZ1bmN0aW9uIChwcm9wTmFtZSwgc291cmNlU3BhbiwgaXNBdHRyKSB7XG4gICAgICAgICAgdmFyIHJlcG9ydCA9IGlzQXR0ciA/IHRoaXMuX3NjaGVtYVJlZ2lzdHJ5LnZhbGlkYXRlQXR0cmlidXRlKHByb3BOYW1lKSA6XG4gICAgICAgICAgICAgIHRoaXMuX3NjaGVtYVJlZ2lzdHJ5LnZhbGlkYXRlUHJvcGVydHkocHJvcE5hbWUpO1xuICAgICAgICAgIGlmIChyZXBvcnQuZXJyb3IpIHtcbiAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IocmVwb3J0Lm1zZywgc291cmNlU3BhbiwgZXhwb3J0cy5QYXJzZUVycm9yTGV2ZWwuRkFUQUwpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX2ZpbmRDb21wb25lbnREaXJlY3RpdmVzID0gZnVuY3Rpb24gKGRpcmVjdGl2ZXMpIHtcbiAgICAgICAgICByZXR1cm4gZGlyZWN0aXZlcy5maWx0ZXIoZnVuY3Rpb24gKGRpcmVjdGl2ZSkgeyByZXR1cm4gZGlyZWN0aXZlLmRpcmVjdGl2ZS5pc0NvbXBvbmVudDsgfSk7XG4gICAgICB9O1xuICAgICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9maW5kQ29tcG9uZW50RGlyZWN0aXZlTmFtZXMgPSBmdW5jdGlvbiAoZGlyZWN0aXZlcykge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9maW5kQ29tcG9uZW50RGlyZWN0aXZlcyhkaXJlY3RpdmVzKVxuICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChkaXJlY3RpdmUpIHsgcmV0dXJuIGRpcmVjdGl2ZS5kaXJlY3RpdmUudHlwZS5uYW1lOyB9KTtcbiAgICAgIH07XG4gICAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX2Fzc2VydE9ubHlPbmVDb21wb25lbnQgPSBmdW5jdGlvbiAoZGlyZWN0aXZlcywgc291cmNlU3Bhbikge1xuICAgICAgICAgIHZhciBjb21wb25lbnRUeXBlTmFtZXMgPSB0aGlzLl9maW5kQ29tcG9uZW50RGlyZWN0aXZlTmFtZXMoZGlyZWN0aXZlcyk7XG4gICAgICAgICAgaWYgKGNvbXBvbmVudFR5cGVOYW1lcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKFwiTW9yZSB0aGFuIG9uZSBjb21wb25lbnQ6IFwiICsgY29tcG9uZW50VHlwZU5hbWVzLmpvaW4oJywnKSwgc291cmNlU3Bhbik7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIC8qKlxuICAgICAgICogTWFrZSBzdXJlIHRoYXQgbm9uLWFuZ3VsYXIgdGFncyBjb25mb3JtIHRvIHRoZSBzY2hlbWFzLlxuICAgICAgICpcbiAgICAgICAqIE5vdGU6IEFuIGVsZW1lbnQgaXMgY29uc2lkZXJlZCBhbiBhbmd1bGFyIHRhZyB3aGVuIGF0IGxlYXN0IG9uZSBkaXJlY3RpdmUgc2VsZWN0b3IgbWF0Y2hlcyB0aGVcbiAgICAgICAqIHRhZyBuYW1lLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSBtYXRjaEVsZW1lbnQgV2hldGhlciBhbnkgZGlyZWN0aXZlIGhhcyBtYXRjaGVkIG9uIHRoZSB0YWcgbmFtZVxuICAgICAgICogQHBhcmFtIGVsZW1lbnQgdGhlIGh0bWwgZWxlbWVudFxuICAgICAgICovXG4gICAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX2Fzc2VydEVsZW1lbnRFeGlzdHMgPSBmdW5jdGlvbiAobWF0Y2hFbGVtZW50LCBlbGVtZW50KSB7XG4gICAgICAgICAgdmFyIGVsTmFtZSA9IGVsZW1lbnQubmFtZS5yZXBsYWNlKC9eOnhodG1sOi8sICcnKTtcbiAgICAgICAgICBpZiAoIW1hdGNoRWxlbWVudCAmJiAhdGhpcy5fc2NoZW1hUmVnaXN0cnkuaGFzRWxlbWVudChlbE5hbWUsIHRoaXMuX3NjaGVtYXMpKSB7XG4gICAgICAgICAgICAgIHZhciBlcnJvck1zZyA9IChcIidcIiArIGVsTmFtZSArIFwiJyBpcyBub3QgYSBrbm93biBlbGVtZW50OlxcblwiKSArXG4gICAgICAgICAgICAgICAgICAoXCIxLiBJZiAnXCIgKyBlbE5hbWUgKyBcIicgaXMgYW4gQW5ndWxhciBjb21wb25lbnQsIHRoZW4gdmVyaWZ5IHRoYXQgaXQgaXMgcGFydCBvZiB0aGlzIG1vZHVsZS5cXG5cIikgK1xuICAgICAgICAgICAgICAgICAgKFwiMi4gSWYgJ1wiICsgZWxOYW1lICsgXCInIGlzIGEgV2ViIENvbXBvbmVudCB0aGVuIGFkZCBcXFwiQ1VTVE9NX0VMRU1FTlRTX1NDSEVNQVxcXCIgdG8gdGhlICdATmdNb2R1bGUuc2NoZW1hcycgb2YgdGhpcyBjb21wb25lbnQgdG8gc3VwcHJlc3MgdGhpcyBtZXNzYWdlLlwiKTtcbiAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoZXJyb3JNc2csIGVsZW1lbnQuc291cmNlU3Bhbik7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fYXNzZXJ0Tm9Db21wb25lbnRzTm9yRWxlbWVudEJpbmRpbmdzT25UZW1wbGF0ZSA9IGZ1bmN0aW9uIChkaXJlY3RpdmVzLCBlbGVtZW50UHJvcHMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBjb21wb25lbnRUeXBlTmFtZXMgPSB0aGlzLl9maW5kQ29tcG9uZW50RGlyZWN0aXZlTmFtZXMoZGlyZWN0aXZlcyk7XG4gICAgICAgICAgaWYgKGNvbXBvbmVudFR5cGVOYW1lcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKFwiQ29tcG9uZW50cyBvbiBhbiBlbWJlZGRlZCB0ZW1wbGF0ZTogXCIgKyBjb21wb25lbnRUeXBlTmFtZXMuam9pbignLCcpLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxlbWVudFByb3BzLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgICAgX3RoaXMuX3JlcG9ydEVycm9yKFwiUHJvcGVydHkgYmluZGluZyBcIiArIHByb3AubmFtZSArIFwiIG5vdCB1c2VkIGJ5IGFueSBkaXJlY3RpdmUgb24gYW4gZW1iZWRkZWQgdGVtcGxhdGUuIE1ha2Ugc3VyZSB0aGF0IHRoZSBwcm9wZXJ0eSBuYW1lIGlzIHNwZWxsZWQgY29ycmVjdGx5IGFuZCBhbGwgZGlyZWN0aXZlcyBhcmUgbGlzdGVkIGluIHRoZSBcXFwiZGlyZWN0aXZlc1xcXCIgc2VjdGlvbi5cIiwgc291cmNlU3Bhbik7XG4gICAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9hc3NlcnRBbGxFdmVudHNQdWJsaXNoZWRCeURpcmVjdGl2ZXMgPSBmdW5jdGlvbiAoZGlyZWN0aXZlcywgZXZlbnRzKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgYWxsRGlyZWN0aXZlRXZlbnRzID0gbmV3IFNldCgpO1xuICAgICAgICAgIGRpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlyZWN0aXZlKSB7XG4gICAgICAgICAgICAgIE9iamVjdC5rZXlzKGRpcmVjdGl2ZS5kaXJlY3RpdmUub3V0cHV0cykuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgICAgICAgdmFyIGV2ZW50TmFtZSA9IGRpcmVjdGl2ZS5kaXJlY3RpdmUub3V0cHV0c1trXTtcbiAgICAgICAgICAgICAgICAgIGFsbERpcmVjdGl2ZUV2ZW50cy5hZGQoZXZlbnROYW1lKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoZXZlbnQudGFyZ2V0KSB8fCAhYWxsRGlyZWN0aXZlRXZlbnRzLmhhcyhldmVudC5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlcG9ydEVycm9yKFwiRXZlbnQgYmluZGluZyBcIiArIGV2ZW50LmZ1bGxOYW1lICsgXCIgbm90IGVtaXR0ZWQgYnkgYW55IGRpcmVjdGl2ZSBvbiBhbiBlbWJlZGRlZCB0ZW1wbGF0ZS4gTWFrZSBzdXJlIHRoYXQgdGhlIGV2ZW50IG5hbWUgaXMgc3BlbGxlZCBjb3JyZWN0bHkgYW5kIGFsbCBkaXJlY3RpdmVzIGFyZSBsaXN0ZWQgaW4gdGhlIFxcXCJkaXJlY3RpdmVzXFxcIiBzZWN0aW9uLlwiLCBldmVudC5zb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBUZW1wbGF0ZVBhcnNlVmlzaXRvcjtcbiAgfSgpKTtcbiAgdmFyIE5vbkJpbmRhYmxlVmlzaXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBOb25CaW5kYWJsZVZpc2l0b3IoKSB7XG4gICAgICB9XG4gICAgICBOb25CaW5kYWJsZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChhc3QsIHBhcmVudCkge1xuICAgICAgICAgIHZhciBwcmVwYXJzZWRFbGVtZW50ID0gcHJlcGFyc2VFbGVtZW50KGFzdCk7XG4gICAgICAgICAgaWYgKHByZXBhcnNlZEVsZW1lbnQudHlwZSA9PT0gUHJlcGFyc2VkRWxlbWVudFR5cGUuU0NSSVBUIHx8XG4gICAgICAgICAgICAgIHByZXBhcnNlZEVsZW1lbnQudHlwZSA9PT0gUHJlcGFyc2VkRWxlbWVudFR5cGUuU1RZTEUgfHxcbiAgICAgICAgICAgICAgcHJlcGFyc2VkRWxlbWVudC50eXBlID09PSBQcmVwYXJzZWRFbGVtZW50VHlwZS5TVFlMRVNIRUVUKSB7XG4gICAgICAgICAgICAgIC8vIFNraXBwaW5nIDxzY3JpcHQ+IGZvciBzZWN1cml0eSByZWFzb25zXG4gICAgICAgICAgICAgIC8vIFNraXBwaW5nIDxzdHlsZT4gYW5kIHN0eWxlc2hlZXRzIGFzIHdlIGFscmVhZHkgcHJvY2Vzc2VkIHRoZW1cbiAgICAgICAgICAgICAgLy8gaW4gdGhlIFN0eWxlQ29tcGlsZXJcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBhdHRyTmFtZUFuZFZhbHVlcyA9IGFzdC5hdHRycy5tYXAoZnVuY3Rpb24gKGF0dHJBc3QpIHsgcmV0dXJuIFthdHRyQXN0Lm5hbWUsIGF0dHJBc3QudmFsdWVdOyB9KTtcbiAgICAgICAgICB2YXIgc2VsZWN0b3IgPSBjcmVhdGVFbGVtZW50Q3NzU2VsZWN0b3IoYXN0Lm5hbWUsIGF0dHJOYW1lQW5kVmFsdWVzKTtcbiAgICAgICAgICB2YXIgbmdDb250ZW50SW5kZXggPSBwYXJlbnQuZmluZE5nQ29udGVudEluZGV4KHNlbGVjdG9yKTtcbiAgICAgICAgICB2YXIgY2hpbGRyZW4gPSB2aXNpdEFsbCh0aGlzLCBhc3QuY2hpbGRyZW4sIEVNUFRZX0VMRU1FTlRfQ09OVEVYVCk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBFbGVtZW50QXN0KGFzdC5uYW1lLCB2aXNpdEFsbCh0aGlzLCBhc3QuYXR0cnMpLCBbXSwgW10sIFtdLCBbXSwgW10sIGZhbHNlLCBjaGlsZHJlbiwgbmdDb250ZW50SW5kZXgsIGFzdC5zb3VyY2VTcGFuLCBhc3QuZW5kU291cmNlU3Bhbik7XG4gICAgICB9O1xuICAgICAgTm9uQmluZGFibGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbW1lbnQgPSBmdW5jdGlvbiAoY29tbWVudCwgY29udGV4dCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICAgIE5vbkJpbmRhYmxlVmlzaXRvci5wcm90b3R5cGUudmlzaXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXR0cmlidXRlLCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBBdHRyQXN0KGF0dHJpYnV0ZS5uYW1lLCBhdHRyaWJ1dGUudmFsdWUsIGF0dHJpYnV0ZS5zb3VyY2VTcGFuKTtcbiAgICAgIH07XG4gICAgICBOb25CaW5kYWJsZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCBwYXJlbnQpIHtcbiAgICAgICAgICB2YXIgbmdDb250ZW50SW5kZXggPSBwYXJlbnQuZmluZE5nQ29udGVudEluZGV4KFRFWFRfQ1NTX1NFTEVDVE9SKTtcbiAgICAgICAgICByZXR1cm4gbmV3IFRleHRBc3QodGV4dC52YWx1ZSwgbmdDb250ZW50SW5kZXgsIHRleHQuc291cmNlU3Bhbik7XG4gICAgICB9O1xuICAgICAgTm9uQmluZGFibGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbiA9IGZ1bmN0aW9uIChleHBhbnNpb24sIGNvbnRleHQpIHsgcmV0dXJuIGV4cGFuc2lvbjsgfTtcbiAgICAgIE5vbkJpbmRhYmxlVmlzaXRvci5wcm90b3R5cGUudmlzaXRFeHBhbnNpb25DYXNlID0gZnVuY3Rpb24gKGV4cGFuc2lvbkNhc2UsIGNvbnRleHQpIHsgcmV0dXJuIGV4cGFuc2lvbkNhc2U7IH07XG4gICAgICByZXR1cm4gTm9uQmluZGFibGVWaXNpdG9yO1xuICB9KCkpO1xuICB2YXIgQm91bmRFbGVtZW50T3JEaXJlY3RpdmVQcm9wZXJ0eSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBCb3VuZEVsZW1lbnRPckRpcmVjdGl2ZVByb3BlcnR5KG5hbWUsIGV4cHJlc3Npb24sIGlzTGl0ZXJhbCwgc291cmNlU3Bhbikge1xuICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgICAgICAgICB0aGlzLmlzTGl0ZXJhbCA9IGlzTGl0ZXJhbDtcbiAgICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEJvdW5kRWxlbWVudE9yRGlyZWN0aXZlUHJvcGVydHk7XG4gIH0oKSk7XG4gIHZhciBFbGVtZW50T3JEaXJlY3RpdmVSZWYgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gRWxlbWVudE9yRGlyZWN0aXZlUmVmKG5hbWUsIHZhbHVlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBFbGVtZW50T3JEaXJlY3RpdmVSZWY7XG4gIH0oKSk7XG4gIGZ1bmN0aW9uIHNwbGl0Q2xhc3NlcyhjbGFzc0F0dHJWYWx1ZSkge1xuICAgICAgcmV0dXJuIGNsYXNzQXR0clZhbHVlLnRyaW0oKS5zcGxpdCgvXFxzKy9nKTtcbiAgfVxuICB2YXIgRWxlbWVudENvbnRleHQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gRWxlbWVudENvbnRleHQoaXNUZW1wbGF0ZUVsZW1lbnQsIF9uZ0NvbnRlbnRJbmRleE1hdGNoZXIsIF93aWxkY2FyZE5nQ29udGVudEluZGV4LCBwcm92aWRlckNvbnRleHQpIHtcbiAgICAgICAgICB0aGlzLmlzVGVtcGxhdGVFbGVtZW50ID0gaXNUZW1wbGF0ZUVsZW1lbnQ7XG4gICAgICAgICAgdGhpcy5fbmdDb250ZW50SW5kZXhNYXRjaGVyID0gX25nQ29udGVudEluZGV4TWF0Y2hlcjtcbiAgICAgICAgICB0aGlzLl93aWxkY2FyZE5nQ29udGVudEluZGV4ID0gX3dpbGRjYXJkTmdDb250ZW50SW5kZXg7XG4gICAgICAgICAgdGhpcy5wcm92aWRlckNvbnRleHQgPSBwcm92aWRlckNvbnRleHQ7XG4gICAgICB9XG4gICAgICBFbGVtZW50Q29udGV4dC5jcmVhdGUgPSBmdW5jdGlvbiAoaXNUZW1wbGF0ZUVsZW1lbnQsIGRpcmVjdGl2ZXMsIHByb3ZpZGVyQ29udGV4dCkge1xuICAgICAgICAgIHZhciBtYXRjaGVyID0gbmV3IFNlbGVjdG9yTWF0Y2hlcigpO1xuICAgICAgICAgIHZhciB3aWxkY2FyZE5nQ29udGVudEluZGV4ID0gbnVsbDtcbiAgICAgICAgICB2YXIgY29tcG9uZW50ID0gZGlyZWN0aXZlcy5maW5kKGZ1bmN0aW9uIChkaXJlY3RpdmUpIHsgcmV0dXJuIGRpcmVjdGl2ZS5kaXJlY3RpdmUuaXNDb21wb25lbnQ7IH0pO1xuICAgICAgICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgdmFyIG5nQ29udGVudFNlbGVjdG9ycyA9IGNvbXBvbmVudC5kaXJlY3RpdmUudGVtcGxhdGUubmdDb250ZW50U2VsZWN0b3JzO1xuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5nQ29udGVudFNlbGVjdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgdmFyIHNlbGVjdG9yID0gbmdDb250ZW50U2VsZWN0b3JzW2ldO1xuICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdG9yID09PSAnKicpIHtcbiAgICAgICAgICAgICAgICAgICAgICB3aWxkY2FyZE5nQ29udGVudEluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXIuYWRkU2VsZWN0YWJsZXMoQ3NzU2VsZWN0b3IucGFyc2UobmdDb250ZW50U2VsZWN0b3JzW2ldKSwgaSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBFbGVtZW50Q29udGV4dChpc1RlbXBsYXRlRWxlbWVudCwgbWF0Y2hlciwgd2lsZGNhcmROZ0NvbnRlbnRJbmRleCwgcHJvdmlkZXJDb250ZXh0KTtcbiAgICAgIH07XG4gICAgICBFbGVtZW50Q29udGV4dC5wcm90b3R5cGUuZmluZE5nQ29udGVudEluZGV4ID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICAgICAgdmFyIG5nQ29udGVudEluZGljZXMgPSBbXTtcbiAgICAgICAgICB0aGlzLl9uZ0NvbnRlbnRJbmRleE1hdGNoZXIubWF0Y2goc2VsZWN0b3IsIGZ1bmN0aW9uIChzZWxlY3RvciwgbmdDb250ZW50SW5kZXgpIHsgbmdDb250ZW50SW5kaWNlcy5wdXNoKG5nQ29udGVudEluZGV4KTsgfSk7XG4gICAgICAgICAgbmdDb250ZW50SW5kaWNlcy5zb3J0KCk7XG4gICAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLl93aWxkY2FyZE5nQ29udGVudEluZGV4KSkge1xuICAgICAgICAgICAgICBuZ0NvbnRlbnRJbmRpY2VzLnB1c2godGhpcy5fd2lsZGNhcmROZ0NvbnRlbnRJbmRleCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZ0NvbnRlbnRJbmRpY2VzLmxlbmd0aCA+IDAgPyBuZ0NvbnRlbnRJbmRpY2VzWzBdIDogbnVsbDtcbiAgICAgIH07XG4gICAgICByZXR1cm4gRWxlbWVudENvbnRleHQ7XG4gIH0oKSk7XG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRDc3NTZWxlY3RvcihlbGVtZW50TmFtZSwgbWF0Y2hhYmxlQXR0cnMpIHtcbiAgICAgIHZhciBjc3NTZWxlY3RvciA9IG5ldyBDc3NTZWxlY3RvcigpO1xuICAgICAgdmFyIGVsTmFtZU5vTnMgPSBzcGxpdE5zTmFtZShlbGVtZW50TmFtZSlbMV07XG4gICAgICBjc3NTZWxlY3Rvci5zZXRFbGVtZW50KGVsTmFtZU5vTnMpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXRjaGFibGVBdHRycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBhdHRyTmFtZSA9IG1hdGNoYWJsZUF0dHJzW2ldWzBdO1xuICAgICAgICAgIHZhciBhdHRyTmFtZU5vTnMgPSBzcGxpdE5zTmFtZShhdHRyTmFtZSlbMV07XG4gICAgICAgICAgdmFyIGF0dHJWYWx1ZSA9IG1hdGNoYWJsZUF0dHJzW2ldWzFdO1xuICAgICAgICAgIGNzc1NlbGVjdG9yLmFkZEF0dHJpYnV0ZShhdHRyTmFtZU5vTnMsIGF0dHJWYWx1ZSk7XG4gICAgICAgICAgaWYgKGF0dHJOYW1lLnRvTG93ZXJDYXNlKCkgPT0gQ0xBU1NfQVRUUikge1xuICAgICAgICAgICAgICB2YXIgY2xhc3NlcyA9IHNwbGl0Q2xhc3NlcyhhdHRyVmFsdWUpO1xuICAgICAgICAgICAgICBjbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKGNsYXNzTmFtZSkgeyByZXR1cm4gY3NzU2VsZWN0b3IuYWRkQ2xhc3NOYW1lKGNsYXNzTmFtZSk7IH0pO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBjc3NTZWxlY3RvcjtcbiAgfVxuICB2YXIgRU1QVFlfRUxFTUVOVF9DT05URVhUID0gbmV3IEVsZW1lbnRDb250ZXh0KHRydWUsIG5ldyBTZWxlY3Rvck1hdGNoZXIoKSwgbnVsbCwgbnVsbCk7XG4gIHZhciBOT05fQklOREFCTEVfVklTSVRPUiA9IG5ldyBOb25CaW5kYWJsZVZpc2l0b3IoKTtcbiAgdmFyIFBpcGVDb2xsZWN0b3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzKFBpcGVDb2xsZWN0b3IsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBQaXBlQ29sbGVjdG9yKCkge1xuICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIHRoaXMucGlwZXMgPSBuZXcgU2V0KCk7XG4gICAgICB9XG4gICAgICBQaXBlQ29sbGVjdG9yLnByb3RvdHlwZS52aXNpdFBpcGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgdGhpcy5waXBlcy5hZGQoYXN0Lm5hbWUpO1xuICAgICAgICAgIGFzdC5leHAudmlzaXQodGhpcyk7XG4gICAgICAgICAgdGhpcy52aXNpdEFsbChhc3QuYXJncywgY29udGV4dCk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFBpcGVDb2xsZWN0b3I7XG4gIH0oUmVjdXJzaXZlQXN0VmlzaXRvcikpO1xuICBmdW5jdGlvbiBfaXNBbmltYXRpb25MYWJlbChuYW1lKSB7XG4gICAgICByZXR1cm4gbmFtZVswXSA9PSAnQCc7XG4gIH1cbiAgZnVuY3Rpb24gX2lzRW1wdHlUZXh0Tm9kZShub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIFRleHQgJiYgbm9kZS52YWx1ZS50cmltKCkubGVuZ3RoID09IDA7XG4gIH1cblxuICBmdW5jdGlvbiB1bmltcGxlbWVudGVkJDEoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuaW1wbGVtZW50ZWQnKTtcbiAgfVxuICB2YXIgQ29tcGlsZXJDb25maWcgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQ29tcGlsZXJDb25maWcoX2EpIHtcbiAgICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgX2MgPSBfYi5yZW5kZXJUeXBlcywgcmVuZGVyVHlwZXMgPSBfYyA9PT0gdm9pZCAwID8gbmV3IERlZmF1bHRSZW5kZXJUeXBlcygpIDogX2MsIF9kID0gX2IuZGVmYXVsdEVuY2Fwc3VsYXRpb24sIGRlZmF1bHRFbmNhcHN1bGF0aW9uID0gX2QgPT09IHZvaWQgMCA/IF9hbmd1bGFyX2NvcmUuVmlld0VuY2Fwc3VsYXRpb24uRW11bGF0ZWQgOiBfZCwgZ2VuRGVidWdJbmZvID0gX2IuZ2VuRGVidWdJbmZvLCBsb2dCaW5kaW5nVXBkYXRlID0gX2IubG9nQmluZGluZ1VwZGF0ZSwgX2UgPSBfYi51c2VKaXQsIHVzZUppdCA9IF9lID09PSB2b2lkIDAgPyB0cnVlIDogX2U7XG4gICAgICAgICAgdGhpcy5yZW5kZXJUeXBlcyA9IHJlbmRlclR5cGVzO1xuICAgICAgICAgIHRoaXMuZGVmYXVsdEVuY2Fwc3VsYXRpb24gPSBkZWZhdWx0RW5jYXBzdWxhdGlvbjtcbiAgICAgICAgICB0aGlzLl9nZW5EZWJ1Z0luZm8gPSBnZW5EZWJ1Z0luZm87XG4gICAgICAgICAgdGhpcy5fbG9nQmluZGluZ1VwZGF0ZSA9IGxvZ0JpbmRpbmdVcGRhdGU7XG4gICAgICAgICAgdGhpcy51c2VKaXQgPSB1c2VKaXQ7XG4gICAgICB9XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcGlsZXJDb25maWcucHJvdG90eXBlLCBcImdlbkRlYnVnSW5mb1wiLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZW5EZWJ1Z0luZm8gPT09IHZvaWQgMCA/IF9hbmd1bGFyX2NvcmUuaXNEZXZNb2RlKCkgOiB0aGlzLl9nZW5EZWJ1Z0luZm87XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcGlsZXJDb25maWcucHJvdG90eXBlLCBcImxvZ0JpbmRpbmdVcGRhdGVcIiwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9nQmluZGluZ1VwZGF0ZSA9PT0gdm9pZCAwID8gX2FuZ3VsYXJfY29yZS5pc0Rldk1vZGUoKSA6IHRoaXMuX2xvZ0JpbmRpbmdVcGRhdGU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gQ29tcGlsZXJDb25maWc7XG4gIH0oKSk7XG4gIC8qKlxuICAgKiBUeXBlcyB1c2VkIGZvciB0aGUgcmVuZGVyZXIuXG4gICAqIENhbiBiZSByZXBsYWNlZCB0byBzcGVjaWFsaXplIHRoZSBnZW5lcmF0ZWQgb3V0cHV0IHRvIGEgc3BlY2lmaWMgcmVuZGVyZXJcbiAgICogdG8gaGVscCB0cmVlIHNoYWtpbmcuXG4gICAqL1xuICB2YXIgUmVuZGVyVHlwZXMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gUmVuZGVyVHlwZXMoKSB7XG4gICAgICB9XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVuZGVyVHlwZXMucHJvdG90eXBlLCBcInJlbmRlcmVyXCIsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaW1wbGVtZW50ZWQkMSgpOyB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZW5kZXJUeXBlcy5wcm90b3R5cGUsIFwicmVuZGVyVGV4dFwiLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmltcGxlbWVudGVkJDEoKTsgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVuZGVyVHlwZXMucHJvdG90eXBlLCBcInJlbmRlckVsZW1lbnRcIiwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCQxKCk7IH0sXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlbmRlclR5cGVzLnByb3RvdHlwZSwgXCJyZW5kZXJDb21tZW50XCIsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaW1wbGVtZW50ZWQkMSgpOyB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZW5kZXJUeXBlcy5wcm90b3R5cGUsIFwicmVuZGVyTm9kZVwiLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmltcGxlbWVudGVkJDEoKTsgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVuZGVyVHlwZXMucHJvdG90eXBlLCBcInJlbmRlckV2ZW50XCIsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaW1wbGVtZW50ZWQkMSgpOyB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBSZW5kZXJUeXBlcztcbiAgfSgpKTtcbiAgdmFyIERlZmF1bHRSZW5kZXJUeXBlcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBEZWZhdWx0UmVuZGVyVHlwZXMoKSB7XG4gICAgICAgICAgdGhpcy5yZW5kZXJUZXh0ID0gbnVsbDtcbiAgICAgICAgICB0aGlzLnJlbmRlckVsZW1lbnQgPSBudWxsO1xuICAgICAgICAgIHRoaXMucmVuZGVyQ29tbWVudCA9IG51bGw7XG4gICAgICAgICAgdGhpcy5yZW5kZXJOb2RlID0gbnVsbDtcbiAgICAgICAgICB0aGlzLnJlbmRlckV2ZW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWZhdWx0UmVuZGVyVHlwZXMucHJvdG90eXBlLCBcInJlbmRlcmVyXCIsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLlJlbmRlcmVyKTsgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICA7XG4gICAgICByZXR1cm4gRGVmYXVsdFJlbmRlclR5cGVzO1xuICB9KCkpO1xuXG4gIC8qKlxuICAgKiBAbGljZW5zZVxuICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICpcbiAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgKi9cbiAgdmFyIF9fZXh0ZW5kcyQxMiA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgfTtcbiAgdmFyIEFuaW1hdGlvbkFzdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBBbmltYXRpb25Bc3QoKSB7XG4gICAgICAgICAgdGhpcy5zdGFydFRpbWUgPSAwO1xuICAgICAgICAgIHRoaXMucGxheVRpbWUgPSAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEFuaW1hdGlvbkFzdDtcbiAgfSgpKTtcbiAgdmFyIEFuaW1hdGlvblN0YXRlQXN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQxMihBbmltYXRpb25TdGF0ZUFzdCwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvblN0YXRlQXN0KCkge1xuICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEFuaW1hdGlvblN0YXRlQXN0O1xuICB9KEFuaW1hdGlvbkFzdCkpO1xuICB2YXIgQW5pbWF0aW9uRW50cnlBc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDEyKEFuaW1hdGlvbkVudHJ5QXN0LCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gQW5pbWF0aW9uRW50cnlBc3QobmFtZSwgc3RhdGVEZWNsYXJhdGlvbnMsIHN0YXRlVHJhbnNpdGlvbnMpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgIHRoaXMuc3RhdGVEZWNsYXJhdGlvbnMgPSBzdGF0ZURlY2xhcmF0aW9ucztcbiAgICAgICAgICB0aGlzLnN0YXRlVHJhbnNpdGlvbnMgPSBzdGF0ZVRyYW5zaXRpb25zO1xuICAgICAgfVxuICAgICAgQW5pbWF0aW9uRW50cnlBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEFuaW1hdGlvbkVudHJ5KHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBBbmltYXRpb25FbnRyeUFzdDtcbiAgfShBbmltYXRpb25Bc3QpKTtcbiAgdmFyIEFuaW1hdGlvblN0YXRlRGVjbGFyYXRpb25Bc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDEyKEFuaW1hdGlvblN0YXRlRGVjbGFyYXRpb25Bc3QsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBBbmltYXRpb25TdGF0ZURlY2xhcmF0aW9uQXN0KHN0YXRlTmFtZSwgc3R5bGVzKSB7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgdGhpcy5zdGF0ZU5hbWUgPSBzdGF0ZU5hbWU7XG4gICAgICAgICAgdGhpcy5zdHlsZXMgPSBzdHlsZXM7XG4gICAgICB9XG4gICAgICBBbmltYXRpb25TdGF0ZURlY2xhcmF0aW9uQXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRBbmltYXRpb25TdGF0ZURlY2xhcmF0aW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBBbmltYXRpb25TdGF0ZURlY2xhcmF0aW9uQXN0O1xuICB9KEFuaW1hdGlvblN0YXRlQXN0KSk7XG4gIHZhciBBbmltYXRpb25TdGF0ZVRyYW5zaXRpb25FeHByZXNzaW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvblN0YXRlVHJhbnNpdGlvbkV4cHJlc3Npb24oZnJvbVN0YXRlLCB0b1N0YXRlKSB7XG4gICAgICAgICAgdGhpcy5mcm9tU3RhdGUgPSBmcm9tU3RhdGU7XG4gICAgICAgICAgdGhpcy50b1N0YXRlID0gdG9TdGF0ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBBbmltYXRpb25TdGF0ZVRyYW5zaXRpb25FeHByZXNzaW9uO1xuICB9KCkpO1xuICB2YXIgQW5pbWF0aW9uU3RhdGVUcmFuc2l0aW9uQXN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQxMihBbmltYXRpb25TdGF0ZVRyYW5zaXRpb25Bc3QsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBBbmltYXRpb25TdGF0ZVRyYW5zaXRpb25Bc3Qoc3RhdGVDaGFuZ2VzLCBhbmltYXRpb24pIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICB0aGlzLnN0YXRlQ2hhbmdlcyA9IHN0YXRlQ2hhbmdlcztcbiAgICAgICAgICB0aGlzLmFuaW1hdGlvbiA9IGFuaW1hdGlvbjtcbiAgICAgIH1cbiAgICAgIEFuaW1hdGlvblN0YXRlVHJhbnNpdGlvbkFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QW5pbWF0aW9uU3RhdGVUcmFuc2l0aW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBBbmltYXRpb25TdGF0ZVRyYW5zaXRpb25Bc3Q7XG4gIH0oQW5pbWF0aW9uU3RhdGVBc3QpKTtcbiAgdmFyIEFuaW1hdGlvblN0ZXBBc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDEyKEFuaW1hdGlvblN0ZXBBc3QsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBBbmltYXRpb25TdGVwQXN0KHN0YXJ0aW5nU3R5bGVzLCBrZXlmcmFtZXMsIGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nKSB7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgdGhpcy5zdGFydGluZ1N0eWxlcyA9IHN0YXJ0aW5nU3R5bGVzO1xuICAgICAgICAgIHRoaXMua2V5ZnJhbWVzID0ga2V5ZnJhbWVzO1xuICAgICAgICAgIHRoaXMuZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICAgICAgICB0aGlzLmRlbGF5ID0gZGVsYXk7XG4gICAgICAgICAgdGhpcy5lYXNpbmcgPSBlYXNpbmc7XG4gICAgICB9XG4gICAgICBBbmltYXRpb25TdGVwQXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRBbmltYXRpb25TdGVwKHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBBbmltYXRpb25TdGVwQXN0O1xuICB9KEFuaW1hdGlvbkFzdCkpO1xuICB2YXIgQW5pbWF0aW9uU3R5bGVzQXN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQxMihBbmltYXRpb25TdHlsZXNBc3QsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBBbmltYXRpb25TdHlsZXNBc3Qoc3R5bGVzKSB7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgdGhpcy5zdHlsZXMgPSBzdHlsZXM7XG4gICAgICB9XG4gICAgICBBbmltYXRpb25TdHlsZXNBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEFuaW1hdGlvblN0eWxlcyh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gQW5pbWF0aW9uU3R5bGVzQXN0O1xuICB9KEFuaW1hdGlvbkFzdCkpO1xuICB2YXIgQW5pbWF0aW9uS2V5ZnJhbWVBc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDEyKEFuaW1hdGlvbktleWZyYW1lQXN0LCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gQW5pbWF0aW9uS2V5ZnJhbWVBc3Qob2Zmc2V0LCBzdHlsZXMpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICB0aGlzLnN0eWxlcyA9IHN0eWxlcztcbiAgICAgIH1cbiAgICAgIEFuaW1hdGlvbktleWZyYW1lQXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRBbmltYXRpb25LZXlmcmFtZSh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gQW5pbWF0aW9uS2V5ZnJhbWVBc3Q7XG4gIH0oQW5pbWF0aW9uQXN0KSk7XG4gIHZhciBBbmltYXRpb25XaXRoU3RlcHNBc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDEyKEFuaW1hdGlvbldpdGhTdGVwc0FzdCwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvbldpdGhTdGVwc0FzdChzdGVwcykge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgIHRoaXMuc3RlcHMgPSBzdGVwcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBBbmltYXRpb25XaXRoU3RlcHNBc3Q7XG4gIH0oQW5pbWF0aW9uQXN0KSk7XG4gIHZhciBBbmltYXRpb25Hcm91cEFzdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMTIoQW5pbWF0aW9uR3JvdXBBc3QsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBBbmltYXRpb25Hcm91cEFzdChzdGVwcykge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHN0ZXBzKTtcbiAgICAgIH1cbiAgICAgIEFuaW1hdGlvbkdyb3VwQXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRBbmltYXRpb25Hcm91cCh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gQW5pbWF0aW9uR3JvdXBBc3Q7XG4gIH0oQW5pbWF0aW9uV2l0aFN0ZXBzQXN0KSk7XG4gIHZhciBBbmltYXRpb25TZXF1ZW5jZUFzdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMTIoQW5pbWF0aW9uU2VxdWVuY2VBc3QsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBBbmltYXRpb25TZXF1ZW5jZUFzdChzdGVwcykge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHN0ZXBzKTtcbiAgICAgIH1cbiAgICAgIEFuaW1hdGlvblNlcXVlbmNlQXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRBbmltYXRpb25TZXF1ZW5jZSh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gQW5pbWF0aW9uU2VxdWVuY2VBc3Q7XG4gIH0oQW5pbWF0aW9uV2l0aFN0ZXBzQXN0KSk7XG5cbiAgdmFyIEFuaW1hdGlvbkVudHJ5Q29tcGlsZVJlc3VsdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBBbmltYXRpb25FbnRyeUNvbXBpbGVSZXN1bHQobmFtZSwgc3RhdGVtZW50cywgZm5FeHApIHtcbiAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgIHRoaXMuc3RhdGVtZW50cyA9IHN0YXRlbWVudHM7XG4gICAgICAgICAgdGhpcy5mbkV4cCA9IGZuRXhwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEFuaW1hdGlvbkVudHJ5Q29tcGlsZVJlc3VsdDtcbiAgfSgpKTtcbiAgdmFyIEFuaW1hdGlvbkNvbXBpbGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvbkNvbXBpbGVyKCkge1xuICAgICAgfVxuICAgICAgQW5pbWF0aW9uQ29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGUgPSBmdW5jdGlvbiAoZmFjdG9yeU5hbWVQcmVmaXgsIHBhcnNlZEFuaW1hdGlvbnMpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VkQW5pbWF0aW9ucy5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICAgIHZhciBmYWN0b3J5TmFtZSA9IGZhY3RvcnlOYW1lUHJlZml4ICsgXCJfXCIgKyBlbnRyeS5uYW1lO1xuICAgICAgICAgICAgICB2YXIgdmlzaXRvciA9IG5ldyBfQW5pbWF0aW9uQnVpbGRlcihlbnRyeS5uYW1lLCBmYWN0b3J5TmFtZSk7XG4gICAgICAgICAgICAgIHJldHVybiB2aXNpdG9yLmJ1aWxkKGVudHJ5KTtcbiAgICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gQW5pbWF0aW9uQ29tcGlsZXI7XG4gIH0oKSk7XG4gIHZhciBfQU5JTUFUSU9OX0ZBQ1RPUllfRUxFTUVOVF9WQVIgPSB2YXJpYWJsZSgnZWxlbWVudCcpO1xuICB2YXIgX0FOSU1BVElPTl9ERUZBVUxUX1NUQVRFX1ZBUiA9IHZhcmlhYmxlKCdkZWZhdWx0U3RhdGVTdHlsZXMnKTtcbiAgdmFyIF9BTklNQVRJT05fRkFDVE9SWV9WSUVXX1ZBUiA9IHZhcmlhYmxlKCd2aWV3Jyk7XG4gIHZhciBfQU5JTUFUSU9OX0ZBQ1RPUllfVklFV19DT05URVhUID0gX0FOSU1BVElPTl9GQUNUT1JZX1ZJRVdfVkFSLnByb3AoJ2FuaW1hdGlvbkNvbnRleHQnKTtcbiAgdmFyIF9BTklNQVRJT05fRkFDVE9SWV9SRU5ERVJFUl9WQVIgPSBfQU5JTUFUSU9OX0ZBQ1RPUllfVklFV19WQVIucHJvcCgncmVuZGVyZXInKTtcbiAgdmFyIF9BTklNQVRJT05fQ1VSUkVOVF9TVEFURV9WQVIgPSB2YXJpYWJsZSgnY3VycmVudFN0YXRlJyk7XG4gIHZhciBfQU5JTUFUSU9OX05FWFRfU1RBVEVfVkFSID0gdmFyaWFibGUoJ25leHRTdGF0ZScpO1xuICB2YXIgX0FOSU1BVElPTl9QTEFZRVJfVkFSID0gdmFyaWFibGUoJ3BsYXllcicpO1xuICB2YXIgX0FOSU1BVElPTl9USU1FX1ZBUiA9IHZhcmlhYmxlKCd0b3RhbFRpbWUnKTtcbiAgdmFyIF9BTklNQVRJT05fU1RBUlRfU1RBVEVfU1RZTEVTX1ZBUiA9IHZhcmlhYmxlKCdzdGFydFN0YXRlU3R5bGVzJyk7XG4gIHZhciBfQU5JTUFUSU9OX0VORF9TVEFURV9TVFlMRVNfVkFSID0gdmFyaWFibGUoJ2VuZFN0YXRlU3R5bGVzJyk7XG4gIHZhciBfQU5JTUFUSU9OX0NPTExFQ1RFRF9TVFlMRVMgPSB2YXJpYWJsZSgnY29sbGVjdGVkU3R5bGVzJyk7XG4gIHZhciBFTVBUWV9NQVAgPSBsaXRlcmFsTWFwKFtdKTtcbiAgdmFyIF9BbmltYXRpb25CdWlsZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIF9BbmltYXRpb25CdWlsZGVyKGFuaW1hdGlvbk5hbWUsIGZhY3RvcnlOYW1lKSB7XG4gICAgICAgICAgdGhpcy5hbmltYXRpb25OYW1lID0gYW5pbWF0aW9uTmFtZTtcbiAgICAgICAgICB0aGlzLl9mblZhck5hbWUgPSBmYWN0b3J5TmFtZSArICdfZmFjdG9yeSc7XG4gICAgICAgICAgdGhpcy5fc3RhdGVzTWFwVmFyTmFtZSA9IGZhY3RvcnlOYW1lICsgJ19zdGF0ZXMnO1xuICAgICAgICAgIHRoaXMuX3N0YXRlc01hcFZhciA9IHZhcmlhYmxlKHRoaXMuX3N0YXRlc01hcFZhck5hbWUpO1xuICAgICAgfVxuICAgICAgX0FuaW1hdGlvbkJ1aWxkZXIucHJvdG90eXBlLnZpc2l0QW5pbWF0aW9uU3R5bGVzID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIHZhciBzdHlsZXNBcnIgPSBbXTtcbiAgICAgICAgICBpZiAoY29udGV4dC5pc0V4cGVjdGluZ0ZpcnN0U3R5bGVTdGVwKSB7XG4gICAgICAgICAgICAgIHN0eWxlc0Fyci5wdXNoKF9BTklNQVRJT05fU1RBUlRfU1RBVEVfU1RZTEVTX1ZBUik7XG4gICAgICAgICAgICAgIGNvbnRleHQuaXNFeHBlY3RpbmdGaXJzdFN0eWxlU3RlcCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhc3Quc3R5bGVzLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICAgIHZhciBlbnRyaWVzID0gT2JqZWN0LmtleXMoZW50cnkpLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBba2V5LCBsaXRlcmFsKGVudHJ5W2tleV0pXTsgfSk7XG4gICAgICAgICAgICAgIHN0eWxlc0Fyci5wdXNoKGxpdGVyYWxNYXAoZW50cmllcykpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBpbXBvcnRFeHByKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLkFuaW1hdGlvblN0eWxlcykpLmluc3RhbnRpYXRlKFtcbiAgICAgICAgICAgICAgaW1wb3J0RXhwcihyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5jb2xsZWN0QW5kUmVzb2x2ZVN0eWxlcykpLmNhbGxGbihbXG4gICAgICAgICAgICAgICAgICBfQU5JTUFUSU9OX0NPTExFQ1RFRF9TVFlMRVMsIGxpdGVyYWxBcnIoc3R5bGVzQXJyKVxuICAgICAgICAgICAgICBdKVxuICAgICAgICAgIF0pO1xuICAgICAgfTtcbiAgICAgIF9BbmltYXRpb25CdWlsZGVyLnByb3RvdHlwZS52aXNpdEFuaW1hdGlvbktleWZyYW1lID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiBpbXBvcnRFeHByKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLkFuaW1hdGlvbktleWZyYW1lKSkuaW5zdGFudGlhdGUoW1xuICAgICAgICAgICAgICBsaXRlcmFsKGFzdC5vZmZzZXQpLCBhc3Quc3R5bGVzLnZpc2l0KHRoaXMsIGNvbnRleHQpXG4gICAgICAgICAgXSk7XG4gICAgICB9O1xuICAgICAgX0FuaW1hdGlvbkJ1aWxkZXIucHJvdG90eXBlLnZpc2l0QW5pbWF0aW9uU3RlcCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIGlmIChjb250ZXh0LmVuZFN0YXRlQW5pbWF0ZVN0ZXAgPT09IGFzdCkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdmlzaXRFbmRTdGF0ZUFuaW1hdGlvbihhc3QsIGNvbnRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgc3RhcnRpbmdTdHlsZXNFeHByID0gYXN0LnN0YXJ0aW5nU3R5bGVzLnZpc2l0KHRoaXMsIGNvbnRleHQpO1xuICAgICAgICAgIHZhciBrZXlmcmFtZUV4cHJlc3Npb25zID0gYXN0LmtleWZyYW1lcy5tYXAoZnVuY3Rpb24gKGtleWZyYW1lRW50cnkpIHsgcmV0dXJuIGtleWZyYW1lRW50cnkudmlzaXQoX3RoaXMsIGNvbnRleHQpOyB9KTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fY2FsbEFuaW1hdGVNZXRob2QoYXN0LCBzdGFydGluZ1N0eWxlc0V4cHIsIGxpdGVyYWxBcnIoa2V5ZnJhbWVFeHByZXNzaW9ucyksIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgIF9BbmltYXRpb25CdWlsZGVyLnByb3RvdHlwZS5fdmlzaXRFbmRTdGF0ZUFuaW1hdGlvbiA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBzdGFydGluZ1N0eWxlc0V4cHIgPSBhc3Quc3RhcnRpbmdTdHlsZXMudmlzaXQodGhpcywgY29udGV4dCk7XG4gICAgICAgICAgdmFyIGtleWZyYW1lRXhwcmVzc2lvbnMgPSBhc3Qua2V5ZnJhbWVzLm1hcChmdW5jdGlvbiAoa2V5ZnJhbWUpIHsgcmV0dXJuIGtleWZyYW1lLnZpc2l0KF90aGlzLCBjb250ZXh0KTsgfSk7XG4gICAgICAgICAgdmFyIGtleWZyYW1lc0V4cHIgPSBpbXBvcnRFeHByKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLmJhbGFuY2VBbmltYXRpb25LZXlmcmFtZXMpKS5jYWxsRm4oW1xuICAgICAgICAgICAgICBfQU5JTUFUSU9OX0NPTExFQ1RFRF9TVFlMRVMsIF9BTklNQVRJT05fRU5EX1NUQVRFX1NUWUxFU19WQVIsXG4gICAgICAgICAgICAgIGxpdGVyYWxBcnIoa2V5ZnJhbWVFeHByZXNzaW9ucylcbiAgICAgICAgICBdKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fY2FsbEFuaW1hdGVNZXRob2QoYXN0LCBzdGFydGluZ1N0eWxlc0V4cHIsIGtleWZyYW1lc0V4cHIsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgIF9BbmltYXRpb25CdWlsZGVyLnByb3RvdHlwZS5fY2FsbEFuaW1hdGVNZXRob2QgPSBmdW5jdGlvbiAoYXN0LCBzdGFydGluZ1N0eWxlc0V4cHIsIGtleWZyYW1lc0V4cHIsIGNvbnRleHQpIHtcbiAgICAgICAgICBjb250ZXh0LnRvdGFsVHJhbnNpdGlvblRpbWUgKz0gYXN0LmR1cmF0aW9uICsgYXN0LmRlbGF5O1xuICAgICAgICAgIHJldHVybiBfQU5JTUFUSU9OX0ZBQ1RPUllfUkVOREVSRVJfVkFSLmNhbGxNZXRob2QoJ2FuaW1hdGUnLCBbXG4gICAgICAgICAgICAgIF9BTklNQVRJT05fRkFDVE9SWV9FTEVNRU5UX1ZBUiwgc3RhcnRpbmdTdHlsZXNFeHByLCBrZXlmcmFtZXNFeHByLCBsaXRlcmFsKGFzdC5kdXJhdGlvbiksXG4gICAgICAgICAgICAgIGxpdGVyYWwoYXN0LmRlbGF5KSwgbGl0ZXJhbChhc3QuZWFzaW5nKVxuICAgICAgICAgIF0pO1xuICAgICAgfTtcbiAgICAgIF9BbmltYXRpb25CdWlsZGVyLnByb3RvdHlwZS52aXNpdEFuaW1hdGlvblNlcXVlbmNlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIHBsYXllckV4cHJzID0gYXN0LnN0ZXBzLm1hcChmdW5jdGlvbiAoc3RlcCkgeyByZXR1cm4gc3RlcC52aXNpdChfdGhpcywgY29udGV4dCk7IH0pO1xuICAgICAgICAgIHJldHVybiBpbXBvcnRFeHByKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLkFuaW1hdGlvblNlcXVlbmNlUGxheWVyKSkuaW5zdGFudGlhdGUoW1xuICAgICAgICAgICAgICBsaXRlcmFsQXJyKHBsYXllckV4cHJzKVxuICAgICAgICAgIF0pO1xuICAgICAgfTtcbiAgICAgIF9BbmltYXRpb25CdWlsZGVyLnByb3RvdHlwZS52aXNpdEFuaW1hdGlvbkdyb3VwID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIHBsYXllckV4cHJzID0gYXN0LnN0ZXBzLm1hcChmdW5jdGlvbiAoc3RlcCkgeyByZXR1cm4gc3RlcC52aXNpdChfdGhpcywgY29udGV4dCk7IH0pO1xuICAgICAgICAgIHJldHVybiBpbXBvcnRFeHByKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLkFuaW1hdGlvbkdyb3VwUGxheWVyKSkuaW5zdGFudGlhdGUoW1xuICAgICAgICAgICAgICBsaXRlcmFsQXJyKHBsYXllckV4cHJzKVxuICAgICAgICAgIF0pO1xuICAgICAgfTtcbiAgICAgIF9BbmltYXRpb25CdWlsZGVyLnByb3RvdHlwZS52aXNpdEFuaW1hdGlvblN0YXRlRGVjbGFyYXRpb24gPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgdmFyIGZsYXRTdHlsZXMgPSB7fTtcbiAgICAgICAgICBfZ2V0U3R5bGVzQXJyYXkoYXN0KS5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkgeyBPYmplY3Qua2V5cyhlbnRyeSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IGZsYXRTdHlsZXNba2V5XSA9IGVudHJ5W2tleV07IH0pOyB9KTtcbiAgICAgICAgICBjb250ZXh0LnN0YXRlTWFwLnJlZ2lzdGVyU3RhdGUoYXN0LnN0YXRlTmFtZSwgZmxhdFN0eWxlcyk7XG4gICAgICB9O1xuICAgICAgX0FuaW1hdGlvbkJ1aWxkZXIucHJvdG90eXBlLnZpc2l0QW5pbWF0aW9uU3RhdGVUcmFuc2l0aW9uID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIHZhciBzdGVwcyA9IGFzdC5hbmltYXRpb24uc3RlcHM7XG4gICAgICAgICAgdmFyIGxhc3RTdGVwID0gc3RlcHNbc3RlcHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgaWYgKF9pc0VuZFN0YXRlQW5pbWF0ZVN0ZXAobGFzdFN0ZXApKSB7XG4gICAgICAgICAgICAgIGNvbnRleHQuZW5kU3RhdGVBbmltYXRlU3RlcCA9IGxhc3RTdGVwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250ZXh0LnRvdGFsVHJhbnNpdGlvblRpbWUgPSAwO1xuICAgICAgICAgIGNvbnRleHQuaXNFeHBlY3RpbmdGaXJzdFN0eWxlU3RlcCA9IHRydWU7XG4gICAgICAgICAgdmFyIHN0YXRlQ2hhbmdlUHJlY29uZGl0aW9ucyA9IFtdO1xuICAgICAgICAgIGFzdC5zdGF0ZUNoYW5nZXMuZm9yRWFjaChmdW5jdGlvbiAoc3RhdGVDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgc3RhdGVDaGFuZ2VQcmVjb25kaXRpb25zLnB1c2goX2NvbXBhcmVUb0FuaW1hdGlvblN0YXRlRXhwcihfQU5JTUFUSU9OX0NVUlJFTlRfU1RBVEVfVkFSLCBzdGF0ZUNoYW5nZS5mcm9tU3RhdGUpXG4gICAgICAgICAgICAgICAgICAuYW5kKF9jb21wYXJlVG9BbmltYXRpb25TdGF0ZUV4cHIoX0FOSU1BVElPTl9ORVhUX1NUQVRFX1ZBUiwgc3RhdGVDaGFuZ2UudG9TdGF0ZSkpKTtcbiAgICAgICAgICAgICAgaWYgKHN0YXRlQ2hhbmdlLmZyb21TdGF0ZSAhPSBBTllfU1RBVEUpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRleHQuc3RhdGVNYXAucmVnaXN0ZXJTdGF0ZShzdGF0ZUNoYW5nZS5mcm9tU3RhdGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChzdGF0ZUNoYW5nZS50b1N0YXRlICE9IEFOWV9TVEFURSkge1xuICAgICAgICAgICAgICAgICAgY29udGV4dC5zdGF0ZU1hcC5yZWdpc3RlclN0YXRlKHN0YXRlQ2hhbmdlLnRvU3RhdGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIGFuaW1hdGlvblBsYXllckV4cHIgPSBhc3QuYW5pbWF0aW9uLnZpc2l0KHRoaXMsIGNvbnRleHQpO1xuICAgICAgICAgIHZhciByZWR1Y2VkU3RhdGVDaGFuZ2VzUHJlY29uZGl0aW9uID0gc3RhdGVDaGFuZ2VQcmVjb25kaXRpb25zLnJlZHVjZShmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5vcihiKTsgfSk7XG4gICAgICAgICAgdmFyIHByZWNvbmRpdGlvbiA9IF9BTklNQVRJT05fUExBWUVSX1ZBUi5lcXVhbHMoTlVMTF9FWFBSKS5hbmQocmVkdWNlZFN0YXRlQ2hhbmdlc1ByZWNvbmRpdGlvbik7XG4gICAgICAgICAgdmFyIGFuaW1hdGlvblN0bXQgPSBfQU5JTUFUSU9OX1BMQVlFUl9WQVIuc2V0KGFuaW1hdGlvblBsYXllckV4cHIpLnRvU3RtdCgpO1xuICAgICAgICAgIHZhciB0b3RhbFRpbWVTdG10ID0gX0FOSU1BVElPTl9USU1FX1ZBUi5zZXQobGl0ZXJhbChjb250ZXh0LnRvdGFsVHJhbnNpdGlvblRpbWUpKS50b1N0bXQoKTtcbiAgICAgICAgICByZXR1cm4gbmV3IElmU3RtdChwcmVjb25kaXRpb24sIFthbmltYXRpb25TdG10LCB0b3RhbFRpbWVTdG10XSk7XG4gICAgICB9O1xuICAgICAgX0FuaW1hdGlvbkJ1aWxkZXIucHJvdG90eXBlLnZpc2l0QW5pbWF0aW9uRW50cnkgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAvLyB2aXNpdCBlYWNoIG9mIHRoZSBkZWNsYXJhdGlvbnMgZmlyc3QgdG8gYnVpbGQgdGhlIGNvbnRleHQgc3RhdGUgbWFwXG4gICAgICAgICAgYXN0LnN0YXRlRGVjbGFyYXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGRlZikgeyByZXR1cm4gZGVmLnZpc2l0KF90aGlzLCBjb250ZXh0KTsgfSk7XG4gICAgICAgICAgLy8gdGhpcyBzaG91bGQgYWx3YXlzIGJlIGRlZmluZWQgZXZlbiBpZiB0aGUgdXNlciBvdmVycmlkZXMgaXRcbiAgICAgICAgICBjb250ZXh0LnN0YXRlTWFwLnJlZ2lzdGVyU3RhdGUoREVGQVVMVF9TVEFURSwge30pO1xuICAgICAgICAgIHZhciBzdGF0ZW1lbnRzID0gW107XG4gICAgICAgICAgc3RhdGVtZW50cy5wdXNoKF9BTklNQVRJT05fRkFDVE9SWV9WSUVXX0NPTlRFWFRcbiAgICAgICAgICAgICAgLmNhbGxNZXRob2QoJ2NhbmNlbEFjdGl2ZUFuaW1hdGlvbicsIFtcbiAgICAgICAgICAgICAgX0FOSU1BVElPTl9GQUNUT1JZX0VMRU1FTlRfVkFSLCBsaXRlcmFsKHRoaXMuYW5pbWF0aW9uTmFtZSksXG4gICAgICAgICAgICAgIF9BTklNQVRJT05fTkVYVF9TVEFURV9WQVIuZXF1YWxzKGxpdGVyYWwoRU1QVFlfQU5JTUFUSU9OX1NUQVRFKSlcbiAgICAgICAgICBdKVxuICAgICAgICAgICAgICAudG9TdG10KCkpO1xuICAgICAgICAgIHN0YXRlbWVudHMucHVzaChfQU5JTUFUSU9OX0NPTExFQ1RFRF9TVFlMRVMuc2V0KEVNUFRZX01BUCkudG9EZWNsU3RtdCgpKTtcbiAgICAgICAgICBzdGF0ZW1lbnRzLnB1c2goX0FOSU1BVElPTl9QTEFZRVJfVkFSLnNldChOVUxMX0VYUFIpLnRvRGVjbFN0bXQoKSk7XG4gICAgICAgICAgc3RhdGVtZW50cy5wdXNoKF9BTklNQVRJT05fVElNRV9WQVIuc2V0KGxpdGVyYWwoMCkpLnRvRGVjbFN0bXQoKSk7XG4gICAgICAgICAgc3RhdGVtZW50cy5wdXNoKF9BTklNQVRJT05fREVGQVVMVF9TVEFURV9WQVIuc2V0KHRoaXMuX3N0YXRlc01hcFZhci5rZXkobGl0ZXJhbChERUZBVUxUX1NUQVRFKSkpXG4gICAgICAgICAgICAgIC50b0RlY2xTdG10KCkpO1xuICAgICAgICAgIHN0YXRlbWVudHMucHVzaChfQU5JTUFUSU9OX1NUQVJUX1NUQVRFX1NUWUxFU19WQVIuc2V0KHRoaXMuX3N0YXRlc01hcFZhci5rZXkoX0FOSU1BVElPTl9DVVJSRU5UX1NUQVRFX1ZBUikpXG4gICAgICAgICAgICAgIC50b0RlY2xTdG10KCkpO1xuICAgICAgICAgIHN0YXRlbWVudHMucHVzaChuZXcgSWZTdG10KF9BTklNQVRJT05fU1RBUlRfU1RBVEVfU1RZTEVTX1ZBUi5lcXVhbHMoTlVMTF9FWFBSKSwgW19BTklNQVRJT05fU1RBUlRfU1RBVEVfU1RZTEVTX1ZBUi5zZXQoX0FOSU1BVElPTl9ERUZBVUxUX1NUQVRFX1ZBUikudG9TdG10KCldKSk7XG4gICAgICAgICAgc3RhdGVtZW50cy5wdXNoKF9BTklNQVRJT05fRU5EX1NUQVRFX1NUWUxFU19WQVIuc2V0KHRoaXMuX3N0YXRlc01hcFZhci5rZXkoX0FOSU1BVElPTl9ORVhUX1NUQVRFX1ZBUikpXG4gICAgICAgICAgICAgIC50b0RlY2xTdG10KCkpO1xuICAgICAgICAgIHN0YXRlbWVudHMucHVzaChuZXcgSWZTdG10KF9BTklNQVRJT05fRU5EX1NUQVRFX1NUWUxFU19WQVIuZXF1YWxzKE5VTExfRVhQUiksIFtfQU5JTUFUSU9OX0VORF9TVEFURV9TVFlMRVNfVkFSLnNldChfQU5JTUFUSU9OX0RFRkFVTFRfU1RBVEVfVkFSKS50b1N0bXQoKV0pKTtcbiAgICAgICAgICB2YXIgUkVOREVSX1NUWUxFU19GTiA9IGltcG9ydEV4cHIocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMucmVuZGVyU3R5bGVzKSk7XG4gICAgICAgICAgLy8gYmVmb3JlIHdlIHN0YXJ0IGFueSBhbmltYXRpb24gd2Ugd2FudCB0byBjbGVhciBvdXQgdGhlIHN0YXJ0aW5nXG4gICAgICAgICAgLy8gc3R5bGVzIGZyb20gdGhlIGVsZW1lbnQncyBzdHlsZSBwcm9wZXJ0eSAoc2luY2UgdGhleSB3ZXJlIHBsYWNlZFxuICAgICAgICAgIC8vIHRoZXJlIGF0IHRoZSBlbmQgb2YgdGhlIGxhc3QgYW5pbWF0aW9uXG4gICAgICAgICAgc3RhdGVtZW50cy5wdXNoKFJFTkRFUl9TVFlMRVNfRk5cbiAgICAgICAgICAgICAgLmNhbGxGbihbXG4gICAgICAgICAgICAgIF9BTklNQVRJT05fRkFDVE9SWV9FTEVNRU5UX1ZBUiwgX0FOSU1BVElPTl9GQUNUT1JZX1JFTkRFUkVSX1ZBUixcbiAgICAgICAgICAgICAgaW1wb3J0RXhwcihyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5jbGVhclN0eWxlcykpXG4gICAgICAgICAgICAgICAgICAuY2FsbEZuKFtfQU5JTUFUSU9OX1NUQVJUX1NUQVRFX1NUWUxFU19WQVJdKVxuICAgICAgICAgIF0pXG4gICAgICAgICAgICAgIC50b1N0bXQoKSk7XG4gICAgICAgICAgYXN0LnN0YXRlVHJhbnNpdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAodHJhbnNBc3QpIHsgcmV0dXJuIHN0YXRlbWVudHMucHVzaCh0cmFuc0FzdC52aXNpdChfdGhpcywgY29udGV4dCkpOyB9KTtcbiAgICAgICAgICAvLyB0aGlzIGNoZWNrIGVuc3VyZXMgdGhhdCB0aGUgYW5pbWF0aW9uIGZhY3RvcnkgYWx3YXlzIHJldHVybnMgYSBwbGF5ZXJcbiAgICAgICAgICAvLyBzbyB0aGF0IHRoZSBvbkRvbmUgY2FsbGJhY2sgY2FuIGJlIHVzZWQgZm9yIHRyYWNraW5nXG4gICAgICAgICAgc3RhdGVtZW50cy5wdXNoKG5ldyBJZlN0bXQoX0FOSU1BVElPTl9QTEFZRVJfVkFSLmVxdWFscyhOVUxMX0VYUFIpLCBbX0FOSU1BVElPTl9QTEFZRVJfVkFSXG4gICAgICAgICAgICAgICAgICAuc2V0KGltcG9ydEV4cHIocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuTm9PcEFuaW1hdGlvblBsYXllcikpLmluc3RhbnRpYXRlKFtdKSlcbiAgICAgICAgICAgICAgICAgIC50b1N0bXQoKV0pKTtcbiAgICAgICAgICAvLyBvbmNlIGNvbXBsZXRlIHdlIHdhbnQgdG8gYXBwbHkgdGhlIHN0eWxlcyBvbiB0aGUgZWxlbWVudFxuICAgICAgICAgIC8vIHNpbmNlIHRoZSBkZXN0aW5hdGlvbiBzdGF0ZSdzIHZhbHVlcyBzaG91bGQgcGVyc2lzdCBvbmNlXG4gICAgICAgICAgLy8gdGhlIGFuaW1hdGlvbiBzZXF1ZW5jZSBoYXMgY29tcGxldGVkLlxuICAgICAgICAgIHN0YXRlbWVudHMucHVzaChfQU5JTUFUSU9OX1BMQVlFUl9WQVJcbiAgICAgICAgICAgICAgLmNhbGxNZXRob2QoJ29uRG9uZScsIFtmbihbXSwgW1JFTkRFUl9TVFlMRVNfRk5cbiAgICAgICAgICAgICAgICAgICAgICAuY2FsbEZuKFtcbiAgICAgICAgICAgICAgICAgICAgICBfQU5JTUFUSU9OX0ZBQ1RPUllfRUxFTUVOVF9WQVIsIF9BTklNQVRJT05fRkFDVE9SWV9SRU5ERVJFUl9WQVIsXG4gICAgICAgICAgICAgICAgICAgICAgaW1wb3J0RXhwcihyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5wcmVwYXJlRmluYWxBbmltYXRpb25TdHlsZXMpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuY2FsbEZuKFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX0FOSU1BVElPTl9TVEFSVF9TVEFURV9TVFlMRVNfVkFSLCBfQU5JTUFUSU9OX0VORF9TVEFURV9TVFlMRVNfVkFSXG4gICAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgICAgLnRvU3RtdCgpXSldKVxuICAgICAgICAgICAgICAudG9TdG10KCkpO1xuICAgICAgICAgIHN0YXRlbWVudHMucHVzaChfQU5JTUFUSU9OX0ZBQ1RPUllfVklFV19DT05URVhUXG4gICAgICAgICAgICAgIC5jYWxsTWV0aG9kKCdxdWV1ZUFuaW1hdGlvbicsIFtcbiAgICAgICAgICAgICAgX0FOSU1BVElPTl9GQUNUT1JZX0VMRU1FTlRfVkFSLCBsaXRlcmFsKHRoaXMuYW5pbWF0aW9uTmFtZSksXG4gICAgICAgICAgICAgIF9BTklNQVRJT05fUExBWUVSX1ZBUlxuICAgICAgICAgIF0pXG4gICAgICAgICAgICAgIC50b1N0bXQoKSk7XG4gICAgICAgICAgc3RhdGVtZW50cy5wdXNoKG5ldyBSZXR1cm5TdGF0ZW1lbnQoaW1wb3J0RXhwcihyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5BbmltYXRpb25UcmFuc2l0aW9uKSkuaW5zdGFudGlhdGUoW1xuICAgICAgICAgICAgICBfQU5JTUFUSU9OX1BMQVlFUl9WQVIsIF9BTklNQVRJT05fQ1VSUkVOVF9TVEFURV9WQVIsIF9BTklNQVRJT05fTkVYVF9TVEFURV9WQVIsXG4gICAgICAgICAgICAgIF9BTklNQVRJT05fVElNRV9WQVJcbiAgICAgICAgICBdKSkpO1xuICAgICAgICAgIHJldHVybiBmbihbXG4gICAgICAgICAgICAgIG5ldyBGblBhcmFtKF9BTklNQVRJT05fRkFDVE9SWV9WSUVXX1ZBUi5uYW1lLCBpbXBvcnRUeXBlKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLkFwcFZpZXcpLCBbRFlOQU1JQ19UWVBFXSkpLFxuICAgICAgICAgICAgICBuZXcgRm5QYXJhbShfQU5JTUFUSU9OX0ZBQ1RPUllfRUxFTUVOVF9WQVIubmFtZSwgRFlOQU1JQ19UWVBFKSxcbiAgICAgICAgICAgICAgbmV3IEZuUGFyYW0oX0FOSU1BVElPTl9DVVJSRU5UX1NUQVRFX1ZBUi5uYW1lLCBEWU5BTUlDX1RZUEUpLFxuICAgICAgICAgICAgICBuZXcgRm5QYXJhbShfQU5JTUFUSU9OX05FWFRfU1RBVEVfVkFSLm5hbWUsIERZTkFNSUNfVFlQRSlcbiAgICAgICAgICBdLCBzdGF0ZW1lbnRzLCBpbXBvcnRUeXBlKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLkFuaW1hdGlvblRyYW5zaXRpb24pKSk7XG4gICAgICB9O1xuICAgICAgX0FuaW1hdGlvbkJ1aWxkZXIucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKGFzdCkge1xuICAgICAgICAgIHZhciBjb250ZXh0ID0gbmV3IF9BbmltYXRpb25CdWlsZGVyQ29udGV4dCgpO1xuICAgICAgICAgIHZhciBmblN0YXRlbWVudCA9IGFzdC52aXNpdCh0aGlzLCBjb250ZXh0KS50b0RlY2xTdG10KHRoaXMuX2ZuVmFyTmFtZSk7XG4gICAgICAgICAgdmFyIGZuVmFyaWFibGUgPSB2YXJpYWJsZSh0aGlzLl9mblZhck5hbWUpO1xuICAgICAgICAgIHZhciBsb29rdXBNYXAgPSBbXTtcbiAgICAgICAgICBPYmplY3Qua2V5cyhjb250ZXh0LnN0YXRlTWFwLnN0YXRlcykuZm9yRWFjaChmdW5jdGlvbiAoc3RhdGVOYW1lKSB7XG4gICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGNvbnRleHQuc3RhdGVNYXAuc3RhdGVzW3N0YXRlTmFtZV07XG4gICAgICAgICAgICAgIHZhciB2YXJpYWJsZVZhbHVlID0gRU1QVFlfTUFQO1xuICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgdmFyIHN0eWxlTWFwXzEgPSBbXTtcbiAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHZhbHVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgc3R5bGVNYXBfMS5wdXNoKFtrZXksIGxpdGVyYWwodmFsdWVba2V5XSldKTsgfSk7XG4gICAgICAgICAgICAgICAgICB2YXJpYWJsZVZhbHVlID0gbGl0ZXJhbE1hcChzdHlsZU1hcF8xKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsb29rdXBNYXAucHVzaChbc3RhdGVOYW1lLCB2YXJpYWJsZVZhbHVlXSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIGNvbXBpbGVkU3RhdGVzTWFwU3RtdCA9IHRoaXMuX3N0YXRlc01hcFZhci5zZXQobGl0ZXJhbE1hcChsb29rdXBNYXApKS50b0RlY2xTdG10KCk7XG4gICAgICAgICAgdmFyIHN0YXRlbWVudHMgPSBbY29tcGlsZWRTdGF0ZXNNYXBTdG10LCBmblN0YXRlbWVudF07XG4gICAgICAgICAgcmV0dXJuIG5ldyBBbmltYXRpb25FbnRyeUNvbXBpbGVSZXN1bHQodGhpcy5hbmltYXRpb25OYW1lLCBzdGF0ZW1lbnRzLCBmblZhcmlhYmxlKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gX0FuaW1hdGlvbkJ1aWxkZXI7XG4gIH0oKSk7XG4gIHZhciBfQW5pbWF0aW9uQnVpbGRlckNvbnRleHQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gX0FuaW1hdGlvbkJ1aWxkZXJDb250ZXh0KCkge1xuICAgICAgICAgIHRoaXMuc3RhdGVNYXAgPSBuZXcgX0FuaW1hdGlvbkJ1aWxkZXJTdGF0ZU1hcCgpO1xuICAgICAgICAgIHRoaXMuZW5kU3RhdGVBbmltYXRlU3RlcCA9IG51bGw7XG4gICAgICAgICAgdGhpcy5pc0V4cGVjdGluZ0ZpcnN0U3R5bGVTdGVwID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy50b3RhbFRyYW5zaXRpb25UaW1lID0gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfQW5pbWF0aW9uQnVpbGRlckNvbnRleHQ7XG4gIH0oKSk7XG4gIHZhciBfQW5pbWF0aW9uQnVpbGRlclN0YXRlTWFwID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIF9BbmltYXRpb25CdWlsZGVyU3RhdGVNYXAoKSB7XG4gICAgICAgICAgdGhpcy5fc3RhdGVzID0ge307XG4gICAgICB9XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX0FuaW1hdGlvbkJ1aWxkZXJTdGF0ZU1hcC5wcm90b3R5cGUsIFwic3RhdGVzXCIsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3N0YXRlczsgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBfQW5pbWF0aW9uQnVpbGRlclN0YXRlTWFwLnByb3RvdHlwZS5yZWdpc3RlclN0YXRlID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHsgdmFsdWUgPSBudWxsOyB9XG4gICAgICAgICAgdmFyIGV4aXN0aW5nRW50cnkgPSB0aGlzLl9zdGF0ZXNbbmFtZV07XG4gICAgICAgICAgaWYgKCFleGlzdGluZ0VudHJ5KSB7XG4gICAgICAgICAgICAgIHRoaXMuX3N0YXRlc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gX0FuaW1hdGlvbkJ1aWxkZXJTdGF0ZU1hcDtcbiAgfSgpKTtcbiAgZnVuY3Rpb24gX2NvbXBhcmVUb0FuaW1hdGlvblN0YXRlRXhwcih2YWx1ZSwgYW5pbWF0aW9uU3RhdGUpIHtcbiAgICAgIHZhciBlbXB0eVN0YXRlTGl0ZXJhbCA9IGxpdGVyYWwoRU1QVFlfQU5JTUFUSU9OX1NUQVRFKTtcbiAgICAgIHN3aXRjaCAoYW5pbWF0aW9uU3RhdGUpIHtcbiAgICAgICAgICBjYXNlIEVNUFRZX0FOSU1BVElPTl9TVEFURTpcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmVxdWFscyhlbXB0eVN0YXRlTGl0ZXJhbCk7XG4gICAgICAgICAgY2FzZSBBTllfU1RBVEU6XG4gICAgICAgICAgICAgIHJldHVybiBsaXRlcmFsKHRydWUpO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5lcXVhbHMobGl0ZXJhbChhbmltYXRpb25TdGF0ZSkpO1xuICAgICAgfVxuICB9XG4gIGZ1bmN0aW9uIF9pc0VuZFN0YXRlQW5pbWF0ZVN0ZXAoc3RlcCkge1xuICAgICAgLy8gdGhlIGZpbmFsIGFuaW1hdGlvbiBzdGVwIGlzIGNoYXJhY3Rlcml6ZWQgYnkgaGF2aW5nIG9ubHkgVFdPXG4gICAgICAvLyBrZXlmcmFtZSB2YWx1ZXMgYW5kIGl0IG11c3QgaGF2ZSB6ZXJvIHN0eWxlcyBmb3IgYm90aCBrZXlmcmFtZXNcbiAgICAgIGlmIChzdGVwIGluc3RhbmNlb2YgQW5pbWF0aW9uU3RlcEFzdCAmJiBzdGVwLmR1cmF0aW9uID4gMCAmJiBzdGVwLmtleWZyYW1lcy5sZW5ndGggPT0gMikge1xuICAgICAgICAgIHZhciBzdHlsZXMxID0gX2dldFN0eWxlc0FycmF5KHN0ZXAua2V5ZnJhbWVzWzBdKVswXTtcbiAgICAgICAgICB2YXIgc3R5bGVzMiA9IF9nZXRTdHlsZXNBcnJheShzdGVwLmtleWZyYW1lc1sxXSlbMF07XG4gICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHN0eWxlczEpLmxlbmd0aCA9PT0gMCAmJiBPYmplY3Qua2V5cyhzdHlsZXMyKS5sZW5ndGggPT09IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZnVuY3Rpb24gX2dldFN0eWxlc0FycmF5KG9iaikge1xuICAgICAgcmV0dXJuIG9iai5zdHlsZXMuc3R5bGVzO1xuICB9XG5cbiAgdmFyIFN0eWxlc0NvbGxlY3Rpb25FbnRyeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBTdHlsZXNDb2xsZWN0aW9uRW50cnkodGltZSwgdmFsdWUpIHtcbiAgICAgICAgICB0aGlzLnRpbWUgPSB0aW1lO1xuICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIFN0eWxlc0NvbGxlY3Rpb25FbnRyeS5wcm90b3R5cGUubWF0Y2hlcyA9IGZ1bmN0aW9uICh0aW1lLCB2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiB0aW1lID09IHRoaXMudGltZSAmJiB2YWx1ZSA9PSB0aGlzLnZhbHVlO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBTdHlsZXNDb2xsZWN0aW9uRW50cnk7XG4gIH0oKSk7XG4gIHZhciBTdHlsZXNDb2xsZWN0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFN0eWxlc0NvbGxlY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy5zdHlsZXMgPSB7fTtcbiAgICAgIH1cbiAgICAgIFN0eWxlc0NvbGxlY3Rpb24ucHJvdG90eXBlLmluc2VydEF0VGltZSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSwgdGltZSwgdmFsdWUpIHtcbiAgICAgICAgICB2YXIgdHVwbGUgPSBuZXcgU3R5bGVzQ29sbGVjdGlvbkVudHJ5KHRpbWUsIHZhbHVlKTtcbiAgICAgICAgICB2YXIgZW50cmllcyA9IHRoaXMuc3R5bGVzW3Byb3BlcnR5XTtcbiAgICAgICAgICBpZiAoIWlzUHJlc2VudChlbnRyaWVzKSkge1xuICAgICAgICAgICAgICBlbnRyaWVzID0gdGhpcy5zdHlsZXNbcHJvcGVydHldID0gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGluc2VydCB0aGlzIGF0IHRoZSByaWdodCBzdG9wIGluIHRoZSBhcnJheVxuICAgICAgICAgIC8vIHRoaXMgd2F5IHdlIGNhbiBrZWVwIGl0IHNvcnRlZFxuICAgICAgICAgIHZhciBpbnNlcnRpb25JbmRleCA9IDA7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IGVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgaWYgKGVudHJpZXNbaV0udGltZSA8PSB0aW1lKSB7XG4gICAgICAgICAgICAgICAgICBpbnNlcnRpb25JbmRleCA9IGkgKyAxO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgTGlzdFdyYXBwZXIuaW5zZXJ0KGVudHJpZXMsIGluc2VydGlvbkluZGV4LCB0dXBsZSk7XG4gICAgICB9O1xuICAgICAgU3R5bGVzQ29sbGVjdGlvbi5wcm90b3R5cGUuZ2V0QnlJbmRleCA9IGZ1bmN0aW9uIChwcm9wZXJ0eSwgaW5kZXgpIHtcbiAgICAgICAgICB2YXIgaXRlbXMgPSB0aGlzLnN0eWxlc1twcm9wZXJ0eV07XG4gICAgICAgICAgaWYgKGlzUHJlc2VudChpdGVtcykpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGluZGV4ID49IGl0ZW1zLmxlbmd0aCA/IG51bGwgOiBpdGVtc1tpbmRleF07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIFN0eWxlc0NvbGxlY3Rpb24ucHJvdG90eXBlLmluZGV4T2ZBdE9yQmVmb3JlVGltZSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSwgdGltZSkge1xuICAgICAgICAgIHZhciBlbnRyaWVzID0gdGhpcy5zdHlsZXNbcHJvcGVydHldO1xuICAgICAgICAgIGlmIChpc1ByZXNlbnQoZW50cmllcykpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgIGlmIChlbnRyaWVzW2ldLnRpbWUgPD0gdGltZSlcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICByZXR1cm4gU3R5bGVzQ29sbGVjdGlvbjtcbiAgfSgpKTtcblxuICAvKipcbiAgICogQGxpY2Vuc2VcbiAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAqXG4gICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICovXG4gIHZhciBfX2V4dGVuZHMkMTMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gIH07XG4gIHZhciBfSU5JVElBTF9LRVlGUkFNRSA9IDA7XG4gIHZhciBfVEVSTUlOQUxfS0VZRlJBTUUgPSAxO1xuICB2YXIgX09ORV9TRUNPTkQgPSAxMDAwO1xuICB2YXIgQW5pbWF0aW9uUGFyc2VFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMTMoQW5pbWF0aW9uUGFyc2VFcnJvciwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvblBhcnNlRXJyb3IobWVzc2FnZSkge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIG51bGwsIG1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgQW5pbWF0aW9uUGFyc2VFcnJvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBcIlwiICsgdGhpcy5tc2c7IH07XG4gICAgICByZXR1cm4gQW5pbWF0aW9uUGFyc2VFcnJvcjtcbiAgfShQYXJzZUVycm9yKSk7XG4gIHZhciBBbmltYXRpb25FbnRyeVBhcnNlUmVzdWx0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvbkVudHJ5UGFyc2VSZXN1bHQoYXN0LCBlcnJvcnMpIHtcbiAgICAgICAgICB0aGlzLmFzdCA9IGFzdDtcbiAgICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICAgIH1cbiAgICAgIHJldHVybiBBbmltYXRpb25FbnRyeVBhcnNlUmVzdWx0O1xuICB9KCkpO1xuICB2YXIgQW5pbWF0aW9uUGFyc2VyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvblBhcnNlcigpIHtcbiAgICAgIH1cbiAgICAgIEFuaW1hdGlvblBhcnNlci5wcm90b3R5cGUucGFyc2VDb21wb25lbnQgPSBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnQudHlwZS5uYW1lO1xuICAgICAgICAgIHZhciBhbmltYXRpb25UcmlnZ2VyTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgdmFyIGFzdHMgPSBjb21wb25lbnQudGVtcGxhdGUuYW5pbWF0aW9ucy5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICAgIHZhciByZXN1bHQgPSBfdGhpcy5wYXJzZUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICAgICAgdmFyIGFzdCA9IHJlc3VsdC5hc3Q7XG4gICAgICAgICAgICAgIHZhciB0cmlnZ2VyTmFtZSA9IGFzdC5uYW1lO1xuICAgICAgICAgICAgICBpZiAoYW5pbWF0aW9uVHJpZ2dlck5hbWVzLmhhcyh0cmlnZ2VyTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5lcnJvcnMucHVzaChuZXcgQW5pbWF0aW9uUGFyc2VFcnJvcihcIlRoZSBhbmltYXRpb24gdHJpZ2dlciBcXFwiXCIgKyB0cmlnZ2VyTmFtZSArIFwiXFxcIiBoYXMgYWxyZWFkeSBiZWVuIHJlZ2lzdGVyZWQgZm9yIHRoZSBcIiArIGNvbXBvbmVudE5hbWUgKyBcIiBjb21wb25lbnRcIikpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uVHJpZ2dlck5hbWVzLmFkZCh0cmlnZ2VyTmFtZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHJlc3VsdC5lcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgdmFyIGVycm9yTWVzc2FnZV8xID0gXCItIFVuYWJsZSB0byBwYXJzZSB0aGUgYW5pbWF0aW9uIHNlcXVlbmNlIGZvciBcXFwiXCIgKyB0cmlnZ2VyTmFtZSArIFwiXFxcIiBvbiB0aGUgXCIgKyBjb21wb25lbnROYW1lICsgXCIgY29tcG9uZW50IGR1ZSB0byB0aGUgZm9sbG93aW5nIGVycm9yczpcIjtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5lcnJvcnMuZm9yRWFjaChmdW5jdGlvbiAoZXJyb3IpIHsgZXJyb3JNZXNzYWdlXzEgKz0gJ1xcbi0tICcgKyBlcnJvci5tc2c7IH0pO1xuICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZXJyb3JNZXNzYWdlXzEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBhc3Q7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHZhciBlcnJvclN0cmluZyA9IGVycm9ycy5qb2luKCdcXG4nKTtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQW5pbWF0aW9uIHBhcnNlIGVycm9yczpcXG5cIiArIGVycm9yU3RyaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGFzdHM7XG4gICAgICB9O1xuICAgICAgQW5pbWF0aW9uUGFyc2VyLnByb3RvdHlwZS5wYXJzZUVudHJ5ID0gZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgdmFyIGVycm9ycyA9IFtdO1xuICAgICAgICAgIHZhciBzdGF0ZVN0eWxlcyA9IHt9O1xuICAgICAgICAgIHZhciB0cmFuc2l0aW9ucyA9IFtdO1xuICAgICAgICAgIHZhciBzdGF0ZURlY2xhcmF0aW9uQXN0cyA9IFtdO1xuICAgICAgICAgIGVudHJ5LmRlZmluaXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGRlZikge1xuICAgICAgICAgICAgICBpZiAoZGVmIGluc3RhbmNlb2YgQ29tcGlsZUFuaW1hdGlvblN0YXRlRGVjbGFyYXRpb25NZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgX3BhcnNlQW5pbWF0aW9uRGVjbGFyYXRpb25TdGF0ZXMoZGVmLCBlcnJvcnMpLmZvckVhY2goZnVuY3Rpb24gKGFzdCkge1xuICAgICAgICAgICAgICAgICAgICAgIHN0YXRlRGVjbGFyYXRpb25Bc3RzLnB1c2goYXN0KTtcbiAgICAgICAgICAgICAgICAgICAgICBzdGF0ZVN0eWxlc1thc3Quc3RhdGVOYW1lXSA9IGFzdC5zdHlsZXM7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb25zLnB1c2goZGVmKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBzdGF0ZVRyYW5zaXRpb25Bc3RzID0gdHJhbnNpdGlvbnMubWFwKGZ1bmN0aW9uICh0cmFuc0RlZikgeyByZXR1cm4gX3BhcnNlQW5pbWF0aW9uU3RhdGVUcmFuc2l0aW9uKHRyYW5zRGVmLCBzdGF0ZVN0eWxlcywgZXJyb3JzKTsgfSk7XG4gICAgICAgICAgdmFyIGFzdCA9IG5ldyBBbmltYXRpb25FbnRyeUFzdChlbnRyeS5uYW1lLCBzdGF0ZURlY2xhcmF0aW9uQXN0cywgc3RhdGVUcmFuc2l0aW9uQXN0cyk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBBbmltYXRpb25FbnRyeVBhcnNlUmVzdWx0KGFzdCwgZXJyb3JzKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gQW5pbWF0aW9uUGFyc2VyO1xuICB9KCkpO1xuICBmdW5jdGlvbiBfcGFyc2VBbmltYXRpb25EZWNsYXJhdGlvblN0YXRlcyhzdGF0ZU1ldGFkYXRhLCBlcnJvcnMpIHtcbiAgICAgIHZhciBzdHlsZVZhbHVlcyA9IFtdO1xuICAgICAgc3RhdGVNZXRhZGF0YS5zdHlsZXMuc3R5bGVzLmZvckVhY2goZnVuY3Rpb24gKHN0eWxlc0VudHJ5KSB7XG4gICAgICAgICAgLy8gVE9ETyAobWF0c2tvKTogY2hhbmdlIHRoaXMgd2hlbiB3ZSBnZXQgQ1NTIGNsYXNzIGludGVncmF0aW9uIHN1cHBvcnRcbiAgICAgICAgICBpZiAodHlwZW9mIHN0eWxlc0VudHJ5ID09PSAnb2JqZWN0JyAmJiBzdHlsZXNFbnRyeSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBzdHlsZVZhbHVlcy5wdXNoKHN0eWxlc0VudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBBbmltYXRpb25QYXJzZUVycm9yKFwiU3RhdGUgYmFzZWQgYW5pbWF0aW9ucyBjYW5ub3QgY29udGFpbiByZWZlcmVuY2VzIHRvIG90aGVyIHN0YXRlc1wiKSk7XG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB2YXIgZGVmU3R5bGVzID0gbmV3IEFuaW1hdGlvblN0eWxlc0FzdChzdHlsZVZhbHVlcyk7XG4gICAgICB2YXIgc3RhdGVzID0gc3RhdGVNZXRhZGF0YS5zdGF0ZU5hbWVFeHByLnNwbGl0KC9cXHMqLFxccyovKTtcbiAgICAgIHJldHVybiBzdGF0ZXMubWFwKGZ1bmN0aW9uIChzdGF0ZSkgeyByZXR1cm4gbmV3IEFuaW1hdGlvblN0YXRlRGVjbGFyYXRpb25Bc3Qoc3RhdGUsIGRlZlN0eWxlcyk7IH0pO1xuICB9XG4gIGZ1bmN0aW9uIF9wYXJzZUFuaW1hdGlvblN0YXRlVHJhbnNpdGlvbih0cmFuc2l0aW9uU3RhdGVNZXRhZGF0YSwgc3RhdGVTdHlsZXMsIGVycm9ycykge1xuICAgICAgdmFyIHN0eWxlcyA9IG5ldyBTdHlsZXNDb2xsZWN0aW9uKCk7XG4gICAgICB2YXIgdHJhbnNpdGlvbkV4cHJzID0gW107XG4gICAgICB2YXIgdHJhbnNpdGlvblN0YXRlcyA9IHRyYW5zaXRpb25TdGF0ZU1ldGFkYXRhLnN0YXRlQ2hhbmdlRXhwci5zcGxpdCgvXFxzKixcXHMqLyk7XG4gICAgICB0cmFuc2l0aW9uU3RhdGVzLmZvckVhY2goZnVuY3Rpb24gKGV4cHIpIHsgdHJhbnNpdGlvbkV4cHJzLnB1c2guYXBwbHkodHJhbnNpdGlvbkV4cHJzLCBfcGFyc2VBbmltYXRpb25UcmFuc2l0aW9uRXhwcihleHByLCBlcnJvcnMpKTsgfSk7XG4gICAgICB2YXIgZW50cnkgPSBfbm9ybWFsaXplQW5pbWF0aW9uRW50cnkodHJhbnNpdGlvblN0YXRlTWV0YWRhdGEuc3RlcHMpO1xuICAgICAgdmFyIGFuaW1hdGlvbiA9IF9ub3JtYWxpemVTdHlsZVN0ZXBzKGVudHJ5LCBzdGF0ZVN0eWxlcywgZXJyb3JzKTtcbiAgICAgIHZhciBhbmltYXRpb25Bc3QgPSBfcGFyc2VUcmFuc2l0aW9uQW5pbWF0aW9uKGFuaW1hdGlvbiwgMCwgc3R5bGVzLCBzdGF0ZVN0eWxlcywgZXJyb3JzKTtcbiAgICAgIGlmIChlcnJvcnMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICBfZmlsbEFuaW1hdGlvbkFzdFN0YXJ0aW5nS2V5ZnJhbWVzKGFuaW1hdGlvbkFzdCwgc3R5bGVzLCBlcnJvcnMpO1xuICAgICAgfVxuICAgICAgdmFyIHN0ZXBzQXN0ID0gKGFuaW1hdGlvbkFzdCBpbnN0YW5jZW9mIEFuaW1hdGlvbldpdGhTdGVwc0FzdCkgP1xuICAgICAgICAgIGFuaW1hdGlvbkFzdCA6XG4gICAgICAgICAgbmV3IEFuaW1hdGlvblNlcXVlbmNlQXN0KFthbmltYXRpb25Bc3RdKTtcbiAgICAgIHJldHVybiBuZXcgQW5pbWF0aW9uU3RhdGVUcmFuc2l0aW9uQXN0KHRyYW5zaXRpb25FeHBycywgc3RlcHNBc3QpO1xuICB9XG4gIGZ1bmN0aW9uIF9wYXJzZUFuaW1hdGlvbkFsaWFzKGFsaWFzLCBlcnJvcnMpIHtcbiAgICAgIHN3aXRjaCAoYWxpYXMpIHtcbiAgICAgICAgICBjYXNlICc6ZW50ZXInOlxuICAgICAgICAgICAgICByZXR1cm4gJ3ZvaWQgPT4gKic7XG4gICAgICAgICAgY2FzZSAnOmxlYXZlJzpcbiAgICAgICAgICAgICAgcmV0dXJuICcqID0+IHZvaWQnO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBBbmltYXRpb25QYXJzZUVycm9yKFwidGhlIHRyYW5zaXRpb24gYWxpYXMgdmFsdWUgXFxcIlwiICsgYWxpYXMgKyBcIlxcXCIgaXMgbm90IHN1cHBvcnRlZFwiKSk7XG4gICAgICAgICAgICAgIHJldHVybiAnKiA9PiAqJztcbiAgICAgIH1cbiAgfVxuICBmdW5jdGlvbiBfcGFyc2VBbmltYXRpb25UcmFuc2l0aW9uRXhwcihldmVudFN0ciwgZXJyb3JzKSB7XG4gICAgICB2YXIgZXhwcmVzc2lvbnMgPSBbXTtcbiAgICAgIGlmIChldmVudFN0clswXSA9PSAnOicpIHtcbiAgICAgICAgICBldmVudFN0ciA9IF9wYXJzZUFuaW1hdGlvbkFsaWFzKGV2ZW50U3RyLCBlcnJvcnMpO1xuICAgICAgfVxuICAgICAgdmFyIG1hdGNoID0gZXZlbnRTdHIubWF0Y2goL14oXFwqfFstXFx3XSspXFxzKig8P1s9LV0+KVxccyooXFwqfFstXFx3XSspJC8pO1xuICAgICAgaWYgKCFpc1ByZXNlbnQobWF0Y2gpIHx8IG1hdGNoLmxlbmd0aCA8IDQpIHtcbiAgICAgICAgICBlcnJvcnMucHVzaChuZXcgQW5pbWF0aW9uUGFyc2VFcnJvcihcInRoZSBwcm92aWRlZCBcIiArIGV2ZW50U3RyICsgXCIgaXMgbm90IG9mIGEgc3VwcG9ydGVkIGZvcm1hdFwiKSk7XG4gICAgICAgICAgcmV0dXJuIGV4cHJlc3Npb25zO1xuICAgICAgfVxuICAgICAgdmFyIGZyb21TdGF0ZSA9IG1hdGNoWzFdO1xuICAgICAgdmFyIHNlcGFyYXRvciA9IG1hdGNoWzJdO1xuICAgICAgdmFyIHRvU3RhdGUgPSBtYXRjaFszXTtcbiAgICAgIGV4cHJlc3Npb25zLnB1c2gobmV3IEFuaW1hdGlvblN0YXRlVHJhbnNpdGlvbkV4cHJlc3Npb24oZnJvbVN0YXRlLCB0b1N0YXRlKSk7XG4gICAgICB2YXIgaXNGdWxsQW55U3RhdGVFeHByID0gZnJvbVN0YXRlID09IEFOWV9TVEFURSAmJiB0b1N0YXRlID09IEFOWV9TVEFURTtcbiAgICAgIGlmIChzZXBhcmF0b3JbMF0gPT0gJzwnICYmICFpc0Z1bGxBbnlTdGF0ZUV4cHIpIHtcbiAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKG5ldyBBbmltYXRpb25TdGF0ZVRyYW5zaXRpb25FeHByZXNzaW9uKHRvU3RhdGUsIGZyb21TdGF0ZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGV4cHJlc3Npb25zO1xuICB9XG4gIGZ1bmN0aW9uIF9ub3JtYWxpemVBbmltYXRpb25FbnRyeShlbnRyeSkge1xuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZW50cnkpID8gbmV3IENvbXBpbGVBbmltYXRpb25TZXF1ZW5jZU1ldGFkYXRhKGVudHJ5KSA6IGVudHJ5O1xuICB9XG4gIGZ1bmN0aW9uIF9ub3JtYWxpemVTdHlsZU1ldGFkYXRhKGVudHJ5LCBzdGF0ZVN0eWxlcywgZXJyb3JzKSB7XG4gICAgICB2YXIgbm9ybWFsaXplZFN0eWxlcyA9IFtdO1xuICAgICAgZW50cnkuc3R5bGVzLmZvckVhY2goZnVuY3Rpb24gKHN0eWxlRW50cnkpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHN0eWxlRW50cnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIExpc3RXcmFwcGVyLmFkZEFsbChub3JtYWxpemVkU3R5bGVzLCBfcmVzb2x2ZVN0eWxlc0Zyb21TdGF0ZShzdHlsZUVudHJ5LCBzdGF0ZVN0eWxlcywgZXJyb3JzKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBub3JtYWxpemVkU3R5bGVzLnB1c2goc3R5bGVFbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbm9ybWFsaXplZFN0eWxlcztcbiAgfVxuICBmdW5jdGlvbiBfbm9ybWFsaXplU3R5bGVTdGVwcyhlbnRyeSwgc3RhdGVTdHlsZXMsIGVycm9ycykge1xuICAgICAgdmFyIHN0ZXBzID0gX25vcm1hbGl6ZVN0eWxlU3RlcEVudHJ5KGVudHJ5LCBzdGF0ZVN0eWxlcywgZXJyb3JzKTtcbiAgICAgIHJldHVybiAoZW50cnkgaW5zdGFuY2VvZiBDb21waWxlQW5pbWF0aW9uR3JvdXBNZXRhZGF0YSkgP1xuICAgICAgICAgIG5ldyBDb21waWxlQW5pbWF0aW9uR3JvdXBNZXRhZGF0YShzdGVwcykgOlxuICAgICAgICAgIG5ldyBDb21waWxlQW5pbWF0aW9uU2VxdWVuY2VNZXRhZGF0YShzdGVwcyk7XG4gIH1cbiAgZnVuY3Rpb24gX21lcmdlQW5pbWF0aW9uU3R5bGVzKHN0eWxlc0xpc3QsIG5ld0l0ZW0pIHtcbiAgICAgIGlmICh0eXBlb2YgbmV3SXRlbSA9PT0gJ29iamVjdCcgJiYgbmV3SXRlbSAhPT0gbnVsbCAmJiBzdHlsZXNMaXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgbGFzdEluZGV4ID0gc3R5bGVzTGlzdC5sZW5ndGggLSAxO1xuICAgICAgICAgIHZhciBsYXN0SXRlbSA9IHN0eWxlc0xpc3RbbGFzdEluZGV4XTtcbiAgICAgICAgICBpZiAodHlwZW9mIGxhc3RJdGVtID09PSAnb2JqZWN0JyAmJiBsYXN0SXRlbSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBzdHlsZXNMaXN0W2xhc3RJbmRleF0gPSBTdHJpbmdNYXBXcmFwcGVyLm1lcmdlKGxhc3RJdGVtLCBuZXdJdGVtKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0eWxlc0xpc3QucHVzaChuZXdJdGVtKTtcbiAgfVxuICBmdW5jdGlvbiBfbm9ybWFsaXplU3R5bGVTdGVwRW50cnkoZW50cnksIHN0YXRlU3R5bGVzLCBlcnJvcnMpIHtcbiAgICAgIHZhciBzdGVwcztcbiAgICAgIGlmIChlbnRyeSBpbnN0YW5jZW9mIENvbXBpbGVBbmltYXRpb25XaXRoU3RlcHNNZXRhZGF0YSkge1xuICAgICAgICAgIHN0ZXBzID0gZW50cnkuc3RlcHM7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gW2VudHJ5XTtcbiAgICAgIH1cbiAgICAgIHZhciBuZXdTdGVwcyA9IFtdO1xuICAgICAgdmFyIGNvbWJpbmVkU3R5bGVzO1xuICAgICAgc3RlcHMuZm9yRWFjaChmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgICAgIGlmIChzdGVwIGluc3RhbmNlb2YgQ29tcGlsZUFuaW1hdGlvblN0eWxlTWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgLy8gdGhpcyBvY2N1cnMgd2hlbiBhIHN0eWxlIHN0ZXAgaXMgZm9sbG93ZWQgYnkgYSBwcmV2aW91cyBzdHlsZSBzdGVwXG4gICAgICAgICAgICAgIC8vIG9yIHdoZW4gdGhlIGZpcnN0IHN0eWxlIHN0ZXAgaXMgcnVuLiBXZSB3YW50IHRvIGNvbmNhdGVuYXRlIGFsbCBzdWJzZXF1ZW50XG4gICAgICAgICAgICAgIC8vIHN0eWxlIHN0ZXBzIHRvZ2V0aGVyIGludG8gYSBzaW5nbGUgc3R5bGUgc3RlcCBzdWNoIHRoYXQgd2UgaGF2ZSB0aGUgY29ycmVjdFxuICAgICAgICAgICAgICAvLyBzdGFydGluZyBrZXlmcmFtZSBkYXRhIHRvIHBhc3MgaW50byB0aGUgYW5pbWF0aW9uIHBsYXllci5cbiAgICAgICAgICAgICAgaWYgKCFpc1ByZXNlbnQoY29tYmluZWRTdHlsZXMpKSB7XG4gICAgICAgICAgICAgICAgICBjb21iaW5lZFN0eWxlcyA9IFtdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF9ub3JtYWxpemVTdHlsZU1ldGFkYXRhKHN0ZXAsIHN0YXRlU3R5bGVzLCBlcnJvcnMpXG4gICAgICAgICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHsgX21lcmdlQW5pbWF0aW9uU3R5bGVzKGNvbWJpbmVkU3R5bGVzLCBlbnRyeSk7IH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gaXQgaXMgaW1wb3J0YW50IHRoYXQgd2UgY3JlYXRlIGEgbWV0YWRhdGEgZW50cnkgb2YgdGhlIGNvbWJpbmVkIHN0eWxlc1xuICAgICAgICAgICAgICAvLyBiZWZvcmUgd2UgZ28gb24gYW4gcHJvY2VzcyB0aGUgYW5pbWF0ZSwgc2VxdWVuY2Ugb3IgZ3JvdXAgbWV0YWRhdGEgc3RlcHMuXG4gICAgICAgICAgICAgIC8vIFRoaXMgd2lsbCBlbnN1cmUgdGhhdCB0aGUgQVNUIHdpbGwgaGF2ZSB0aGUgcHJldmlvdXMgc3R5bGVzIHBhaW50ZWQgb25cbiAgICAgICAgICAgICAgLy8gc2NyZWVuIGJlZm9yZSBhbnkgZnVydGhlciBhbmltYXRpb25zIHRoYXQgdXNlIHRoZSBzdHlsZXMgdGFrZSBwbGFjZS5cbiAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudChjb21iaW5lZFN0eWxlcykpIHtcbiAgICAgICAgICAgICAgICAgIG5ld1N0ZXBzLnB1c2gobmV3IENvbXBpbGVBbmltYXRpb25TdHlsZU1ldGFkYXRhKDAsIGNvbWJpbmVkU3R5bGVzKSk7XG4gICAgICAgICAgICAgICAgICBjb21iaW5lZFN0eWxlcyA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHN0ZXAgaW5zdGFuY2VvZiBDb21waWxlQW5pbWF0aW9uQW5pbWF0ZU1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAvLyB3ZSBkbyBub3QgcmVjdXJzZSBpbnRvIENvbXBpbGVBbmltYXRpb25BbmltYXRlTWV0YWRhdGEgc2luY2VcbiAgICAgICAgICAgICAgICAgIC8vIHRob3NlIHN0eWxlIHN0ZXBzIGFyZSBub3QgZ29pbmcgdG8gYmUgc3F1YXNoZWRcbiAgICAgICAgICAgICAgICAgIHZhciBhbmltYXRlU3R5bGVWYWx1ZSA9IHN0ZXAuc3R5bGVzO1xuICAgICAgICAgICAgICAgICAgaWYgKGFuaW1hdGVTdHlsZVZhbHVlIGluc3RhbmNlb2YgQ29tcGlsZUFuaW1hdGlvblN0eWxlTWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBhbmltYXRlU3R5bGVWYWx1ZS5zdHlsZXMgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICBfbm9ybWFsaXplU3R5bGVNZXRhZGF0YShhbmltYXRlU3R5bGVWYWx1ZSwgc3RhdGVTdHlsZXMsIGVycm9ycyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIGlmIChhbmltYXRlU3R5bGVWYWx1ZSBpbnN0YW5jZW9mIENvbXBpbGVBbmltYXRpb25LZXlmcmFtZXNTZXF1ZW5jZU1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgYW5pbWF0ZVN0eWxlVmFsdWUuc3RlcHMuZm9yRWFjaChmdW5jdGlvbiAoc3RlcCkgeyBzdGVwLnN0eWxlcyA9IF9ub3JtYWxpemVTdHlsZU1ldGFkYXRhKHN0ZXAsIHN0YXRlU3R5bGVzLCBlcnJvcnMpOyB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmIChzdGVwIGluc3RhbmNlb2YgQ29tcGlsZUFuaW1hdGlvbldpdGhTdGVwc01ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgaW5uZXJTdGVwcyA9IF9ub3JtYWxpemVTdHlsZVN0ZXBFbnRyeShzdGVwLCBzdGF0ZVN0eWxlcywgZXJyb3JzKTtcbiAgICAgICAgICAgICAgICAgIHN0ZXAgPSBzdGVwIGluc3RhbmNlb2YgQ29tcGlsZUFuaW1hdGlvbkdyb3VwTWV0YWRhdGEgP1xuICAgICAgICAgICAgICAgICAgICAgIG5ldyBDb21waWxlQW5pbWF0aW9uR3JvdXBNZXRhZGF0YShpbm5lclN0ZXBzKSA6XG4gICAgICAgICAgICAgICAgICAgICAgbmV3IENvbXBpbGVBbmltYXRpb25TZXF1ZW5jZU1ldGFkYXRhKGlubmVyU3RlcHMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG5ld1N0ZXBzLnB1c2goc3RlcCk7XG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICAvLyB0aGlzIGhhcHBlbnMgd2hlbiBvbmx5IHN0eWxlcyB3ZXJlIGFuaW1hdGVkIHdpdGhpbiB0aGUgc2VxdWVuY2VcbiAgICAgIGlmIChpc1ByZXNlbnQoY29tYmluZWRTdHlsZXMpKSB7XG4gICAgICAgICAgbmV3U3RlcHMucHVzaChuZXcgQ29tcGlsZUFuaW1hdGlvblN0eWxlTWV0YWRhdGEoMCwgY29tYmluZWRTdHlsZXMpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdTdGVwcztcbiAgfVxuICBmdW5jdGlvbiBfcmVzb2x2ZVN0eWxlc0Zyb21TdGF0ZShzdGF0ZU5hbWUsIHN0YXRlU3R5bGVzLCBlcnJvcnMpIHtcbiAgICAgIHZhciBzdHlsZXMgPSBbXTtcbiAgICAgIGlmIChzdGF0ZU5hbWVbMF0gIT0gJzonKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2gobmV3IEFuaW1hdGlvblBhcnNlRXJyb3IoXCJBbmltYXRpb24gc3RhdGVzIHZpYSBzdHlsZXMgbXVzdCBiZSBwcmVmaXhlZCB3aXRoIGEgXFxcIjpcXFwiXCIpKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBub3JtYWxpemVkU3RhdGVOYW1lID0gc3RhdGVOYW1lLnN1YnN0cmluZygxKTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBzdGF0ZVN0eWxlc1tub3JtYWxpemVkU3RhdGVOYW1lXTtcbiAgICAgICAgICBpZiAoIWlzUHJlc2VudCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IEFuaW1hdGlvblBhcnNlRXJyb3IoXCJVbmFibGUgdG8gYXBwbHkgc3R5bGVzIGR1ZSB0byBtaXNzaW5nIGEgc3RhdGU6IFxcXCJcIiArIG5vcm1hbGl6ZWRTdGF0ZU5hbWUgKyBcIlxcXCJcIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdmFsdWUuc3R5bGVzLmZvckVhY2goZnVuY3Rpb24gKHN0eWxlc0VudHJ5KSB7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHN0eWxlc0VudHJ5ID09PSAnb2JqZWN0JyAmJiBzdHlsZXNFbnRyeSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgIHN0eWxlcy5wdXNoKHN0eWxlc0VudHJ5KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHN0eWxlcztcbiAgfVxuICB2YXIgX0FuaW1hdGlvblRpbWluZ3MgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gX0FuaW1hdGlvblRpbWluZ3MoZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcpIHtcbiAgICAgICAgICB0aGlzLmR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgICAgICAgdGhpcy5kZWxheSA9IGRlbGF5O1xuICAgICAgICAgIHRoaXMuZWFzaW5nID0gZWFzaW5nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9BbmltYXRpb25UaW1pbmdzO1xuICB9KCkpO1xuICBmdW5jdGlvbiBfcGFyc2VBbmltYXRpb25LZXlmcmFtZXMoa2V5ZnJhbWVTZXF1ZW5jZSwgY3VycmVudFRpbWUsIGNvbGxlY3RlZFN0eWxlcywgc3RhdGVTdHlsZXMsIGVycm9ycykge1xuICAgICAgdmFyIHRvdGFsRW50cmllcyA9IGtleWZyYW1lU2VxdWVuY2Uuc3RlcHMubGVuZ3RoO1xuICAgICAgdmFyIHRvdGFsT2Zmc2V0cyA9IDA7XG4gICAgICBrZXlmcmFtZVNlcXVlbmNlLnN0ZXBzLmZvckVhY2goZnVuY3Rpb24gKHN0ZXApIHsgcmV0dXJuIHRvdGFsT2Zmc2V0cyArPSAoaXNQcmVzZW50KHN0ZXAub2Zmc2V0KSA/IDEgOiAwKTsgfSk7XG4gICAgICBpZiAodG90YWxPZmZzZXRzID4gMCAmJiB0b3RhbE9mZnNldHMgPCB0b3RhbEVudHJpZXMpIHtcbiAgICAgICAgICBlcnJvcnMucHVzaChuZXcgQW5pbWF0aW9uUGFyc2VFcnJvcihcIk5vdCBhbGwgc3R5bGUoKSBlbnRyaWVzIGNvbnRhaW4gYW4gb2Zmc2V0IGZvciB0aGUgcHJvdmlkZWQga2V5ZnJhbWUoKVwiKSk7XG4gICAgICAgICAgdG90YWxPZmZzZXRzID0gdG90YWxFbnRyaWVzO1xuICAgICAgfVxuICAgICAgdmFyIGxpbWl0ID0gdG90YWxFbnRyaWVzIC0gMTtcbiAgICAgIHZhciBtYXJnaW4gPSB0b3RhbE9mZnNldHMgPT0gMCA/ICgxIC8gbGltaXQpIDogMDtcbiAgICAgIHZhciByYXdLZXlmcmFtZXMgPSBbXTtcbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICB2YXIgZG9Tb3J0S2V5ZnJhbWVzID0gZmFsc2U7XG4gICAgICB2YXIgbGFzdE9mZnNldCA9IDA7XG4gICAgICBrZXlmcmFtZVNlcXVlbmNlLnN0ZXBzLmZvckVhY2goZnVuY3Rpb24gKHN0eWxlTWV0YWRhdGEpIHtcbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gc3R5bGVNZXRhZGF0YS5vZmZzZXQ7XG4gICAgICAgICAgdmFyIGtleWZyYW1lU3R5bGVzID0ge307XG4gICAgICAgICAgc3R5bGVNZXRhZGF0YS5zdHlsZXMuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgT2JqZWN0LmtleXMoZW50cnkpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgICAgICAgIGlmIChwcm9wICE9ICdvZmZzZXQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAga2V5ZnJhbWVTdHlsZXNbcHJvcF0gPSBlbnRyeVtwcm9wXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGlzUHJlc2VudChvZmZzZXQpKSB7XG4gICAgICAgICAgICAgIGRvU29ydEtleWZyYW1lcyA9IGRvU29ydEtleWZyYW1lcyB8fCAob2Zmc2V0IDwgbGFzdE9mZnNldCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBvZmZzZXQgPSBpbmRleCA9PSBsaW1pdCA/IF9URVJNSU5BTF9LRVlGUkFNRSA6IChtYXJnaW4gKiBpbmRleCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJhd0tleWZyYW1lcy5wdXNoKFtvZmZzZXQsIGtleWZyYW1lU3R5bGVzXSk7XG4gICAgICAgICAgbGFzdE9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICBpbmRleCsrO1xuICAgICAgfSk7XG4gICAgICBpZiAoZG9Tb3J0S2V5ZnJhbWVzKSB7XG4gICAgICAgICAgTGlzdFdyYXBwZXIuc29ydChyYXdLZXlmcmFtZXMsIGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhWzBdIDw9IGJbMF0gPyAtMSA6IDE7IH0pO1xuICAgICAgfVxuICAgICAgdmFyIGZpcnN0S2V5ZnJhbWUgPSByYXdLZXlmcmFtZXNbMF07XG4gICAgICBpZiAoZmlyc3RLZXlmcmFtZVswXSAhPSBfSU5JVElBTF9LRVlGUkFNRSkge1xuICAgICAgICAgIExpc3RXcmFwcGVyLmluc2VydChyYXdLZXlmcmFtZXMsIDAsIGZpcnN0S2V5ZnJhbWUgPSBbX0lOSVRJQUxfS0VZRlJBTUUsIHt9XSk7XG4gICAgICB9XG4gICAgICB2YXIgZmlyc3RLZXlmcmFtZVN0eWxlcyA9IGZpcnN0S2V5ZnJhbWVbMV07XG4gICAgICBsaW1pdCA9IHJhd0tleWZyYW1lcy5sZW5ndGggLSAxO1xuICAgICAgdmFyIGxhc3RLZXlmcmFtZSA9IHJhd0tleWZyYW1lc1tsaW1pdF07XG4gICAgICBpZiAobGFzdEtleWZyYW1lWzBdICE9IF9URVJNSU5BTF9LRVlGUkFNRSkge1xuICAgICAgICAgIHJhd0tleWZyYW1lcy5wdXNoKGxhc3RLZXlmcmFtZSA9IFtfVEVSTUlOQUxfS0VZRlJBTUUsIHt9XSk7XG4gICAgICAgICAgbGltaXQrKztcbiAgICAgIH1cbiAgICAgIHZhciBsYXN0S2V5ZnJhbWVTdHlsZXMgPSBsYXN0S2V5ZnJhbWVbMV07XG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBsaW1pdDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVudHJ5ID0gcmF3S2V5ZnJhbWVzW2ldO1xuICAgICAgICAgIHZhciBzdHlsZXMgPSBlbnRyeVsxXTtcbiAgICAgICAgICBPYmplY3Qua2V5cyhzdHlsZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgICAgaWYgKCFpc1ByZXNlbnQoZmlyc3RLZXlmcmFtZVN0eWxlc1twcm9wXSkpIHtcbiAgICAgICAgICAgICAgICAgIGZpcnN0S2V5ZnJhbWVTdHlsZXNbcHJvcF0gPSBGSUxMX1NUWUxFX0ZMQUc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24oaSkge1xuICAgICAgICAgIHZhciBlbnRyeSA9IHJhd0tleWZyYW1lc1tpXTtcbiAgICAgICAgICB2YXIgc3R5bGVzID0gZW50cnlbMV07XG4gICAgICAgICAgT2JqZWN0LmtleXMoc3R5bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICAgIGlmICghaXNQcmVzZW50KGxhc3RLZXlmcmFtZVN0eWxlc1twcm9wXSkpIHtcbiAgICAgICAgICAgICAgICAgIGxhc3RLZXlmcmFtZVN0eWxlc1twcm9wXSA9IHN0eWxlc1twcm9wXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGZvciAodmFyIGkgPSBsaW1pdCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgX2xvb3BfMShpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByYXdLZXlmcmFtZXMubWFwKGZ1bmN0aW9uIChlbnRyeSkgeyByZXR1cm4gbmV3IEFuaW1hdGlvbktleWZyYW1lQXN0KGVudHJ5WzBdLCBuZXcgQW5pbWF0aW9uU3R5bGVzQXN0KFtlbnRyeVsxXV0pKTsgfSk7XG4gIH1cbiAgZnVuY3Rpb24gX3BhcnNlVHJhbnNpdGlvbkFuaW1hdGlvbihlbnRyeSwgY3VycmVudFRpbWUsIGNvbGxlY3RlZFN0eWxlcywgc3RhdGVTdHlsZXMsIGVycm9ycykge1xuICAgICAgdmFyIGFzdDtcbiAgICAgIHZhciBwbGF5VGltZSA9IDA7XG4gICAgICB2YXIgc3RhcnRpbmdUaW1lID0gY3VycmVudFRpbWU7XG4gICAgICBpZiAoZW50cnkgaW5zdGFuY2VvZiBDb21waWxlQW5pbWF0aW9uV2l0aFN0ZXBzTWV0YWRhdGEpIHtcbiAgICAgICAgICB2YXIgbWF4RHVyYXRpb24gPSAwO1xuICAgICAgICAgIHZhciBzdGVwcyA9IFtdO1xuICAgICAgICAgIHZhciBpc0dyb3VwID0gZW50cnkgaW5zdGFuY2VvZiBDb21waWxlQW5pbWF0aW9uR3JvdXBNZXRhZGF0YTtcbiAgICAgICAgICB2YXIgcHJldmlvdXNTdHlsZXM7XG4gICAgICAgICAgZW50cnkuc3RlcHMuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgLy8gdGhlc2Ugd2lsbCBnZXQgcGlja2VkIHVwIGJ5IHRoZSBuZXh0IHN0ZXAuLi5cbiAgICAgICAgICAgICAgdmFyIHRpbWUgPSBpc0dyb3VwID8gc3RhcnRpbmdUaW1lIDogY3VycmVudFRpbWU7XG4gICAgICAgICAgICAgIGlmIChlbnRyeSBpbnN0YW5jZW9mIENvbXBpbGVBbmltYXRpb25TdHlsZU1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICBlbnRyeS5zdHlsZXMuZm9yRWFjaChmdW5jdGlvbiAoc3R5bGVzRW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBieSB0aGlzIHBvaW50IHdlIGtub3cgdGhhdCB3ZSBvbmx5IGhhdmUgc3RyaW5nbWFwIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXAgPSBzdHlsZXNFbnRyeTtcbiAgICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhtYXApLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHsgY29sbGVjdGVkU3R5bGVzLmluc2VydEF0VGltZShwcm9wLCB0aW1lLCBtYXBbcHJvcF0pOyB9KTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgcHJldmlvdXNTdHlsZXMgPSBlbnRyeS5zdHlsZXM7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIGlubmVyQXN0ID0gX3BhcnNlVHJhbnNpdGlvbkFuaW1hdGlvbihlbnRyeSwgdGltZSwgY29sbGVjdGVkU3R5bGVzLCBzdGF0ZVN0eWxlcywgZXJyb3JzKTtcbiAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudChwcmV2aW91c1N0eWxlcykpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChlbnRyeSBpbnN0YW5jZW9mIENvbXBpbGVBbmltYXRpb25XaXRoU3RlcHNNZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGFydGluZ1N0eWxlcyA9IG5ldyBBbmltYXRpb25TdHlsZXNBc3QocHJldmlvdXNTdHlsZXMpO1xuICAgICAgICAgICAgICAgICAgICAgIHN0ZXBzLnB1c2gobmV3IEFuaW1hdGlvblN0ZXBBc3Qoc3RhcnRpbmdTdHlsZXMsIFtdLCAwLCAwLCAnJykpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGlubmVyU3RlcCA9IGlubmVyQXN0O1xuICAgICAgICAgICAgICAgICAgICAgIExpc3RXcmFwcGVyLmFkZEFsbChpbm5lclN0ZXAuc3RhcnRpbmdTdHlsZXMuc3R5bGVzLCBwcmV2aW91c1N0eWxlcyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBwcmV2aW91c1N0eWxlcyA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIGFzdER1cmF0aW9uID0gaW5uZXJBc3QucGxheVRpbWU7XG4gICAgICAgICAgICAgIGN1cnJlbnRUaW1lICs9IGFzdER1cmF0aW9uO1xuICAgICAgICAgICAgICBwbGF5VGltZSArPSBhc3REdXJhdGlvbjtcbiAgICAgICAgICAgICAgbWF4RHVyYXRpb24gPSBNYXRoLm1heChhc3REdXJhdGlvbiwgbWF4RHVyYXRpb24pO1xuICAgICAgICAgICAgICBzdGVwcy5wdXNoKGlubmVyQXN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KHByZXZpb3VzU3R5bGVzKSkge1xuICAgICAgICAgICAgICB2YXIgc3RhcnRpbmdTdHlsZXMgPSBuZXcgQW5pbWF0aW9uU3R5bGVzQXN0KHByZXZpb3VzU3R5bGVzKTtcbiAgICAgICAgICAgICAgc3RlcHMucHVzaChuZXcgQW5pbWF0aW9uU3RlcEFzdChzdGFydGluZ1N0eWxlcywgW10sIDAsIDAsICcnKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0dyb3VwKSB7XG4gICAgICAgICAgICAgIGFzdCA9IG5ldyBBbmltYXRpb25Hcm91cEFzdChzdGVwcyk7XG4gICAgICAgICAgICAgIHBsYXlUaW1lID0gbWF4RHVyYXRpb247XG4gICAgICAgICAgICAgIGN1cnJlbnRUaW1lID0gc3RhcnRpbmdUaW1lICsgcGxheVRpbWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBhc3QgPSBuZXcgQW5pbWF0aW9uU2VxdWVuY2VBc3Qoc3RlcHMpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGVudHJ5IGluc3RhbmNlb2YgQ29tcGlsZUFuaW1hdGlvbkFuaW1hdGVNZXRhZGF0YSkge1xuICAgICAgICAgIHZhciB0aW1pbmdzID0gX3BhcnNlVGltZUV4cHJlc3Npb24oZW50cnkudGltaW5ncywgZXJyb3JzKTtcbiAgICAgICAgICB2YXIgc3R5bGVzID0gZW50cnkuc3R5bGVzO1xuICAgICAgICAgIHZhciBrZXlmcmFtZXM7XG4gICAgICAgICAgaWYgKHN0eWxlcyBpbnN0YW5jZW9mIENvbXBpbGVBbmltYXRpb25LZXlmcmFtZXNTZXF1ZW5jZU1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgIGtleWZyYW1lcyA9XG4gICAgICAgICAgICAgICAgICBfcGFyc2VBbmltYXRpb25LZXlmcmFtZXMoc3R5bGVzLCBjdXJyZW50VGltZSwgY29sbGVjdGVkU3R5bGVzLCBzdGF0ZVN0eWxlcywgZXJyb3JzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBzdHlsZURhdGEgPSBzdHlsZXM7XG4gICAgICAgICAgICAgIHZhciBvZmZzZXQgPSBfVEVSTUlOQUxfS0VZRlJBTUU7XG4gICAgICAgICAgICAgIHZhciBzdHlsZUFzdCA9IG5ldyBBbmltYXRpb25TdHlsZXNBc3Qoc3R5bGVEYXRhLnN0eWxlcyk7XG4gICAgICAgICAgICAgIHZhciBrZXlmcmFtZSA9IG5ldyBBbmltYXRpb25LZXlmcmFtZUFzdChvZmZzZXQsIHN0eWxlQXN0KTtcbiAgICAgICAgICAgICAga2V5ZnJhbWVzID0gW2tleWZyYW1lXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXN0ID0gbmV3IEFuaW1hdGlvblN0ZXBBc3QobmV3IEFuaW1hdGlvblN0eWxlc0FzdChbXSksIGtleWZyYW1lcywgdGltaW5ncy5kdXJhdGlvbiwgdGltaW5ncy5kZWxheSwgdGltaW5ncy5lYXNpbmcpO1xuICAgICAgICAgIHBsYXlUaW1lID0gdGltaW5ncy5kdXJhdGlvbiArIHRpbWluZ3MuZGVsYXk7XG4gICAgICAgICAgY3VycmVudFRpbWUgKz0gcGxheVRpbWU7XG4gICAgICAgICAga2V5ZnJhbWVzLmZvckVhY2goZnVuY3Rpb24gKGtleWZyYW1lIC8qKiBUT0RPICM5MTAwICovKSB7IHJldHVybiBrZXlmcmFtZS5zdHlsZXMuc3R5bGVzLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5IC8qKiBUT0RPICM5MTAwICovKSB7IHJldHVybiBPYmplY3Qua2V5cyhlbnRyeSkuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkgeyBjb2xsZWN0ZWRTdHlsZXMuaW5zZXJ0QXRUaW1lKHByb3AsIGN1cnJlbnRUaW1lLCBlbnRyeVtwcm9wXSk7IH0pOyB9KTsgfSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgICAvLyBpZiB0aGUgY29kZSByZWFjaGVzIHRoaXMgc3RhZ2UgdGhlbiBhbiBlcnJvclxuICAgICAgICAgIC8vIGhhcyBhbHJlYWR5IGJlZW4gcG9wdWxhdGVkIHdpdGhpbiB0aGUgX25vcm1hbGl6ZVN0eWxlU3RlcHMoKVxuICAgICAgICAgIC8vIG9wZXJhdGlvbi4uLlxuICAgICAgICAgIGFzdCA9IG5ldyBBbmltYXRpb25TdGVwQXN0KG51bGwsIFtdLCAwLCAwLCAnJyk7XG4gICAgICB9XG4gICAgICBhc3QucGxheVRpbWUgPSBwbGF5VGltZTtcbiAgICAgIGFzdC5zdGFydFRpbWUgPSBzdGFydGluZ1RpbWU7XG4gICAgICByZXR1cm4gYXN0O1xuICB9XG4gIGZ1bmN0aW9uIF9maWxsQW5pbWF0aW9uQXN0U3RhcnRpbmdLZXlmcmFtZXMoYXN0LCBjb2xsZWN0ZWRTdHlsZXMsIGVycm9ycykge1xuICAgICAgLy8gc3RlcHMgdGhhdCBvbmx5IGNvbnRhaW4gc3R5bGUgd2lsbCBub3QgYmUgZmlsbGVkXG4gICAgICBpZiAoKGFzdCBpbnN0YW5jZW9mIEFuaW1hdGlvblN0ZXBBc3QpICYmIGFzdC5rZXlmcmFtZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciBrZXlmcmFtZXMgPSBhc3Qua2V5ZnJhbWVzO1xuICAgICAgICAgIGlmIChrZXlmcmFtZXMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICAgdmFyIGVuZEtleWZyYW1lID0ga2V5ZnJhbWVzWzBdO1xuICAgICAgICAgICAgICB2YXIgc3RhcnRLZXlmcmFtZSA9IF9jcmVhdGVTdGFydEtleWZyYW1lRnJvbUVuZEtleWZyYW1lKGVuZEtleWZyYW1lLCBhc3Quc3RhcnRUaW1lLCBhc3QucGxheVRpbWUsIGNvbGxlY3RlZFN0eWxlcywgZXJyb3JzKTtcbiAgICAgICAgICAgICAgYXN0LmtleWZyYW1lcyA9IFtzdGFydEtleWZyYW1lLCBlbmRLZXlmcmFtZV07XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYXN0IGluc3RhbmNlb2YgQW5pbWF0aW9uV2l0aFN0ZXBzQXN0KSB7XG4gICAgICAgICAgYXN0LnN0ZXBzLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7IHJldHVybiBfZmlsbEFuaW1hdGlvbkFzdFN0YXJ0aW5nS2V5ZnJhbWVzKGVudHJ5LCBjb2xsZWN0ZWRTdHlsZXMsIGVycm9ycyk7IH0pO1xuICAgICAgfVxuICB9XG4gIGZ1bmN0aW9uIF9wYXJzZVRpbWVFeHByZXNzaW9uKGV4cCwgZXJyb3JzKSB7XG4gICAgICB2YXIgcmVnZXggPSAvXihbXFwuXFxkXSspKG0/cykoPzpcXHMrKFtcXC5cXGRdKykobT9zKSk/KD86XFxzKyhbLWEtel0rKD86XFwoLis/XFwpKT8pKT8vaTtcbiAgICAgIHZhciBkdXJhdGlvbjtcbiAgICAgIHZhciBkZWxheSA9IDA7XG4gICAgICB2YXIgZWFzaW5nID0gbnVsbDtcbiAgICAgIGlmICh0eXBlb2YgZXhwID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHZhciBtYXRjaGVzID0gZXhwLm1hdGNoKHJlZ2V4KTtcbiAgICAgICAgICBpZiAobWF0Y2hlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgQW5pbWF0aW9uUGFyc2VFcnJvcihcIlRoZSBwcm92aWRlZCB0aW1pbmcgdmFsdWUgXFxcIlwiICsgZXhwICsgXCJcXFwiIGlzIGludmFsaWQuXCIpKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBfQW5pbWF0aW9uVGltaW5ncygwLCAwLCBudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGR1cmF0aW9uTWF0Y2ggPSBwYXJzZUZsb2F0KG1hdGNoZXNbMV0pO1xuICAgICAgICAgIHZhciBkdXJhdGlvblVuaXQgPSBtYXRjaGVzWzJdO1xuICAgICAgICAgIGlmIChkdXJhdGlvblVuaXQgPT0gJ3MnKSB7XG4gICAgICAgICAgICAgIGR1cmF0aW9uTWF0Y2ggKj0gX09ORV9TRUNPTkQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGR1cmF0aW9uID0gTWF0aC5mbG9vcihkdXJhdGlvbk1hdGNoKTtcbiAgICAgICAgICB2YXIgZGVsYXlNYXRjaCA9IG1hdGNoZXNbM107XG4gICAgICAgICAgdmFyIGRlbGF5VW5pdCA9IG1hdGNoZXNbNF07XG4gICAgICAgICAgaWYgKGlzUHJlc2VudChkZWxheU1hdGNoKSkge1xuICAgICAgICAgICAgICB2YXIgZGVsYXlWYWwgPSBwYXJzZUZsb2F0KGRlbGF5TWF0Y2gpO1xuICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KGRlbGF5VW5pdCkgJiYgZGVsYXlVbml0ID09ICdzJykge1xuICAgICAgICAgICAgICAgICAgZGVsYXlWYWwgKj0gX09ORV9TRUNPTkQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGVsYXkgPSBNYXRoLmZsb29yKGRlbGF5VmFsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGVhc2luZ1ZhbCA9IG1hdGNoZXNbNV07XG4gICAgICAgICAgaWYgKCFpc0JsYW5rKGVhc2luZ1ZhbCkpIHtcbiAgICAgICAgICAgICAgZWFzaW5nID0gZWFzaW5nVmFsO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgIGR1cmF0aW9uID0gZXhwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBfQW5pbWF0aW9uVGltaW5ncyhkdXJhdGlvbiwgZGVsYXksIGVhc2luZyk7XG4gIH1cbiAgZnVuY3Rpb24gX2NyZWF0ZVN0YXJ0S2V5ZnJhbWVGcm9tRW5kS2V5ZnJhbWUoZW5kS2V5ZnJhbWUsIHN0YXJ0VGltZSwgZHVyYXRpb24sIGNvbGxlY3RlZFN0eWxlcywgZXJyb3JzKSB7XG4gICAgICB2YXIgdmFsdWVzID0ge307XG4gICAgICB2YXIgZW5kVGltZSA9IHN0YXJ0VGltZSArIGR1cmF0aW9uO1xuICAgICAgZW5kS2V5ZnJhbWUuc3R5bGVzLnN0eWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChzdHlsZURhdGEpIHtcbiAgICAgICAgICBPYmplY3Qua2V5cyhzdHlsZURhdGEpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgICAgdmFyIHZhbCA9IHN0eWxlRGF0YVtwcm9wXTtcbiAgICAgICAgICAgICAgaWYgKHByb3AgPT0gJ29mZnNldCcpXG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIHZhciByZXN1bHRJbmRleCA9IGNvbGxlY3RlZFN0eWxlcy5pbmRleE9mQXRPckJlZm9yZVRpbWUocHJvcCwgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdEVudHJ5IC8qKiBUT0RPICM5MTAwICovLCBuZXh0RW50cnkgLyoqIFRPRE8gIzkxMDAgKi8sIHZhbHVlO1xuICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KHJlc3VsdEluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0RW50cnkgPSBjb2xsZWN0ZWRTdHlsZXMuZ2V0QnlJbmRleChwcm9wLCByZXN1bHRJbmRleCk7XG4gICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJlc3VsdEVudHJ5LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgbmV4dEVudHJ5ID0gY29sbGVjdGVkU3R5bGVzLmdldEJ5SW5kZXgocHJvcCwgcmVzdWx0SW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgYSBmbGFnIHRoYXQgdGhlIHJ1bnRpbWUgY29kZSB1c2VzIHRvIHBhc3NcbiAgICAgICAgICAgICAgICAgIC8vIGluIGEgdmFsdWUgZWl0aGVyIGZyb20gdGhlIHN0YXRlIGRlY2xhcmF0aW9uIHN0eWxlc1xuICAgICAgICAgICAgICAgICAgLy8gb3IgdXNpbmcgdGhlIEFVVE9fU1RZTEUgdmFsdWUgKGUuZy4gZ2V0Q29tcHV0ZWRTdHlsZSlcbiAgICAgICAgICAgICAgICAgIHZhbHVlID0gRklMTF9TVFlMRV9GTEFHO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQobmV4dEVudHJ5KSAmJiAhbmV4dEVudHJ5Lm1hdGNoZXMoZW5kVGltZSwgdmFsKSkge1xuICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IEFuaW1hdGlvblBhcnNlRXJyb3IoXCJUaGUgYW5pbWF0ZWQgQ1NTIHByb3BlcnR5IFxcXCJcIiArIHByb3AgKyBcIlxcXCIgdW5leHBlY3RlZGx5IGNoYW5nZXMgYmV0d2VlbiBzdGVwcyBcXFwiXCIgKyByZXN1bHRFbnRyeS50aW1lICsgXCJtc1xcXCIgYW5kIFxcXCJcIiArIGVuZFRpbWUgKyBcIm1zXFxcIiBhdCBcXFwiXCIgKyBuZXh0RW50cnkudGltZSArIFwibXNcXFwiXCIpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YWx1ZXNbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5ldyBBbmltYXRpb25LZXlmcmFtZUFzdChfSU5JVElBTF9LRVlGUkFNRSwgbmV3IEFuaW1hdGlvblN0eWxlc0FzdChbdmFsdWVzXSkpO1xuICB9XG5cbiAgdmFyIERpcmVjdGl2ZVdyYXBwZXJDb21waWxlUmVzdWx0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIERpcmVjdGl2ZVdyYXBwZXJDb21waWxlUmVzdWx0KHN0YXRlbWVudHMsIGRpcldyYXBwZXJDbGFzc1Zhcikge1xuICAgICAgICAgIHRoaXMuc3RhdGVtZW50cyA9IHN0YXRlbWVudHM7XG4gICAgICAgICAgdGhpcy5kaXJXcmFwcGVyQ2xhc3NWYXIgPSBkaXJXcmFwcGVyQ2xhc3NWYXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gRGlyZWN0aXZlV3JhcHBlckNvbXBpbGVSZXN1bHQ7XG4gIH0oKSk7XG4gIHZhciBDT05URVhUX0ZJRUxEX05BTUUgPSAnY29udGV4dCc7XG4gIHZhciBDSEFOR0VTX0ZJRUxEX05BTUUgPSAnY2hhbmdlcyc7XG4gIHZhciBDSEFOR0VEX0ZJRUxEX05BTUUgPSAnY2hhbmdlZCc7XG4gIHZhciBDVVJSX1ZBTFVFX1ZBUiA9IHZhcmlhYmxlKCdjdXJyVmFsdWUnKTtcbiAgdmFyIFRIUk9XX09OX0NIQU5HRV9WQVIgPSB2YXJpYWJsZSgndGhyb3dPbkNoYW5nZScpO1xuICB2YXIgRk9SQ0VfVVBEQVRFX1ZBUiA9IHZhcmlhYmxlKCdmb3JjZVVwZGF0ZScpO1xuICB2YXIgVklFV19WQVIgPSB2YXJpYWJsZSgndmlldycpO1xuICB2YXIgUkVOREVSX0VMX1ZBUiA9IHZhcmlhYmxlKCdlbCcpO1xuICB2YXIgUkVTRVRfQ0hBTkdFU19TVE1UID0gVEhJU19FWFBSLnByb3AoQ0hBTkdFU19GSUVMRF9OQU1FKS5zZXQobGl0ZXJhbE1hcChbXSkpLnRvU3RtdCgpO1xuICAvKipcbiAgICogV2UgZ2VuZXJhdGUgZGlyZWN0aXZlIHdyYXBwZXJzIHRvIHByZXZlbnQgY29kZSBibG9hdCB3aGVuIGEgZGlyZWN0aXZlIGlzIHVzZWQuXG4gICAqIEEgZGlyZWN0aXZlIHdyYXBwZXIgZW5jYXBzdWxhdGVzXG4gICAqIHRoZSBkaXJ0eSBjaGVja2luZyBmb3IgYEBJbnB1dGAsIHRoZSBoYW5kbGluZyBvZiBgQEhvc3RMaXN0ZW5lcmAgLyBgQEhvc3RCaW5kaW5nYFxuICAgKiBhbmQgY2FsbGluZyB0aGUgbGlmZWN5Y2xlaG9va3MgYG5nT25Jbml0YCwgYG5nT25DaGFuZ2VzYCwgYG5nRG9DaGVja2AuXG4gICAqXG4gICAqIFNvIGZhciwgb25seSBgQElucHV0YCBhbmQgdGhlIGxpZmVjeWNsZSBob29rcyBoYXZlIGJlZW4gaW1wbGVtZW50ZWQuXG4gICAqL1xuICB2YXIgRGlyZWN0aXZlV3JhcHBlckNvbXBpbGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIERpcmVjdGl2ZVdyYXBwZXJDb21waWxlcihjb21waWxlckNvbmZpZykge1xuICAgICAgICAgIHRoaXMuY29tcGlsZXJDb25maWcgPSBjb21waWxlckNvbmZpZztcbiAgICAgIH1cbiAgICAgIERpcmVjdGl2ZVdyYXBwZXJDb21waWxlci5kaXJXcmFwcGVyQ2xhc3NOYW1lID0gZnVuY3Rpb24gKGlkKSB7IHJldHVybiBcIldyYXBwZXJfXCIgKyBpZC5uYW1lOyB9O1xuICAgICAgRGlyZWN0aXZlV3JhcHBlckNvbXBpbGVyLnByb3RvdHlwZS5jb21waWxlID0gZnVuY3Rpb24gKGRpck1ldGEpIHtcbiAgICAgICAgICB2YXIgZGlyRGVwUGFyYW1OYW1lcyA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlyTWV0YS50eXBlLmRpRGVwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBkaXJEZXBQYXJhbU5hbWVzLnB1c2goXCJwXCIgKyBpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGRpckxpZmVjeWNsZUhvb2tzID0gZGlyTWV0YS50eXBlLmxpZmVjeWNsZUhvb2tzO1xuICAgICAgICAgIHZhciBsaWZlY3ljbGVIb29rcyA9IHtcbiAgICAgICAgICAgICAgZ2VuQ2hhbmdlczogZGlyTGlmZWN5Y2xlSG9va3MuaW5kZXhPZihMaWZlY3ljbGVIb29rcy5PbkNoYW5nZXMpICE9PSAtMSB8fFxuICAgICAgICAgICAgICAgICAgdGhpcy5jb21waWxlckNvbmZpZy5sb2dCaW5kaW5nVXBkYXRlLFxuICAgICAgICAgICAgICBuZ09uQ2hhbmdlczogZGlyTGlmZWN5Y2xlSG9va3MuaW5kZXhPZihMaWZlY3ljbGVIb29rcy5PbkNoYW5nZXMpICE9PSAtMSxcbiAgICAgICAgICAgICAgbmdPbkluaXQ6IGRpckxpZmVjeWNsZUhvb2tzLmluZGV4T2YoTGlmZWN5Y2xlSG9va3MuT25Jbml0KSAhPT0gLTEsXG4gICAgICAgICAgICAgIG5nRG9DaGVjazogZGlyTGlmZWN5Y2xlSG9va3MuaW5kZXhPZihMaWZlY3ljbGVIb29rcy5Eb0NoZWNrKSAhPT0gLTFcbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciBmaWVsZHMgPSBbXG4gICAgICAgICAgICAgIG5ldyBDbGFzc0ZpZWxkKENPTlRFWFRfRklFTERfTkFNRSwgaW1wb3J0VHlwZShkaXJNZXRhLnR5cGUpKSxcbiAgICAgICAgICAgICAgbmV3IENsYXNzRmllbGQoQ0hBTkdFRF9GSUVMRF9OQU1FLCBCT09MX1RZUEUpLFxuICAgICAgICAgIF07XG4gICAgICAgICAgdmFyIGN0b3JTdG10cyA9IFtUSElTX0VYUFIucHJvcChDSEFOR0VEX0ZJRUxEX05BTUUpLnNldChsaXRlcmFsKGZhbHNlKSkudG9TdG10KCldO1xuICAgICAgICAgIGlmIChsaWZlY3ljbGVIb29rcy5nZW5DaGFuZ2VzKSB7XG4gICAgICAgICAgICAgIGZpZWxkcy5wdXNoKG5ldyBDbGFzc0ZpZWxkKENIQU5HRVNfRklFTERfTkFNRSwgbmV3IE1hcFR5cGUoRFlOQU1JQ19UWVBFKSkpO1xuICAgICAgICAgICAgICBjdG9yU3RtdHMucHVzaChSRVNFVF9DSEFOR0VTX1NUTVQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbWV0aG9kcyA9IFtdO1xuICAgICAgICAgIE9iamVjdC5rZXlzKGRpck1ldGEuaW5wdXRzKS5mb3JFYWNoKGZ1bmN0aW9uIChpbnB1dEZpZWxkTmFtZSwgaWR4KSB7XG4gICAgICAgICAgICAgIHZhciBmaWVsZE5hbWUgPSBcIl9cIiArIGlucHV0RmllbGROYW1lO1xuICAgICAgICAgICAgICAvLyBwcml2YXRlIGlzIGZpbmUgaGVyZSBhcyBubyBjaGlsZCB2aWV3IHdpbGwgcmVmZXJlbmNlIHRoZSBjYWNoZWQgdmFsdWUuLi5cbiAgICAgICAgICAgICAgZmllbGRzLnB1c2gobmV3IENsYXNzRmllbGQoZmllbGROYW1lLCBudWxsLCBbU3RtdE1vZGlmaWVyLlByaXZhdGVdKSk7XG4gICAgICAgICAgICAgIGN0b3JTdG10cy5wdXNoKFRISVNfRVhQUi5wcm9wKGZpZWxkTmFtZSlcbiAgICAgICAgICAgICAgICAgIC5zZXQoaW1wb3J0RXhwcihyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5VTklOSVRJQUxJWkVEKSkpXG4gICAgICAgICAgICAgICAgICAudG9TdG10KCkpO1xuICAgICAgICAgICAgICBtZXRob2RzLnB1c2goY2hlY2tJbnB1dE1ldGhvZChpbnB1dEZpZWxkTmFtZSwgVEhJU19FWFBSLnByb3AoZmllbGROYW1lKSwgbGlmZWN5Y2xlSG9va3MpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBtZXRob2RzLnB1c2goZGV0ZWN0Q2hhbmdlc0ludGVybmFsTWV0aG9kKGxpZmVjeWNsZUhvb2tzLCB0aGlzLmNvbXBpbGVyQ29uZmlnLmdlbkRlYnVnSW5mbykpO1xuICAgICAgICAgIGN0b3JTdG10cy5wdXNoKFRISVNfRVhQUi5wcm9wKENPTlRFWFRfRklFTERfTkFNRSlcbiAgICAgICAgICAgICAgLnNldChpbXBvcnRFeHByKGRpck1ldGEudHlwZSlcbiAgICAgICAgICAgICAgLmluc3RhbnRpYXRlKGRpckRlcFBhcmFtTmFtZXMubWFwKGZ1bmN0aW9uIChwYXJhbU5hbWUpIHsgcmV0dXJuIHZhcmlhYmxlKHBhcmFtTmFtZSk7IH0pKSlcbiAgICAgICAgICAgICAgLnRvU3RtdCgpKTtcbiAgICAgICAgICB2YXIgY3RvciA9IG5ldyBDbGFzc01ldGhvZChudWxsLCBkaXJEZXBQYXJhbU5hbWVzLm1hcChmdW5jdGlvbiAocGFyYW1OYW1lKSB7IHJldHVybiBuZXcgRm5QYXJhbShwYXJhbU5hbWUsIERZTkFNSUNfVFlQRSk7IH0pLCBjdG9yU3RtdHMpO1xuICAgICAgICAgIHZhciB3cmFwcGVyQ2xhc3NOYW1lID0gRGlyZWN0aXZlV3JhcHBlckNvbXBpbGVyLmRpcldyYXBwZXJDbGFzc05hbWUoZGlyTWV0YS50eXBlKTtcbiAgICAgICAgICB2YXIgY2xhc3NTdG10ID0gbmV3IENsYXNzU3RtdCh3cmFwcGVyQ2xhc3NOYW1lLCBudWxsLCBmaWVsZHMsIFtdLCBjdG9yLCBtZXRob2RzKTtcbiAgICAgICAgICByZXR1cm4gbmV3IERpcmVjdGl2ZVdyYXBwZXJDb21waWxlUmVzdWx0KFtjbGFzc1N0bXRdLCB3cmFwcGVyQ2xhc3NOYW1lKTtcbiAgICAgIH07XG4gICAgICBEaXJlY3RpdmVXcmFwcGVyQ29tcGlsZXIuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuICAgICAgXTtcbiAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgRGlyZWN0aXZlV3JhcHBlckNvbXBpbGVyLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgIHsgdHlwZTogQ29tcGlsZXJDb25maWcsIH0sXG4gICAgICBdO1xuICAgICAgcmV0dXJuIERpcmVjdGl2ZVdyYXBwZXJDb21waWxlcjtcbiAgfSgpKTtcbiAgZnVuY3Rpb24gZGV0ZWN0Q2hhbmdlc0ludGVybmFsTWV0aG9kKGxpZmVjeWNsZUhvb2tzLCBsb2dCaW5kaW5nVXBkYXRlKSB7XG4gICAgICB2YXIgY2hhbmdlZFZhciA9IHZhcmlhYmxlKCdjaGFuZ2VkJyk7XG4gICAgICB2YXIgc3RtdHMgPSBbXG4gICAgICAgICAgY2hhbmdlZFZhci5zZXQoVEhJU19FWFBSLnByb3AoQ0hBTkdFRF9GSUVMRF9OQU1FKSkudG9EZWNsU3RtdCgpLFxuICAgICAgICAgIFRISVNfRVhQUi5wcm9wKENIQU5HRURfRklFTERfTkFNRSkuc2V0KGxpdGVyYWwoZmFsc2UpKS50b1N0bXQoKSxcbiAgICAgIF07XG4gICAgICB2YXIgbGlmZWN5Y2xlU3RtdHMgPSBbXTtcbiAgICAgIGlmIChsaWZlY3ljbGVIb29rcy5nZW5DaGFuZ2VzKSB7XG4gICAgICAgICAgdmFyIG9uQ2hhbmdlc1N0bXRzID0gW107XG4gICAgICAgICAgaWYgKGxpZmVjeWNsZUhvb2tzLm5nT25DaGFuZ2VzKSB7XG4gICAgICAgICAgICAgIG9uQ2hhbmdlc1N0bXRzLnB1c2goVEhJU19FWFBSLnByb3AoQ09OVEVYVF9GSUVMRF9OQU1FKVxuICAgICAgICAgICAgICAgICAgLmNhbGxNZXRob2QoJ25nT25DaGFuZ2VzJywgW1RISVNfRVhQUi5wcm9wKENIQU5HRVNfRklFTERfTkFNRSldKVxuICAgICAgICAgICAgICAgICAgLnRvU3RtdCgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGxvZ0JpbmRpbmdVcGRhdGUpIHtcbiAgICAgICAgICAgICAgb25DaGFuZ2VzU3RtdHMucHVzaChpbXBvcnRFeHByKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLnNldEJpbmRpbmdEZWJ1Z0luZm9Gb3JDaGFuZ2VzKSlcbiAgICAgICAgICAgICAgICAgIC5jYWxsRm4oW1ZJRVdfVkFSLnByb3AoJ3JlbmRlcmVyJyksIFJFTkRFUl9FTF9WQVIsIFRISVNfRVhQUi5wcm9wKENIQU5HRVNfRklFTERfTkFNRSldKVxuICAgICAgICAgICAgICAgICAgLnRvU3RtdCgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb25DaGFuZ2VzU3RtdHMucHVzaChSRVNFVF9DSEFOR0VTX1NUTVQpO1xuICAgICAgICAgIGxpZmVjeWNsZVN0bXRzLnB1c2gobmV3IElmU3RtdChjaGFuZ2VkVmFyLCBvbkNoYW5nZXNTdG10cykpO1xuICAgICAgfVxuICAgICAgaWYgKGxpZmVjeWNsZUhvb2tzLm5nT25Jbml0KSB7XG4gICAgICAgICAgbGlmZWN5Y2xlU3RtdHMucHVzaChuZXcgSWZTdG10KFZJRVdfVkFSLnByb3AoJ251bWJlck9mQ2hlY2tzJykuaWRlbnRpY2FsKG5ldyBMaXRlcmFsRXhwcigwKSksIFtUSElTX0VYUFIucHJvcChDT05URVhUX0ZJRUxEX05BTUUpLmNhbGxNZXRob2QoJ25nT25Jbml0JywgW10pLnRvU3RtdCgpXSkpO1xuICAgICAgfVxuICAgICAgaWYgKGxpZmVjeWNsZUhvb2tzLm5nRG9DaGVjaykge1xuICAgICAgICAgIGxpZmVjeWNsZVN0bXRzLnB1c2goVEhJU19FWFBSLnByb3AoQ09OVEVYVF9GSUVMRF9OQU1FKS5jYWxsTWV0aG9kKCduZ0RvQ2hlY2snLCBbXSkudG9TdG10KCkpO1xuICAgICAgfVxuICAgICAgaWYgKGxpZmVjeWNsZVN0bXRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBzdG10cy5wdXNoKG5ldyBJZlN0bXQobm90KFRIUk9XX09OX0NIQU5HRV9WQVIpLCBsaWZlY3ljbGVTdG10cykpO1xuICAgICAgfVxuICAgICAgc3RtdHMucHVzaChuZXcgUmV0dXJuU3RhdGVtZW50KGNoYW5nZWRWYXIpKTtcbiAgICAgIHJldHVybiBuZXcgQ2xhc3NNZXRob2QoJ2RldGVjdENoYW5nZXNJbnRlcm5hbCcsIFtcbiAgICAgICAgICBuZXcgRm5QYXJhbShWSUVXX1ZBUi5uYW1lLCBpbXBvcnRUeXBlKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLkFwcFZpZXcpLCBbRFlOQU1JQ19UWVBFXSkpLFxuICAgICAgICAgIG5ldyBGblBhcmFtKFJFTkRFUl9FTF9WQVIubmFtZSwgRFlOQU1JQ19UWVBFKSxcbiAgICAgICAgICBuZXcgRm5QYXJhbShUSFJPV19PTl9DSEFOR0VfVkFSLm5hbWUsIEJPT0xfVFlQRSksXG4gICAgICBdLCBzdG10cywgQk9PTF9UWVBFKTtcbiAgfVxuICBmdW5jdGlvbiBjaGVja0lucHV0TWV0aG9kKGlucHV0LCBmaWVsZEV4cHIsIGxpZmVjeWNsZUhvb2tzKSB7XG4gICAgICB2YXIgb25DaGFuZ2VTdGF0ZW1lbnRzID0gW1xuICAgICAgICAgIFRISVNfRVhQUi5wcm9wKENIQU5HRURfRklFTERfTkFNRSkuc2V0KGxpdGVyYWwodHJ1ZSkpLnRvU3RtdCgpLFxuICAgICAgICAgIFRISVNfRVhQUi5wcm9wKENPTlRFWFRfRklFTERfTkFNRSkucHJvcChpbnB1dCkuc2V0KENVUlJfVkFMVUVfVkFSKS50b1N0bXQoKSxcbiAgICAgIF07XG4gICAgICBpZiAobGlmZWN5Y2xlSG9va3MuZ2VuQ2hhbmdlcykge1xuICAgICAgICAgIG9uQ2hhbmdlU3RhdGVtZW50cy5wdXNoKFRISVNfRVhQUi5wcm9wKENIQU5HRVNfRklFTERfTkFNRSlcbiAgICAgICAgICAgICAgLmtleShsaXRlcmFsKGlucHV0KSlcbiAgICAgICAgICAgICAgLnNldChpbXBvcnRFeHByKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLlNpbXBsZUNoYW5nZSkpXG4gICAgICAgICAgICAgIC5pbnN0YW50aWF0ZShbZmllbGRFeHByLCBDVVJSX1ZBTFVFX1ZBUl0pKVxuICAgICAgICAgICAgICAudG9TdG10KCkpO1xuICAgICAgfVxuICAgICAgb25DaGFuZ2VTdGF0ZW1lbnRzLnB1c2goZmllbGRFeHByLnNldChDVVJSX1ZBTFVFX1ZBUikudG9TdG10KCkpO1xuICAgICAgdmFyIG1ldGhvZEJvZHkgPSBbXG4gICAgICAgICAgbmV3IElmU3RtdChGT1JDRV9VUERBVEVfVkFSLm9yKGltcG9ydEV4cHIocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuY2hlY2tCaW5kaW5nKSlcbiAgICAgICAgICAgICAgLmNhbGxGbihbVEhST1dfT05fQ0hBTkdFX1ZBUiwgZmllbGRFeHByLCBDVVJSX1ZBTFVFX1ZBUl0pKSwgb25DaGFuZ2VTdGF0ZW1lbnRzKSxcbiAgICAgIF07XG4gICAgICByZXR1cm4gbmV3IENsYXNzTWV0aG9kKFwiY2hlY2tfXCIgKyBpbnB1dCwgW1xuICAgICAgICAgIG5ldyBGblBhcmFtKENVUlJfVkFMVUVfVkFSLm5hbWUsIERZTkFNSUNfVFlQRSksXG4gICAgICAgICAgbmV3IEZuUGFyYW0oVEhST1dfT05fQ0hBTkdFX1ZBUi5uYW1lLCBCT09MX1RZUEUpLFxuICAgICAgICAgIG5ldyBGblBhcmFtKEZPUkNFX1VQREFURV9WQVIubmFtZSwgQk9PTF9UWVBFKSxcbiAgICAgIF0sIG1ldGhvZEJvZHkpO1xuICB9XG5cbiAgZnVuY3Rpb24gY29udmVydFZhbHVlVG9PdXRwdXRBc3QodmFsdWUsIHR5cGUpIHtcbiAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICAgIHJldHVybiB2aXNpdFZhbHVlKHZhbHVlLCBuZXcgX1ZhbHVlT3V0cHV0QXN0VHJhbnNmb3JtZXIoKSwgdHlwZSk7XG4gIH1cbiAgdmFyIF9WYWx1ZU91dHB1dEFzdFRyYW5zZm9ybWVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIF9WYWx1ZU91dHB1dEFzdFRyYW5zZm9ybWVyKCkge1xuICAgICAgfVxuICAgICAgX1ZhbHVlT3V0cHV0QXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0QXJyYXkgPSBmdW5jdGlvbiAoYXJyLCB0eXBlKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICByZXR1cm4gbGl0ZXJhbEFycihhcnIubWFwKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmlzaXRWYWx1ZSh2YWx1ZSwgX3RoaXMsIG51bGwpOyB9KSwgdHlwZSk7XG4gICAgICB9O1xuICAgICAgX1ZhbHVlT3V0cHV0QXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0U3RyaW5nTWFwID0gZnVuY3Rpb24gKG1hcCwgdHlwZSkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIGVudHJpZXMgPSBbXTtcbiAgICAgICAgICBPYmplY3Qua2V5cyhtYXApLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBlbnRyaWVzLnB1c2goW2tleSwgdmlzaXRWYWx1ZShtYXBba2V5XSwgX3RoaXMsIG51bGwpXSk7IH0pO1xuICAgICAgICAgIHJldHVybiBsaXRlcmFsTWFwKGVudHJpZXMsIHR5cGUpO1xuICAgICAgfTtcbiAgICAgIF9WYWx1ZU91dHB1dEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFByaW1pdGl2ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgdHlwZSkgeyByZXR1cm4gbGl0ZXJhbCh2YWx1ZSwgdHlwZSk7IH07XG4gICAgICBfVmFsdWVPdXRwdXRBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRPdGhlciA9IGZ1bmN0aW9uICh2YWx1ZSwgdHlwZSkge1xuICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIENvbXBpbGVJZGVudGlmaWVyTWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGltcG9ydEV4cHIodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSWxsZWdhbCBzdGF0ZTogRG9uJ3Qgbm93IGhvdyB0byBjb21waWxlIHZhbHVlIFwiICsgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gX1ZhbHVlT3V0cHV0QXN0VHJhbnNmb3JtZXI7XG4gIH0oKSk7XG5cbiAgdmFyIF9EZWJ1Z1N0YXRlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIF9EZWJ1Z1N0YXRlKG5vZGVJbmRleCwgc291cmNlQXN0KSB7XG4gICAgICAgICAgdGhpcy5ub2RlSW5kZXggPSBub2RlSW5kZXg7XG4gICAgICAgICAgdGhpcy5zb3VyY2VBc3QgPSBzb3VyY2VBc3Q7XG4gICAgICB9XG4gICAgICByZXR1cm4gX0RlYnVnU3RhdGU7XG4gIH0oKSk7XG4gIHZhciBOVUxMX0RFQlVHX1NUQVRFID0gbmV3IF9EZWJ1Z1N0YXRlKG51bGwsIG51bGwpO1xuICB2YXIgQ29tcGlsZU1ldGhvZCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBDb21waWxlTWV0aG9kKF92aWV3KSB7XG4gICAgICAgICAgdGhpcy5fdmlldyA9IF92aWV3O1xuICAgICAgICAgIHRoaXMuX25ld1N0YXRlID0gTlVMTF9ERUJVR19TVEFURTtcbiAgICAgICAgICB0aGlzLl9jdXJyU3RhdGUgPSBOVUxMX0RFQlVHX1NUQVRFO1xuICAgICAgICAgIHRoaXMuX2JvZHlTdGF0ZW1lbnRzID0gW107XG4gICAgICAgICAgdGhpcy5fZGVidWdFbmFibGVkID0gdGhpcy5fdmlldy5nZW5Db25maWcuZ2VuRGVidWdJbmZvO1xuICAgICAgfVxuICAgICAgQ29tcGlsZU1ldGhvZC5wcm90b3R5cGUuX3VwZGF0ZURlYnVnQ29udGV4dElmTmVlZGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICh0aGlzLl9uZXdTdGF0ZS5ub2RlSW5kZXggIT09IHRoaXMuX2N1cnJTdGF0ZS5ub2RlSW5kZXggfHxcbiAgICAgICAgICAgICAgdGhpcy5fbmV3U3RhdGUuc291cmNlQXN0ICE9PSB0aGlzLl9jdXJyU3RhdGUuc291cmNlQXN0KSB7XG4gICAgICAgICAgICAgIHZhciBleHByID0gdGhpcy5fdXBkYXRlRGVidWdDb250ZXh0KHRoaXMuX25ld1N0YXRlKTtcbiAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudChleHByKSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fYm9keVN0YXRlbWVudHMucHVzaChleHByLnRvU3RtdCgpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBDb21waWxlTWV0aG9kLnByb3RvdHlwZS5fdXBkYXRlRGVidWdDb250ZXh0ID0gZnVuY3Rpb24gKG5ld1N0YXRlKSB7XG4gICAgICAgICAgdGhpcy5fY3VyclN0YXRlID0gdGhpcy5fbmV3U3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgICBpZiAodGhpcy5fZGVidWdFbmFibGVkKSB7XG4gICAgICAgICAgICAgIHZhciBzb3VyY2VMb2NhdGlvbiA9IGlzUHJlc2VudChuZXdTdGF0ZS5zb3VyY2VBc3QpID8gbmV3U3RhdGUuc291cmNlQXN0LnNvdXJjZVNwYW4uc3RhcnQgOiBudWxsO1xuICAgICAgICAgICAgICByZXR1cm4gVEhJU19FWFBSLmNhbGxNZXRob2QoJ2RlYnVnJywgW1xuICAgICAgICAgICAgICAgICAgbGl0ZXJhbChuZXdTdGF0ZS5ub2RlSW5kZXgpLFxuICAgICAgICAgICAgICAgICAgaXNQcmVzZW50KHNvdXJjZUxvY2F0aW9uKSA/IGxpdGVyYWwoc291cmNlTG9jYXRpb24ubGluZSkgOiBOVUxMX0VYUFIsXG4gICAgICAgICAgICAgICAgICBpc1ByZXNlbnQoc291cmNlTG9jYXRpb24pID8gbGl0ZXJhbChzb3VyY2VMb2NhdGlvbi5jb2wpIDogTlVMTF9FWFBSXG4gICAgICAgICAgICAgIF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIENvbXBpbGVNZXRob2QucHJvdG90eXBlLnJlc2V0RGVidWdJbmZvRXhwciA9IGZ1bmN0aW9uIChub2RlSW5kZXgsIHRlbXBsYXRlQXN0KSB7XG4gICAgICAgICAgdmFyIHJlcyA9IHRoaXMuX3VwZGF0ZURlYnVnQ29udGV4dChuZXcgX0RlYnVnU3RhdGUobm9kZUluZGV4LCB0ZW1wbGF0ZUFzdCkpO1xuICAgICAgICAgIHJldHVybiByZXMgfHwgTlVMTF9FWFBSO1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVNZXRob2QucHJvdG90eXBlLnJlc2V0RGVidWdJbmZvID0gZnVuY3Rpb24gKG5vZGVJbmRleCwgdGVtcGxhdGVBc3QpIHtcbiAgICAgICAgICB0aGlzLl9uZXdTdGF0ZSA9IG5ldyBfRGVidWdTdGF0ZShub2RlSW5kZXgsIHRlbXBsYXRlQXN0KTtcbiAgICAgIH07XG4gICAgICBDb21waWxlTWV0aG9kLnByb3RvdHlwZS5hZGRTdG10ID0gZnVuY3Rpb24gKHN0bXQpIHtcbiAgICAgICAgICB0aGlzLl91cGRhdGVEZWJ1Z0NvbnRleHRJZk5lZWRlZCgpO1xuICAgICAgICAgIHRoaXMuX2JvZHlTdGF0ZW1lbnRzLnB1c2goc3RtdCk7XG4gICAgICB9O1xuICAgICAgQ29tcGlsZU1ldGhvZC5wcm90b3R5cGUuYWRkU3RtdHMgPSBmdW5jdGlvbiAoc3RtdHMpIHtcbiAgICAgICAgICB0aGlzLl91cGRhdGVEZWJ1Z0NvbnRleHRJZk5lZWRlZCgpO1xuICAgICAgICAgIExpc3RXcmFwcGVyLmFkZEFsbCh0aGlzLl9ib2R5U3RhdGVtZW50cywgc3RtdHMpO1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVNZXRob2QucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2JvZHlTdGF0ZW1lbnRzOyB9O1xuICAgICAgQ29tcGlsZU1ldGhvZC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2JvZHlTdGF0ZW1lbnRzLmxlbmd0aCA9PT0gMDsgfTtcbiAgICAgIHJldHVybiBDb21waWxlTWV0aG9kO1xuICB9KCkpO1xuXG4gIC8qKlxuICAgKiBAbGljZW5zZVxuICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICpcbiAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgKi9cbiAgdmFyIF9fZXh0ZW5kcyQxNSA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgfTtcbiAgZnVuY3Rpb24gZ2V0UHJvcGVydHlJblZpZXcocHJvcGVydHksIGNhbGxpbmdWaWV3LCBkZWZpbmVkVmlldykge1xuICAgICAgaWYgKGNhbGxpbmdWaWV3ID09PSBkZWZpbmVkVmlldykge1xuICAgICAgICAgIHJldHVybiBwcm9wZXJ0eTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciB2aWV3UHJvcCA9IFRISVNfRVhQUjtcbiAgICAgICAgICB2YXIgY3VyclZpZXcgPSBjYWxsaW5nVmlldztcbiAgICAgICAgICB3aGlsZSAoY3VyclZpZXcgIT09IGRlZmluZWRWaWV3ICYmIGlzUHJlc2VudChjdXJyVmlldy5kZWNsYXJhdGlvbkVsZW1lbnQudmlldykpIHtcbiAgICAgICAgICAgICAgY3VyclZpZXcgPSBjdXJyVmlldy5kZWNsYXJhdGlvbkVsZW1lbnQudmlldztcbiAgICAgICAgICAgICAgdmlld1Byb3AgPSB2aWV3UHJvcC5wcm9wKCdwYXJlbnQnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGN1cnJWaWV3ICE9PSBkZWZpbmVkVmlldykge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnRlcm5hbCBlcnJvcjogQ291bGQgbm90IGNhbGN1bGF0ZSBhIHByb3BlcnR5IGluIGEgcGFyZW50IHZpZXc6IFwiICsgcHJvcGVydHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcHJvcGVydHkudmlzaXRFeHByZXNzaW9uKG5ldyBfUmVwbGFjZVZpZXdUcmFuc2Zvcm1lcih2aWV3UHJvcCwgZGVmaW5lZFZpZXcpLCBudWxsKTtcbiAgICAgIH1cbiAgfVxuICB2YXIgX1JlcGxhY2VWaWV3VHJhbnNmb3JtZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDE1KF9SZXBsYWNlVmlld1RyYW5zZm9ybWVyLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gX1JlcGxhY2VWaWV3VHJhbnNmb3JtZXIoX3ZpZXdFeHByLCBfdmlldykge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgIHRoaXMuX3ZpZXdFeHByID0gX3ZpZXdFeHByO1xuICAgICAgICAgIHRoaXMuX3ZpZXcgPSBfdmlldztcbiAgICAgIH1cbiAgICAgIF9SZXBsYWNlVmlld1RyYW5zZm9ybWVyLnByb3RvdHlwZS5faXNUaGlzID0gZnVuY3Rpb24gKGV4cHIpIHtcbiAgICAgICAgICByZXR1cm4gZXhwciBpbnN0YW5jZW9mIFJlYWRWYXJFeHByICYmIGV4cHIuYnVpbHRpbiA9PT0gQnVpbHRpblZhci5UaGlzO1xuICAgICAgfTtcbiAgICAgIF9SZXBsYWNlVmlld1RyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFJlYWRWYXJFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9pc1RoaXMoYXN0KSA/IHRoaXMuX3ZpZXdFeHByIDogYXN0O1xuICAgICAgfTtcbiAgICAgIF9SZXBsYWNlVmlld1RyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFJlYWRQcm9wRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICBpZiAodGhpcy5faXNUaGlzKGFzdC5yZWNlaXZlcikpIHtcbiAgICAgICAgICAgICAgLy8gTm90ZTogRG9uJ3QgY2FzdCBmb3IgbWVtYmVycyBvZiB0aGUgQXBwVmlldyBiYXNlIGNsYXNzLi4uXG4gICAgICAgICAgICAgIGlmICh0aGlzLl92aWV3LmZpZWxkcy5zb21lKGZ1bmN0aW9uIChmaWVsZCkgeyByZXR1cm4gZmllbGQubmFtZSA9PSBhc3QubmFtZTsgfSkgfHxcbiAgICAgICAgICAgICAgICAgIHRoaXMuX3ZpZXcuZ2V0dGVycy5zb21lKGZ1bmN0aW9uIChmaWVsZCkgeyByZXR1cm4gZmllbGQubmFtZSA9PSBhc3QubmFtZTsgfSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92aWV3RXhwci5jYXN0KHRoaXMuX3ZpZXcuY2xhc3NUeXBlKS5wcm9wKGFzdC5uYW1lKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS52aXNpdFJlYWRQcm9wRXhwci5jYWxsKHRoaXMsIGFzdCwgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIF9SZXBsYWNlVmlld1RyYW5zZm9ybWVyO1xuICB9KEV4cHJlc3Npb25UcmFuc2Zvcm1lcikpO1xuICBmdW5jdGlvbiBpbmplY3RGcm9tVmlld1BhcmVudEluamVjdG9yKHRva2VuLCBvcHRpb25hbCkge1xuICAgICAgdmFyIGFyZ3MgPSBbY3JlYXRlRGlUb2tlbkV4cHJlc3Npb24odG9rZW4pXTtcbiAgICAgIGlmIChvcHRpb25hbCkge1xuICAgICAgICAgIGFyZ3MucHVzaChOVUxMX0VYUFIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFRISVNfRVhQUi5wcm9wKCdwYXJlbnRJbmplY3RvcicpLmNhbGxNZXRob2QoJ2dldCcsIGFyZ3MpO1xuICB9XG4gIGZ1bmN0aW9uIGdldFZpZXdGYWN0b3J5TmFtZShjb21wb25lbnQsIGVtYmVkZGVkVGVtcGxhdGVJbmRleCkge1xuICAgICAgcmV0dXJuIFwidmlld0ZhY3RvcnlfXCIgKyBjb21wb25lbnQudHlwZS5uYW1lICsgZW1iZWRkZWRUZW1wbGF0ZUluZGV4O1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZUZsYXRBcnJheShleHByZXNzaW9ucykge1xuICAgICAgdmFyIGxhc3ROb25BcnJheUV4cHJlc3Npb25zID0gW107XG4gICAgICB2YXIgcmVzdWx0ID0gbGl0ZXJhbEFycihbXSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cHJlc3Npb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGV4cHIgPSBleHByZXNzaW9uc1tpXTtcbiAgICAgICAgICBpZiAoZXhwci50eXBlIGluc3RhbmNlb2YgQXJyYXlUeXBlKSB7XG4gICAgICAgICAgICAgIGlmIChsYXN0Tm9uQXJyYXlFeHByZXNzaW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQgPVxuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5jYWxsTWV0aG9kKEJ1aWx0aW5NZXRob2QuQ29uY2F0QXJyYXksIFtsaXRlcmFsQXJyKGxhc3ROb25BcnJheUV4cHJlc3Npb25zKV0pO1xuICAgICAgICAgICAgICAgICAgbGFzdE5vbkFycmF5RXhwcmVzc2lvbnMgPSBbXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuY2FsbE1ldGhvZChCdWlsdGluTWV0aG9kLkNvbmNhdEFycmF5LCBbZXhwcl0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgbGFzdE5vbkFycmF5RXhwcmVzc2lvbnMucHVzaChleHByKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobGFzdE5vbkFycmF5RXhwcmVzc2lvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHJlc3VsdCA9XG4gICAgICAgICAgICAgIHJlc3VsdC5jYWxsTWV0aG9kKEJ1aWx0aW5NZXRob2QuQ29uY2F0QXJyYXksIFtsaXRlcmFsQXJyKGxhc3ROb25BcnJheUV4cHJlc3Npb25zKV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVQdXJlUHJveHkoZm4sIGFyZ0NvdW50LCBwdXJlUHJveHlQcm9wLCB2aWV3KSB7XG4gICAgICB2aWV3LmZpZWxkcy5wdXNoKG5ldyBDbGFzc0ZpZWxkKHB1cmVQcm94eVByb3AubmFtZSwgbnVsbCkpO1xuICAgICAgdmFyIHB1cmVQcm94eUlkID0gYXJnQ291bnQgPCBJZGVudGlmaWVycy5wdXJlUHJveGllcy5sZW5ndGggPyBJZGVudGlmaWVycy5wdXJlUHJveGllc1thcmdDb3VudF0gOiBudWxsO1xuICAgICAgaWYgKCFwdXJlUHJveHlJZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIG51bWJlciBvZiBhcmd1bWVudCBmb3IgcHVyZSBmdW5jdGlvbnM6IFwiICsgYXJnQ291bnQpO1xuICAgICAgfVxuICAgICAgdmlldy5jcmVhdGVNZXRob2QuYWRkU3RtdChUSElTX0VYUFIucHJvcChwdXJlUHJveHlQcm9wLm5hbWUpXG4gICAgICAgICAgLnNldChpbXBvcnRFeHByKHJlc29sdmVJZGVudGlmaWVyKHB1cmVQcm94eUlkKSkuY2FsbEZuKFtmbl0pKVxuICAgICAgICAgIC50b1N0bXQoKSk7XG4gIH1cblxuICB2YXIgVmlld1F1ZXJ5VmFsdWVzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFZpZXdRdWVyeVZhbHVlcyh2aWV3LCB2YWx1ZXMpIHtcbiAgICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICAgIHRoaXMudmFsdWVzID0gdmFsdWVzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFZpZXdRdWVyeVZhbHVlcztcbiAgfSgpKTtcbiAgdmFyIENvbXBpbGVRdWVyeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBDb21waWxlUXVlcnkobWV0YSwgcXVlcnlMaXN0LCBvd25lckRpcmVjdGl2ZUV4cHJlc3Npb24sIHZpZXcpIHtcbiAgICAgICAgICB0aGlzLm1ldGEgPSBtZXRhO1xuICAgICAgICAgIHRoaXMucXVlcnlMaXN0ID0gcXVlcnlMaXN0O1xuICAgICAgICAgIHRoaXMub3duZXJEaXJlY3RpdmVFeHByZXNzaW9uID0gb3duZXJEaXJlY3RpdmVFeHByZXNzaW9uO1xuICAgICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgICAgdGhpcy5fdmFsdWVzID0gbmV3IFZpZXdRdWVyeVZhbHVlcyh2aWV3LCBbXSk7XG4gICAgICB9XG4gICAgICBDb21waWxlUXVlcnkucHJvdG90eXBlLmFkZFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCB2aWV3KSB7XG4gICAgICAgICAgdmFyIGN1cnJlbnRWaWV3ID0gdmlldztcbiAgICAgICAgICB2YXIgZWxQYXRoID0gW107XG4gICAgICAgICAgd2hpbGUgKGlzUHJlc2VudChjdXJyZW50VmlldykgJiYgY3VycmVudFZpZXcgIT09IHRoaXMudmlldykge1xuICAgICAgICAgICAgICB2YXIgcGFyZW50RWwgPSBjdXJyZW50Vmlldy5kZWNsYXJhdGlvbkVsZW1lbnQ7XG4gICAgICAgICAgICAgIGVsUGF0aC51bnNoaWZ0KHBhcmVudEVsKTtcbiAgICAgICAgICAgICAgY3VycmVudFZpZXcgPSBwYXJlbnRFbC52aWV3O1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcXVlcnlMaXN0Rm9yRGlydHlFeHByID0gZ2V0UHJvcGVydHlJblZpZXcodGhpcy5xdWVyeUxpc3QsIHZpZXcsIHRoaXMudmlldyk7XG4gICAgICAgICAgdmFyIHZpZXdWYWx1ZXMgPSB0aGlzLl92YWx1ZXM7XG4gICAgICAgICAgZWxQYXRoLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgIHZhciBsYXN0ID0gdmlld1ZhbHVlcy52YWx1ZXMubGVuZ3RoID4gMCA/IHZpZXdWYWx1ZXMudmFsdWVzW3ZpZXdWYWx1ZXMudmFsdWVzLmxlbmd0aCAtIDFdIDogbnVsbDtcbiAgICAgICAgICAgICAgaWYgKGxhc3QgaW5zdGFuY2VvZiBWaWV3UXVlcnlWYWx1ZXMgJiYgbGFzdC52aWV3ID09PSBlbC5lbWJlZGRlZFZpZXcpIHtcbiAgICAgICAgICAgICAgICAgIHZpZXdWYWx1ZXMgPSBsYXN0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdmFyIG5ld1ZpZXdWYWx1ZXMgPSBuZXcgVmlld1F1ZXJ5VmFsdWVzKGVsLmVtYmVkZGVkVmlldywgW10pO1xuICAgICAgICAgICAgICAgICAgdmlld1ZhbHVlcy52YWx1ZXMucHVzaChuZXdWaWV3VmFsdWVzKTtcbiAgICAgICAgICAgICAgICAgIHZpZXdWYWx1ZXMgPSBuZXdWaWV3VmFsdWVzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmlld1ZhbHVlcy52YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgaWYgKGVsUGF0aC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHZpZXcuZGlydHlQYXJlbnRRdWVyaWVzTWV0aG9kLmFkZFN0bXQocXVlcnlMaXN0Rm9yRGlydHlFeHByLmNhbGxNZXRob2QoJ3NldERpcnR5JywgW10pLnRvU3RtdCgpKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgQ29tcGlsZVF1ZXJ5LnByb3RvdHlwZS5faXNTdGF0aWMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuICF0aGlzLl92YWx1ZXMudmFsdWVzLnNvbWUoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFZpZXdRdWVyeVZhbHVlczsgfSk7XG4gICAgICB9O1xuICAgICAgQ29tcGlsZVF1ZXJ5LnByb3RvdHlwZS5hZnRlckNoaWxkcmVuID0gZnVuY3Rpb24gKHRhcmdldFN0YXRpY01ldGhvZCwgdGFyZ2V0RHluYW1pY01ldGhvZCkge1xuICAgICAgICAgIHZhciB2YWx1ZXMgPSBjcmVhdGVRdWVyeVZhbHVlcyh0aGlzLl92YWx1ZXMpO1xuICAgICAgICAgIHZhciB1cGRhdGVTdG10cyA9IFt0aGlzLnF1ZXJ5TGlzdC5jYWxsTWV0aG9kKCdyZXNldCcsIFtsaXRlcmFsQXJyKHZhbHVlcyldKS50b1N0bXQoKV07XG4gICAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLm93bmVyRGlyZWN0aXZlRXhwcmVzc2lvbikpIHtcbiAgICAgICAgICAgICAgdmFyIHZhbHVlRXhwciA9IHRoaXMubWV0YS5maXJzdCA/IHRoaXMucXVlcnlMaXN0LnByb3AoJ2ZpcnN0JykgOiB0aGlzLnF1ZXJ5TGlzdDtcbiAgICAgICAgICAgICAgdXBkYXRlU3RtdHMucHVzaCh0aGlzLm93bmVyRGlyZWN0aXZlRXhwcmVzc2lvbi5wcm9wKHRoaXMubWV0YS5wcm9wZXJ0eU5hbWUpLnNldCh2YWx1ZUV4cHIpLnRvU3RtdCgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF0aGlzLm1ldGEuZmlyc3QpIHtcbiAgICAgICAgICAgICAgdXBkYXRlU3RtdHMucHVzaCh0aGlzLnF1ZXJ5TGlzdC5jYWxsTWV0aG9kKCdub3RpZnlPbkNoYW5nZXMnLCBbXSkudG9TdG10KCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5tZXRhLmZpcnN0ICYmIHRoaXMuX2lzU3RhdGljKCkpIHtcbiAgICAgICAgICAgICAgLy8gZm9yIHF1ZXJpZXMgdGhhdCBkb24ndCBjaGFuZ2UgYW5kIHRoZSB1c2VyIGFza2VkIGZvciBhIHNpbmdsZSBlbGVtZW50LFxuICAgICAgICAgICAgICAvLyBzZXQgaXQgaW1tZWRpYXRlbHkuIFRoYXQgaXMgZS5nLiBuZWVkZWQgZm9yIHF1ZXJ5aW5nIGZvciBWaWV3Q29udGFpbmVyUmVmcywgLi4uXG4gICAgICAgICAgICAgIC8vIHdlIGRvbid0IGRvIHRoaXMgZm9yIFF1ZXJ5TGlzdHMgZm9yIG5vdyBhcyB0aGlzIHdvdWxkIGJyZWFrIHRoZSB0aW1pbmcgd2hlblxuICAgICAgICAgICAgICAvLyB3ZSBjYWxsIFF1ZXJ5TGlzdCBsaXN0ZW5lcnMuLi5cbiAgICAgICAgICAgICAgdGFyZ2V0U3RhdGljTWV0aG9kLmFkZFN0bXRzKHVwZGF0ZVN0bXRzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHRhcmdldER5bmFtaWNNZXRob2QuYWRkU3RtdChuZXcgSWZTdG10KHRoaXMucXVlcnlMaXN0LnByb3AoJ2RpcnR5JyksIHVwZGF0ZVN0bXRzKSk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiBDb21waWxlUXVlcnk7XG4gIH0oKSk7XG4gIGZ1bmN0aW9uIGNyZWF0ZVF1ZXJ5VmFsdWVzKHZpZXdWYWx1ZXMpIHtcbiAgICAgIHJldHVybiBMaXN0V3JhcHBlci5mbGF0dGVuKHZpZXdWYWx1ZXMudmFsdWVzLm1hcChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICBpZiAoZW50cnkgaW5zdGFuY2VvZiBWaWV3UXVlcnlWYWx1ZXMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG1hcE5lc3RlZFZpZXdzKGVudHJ5LnZpZXcuZGVjbGFyYXRpb25FbGVtZW50LmFwcEVsZW1lbnQsIGVudHJ5LnZpZXcsIGNyZWF0ZVF1ZXJ5VmFsdWVzKGVudHJ5KSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gZW50cnk7XG4gICAgICAgICAgfVxuICAgICAgfSkpO1xuICB9XG4gIGZ1bmN0aW9uIG1hcE5lc3RlZFZpZXdzKGRlY2xhcmF0aW9uQXBwRWxlbWVudCwgdmlldywgZXhwcmVzc2lvbnMpIHtcbiAgICAgIHZhciBhZGp1c3RlZEV4cHJlc3Npb25zID0gZXhwcmVzc2lvbnMubWFwKGZ1bmN0aW9uIChleHByKSB7IHJldHVybiByZXBsYWNlVmFySW5FeHByZXNzaW9uKFRISVNfRVhQUi5uYW1lLCB2YXJpYWJsZSgnbmVzdGVkVmlldycpLCBleHByKTsgfSk7XG4gICAgICByZXR1cm4gZGVjbGFyYXRpb25BcHBFbGVtZW50LmNhbGxNZXRob2QoJ21hcE5lc3RlZFZpZXdzJywgW1xuICAgICAgICAgIHZhcmlhYmxlKHZpZXcuY2xhc3NOYW1lKSxcbiAgICAgICAgICBmbihbbmV3IEZuUGFyYW0oJ25lc3RlZFZpZXcnLCB2aWV3LmNsYXNzVHlwZSldLCBbbmV3IFJldHVyblN0YXRlbWVudChsaXRlcmFsQXJyKGFkanVzdGVkRXhwcmVzc2lvbnMpKV0sIERZTkFNSUNfVFlQRSlcbiAgICAgIF0pO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZVF1ZXJ5TGlzdChxdWVyeSwgZGlyZWN0aXZlSW5zdGFuY2UsIHByb3BlcnR5TmFtZSwgY29tcGlsZVZpZXcpIHtcbiAgICAgIGNvbXBpbGVWaWV3LmZpZWxkcy5wdXNoKG5ldyBDbGFzc0ZpZWxkKHByb3BlcnR5TmFtZSwgaW1wb3J0VHlwZShyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5RdWVyeUxpc3QpLCBbRFlOQU1JQ19UWVBFXSkpKTtcbiAgICAgIHZhciBleHByID0gVEhJU19FWFBSLnByb3AocHJvcGVydHlOYW1lKTtcbiAgICAgIGNvbXBpbGVWaWV3LmNyZWF0ZU1ldGhvZC5hZGRTdG10KFRISVNfRVhQUi5wcm9wKHByb3BlcnR5TmFtZSlcbiAgICAgICAgICAuc2V0KGltcG9ydEV4cHIocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuUXVlcnlMaXN0KSwgW0RZTkFNSUNfVFlQRV0pXG4gICAgICAgICAgLmluc3RhbnRpYXRlKFtdKSlcbiAgICAgICAgICAudG9TdG10KCkpO1xuICAgICAgcmV0dXJuIGV4cHI7XG4gIH1cbiAgZnVuY3Rpb24gYWRkUXVlcnlUb1Rva2VuTWFwKG1hcCwgcXVlcnkpIHtcbiAgICAgIHF1ZXJ5Lm1ldGEuc2VsZWN0b3JzLmZvckVhY2goZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICAgICAgdmFyIGVudHJ5ID0gbWFwLmdldChzZWxlY3Rvci5yZWZlcmVuY2UpO1xuICAgICAgICAgIGlmICghZW50cnkpIHtcbiAgICAgICAgICAgICAgZW50cnkgPSBbXTtcbiAgICAgICAgICAgICAgbWFwLnNldChzZWxlY3Rvci5yZWZlcmVuY2UsIGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZW50cnkucHVzaChxdWVyeSk7XG4gICAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9lbnVtRXhwcmVzc2lvbihjbGFzc0lkZW50aWZpZXIsIG5hbWUpIHtcbiAgICAgIHJldHVybiBpbXBvcnRFeHByKHJlc29sdmVFbnVtSWRlbnRpZmllcihjbGFzc0lkZW50aWZpZXIsIG5hbWUpKTtcbiAgfVxuICB2YXIgVmlld1R5cGVFbnVtID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFZpZXdUeXBlRW51bSgpIHtcbiAgICAgIH1cbiAgICAgIFZpZXdUeXBlRW51bS5mcm9tVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB2YXIgdmlld1R5cGUgPSByZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5WaWV3VHlwZSk7XG4gICAgICAgICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgICAgICAgICBjYXNlIFZpZXdUeXBlLkhPU1Q6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2VudW1FeHByZXNzaW9uKHZpZXdUeXBlLCAnSE9TVCcpO1xuICAgICAgICAgICAgICBjYXNlIFZpZXdUeXBlLkNPTVBPTkVOVDpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfZW51bUV4cHJlc3Npb24odmlld1R5cGUsICdDT01QT05FTlQnKTtcbiAgICAgICAgICAgICAgY2FzZSBWaWV3VHlwZS5FTUJFRERFRDpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfZW51bUV4cHJlc3Npb24odmlld1R5cGUsICdFTUJFRERFRCcpO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbmF2bGlkIFZpZXdUeXBlIHZhbHVlOiBcIiArIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFZpZXdUeXBlRW51bTtcbiAgfSgpKTtcbiAgdmFyIFZpZXdFbmNhcHN1bGF0aW9uRW51bSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBWaWV3RW5jYXBzdWxhdGlvbkVudW0oKSB7XG4gICAgICB9XG4gICAgICBWaWV3RW5jYXBzdWxhdGlvbkVudW0uZnJvbVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIHZpZXdFbmNhcHN1bGF0aW9uID0gcmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuVmlld0VuY2Fwc3VsYXRpb24pO1xuICAgICAgICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgICAgICAgICAgY2FzZSBfYW5ndWxhcl9jb3JlLlZpZXdFbmNhcHN1bGF0aW9uLkVtdWxhdGVkOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9lbnVtRXhwcmVzc2lvbih2aWV3RW5jYXBzdWxhdGlvbiwgJ0VtdWxhdGVkJyk7XG4gICAgICAgICAgICAgIGNhc2UgX2FuZ3VsYXJfY29yZS5WaWV3RW5jYXBzdWxhdGlvbi5OYXRpdmU6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2VudW1FeHByZXNzaW9uKHZpZXdFbmNhcHN1bGF0aW9uLCAnTmF0aXZlJyk7XG4gICAgICAgICAgICAgIGNhc2UgX2FuZ3VsYXJfY29yZS5WaWV3RW5jYXBzdWxhdGlvbi5Ob25lOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9lbnVtRXhwcmVzc2lvbih2aWV3RW5jYXBzdWxhdGlvbiwgJ05vbmUnKTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSW5hdmxpZCBWaWV3RW5jYXBzdWxhdGlvbiB2YWx1ZTogXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiBWaWV3RW5jYXBzdWxhdGlvbkVudW07XG4gIH0oKSk7XG4gIHZhciBDaGFuZ2VEZXRlY3RvclN0YXR1c0VudW0gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQ2hhbmdlRGV0ZWN0b3JTdGF0dXNFbnVtKCkge1xuICAgICAgfVxuICAgICAgQ2hhbmdlRGV0ZWN0b3JTdGF0dXNFbnVtLmZyb21WYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHZhciBjaGFuZ2VEZXRlY3RvclN0YXR1cyA9IHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLkNoYW5nZURldGVjdG9yU3RhdHVzKTtcbiAgICAgICAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAgICAgICAgIGNhc2UgQ2hhbmdlRGV0ZWN0b3JTdGF0dXMuQ2hlY2tPbmNlOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9lbnVtRXhwcmVzc2lvbihjaGFuZ2VEZXRlY3RvclN0YXR1cywgJ0NoZWNrT25jZScpO1xuICAgICAgICAgICAgICBjYXNlIENoYW5nZURldGVjdG9yU3RhdHVzLkNoZWNrZWQ6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2VudW1FeHByZXNzaW9uKGNoYW5nZURldGVjdG9yU3RhdHVzLCAnQ2hlY2tlZCcpO1xuICAgICAgICAgICAgICBjYXNlIENoYW5nZURldGVjdG9yU3RhdHVzLkNoZWNrQWx3YXlzOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9lbnVtRXhwcmVzc2lvbihjaGFuZ2VEZXRlY3RvclN0YXR1cywgJ0NoZWNrQWx3YXlzJyk7XG4gICAgICAgICAgICAgIGNhc2UgQ2hhbmdlRGV0ZWN0b3JTdGF0dXMuRGV0YWNoZWQ6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2VudW1FeHByZXNzaW9uKGNoYW5nZURldGVjdG9yU3RhdHVzLCAnRGV0YWNoZWQnKTtcbiAgICAgICAgICAgICAgY2FzZSBDaGFuZ2VEZXRlY3RvclN0YXR1cy5FcnJvcmVkOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9lbnVtRXhwcmVzc2lvbihjaGFuZ2VEZXRlY3RvclN0YXR1cywgJ0Vycm9yZWQnKTtcbiAgICAgICAgICAgICAgY2FzZSBDaGFuZ2VEZXRlY3RvclN0YXR1cy5EZXN0cm95ZWQ6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2VudW1FeHByZXNzaW9uKGNoYW5nZURldGVjdG9yU3RhdHVzLCAnRGVzdHJveWVkJyk7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIkluYXZsaWQgQ2hhbmdlRGV0ZWN0b3JTdGF0dXMgdmFsdWU6IFwiICsgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gQ2hhbmdlRGV0ZWN0b3JTdGF0dXNFbnVtO1xuICB9KCkpO1xuICB2YXIgVmlld0NvbnN0cnVjdG9yVmFycyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBWaWV3Q29uc3RydWN0b3JWYXJzKCkge1xuICAgICAgfVxuICAgICAgVmlld0NvbnN0cnVjdG9yVmFycy52aWV3VXRpbHMgPSB2YXJpYWJsZSgndmlld1V0aWxzJyk7XG4gICAgICBWaWV3Q29uc3RydWN0b3JWYXJzLnBhcmVudEluamVjdG9yID0gdmFyaWFibGUoJ3BhcmVudEluamVjdG9yJyk7XG4gICAgICBWaWV3Q29uc3RydWN0b3JWYXJzLmRlY2xhcmF0aW9uRWwgPSB2YXJpYWJsZSgnZGVjbGFyYXRpb25FbCcpO1xuICAgICAgcmV0dXJuIFZpZXdDb25zdHJ1Y3RvclZhcnM7XG4gIH0oKSk7XG4gIHZhciBWaWV3UHJvcGVydGllcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBWaWV3UHJvcGVydGllcygpIHtcbiAgICAgIH1cbiAgICAgIFZpZXdQcm9wZXJ0aWVzLnJlbmRlcmVyID0gVEhJU19FWFBSLnByb3AoJ3JlbmRlcmVyJyk7XG4gICAgICBWaWV3UHJvcGVydGllcy5wcm9qZWN0YWJsZU5vZGVzID0gVEhJU19FWFBSLnByb3AoJ3Byb2plY3RhYmxlTm9kZXMnKTtcbiAgICAgIFZpZXdQcm9wZXJ0aWVzLnZpZXdVdGlscyA9IFRISVNfRVhQUi5wcm9wKCd2aWV3VXRpbHMnKTtcbiAgICAgIHJldHVybiBWaWV3UHJvcGVydGllcztcbiAgfSgpKTtcbiAgdmFyIEV2ZW50SGFuZGxlclZhcnMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gRXZlbnRIYW5kbGVyVmFycygpIHtcbiAgICAgIH1cbiAgICAgIEV2ZW50SGFuZGxlclZhcnMuZXZlbnQgPSB2YXJpYWJsZSgnJGV2ZW50Jyk7XG4gICAgICByZXR1cm4gRXZlbnRIYW5kbGVyVmFycztcbiAgfSgpKTtcbiAgdmFyIEluamVjdE1ldGhvZFZhcnMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gSW5qZWN0TWV0aG9kVmFycygpIHtcbiAgICAgIH1cbiAgICAgIEluamVjdE1ldGhvZFZhcnMudG9rZW4gPSB2YXJpYWJsZSgndG9rZW4nKTtcbiAgICAgIEluamVjdE1ldGhvZFZhcnMucmVxdWVzdE5vZGVJbmRleCA9IHZhcmlhYmxlKCdyZXF1ZXN0Tm9kZUluZGV4Jyk7XG4gICAgICBJbmplY3RNZXRob2RWYXJzLm5vdEZvdW5kUmVzdWx0ID0gdmFyaWFibGUoJ25vdEZvdW5kUmVzdWx0Jyk7XG4gICAgICByZXR1cm4gSW5qZWN0TWV0aG9kVmFycztcbiAgfSgpKTtcbiAgdmFyIERldGVjdENoYW5nZXNWYXJzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIERldGVjdENoYW5nZXNWYXJzKCkge1xuICAgICAgfVxuICAgICAgRGV0ZWN0Q2hhbmdlc1ZhcnMudGhyb3dPbkNoYW5nZSA9IHZhcmlhYmxlKFwidGhyb3dPbkNoYW5nZVwiKTtcbiAgICAgIERldGVjdENoYW5nZXNWYXJzLmNoYW5nZXMgPSB2YXJpYWJsZShcImNoYW5nZXNcIik7XG4gICAgICBEZXRlY3RDaGFuZ2VzVmFycy5jaGFuZ2VkID0gdmFyaWFibGUoXCJjaGFuZ2VkXCIpO1xuICAgICAgRGV0ZWN0Q2hhbmdlc1ZhcnMudmFsVW53cmFwcGVyID0gdmFyaWFibGUoXCJ2YWxVbndyYXBwZXJcIik7XG4gICAgICByZXR1cm4gRGV0ZWN0Q2hhbmdlc1ZhcnM7XG4gIH0oKSk7XG5cbiAgLyoqXG4gICAqIEBsaWNlbnNlXG4gICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgKlxuICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAqL1xuICB2YXIgVmlld0ZhY3RvcnlEZXBlbmRlbmN5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFZpZXdGYWN0b3J5RGVwZW5kZW5jeShjb21wLCBwbGFjZWhvbGRlcikge1xuICAgICAgICAgIHRoaXMuY29tcCA9IGNvbXA7XG4gICAgICAgICAgdGhpcy5wbGFjZWhvbGRlciA9IHBsYWNlaG9sZGVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFZpZXdGYWN0b3J5RGVwZW5kZW5jeTtcbiAgfSgpKTtcbiAgdmFyIENvbXBvbmVudEZhY3RvcnlEZXBlbmRlbmN5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIENvbXBvbmVudEZhY3RvcnlEZXBlbmRlbmN5KGNvbXAsIHBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgdGhpcy5jb21wID0gY29tcDtcbiAgICAgICAgICB0aGlzLnBsYWNlaG9sZGVyID0gcGxhY2Vob2xkZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gQ29tcG9uZW50RmFjdG9yeURlcGVuZGVuY3k7XG4gIH0oKSk7XG4gIHZhciBEaXJlY3RpdmVXcmFwcGVyRGVwZW5kZW5jeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBEaXJlY3RpdmVXcmFwcGVyRGVwZW5kZW5jeShkaXIsIHBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgdGhpcy5kaXIgPSBkaXI7XG4gICAgICAgICAgdGhpcy5wbGFjZWhvbGRlciA9IHBsYWNlaG9sZGVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIERpcmVjdGl2ZVdyYXBwZXJEZXBlbmRlbmN5O1xuICB9KCkpO1xuXG4gIC8qKlxuICAgKiBAbGljZW5zZVxuICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICpcbiAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgKi9cbiAgdmFyIF9fZXh0ZW5kcyQxNCA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgfTtcbiAgdmFyIENvbXBpbGVOb2RlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIENvbXBpbGVOb2RlKHBhcmVudCwgdmlldywgbm9kZUluZGV4LCByZW5kZXJOb2RlLCBzb3VyY2VBc3QpIHtcbiAgICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICAgIHRoaXMubm9kZUluZGV4ID0gbm9kZUluZGV4O1xuICAgICAgICAgIHRoaXMucmVuZGVyTm9kZSA9IHJlbmRlck5vZGU7XG4gICAgICAgICAgdGhpcy5zb3VyY2VBc3QgPSBzb3VyY2VBc3Q7XG4gICAgICB9XG4gICAgICBDb21waWxlTm9kZS5wcm90b3R5cGUuaXNOdWxsID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gIXRoaXMucmVuZGVyTm9kZTsgfTtcbiAgICAgIENvbXBpbGVOb2RlLnByb3RvdHlwZS5pc1Jvb3RFbGVtZW50ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy52aWV3ICE9IHRoaXMucGFyZW50LnZpZXc7IH07XG4gICAgICByZXR1cm4gQ29tcGlsZU5vZGU7XG4gIH0oKSk7XG4gIHZhciBDb21waWxlRWxlbWVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMTQoQ29tcGlsZUVsZW1lbnQsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBDb21waWxlRWxlbWVudChwYXJlbnQsIHZpZXcsIG5vZGVJbmRleCwgcmVuZGVyTm9kZSwgc291cmNlQXN0LCBjb21wb25lbnQsIF9kaXJlY3RpdmVzLCBfcmVzb2x2ZWRQcm92aWRlcnNBcnJheSwgaGFzVmlld0NvbnRhaW5lciwgaGFzRW1iZWRkZWRWaWV3LCByZWZlcmVuY2VzLCBfdGFyZ2V0RGVwZW5kZW5jaWVzKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBwYXJlbnQsIHZpZXcsIG5vZGVJbmRleCwgcmVuZGVyTm9kZSwgc291cmNlQXN0KTtcbiAgICAgICAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgICAgICAgICB0aGlzLl9kaXJlY3RpdmVzID0gX2RpcmVjdGl2ZXM7XG4gICAgICAgICAgdGhpcy5fcmVzb2x2ZWRQcm92aWRlcnNBcnJheSA9IF9yZXNvbHZlZFByb3ZpZGVyc0FycmF5O1xuICAgICAgICAgIHRoaXMuaGFzVmlld0NvbnRhaW5lciA9IGhhc1ZpZXdDb250YWluZXI7XG4gICAgICAgICAgdGhpcy5oYXNFbWJlZGRlZFZpZXcgPSBoYXNFbWJlZGRlZFZpZXc7XG4gICAgICAgICAgdGhpcy5fdGFyZ2V0RGVwZW5kZW5jaWVzID0gX3RhcmdldERlcGVuZGVuY2llcztcbiAgICAgICAgICB0aGlzLl9jb21wVmlld0V4cHIgPSBudWxsO1xuICAgICAgICAgIHRoaXMuaW5zdGFuY2VzID0gbmV3IE1hcCgpO1xuICAgICAgICAgIHRoaXMuZGlyZWN0aXZlV3JhcHBlckluc3RhbmNlID0gbmV3IE1hcCgpO1xuICAgICAgICAgIHRoaXMuX3F1ZXJ5Q291bnQgPSAwO1xuICAgICAgICAgIHRoaXMuX3F1ZXJpZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgdGhpcy5fY29tcG9uZW50Q29uc3RydWN0b3JWaWV3UXVlcnlMaXN0cyA9IFtdO1xuICAgICAgICAgIHRoaXMuY29udGVudE5vZGVzQnlOZ0NvbnRlbnRJbmRleCA9IG51bGw7XG4gICAgICAgICAgdGhpcy5yZWZlcmVuY2VUb2tlbnMgPSB7fTtcbiAgICAgICAgICByZWZlcmVuY2VzLmZvckVhY2goZnVuY3Rpb24gKHJlZikgeyByZXR1cm4gX3RoaXMucmVmZXJlbmNlVG9rZW5zW3JlZi5uYW1lXSA9IHJlZi52YWx1ZTsgfSk7XG4gICAgICAgICAgdGhpcy5lbGVtZW50UmVmID1cbiAgICAgICAgICAgICAgaW1wb3J0RXhwcihyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5FbGVtZW50UmVmKSkuaW5zdGFudGlhdGUoW3RoaXMucmVuZGVyTm9kZV0pO1xuICAgICAgICAgIHRoaXMuaW5zdGFuY2VzLnNldChyZXNvbHZlSWRlbnRpZmllclRva2VuKElkZW50aWZpZXJzLkVsZW1lbnRSZWYpLnJlZmVyZW5jZSwgdGhpcy5lbGVtZW50UmVmKTtcbiAgICAgICAgICB0aGlzLmluamVjdG9yID0gVEhJU19FWFBSLmNhbGxNZXRob2QoJ2luamVjdG9yJywgW2xpdGVyYWwodGhpcy5ub2RlSW5kZXgpXSk7XG4gICAgICAgICAgdGhpcy5pbnN0YW5jZXMuc2V0KHJlc29sdmVJZGVudGlmaWVyVG9rZW4oSWRlbnRpZmllcnMuSW5qZWN0b3IpLnJlZmVyZW5jZSwgdGhpcy5pbmplY3Rvcik7XG4gICAgICAgICAgdGhpcy5pbnN0YW5jZXMuc2V0KHJlc29sdmVJZGVudGlmaWVyVG9rZW4oSWRlbnRpZmllcnMuUmVuZGVyZXIpLnJlZmVyZW5jZSwgVEhJU19FWFBSLnByb3AoJ3JlbmRlcmVyJykpO1xuICAgICAgICAgIGlmICh0aGlzLmhhc1ZpZXdDb250YWluZXIgfHwgdGhpcy5oYXNFbWJlZGRlZFZpZXcgfHwgaXNQcmVzZW50KHRoaXMuY29tcG9uZW50KSkge1xuICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVBcHBFbGVtZW50KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLmNvbXBvbmVudCkge1xuICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIoKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBDb21waWxlRWxlbWVudC5jcmVhdGVOdWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBuZXcgQ29tcGlsZUVsZW1lbnQobnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgW10sIFtdLCBmYWxzZSwgZmFsc2UsIFtdLCBbXSk7XG4gICAgICB9O1xuICAgICAgQ29tcGlsZUVsZW1lbnQucHJvdG90eXBlLl9jcmVhdGVBcHBFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBmaWVsZE5hbWUgPSBcIl9hcHBFbF9cIiArIHRoaXMubm9kZUluZGV4O1xuICAgICAgICAgIHZhciBwYXJlbnROb2RlSW5kZXggPSB0aGlzLmlzUm9vdEVsZW1lbnQoKSA/IG51bGwgOiB0aGlzLnBhcmVudC5ub2RlSW5kZXg7XG4gICAgICAgICAgLy8gcHJpdmF0ZSBpcyBmaW5lIGhlcmUgYXMgbm8gY2hpbGQgdmlldyB3aWxsIHJlZmVyZW5jZSBhbiBBcHBFbGVtZW50XG4gICAgICAgICAgdGhpcy52aWV3LmZpZWxkcy5wdXNoKG5ldyBDbGFzc0ZpZWxkKGZpZWxkTmFtZSwgaW1wb3J0VHlwZShyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5BcHBFbGVtZW50KSksIFtTdG10TW9kaWZpZXIuUHJpdmF0ZV0pKTtcbiAgICAgICAgICB2YXIgc3RhdGVtZW50ID0gVEhJU19FWFBSLnByb3AoZmllbGROYW1lKVxuICAgICAgICAgICAgICAuc2V0KGltcG9ydEV4cHIocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuQXBwRWxlbWVudCkpLmluc3RhbnRpYXRlKFtcbiAgICAgICAgICAgICAgbGl0ZXJhbCh0aGlzLm5vZGVJbmRleCksIGxpdGVyYWwocGFyZW50Tm9kZUluZGV4KSwgVEhJU19FWFBSLCB0aGlzLnJlbmRlck5vZGVcbiAgICAgICAgICBdKSlcbiAgICAgICAgICAgICAgLnRvU3RtdCgpO1xuICAgICAgICAgIHRoaXMudmlldy5jcmVhdGVNZXRob2QuYWRkU3RtdChzdGF0ZW1lbnQpO1xuICAgICAgICAgIHRoaXMuYXBwRWxlbWVudCA9IFRISVNfRVhQUi5wcm9wKGZpZWxkTmFtZSk7XG4gICAgICAgICAgdGhpcy5pbnN0YW5jZXMuc2V0KHJlc29sdmVJZGVudGlmaWVyVG9rZW4oSWRlbnRpZmllcnMuQXBwRWxlbWVudCkucmVmZXJlbmNlLCB0aGlzLmFwcEVsZW1lbnQpO1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVFbGVtZW50LnByb3RvdHlwZS5fY3JlYXRlQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIGVudHJ5Q29tcG9uZW50cyA9IHRoaXMuY29tcG9uZW50LmVudHJ5Q29tcG9uZW50cy5tYXAoZnVuY3Rpb24gKGVudHJ5Q29tcG9uZW50KSB7XG4gICAgICAgICAgICAgIHZhciBpZCA9IG5ldyBDb21waWxlSWRlbnRpZmllck1ldGFkYXRhKHsgbmFtZTogZW50cnlDb21wb25lbnQubmFtZSB9KTtcbiAgICAgICAgICAgICAgX3RoaXMuX3RhcmdldERlcGVuZGVuY2llcy5wdXNoKG5ldyBDb21wb25lbnRGYWN0b3J5RGVwZW5kZW5jeShlbnRyeUNvbXBvbmVudCwgaWQpKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICghZW50cnlDb21wb25lbnRzIHx8IGVudHJ5Q29tcG9uZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgY3JlYXRlQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyRXhwciA9IGltcG9ydEV4cHIocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuQ29kZWdlbkNvbXBvbmVudEZhY3RvcnlSZXNvbHZlcikpLmluc3RhbnRpYXRlKFtcbiAgICAgICAgICAgICAgbGl0ZXJhbEFycihlbnRyeUNvbXBvbmVudHMubWFwKGZ1bmN0aW9uIChlbnRyeUNvbXBvbmVudCkgeyByZXR1cm4gaW1wb3J0RXhwcihlbnRyeUNvbXBvbmVudCk7IH0pKSxcbiAgICAgICAgICAgICAgaW5qZWN0RnJvbVZpZXdQYXJlbnRJbmplY3RvcihyZXNvbHZlSWRlbnRpZmllclRva2VuKElkZW50aWZpZXJzLkNvbXBvbmVudEZhY3RvcnlSZXNvbHZlciksIGZhbHNlKVxuICAgICAgICAgIF0pO1xuICAgICAgICAgIHZhciBwcm92aWRlciA9IG5ldyBDb21waWxlUHJvdmlkZXJNZXRhZGF0YSh7XG4gICAgICAgICAgICAgIHRva2VuOiByZXNvbHZlSWRlbnRpZmllclRva2VuKElkZW50aWZpZXJzLkNvbXBvbmVudEZhY3RvcnlSZXNvbHZlciksXG4gICAgICAgICAgICAgIHVzZVZhbHVlOiBjcmVhdGVDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXJFeHByXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgLy8gQWRkIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlciBhcyBmaXJzdCBwcm92aWRlciBhcyBpdCBkb2VzIG5vdCBoYXZlIGRlcHMgb24gb3RoZXIgcHJvdmlkZXJzXG4gICAgICAgICAgLy8gUHJvdmlkZXJBc3RUeXBlLlByaXZhdGVTZXJ2aWNlIGFzIG9ubHkgdGhlIGNvbXBvbmVudCBhbmQgaXRzIHZpZXcgY2FuIHNlZSBpdCxcbiAgICAgICAgICAvLyBidXQgbm9ib2R5IGVsc2VcbiAgICAgICAgICB0aGlzLl9yZXNvbHZlZFByb3ZpZGVyc0FycmF5LnVuc2hpZnQobmV3IFByb3ZpZGVyQXN0KHByb3ZpZGVyLnRva2VuLCBmYWxzZSwgdHJ1ZSwgW3Byb3ZpZGVyXSwgZXhwb3J0cy5Qcm92aWRlckFzdFR5cGUuUHJpdmF0ZVNlcnZpY2UsIFtdLCB0aGlzLnNvdXJjZUFzdC5zb3VyY2VTcGFuKSk7XG4gICAgICB9O1xuICAgICAgQ29tcGlsZUVsZW1lbnQucHJvdG90eXBlLnNldENvbXBvbmVudFZpZXcgPSBmdW5jdGlvbiAoY29tcFZpZXdFeHByKSB7XG4gICAgICAgICAgdGhpcy5fY29tcFZpZXdFeHByID0gY29tcFZpZXdFeHByO1xuICAgICAgICAgIHRoaXMuY29udGVudE5vZGVzQnlOZ0NvbnRlbnRJbmRleCA9XG4gICAgICAgICAgICAgIG5ldyBBcnJheSh0aGlzLmNvbXBvbmVudC50ZW1wbGF0ZS5uZ0NvbnRlbnRTZWxlY3RvcnMubGVuZ3RoKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29udGVudE5vZGVzQnlOZ0NvbnRlbnRJbmRleC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB0aGlzLmNvbnRlbnROb2Rlc0J5TmdDb250ZW50SW5kZXhbaV0gPSBbXTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgQ29tcGlsZUVsZW1lbnQucHJvdG90eXBlLnNldEVtYmVkZGVkVmlldyA9IGZ1bmN0aW9uIChlbWJlZGRlZFZpZXcpIHtcbiAgICAgICAgICB0aGlzLmVtYmVkZGVkVmlldyA9IGVtYmVkZGVkVmlldztcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KGVtYmVkZGVkVmlldykpIHtcbiAgICAgICAgICAgICAgdmFyIGNyZWF0ZVRlbXBsYXRlUmVmRXhwciA9IGltcG9ydEV4cHIocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuVGVtcGxhdGVSZWZfKSkuaW5zdGFudGlhdGUoW1xuICAgICAgICAgICAgICAgICAgdGhpcy5hcHBFbGVtZW50LCB0aGlzLmVtYmVkZGVkVmlldy52aWV3RmFjdG9yeVxuICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgdmFyIHByb3ZpZGVyID0gbmV3IENvbXBpbGVQcm92aWRlck1ldGFkYXRhKHtcbiAgICAgICAgICAgICAgICAgIHRva2VuOiByZXNvbHZlSWRlbnRpZmllclRva2VuKElkZW50aWZpZXJzLlRlbXBsYXRlUmVmKSxcbiAgICAgICAgICAgICAgICAgIHVzZVZhbHVlOiBjcmVhdGVUZW1wbGF0ZVJlZkV4cHJcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIC8vIEFkZCBUZW1wbGF0ZVJlZiBhcyBmaXJzdCBwcm92aWRlciBhcyBpdCBkb2VzIG5vdCBoYXZlIGRlcHMgb24gb3RoZXIgcHJvdmlkZXJzXG4gICAgICAgICAgICAgIHRoaXMuX3Jlc29sdmVkUHJvdmlkZXJzQXJyYXkudW5zaGlmdChuZXcgUHJvdmlkZXJBc3QocHJvdmlkZXIudG9rZW4sIGZhbHNlLCB0cnVlLCBbcHJvdmlkZXJdLCBleHBvcnRzLlByb3ZpZGVyQXN0VHlwZS5CdWlsdGluLCBbXSwgdGhpcy5zb3VyY2VBc3Quc291cmNlU3BhbikpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBDb21waWxlRWxlbWVudC5wcm90b3R5cGUuYmVmb3JlQ2hpbGRyZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICBpZiAodGhpcy5oYXNWaWV3Q29udGFpbmVyKSB7XG4gICAgICAgICAgICAgIHRoaXMuaW5zdGFuY2VzLnNldChyZXNvbHZlSWRlbnRpZmllclRva2VuKElkZW50aWZpZXJzLlZpZXdDb250YWluZXJSZWYpLnJlZmVyZW5jZSwgdGhpcy5hcHBFbGVtZW50LnByb3AoJ3ZjUmVmJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9yZXNvbHZlZFByb3ZpZGVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICB0aGlzLl9yZXNvbHZlZFByb3ZpZGVyc0FycmF5LmZvckVhY2goZnVuY3Rpb24gKHByb3ZpZGVyKSB7IHJldHVybiBfdGhpcy5fcmVzb2x2ZWRQcm92aWRlcnMuc2V0KHByb3ZpZGVyLnRva2VuLnJlZmVyZW5jZSwgcHJvdmlkZXIpOyB9KTtcbiAgICAgICAgICAvLyBjcmVhdGUgYWxsIHRoZSBwcm92aWRlciBpbnN0YW5jZXMsIHNvbWUgaW4gdGhlIHZpZXcgY29uc3RydWN0b3IsXG4gICAgICAgICAgLy8gc29tZSBhcyBnZXR0ZXJzLiBXZSByZWx5IG9uIHRoZSBmYWN0IHRoYXQgdGhleSBhcmUgYWxyZWFkeSBzb3J0ZWQgdG9wb2xvZ2ljYWxseS5cbiAgICAgICAgICBNYXBXcmFwcGVyLnZhbHVlcyh0aGlzLl9yZXNvbHZlZFByb3ZpZGVycykuZm9yRWFjaChmdW5jdGlvbiAocmVzb2x2ZWRQcm92aWRlcikge1xuICAgICAgICAgICAgICB2YXIgaXNEaXJlY3RpdmVXcmFwcGVyID0gcmVzb2x2ZWRQcm92aWRlci5wcm92aWRlclR5cGUgPT09IGV4cG9ydHMuUHJvdmlkZXJBc3RUeXBlLkNvbXBvbmVudCB8fFxuICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRQcm92aWRlci5wcm92aWRlclR5cGUgPT09IGV4cG9ydHMuUHJvdmlkZXJBc3RUeXBlLkRpcmVjdGl2ZTtcbiAgICAgICAgICAgICAgdmFyIHByb3ZpZGVyVmFsdWVFeHByZXNzaW9ucyA9IHJlc29sdmVkUHJvdmlkZXIucHJvdmlkZXJzLm1hcChmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQocHJvdmlkZXIudXNlRXhpc3RpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9nZXREZXBlbmRlbmN5KHJlc29sdmVkUHJvdmlkZXIucHJvdmlkZXJUeXBlLCBuZXcgQ29tcGlsZURpRGVwZW5kZW5jeU1ldGFkYXRhKHsgdG9rZW46IHByb3ZpZGVyLnVzZUV4aXN0aW5nIH0pKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzUHJlc2VudChwcm92aWRlci51c2VGYWN0b3J5KSkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBkZXBzID0gcHJvdmlkZXIuZGVwcyB8fCBwcm92aWRlci51c2VGYWN0b3J5LmRpRGVwcztcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVwc0V4cHIgPSBkZXBzLm1hcChmdW5jdGlvbiAoZGVwKSB7IHJldHVybiBfdGhpcy5fZ2V0RGVwZW5kZW5jeShyZXNvbHZlZFByb3ZpZGVyLnByb3ZpZGVyVHlwZSwgZGVwKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGltcG9ydEV4cHIocHJvdmlkZXIudXNlRmFjdG9yeSkuY2FsbEZuKGRlcHNFeHByKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzUHJlc2VudChwcm92aWRlci51c2VDbGFzcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVwcyA9IHByb3ZpZGVyLmRlcHMgfHwgcHJvdmlkZXIudXNlQ2xhc3MuZGlEZXBzO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBkZXBzRXhwciA9IGRlcHMubWFwKGZ1bmN0aW9uIChkZXApIHsgcmV0dXJuIF90aGlzLl9nZXREZXBlbmRlbmN5KHJlc29sdmVkUHJvdmlkZXIucHJvdmlkZXJUeXBlLCBkZXApOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNEaXJlY3RpdmVXcmFwcGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkaXJlY3RpdmVXcmFwcGVySWRlbnRpZmllciA9IG5ldyBDb21waWxlSWRlbnRpZmllck1ldGFkYXRhKHsgbmFtZTogRGlyZWN0aXZlV3JhcHBlckNvbXBpbGVyLmRpcldyYXBwZXJDbGFzc05hbWUocHJvdmlkZXIudXNlQ2xhc3MpIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fdGFyZ2V0RGVwZW5kZW5jaWVzLnB1c2gobmV3IERpcmVjdGl2ZVdyYXBwZXJEZXBlbmRlbmN5KHByb3ZpZGVyLnVzZUNsYXNzLCBkaXJlY3RpdmVXcmFwcGVySWRlbnRpZmllcikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW1wb3J0RXhwcihkaXJlY3RpdmVXcmFwcGVySWRlbnRpZmllcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5pbnN0YW50aWF0ZShkZXBzRXhwciwgaW1wb3J0VHlwZShkaXJlY3RpdmVXcmFwcGVySWRlbnRpZmllcikpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGltcG9ydEV4cHIocHJvdmlkZXIudXNlQ2xhc3MpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuaW5zdGFudGlhdGUoZGVwc0V4cHIsIGltcG9ydFR5cGUocHJvdmlkZXIudXNlQ2xhc3MpKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udmVydFZhbHVlVG9PdXRwdXRBc3QocHJvdmlkZXIudXNlVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgdmFyIHByb3BOYW1lID0gXCJfXCIgKyByZXNvbHZlZFByb3ZpZGVyLnRva2VuLm5hbWUgKyBcIl9cIiArIF90aGlzLm5vZGVJbmRleCArIFwiX1wiICsgX3RoaXMuaW5zdGFuY2VzLnNpemU7XG4gICAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGNyZWF0ZVByb3ZpZGVyUHJvcGVydHkocHJvcE5hbWUsIHJlc29sdmVkUHJvdmlkZXIsIHByb3ZpZGVyVmFsdWVFeHByZXNzaW9ucywgcmVzb2x2ZWRQcm92aWRlci5tdWx0aVByb3ZpZGVyLCByZXNvbHZlZFByb3ZpZGVyLmVhZ2VyLCBfdGhpcyk7XG4gICAgICAgICAgICAgIGlmIChpc0RpcmVjdGl2ZVdyYXBwZXIpIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzLmRpcmVjdGl2ZVdyYXBwZXJJbnN0YW5jZS5zZXQocmVzb2x2ZWRQcm92aWRlci50b2tlbi5yZWZlcmVuY2UsIGluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgIF90aGlzLmluc3RhbmNlcy5zZXQocmVzb2x2ZWRQcm92aWRlci50b2tlbi5yZWZlcmVuY2UsIGluc3RhbmNlLnByb3AoJ2NvbnRleHQnKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICBfdGhpcy5pbnN0YW5jZXMuc2V0KHJlc29sdmVkUHJvdmlkZXIudG9rZW4ucmVmZXJlbmNlLCBpbnN0YW5jZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2RpcmVjdGl2ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIGRpcmVjdGl2ZSA9IHRoaXMuX2RpcmVjdGl2ZXNbaV07XG4gICAgICAgICAgICAgIHZhciBkaXJlY3RpdmVJbnN0YW5jZSA9IHRoaXMuaW5zdGFuY2VzLmdldChpZGVudGlmaWVyVG9rZW4oZGlyZWN0aXZlLnR5cGUpLnJlZmVyZW5jZSk7XG4gICAgICAgICAgICAgIGRpcmVjdGl2ZS5xdWVyaWVzLmZvckVhY2goZnVuY3Rpb24gKHF1ZXJ5TWV0YSkgeyBfdGhpcy5fYWRkUXVlcnkocXVlcnlNZXRhLCBkaXJlY3RpdmVJbnN0YW5jZSk7IH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcXVlcmllc1dpdGhSZWFkcyA9IFtdO1xuICAgICAgICAgIE1hcFdyYXBwZXIudmFsdWVzKHRoaXMuX3Jlc29sdmVkUHJvdmlkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChyZXNvbHZlZFByb3ZpZGVyKSB7XG4gICAgICAgICAgICAgIHZhciBxdWVyaWVzRm9yUHJvdmlkZXIgPSBfdGhpcy5fZ2V0UXVlcmllc0ZvcihyZXNvbHZlZFByb3ZpZGVyLnRva2VuKTtcbiAgICAgICAgICAgICAgTGlzdFdyYXBwZXIuYWRkQWxsKHF1ZXJpZXNXaXRoUmVhZHMsIHF1ZXJpZXNGb3JQcm92aWRlci5tYXAoZnVuY3Rpb24gKHF1ZXJ5KSB7IHJldHVybiBuZXcgX1F1ZXJ5V2l0aFJlYWQocXVlcnksIHJlc29sdmVkUHJvdmlkZXIudG9rZW4pOyB9KSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgT2JqZWN0LmtleXModGhpcy5yZWZlcmVuY2VUb2tlbnMpLmZvckVhY2goZnVuY3Rpb24gKHZhck5hbWUpIHtcbiAgICAgICAgICAgICAgdmFyIHRva2VuID0gX3RoaXMucmVmZXJlbmNlVG9rZW5zW3Zhck5hbWVdO1xuICAgICAgICAgICAgICB2YXIgdmFyVmFsdWU7XG4gICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQodG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgICB2YXJWYWx1ZSA9IF90aGlzLmluc3RhbmNlcy5nZXQodG9rZW4ucmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHZhclZhbHVlID0gX3RoaXMucmVuZGVyTm9kZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBfdGhpcy52aWV3LmxvY2Fscy5zZXQodmFyTmFtZSwgdmFyVmFsdWUpO1xuICAgICAgICAgICAgICB2YXIgdmFyVG9rZW4gPSBuZXcgQ29tcGlsZVRva2VuTWV0YWRhdGEoeyB2YWx1ZTogdmFyTmFtZSB9KTtcbiAgICAgICAgICAgICAgTGlzdFdyYXBwZXIuYWRkQWxsKHF1ZXJpZXNXaXRoUmVhZHMsIF90aGlzLl9nZXRRdWVyaWVzRm9yKHZhclRva2VuKS5tYXAoZnVuY3Rpb24gKHF1ZXJ5KSB7IHJldHVybiBuZXcgX1F1ZXJ5V2l0aFJlYWQocXVlcnksIHZhclRva2VuKTsgfSkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHF1ZXJpZXNXaXRoUmVhZHMuZm9yRWFjaChmdW5jdGlvbiAocXVlcnlXaXRoUmVhZCkge1xuICAgICAgICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQocXVlcnlXaXRoUmVhZC5yZWFkLmlkZW50aWZpZXIpKSB7XG4gICAgICAgICAgICAgICAgICAvLyBxdWVyeSBmb3IgYW4gaWRlbnRpZmllclxuICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfdGhpcy5pbnN0YW5jZXMuZ2V0KHF1ZXJ5V2l0aFJlYWQucmVhZC5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLy8gcXVlcnkgZm9yIGEgcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgICB2YXIgdG9rZW4gPSBfdGhpcy5yZWZlcmVuY2VUb2tlbnNbcXVlcnlXaXRoUmVhZC5yZWFkLnZhbHVlXTtcbiAgICAgICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQodG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfdGhpcy5pbnN0YW5jZXMuZ2V0KHRva2VuLnJlZmVyZW5jZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF90aGlzLmVsZW1lbnRSZWY7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgIHF1ZXJ5V2l0aFJlYWQucXVlcnkuYWRkVmFsdWUodmFsdWUsIF90aGlzLnZpZXcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmNvbXBvbmVudCkpIHtcbiAgICAgICAgICAgICAgdmFyIGNvbXBvbmVudENvbnN0cnVjdG9yVmlld1F1ZXJ5TGlzdCA9IGlzUHJlc2VudCh0aGlzLmNvbXBvbmVudCkgP1xuICAgICAgICAgICAgICAgICAgbGl0ZXJhbEFycih0aGlzLl9jb21wb25lbnRDb25zdHJ1Y3RvclZpZXdRdWVyeUxpc3RzKSA6XG4gICAgICAgICAgICAgICAgICBOVUxMX0VYUFI7XG4gICAgICAgICAgICAgIHZhciBjb21wRXhwciA9IGlzUHJlc2VudCh0aGlzLmdldENvbXBvbmVudCgpKSA/IHRoaXMuZ2V0Q29tcG9uZW50KCkgOiBOVUxMX0VYUFI7XG4gICAgICAgICAgICAgIHRoaXMudmlldy5jcmVhdGVNZXRob2QuYWRkU3RtdCh0aGlzLmFwcEVsZW1lbnRcbiAgICAgICAgICAgICAgICAgIC5jYWxsTWV0aG9kKCdpbml0Q29tcG9uZW50JywgW2NvbXBFeHByLCBjb21wb25lbnRDb25zdHJ1Y3RvclZpZXdRdWVyeUxpc3QsIHRoaXMuX2NvbXBWaWV3RXhwcl0pXG4gICAgICAgICAgICAgICAgICAudG9TdG10KCkpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBDb21waWxlRWxlbWVudC5wcm90b3R5cGUuYWZ0ZXJDaGlsZHJlbiA9IGZ1bmN0aW9uIChjaGlsZE5vZGVDb3VudCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgTWFwV3JhcHBlci52YWx1ZXModGhpcy5fcmVzb2x2ZWRQcm92aWRlcnMpLmZvckVhY2goZnVuY3Rpb24gKHJlc29sdmVkUHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgLy8gTm90ZTogYWZ0ZXJDaGlsZHJlbiBpcyBjYWxsZWQgYWZ0ZXIgcmVjdXJzaW5nIGludG8gY2hpbGRyZW4uXG4gICAgICAgICAgICAgIC8vIFRoaXMgaXMgZ29vZCBzbyB0aGF0IGFuIGluamVjdG9yIG1hdGNoIGluIGFuIGVsZW1lbnQgdGhhdCBpcyBjbG9zZXIgdG8gYSByZXF1ZXN0aW5nIGVsZW1lbnRcbiAgICAgICAgICAgICAgLy8gbWF0Y2hlcyBmaXJzdC5cbiAgICAgICAgICAgICAgdmFyIHByb3ZpZGVyRXhwciA9IF90aGlzLmluc3RhbmNlcy5nZXQocmVzb2x2ZWRQcm92aWRlci50b2tlbi5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgICAvLyBOb3RlOiB2aWV3IHByb3ZpZGVycyBhcmUgb25seSB2aXNpYmxlIG9uIHRoZSBpbmplY3RvciBvZiB0aGF0IGVsZW1lbnQuXG4gICAgICAgICAgICAgIC8vIFRoaXMgaXMgbm90IGZ1bGx5IGNvcnJlY3QgYXMgdGhlIHJ1bGVzIGR1cmluZyBjb2RlZ2VuIGRvbid0IGFsbG93IGEgZGlyZWN0aXZlXG4gICAgICAgICAgICAgIC8vIHRvIGdldCBob2xkIG9mIGEgdmlldyBwcm92ZGllciBvbiB0aGUgc2FtZSBlbGVtZW50LiBXZSBzdGlsbCBkbyB0aGlzIHNlbWFudGljXG4gICAgICAgICAgICAgIC8vIGFzIGl0IHNpbXBsaWZpZXMgb3VyIG1vZGVsIHRvIGhhdmluZyBvbmx5IG9uZSBydW50aW1lIGluamVjdG9yIHBlciBlbGVtZW50LlxuICAgICAgICAgICAgICB2YXIgcHJvdmlkZXJDaGlsZE5vZGVDb3VudCA9IHJlc29sdmVkUHJvdmlkZXIucHJvdmlkZXJUeXBlID09PSBleHBvcnRzLlByb3ZpZGVyQXN0VHlwZS5Qcml2YXRlU2VydmljZSA/IDAgOiBjaGlsZE5vZGVDb3VudDtcbiAgICAgICAgICAgICAgX3RoaXMudmlldy5pbmplY3RvckdldE1ldGhvZC5hZGRTdG10KGNyZWF0ZUluamVjdEludGVybmFsQ29uZGl0aW9uKF90aGlzLm5vZGVJbmRleCwgcHJvdmlkZXJDaGlsZE5vZGVDb3VudCwgcmVzb2x2ZWRQcm92aWRlciwgcHJvdmlkZXJFeHByKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgTWFwV3JhcHBlci52YWx1ZXModGhpcy5fcXVlcmllcylcbiAgICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKHF1ZXJpZXMpIHsgcmV0dXJuIHF1ZXJpZXMuZm9yRWFjaChmdW5jdGlvbiAocXVlcnkpIHsgcmV0dXJuIHF1ZXJ5LmFmdGVyQ2hpbGRyZW4oX3RoaXMudmlldy5jcmVhdGVNZXRob2QsIF90aGlzLnZpZXcudXBkYXRlQ29udGVudFF1ZXJpZXNNZXRob2QpOyB9KTsgfSk7XG4gICAgICB9O1xuICAgICAgQ29tcGlsZUVsZW1lbnQucHJvdG90eXBlLmFkZENvbnRlbnROb2RlID0gZnVuY3Rpb24gKG5nQ29udGVudEluZGV4LCBub2RlRXhwcikge1xuICAgICAgICAgIHRoaXMuY29udGVudE5vZGVzQnlOZ0NvbnRlbnRJbmRleFtuZ0NvbnRlbnRJbmRleF0ucHVzaChub2RlRXhwcik7XG4gICAgICB9O1xuICAgICAgQ29tcGlsZUVsZW1lbnQucHJvdG90eXBlLmdldENvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMuY29tcG9uZW50KSA/XG4gICAgICAgICAgICAgIHRoaXMuaW5zdGFuY2VzLmdldChpZGVudGlmaWVyVG9rZW4odGhpcy5jb21wb25lbnQudHlwZSkucmVmZXJlbmNlKSA6XG4gICAgICAgICAgICAgIG51bGw7XG4gICAgICB9O1xuICAgICAgQ29tcGlsZUVsZW1lbnQucHJvdG90eXBlLmdldFByb3ZpZGVyVG9rZW5zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBNYXBXcmFwcGVyLnZhbHVlcyh0aGlzLl9yZXNvbHZlZFByb3ZpZGVycylcbiAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAocmVzb2x2ZWRQcm92aWRlcikgeyByZXR1cm4gY3JlYXRlRGlUb2tlbkV4cHJlc3Npb24ocmVzb2x2ZWRQcm92aWRlci50b2tlbik7IH0pO1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVFbGVtZW50LnByb3RvdHlwZS5fZ2V0UXVlcmllc0ZvciA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICB2YXIgY3VycmVudEVsID0gdGhpcztcbiAgICAgICAgICB2YXIgZGlzdGFuY2UgPSAwO1xuICAgICAgICAgIHZhciBxdWVyaWVzO1xuICAgICAgICAgIHdoaWxlICghY3VycmVudEVsLmlzTnVsbCgpKSB7XG4gICAgICAgICAgICAgIHF1ZXJpZXMgPSBjdXJyZW50RWwuX3F1ZXJpZXMuZ2V0KHRva2VuLnJlZmVyZW5jZSk7XG4gICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQocXVlcmllcykpIHtcbiAgICAgICAgICAgICAgICAgIExpc3RXcmFwcGVyLmFkZEFsbChyZXN1bHQsIHF1ZXJpZXMuZmlsdGVyKGZ1bmN0aW9uIChxdWVyeSkgeyByZXR1cm4gcXVlcnkubWV0YS5kZXNjZW5kYW50cyB8fCBkaXN0YW5jZSA8PSAxOyB9KSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGN1cnJlbnRFbC5fZGlyZWN0aXZlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICBkaXN0YW5jZSsrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGN1cnJlbnRFbCA9IGN1cnJlbnRFbC5wYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHF1ZXJpZXMgPSB0aGlzLnZpZXcuY29tcG9uZW50Vmlldy52aWV3UXVlcmllcy5nZXQodG9rZW4ucmVmZXJlbmNlKTtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KHF1ZXJpZXMpKSB7XG4gICAgICAgICAgICAgIExpc3RXcmFwcGVyLmFkZEFsbChyZXN1bHQsIHF1ZXJpZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVFbGVtZW50LnByb3RvdHlwZS5fYWRkUXVlcnkgPSBmdW5jdGlvbiAocXVlcnlNZXRhLCBkaXJlY3RpdmVJbnN0YW5jZSkge1xuICAgICAgICAgIHZhciBwcm9wTmFtZSA9IFwiX3F1ZXJ5X1wiICsgcXVlcnlNZXRhLnNlbGVjdG9yc1swXS5uYW1lICsgXCJfXCIgKyB0aGlzLm5vZGVJbmRleCArIFwiX1wiICsgdGhpcy5fcXVlcnlDb3VudCsrO1xuICAgICAgICAgIHZhciBxdWVyeUxpc3QgPSBjcmVhdGVRdWVyeUxpc3QocXVlcnlNZXRhLCBkaXJlY3RpdmVJbnN0YW5jZSwgcHJvcE5hbWUsIHRoaXMudmlldyk7XG4gICAgICAgICAgdmFyIHF1ZXJ5ID0gbmV3IENvbXBpbGVRdWVyeShxdWVyeU1ldGEsIHF1ZXJ5TGlzdCwgZGlyZWN0aXZlSW5zdGFuY2UsIHRoaXMudmlldyk7XG4gICAgICAgICAgYWRkUXVlcnlUb1Rva2VuTWFwKHRoaXMuX3F1ZXJpZXMsIHF1ZXJ5KTtcbiAgICAgICAgICByZXR1cm4gcXVlcnk7XG4gICAgICB9O1xuICAgICAgQ29tcGlsZUVsZW1lbnQucHJvdG90eXBlLl9nZXRMb2NhbERlcGVuZGVuY3kgPSBmdW5jdGlvbiAocmVxdWVzdGluZ1Byb3ZpZGVyVHlwZSwgZGVwKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgLy8gY29uc3RydWN0b3IgY29udGVudCBxdWVyeVxuICAgICAgICAgIGlmICghcmVzdWx0ICYmIGlzUHJlc2VudChkZXAucXVlcnkpKSB7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuX2FkZFF1ZXJ5KGRlcC5xdWVyeSwgbnVsbCkucXVlcnlMaXN0O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBjb25zdHJ1Y3RvciB2aWV3IHF1ZXJ5XG4gICAgICAgICAgaWYgKCFyZXN1bHQgJiYgaXNQcmVzZW50KGRlcC52aWV3UXVlcnkpKSB7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IGNyZWF0ZVF1ZXJ5TGlzdChkZXAudmlld1F1ZXJ5LCBudWxsLCBcIl92aWV3UXVlcnlfXCIgKyBkZXAudmlld1F1ZXJ5LnNlbGVjdG9yc1swXS5uYW1lICsgXCJfXCIgKyB0aGlzLm5vZGVJbmRleCArIFwiX1wiICsgdGhpcy5fY29tcG9uZW50Q29uc3RydWN0b3JWaWV3UXVlcnlMaXN0cy5sZW5ndGgsIHRoaXMudmlldyk7XG4gICAgICAgICAgICAgIHRoaXMuX2NvbXBvbmVudENvbnN0cnVjdG9yVmlld1F1ZXJ5TGlzdHMucHVzaChyZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNQcmVzZW50KGRlcC50b2tlbikpIHtcbiAgICAgICAgICAgICAgLy8gYWNjZXNzIGJ1aWx0aW5zIHdpdGggc3BlY2lhbCB2aXNpYmlsaXR5XG4gICAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZGVwLnRva2VuLnJlZmVyZW5jZSA9PT1cbiAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlSWRlbnRpZmllclRva2VuKElkZW50aWZpZXJzLkNoYW5nZURldGVjdG9yUmVmKS5yZWZlcmVuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAocmVxdWVzdGluZ1Byb3ZpZGVyVHlwZSA9PT0gZXhwb3J0cy5Qcm92aWRlckFzdFR5cGUuQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb21wVmlld0V4cHIucHJvcCgncmVmJyk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0UHJvcGVydHlJblZpZXcoVEhJU19FWFBSLnByb3AoJ3JlZicpLCB0aGlzLnZpZXcsIHRoaXMudmlldy5jb21wb25lbnRWaWV3KTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gYWNjZXNzIHJlZ3VsYXIgcHJvdmlkZXJzIG9uIHRoZSBlbGVtZW50XG4gICAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcmVzb2x2ZWRQcm92aWRlciA9IHRoaXMuX3Jlc29sdmVkUHJvdmlkZXJzLmdldChkZXAudG9rZW4ucmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgICAgIC8vIGRvbid0IGFsbG93IGRpcmVjdGl2ZXMgLyBwdWJsaWMgc2VydmljZXMgdG8gYWNjZXNzIHByaXZhdGUgc2VydmljZXMuXG4gICAgICAgICAgICAgICAgICAvLyBvbmx5IGNvbXBvbmVudHMgYW5kIHByaXZhdGUgc2VydmljZXMgY2FuIGFjY2VzcyBwcml2YXRlIHNlcnZpY2VzLlxuICAgICAgICAgICAgICAgICAgaWYgKHJlc29sdmVkUHJvdmlkZXIgJiYgKHJlcXVlc3RpbmdQcm92aWRlclR5cGUgPT09IGV4cG9ydHMuUHJvdmlkZXJBc3RUeXBlLkRpcmVjdGl2ZSB8fFxuICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RpbmdQcm92aWRlclR5cGUgPT09IGV4cG9ydHMuUHJvdmlkZXJBc3RUeXBlLlB1YmxpY1NlcnZpY2UpICYmXG4gICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRQcm92aWRlci5wcm92aWRlclR5cGUgPT09IGV4cG9ydHMuUHJvdmlkZXJBc3RUeXBlLlByaXZhdGVTZXJ2aWNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLmluc3RhbmNlcy5nZXQoZGVwLnRva2VuLnJlZmVyZW5jZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgICBDb21waWxlRWxlbWVudC5wcm90b3R5cGUuX2dldERlcGVuZGVuY3kgPSBmdW5jdGlvbiAocmVxdWVzdGluZ1Byb3ZpZGVyVHlwZSwgZGVwKSB7XG4gICAgICAgICAgdmFyIGN1cnJFbGVtZW50ID0gdGhpcztcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICBpZiAoZGVwLmlzVmFsdWUpIHtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gbGl0ZXJhbChkZXAudmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXJlc3VsdCAmJiAhZGVwLmlzU2tpcFNlbGYpIHtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5fZ2V0TG9jYWxEZXBlbmRlbmN5KHJlcXVlc3RpbmdQcm92aWRlclR5cGUsIGRlcCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGNoZWNrIHBhcmVudCBlbGVtZW50c1xuICAgICAgICAgIHdoaWxlICghcmVzdWx0ICYmICFjdXJyRWxlbWVudC5wYXJlbnQuaXNOdWxsKCkpIHtcbiAgICAgICAgICAgICAgY3VyckVsZW1lbnQgPSBjdXJyRWxlbWVudC5wYXJlbnQ7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IGN1cnJFbGVtZW50Ll9nZXRMb2NhbERlcGVuZGVuY3koZXhwb3J0cy5Qcm92aWRlckFzdFR5cGUuUHVibGljU2VydmljZSwgbmV3IENvbXBpbGVEaURlcGVuZGVuY3lNZXRhZGF0YSh7IHRva2VuOiBkZXAudG9rZW4gfSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICByZXN1bHQgPSBpbmplY3RGcm9tVmlld1BhcmVudEluamVjdG9yKGRlcC50b2tlbiwgZGVwLmlzT3B0aW9uYWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICByZXN1bHQgPSBOVUxMX0VYUFI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBnZXRQcm9wZXJ0eUluVmlldyhyZXN1bHQsIHRoaXMudmlldywgY3VyckVsZW1lbnQudmlldyk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIENvbXBpbGVFbGVtZW50O1xuICB9KENvbXBpbGVOb2RlKSk7XG4gIGZ1bmN0aW9uIGNyZWF0ZUluamVjdEludGVybmFsQ29uZGl0aW9uKG5vZGVJbmRleCwgY2hpbGROb2RlQ291bnQsIHByb3ZpZGVyLCBwcm92aWRlckV4cHIpIHtcbiAgICAgIHZhciBpbmRleENvbmRpdGlvbjtcbiAgICAgIGlmIChjaGlsZE5vZGVDb3VudCA+IDApIHtcbiAgICAgICAgICBpbmRleENvbmRpdGlvbiA9IGxpdGVyYWwobm9kZUluZGV4KVxuICAgICAgICAgICAgICAubG93ZXJFcXVhbHMoSW5qZWN0TWV0aG9kVmFycy5yZXF1ZXN0Tm9kZUluZGV4KVxuICAgICAgICAgICAgICAuYW5kKEluamVjdE1ldGhvZFZhcnMucmVxdWVzdE5vZGVJbmRleC5sb3dlckVxdWFscyhsaXRlcmFsKG5vZGVJbmRleCArIGNoaWxkTm9kZUNvdW50KSkpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICAgaW5kZXhDb25kaXRpb24gPSBsaXRlcmFsKG5vZGVJbmRleCkuaWRlbnRpY2FsKEluamVjdE1ldGhvZFZhcnMucmVxdWVzdE5vZGVJbmRleCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IElmU3RtdChJbmplY3RNZXRob2RWYXJzLnRva2VuLmlkZW50aWNhbChjcmVhdGVEaVRva2VuRXhwcmVzc2lvbihwcm92aWRlci50b2tlbikpLmFuZChpbmRleENvbmRpdGlvbiksIFtuZXcgUmV0dXJuU3RhdGVtZW50KHByb3ZpZGVyRXhwcildKTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVQcm92aWRlclByb3BlcnR5KHByb3BOYW1lLCBwcm92aWRlciwgcHJvdmlkZXJWYWx1ZUV4cHJlc3Npb25zLCBpc011bHRpLCBpc0VhZ2VyLCBjb21waWxlRWxlbWVudCkge1xuICAgICAgdmFyIHZpZXcgPSBjb21waWxlRWxlbWVudC52aWV3O1xuICAgICAgdmFyIHJlc29sdmVkUHJvdmlkZXJWYWx1ZUV4cHI7XG4gICAgICB2YXIgdHlwZTtcbiAgICAgIGlmIChpc011bHRpKSB7XG4gICAgICAgICAgcmVzb2x2ZWRQcm92aWRlclZhbHVlRXhwciA9IGxpdGVyYWxBcnIocHJvdmlkZXJWYWx1ZUV4cHJlc3Npb25zKTtcbiAgICAgICAgICB0eXBlID0gbmV3IEFycmF5VHlwZShEWU5BTUlDX1RZUEUpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZWRQcm92aWRlclZhbHVlRXhwciA9IHByb3ZpZGVyVmFsdWVFeHByZXNzaW9uc1swXTtcbiAgICAgICAgICB0eXBlID0gcHJvdmlkZXJWYWx1ZUV4cHJlc3Npb25zWzBdLnR5cGU7XG4gICAgICB9XG4gICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICB0eXBlID0gRFlOQU1JQ19UWVBFO1xuICAgICAgfVxuICAgICAgaWYgKGlzRWFnZXIpIHtcbiAgICAgICAgICB2aWV3LmZpZWxkcy5wdXNoKG5ldyBDbGFzc0ZpZWxkKHByb3BOYW1lLCB0eXBlKSk7XG4gICAgICAgICAgdmlldy5jcmVhdGVNZXRob2QuYWRkU3RtdChUSElTX0VYUFIucHJvcChwcm9wTmFtZSkuc2V0KHJlc29sdmVkUHJvdmlkZXJWYWx1ZUV4cHIpLnRvU3RtdCgpKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBpbnRlcm5hbEZpZWxkID0gXCJfXCIgKyBwcm9wTmFtZTtcbiAgICAgICAgICB2aWV3LmZpZWxkcy5wdXNoKG5ldyBDbGFzc0ZpZWxkKGludGVybmFsRmllbGQsIHR5cGUpKTtcbiAgICAgICAgICB2YXIgZ2V0dGVyID0gbmV3IENvbXBpbGVNZXRob2Qodmlldyk7XG4gICAgICAgICAgZ2V0dGVyLnJlc2V0RGVidWdJbmZvKGNvbXBpbGVFbGVtZW50Lm5vZGVJbmRleCwgY29tcGlsZUVsZW1lbnQuc291cmNlQXN0KTtcbiAgICAgICAgICAvLyBOb3RlOiBFcXVhbHMgaXMgaW1wb3J0YW50IGZvciBKUyBzbyB0aGF0IGl0IGFsc28gY2hlY2tzIHRoZSB1bmRlZmluZWQgY2FzZSFcbiAgICAgICAgICBnZXR0ZXIuYWRkU3RtdChuZXcgSWZTdG10KFRISVNfRVhQUi5wcm9wKGludGVybmFsRmllbGQpLmlzQmxhbmsoKSwgW1RISVNfRVhQUi5wcm9wKGludGVybmFsRmllbGQpLnNldChyZXNvbHZlZFByb3ZpZGVyVmFsdWVFeHByKS50b1N0bXQoKV0pKTtcbiAgICAgICAgICBnZXR0ZXIuYWRkU3RtdChuZXcgUmV0dXJuU3RhdGVtZW50KFRISVNfRVhQUi5wcm9wKGludGVybmFsRmllbGQpKSk7XG4gICAgICAgICAgdmlldy5nZXR0ZXJzLnB1c2gobmV3IENsYXNzR2V0dGVyKHByb3BOYW1lLCBnZXR0ZXIuZmluaXNoKCksIHR5cGUpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBUSElTX0VYUFIucHJvcChwcm9wTmFtZSk7XG4gIH1cbiAgdmFyIF9RdWVyeVdpdGhSZWFkID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIF9RdWVyeVdpdGhSZWFkKHF1ZXJ5LCBtYXRjaCkge1xuICAgICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeTtcbiAgICAgICAgICB0aGlzLnJlYWQgPSBxdWVyeS5tZXRhLnJlYWQgfHwgbWF0Y2g7XG4gICAgICB9XG4gICAgICByZXR1cm4gX1F1ZXJ5V2l0aFJlYWQ7XG4gIH0oKSk7XG5cbiAgdmFyIENvbXBpbGVQaXBlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIENvbXBpbGVQaXBlKHZpZXcsIG1ldGEpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgICAgdGhpcy5tZXRhID0gbWV0YTtcbiAgICAgICAgICB0aGlzLl9wdXJlUGlwZVByb3h5Q291bnQgPSAwO1xuICAgICAgICAgIHRoaXMuaW5zdGFuY2UgPSBUSElTX0VYUFIucHJvcChcIl9waXBlX1wiICsgbWV0YS5uYW1lICsgXCJfXCIgKyB2aWV3LnBpcGVDb3VudCsrKTtcbiAgICAgICAgICB2YXIgZGVwcyA9IHRoaXMubWV0YS50eXBlLmRpRGVwcy5tYXAoZnVuY3Rpb24gKGRpRGVwKSB7XG4gICAgICAgICAgICAgIGlmIChkaURlcC50b2tlbi5yZWZlcmVuY2UgPT09XG4gICAgICAgICAgICAgICAgICByZXNvbHZlSWRlbnRpZmllclRva2VuKElkZW50aWZpZXJzLkNoYW5nZURldGVjdG9yUmVmKS5yZWZlcmVuY2UpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRQcm9wZXJ0eUluVmlldyhUSElTX0VYUFIucHJvcCgncmVmJyksIF90aGlzLnZpZXcsIF90aGlzLnZpZXcuY29tcG9uZW50Vmlldyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGluamVjdEZyb21WaWV3UGFyZW50SW5qZWN0b3IoZGlEZXAudG9rZW4sIGZhbHNlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLnZpZXcuZmllbGRzLnB1c2gobmV3IENsYXNzRmllbGQodGhpcy5pbnN0YW5jZS5uYW1lLCBpbXBvcnRUeXBlKHRoaXMubWV0YS50eXBlKSkpO1xuICAgICAgICAgIHRoaXMudmlldy5jcmVhdGVNZXRob2QucmVzZXREZWJ1Z0luZm8obnVsbCwgbnVsbCk7XG4gICAgICAgICAgdGhpcy52aWV3LmNyZWF0ZU1ldGhvZC5hZGRTdG10KFRISVNfRVhQUi5wcm9wKHRoaXMuaW5zdGFuY2UubmFtZSlcbiAgICAgICAgICAgICAgLnNldChpbXBvcnRFeHByKHRoaXMubWV0YS50eXBlKS5pbnN0YW50aWF0ZShkZXBzKSlcbiAgICAgICAgICAgICAgLnRvU3RtdCgpKTtcbiAgICAgIH1cbiAgICAgIENvbXBpbGVQaXBlLmNhbGwgPSBmdW5jdGlvbiAodmlldywgbmFtZSwgYXJncykge1xuICAgICAgICAgIHZhciBjb21wVmlldyA9IHZpZXcuY29tcG9uZW50VmlldztcbiAgICAgICAgICB2YXIgbWV0YSA9IF9maW5kUGlwZU1ldGEoY29tcFZpZXcsIG5hbWUpO1xuICAgICAgICAgIHZhciBwaXBlO1xuICAgICAgICAgIGlmIChtZXRhLnB1cmUpIHtcbiAgICAgICAgICAgICAgLy8gcHVyZSBwaXBlcyBsaXZlIG9uIHRoZSBjb21wb25lbnQgdmlld1xuICAgICAgICAgICAgICBwaXBlID0gY29tcFZpZXcucHVyZVBpcGVzLmdldChuYW1lKTtcbiAgICAgICAgICAgICAgaWYgKCFwaXBlKSB7XG4gICAgICAgICAgICAgICAgICBwaXBlID0gbmV3IENvbXBpbGVQaXBlKGNvbXBWaWV3LCBtZXRhKTtcbiAgICAgICAgICAgICAgICAgIGNvbXBWaWV3LnB1cmVQaXBlcy5zZXQobmFtZSwgcGlwZSk7XG4gICAgICAgICAgICAgICAgICBjb21wVmlldy5waXBlcy5wdXNoKHBpcGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAvLyBOb24gcHVyZSBwaXBlcyBsaXZlIG9uIHRoZSB2aWV3IHRoYXQgY2FsbGVkIGl0XG4gICAgICAgICAgICAgIHBpcGUgPSBuZXcgQ29tcGlsZVBpcGUodmlldywgbWV0YSk7XG4gICAgICAgICAgICAgIHZpZXcucGlwZXMucHVzaChwaXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHBpcGUuX2NhbGwodmlldywgYXJncyk7XG4gICAgICB9O1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBpbGVQaXBlLnByb3RvdHlwZSwgXCJwdXJlXCIsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubWV0YS5wdXJlOyB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIENvbXBpbGVQaXBlLnByb3RvdHlwZS5fY2FsbCA9IGZ1bmN0aW9uIChjYWxsaW5nVmlldywgYXJncykge1xuICAgICAgICAgIGlmICh0aGlzLm1ldGEucHVyZSkge1xuICAgICAgICAgICAgICAvLyBQdXJlUGlwZVByb3hpZXMgbGl2ZSBvbiB0aGUgdmlldyB0aGF0IGNhbGxlZCB0aGVtLlxuICAgICAgICAgICAgICB2YXIgcHVyZVBpcGVQcm94eUluc3RhbmNlID0gVEhJU19FWFBSLnByb3AodGhpcy5pbnN0YW5jZS5uYW1lICsgXCJfXCIgKyB0aGlzLl9wdXJlUGlwZVByb3h5Q291bnQrKyk7XG4gICAgICAgICAgICAgIHZhciBwaXBlSW5zdGFuY2VTZWVuRnJvbVB1cmVQcm94eSA9IGdldFByb3BlcnR5SW5WaWV3KHRoaXMuaW5zdGFuY2UsIGNhbGxpbmdWaWV3LCB0aGlzLnZpZXcpO1xuICAgICAgICAgICAgICBjcmVhdGVQdXJlUHJveHkocGlwZUluc3RhbmNlU2VlbkZyb21QdXJlUHJveHkucHJvcCgndHJhbnNmb3JtJylcbiAgICAgICAgICAgICAgICAgIC5jYWxsTWV0aG9kKEJ1aWx0aW5NZXRob2QuQmluZCwgW3BpcGVJbnN0YW5jZVNlZW5Gcm9tUHVyZVByb3h5XSksIGFyZ3MubGVuZ3RoLCBwdXJlUGlwZVByb3h5SW5zdGFuY2UsIGNhbGxpbmdWaWV3KTtcbiAgICAgICAgICAgICAgcmV0dXJuIGltcG9ydEV4cHIocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuY2FzdEJ5VmFsdWUpKVxuICAgICAgICAgICAgICAgICAgLmNhbGxGbihbcHVyZVBpcGVQcm94eUluc3RhbmNlLCBwaXBlSW5zdGFuY2VTZWVuRnJvbVB1cmVQcm94eS5wcm9wKCd0cmFuc2Zvcm0nKV0pXG4gICAgICAgICAgICAgICAgICAuY2FsbEZuKGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldFByb3BlcnR5SW5WaWV3KHRoaXMuaW5zdGFuY2UsIGNhbGxpbmdWaWV3LCB0aGlzLnZpZXcpLmNhbGxNZXRob2QoJ3RyYW5zZm9ybScsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gQ29tcGlsZVBpcGU7XG4gIH0oKSk7XG4gIGZ1bmN0aW9uIF9maW5kUGlwZU1ldGEodmlldywgbmFtZSkge1xuICAgICAgdmFyIHBpcGVNZXRhID0gbnVsbDtcbiAgICAgIGZvciAodmFyIGkgPSB2aWV3LnBpcGVNZXRhcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHZhciBsb2NhbFBpcGVNZXRhID0gdmlldy5waXBlTWV0YXNbaV07XG4gICAgICAgICAgaWYgKGxvY2FsUGlwZU1ldGEubmFtZSA9PSBuYW1lKSB7XG4gICAgICAgICAgICAgIHBpcGVNZXRhID0gbG9jYWxQaXBlTWV0YTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFwaXBlTWV0YSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklsbGVnYWwgc3RhdGU6IENvdWxkIG5vdCBmaW5kIHBpcGUgXCIgKyBuYW1lICsgXCIgYWx0aG91Z2ggdGhlIHBhcnNlciBzaG91bGQgaGF2ZSBkZXRlY3RlZCB0aGlzIGVycm9yIVwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwaXBlTWV0YTtcbiAgfVxuXG4gIHZhciBDb21waWxlVmlldyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBDb21waWxlVmlldyhjb21wb25lbnQsIGdlbkNvbmZpZywgcGlwZU1ldGFzLCBzdHlsZXMsIGFuaW1hdGlvbnMsIHZpZXdJbmRleCwgZGVjbGFyYXRpb25FbGVtZW50LCB0ZW1wbGF0ZVZhcmlhYmxlQmluZGluZ3MpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgICAgICAgIHRoaXMuZ2VuQ29uZmlnID0gZ2VuQ29uZmlnO1xuICAgICAgICAgIHRoaXMucGlwZU1ldGFzID0gcGlwZU1ldGFzO1xuICAgICAgICAgIHRoaXMuc3R5bGVzID0gc3R5bGVzO1xuICAgICAgICAgIHRoaXMuYW5pbWF0aW9ucyA9IGFuaW1hdGlvbnM7XG4gICAgICAgICAgdGhpcy52aWV3SW5kZXggPSB2aWV3SW5kZXg7XG4gICAgICAgICAgdGhpcy5kZWNsYXJhdGlvbkVsZW1lbnQgPSBkZWNsYXJhdGlvbkVsZW1lbnQ7XG4gICAgICAgICAgdGhpcy50ZW1wbGF0ZVZhcmlhYmxlQmluZGluZ3MgPSB0ZW1wbGF0ZVZhcmlhYmxlQmluZGluZ3M7XG4gICAgICAgICAgdGhpcy5ub2RlcyA9IFtdO1xuICAgICAgICAgIC8vIHJvb3Qgbm9kZXMgb3IgQXBwRWxlbWVudHMgZm9yIFZpZXdDb250YWluZXJzXG4gICAgICAgICAgdGhpcy5yb290Tm9kZXNPckFwcEVsZW1lbnRzID0gW107XG4gICAgICAgICAgdGhpcy5iaW5kaW5ncyA9IFtdO1xuICAgICAgICAgIHRoaXMuY2xhc3NTdGF0ZW1lbnRzID0gW107XG4gICAgICAgICAgdGhpcy5ldmVudEhhbmRsZXJNZXRob2RzID0gW107XG4gICAgICAgICAgdGhpcy5maWVsZHMgPSBbXTtcbiAgICAgICAgICB0aGlzLmdldHRlcnMgPSBbXTtcbiAgICAgICAgICB0aGlzLmRpc3Bvc2FibGVzID0gW107XG4gICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gW107XG4gICAgICAgICAgdGhpcy5wdXJlUGlwZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgdGhpcy5waXBlcyA9IFtdO1xuICAgICAgICAgIHRoaXMubG9jYWxzID0gbmV3IE1hcCgpO1xuICAgICAgICAgIHRoaXMubGl0ZXJhbEFycmF5Q291bnQgPSAwO1xuICAgICAgICAgIHRoaXMubGl0ZXJhbE1hcENvdW50ID0gMDtcbiAgICAgICAgICB0aGlzLnBpcGVDb3VudCA9IDA7XG4gICAgICAgICAgdGhpcy5jcmVhdGVNZXRob2QgPSBuZXcgQ29tcGlsZU1ldGhvZCh0aGlzKTtcbiAgICAgICAgICB0aGlzLmFuaW1hdGlvbkJpbmRpbmdzTWV0aG9kID0gbmV3IENvbXBpbGVNZXRob2QodGhpcyk7XG4gICAgICAgICAgdGhpcy5pbmplY3RvckdldE1ldGhvZCA9IG5ldyBDb21waWxlTWV0aG9kKHRoaXMpO1xuICAgICAgICAgIHRoaXMudXBkYXRlQ29udGVudFF1ZXJpZXNNZXRob2QgPSBuZXcgQ29tcGlsZU1ldGhvZCh0aGlzKTtcbiAgICAgICAgICB0aGlzLmRpcnR5UGFyZW50UXVlcmllc01ldGhvZCA9IG5ldyBDb21waWxlTWV0aG9kKHRoaXMpO1xuICAgICAgICAgIHRoaXMudXBkYXRlVmlld1F1ZXJpZXNNZXRob2QgPSBuZXcgQ29tcGlsZU1ldGhvZCh0aGlzKTtcbiAgICAgICAgICB0aGlzLmRldGVjdENoYW5nZXNJbklucHV0c01ldGhvZCA9IG5ldyBDb21waWxlTWV0aG9kKHRoaXMpO1xuICAgICAgICAgIHRoaXMuZGV0ZWN0Q2hhbmdlc1JlbmRlclByb3BlcnRpZXNNZXRob2QgPSBuZXcgQ29tcGlsZU1ldGhvZCh0aGlzKTtcbiAgICAgICAgICB0aGlzLmFmdGVyQ29udGVudExpZmVjeWNsZUNhbGxiYWNrc01ldGhvZCA9IG5ldyBDb21waWxlTWV0aG9kKHRoaXMpO1xuICAgICAgICAgIHRoaXMuYWZ0ZXJWaWV3TGlmZWN5Y2xlQ2FsbGJhY2tzTWV0aG9kID0gbmV3IENvbXBpbGVNZXRob2QodGhpcyk7XG4gICAgICAgICAgdGhpcy5kZXN0cm95TWV0aG9kID0gbmV3IENvbXBpbGVNZXRob2QodGhpcyk7XG4gICAgICAgICAgdGhpcy5kZXRhY2hNZXRob2QgPSBuZXcgQ29tcGlsZU1ldGhvZCh0aGlzKTtcbiAgICAgICAgICB0aGlzLnZpZXdUeXBlID0gZ2V0Vmlld1R5cGUoY29tcG9uZW50LCB2aWV3SW5kZXgpO1xuICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gXCJfVmlld19cIiArIGNvbXBvbmVudC50eXBlLm5hbWUgKyB2aWV3SW5kZXg7XG4gICAgICAgICAgdGhpcy5jbGFzc1R5cGUgPSBpbXBvcnRUeXBlKG5ldyBDb21waWxlSWRlbnRpZmllck1ldGFkYXRhKHsgbmFtZTogdGhpcy5jbGFzc05hbWUgfSkpO1xuICAgICAgICAgIHRoaXMudmlld0ZhY3RvcnkgPSB2YXJpYWJsZShnZXRWaWV3RmFjdG9yeU5hbWUoY29tcG9uZW50LCB2aWV3SW5kZXgpKTtcbiAgICAgICAgICBpZiAodGhpcy52aWV3VHlwZSA9PT0gVmlld1R5cGUuQ09NUE9ORU5UIHx8IHRoaXMudmlld1R5cGUgPT09IFZpZXdUeXBlLkhPU1QpIHtcbiAgICAgICAgICAgICAgdGhpcy5jb21wb25lbnRWaWV3ID0gdGhpcztcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuY29tcG9uZW50VmlldyA9IHRoaXMuZGVjbGFyYXRpb25FbGVtZW50LnZpZXcuY29tcG9uZW50VmlldztcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5jb21wb25lbnRDb250ZXh0ID1cbiAgICAgICAgICAgICAgZ2V0UHJvcGVydHlJblZpZXcoVEhJU19FWFBSLnByb3AoJ2NvbnRleHQnKSwgdGhpcywgdGhpcy5jb21wb25lbnRWaWV3KTtcbiAgICAgICAgICB2YXIgdmlld1F1ZXJpZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgaWYgKHRoaXMudmlld1R5cGUgPT09IFZpZXdUeXBlLkNPTVBPTkVOVCkge1xuICAgICAgICAgICAgICB2YXIgZGlyZWN0aXZlSW5zdGFuY2UgPSBUSElTX0VYUFIucHJvcCgnY29udGV4dCcpO1xuICAgICAgICAgICAgICBMaXN0V3JhcHBlci5mb3JFYWNoV2l0aEluZGV4KHRoaXMuY29tcG9uZW50LnZpZXdRdWVyaWVzLCBmdW5jdGlvbiAocXVlcnlNZXRhLCBxdWVyeUluZGV4KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcHJvcE5hbWUgPSBcIl92aWV3UXVlcnlfXCIgKyBxdWVyeU1ldGEuc2VsZWN0b3JzWzBdLm5hbWUgKyBcIl9cIiArIHF1ZXJ5SW5kZXg7XG4gICAgICAgICAgICAgICAgICB2YXIgcXVlcnlMaXN0ID0gY3JlYXRlUXVlcnlMaXN0KHF1ZXJ5TWV0YSwgZGlyZWN0aXZlSW5zdGFuY2UsIHByb3BOYW1lLCBfdGhpcyk7XG4gICAgICAgICAgICAgICAgICB2YXIgcXVlcnkgPSBuZXcgQ29tcGlsZVF1ZXJ5KHF1ZXJ5TWV0YSwgcXVlcnlMaXN0LCBkaXJlY3RpdmVJbnN0YW5jZSwgX3RoaXMpO1xuICAgICAgICAgICAgICAgICAgYWRkUXVlcnlUb1Rva2VuTWFwKHZpZXdRdWVyaWVzLCBxdWVyeSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB2YXIgY29uc3RydWN0b3JWaWV3UXVlcnlDb3VudCA9IDA7XG4gICAgICAgICAgICAgIHRoaXMuY29tcG9uZW50LnR5cGUuZGlEZXBzLmZvckVhY2goZnVuY3Rpb24gKGRlcCkge1xuICAgICAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudChkZXAudmlld1F1ZXJ5KSkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBxdWVyeUxpc3QgPSBUSElTX0VYUFIucHJvcCgnZGVjbGFyYXRpb25BcHBFbGVtZW50JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLnByb3AoJ2NvbXBvbmVudENvbnN0cnVjdG9yVmlld1F1ZXJpZXMnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAua2V5KGxpdGVyYWwoY29uc3RydWN0b3JWaWV3UXVlcnlDb3VudCsrKSk7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHF1ZXJ5ID0gbmV3IENvbXBpbGVRdWVyeShkZXAudmlld1F1ZXJ5LCBxdWVyeUxpc3QsIG51bGwsIF90aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICBhZGRRdWVyeVRvVG9rZW5NYXAodmlld1F1ZXJpZXMsIHF1ZXJ5KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMudmlld1F1ZXJpZXMgPSB2aWV3UXVlcmllcztcbiAgICAgICAgICB0ZW1wbGF0ZVZhcmlhYmxlQmluZGluZ3MuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHsgX3RoaXMubG9jYWxzLnNldChlbnRyeVsxXSwgVEhJU19FWFBSLnByb3AoJ2NvbnRleHQnKS5wcm9wKGVudHJ5WzBdKSk7IH0pO1xuICAgICAgICAgIGlmICghdGhpcy5kZWNsYXJhdGlvbkVsZW1lbnQuaXNOdWxsKCkpIHtcbiAgICAgICAgICAgICAgdGhpcy5kZWNsYXJhdGlvbkVsZW1lbnQuc2V0RW1iZWRkZWRWaWV3KHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIENvbXBpbGVWaWV3LnByb3RvdHlwZS5jYWxsUGlwZSA9IGZ1bmN0aW9uIChuYW1lLCBpbnB1dCwgYXJncykge1xuICAgICAgICAgIHJldHVybiBDb21waWxlUGlwZS5jYWxsKHRoaXMsIG5hbWUsIFtpbnB1dF0uY29uY2F0KGFyZ3MpKTtcbiAgICAgIH07XG4gICAgICBDb21waWxlVmlldy5wcm90b3R5cGUuZ2V0TG9jYWwgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgIGlmIChuYW1lID09IEV2ZW50SGFuZGxlclZhcnMuZXZlbnQubmFtZSkge1xuICAgICAgICAgICAgICByZXR1cm4gRXZlbnRIYW5kbGVyVmFycy5ldmVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGN1cnJWaWV3ID0gdGhpcztcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gY3VyclZpZXcubG9jYWxzLmdldChuYW1lKTtcbiAgICAgICAgICB3aGlsZSAoIXJlc3VsdCAmJiBpc1ByZXNlbnQoY3VyclZpZXcuZGVjbGFyYXRpb25FbGVtZW50LnZpZXcpKSB7XG4gICAgICAgICAgICAgIGN1cnJWaWV3ID0gY3VyclZpZXcuZGVjbGFyYXRpb25FbGVtZW50LnZpZXc7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IGN1cnJWaWV3LmxvY2Fscy5nZXQobmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1ByZXNlbnQocmVzdWx0KSkge1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0UHJvcGVydHlJblZpZXcocmVzdWx0LCB0aGlzLCBjdXJyVmlldyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgQ29tcGlsZVZpZXcucHJvdG90eXBlLmNyZWF0ZUxpdGVyYWxBcnJheSA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICByZXR1cm4gaW1wb3J0RXhwcihyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5FTVBUWV9BUlJBWSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcHJveHlFeHByID0gVEhJU19FWFBSLnByb3AoXCJfYXJyX1wiICsgdGhpcy5saXRlcmFsQXJyYXlDb3VudCsrKTtcbiAgICAgICAgICB2YXIgcHJveHlQYXJhbXMgPSBbXTtcbiAgICAgICAgICB2YXIgcHJveHlSZXR1cm5FbnRyaWVzID0gW107XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIHBhcmFtTmFtZSA9IFwicFwiICsgaTtcbiAgICAgICAgICAgICAgcHJveHlQYXJhbXMucHVzaChuZXcgRm5QYXJhbShwYXJhbU5hbWUpKTtcbiAgICAgICAgICAgICAgcHJveHlSZXR1cm5FbnRyaWVzLnB1c2godmFyaWFibGUocGFyYW1OYW1lKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNyZWF0ZVB1cmVQcm94eShmbihwcm94eVBhcmFtcywgW25ldyBSZXR1cm5TdGF0ZW1lbnQobGl0ZXJhbEFycihwcm94eVJldHVybkVudHJpZXMpKV0sIG5ldyBBcnJheVR5cGUoRFlOQU1JQ19UWVBFKSksIHZhbHVlcy5sZW5ndGgsIHByb3h5RXhwciwgdGhpcyk7XG4gICAgICAgICAgcmV0dXJuIHByb3h5RXhwci5jYWxsRm4odmFsdWVzKTtcbiAgICAgIH07XG4gICAgICBDb21waWxlVmlldy5wcm90b3R5cGUuY3JlYXRlTGl0ZXJhbE1hcCA9IGZ1bmN0aW9uIChlbnRyaWVzKSB7XG4gICAgICAgICAgaWYgKGVudHJpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpbXBvcnRFeHByKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLkVNUFRZX01BUCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcHJveHlFeHByID0gVEhJU19FWFBSLnByb3AoXCJfbWFwX1wiICsgdGhpcy5saXRlcmFsTWFwQ291bnQrKyk7XG4gICAgICAgICAgdmFyIHByb3h5UGFyYW1zID0gW107XG4gICAgICAgICAgdmFyIHByb3h5UmV0dXJuRW50cmllcyA9IFtdO1xuICAgICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVudHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIHBhcmFtTmFtZSA9IFwicFwiICsgaTtcbiAgICAgICAgICAgICAgcHJveHlQYXJhbXMucHVzaChuZXcgRm5QYXJhbShwYXJhbU5hbWUpKTtcbiAgICAgICAgICAgICAgcHJveHlSZXR1cm5FbnRyaWVzLnB1c2goW2VudHJpZXNbaV1bMF0sIHZhcmlhYmxlKHBhcmFtTmFtZSldKTtcbiAgICAgICAgICAgICAgdmFsdWVzLnB1c2goZW50cmllc1tpXVsxXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNyZWF0ZVB1cmVQcm94eShmbihwcm94eVBhcmFtcywgW25ldyBSZXR1cm5TdGF0ZW1lbnQobGl0ZXJhbE1hcChwcm94eVJldHVybkVudHJpZXMpKV0sIG5ldyBNYXBUeXBlKERZTkFNSUNfVFlQRSkpLCBlbnRyaWVzLmxlbmd0aCwgcHJveHlFeHByLCB0aGlzKTtcbiAgICAgICAgICByZXR1cm4gcHJveHlFeHByLmNhbGxGbih2YWx1ZXMpO1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVWaWV3LnByb3RvdHlwZS5hZnRlck5vZGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgTWFwV3JhcHBlci52YWx1ZXModGhpcy52aWV3UXVlcmllcylcbiAgICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKHF1ZXJpZXMpIHsgcmV0dXJuIHF1ZXJpZXMuZm9yRWFjaChmdW5jdGlvbiAocXVlcnkpIHsgcmV0dXJuIHF1ZXJ5LmFmdGVyQ2hpbGRyZW4oX3RoaXMuY3JlYXRlTWV0aG9kLCBfdGhpcy51cGRhdGVWaWV3UXVlcmllc01ldGhvZCk7IH0pOyB9KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gQ29tcGlsZVZpZXc7XG4gIH0oKSk7XG4gIGZ1bmN0aW9uIGdldFZpZXdUeXBlKGNvbXBvbmVudCwgZW1iZWRkZWRUZW1wbGF0ZUluZGV4KSB7XG4gICAgICBpZiAoZW1iZWRkZWRUZW1wbGF0ZUluZGV4ID4gMCkge1xuICAgICAgICAgIHJldHVybiBWaWV3VHlwZS5FTUJFRERFRDtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGNvbXBvbmVudC50eXBlLmlzSG9zdCkge1xuICAgICAgICAgIHJldHVybiBWaWV3VHlwZS5IT1NUO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFZpZXdUeXBlLkNPTVBPTkVOVDtcbiAgICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbGljZW5zZVxuICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICpcbiAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgKi9cbiAgdmFyIENvbXBpbGVCaW5kaW5nID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIENvbXBpbGVCaW5kaW5nKG5vZGUsIHNvdXJjZUFzdCkge1xuICAgICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgICAgdGhpcy5zb3VyY2VBc3QgPSBzb3VyY2VBc3Q7XG4gICAgICB9XG4gICAgICByZXR1cm4gQ29tcGlsZUJpbmRpbmc7XG4gIH0oKSk7XG5cbiAgdmFyIEV4cHJlc3Npb25XaXRoV3JhcHBlZFZhbHVlSW5mbyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBFeHByZXNzaW9uV2l0aFdyYXBwZWRWYWx1ZUluZm8oZXhwcmVzc2lvbiwgbmVlZHNWYWx1ZVVud3JhcHBlciwgdGVtcG9yYXJ5Q291bnQpIHtcbiAgICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgICAgICAgIHRoaXMubmVlZHNWYWx1ZVVud3JhcHBlciA9IG5lZWRzVmFsdWVVbndyYXBwZXI7XG4gICAgICAgICAgdGhpcy50ZW1wb3JhcnlDb3VudCA9IHRlbXBvcmFyeUNvdW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuIEV4cHJlc3Npb25XaXRoV3JhcHBlZFZhbHVlSW5mbztcbiAgfSgpKTtcbiAgZnVuY3Rpb24gY29udmVydENkRXhwcmVzc2lvblRvSXIobmFtZVJlc29sdmVyLCBpbXBsaWNpdFJlY2VpdmVyLCBleHByZXNzaW9uLCB2YWx1ZVVud3JhcHBlciwgYmluZGluZ0luZGV4KSB7XG4gICAgICB2YXIgdmlzaXRvciA9IG5ldyBfQXN0VG9JclZpc2l0b3IobmFtZVJlc29sdmVyLCBpbXBsaWNpdFJlY2VpdmVyLCB2YWx1ZVVud3JhcHBlciwgYmluZGluZ0luZGV4KTtcbiAgICAgIHZhciBpckFzdCA9IGV4cHJlc3Npb24udmlzaXQodmlzaXRvciwgX01vZGUuRXhwcmVzc2lvbik7XG4gICAgICByZXR1cm4gbmV3IEV4cHJlc3Npb25XaXRoV3JhcHBlZFZhbHVlSW5mbyhpckFzdCwgdmlzaXRvci5uZWVkc1ZhbHVlVW53cmFwcGVyLCB2aXNpdG9yLnRlbXBvcmFyeUNvdW50KTtcbiAgfVxuICBmdW5jdGlvbiBjb252ZXJ0Q2RTdGF0ZW1lbnRUb0lyKG5hbWVSZXNvbHZlciwgaW1wbGljaXRSZWNlaXZlciwgc3RtdCwgYmluZGluZ0luZGV4KSB7XG4gICAgICB2YXIgdmlzaXRvciA9IG5ldyBfQXN0VG9JclZpc2l0b3IobmFtZVJlc29sdmVyLCBpbXBsaWNpdFJlY2VpdmVyLCBudWxsLCBiaW5kaW5nSW5kZXgpO1xuICAgICAgdmFyIHN0YXRlbWVudHMgPSBbXTtcbiAgICAgIGZsYXR0ZW5TdGF0ZW1lbnRzKHN0bXQudmlzaXQodmlzaXRvciwgX01vZGUuU3RhdGVtZW50KSwgc3RhdGVtZW50cyk7XG4gICAgICBwcmVwZW5kVGVtcG9yYXJ5RGVjbHModmlzaXRvci50ZW1wb3JhcnlDb3VudCwgYmluZGluZ0luZGV4LCBzdGF0ZW1lbnRzKTtcbiAgICAgIHJldHVybiBzdGF0ZW1lbnRzO1xuICB9XG4gIGZ1bmN0aW9uIHRlbXBvcmFyeU5hbWUoYmluZGluZ0luZGV4LCB0ZW1wb3JhcnlOdW1iZXIpIHtcbiAgICAgIHJldHVybiBcInRtcF9cIiArIGJpbmRpbmdJbmRleCArIFwiX1wiICsgdGVtcG9yYXJ5TnVtYmVyO1xuICB9XG4gIGZ1bmN0aW9uIHRlbXBvcmFyeURlY2xhcmF0aW9uKGJpbmRpbmdJbmRleCwgdGVtcG9yYXJ5TnVtYmVyKSB7XG4gICAgICByZXR1cm4gbmV3IERlY2xhcmVWYXJTdG10KHRlbXBvcmFyeU5hbWUoYmluZGluZ0luZGV4LCB0ZW1wb3JhcnlOdW1iZXIpLCBOVUxMX0VYUFIpO1xuICB9XG4gIGZ1bmN0aW9uIHByZXBlbmRUZW1wb3JhcnlEZWNscyh0ZW1wb3JhcnlDb3VudCwgYmluZGluZ0luZGV4LCBzdGF0ZW1lbnRzKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGVtcG9yYXJ5Q291bnQgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHN0YXRlbWVudHMudW5zaGlmdCh0ZW1wb3JhcnlEZWNsYXJhdGlvbihiaW5kaW5nSW5kZXgsIGkpKTtcbiAgICAgIH1cbiAgfVxuICB2YXIgX01vZGU7XG4gIChmdW5jdGlvbiAoX01vZGUpIHtcbiAgICAgIF9Nb2RlW19Nb2RlW1wiU3RhdGVtZW50XCJdID0gMF0gPSBcIlN0YXRlbWVudFwiO1xuICAgICAgX01vZGVbX01vZGVbXCJFeHByZXNzaW9uXCJdID0gMV0gPSBcIkV4cHJlc3Npb25cIjtcbiAgfSkoX01vZGUgfHwgKF9Nb2RlID0ge30pKTtcbiAgZnVuY3Rpb24gZW5zdXJlU3RhdGVtZW50TW9kZShtb2RlLCBhc3QpIHtcbiAgICAgIGlmIChtb2RlICE9PSBfTW9kZS5TdGF0ZW1lbnQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBhIHN0YXRlbWVudCwgYnV0IHNhdyBcIiArIGFzdCk7XG4gICAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZW5zdXJlRXhwcmVzc2lvbk1vZGUobW9kZSwgYXN0KSB7XG4gICAgICBpZiAobW9kZSAhPT0gX01vZGUuRXhwcmVzc2lvbikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIGFuIGV4cHJlc3Npb24sIGJ1dCBzYXcgXCIgKyBhc3QpO1xuICAgICAgfVxuICB9XG4gIGZ1bmN0aW9uIGNvbnZlcnRUb1N0YXRlbWVudElmTmVlZGVkKG1vZGUsIGV4cHIpIHtcbiAgICAgIGlmIChtb2RlID09PSBfTW9kZS5TdGF0ZW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4gZXhwci50b1N0bXQoKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBleHByO1xuICAgICAgfVxuICB9XG4gIHZhciBfQXN0VG9JclZpc2l0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gX0FzdFRvSXJWaXNpdG9yKF9uYW1lUmVzb2x2ZXIsIF9pbXBsaWNpdFJlY2VpdmVyLCBfdmFsdWVVbndyYXBwZXIsIGJpbmRpbmdJbmRleCkge1xuICAgICAgICAgIHRoaXMuX25hbWVSZXNvbHZlciA9IF9uYW1lUmVzb2x2ZXI7XG4gICAgICAgICAgdGhpcy5faW1wbGljaXRSZWNlaXZlciA9IF9pbXBsaWNpdFJlY2VpdmVyO1xuICAgICAgICAgIHRoaXMuX3ZhbHVlVW53cmFwcGVyID0gX3ZhbHVlVW53cmFwcGVyO1xuICAgICAgICAgIHRoaXMuYmluZGluZ0luZGV4ID0gYmluZGluZ0luZGV4O1xuICAgICAgICAgIHRoaXMuX25vZGVNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgdGhpcy5fcmVzdWx0TWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgIHRoaXMuX2N1cnJlbnRUZW1wb3JhcnkgPSAwO1xuICAgICAgICAgIHRoaXMubmVlZHNWYWx1ZVVud3JhcHBlciA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMudGVtcG9yYXJ5Q291bnQgPSAwO1xuICAgICAgfVxuICAgICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEJpbmFyeSA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgICB2YXIgb3A7XG4gICAgICAgICAgc3dpdGNoIChhc3Qub3BlcmF0aW9uKSB7XG4gICAgICAgICAgICAgIGNhc2UgJysnOlxuICAgICAgICAgICAgICAgICAgb3AgPSBCaW5hcnlPcGVyYXRvci5QbHVzO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgICAgICAgb3AgPSBCaW5hcnlPcGVyYXRvci5NaW51cztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICcqJzpcbiAgICAgICAgICAgICAgICAgIG9wID0gQmluYXJ5T3BlcmF0b3IuTXVsdGlwbHk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnLyc6XG4gICAgICAgICAgICAgICAgICBvcCA9IEJpbmFyeU9wZXJhdG9yLkRpdmlkZTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICclJzpcbiAgICAgICAgICAgICAgICAgIG9wID0gQmluYXJ5T3BlcmF0b3IuTW9kdWxvO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJyYmJzpcbiAgICAgICAgICAgICAgICAgIG9wID0gQmluYXJ5T3BlcmF0b3IuQW5kO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJ3x8JzpcbiAgICAgICAgICAgICAgICAgIG9wID0gQmluYXJ5T3BlcmF0b3IuT3I7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnPT0nOlxuICAgICAgICAgICAgICAgICAgb3AgPSBCaW5hcnlPcGVyYXRvci5FcXVhbHM7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnIT0nOlxuICAgICAgICAgICAgICAgICAgb3AgPSBCaW5hcnlPcGVyYXRvci5Ob3RFcXVhbHM7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnPT09JzpcbiAgICAgICAgICAgICAgICAgIG9wID0gQmluYXJ5T3BlcmF0b3IuSWRlbnRpY2FsO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJyE9PSc6XG4gICAgICAgICAgICAgICAgICBvcCA9IEJpbmFyeU9wZXJhdG9yLk5vdElkZW50aWNhbDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgICAgICAgICAgIG9wID0gQmluYXJ5T3BlcmF0b3IuTG93ZXI7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnPic6XG4gICAgICAgICAgICAgICAgICBvcCA9IEJpbmFyeU9wZXJhdG9yLkJpZ2dlcjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICc8PSc6XG4gICAgICAgICAgICAgICAgICBvcCA9IEJpbmFyeU9wZXJhdG9yLkxvd2VyRXF1YWxzO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJz49JzpcbiAgICAgICAgICAgICAgICAgIG9wID0gQmluYXJ5T3BlcmF0b3IuQmlnZ2VyRXF1YWxzO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBvcGVyYXRpb24gXCIgKyBhc3Qub3BlcmF0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1N0YXRlbWVudElmTmVlZGVkKG1vZGUsIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIob3AsIHRoaXMudmlzaXQoYXN0LmxlZnQsIF9Nb2RlLkV4cHJlc3Npb24pLCB0aGlzLnZpc2l0KGFzdC5yaWdodCwgX01vZGUuRXhwcmVzc2lvbikpKTtcbiAgICAgIH07XG4gICAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q2hhaW4gPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgICAgZW5zdXJlU3RhdGVtZW50TW9kZShtb2RlLCBhc3QpO1xuICAgICAgICAgIHJldHVybiB0aGlzLnZpc2l0QWxsKGFzdC5leHByZXNzaW9ucywgbW9kZSk7XG4gICAgICB9O1xuICAgICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbmRpdGlvbmFsID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmlzaXQoYXN0LmNvbmRpdGlvbiwgX01vZGUuRXhwcmVzc2lvbik7XG4gICAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1N0YXRlbWVudElmTmVlZGVkKG1vZGUsIHZhbHVlLmNvbmRpdGlvbmFsKHRoaXMudmlzaXQoYXN0LnRydWVFeHAsIF9Nb2RlLkV4cHJlc3Npb24pLCB0aGlzLnZpc2l0KGFzdC5mYWxzZUV4cCwgX01vZGUuRXhwcmVzc2lvbikpKTtcbiAgICAgIH07XG4gICAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UGlwZSA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLnZpc2l0KGFzdC5leHAsIF9Nb2RlLkV4cHJlc3Npb24pO1xuICAgICAgICAgIHZhciBhcmdzID0gdGhpcy52aXNpdEFsbChhc3QuYXJncywgX01vZGUuRXhwcmVzc2lvbik7XG4gICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fbmFtZVJlc29sdmVyLmNhbGxQaXBlKGFzdC5uYW1lLCBpbnB1dCwgYXJncyk7XG4gICAgICAgICAgdGhpcy5uZWVkc1ZhbHVlVW53cmFwcGVyID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgdGhpcy5fdmFsdWVVbndyYXBwZXIuY2FsbE1ldGhvZCgndW53cmFwJywgW3ZhbHVlXSkpO1xuICAgICAgfTtcbiAgICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRGdW5jdGlvbkNhbGwgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1N0YXRlbWVudElmTmVlZGVkKG1vZGUsIHRoaXMudmlzaXQoYXN0LnRhcmdldCwgX01vZGUuRXhwcmVzc2lvbikuY2FsbEZuKHRoaXMudmlzaXRBbGwoYXN0LmFyZ3MsIF9Nb2RlLkV4cHJlc3Npb24pKSk7XG4gICAgICB9O1xuICAgICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEltcGxpY2l0UmVjZWl2ZXIgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgICAgZW5zdXJlRXhwcmVzc2lvbk1vZGUobW9kZSwgYXN0KTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5faW1wbGljaXRSZWNlaXZlcjtcbiAgICAgIH07XG4gICAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0SW50ZXJwb2xhdGlvbiA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgICBlbnN1cmVFeHByZXNzaW9uTW9kZShtb2RlLCBhc3QpO1xuICAgICAgICAgIHZhciBhcmdzID0gW2xpdGVyYWwoYXN0LmV4cHJlc3Npb25zLmxlbmd0aCldO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXN0LnN0cmluZ3MubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgIGFyZ3MucHVzaChsaXRlcmFsKGFzdC5zdHJpbmdzW2ldKSk7XG4gICAgICAgICAgICAgIGFyZ3MucHVzaCh0aGlzLnZpc2l0KGFzdC5leHByZXNzaW9uc1tpXSwgX01vZGUuRXhwcmVzc2lvbikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhcmdzLnB1c2gobGl0ZXJhbChhc3Quc3RyaW5nc1thc3Quc3RyaW5ncy5sZW5ndGggLSAxXSkpO1xuICAgICAgICAgIHJldHVybiBpbXBvcnRFeHByKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLmludGVycG9sYXRlKSkuY2FsbEZuKGFyZ3MpO1xuICAgICAgfTtcbiAgICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRLZXllZFJlYWQgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1N0YXRlbWVudElmTmVlZGVkKG1vZGUsIHRoaXMudmlzaXQoYXN0Lm9iaiwgX01vZGUuRXhwcmVzc2lvbikua2V5KHRoaXMudmlzaXQoYXN0LmtleSwgX01vZGUuRXhwcmVzc2lvbikpKTtcbiAgICAgIH07XG4gICAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0S2V5ZWRXcml0ZSA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgICB2YXIgb2JqID0gdGhpcy52aXNpdChhc3Qub2JqLCBfTW9kZS5FeHByZXNzaW9uKTtcbiAgICAgICAgICB2YXIga2V5ID0gdGhpcy52aXNpdChhc3Qua2V5LCBfTW9kZS5FeHByZXNzaW9uKTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnZpc2l0KGFzdC52YWx1ZSwgX01vZGUuRXhwcmVzc2lvbik7XG4gICAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1N0YXRlbWVudElmTmVlZGVkKG1vZGUsIG9iai5rZXkoa2V5KS5zZXQodmFsdWUpKTtcbiAgICAgIH07XG4gICAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0TGl0ZXJhbEFycmF5ID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICAgIHJldHVybiBjb252ZXJ0VG9TdGF0ZW1lbnRJZk5lZWRlZChtb2RlLCB0aGlzLl9uYW1lUmVzb2x2ZXIuY3JlYXRlTGl0ZXJhbEFycmF5KHRoaXMudmlzaXRBbGwoYXN0LmV4cHJlc3Npb25zLCBtb2RlKSkpO1xuICAgICAgfTtcbiAgICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRMaXRlcmFsTWFwID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICAgIHZhciBwYXJ0cyA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXN0LmtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgcGFydHMucHVzaChbYXN0LmtleXNbaV0sIHRoaXMudmlzaXQoYXN0LnZhbHVlc1tpXSwgX01vZGUuRXhwcmVzc2lvbildKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1N0YXRlbWVudElmTmVlZGVkKG1vZGUsIHRoaXMuX25hbWVSZXNvbHZlci5jcmVhdGVMaXRlcmFsTWFwKHBhcnRzKSk7XG4gICAgICB9O1xuICAgICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdExpdGVyYWxQcmltaXRpdmUgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1N0YXRlbWVudElmTmVlZGVkKG1vZGUsIGxpdGVyYWwoYXN0LnZhbHVlKSk7XG4gICAgICB9O1xuICAgICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdE1ldGhvZENhbGwgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgICAgdmFyIGxlZnRNb3N0U2FmZSA9IHRoaXMubGVmdE1vc3RTYWZlTm9kZShhc3QpO1xuICAgICAgICAgIGlmIChsZWZ0TW9zdFNhZmUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydFNhZmVBY2Nlc3MoYXN0LCBsZWZ0TW9zdFNhZmUsIG1vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIGFyZ3MgPSB0aGlzLnZpc2l0QWxsKGFzdC5hcmdzLCBfTW9kZS5FeHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICAgIHZhciByZWNlaXZlciA9IHRoaXMudmlzaXQoYXN0LnJlY2VpdmVyLCBfTW9kZS5FeHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgaWYgKHJlY2VpdmVyID09PSB0aGlzLl9pbXBsaWNpdFJlY2VpdmVyKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgdmFyRXhwciA9IHRoaXMuX25hbWVSZXNvbHZlci5nZXRMb2NhbChhc3QubmFtZSk7XG4gICAgICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KHZhckV4cHIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdmFyRXhwci5jYWxsRm4oYXJncyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGlzQmxhbmsocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVjZWl2ZXIuY2FsbE1ldGhvZChhc3QubmFtZSwgYXJncyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1N0YXRlbWVudElmTmVlZGVkKG1vZGUsIHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRQcmVmaXhOb3QgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1N0YXRlbWVudElmTmVlZGVkKG1vZGUsIG5vdCh0aGlzLnZpc2l0KGFzdC5leHByZXNzaW9uLCBfTW9kZS5FeHByZXNzaW9uKSkpO1xuICAgICAgfTtcbiAgICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRQcm9wZXJ0eVJlYWQgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgICAgdmFyIGxlZnRNb3N0U2FmZSA9IHRoaXMubGVmdE1vc3RTYWZlTm9kZShhc3QpO1xuICAgICAgICAgIGlmIChsZWZ0TW9zdFNhZmUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydFNhZmVBY2Nlc3MoYXN0LCBsZWZ0TW9zdFNhZmUsIG1vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICAgIHZhciByZWNlaXZlciA9IHRoaXMudmlzaXQoYXN0LnJlY2VpdmVyLCBfTW9kZS5FeHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgaWYgKHJlY2VpdmVyID09PSB0aGlzLl9pbXBsaWNpdFJlY2VpdmVyKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9uYW1lUmVzb2x2ZXIuZ2V0TG9jYWwoYXN0Lm5hbWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChpc0JsYW5rKHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlY2VpdmVyLnByb3AoYXN0Lm5hbWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBjb252ZXJ0VG9TdGF0ZW1lbnRJZk5lZWRlZChtb2RlLCByZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UHJvcGVydHlXcml0ZSA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgICB2YXIgcmVjZWl2ZXIgPSB0aGlzLnZpc2l0KGFzdC5yZWNlaXZlciwgX01vZGUuRXhwcmVzc2lvbik7XG4gICAgICAgICAgaWYgKHJlY2VpdmVyID09PSB0aGlzLl9pbXBsaWNpdFJlY2VpdmVyKSB7XG4gICAgICAgICAgICAgIHZhciB2YXJFeHByID0gdGhpcy5fbmFtZVJlc29sdmVyLmdldExvY2FsKGFzdC5uYW1lKTtcbiAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudCh2YXJFeHByKSkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYXNzaWduIHRvIGEgcmVmZXJlbmNlIG9yIHZhcmlhYmxlIScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjb252ZXJ0VG9TdGF0ZW1lbnRJZk5lZWRlZChtb2RlLCByZWNlaXZlci5wcm9wKGFzdC5uYW1lKS5zZXQodGhpcy52aXNpdChhc3QudmFsdWUsIF9Nb2RlLkV4cHJlc3Npb24pKSk7XG4gICAgICB9O1xuICAgICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFNhZmVQcm9wZXJ0eVJlYWQgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydFNhZmVBY2Nlc3MoYXN0LCB0aGlzLmxlZnRNb3N0U2FmZU5vZGUoYXN0KSwgbW9kZSk7XG4gICAgICB9O1xuICAgICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFNhZmVNZXRob2RDYWxsID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRTYWZlQWNjZXNzKGFzdCwgdGhpcy5sZWZ0TW9zdFNhZmVOb2RlKGFzdCksIG1vZGUpO1xuICAgICAgfTtcbiAgICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRBbGwgPSBmdW5jdGlvbiAoYXN0cywgbW9kZSkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgcmV0dXJuIGFzdHMubWFwKGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIF90aGlzLnZpc2l0KGFzdCwgbW9kZSk7IH0pO1xuICAgICAgfTtcbiAgICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRRdW90ZSA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1F1b3RlcyBhcmUgbm90IHN1cHBvcnRlZCBmb3IgZXZhbHVhdGlvbiEnKTtcbiAgICAgIH07XG4gICAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9yZXN1bHRNYXAuZ2V0KGFzdCk7XG4gICAgICAgICAgaWYgKHJlc3VsdClcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICByZXR1cm4gKHRoaXMuX25vZGVNYXAuZ2V0KGFzdCkgfHwgYXN0KS52aXNpdCh0aGlzLCBtb2RlKTtcbiAgICAgIH07XG4gICAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLmNvbnZlcnRTYWZlQWNjZXNzID0gZnVuY3Rpb24gKGFzdCwgbGVmdE1vc3RTYWZlLCBtb2RlKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGV4cHJlc3Npb24gY29udGFpbnMgYSBzYWZlIGFjY2VzcyBub2RlIG9uIHRoZSBsZWZ0IGl0IG5lZWRzIHRvIGJlIGNvbnZlcnRlZCB0b1xuICAgICAgICAgIC8vIGFuIGV4cHJlc3Npb24gdGhhdCBndWFyZHMgdGhlIGFjY2VzcyB0byB0aGUgbWVtYmVyIGJ5IGNoZWNraW5nIHRoZSByZWNlaXZlciBmb3IgYmxhbmsuIEFzXG4gICAgICAgICAgLy8gZXhlY3V0aW9uIHByb2NlZWRzIGZyb20gbGVmdCB0byByaWdodCwgdGhlIGxlZnQgbW9zdCBwYXJ0IG9mIHRoZSBleHByZXNzaW9uIG11c3QgYmUgZ3VhcmRlZFxuICAgICAgICAgIC8vIGZpcnN0IGJ1dCwgYmVjYXVzZSBtZW1iZXIgYWNjZXNzIGlzIGxlZnQgYXNzb2NpYXRpdmUsIHRoZSByaWdodCBzaWRlIG9mIHRoZSBleHByZXNzaW9uIGlzIGF0XG4gICAgICAgICAgLy8gdGhlIHRvcCBvZiB0aGUgQVNULiBUaGUgZGVzaXJlZCByZXN1bHQgcmVxdWlyZXMgbGlmdGluZyBhIGNvcHkgb2YgdGhlIHRoZSBsZWZ0IHBhcnQgb2YgdGhlXG4gICAgICAgICAgLy8gZXhwcmVzc2lvbiB1cCB0byB0ZXN0IGl0IGZvciBibGFuayBiZWZvcmUgZ2VuZXJhdGluZyB0aGUgdW5ndWFyZGVkIHZlcnNpb24uXG4gICAgICAgICAgLy8gQ29uc2lkZXIsIGZvciBleGFtcGxlIHRoZSBmb2xsb3dpbmcgZXhwcmVzc2lvbjogYT8uYi5jPy5kLmVcbiAgICAgICAgICAvLyBUaGlzIHJlc3VsdHMgaW4gdGhlIGFzdDpcbiAgICAgICAgICAvLyAgICAgICAgIC5cbiAgICAgICAgICAvLyAgICAgICAgLyBcXFxuICAgICAgICAgIC8vICAgICAgID8uICAgZVxuICAgICAgICAgIC8vICAgICAgLyAgXFxcbiAgICAgICAgICAvLyAgICAgLiAgICBkXG4gICAgICAgICAgLy8gICAgLyBcXFxuICAgICAgICAgIC8vICAgPy4gIGNcbiAgICAgICAgICAvLyAgLyAgXFxcbiAgICAgICAgICAvLyBhICAgIGJcbiAgICAgICAgICAvLyBUaGUgZm9sbG93aW5nIHRyZWUgc2hvdWxkIGJlIGdlbmVyYXRlZDpcbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vICAgICAgICAvLS0tLSA/IC0tLS1cXFxuICAgICAgICAgIC8vICAgICAgIC8gICAgICB8ICAgICAgXFxcbiAgICAgICAgICAvLyAgICAgYSAgIC8tLS0gPyAtLS1cXCAgbnVsbFxuICAgICAgICAgIC8vICAgICAgICAvICAgICB8ICAgICBcXFxuICAgICAgICAgIC8vICAgICAgIC4gICAgICAuICAgICBudWxsXG4gICAgICAgICAgLy8gICAgICAvIFxcICAgIC8gXFxcbiAgICAgICAgICAvLyAgICAgLiAgYyAgIC4gICBlXG4gICAgICAgICAgLy8gICAgLyBcXCAgICAvIFxcXG4gICAgICAgICAgLy8gICBhICAgYiAgLCAgIGRcbiAgICAgICAgICAvLyAgICAgICAgIC8gXFxcbiAgICAgICAgICAvLyAgICAgICAgLiAgIGNcbiAgICAgICAgICAvLyAgICAgICAvIFxcXG4gICAgICAgICAgLy8gICAgICBhICAgYlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gTm90aWNlIHRoYXQgdGhlIGZpcnN0IGd1YXJkIGNvbmRpdGlvbiBpcyB0aGUgbGVmdCBoYW5kIG9mIHRoZSBsZWZ0IG1vc3Qgc2FmZSBhY2Nlc3Mgbm9kZVxuICAgICAgICAgIC8vIHdoaWNoIGNvbWVzIGluIGFzIGxlZnRNb3N0U2FmZSB0byB0aGlzIHJvdXRpbmUuXG4gICAgICAgICAgdmFyIGd1YXJkZWRFeHByZXNzaW9uID0gdGhpcy52aXNpdChsZWZ0TW9zdFNhZmUucmVjZWl2ZXIsIF9Nb2RlLkV4cHJlc3Npb24pO1xuICAgICAgICAgIHZhciB0ZW1wb3Jhcnk7XG4gICAgICAgICAgaWYgKHRoaXMubmVlZHNUZW1wb3JhcnkobGVmdE1vc3RTYWZlLnJlY2VpdmVyKSkge1xuICAgICAgICAgICAgICAvLyBJZiB0aGUgZXhwcmVzc2lvbiBoYXMgbWV0aG9kIGNhbGxzIG9yIHBpcGVzIHRoZW4gd2UgbmVlZCB0byBzYXZlIHRoZSByZXN1bHQgaW50byBhXG4gICAgICAgICAgICAgIC8vIHRlbXBvcmFyeSB2YXJpYWJsZSB0byBhdm9pZCBjYWxsaW5nIHN0YXRlZnVsIG9yIGltcHVyZSBjb2RlIG1vcmUgdGhhbiBvbmNlLlxuICAgICAgICAgICAgICB0ZW1wb3JhcnkgPSB0aGlzLmFsbG9jYXRlVGVtcG9yYXJ5KCk7XG4gICAgICAgICAgICAgIC8vIFByZXNlcnZlIHRoZSByZXN1bHQgaW4gdGhlIHRlbXBvcmFyeSB2YXJpYWJsZVxuICAgICAgICAgICAgICBndWFyZGVkRXhwcmVzc2lvbiA9IHRlbXBvcmFyeS5zZXQoZ3VhcmRlZEV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAvLyBFbnN1cmUgYWxsIGZ1cnRoZXIgcmVmZXJlbmNlcyB0byB0aGUgZ3VhcmRlZCBleHByZXNzaW9uIHJlZmVyIHRvIHRoZSB0ZW1wb3JhcnkgaW5zdGVhZC5cbiAgICAgICAgICAgICAgdGhpcy5fcmVzdWx0TWFwLnNldChsZWZ0TW9zdFNhZmUucmVjZWl2ZXIsIHRlbXBvcmFyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBjb25kaXRpb24gPSBndWFyZGVkRXhwcmVzc2lvbi5pc0JsYW5rKCk7XG4gICAgICAgICAgLy8gQ29udmVydCB0aGUgYXN0IHRvIGFuIHVuZ3VhcmRlZCBhY2Nlc3MgdG8gdGhlIHJlY2VpdmVyJ3MgbWVtYmVyLiBUaGUgbWFwIHdpbGwgc3Vic3RpdHV0ZVxuICAgICAgICAgIC8vIGxlZnRNb3N0Tm9kZSB3aXRoIGl0cyB1bmd1YXJkZWQgdmVyc2lvbiBpbiB0aGUgY2FsbCB0byBgdGhpcy52aXNpdCgpYC5cbiAgICAgICAgICBpZiAobGVmdE1vc3RTYWZlIGluc3RhbmNlb2YgU2FmZU1ldGhvZENhbGwpIHtcbiAgICAgICAgICAgICAgdGhpcy5fbm9kZU1hcC5zZXQobGVmdE1vc3RTYWZlLCBuZXcgTWV0aG9kQ2FsbChsZWZ0TW9zdFNhZmUuc3BhbiwgbGVmdE1vc3RTYWZlLnJlY2VpdmVyLCBsZWZ0TW9zdFNhZmUubmFtZSwgbGVmdE1vc3RTYWZlLmFyZ3MpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuX25vZGVNYXAuc2V0KGxlZnRNb3N0U2FmZSwgbmV3IFByb3BlcnR5UmVhZChsZWZ0TW9zdFNhZmUuc3BhbiwgbGVmdE1vc3RTYWZlLnJlY2VpdmVyLCBsZWZ0TW9zdFNhZmUubmFtZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBSZWN1cnNpdmVseSBjb252ZXJ0IHRoZSBub2RlIG5vdyB3aXRob3V0IHRoZSBndWFyZGVkIG1lbWJlciBhY2Nlc3MuXG4gICAgICAgICAgdmFyIGFjY2VzcyA9IHRoaXMudmlzaXQoYXN0LCBfTW9kZS5FeHByZXNzaW9uKTtcbiAgICAgICAgICAvLyBSZW1vdmUgdGhlIG1hcHBpbmcuIFRoaXMgaXMgbm90IHN0cmljdGx5IHJlcXVpcmVkIGFzIHRoZSBjb252ZXJ0ZXIgb25seSB0cmF2ZXJzZXMgZWFjaCBub2RlXG4gICAgICAgICAgLy8gb25jZSBidXQgaXMgc2FmZXIgaWYgdGhlIGNvbnZlcnNpb24gaXMgY2hhbmdlZCB0byB0cmF2ZXJzZSB0aGUgbm9kZXMgbW9yZSB0aGFuIG9uY2UuXG4gICAgICAgICAgdGhpcy5fbm9kZU1hcC5kZWxldGUobGVmdE1vc3RTYWZlKTtcbiAgICAgICAgICAvLyBJZiB3ZSBhbGxjb2F0ZWQgYSB0ZW1wb3JhcnksIHJlbGVhc2UgaXQuXG4gICAgICAgICAgaWYgKHRlbXBvcmFyeSkge1xuICAgICAgICAgICAgICB0aGlzLnJlbGVhc2VUZW1wb3JhcnkodGVtcG9yYXJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUHJvZHVjZSB0aGUgY29uZGl0aW9uYWxcbiAgICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgY29uZGl0aW9uLmNvbmRpdGlvbmFsKGxpdGVyYWwobnVsbCksIGFjY2VzcykpO1xuICAgICAgfTtcbiAgICAgIC8vIEdpdmVuIGEgZXhwcmVzc2lvbiBvZiB0aGUgZm9ybSBhPy5iLmM/LmQuZSB0aGUgdGhlIGxlZnQgbW9zdCBzYWZlIG5vZGUgaXNcbiAgICAgIC8vIHRoZSAoYT8uYikuIFRoZSAuIGFuZCA/LiBhcmUgbGVmdCBhc3NvY2lhdGl2ZSB0aHVzIGNhbiBiZSByZXdyaXR0ZW4gYXM6XG4gICAgICAvLyAoKCgoYT8uYykuYikuYyk/LmQpLmUuIFRoaXMgcmV0dXJucyB0aGUgbW9zdCBkZWVwbHkgbmVzdGVkIHNhZmUgcmVhZCBvclxuICAgICAgLy8gc2FmZSBtZXRob2QgY2FsbCBhcyB0aGlzIG5lZWRzIGJlIHRyYW5zZm9ybSBpbml0aWFsbHkgdG86XG4gICAgICAvLyAgIGEgPT0gbnVsbCA/IG51bGwgOiBhLmMuYi5jPy5kLmVcbiAgICAgIC8vIHRoZW4gdG86XG4gICAgICAvLyAgIGEgPT0gbnVsbCA/IG51bGwgOiBhLmIuYyA9PSBudWxsID8gbnVsbCA6IGEuYi5jLmQuZVxuICAgICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS5sZWZ0TW9zdFNhZmVOb2RlID0gZnVuY3Rpb24gKGFzdCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIHZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGFzdCkge1xuICAgICAgICAgICAgICByZXR1cm4gKF90aGlzLl9ub2RlTWFwLmdldChhc3QpIHx8IGFzdCkudmlzaXQodmlzaXRvcik7XG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gYXN0LnZpc2l0KHtcbiAgICAgICAgICAgICAgdmlzaXRCaW5hcnk6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgICAgIHZpc2l0Q2hhaW46IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgICAgIHZpc2l0Q29uZGl0aW9uYWw6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgICAgIHZpc2l0RnVuY3Rpb25DYWxsOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgICB2aXNpdEltcGxpY2l0UmVjZWl2ZXI6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgICAgIHZpc2l0SW50ZXJwb2xhdGlvbjogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgICAgICAgdmlzaXRLZXllZFJlYWQ6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIHZpc2l0KHRoaXMsIGFzdC5vYmopOyB9LFxuICAgICAgICAgICAgICB2aXNpdEtleWVkV3JpdGU6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgICAgIHZpc2l0TGl0ZXJhbEFycmF5OiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgICB2aXNpdExpdGVyYWxNYXA6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgICAgIHZpc2l0TGl0ZXJhbFByaW1pdGl2ZTogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgICAgICAgdmlzaXRNZXRob2RDYWxsOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiB2aXNpdCh0aGlzLCBhc3QucmVjZWl2ZXIpOyB9LFxuICAgICAgICAgICAgICB2aXNpdFBpcGU6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgICAgIHZpc2l0UHJlZml4Tm90OiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgICB2aXNpdFByb3BlcnR5UmVhZDogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gdmlzaXQodGhpcywgYXN0LnJlY2VpdmVyKTsgfSxcbiAgICAgICAgICAgICAgdmlzaXRQcm9wZXJ0eVdyaXRlOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgICB2aXNpdFF1b3RlOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgICB2aXNpdFNhZmVNZXRob2RDYWxsOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiB2aXNpdCh0aGlzLCBhc3QucmVjZWl2ZXIpIHx8IGFzdDsgfSxcbiAgICAgICAgICAgICAgdmlzaXRTYWZlUHJvcGVydHlSZWFkOiBmdW5jdGlvbiAoYXN0KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdmlzaXQodGhpcywgYXN0LnJlY2VpdmVyKSB8fCBhc3Q7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICAvLyBSZXR1cm5zIHRydWUgb2YgdGhlIEFTVCBpbmNsdWRlcyBhIG1ldGhvZCBvciBhIHBpcGUgaW5kaWNhdGluZyB0aGF0LCBpZiB0aGVcbiAgICAgIC8vIGV4cHJlc3Npb24gaXMgdXNlZCBhcyB0aGUgdGFyZ2V0IG9mIGEgc2FmZSBwcm9wZXJ0eSBvciBtZXRob2QgYWNjZXNzIHRoZW5cbiAgICAgIC8vIHRoZSBleHByZXNzaW9uIHNob3VsZCBiZSBzdG9yZWQgaW50byBhIHRlbXBvcmFyeSB2YXJpYWJsZS5cbiAgICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUubmVlZHNUZW1wb3JhcnkgPSBmdW5jdGlvbiAoYXN0KSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgdmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgYXN0KSB7XG4gICAgICAgICAgICAgIHJldHVybiBhc3QgJiYgKF90aGlzLl9ub2RlTWFwLmdldChhc3QpIHx8IGFzdCkudmlzaXQodmlzaXRvcik7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgdmlzaXRTb21lID0gZnVuY3Rpb24gKHZpc2l0b3IsIGFzdCkge1xuICAgICAgICAgICAgICByZXR1cm4gYXN0LnNvbWUoZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gdmlzaXQodmlzaXRvciwgYXN0KTsgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gYXN0LnZpc2l0KHtcbiAgICAgICAgICAgICAgdmlzaXRCaW5hcnk6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIHZpc2l0KHRoaXMsIGFzdC5sZWZ0KSB8fCB2aXNpdCh0aGlzLCBhc3QucmlnaHQpOyB9LFxuICAgICAgICAgICAgICB2aXNpdENoYWluOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBmYWxzZTsgfSxcbiAgICAgICAgICAgICAgdmlzaXRDb25kaXRpb25hbDogZnVuY3Rpb24gKGFzdCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHZpc2l0KHRoaXMsIGFzdC5jb25kaXRpb24pIHx8IHZpc2l0KHRoaXMsIGFzdC50cnVlRXhwKSB8fFxuICAgICAgICAgICAgICAgICAgICAgIHZpc2l0KHRoaXMsIGFzdC5mYWxzZUV4cCk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHZpc2l0RnVuY3Rpb25DYWxsOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiB0cnVlOyB9LFxuICAgICAgICAgICAgICB2aXNpdEltcGxpY2l0UmVjZWl2ZXI6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIGZhbHNlOyB9LFxuICAgICAgICAgICAgICB2aXNpdEludGVycG9sYXRpb246IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIHZpc2l0U29tZSh0aGlzLCBhc3QuZXhwcmVzc2lvbnMpOyB9LFxuICAgICAgICAgICAgICB2aXNpdEtleWVkUmVhZDogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gZmFsc2U7IH0sXG4gICAgICAgICAgICAgIHZpc2l0S2V5ZWRXcml0ZTogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gZmFsc2U7IH0sXG4gICAgICAgICAgICAgIHZpc2l0TGl0ZXJhbEFycmF5OiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiB0cnVlOyB9LFxuICAgICAgICAgICAgICB2aXNpdExpdGVyYWxNYXA6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIHRydWU7IH0sXG4gICAgICAgICAgICAgIHZpc2l0TGl0ZXJhbFByaW1pdGl2ZTogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gZmFsc2U7IH0sXG4gICAgICAgICAgICAgIHZpc2l0TWV0aG9kQ2FsbDogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gdHJ1ZTsgfSxcbiAgICAgICAgICAgICAgdmlzaXRQaXBlOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiB0cnVlOyB9LFxuICAgICAgICAgICAgICB2aXNpdFByZWZpeE5vdDogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gdmlzaXQodGhpcywgYXN0LmV4cHJlc3Npb24pOyB9LFxuICAgICAgICAgICAgICB2aXNpdFByb3BlcnR5UmVhZDogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gZmFsc2U7IH0sXG4gICAgICAgICAgICAgIHZpc2l0UHJvcGVydHlXcml0ZTogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gZmFsc2U7IH0sXG4gICAgICAgICAgICAgIHZpc2l0UXVvdGU6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIGZhbHNlOyB9LFxuICAgICAgICAgICAgICB2aXNpdFNhZmVNZXRob2RDYWxsOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiB0cnVlOyB9LFxuICAgICAgICAgICAgICB2aXNpdFNhZmVQcm9wZXJ0eVJlYWQ6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS5hbGxvY2F0ZVRlbXBvcmFyeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgdGVtcE51bWJlciA9IHRoaXMuX2N1cnJlbnRUZW1wb3JhcnkrKztcbiAgICAgICAgICB0aGlzLnRlbXBvcmFyeUNvdW50ID0gTWF0aC5tYXgodGhpcy5fY3VycmVudFRlbXBvcmFyeSwgdGhpcy50ZW1wb3JhcnlDb3VudCk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBSZWFkVmFyRXhwcih0ZW1wb3JhcnlOYW1lKHRoaXMuYmluZGluZ0luZGV4LCB0ZW1wTnVtYmVyKSk7XG4gICAgICB9O1xuICAgICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS5yZWxlYXNlVGVtcG9yYXJ5ID0gZnVuY3Rpb24gKHRlbXBvcmFyeSkge1xuICAgICAgICAgIHRoaXMuX2N1cnJlbnRUZW1wb3JhcnktLTtcbiAgICAgICAgICBpZiAodGVtcG9yYXJ5Lm5hbWUgIT0gdGVtcG9yYXJ5TmFtZSh0aGlzLmJpbmRpbmdJbmRleCwgdGhpcy5fY3VycmVudFRlbXBvcmFyeSkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGVtcG9yYXJ5IFwiICsgdGVtcG9yYXJ5Lm5hbWUgKyBcIiByZWxlYXNlZCBvdXQgb2Ygb3JkZXJcIik7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiBfQXN0VG9JclZpc2l0b3I7XG4gIH0oKSk7XG4gIGZ1bmN0aW9uIGZsYXR0ZW5TdGF0ZW1lbnRzKGFyZywgb3V0cHV0KSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICAgICAgYXJnLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7IHJldHVybiBmbGF0dGVuU3RhdGVtZW50cyhlbnRyeSwgb3V0cHV0KTsgfSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgICBvdXRwdXQucHVzaChhcmcpO1xuICAgICAgfVxuICB9XG5cbiAgdmFyIENvbXBpbGVFdmVudExpc3RlbmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIENvbXBpbGVFdmVudExpc3RlbmVyKGNvbXBpbGVFbGVtZW50LCBldmVudFRhcmdldCwgZXZlbnROYW1lLCBldmVudFBoYXNlLCBsaXN0ZW5lckluZGV4KSB7XG4gICAgICAgICAgdGhpcy5jb21waWxlRWxlbWVudCA9IGNvbXBpbGVFbGVtZW50O1xuICAgICAgICAgIHRoaXMuZXZlbnRUYXJnZXQgPSBldmVudFRhcmdldDtcbiAgICAgICAgICB0aGlzLmV2ZW50TmFtZSA9IGV2ZW50TmFtZTtcbiAgICAgICAgICB0aGlzLmV2ZW50UGhhc2UgPSBldmVudFBoYXNlO1xuICAgICAgICAgIHRoaXMuX2hhc0NvbXBvbmVudEhvc3RMaXN0ZW5lciA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuX2FjdGlvblJlc3VsdEV4cHJzID0gW107XG4gICAgICAgICAgdGhpcy5fbWV0aG9kID0gbmV3IENvbXBpbGVNZXRob2QoY29tcGlsZUVsZW1lbnQudmlldyk7XG4gICAgICAgICAgdGhpcy5fbWV0aG9kTmFtZSA9XG4gICAgICAgICAgICAgIFwiX2hhbmRsZV9cIiArIHNhbml0aXplRXZlbnROYW1lKGV2ZW50TmFtZSkgKyBcIl9cIiArIGNvbXBpbGVFbGVtZW50Lm5vZGVJbmRleCArIFwiX1wiICsgbGlzdGVuZXJJbmRleDtcbiAgICAgICAgICB0aGlzLl9ldmVudFBhcmFtID0gbmV3IEZuUGFyYW0oRXZlbnRIYW5kbGVyVmFycy5ldmVudC5uYW1lLCBpbXBvcnRUeXBlKHRoaXMuY29tcGlsZUVsZW1lbnQudmlldy5nZW5Db25maWcucmVuZGVyVHlwZXMucmVuZGVyRXZlbnQpKTtcbiAgICAgIH1cbiAgICAgIENvbXBpbGVFdmVudExpc3RlbmVyLmdldE9yQ3JlYXRlID0gZnVuY3Rpb24gKGNvbXBpbGVFbGVtZW50LCBldmVudFRhcmdldCwgZXZlbnROYW1lLCBldmVudFBoYXNlLCB0YXJnZXRFdmVudExpc3RlbmVycykge1xuICAgICAgICAgIHZhciBsaXN0ZW5lciA9IHRhcmdldEV2ZW50TGlzdGVuZXJzLmZpbmQoZnVuY3Rpb24gKGxpc3RlbmVyKSB7IHJldHVybiBsaXN0ZW5lci5ldmVudFRhcmdldCA9PSBldmVudFRhcmdldCAmJiBsaXN0ZW5lci5ldmVudE5hbWUgPT0gZXZlbnROYW1lICYmXG4gICAgICAgICAgICAgIGxpc3RlbmVyLmV2ZW50UGhhc2UgPT0gZXZlbnRQaGFzZTsgfSk7XG4gICAgICAgICAgaWYgKCFsaXN0ZW5lcikge1xuICAgICAgICAgICAgICBsaXN0ZW5lciA9IG5ldyBDb21waWxlRXZlbnRMaXN0ZW5lcihjb21waWxlRWxlbWVudCwgZXZlbnRUYXJnZXQsIGV2ZW50TmFtZSwgZXZlbnRQaGFzZSwgdGFyZ2V0RXZlbnRMaXN0ZW5lcnMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgdGFyZ2V0RXZlbnRMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBsaXN0ZW5lcjtcbiAgICAgIH07XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcGlsZUV2ZW50TGlzdGVuZXIucHJvdG90eXBlLCBcIm1ldGhvZE5hbWVcIiwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbWV0aG9kTmFtZTsgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcGlsZUV2ZW50TGlzdGVuZXIucHJvdG90eXBlLCBcImlzQW5pbWF0aW9uXCIsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICEhdGhpcy5ldmVudFBoYXNlOyB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIENvbXBpbGVFdmVudExpc3RlbmVyLnByb3RvdHlwZS5hZGRBY3Rpb24gPSBmdW5jdGlvbiAoaG9zdEV2ZW50LCBkaXJlY3RpdmUsIGRpcmVjdGl2ZUluc3RhbmNlKSB7XG4gICAgICAgICAgaWYgKGlzUHJlc2VudChkaXJlY3RpdmUpICYmIGRpcmVjdGl2ZS5pc0NvbXBvbmVudCkge1xuICAgICAgICAgICAgICB0aGlzLl9oYXNDb21wb25lbnRIb3N0TGlzdGVuZXIgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9tZXRob2QucmVzZXREZWJ1Z0luZm8odGhpcy5jb21waWxlRWxlbWVudC5ub2RlSW5kZXgsIGhvc3RFdmVudCk7XG4gICAgICAgICAgdmFyIGNvbnRleHQgPSBkaXJlY3RpdmVJbnN0YW5jZSB8fCB0aGlzLmNvbXBpbGVFbGVtZW50LnZpZXcuY29tcG9uZW50Q29udGV4dDtcbiAgICAgICAgICB2YXIgYWN0aW9uU3RtdHMgPSBjb252ZXJ0Q2RTdGF0ZW1lbnRUb0lyKHRoaXMuY29tcGlsZUVsZW1lbnQudmlldywgY29udGV4dCwgaG9zdEV2ZW50LmhhbmRsZXIsIHRoaXMuY29tcGlsZUVsZW1lbnQubm9kZUluZGV4KTtcbiAgICAgICAgICB2YXIgbGFzdEluZGV4ID0gYWN0aW9uU3RtdHMubGVuZ3RoIC0gMTtcbiAgICAgICAgICBpZiAobGFzdEluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgdmFyIGxhc3RTdGF0ZW1lbnQgPSBhY3Rpb25TdG10c1tsYXN0SW5kZXhdO1xuICAgICAgICAgICAgICB2YXIgcmV0dXJuRXhwciA9IGNvbnZlcnRTdG10SW50b0V4cHJlc3Npb24obGFzdFN0YXRlbWVudCk7XG4gICAgICAgICAgICAgIHZhciBwcmV2ZW50RGVmYXVsdFZhciA9IHZhcmlhYmxlKFwicGRfXCIgKyB0aGlzLl9hY3Rpb25SZXN1bHRFeHBycy5sZW5ndGgpO1xuICAgICAgICAgICAgICB0aGlzLl9hY3Rpb25SZXN1bHRFeHBycy5wdXNoKHByZXZlbnREZWZhdWx0VmFyKTtcbiAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudChyZXR1cm5FeHByKSkge1xuICAgICAgICAgICAgICAgICAgLy8gTm90ZTogV2UgbmVlZCB0byBjYXN0IHRoZSByZXN1bHQgb2YgdGhlIG1ldGhvZCBjYWxsIHRvIGR5bmFtaWMsXG4gICAgICAgICAgICAgICAgICAvLyBhcyBpdCBtaWdodCBiZSBhIHZvaWQgbWV0aG9kIVxuICAgICAgICAgICAgICAgICAgYWN0aW9uU3RtdHNbbGFzdEluZGV4XSA9XG4gICAgICAgICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHRWYXIuc2V0KHJldHVybkV4cHIuY2FzdChEWU5BTUlDX1RZUEUpLm5vdElkZW50aWNhbChsaXRlcmFsKGZhbHNlKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC50b0RlY2xTdG10KG51bGwsIFtTdG10TW9kaWZpZXIuRmluYWxdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9tZXRob2QuYWRkU3RtdHMoYWN0aW9uU3RtdHMpO1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVFdmVudExpc3RlbmVyLnByb3RvdHlwZS5maW5pc2hNZXRob2QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIG1hcmtQYXRoVG9Sb290U3RhcnQgPSB0aGlzLl9oYXNDb21wb25lbnRIb3N0TGlzdGVuZXIgP1xuICAgICAgICAgICAgICB0aGlzLmNvbXBpbGVFbGVtZW50LmFwcEVsZW1lbnQucHJvcCgnY29tcG9uZW50VmlldycpIDpcbiAgICAgICAgICAgICAgVEhJU19FWFBSO1xuICAgICAgICAgIHZhciByZXN1bHRFeHByID0gbGl0ZXJhbCh0cnVlKTtcbiAgICAgICAgICB0aGlzLl9hY3Rpb25SZXN1bHRFeHBycy5mb3JFYWNoKGZ1bmN0aW9uIChleHByKSB7IHJlc3VsdEV4cHIgPSByZXN1bHRFeHByLmFuZChleHByKTsgfSk7XG4gICAgICAgICAgdmFyIHN0bXRzID0gW21hcmtQYXRoVG9Sb290U3RhcnQuY2FsbE1ldGhvZCgnbWFya1BhdGhUb1Jvb3RBc0NoZWNrT25jZScsIFtdKS50b1N0bXQoKV1cbiAgICAgICAgICAgICAgLmNvbmNhdCh0aGlzLl9tZXRob2QuZmluaXNoKCkpXG4gICAgICAgICAgICAgIC5jb25jYXQoW25ldyBSZXR1cm5TdGF0ZW1lbnQocmVzdWx0RXhwcildKTtcbiAgICAgICAgICAvLyBwcml2YXRlIGlzIGZpbmUgaGVyZSBhcyBubyBjaGlsZCB2aWV3IHdpbGwgcmVmZXJlbmNlIHRoZSBldmVudCBoYW5kbGVyLi4uXG4gICAgICAgICAgdGhpcy5jb21waWxlRWxlbWVudC52aWV3LmV2ZW50SGFuZGxlck1ldGhvZHMucHVzaChuZXcgQ2xhc3NNZXRob2QodGhpcy5fbWV0aG9kTmFtZSwgW3RoaXMuX2V2ZW50UGFyYW1dLCBzdG10cywgQk9PTF9UWVBFLCBbU3RtdE1vZGlmaWVyLlByaXZhdGVdKSk7XG4gICAgICB9O1xuICAgICAgQ29tcGlsZUV2ZW50TGlzdGVuZXIucHJvdG90eXBlLmxpc3RlblRvUmVuZGVyZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGxpc3RlbkV4cHI7XG4gICAgICAgICAgdmFyIGV2ZW50TGlzdGVuZXIgPSBUSElTX0VYUFIuY2FsbE1ldGhvZCgnZXZlbnRIYW5kbGVyJywgW1RISVNfRVhQUi5wcm9wKHRoaXMuX21ldGhvZE5hbWUpLmNhbGxNZXRob2QoQnVpbHRpbk1ldGhvZC5CaW5kLCBbVEhJU19FWFBSXSldKTtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuZXZlbnRUYXJnZXQpKSB7XG4gICAgICAgICAgICAgIGxpc3RlbkV4cHIgPSBWaWV3UHJvcGVydGllcy5yZW5kZXJlci5jYWxsTWV0aG9kKCdsaXN0ZW5HbG9iYWwnLCBbbGl0ZXJhbCh0aGlzLmV2ZW50VGFyZ2V0KSwgbGl0ZXJhbCh0aGlzLmV2ZW50TmFtZSksIGV2ZW50TGlzdGVuZXJdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGxpc3RlbkV4cHIgPSBWaWV3UHJvcGVydGllcy5yZW5kZXJlci5jYWxsTWV0aG9kKCdsaXN0ZW4nLCBbdGhpcy5jb21waWxlRWxlbWVudC5yZW5kZXJOb2RlLCBsaXRlcmFsKHRoaXMuZXZlbnROYW1lKSwgZXZlbnRMaXN0ZW5lcl0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZGlzcG9zYWJsZSA9IHZhcmlhYmxlKFwiZGlzcG9zYWJsZV9cIiArIHRoaXMuY29tcGlsZUVsZW1lbnQudmlldy5kaXNwb3NhYmxlcy5sZW5ndGgpO1xuICAgICAgICAgIHRoaXMuY29tcGlsZUVsZW1lbnQudmlldy5kaXNwb3NhYmxlcy5wdXNoKGRpc3Bvc2FibGUpO1xuICAgICAgICAgIC8vIHByaXZhdGUgaXMgZmluZSBoZXJlIGFzIG5vIGNoaWxkIHZpZXcgd2lsbCByZWZlcmVuY2UgdGhlIGV2ZW50IGhhbmRsZXIuLi5cbiAgICAgICAgICB0aGlzLmNvbXBpbGVFbGVtZW50LnZpZXcuY3JlYXRlTWV0aG9kLmFkZFN0bXQoZGlzcG9zYWJsZS5zZXQobGlzdGVuRXhwcikudG9EZWNsU3RtdChGVU5DVElPTl9UWVBFLCBbU3RtdE1vZGlmaWVyLlByaXZhdGVdKSk7XG4gICAgICB9O1xuICAgICAgQ29tcGlsZUV2ZW50TGlzdGVuZXIucHJvdG90eXBlLmxpc3RlblRvQW5pbWF0aW9uID0gZnVuY3Rpb24gKGFuaW1hdGlvblRyYW5zaXRpb25WYXIpIHtcbiAgICAgICAgICB2YXIgY2FsbGJhY2tNZXRob2QgPSB0aGlzLmV2ZW50UGhhc2UgPT0gJ3N0YXJ0JyA/ICdvblN0YXJ0JyA6ICdvbkRvbmUnO1xuICAgICAgICAgIHJldHVybiBhbmltYXRpb25UcmFuc2l0aW9uVmFyXG4gICAgICAgICAgICAgIC5jYWxsTWV0aG9kKGNhbGxiYWNrTWV0aG9kLCBbVEhJU19FWFBSLnByb3AodGhpcy5tZXRob2ROYW1lKS5jYWxsTWV0aG9kKEJ1aWx0aW5NZXRob2QuQmluZCwgW1RISVNfRVhQUl0pXSlcbiAgICAgICAgICAgICAgLnRvU3RtdCgpO1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVFdmVudExpc3RlbmVyLnByb3RvdHlwZS5saXN0ZW5Ub0RpcmVjdGl2ZSA9IGZ1bmN0aW9uIChkaXJlY3RpdmVJbnN0YW5jZSwgb2JzZXJ2YWJsZVByb3BOYW1lKSB7XG4gICAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHZhcmlhYmxlKFwic3Vic2NyaXB0aW9uX1wiICsgdGhpcy5jb21waWxlRWxlbWVudC52aWV3LnN1YnNjcmlwdGlvbnMubGVuZ3RoKTtcbiAgICAgICAgICB0aGlzLmNvbXBpbGVFbGVtZW50LnZpZXcuc3Vic2NyaXB0aW9ucy5wdXNoKHN1YnNjcmlwdGlvbik7XG4gICAgICAgICAgdmFyIGV2ZW50TGlzdGVuZXIgPSBUSElTX0VYUFIuY2FsbE1ldGhvZCgnZXZlbnRIYW5kbGVyJywgW1RISVNfRVhQUi5wcm9wKHRoaXMuX21ldGhvZE5hbWUpLmNhbGxNZXRob2QoQnVpbHRpbk1ldGhvZC5CaW5kLCBbVEhJU19FWFBSXSldKTtcbiAgICAgICAgICB0aGlzLmNvbXBpbGVFbGVtZW50LnZpZXcuY3JlYXRlTWV0aG9kLmFkZFN0bXQoc3Vic2NyaXB0aW9uXG4gICAgICAgICAgICAgIC5zZXQoZGlyZWN0aXZlSW5zdGFuY2UucHJvcChvYnNlcnZhYmxlUHJvcE5hbWUpXG4gICAgICAgICAgICAgIC5jYWxsTWV0aG9kKEJ1aWx0aW5NZXRob2QuU3Vic2NyaWJlT2JzZXJ2YWJsZSwgW2V2ZW50TGlzdGVuZXJdKSlcbiAgICAgICAgICAgICAgLnRvRGVjbFN0bXQobnVsbCwgW1N0bXRNb2RpZmllci5GaW5hbF0pKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gQ29tcGlsZUV2ZW50TGlzdGVuZXI7XG4gIH0oKSk7XG4gIGZ1bmN0aW9uIGNvbGxlY3RFdmVudExpc3RlbmVycyhob3N0RXZlbnRzLCBkaXJzLCBjb21waWxlRWxlbWVudCkge1xuICAgICAgdmFyIGV2ZW50TGlzdGVuZXJzID0gW107XG4gICAgICBob3N0RXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGhvc3RFdmVudCkge1xuICAgICAgICAgIGNvbXBpbGVFbGVtZW50LnZpZXcuYmluZGluZ3MucHVzaChuZXcgQ29tcGlsZUJpbmRpbmcoY29tcGlsZUVsZW1lbnQsIGhvc3RFdmVudCkpO1xuICAgICAgICAgIHZhciBsaXN0ZW5lciA9IENvbXBpbGVFdmVudExpc3RlbmVyLmdldE9yQ3JlYXRlKGNvbXBpbGVFbGVtZW50LCBob3N0RXZlbnQudGFyZ2V0LCBob3N0RXZlbnQubmFtZSwgaG9zdEV2ZW50LnBoYXNlLCBldmVudExpc3RlbmVycyk7XG4gICAgICAgICAgbGlzdGVuZXIuYWRkQWN0aW9uKGhvc3RFdmVudCwgbnVsbCwgbnVsbCk7XG4gICAgICB9KTtcbiAgICAgIGRpcnMuZm9yRWFjaChmdW5jdGlvbiAoZGlyZWN0aXZlQXN0KSB7XG4gICAgICAgICAgdmFyIGRpcmVjdGl2ZUluc3RhbmNlID0gY29tcGlsZUVsZW1lbnQuaW5zdGFuY2VzLmdldChpZGVudGlmaWVyVG9rZW4oZGlyZWN0aXZlQXN0LmRpcmVjdGl2ZS50eXBlKS5yZWZlcmVuY2UpO1xuICAgICAgICAgIGRpcmVjdGl2ZUFzdC5ob3N0RXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGhvc3RFdmVudCkge1xuICAgICAgICAgICAgICBjb21waWxlRWxlbWVudC52aWV3LmJpbmRpbmdzLnB1c2gobmV3IENvbXBpbGVCaW5kaW5nKGNvbXBpbGVFbGVtZW50LCBob3N0RXZlbnQpKTtcbiAgICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gQ29tcGlsZUV2ZW50TGlzdGVuZXIuZ2V0T3JDcmVhdGUoY29tcGlsZUVsZW1lbnQsIGhvc3RFdmVudC50YXJnZXQsIGhvc3RFdmVudC5uYW1lLCBob3N0RXZlbnQucGhhc2UsIGV2ZW50TGlzdGVuZXJzKTtcbiAgICAgICAgICAgICAgbGlzdGVuZXIuYWRkQWN0aW9uKGhvc3RFdmVudCwgZGlyZWN0aXZlQXN0LmRpcmVjdGl2ZSwgZGlyZWN0aXZlSW5zdGFuY2UpO1xuICAgICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBldmVudExpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikgeyByZXR1cm4gbGlzdGVuZXIuZmluaXNoTWV0aG9kKCk7IH0pO1xuICAgICAgcmV0dXJuIGV2ZW50TGlzdGVuZXJzO1xuICB9XG4gIGZ1bmN0aW9uIGJpbmREaXJlY3RpdmVPdXRwdXRzKGRpcmVjdGl2ZUFzdCwgZGlyZWN0aXZlSW5zdGFuY2UsIGV2ZW50TGlzdGVuZXJzKSB7XG4gICAgICBPYmplY3Qua2V5cyhkaXJlY3RpdmVBc3QuZGlyZWN0aXZlLm91dHB1dHMpLmZvckVhY2goZnVuY3Rpb24gKG9ic2VydmFibGVQcm9wTmFtZSkge1xuICAgICAgICAgIHZhciBldmVudE5hbWUgPSBkaXJlY3RpdmVBc3QuZGlyZWN0aXZlLm91dHB1dHNbb2JzZXJ2YWJsZVByb3BOYW1lXTtcbiAgICAgICAgICBldmVudExpc3RlbmVycy5maWx0ZXIoZnVuY3Rpb24gKGxpc3RlbmVyKSB7IHJldHVybiBsaXN0ZW5lci5ldmVudE5hbWUgPT0gZXZlbnROYW1lOyB9KS5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5Ub0RpcmVjdGl2ZShkaXJlY3RpdmVJbnN0YW5jZSwgb2JzZXJ2YWJsZVByb3BOYW1lKTtcbiAgICAgICAgICB9KTtcbiAgICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGJpbmRSZW5kZXJPdXRwdXRzKGV2ZW50TGlzdGVuZXJzKSB7XG4gICAgICBldmVudExpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICAgIC8vIHRoZSBhbmltYXRpb24gbGlzdGVuZXJzIGFyZSBoYW5kbGVkIHdpdGhpbiBwcm9wZXJ0eV9iaW5kZXIudHMgdG9cbiAgICAgICAgICAvLyBhbGxvdyB0aGVtIHRvIGJlIHBsYWNlZCBuZXh0IHRvIHRoZSBhbmltYXRpb24gZmFjdG9yeSBzdGF0ZW1lbnRzXG4gICAgICAgICAgaWYgKCFsaXN0ZW5lci5pc0FuaW1hdGlvbikge1xuICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5Ub1JlbmRlcmVyKCk7XG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gY29udmVydFN0bXRJbnRvRXhwcmVzc2lvbihzdG10KSB7XG4gICAgICBpZiAoc3RtdCBpbnN0YW5jZW9mIEV4cHJlc3Npb25TdGF0ZW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4gc3RtdC5leHByO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc3RtdCBpbnN0YW5jZW9mIFJldHVyblN0YXRlbWVudCkge1xuICAgICAgICAgIHJldHVybiBzdG10LnZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gc2FuaXRpemVFdmVudE5hbWUobmFtZSkge1xuICAgICAgcmV0dXJuIG5hbWUucmVwbGFjZSgvW15hLXpBLVpfXS9nLCAnXycpO1xuICB9XG5cbiAgdmFyIFNUQVRFX0lTX05FVkVSX0NIRUNLRUQgPSBUSElTX0VYUFIucHJvcCgnbnVtYmVyT2ZDaGVja3MnKS5pZGVudGljYWwobmV3IExpdGVyYWxFeHByKDApKTtcbiAgdmFyIE5PVF9USFJPV19PTl9DSEFOR0VTID0gbm90KERldGVjdENoYW5nZXNWYXJzLnRocm93T25DaGFuZ2UpO1xuICBmdW5jdGlvbiBiaW5kRGlyZWN0aXZlQWZ0ZXJDb250ZW50TGlmZWN5Y2xlQ2FsbGJhY2tzKGRpcmVjdGl2ZU1ldGEsIGRpcmVjdGl2ZUluc3RhbmNlLCBjb21waWxlRWxlbWVudCkge1xuICAgICAgdmFyIHZpZXcgPSBjb21waWxlRWxlbWVudC52aWV3O1xuICAgICAgdmFyIGxpZmVjeWNsZUhvb2tzID0gZGlyZWN0aXZlTWV0YS50eXBlLmxpZmVjeWNsZUhvb2tzO1xuICAgICAgdmFyIGFmdGVyQ29udGVudExpZmVjeWNsZUNhbGxiYWNrc01ldGhvZCA9IHZpZXcuYWZ0ZXJDb250ZW50TGlmZWN5Y2xlQ2FsbGJhY2tzTWV0aG9kO1xuICAgICAgYWZ0ZXJDb250ZW50TGlmZWN5Y2xlQ2FsbGJhY2tzTWV0aG9kLnJlc2V0RGVidWdJbmZvKGNvbXBpbGVFbGVtZW50Lm5vZGVJbmRleCwgY29tcGlsZUVsZW1lbnQuc291cmNlQXN0KTtcbiAgICAgIGlmIChsaWZlY3ljbGVIb29rcy5pbmRleE9mKExpZmVjeWNsZUhvb2tzLkFmdGVyQ29udGVudEluaXQpICE9PSAtMSkge1xuICAgICAgICAgIGFmdGVyQ29udGVudExpZmVjeWNsZUNhbGxiYWNrc01ldGhvZC5hZGRTdG10KG5ldyBJZlN0bXQoU1RBVEVfSVNfTkVWRVJfQ0hFQ0tFRCwgW2RpcmVjdGl2ZUluc3RhbmNlLmNhbGxNZXRob2QoJ25nQWZ0ZXJDb250ZW50SW5pdCcsIFtdKS50b1N0bXQoKV0pKTtcbiAgICAgIH1cbiAgICAgIGlmIChsaWZlY3ljbGVIb29rcy5pbmRleE9mKExpZmVjeWNsZUhvb2tzLkFmdGVyQ29udGVudENoZWNrZWQpICE9PSAtMSkge1xuICAgICAgICAgIGFmdGVyQ29udGVudExpZmVjeWNsZUNhbGxiYWNrc01ldGhvZC5hZGRTdG10KGRpcmVjdGl2ZUluc3RhbmNlLmNhbGxNZXRob2QoJ25nQWZ0ZXJDb250ZW50Q2hlY2tlZCcsIFtdKS50b1N0bXQoKSk7XG4gICAgICB9XG4gIH1cbiAgZnVuY3Rpb24gYmluZERpcmVjdGl2ZUFmdGVyVmlld0xpZmVjeWNsZUNhbGxiYWNrcyhkaXJlY3RpdmVNZXRhLCBkaXJlY3RpdmVJbnN0YW5jZSwgY29tcGlsZUVsZW1lbnQpIHtcbiAgICAgIHZhciB2aWV3ID0gY29tcGlsZUVsZW1lbnQudmlldztcbiAgICAgIHZhciBsaWZlY3ljbGVIb29rcyA9IGRpcmVjdGl2ZU1ldGEudHlwZS5saWZlY3ljbGVIb29rcztcbiAgICAgIHZhciBhZnRlclZpZXdMaWZlY3ljbGVDYWxsYmFja3NNZXRob2QgPSB2aWV3LmFmdGVyVmlld0xpZmVjeWNsZUNhbGxiYWNrc01ldGhvZDtcbiAgICAgIGFmdGVyVmlld0xpZmVjeWNsZUNhbGxiYWNrc01ldGhvZC5yZXNldERlYnVnSW5mbyhjb21waWxlRWxlbWVudC5ub2RlSW5kZXgsIGNvbXBpbGVFbGVtZW50LnNvdXJjZUFzdCk7XG4gICAgICBpZiAobGlmZWN5Y2xlSG9va3MuaW5kZXhPZihMaWZlY3ljbGVIb29rcy5BZnRlclZpZXdJbml0KSAhPT0gLTEpIHtcbiAgICAgICAgICBhZnRlclZpZXdMaWZlY3ljbGVDYWxsYmFja3NNZXRob2QuYWRkU3RtdChuZXcgSWZTdG10KFNUQVRFX0lTX05FVkVSX0NIRUNLRUQsIFtkaXJlY3RpdmVJbnN0YW5jZS5jYWxsTWV0aG9kKCduZ0FmdGVyVmlld0luaXQnLCBbXSkudG9TdG10KCldKSk7XG4gICAgICB9XG4gICAgICBpZiAobGlmZWN5Y2xlSG9va3MuaW5kZXhPZihMaWZlY3ljbGVIb29rcy5BZnRlclZpZXdDaGVja2VkKSAhPT0gLTEpIHtcbiAgICAgICAgICBhZnRlclZpZXdMaWZlY3ljbGVDYWxsYmFja3NNZXRob2QuYWRkU3RtdChkaXJlY3RpdmVJbnN0YW5jZS5jYWxsTWV0aG9kKCduZ0FmdGVyVmlld0NoZWNrZWQnLCBbXSkudG9TdG10KCkpO1xuICAgICAgfVxuICB9XG4gIGZ1bmN0aW9uIGJpbmRJbmplY3RhYmxlRGVzdHJveUxpZmVjeWNsZUNhbGxiYWNrcyhwcm92aWRlciwgcHJvdmlkZXJJbnN0YW5jZSwgY29tcGlsZUVsZW1lbnQpIHtcbiAgICAgIHZhciBvbkRlc3Ryb3lNZXRob2QgPSBjb21waWxlRWxlbWVudC52aWV3LmRlc3Ryb3lNZXRob2Q7XG4gICAgICBvbkRlc3Ryb3lNZXRob2QucmVzZXREZWJ1Z0luZm8oY29tcGlsZUVsZW1lbnQubm9kZUluZGV4LCBjb21waWxlRWxlbWVudC5zb3VyY2VBc3QpO1xuICAgICAgaWYgKHByb3ZpZGVyLmxpZmVjeWNsZUhvb2tzLmluZGV4T2YoTGlmZWN5Y2xlSG9va3MuT25EZXN0cm95KSAhPT0gLTEpIHtcbiAgICAgICAgICBvbkRlc3Ryb3lNZXRob2QuYWRkU3RtdChwcm92aWRlckluc3RhbmNlLmNhbGxNZXRob2QoJ25nT25EZXN0cm95JywgW10pLnRvU3RtdCgpKTtcbiAgICAgIH1cbiAgfVxuICBmdW5jdGlvbiBiaW5kUGlwZURlc3Ryb3lMaWZlY3ljbGVDYWxsYmFja3MocGlwZU1ldGEsIHBpcGVJbnN0YW5jZSwgdmlldykge1xuICAgICAgdmFyIG9uRGVzdHJveU1ldGhvZCA9IHZpZXcuZGVzdHJveU1ldGhvZDtcbiAgICAgIGlmIChwaXBlTWV0YS50eXBlLmxpZmVjeWNsZUhvb2tzLmluZGV4T2YoTGlmZWN5Y2xlSG9va3MuT25EZXN0cm95KSAhPT0gLTEpIHtcbiAgICAgICAgICBvbkRlc3Ryb3lNZXRob2QuYWRkU3RtdChwaXBlSW5zdGFuY2UuY2FsbE1ldGhvZCgnbmdPbkRlc3Ryb3knLCBbXSkudG9TdG10KCkpO1xuICAgICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQmluZEZpZWxkRXhwcihleHBySW5kZXgpIHtcbiAgICAgIHJldHVybiBUSElTX0VYUFIucHJvcChcIl9leHByX1wiICsgZXhwckluZGV4KTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVDdXJyVmFsdWVFeHByKGV4cHJJbmRleCkge1xuICAgICAgcmV0dXJuIHZhcmlhYmxlKFwiY3VyclZhbF9cIiArIGV4cHJJbmRleCk7IC8vIGZpeCBzeW50YXggaGlnaGxpZ2h0aW5nOiBgXG4gIH1cbiAgdmFyIEV2YWxSZXN1bHQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gRXZhbFJlc3VsdChmb3JjZVVwZGF0ZSkge1xuICAgICAgICAgIHRoaXMuZm9yY2VVcGRhdGUgPSBmb3JjZVVwZGF0ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBFdmFsUmVzdWx0O1xuICB9KCkpO1xuICBmdW5jdGlvbiBldmFsQ2RBc3QodmlldywgY3VyclZhbEV4cHIsIHBhcnNlZEV4cHJlc3Npb24sIGNvbnRleHQsIG1ldGhvZCwgYmluZGluZ0luZGV4KSB7XG4gICAgICB2YXIgY2hlY2tFeHByZXNzaW9uID0gY29udmVydENkRXhwcmVzc2lvblRvSXIodmlldywgY29udGV4dCwgcGFyc2VkRXhwcmVzc2lvbiwgRGV0ZWN0Q2hhbmdlc1ZhcnMudmFsVW53cmFwcGVyLCBiaW5kaW5nSW5kZXgpO1xuICAgICAgaWYgKCFjaGVja0V4cHJlc3Npb24uZXhwcmVzc2lvbikge1xuICAgICAgICAgIC8vIGUuZy4gYW4gZW1wdHkgZXhwcmVzc2lvbiB3YXMgZ2l2ZW5cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChjaGVja0V4cHJlc3Npb24udGVtcG9yYXJ5Q291bnQpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoZWNrRXhwcmVzc2lvbi50ZW1wb3JhcnlDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgIG1ldGhvZC5hZGRTdG10KHRlbXBvcmFyeURlY2xhcmF0aW9uKGJpbmRpbmdJbmRleCwgaSkpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjaGVja0V4cHJlc3Npb24ubmVlZHNWYWx1ZVVud3JhcHBlcikge1xuICAgICAgICAgIHZhciBpbml0VmFsdWVVbndyYXBwZXJTdG10ID0gRGV0ZWN0Q2hhbmdlc1ZhcnMudmFsVW53cmFwcGVyLmNhbGxNZXRob2QoJ3Jlc2V0JywgW10pLnRvU3RtdCgpO1xuICAgICAgICAgIG1ldGhvZC5hZGRTdG10KGluaXRWYWx1ZVVud3JhcHBlclN0bXQpO1xuICAgICAgfVxuICAgICAgbWV0aG9kLmFkZFN0bXQoY3VyclZhbEV4cHIuc2V0KGNoZWNrRXhwcmVzc2lvbi5leHByZXNzaW9uKS50b0RlY2xTdG10KG51bGwsIFtTdG10TW9kaWZpZXIuRmluYWxdKSk7XG4gICAgICBpZiAoY2hlY2tFeHByZXNzaW9uLm5lZWRzVmFsdWVVbndyYXBwZXIpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEV2YWxSZXN1bHQoRGV0ZWN0Q2hhbmdlc1ZhcnMudmFsVW53cmFwcGVyLnByb3AoJ2hhc1dyYXBwZWRWYWx1ZScpKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBuZXcgRXZhbFJlc3VsdChudWxsKTtcbiAgICAgIH1cbiAgfVxuICBmdW5jdGlvbiBiaW5kKHZpZXcsIGN1cnJWYWxFeHByLCBmaWVsZEV4cHIsIHBhcnNlZEV4cHJlc3Npb24sIGNvbnRleHQsIGFjdGlvbnMsIG1ldGhvZCwgYmluZGluZ0luZGV4KSB7XG4gICAgICB2YXIgZXZhbFJlc3VsdCA9IGV2YWxDZEFzdCh2aWV3LCBjdXJyVmFsRXhwciwgcGFyc2VkRXhwcmVzc2lvbiwgY29udGV4dCwgbWV0aG9kLCBiaW5kaW5nSW5kZXgpO1xuICAgICAgaWYgKCFldmFsUmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gcHJpdmF0ZSBpcyBmaW5lIGhlcmUgYXMgbm8gY2hpbGQgdmlldyB3aWxsIHJlZmVyZW5jZSB0aGUgY2FjaGVkIHZhbHVlLi4uXG4gICAgICB2aWV3LmZpZWxkcy5wdXNoKG5ldyBDbGFzc0ZpZWxkKGZpZWxkRXhwci5uYW1lLCBudWxsLCBbU3RtdE1vZGlmaWVyLlByaXZhdGVdKSk7XG4gICAgICB2aWV3LmNyZWF0ZU1ldGhvZC5hZGRTdG10KFRISVNfRVhQUi5wcm9wKGZpZWxkRXhwci5uYW1lKVxuICAgICAgICAgIC5zZXQoaW1wb3J0RXhwcihyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5VTklOSVRJQUxJWkVEKSkpXG4gICAgICAgICAgLnRvU3RtdCgpKTtcbiAgICAgIHZhciBjb25kaXRpb24gPSBpbXBvcnRFeHByKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLmNoZWNrQmluZGluZykpLmNhbGxGbihbXG4gICAgICAgICAgRGV0ZWN0Q2hhbmdlc1ZhcnMudGhyb3dPbkNoYW5nZSwgZmllbGRFeHByLCBjdXJyVmFsRXhwclxuICAgICAgXSk7XG4gICAgICBpZiAoZXZhbFJlc3VsdC5mb3JjZVVwZGF0ZSkge1xuICAgICAgICAgIGNvbmRpdGlvbiA9IGV2YWxSZXN1bHQuZm9yY2VVcGRhdGUub3IoY29uZGl0aW9uKTtcbiAgICAgIH1cbiAgICAgIG1ldGhvZC5hZGRTdG10KG5ldyBJZlN0bXQoY29uZGl0aW9uLCBhY3Rpb25zLmNvbmNhdChbVEhJU19FWFBSLnByb3AoZmllbGRFeHByLm5hbWUpLnNldChjdXJyVmFsRXhwcikudG9TdG10KCldKSkpO1xuICB9XG4gIGZ1bmN0aW9uIGJpbmRSZW5kZXJUZXh0KGJvdW5kVGV4dCwgY29tcGlsZU5vZGUsIHZpZXcpIHtcbiAgICAgIHZhciBiaW5kaW5nSW5kZXggPSB2aWV3LmJpbmRpbmdzLmxlbmd0aDtcbiAgICAgIHZpZXcuYmluZGluZ3MucHVzaChuZXcgQ29tcGlsZUJpbmRpbmcoY29tcGlsZU5vZGUsIGJvdW5kVGV4dCkpO1xuICAgICAgdmFyIGN1cnJWYWxFeHByID0gY3JlYXRlQ3VyclZhbHVlRXhwcihiaW5kaW5nSW5kZXgpO1xuICAgICAgdmFyIHZhbHVlRmllbGQgPSBjcmVhdGVCaW5kRmllbGRFeHByKGJpbmRpbmdJbmRleCk7XG4gICAgICB2aWV3LmRldGVjdENoYW5nZXNSZW5kZXJQcm9wZXJ0aWVzTWV0aG9kLnJlc2V0RGVidWdJbmZvKGNvbXBpbGVOb2RlLm5vZGVJbmRleCwgYm91bmRUZXh0KTtcbiAgICAgIGJpbmQodmlldywgY3VyclZhbEV4cHIsIHZhbHVlRmllbGQsIGJvdW5kVGV4dC52YWx1ZSwgdmlldy5jb21wb25lbnRDb250ZXh0LCBbVEhJU19FWFBSLnByb3AoJ3JlbmRlcmVyJylcbiAgICAgICAgICAgICAgLmNhbGxNZXRob2QoJ3NldFRleHQnLCBbY29tcGlsZU5vZGUucmVuZGVyTm9kZSwgY3VyclZhbEV4cHJdKVxuICAgICAgICAgICAgICAudG9TdG10KCldLCB2aWV3LmRldGVjdENoYW5nZXNSZW5kZXJQcm9wZXJ0aWVzTWV0aG9kLCBiaW5kaW5nSW5kZXgpO1xuICB9XG4gIGZ1bmN0aW9uIGJpbmRBbmRXcml0ZVRvUmVuZGVyZXIoYm91bmRQcm9wcywgY29udGV4dCwgY29tcGlsZUVsZW1lbnQsIGlzSG9zdFByb3AsIGV2ZW50TGlzdGVuZXJzKSB7XG4gICAgICB2YXIgdmlldyA9IGNvbXBpbGVFbGVtZW50LnZpZXc7XG4gICAgICB2YXIgcmVuZGVyTm9kZSA9IGNvbXBpbGVFbGVtZW50LnJlbmRlck5vZGU7XG4gICAgICBib3VuZFByb3BzLmZvckVhY2goZnVuY3Rpb24gKGJvdW5kUHJvcCkge1xuICAgICAgICAgIHZhciBiaW5kaW5nSW5kZXggPSB2aWV3LmJpbmRpbmdzLmxlbmd0aDtcbiAgICAgICAgICB2aWV3LmJpbmRpbmdzLnB1c2gobmV3IENvbXBpbGVCaW5kaW5nKGNvbXBpbGVFbGVtZW50LCBib3VuZFByb3ApKTtcbiAgICAgICAgICB2aWV3LmRldGVjdENoYW5nZXNSZW5kZXJQcm9wZXJ0aWVzTWV0aG9kLnJlc2V0RGVidWdJbmZvKGNvbXBpbGVFbGVtZW50Lm5vZGVJbmRleCwgYm91bmRQcm9wKTtcbiAgICAgICAgICB2YXIgZmllbGRFeHByID0gY3JlYXRlQmluZEZpZWxkRXhwcihiaW5kaW5nSW5kZXgpO1xuICAgICAgICAgIHZhciBjdXJyVmFsRXhwciA9IGNyZWF0ZUN1cnJWYWx1ZUV4cHIoYmluZGluZ0luZGV4KTtcbiAgICAgICAgICB2YXIgb2xkUmVuZGVyVmFsdWUgPSBzYW5pdGl6ZWRWYWx1ZShib3VuZFByb3AsIGZpZWxkRXhwcik7XG4gICAgICAgICAgdmFyIHJlbmRlclZhbHVlID0gc2FuaXRpemVkVmFsdWUoYm91bmRQcm9wLCBjdXJyVmFsRXhwcik7XG4gICAgICAgICAgdmFyIHVwZGF0ZVN0bXRzID0gW107XG4gICAgICAgICAgdmFyIGNvbXBpbGVNZXRob2QgPSB2aWV3LmRldGVjdENoYW5nZXNSZW5kZXJQcm9wZXJ0aWVzTWV0aG9kO1xuICAgICAgICAgIHN3aXRjaCAoYm91bmRQcm9wLnR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBleHBvcnRzLlByb3BlcnR5QmluZGluZ1R5cGUuUHJvcGVydHk6XG4gICAgICAgICAgICAgICAgICBpZiAodmlldy5nZW5Db25maWcubG9nQmluZGluZ1VwZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVN0bXRzLnB1c2gobG9nQmluZGluZ1VwZGF0ZVN0bXQocmVuZGVyTm9kZSwgYm91bmRQcm9wLm5hbWUsIHJlbmRlclZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB1cGRhdGVTdG10cy5wdXNoKFRISVNfRVhQUi5wcm9wKCdyZW5kZXJlcicpXG4gICAgICAgICAgICAgICAgICAgICAgLmNhbGxNZXRob2QoJ3NldEVsZW1lbnRQcm9wZXJ0eScsIFtyZW5kZXJOb2RlLCBsaXRlcmFsKGJvdW5kUHJvcC5uYW1lKSwgcmVuZGVyVmFsdWVdKVxuICAgICAgICAgICAgICAgICAgICAgIC50b1N0bXQoKSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBleHBvcnRzLlByb3BlcnR5QmluZGluZ1R5cGUuQXR0cmlidXRlOlxuICAgICAgICAgICAgICAgICAgcmVuZGVyVmFsdWUgPVxuICAgICAgICAgICAgICAgICAgICAgIHJlbmRlclZhbHVlLmlzQmxhbmsoKS5jb25kaXRpb25hbChOVUxMX0VYUFIsIHJlbmRlclZhbHVlLmNhbGxNZXRob2QoJ3RvU3RyaW5nJywgW10pKTtcbiAgICAgICAgICAgICAgICAgIHVwZGF0ZVN0bXRzLnB1c2goVEhJU19FWFBSLnByb3AoJ3JlbmRlcmVyJylcbiAgICAgICAgICAgICAgICAgICAgICAuY2FsbE1ldGhvZCgnc2V0RWxlbWVudEF0dHJpYnV0ZScsIFtyZW5kZXJOb2RlLCBsaXRlcmFsKGJvdW5kUHJvcC5uYW1lKSwgcmVuZGVyVmFsdWVdKVxuICAgICAgICAgICAgICAgICAgICAgIC50b1N0bXQoKSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBleHBvcnRzLlByb3BlcnR5QmluZGluZ1R5cGUuQ2xhc3M6XG4gICAgICAgICAgICAgICAgICB1cGRhdGVTdG10cy5wdXNoKFRISVNfRVhQUi5wcm9wKCdyZW5kZXJlcicpXG4gICAgICAgICAgICAgICAgICAgICAgLmNhbGxNZXRob2QoJ3NldEVsZW1lbnRDbGFzcycsIFtyZW5kZXJOb2RlLCBsaXRlcmFsKGJvdW5kUHJvcC5uYW1lKSwgcmVuZGVyVmFsdWVdKVxuICAgICAgICAgICAgICAgICAgICAgIC50b1N0bXQoKSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBleHBvcnRzLlByb3BlcnR5QmluZGluZ1R5cGUuU3R5bGU6XG4gICAgICAgICAgICAgICAgICB2YXIgc3RyVmFsdWUgPSByZW5kZXJWYWx1ZS5jYWxsTWV0aG9kKCd0b1N0cmluZycsIFtdKTtcbiAgICAgICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoYm91bmRQcm9wLnVuaXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgc3RyVmFsdWUgPSBzdHJWYWx1ZS5wbHVzKGxpdGVyYWwoYm91bmRQcm9wLnVuaXQpKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJlbmRlclZhbHVlID0gcmVuZGVyVmFsdWUuaXNCbGFuaygpLmNvbmRpdGlvbmFsKE5VTExfRVhQUiwgc3RyVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgdXBkYXRlU3RtdHMucHVzaChUSElTX0VYUFIucHJvcCgncmVuZGVyZXInKVxuICAgICAgICAgICAgICAgICAgICAgIC5jYWxsTWV0aG9kKCdzZXRFbGVtZW50U3R5bGUnLCBbcmVuZGVyTm9kZSwgbGl0ZXJhbChib3VuZFByb3AubmFtZSksIHJlbmRlclZhbHVlXSlcbiAgICAgICAgICAgICAgICAgICAgICAudG9TdG10KCkpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5Qcm9wZXJ0eUJpbmRpbmdUeXBlLkFuaW1hdGlvbjpcbiAgICAgICAgICAgICAgICAgIGNvbXBpbGVNZXRob2QgPSB2aWV3LmFuaW1hdGlvbkJpbmRpbmdzTWV0aG9kO1xuICAgICAgICAgICAgICAgICAgdmFyIGRldGFjaFN0bXRzXzEgPSBbXTtcbiAgICAgICAgICAgICAgICAgIHZhciBhbmltYXRpb25OYW1lXzEgPSBib3VuZFByb3AubmFtZTtcbiAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXRWaWV3RXhwciA9IGlzSG9zdFByb3AgPyBjb21waWxlRWxlbWVudC5hcHBFbGVtZW50LnByb3AoJ2NvbXBvbmVudFZpZXcnKSA6IFRISVNfRVhQUjtcbiAgICAgICAgICAgICAgICAgIHZhciBhbmltYXRpb25GbkV4cHIgPSB0YXJnZXRWaWV3RXhwci5wcm9wKCdjb21wb25lbnRUeXBlJykucHJvcCgnYW5pbWF0aW9ucycpLmtleShsaXRlcmFsKGFuaW1hdGlvbk5hbWVfMSkpO1xuICAgICAgICAgICAgICAgICAgLy8gaXQncyBpbXBvcnRhbnQgdG8gbm9ybWFsaXplIHRoZSB2b2lkIHZhbHVlIGFzIGB2b2lkYCBleHBsaWNpdGx5XG4gICAgICAgICAgICAgICAgICAvLyBzbyB0aGF0IHRoZSBzdHlsZXMgZGF0YSBjYW4gYmUgb2J0YWluZWQgZnJvbSB0aGUgc3RyaW5nbWFwXG4gICAgICAgICAgICAgICAgICB2YXIgZW1wdHlTdGF0ZVZhbHVlID0gbGl0ZXJhbChFTVBUWV9BTklNQVRJT05fU1RBVEUpO1xuICAgICAgICAgICAgICAgICAgdmFyIHVuaXRpYWxpemVkVmFsdWUgPSBpbXBvcnRFeHByKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLlVOSU5JVElBTElaRUQpKTtcbiAgICAgICAgICAgICAgICAgIHZhciBhbmltYXRpb25UcmFuc2l0aW9uVmFyXzEgPSB2YXJpYWJsZSgnYW5pbWF0aW9uVHJhbnNpdGlvbl8nICsgYW5pbWF0aW9uTmFtZV8xKTtcbiAgICAgICAgICAgICAgICAgIHVwZGF0ZVN0bXRzLnB1c2goYW5pbWF0aW9uVHJhbnNpdGlvblZhcl8xXG4gICAgICAgICAgICAgICAgICAgICAgLnNldChhbmltYXRpb25GbkV4cHIuY2FsbEZuKFtcbiAgICAgICAgICAgICAgICAgICAgICBUSElTX0VYUFIsIHJlbmRlck5vZGUsIG9sZFJlbmRlclZhbHVlLmVxdWFscyh1bml0aWFsaXplZFZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuY29uZGl0aW9uYWwoZW1wdHlTdGF0ZVZhbHVlLCBvbGRSZW5kZXJWYWx1ZSksXG4gICAgICAgICAgICAgICAgICAgICAgcmVuZGVyVmFsdWUuZXF1YWxzKHVuaXRpYWxpemVkVmFsdWUpLmNvbmRpdGlvbmFsKGVtcHR5U3RhdGVWYWx1ZSwgcmVuZGVyVmFsdWUpXG4gICAgICAgICAgICAgICAgICBdKSlcbiAgICAgICAgICAgICAgICAgICAgICAudG9EZWNsU3RtdCgpKTtcbiAgICAgICAgICAgICAgICAgIGRldGFjaFN0bXRzXzEucHVzaChhbmltYXRpb25UcmFuc2l0aW9uVmFyXzFcbiAgICAgICAgICAgICAgICAgICAgICAuc2V0KGFuaW1hdGlvbkZuRXhwci5jYWxsRm4oW1RISVNfRVhQUiwgcmVuZGVyTm9kZSwgb2xkUmVuZGVyVmFsdWUsIGVtcHR5U3RhdGVWYWx1ZV0pKVxuICAgICAgICAgICAgICAgICAgICAgIC50b0RlY2xTdG10KCkpO1xuICAgICAgICAgICAgICAgICAgZXZlbnRMaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXIuaXNBbmltYXRpb24gJiYgbGlzdGVuZXIuZXZlbnROYW1lID09PSBhbmltYXRpb25OYW1lXzEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFuaW1hdGlvblN0bXQgPSBsaXN0ZW5lci5saXN0ZW5Ub0FuaW1hdGlvbihhbmltYXRpb25UcmFuc2l0aW9uVmFyXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVTdG10cy5wdXNoKGFuaW1hdGlvblN0bXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhY2hTdG10c18xLnB1c2goYW5pbWF0aW9uU3RtdCk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB2aWV3LmRldGFjaE1ldGhvZC5hZGRTdG10cyhkZXRhY2hTdG10c18xKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBiaW5kKHZpZXcsIGN1cnJWYWxFeHByLCBmaWVsZEV4cHIsIGJvdW5kUHJvcC52YWx1ZSwgY29udGV4dCwgdXBkYXRlU3RtdHMsIGNvbXBpbGVNZXRob2QsIHZpZXcuYmluZGluZ3MubGVuZ3RoKTtcbiAgICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHNhbml0aXplZFZhbHVlKGJvdW5kUHJvcCwgcmVuZGVyVmFsdWUpIHtcbiAgICAgIHZhciBlbnVtVmFsdWU7XG4gICAgICBzd2l0Y2ggKGJvdW5kUHJvcC5zZWN1cml0eUNvbnRleHQpIHtcbiAgICAgICAgICBjYXNlIF9hbmd1bGFyX2NvcmUuU2VjdXJpdHlDb250ZXh0Lk5PTkU6XG4gICAgICAgICAgICAgIHJldHVybiByZW5kZXJWYWx1ZTsgLy8gTm8gc2FuaXRpemF0aW9uIG5lZWRlZC5cbiAgICAgICAgICBjYXNlIF9hbmd1bGFyX2NvcmUuU2VjdXJpdHlDb250ZXh0LkhUTUw6XG4gICAgICAgICAgICAgIGVudW1WYWx1ZSA9ICdIVE1MJztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBfYW5ndWxhcl9jb3JlLlNlY3VyaXR5Q29udGV4dC5TVFlMRTpcbiAgICAgICAgICAgICAgZW51bVZhbHVlID0gJ1NUWUxFJztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBfYW5ndWxhcl9jb3JlLlNlY3VyaXR5Q29udGV4dC5TQ1JJUFQ6XG4gICAgICAgICAgICAgIGVudW1WYWx1ZSA9ICdTQ1JJUFQnO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIF9hbmd1bGFyX2NvcmUuU2VjdXJpdHlDb250ZXh0LlVSTDpcbiAgICAgICAgICAgICAgZW51bVZhbHVlID0gJ1VSTCc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgX2FuZ3VsYXJfY29yZS5TZWN1cml0eUNvbnRleHQuUkVTT1VSQ0VfVVJMOlxuICAgICAgICAgICAgICBlbnVtVmFsdWUgPSAnUkVTT1VSQ0VfVVJMJztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW50ZXJuYWwgZXJyb3IsIHVuZXhwZWN0ZWQgU2VjdXJpdHlDb250ZXh0IFwiICsgYm91bmRQcm9wLnNlY3VyaXR5Q29udGV4dCArIFwiLlwiKTtcbiAgICAgIH1cbiAgICAgIHZhciBjdHggPSBWaWV3UHJvcGVydGllcy52aWV3VXRpbHMucHJvcCgnc2FuaXRpemVyJyk7XG4gICAgICB2YXIgYXJncyA9IFtpbXBvcnRFeHByKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLlNlY3VyaXR5Q29udGV4dCkpLnByb3AoZW51bVZhbHVlKSwgcmVuZGVyVmFsdWVdO1xuICAgICAgcmV0dXJuIGN0eC5jYWxsTWV0aG9kKCdzYW5pdGl6ZScsIGFyZ3MpO1xuICB9XG4gIGZ1bmN0aW9uIGJpbmRSZW5kZXJJbnB1dHMoYm91bmRQcm9wcywgY29tcGlsZUVsZW1lbnQsIGV2ZW50TGlzdGVuZXJzKSB7XG4gICAgICBiaW5kQW5kV3JpdGVUb1JlbmRlcmVyKGJvdW5kUHJvcHMsIGNvbXBpbGVFbGVtZW50LnZpZXcuY29tcG9uZW50Q29udGV4dCwgY29tcGlsZUVsZW1lbnQsIGZhbHNlLCBldmVudExpc3RlbmVycyk7XG4gIH1cbiAgZnVuY3Rpb24gYmluZERpcmVjdGl2ZUhvc3RQcm9wcyhkaXJlY3RpdmVBc3QsIGRpcmVjdGl2ZUluc3RhbmNlLCBjb21waWxlRWxlbWVudCwgZXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAgIGJpbmRBbmRXcml0ZVRvUmVuZGVyZXIoZGlyZWN0aXZlQXN0Lmhvc3RQcm9wZXJ0aWVzLCBkaXJlY3RpdmVJbnN0YW5jZSwgY29tcGlsZUVsZW1lbnQsIHRydWUsIGV2ZW50TGlzdGVuZXJzKTtcbiAgfVxuICBmdW5jdGlvbiBiaW5kRGlyZWN0aXZlSW5wdXRzKGRpcmVjdGl2ZUFzdCwgZGlyZWN0aXZlV3JhcHBlckluc3RhbmNlLCBjb21waWxlRWxlbWVudCkge1xuICAgICAgdmFyIHZpZXcgPSBjb21waWxlRWxlbWVudC52aWV3O1xuICAgICAgdmFyIGRldGVjdENoYW5nZXNJbklucHV0c01ldGhvZCA9IHZpZXcuZGV0ZWN0Q2hhbmdlc0luSW5wdXRzTWV0aG9kO1xuICAgICAgZGV0ZWN0Q2hhbmdlc0luSW5wdXRzTWV0aG9kLnJlc2V0RGVidWdJbmZvKGNvbXBpbGVFbGVtZW50Lm5vZGVJbmRleCwgY29tcGlsZUVsZW1lbnQuc291cmNlQXN0KTtcbiAgICAgIGRpcmVjdGl2ZUFzdC5pbnB1dHMuZm9yRWFjaChmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgICB2YXIgYmluZGluZ0luZGV4ID0gdmlldy5iaW5kaW5ncy5sZW5ndGg7XG4gICAgICAgICAgdmlldy5iaW5kaW5ncy5wdXNoKG5ldyBDb21waWxlQmluZGluZyhjb21waWxlRWxlbWVudCwgaW5wdXQpKTtcbiAgICAgICAgICBkZXRlY3RDaGFuZ2VzSW5JbnB1dHNNZXRob2QucmVzZXREZWJ1Z0luZm8oY29tcGlsZUVsZW1lbnQubm9kZUluZGV4LCBpbnB1dCk7XG4gICAgICAgICAgdmFyIGN1cnJWYWxFeHByID0gY3JlYXRlQ3VyclZhbHVlRXhwcihiaW5kaW5nSW5kZXgpO1xuICAgICAgICAgIHZhciBldmFsUmVzdWx0ID0gZXZhbENkQXN0KHZpZXcsIGN1cnJWYWxFeHByLCBpbnB1dC52YWx1ZSwgdmlldy5jb21wb25lbnRDb250ZXh0LCBkZXRlY3RDaGFuZ2VzSW5JbnB1dHNNZXRob2QsIGJpbmRpbmdJbmRleCk7XG4gICAgICAgICAgaWYgKCFldmFsUmVzdWx0KSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGV0ZWN0Q2hhbmdlc0luSW5wdXRzTWV0aG9kLmFkZFN0bXQoZGlyZWN0aXZlV3JhcHBlckluc3RhbmNlXG4gICAgICAgICAgICAgIC5jYWxsTWV0aG9kKFwiY2hlY2tfXCIgKyBpbnB1dC5kaXJlY3RpdmVOYW1lLCBbXG4gICAgICAgICAgICAgIGN1cnJWYWxFeHByLCBEZXRlY3RDaGFuZ2VzVmFycy50aHJvd09uQ2hhbmdlLFxuICAgICAgICAgICAgICBldmFsUmVzdWx0LmZvcmNlVXBkYXRlIHx8IGxpdGVyYWwoZmFsc2UpXG4gICAgICAgICAgXSlcbiAgICAgICAgICAgICAgLnRvU3RtdCgpKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIGlzT25QdXNoQ29tcCA9IGRpcmVjdGl2ZUFzdC5kaXJlY3RpdmUuaXNDb21wb25lbnQgJiZcbiAgICAgICAgICAhaXNEZWZhdWx0Q2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3koZGlyZWN0aXZlQXN0LmRpcmVjdGl2ZS5jaGFuZ2VEZXRlY3Rpb24pO1xuICAgICAgdmFyIGRpcmVjdGl2ZURldGVjdENoYW5nZXNFeHByID0gZGlyZWN0aXZlV3JhcHBlckluc3RhbmNlLmNhbGxNZXRob2QoJ2RldGVjdENoYW5nZXNJbnRlcm5hbCcsIFtUSElTX0VYUFIsIGNvbXBpbGVFbGVtZW50LnJlbmRlck5vZGUsIERldGVjdENoYW5nZXNWYXJzLnRocm93T25DaGFuZ2VdKTtcbiAgICAgIHZhciBkaXJlY3RpdmVEZXRlY3RDaGFuZ2VzU3RtdCA9IGlzT25QdXNoQ29tcCA/XG4gICAgICAgICAgbmV3IElmU3RtdChkaXJlY3RpdmVEZXRlY3RDaGFuZ2VzRXhwciwgW2NvbXBpbGVFbGVtZW50LmFwcEVsZW1lbnQucHJvcCgnY29tcG9uZW50VmlldycpXG4gICAgICAgICAgICAgICAgICAuY2FsbE1ldGhvZCgnbWFya0FzQ2hlY2tPbmNlJywgW10pXG4gICAgICAgICAgICAgICAgICAudG9TdG10KCldKSA6XG4gICAgICAgICAgZGlyZWN0aXZlRGV0ZWN0Q2hhbmdlc0V4cHIudG9TdG10KCk7XG4gICAgICBkZXRlY3RDaGFuZ2VzSW5JbnB1dHNNZXRob2QuYWRkU3RtdChkaXJlY3RpdmVEZXRlY3RDaGFuZ2VzU3RtdCk7XG4gIH1cbiAgZnVuY3Rpb24gbG9nQmluZGluZ1VwZGF0ZVN0bXQocmVuZGVyTm9kZSwgcHJvcE5hbWUsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gaW1wb3J0RXhwcihyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5zZXRCaW5kaW5nRGVidWdJbmZvKSlcbiAgICAgICAgICAuY2FsbEZuKFtUSElTX0VYUFIucHJvcCgncmVuZGVyZXInKSwgcmVuZGVyTm9kZSwgbGl0ZXJhbChwcm9wTmFtZSksIHZhbHVlXSlcbiAgICAgICAgICAudG9TdG10KCk7XG4gIH1cblxuICBmdW5jdGlvbiBiaW5kVmlldyh2aWV3LCBwYXJzZWRUZW1wbGF0ZSkge1xuICAgICAgdmFyIHZpc2l0b3IgPSBuZXcgVmlld0JpbmRlclZpc2l0b3Iodmlldyk7XG4gICAgICB0ZW1wbGF0ZVZpc2l0QWxsKHZpc2l0b3IsIHBhcnNlZFRlbXBsYXRlKTtcbiAgICAgIHZpZXcucGlwZXMuZm9yRWFjaChmdW5jdGlvbiAocGlwZSkgeyBiaW5kUGlwZURlc3Ryb3lMaWZlY3ljbGVDYWxsYmFja3MocGlwZS5tZXRhLCBwaXBlLmluc3RhbmNlLCBwaXBlLnZpZXcpOyB9KTtcbiAgfVxuICB2YXIgVmlld0JpbmRlclZpc2l0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gVmlld0JpbmRlclZpc2l0b3Iodmlldykge1xuICAgICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgICAgdGhpcy5fbm9kZUluZGV4ID0gMDtcbiAgICAgIH1cbiAgICAgIFZpZXdCaW5kZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEJvdW5kVGV4dCA9IGZ1bmN0aW9uIChhc3QsIHBhcmVudCkge1xuICAgICAgICAgIHZhciBub2RlID0gdGhpcy52aWV3Lm5vZGVzW3RoaXMuX25vZGVJbmRleCsrXTtcbiAgICAgICAgICBiaW5kUmVuZGVyVGV4dChhc3QsIG5vZGUsIHRoaXMudmlldyk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgVmlld0JpbmRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uIChhc3QsIHBhcmVudCkge1xuICAgICAgICAgIHRoaXMuX25vZGVJbmRleCsrO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIFZpZXdCaW5kZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdE5nQ29udGVudCA9IGZ1bmN0aW9uIChhc3QsIHBhcmVudCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICAgIFZpZXdCaW5kZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEVsZW1lbnQgPSBmdW5jdGlvbiAoYXN0LCBwYXJlbnQpIHtcbiAgICAgICAgICB2YXIgY29tcGlsZUVsZW1lbnQgPSB0aGlzLnZpZXcubm9kZXNbdGhpcy5fbm9kZUluZGV4KytdO1xuICAgICAgICAgIHZhciBldmVudExpc3RlbmVycyA9IFtdO1xuICAgICAgICAgIGNvbGxlY3RFdmVudExpc3RlbmVycyhhc3Qub3V0cHV0cywgYXN0LmRpcmVjdGl2ZXMsIGNvbXBpbGVFbGVtZW50KS5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgICAgICBldmVudExpc3RlbmVycy5wdXNoKGVudHJ5KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBiaW5kUmVuZGVySW5wdXRzKGFzdC5pbnB1dHMsIGNvbXBpbGVFbGVtZW50LCBldmVudExpc3RlbmVycyk7XG4gICAgICAgICAgYmluZFJlbmRlck91dHB1dHMoZXZlbnRMaXN0ZW5lcnMpO1xuICAgICAgICAgIGFzdC5kaXJlY3RpdmVzLmZvckVhY2goZnVuY3Rpb24gKGRpcmVjdGl2ZUFzdCkge1xuICAgICAgICAgICAgICB2YXIgZGlyZWN0aXZlSW5zdGFuY2UgPSBjb21waWxlRWxlbWVudC5pbnN0YW5jZXMuZ2V0KGRpcmVjdGl2ZUFzdC5kaXJlY3RpdmUudHlwZS5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgICB2YXIgZGlyZWN0aXZlV3JhcHBlckluc3RhbmNlID0gY29tcGlsZUVsZW1lbnQuZGlyZWN0aXZlV3JhcHBlckluc3RhbmNlLmdldChkaXJlY3RpdmVBc3QuZGlyZWN0aXZlLnR5cGUucmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgYmluZERpcmVjdGl2ZUlucHV0cyhkaXJlY3RpdmVBc3QsIGRpcmVjdGl2ZVdyYXBwZXJJbnN0YW5jZSwgY29tcGlsZUVsZW1lbnQpO1xuICAgICAgICAgICAgICBiaW5kRGlyZWN0aXZlSG9zdFByb3BzKGRpcmVjdGl2ZUFzdCwgZGlyZWN0aXZlSW5zdGFuY2UsIGNvbXBpbGVFbGVtZW50LCBldmVudExpc3RlbmVycyk7XG4gICAgICAgICAgICAgIGJpbmREaXJlY3RpdmVPdXRwdXRzKGRpcmVjdGl2ZUFzdCwgZGlyZWN0aXZlSW5zdGFuY2UsIGV2ZW50TGlzdGVuZXJzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0ZW1wbGF0ZVZpc2l0QWxsKHRoaXMsIGFzdC5jaGlsZHJlbiwgY29tcGlsZUVsZW1lbnQpO1xuICAgICAgICAgIC8vIGFmdGVyQ29udGVudCBhbmQgYWZ0ZXJWaWV3IGxpZmVjeWNsZXMgbmVlZCB0byBiZSBjYWxsZWQgYm90dG9tIHVwXG4gICAgICAgICAgLy8gc28gdGhhdCBjaGlsZHJlbiBhcmUgbm90aWZpZWQgYmVmb3JlIHBhcmVudHNcbiAgICAgICAgICBhc3QuZGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChkaXJlY3RpdmVBc3QpIHtcbiAgICAgICAgICAgICAgdmFyIGRpcmVjdGl2ZUluc3RhbmNlID0gY29tcGlsZUVsZW1lbnQuaW5zdGFuY2VzLmdldChkaXJlY3RpdmVBc3QuZGlyZWN0aXZlLnR5cGUucmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgYmluZERpcmVjdGl2ZUFmdGVyQ29udGVudExpZmVjeWNsZUNhbGxiYWNrcyhkaXJlY3RpdmVBc3QuZGlyZWN0aXZlLCBkaXJlY3RpdmVJbnN0YW5jZSwgY29tcGlsZUVsZW1lbnQpO1xuICAgICAgICAgICAgICBiaW5kRGlyZWN0aXZlQWZ0ZXJWaWV3TGlmZWN5Y2xlQ2FsbGJhY2tzKGRpcmVjdGl2ZUFzdC5kaXJlY3RpdmUsIGRpcmVjdGl2ZUluc3RhbmNlLCBjb21waWxlRWxlbWVudCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYXN0LnByb3ZpZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChwcm92aWRlckFzdCkge1xuICAgICAgICAgICAgICB2YXIgcHJvdmlkZXJJbnN0YW5jZSA9IGNvbXBpbGVFbGVtZW50Lmluc3RhbmNlcy5nZXQocHJvdmlkZXJBc3QudG9rZW4ucmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgYmluZEluamVjdGFibGVEZXN0cm95TGlmZWN5Y2xlQ2FsbGJhY2tzKHByb3ZpZGVyQXN0LCBwcm92aWRlckluc3RhbmNlLCBjb21waWxlRWxlbWVudCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgVmlld0JpbmRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RW1iZWRkZWRUZW1wbGF0ZSA9IGZ1bmN0aW9uIChhc3QsIHBhcmVudCkge1xuICAgICAgICAgIHZhciBjb21waWxlRWxlbWVudCA9IHRoaXMudmlldy5ub2Rlc1t0aGlzLl9ub2RlSW5kZXgrK107XG4gICAgICAgICAgdmFyIGV2ZW50TGlzdGVuZXJzID0gY29sbGVjdEV2ZW50TGlzdGVuZXJzKGFzdC5vdXRwdXRzLCBhc3QuZGlyZWN0aXZlcywgY29tcGlsZUVsZW1lbnQpO1xuICAgICAgICAgIGFzdC5kaXJlY3RpdmVzLmZvckVhY2goZnVuY3Rpb24gKGRpcmVjdGl2ZUFzdCkge1xuICAgICAgICAgICAgICB2YXIgZGlyZWN0aXZlSW5zdGFuY2UgPSBjb21waWxlRWxlbWVudC5pbnN0YW5jZXMuZ2V0KGRpcmVjdGl2ZUFzdC5kaXJlY3RpdmUudHlwZS5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgICB2YXIgZGlyZWN0aXZlV3JhcHBlckluc3RhbmNlID0gY29tcGlsZUVsZW1lbnQuZGlyZWN0aXZlV3JhcHBlckluc3RhbmNlLmdldChkaXJlY3RpdmVBc3QuZGlyZWN0aXZlLnR5cGUucmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgYmluZERpcmVjdGl2ZUlucHV0cyhkaXJlY3RpdmVBc3QsIGRpcmVjdGl2ZVdyYXBwZXJJbnN0YW5jZSwgY29tcGlsZUVsZW1lbnQpO1xuICAgICAgICAgICAgICBiaW5kRGlyZWN0aXZlT3V0cHV0cyhkaXJlY3RpdmVBc3QsIGRpcmVjdGl2ZUluc3RhbmNlLCBldmVudExpc3RlbmVycyk7XG4gICAgICAgICAgICAgIGJpbmREaXJlY3RpdmVBZnRlckNvbnRlbnRMaWZlY3ljbGVDYWxsYmFja3MoZGlyZWN0aXZlQXN0LmRpcmVjdGl2ZSwgZGlyZWN0aXZlSW5zdGFuY2UsIGNvbXBpbGVFbGVtZW50KTtcbiAgICAgICAgICAgICAgYmluZERpcmVjdGl2ZUFmdGVyVmlld0xpZmVjeWNsZUNhbGxiYWNrcyhkaXJlY3RpdmVBc3QuZGlyZWN0aXZlLCBkaXJlY3RpdmVJbnN0YW5jZSwgY29tcGlsZUVsZW1lbnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGFzdC5wcm92aWRlcnMuZm9yRWFjaChmdW5jdGlvbiAocHJvdmlkZXJBc3QpIHtcbiAgICAgICAgICAgICAgdmFyIHByb3ZpZGVySW5zdGFuY2UgPSBjb21waWxlRWxlbWVudC5pbnN0YW5jZXMuZ2V0KHByb3ZpZGVyQXN0LnRva2VuLnJlZmVyZW5jZSk7XG4gICAgICAgICAgICAgIGJpbmRJbmplY3RhYmxlRGVzdHJveUxpZmVjeWNsZUNhbGxiYWNrcyhwcm92aWRlckFzdCwgcHJvdmlkZXJJbnN0YW5jZSwgY29tcGlsZUVsZW1lbnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJpbmRWaWV3KGNvbXBpbGVFbGVtZW50LmVtYmVkZGVkVmlldywgYXN0LmNoaWxkcmVuKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBWaWV3QmluZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRBdHRyID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgVmlld0JpbmRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RGlyZWN0aXZlID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgVmlld0JpbmRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXZlbnQgPSBmdW5jdGlvbiAoYXN0LCBldmVudFRhcmdldEFuZE5hbWVzKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgVmlld0JpbmRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UmVmZXJlbmNlID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgVmlld0JpbmRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0VmFyaWFibGUgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgICBWaWV3QmluZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXREaXJlY3RpdmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgICBWaWV3QmluZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRFbGVtZW50UHJvcGVydHkgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgcmV0dXJuIFZpZXdCaW5kZXJWaXNpdG9yO1xuICB9KCkpO1xuXG4gIHZhciBJTVBMSUNJVF9URU1QTEFURV9WQVIgPSAnXFwkaW1wbGljaXQnO1xuICB2YXIgQ0xBU1NfQVRUUiQxID0gJ2NsYXNzJztcbiAgdmFyIFNUWUxFX0FUVFIgPSAnc3R5bGUnO1xuICB2YXIgTkdfQ09OVEFJTkVSX1RBRyA9ICduZy1jb250YWluZXInO1xuICB2YXIgcGFyZW50UmVuZGVyTm9kZVZhciA9IHZhcmlhYmxlKCdwYXJlbnRSZW5kZXJOb2RlJyk7XG4gIHZhciByb290U2VsZWN0b3JWYXIgPSB2YXJpYWJsZSgncm9vdFNlbGVjdG9yJyk7XG4gIGZ1bmN0aW9uIGJ1aWxkVmlldyh2aWV3LCB0ZW1wbGF0ZSwgdGFyZ2V0RGVwZW5kZW5jaWVzKSB7XG4gICAgICB2YXIgYnVpbGRlclZpc2l0b3IgPSBuZXcgVmlld0J1aWxkZXJWaXNpdG9yKHZpZXcsIHRhcmdldERlcGVuZGVuY2llcyk7XG4gICAgICB0ZW1wbGF0ZVZpc2l0QWxsKGJ1aWxkZXJWaXNpdG9yLCB0ZW1wbGF0ZSwgdmlldy5kZWNsYXJhdGlvbkVsZW1lbnQuaXNOdWxsKCkgPyB2aWV3LmRlY2xhcmF0aW9uRWxlbWVudCA6IHZpZXcuZGVjbGFyYXRpb25FbGVtZW50LnBhcmVudCk7XG4gICAgICByZXR1cm4gYnVpbGRlclZpc2l0b3IubmVzdGVkVmlld0NvdW50O1xuICB9XG4gIGZ1bmN0aW9uIGZpbmlzaFZpZXcodmlldywgdGFyZ2V0U3RhdGVtZW50cykge1xuICAgICAgdmlldy5hZnRlck5vZGVzKCk7XG4gICAgICBjcmVhdGVWaWV3VG9wTGV2ZWxTdG10cyh2aWV3LCB0YXJnZXRTdGF0ZW1lbnRzKTtcbiAgICAgIHZpZXcubm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQ29tcGlsZUVsZW1lbnQgJiYgbm9kZS5oYXNFbWJlZGRlZFZpZXcpIHtcbiAgICAgICAgICAgICAgZmluaXNoVmlldyhub2RlLmVtYmVkZGVkVmlldywgdGFyZ2V0U3RhdGVtZW50cyk7XG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gIH1cbiAgdmFyIFZpZXdCdWlsZGVyVmlzaXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBWaWV3QnVpbGRlclZpc2l0b3IodmlldywgdGFyZ2V0RGVwZW5kZW5jaWVzKSB7XG4gICAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgICB0aGlzLnRhcmdldERlcGVuZGVuY2llcyA9IHRhcmdldERlcGVuZGVuY2llcztcbiAgICAgICAgICB0aGlzLm5lc3RlZFZpZXdDb3VudCA9IDA7XG4gICAgICB9XG4gICAgICBWaWV3QnVpbGRlclZpc2l0b3IucHJvdG90eXBlLl9pc1Jvb3ROb2RlID0gZnVuY3Rpb24gKHBhcmVudCkgeyByZXR1cm4gcGFyZW50LnZpZXcgIT09IHRoaXMudmlldzsgfTtcbiAgICAgIFZpZXdCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUuX2FkZFJvb3ROb2RlQW5kUHJvamVjdCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgdmFyIHByb2plY3RlZE5vZGUgPSBfZ2V0T3V0ZXJDb250YWluZXJPclNlbGYobm9kZSk7XG4gICAgICAgICAgdmFyIHBhcmVudCA9IHByb2plY3RlZE5vZGUucGFyZW50O1xuICAgICAgICAgIHZhciBuZ0NvbnRlbnRJbmRleCA9IHByb2plY3RlZE5vZGUuc291cmNlQXN0Lm5nQ29udGVudEluZGV4O1xuICAgICAgICAgIHZhciB2Y0FwcEVsID0gKG5vZGUgaW5zdGFuY2VvZiBDb21waWxlRWxlbWVudCAmJiBub2RlLmhhc1ZpZXdDb250YWluZXIpID8gbm9kZS5hcHBFbGVtZW50IDogbnVsbDtcbiAgICAgICAgICBpZiAodGhpcy5faXNSb290Tm9kZShwYXJlbnQpKSB7XG4gICAgICAgICAgICAgIC8vIHN0b3JlIGFwcEVsZW1lbnQgYXMgcm9vdCBub2RlIG9ubHkgZm9yIFZpZXdDb250YWluZXJzXG4gICAgICAgICAgICAgIGlmICh0aGlzLnZpZXcudmlld1R5cGUgIT09IFZpZXdUeXBlLkNPTVBPTkVOVCkge1xuICAgICAgICAgICAgICAgICAgdGhpcy52aWV3LnJvb3ROb2Rlc09yQXBwRWxlbWVudHMucHVzaCh2Y0FwcEVsIHx8IG5vZGUucmVuZGVyTm9kZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoaXNQcmVzZW50KHBhcmVudC5jb21wb25lbnQpICYmIGlzUHJlc2VudChuZ0NvbnRlbnRJbmRleCkpIHtcbiAgICAgICAgICAgICAgcGFyZW50LmFkZENvbnRlbnROb2RlKG5nQ29udGVudEluZGV4LCB2Y0FwcEVsIHx8IG5vZGUucmVuZGVyTm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIFZpZXdCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUuX2dldFBhcmVudFJlbmRlck5vZGUgPSBmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgICAgICAgcGFyZW50ID0gX2dldE91dGVyQ29udGFpbmVyUGFyZW50T3JTZWxmKHBhcmVudCk7XG4gICAgICAgICAgaWYgKHRoaXMuX2lzUm9vdE5vZGUocGFyZW50KSkge1xuICAgICAgICAgICAgICBpZiAodGhpcy52aWV3LnZpZXdUeXBlID09PSBWaWV3VHlwZS5DT01QT05FTlQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnRSZW5kZXJOb2RlVmFyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLy8gcm9vdCBub2RlIG9mIGFuIGVtYmVkZGVkL2hvc3Qgdmlld1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIE5VTExfRVhQUjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGlzUHJlc2VudChwYXJlbnQuY29tcG9uZW50KSAmJlxuICAgICAgICAgICAgICAgICAgcGFyZW50LmNvbXBvbmVudC50ZW1wbGF0ZS5lbmNhcHN1bGF0aW9uICE9PSBfYW5ndWxhcl9jb3JlLlZpZXdFbmNhcHN1bGF0aW9uLk5hdGl2ZSA/XG4gICAgICAgICAgICAgICAgICBOVUxMX0VYUFIgOlxuICAgICAgICAgICAgICAgICAgcGFyZW50LnJlbmRlck5vZGU7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIFZpZXdCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRCb3VuZFRleHQgPSBmdW5jdGlvbiAoYXN0LCBwYXJlbnQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fdmlzaXRUZXh0KGFzdCwgJycsIHBhcmVudCk7XG4gICAgICB9O1xuICAgICAgVmlld0J1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAoYXN0LCBwYXJlbnQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fdmlzaXRUZXh0KGFzdCwgYXN0LnZhbHVlLCBwYXJlbnQpO1xuICAgICAgfTtcbiAgICAgIFZpZXdCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUuX3Zpc2l0VGV4dCA9IGZ1bmN0aW9uIChhc3QsIHZhbHVlLCBwYXJlbnQpIHtcbiAgICAgICAgICB2YXIgZmllbGROYW1lID0gXCJfdGV4dF9cIiArIHRoaXMudmlldy5ub2Rlcy5sZW5ndGg7XG4gICAgICAgICAgdGhpcy52aWV3LmZpZWxkcy5wdXNoKG5ldyBDbGFzc0ZpZWxkKGZpZWxkTmFtZSwgaW1wb3J0VHlwZSh0aGlzLnZpZXcuZ2VuQ29uZmlnLnJlbmRlclR5cGVzLnJlbmRlclRleHQpKSk7XG4gICAgICAgICAgdmFyIHJlbmRlck5vZGUgPSBUSElTX0VYUFIucHJvcChmaWVsZE5hbWUpO1xuICAgICAgICAgIHZhciBjb21waWxlTm9kZSA9IG5ldyBDb21waWxlTm9kZShwYXJlbnQsIHRoaXMudmlldywgdGhpcy52aWV3Lm5vZGVzLmxlbmd0aCwgcmVuZGVyTm9kZSwgYXN0KTtcbiAgICAgICAgICB2YXIgY3JlYXRlUmVuZGVyTm9kZSA9IFRISVNfRVhQUi5wcm9wKGZpZWxkTmFtZSlcbiAgICAgICAgICAgICAgLnNldChWaWV3UHJvcGVydGllcy5yZW5kZXJlci5jYWxsTWV0aG9kKCdjcmVhdGVUZXh0JywgW1xuICAgICAgICAgICAgICB0aGlzLl9nZXRQYXJlbnRSZW5kZXJOb2RlKHBhcmVudCksIGxpdGVyYWwodmFsdWUpLFxuICAgICAgICAgICAgICB0aGlzLnZpZXcuY3JlYXRlTWV0aG9kLnJlc2V0RGVidWdJbmZvRXhwcih0aGlzLnZpZXcubm9kZXMubGVuZ3RoLCBhc3QpXG4gICAgICAgICAgXSkpXG4gICAgICAgICAgICAgIC50b1N0bXQoKTtcbiAgICAgICAgICB0aGlzLnZpZXcubm9kZXMucHVzaChjb21waWxlTm9kZSk7XG4gICAgICAgICAgdGhpcy52aWV3LmNyZWF0ZU1ldGhvZC5hZGRTdG10KGNyZWF0ZVJlbmRlck5vZGUpO1xuICAgICAgICAgIHRoaXMuX2FkZFJvb3ROb2RlQW5kUHJvamVjdChjb21waWxlTm9kZSk7XG4gICAgICAgICAgcmV0dXJuIHJlbmRlck5vZGU7XG4gICAgICB9O1xuICAgICAgVmlld0J1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdE5nQ29udGVudCA9IGZ1bmN0aW9uIChhc3QsIHBhcmVudCkge1xuICAgICAgICAgIC8vIHRoZSBwcm9qZWN0ZWQgbm9kZXMgb3JpZ2luYXRlIGZyb20gYSBkaWZmZXJlbnQgdmlldywgc28gd2UgZG9uJ3RcbiAgICAgICAgICAvLyBoYXZlIGRlYnVnIGluZm9ybWF0aW9uIGZvciB0aGVtLi4uXG4gICAgICAgICAgdGhpcy52aWV3LmNyZWF0ZU1ldGhvZC5yZXNldERlYnVnSW5mbyhudWxsLCBhc3QpO1xuICAgICAgICAgIHZhciBwYXJlbnRSZW5kZXJOb2RlID0gdGhpcy5fZ2V0UGFyZW50UmVuZGVyTm9kZShwYXJlbnQpO1xuICAgICAgICAgIHZhciBub2Rlc0V4cHJlc3Npb24gPSBWaWV3UHJvcGVydGllcy5wcm9qZWN0YWJsZU5vZGVzLmtleShsaXRlcmFsKGFzdC5pbmRleCksIG5ldyBBcnJheVR5cGUoaW1wb3J0VHlwZSh0aGlzLnZpZXcuZ2VuQ29uZmlnLnJlbmRlclR5cGVzLnJlbmRlck5vZGUpKSk7XG4gICAgICAgICAgaWYgKHBhcmVudFJlbmRlck5vZGUgIT09IE5VTExfRVhQUikge1xuICAgICAgICAgICAgICB0aGlzLnZpZXcuY3JlYXRlTWV0aG9kLmFkZFN0bXQoVmlld1Byb3BlcnRpZXMucmVuZGVyZXJcbiAgICAgICAgICAgICAgICAgIC5jYWxsTWV0aG9kKCdwcm9qZWN0Tm9kZXMnLCBbXG4gICAgICAgICAgICAgICAgICBwYXJlbnRSZW5kZXJOb2RlLFxuICAgICAgICAgICAgICAgICAgaW1wb3J0RXhwcihyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5mbGF0dGVuTmVzdGVkVmlld1JlbmRlck5vZGVzKSlcbiAgICAgICAgICAgICAgICAgICAgICAuY2FsbEZuKFtub2Rlc0V4cHJlc3Npb25dKVxuICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgLnRvU3RtdCgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAodGhpcy5faXNSb290Tm9kZShwYXJlbnQpKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLnZpZXcudmlld1R5cGUgIT09IFZpZXdUeXBlLkNPTVBPTkVOVCkge1xuICAgICAgICAgICAgICAgICAgLy8gc3RvcmUgcm9vdCBub2RlcyBvbmx5IGZvciBlbWJlZGRlZC9ob3N0IHZpZXdzXG4gICAgICAgICAgICAgICAgICB0aGlzLnZpZXcucm9vdE5vZGVzT3JBcHBFbGVtZW50cy5wdXNoKG5vZGVzRXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQocGFyZW50LmNvbXBvbmVudCkgJiYgaXNQcmVzZW50KGFzdC5uZ0NvbnRlbnRJbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgIHBhcmVudC5hZGRDb250ZW50Tm9kZShhc3QubmdDb250ZW50SW5kZXgsIG5vZGVzRXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgVmlld0J1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEVsZW1lbnQgPSBmdW5jdGlvbiAoYXN0LCBwYXJlbnQpIHtcbiAgICAgICAgICB2YXIgbm9kZUluZGV4ID0gdGhpcy52aWV3Lm5vZGVzLmxlbmd0aDtcbiAgICAgICAgICB2YXIgY3JlYXRlUmVuZGVyTm9kZUV4cHI7XG4gICAgICAgICAgdmFyIGRlYnVnQ29udGV4dEV4cHIgPSB0aGlzLnZpZXcuY3JlYXRlTWV0aG9kLnJlc2V0RGVidWdJbmZvRXhwcihub2RlSW5kZXgsIGFzdCk7XG4gICAgICAgICAgaWYgKG5vZGVJbmRleCA9PT0gMCAmJiB0aGlzLnZpZXcudmlld1R5cGUgPT09IFZpZXdUeXBlLkhPU1QpIHtcbiAgICAgICAgICAgICAgY3JlYXRlUmVuZGVyTm9kZUV4cHIgPSBUSElTX0VYUFIuY2FsbE1ldGhvZCgnc2VsZWN0T3JDcmVhdGVIb3N0RWxlbWVudCcsIFtsaXRlcmFsKGFzdC5uYW1lKSwgcm9vdFNlbGVjdG9yVmFyLCBkZWJ1Z0NvbnRleHRFeHByXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoYXN0Lm5hbWUgPT09IE5HX0NPTlRBSU5FUl9UQUcpIHtcbiAgICAgICAgICAgICAgICAgIGNyZWF0ZVJlbmRlck5vZGVFeHByID0gVmlld1Byb3BlcnRpZXMucmVuZGVyZXIuY2FsbE1ldGhvZCgnY3JlYXRlVGVtcGxhdGVBbmNob3InLCBbdGhpcy5fZ2V0UGFyZW50UmVuZGVyTm9kZShwYXJlbnQpLCBkZWJ1Z0NvbnRleHRFeHByXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICBjcmVhdGVSZW5kZXJOb2RlRXhwciA9IFZpZXdQcm9wZXJ0aWVzLnJlbmRlcmVyLmNhbGxNZXRob2QoJ2NyZWF0ZUVsZW1lbnQnLCBbdGhpcy5fZ2V0UGFyZW50UmVuZGVyTm9kZShwYXJlbnQpLCBsaXRlcmFsKGFzdC5uYW1lKSwgZGVidWdDb250ZXh0RXhwcl0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBmaWVsZE5hbWUgPSBcIl9lbF9cIiArIG5vZGVJbmRleDtcbiAgICAgICAgICB0aGlzLnZpZXcuZmllbGRzLnB1c2gobmV3IENsYXNzRmllbGQoZmllbGROYW1lLCBpbXBvcnRUeXBlKHRoaXMudmlldy5nZW5Db25maWcucmVuZGVyVHlwZXMucmVuZGVyRWxlbWVudCkpKTtcbiAgICAgICAgICB0aGlzLnZpZXcuY3JlYXRlTWV0aG9kLmFkZFN0bXQoVEhJU19FWFBSLnByb3AoZmllbGROYW1lKS5zZXQoY3JlYXRlUmVuZGVyTm9kZUV4cHIpLnRvU3RtdCgpKTtcbiAgICAgICAgICB2YXIgcmVuZGVyTm9kZSA9IFRISVNfRVhQUi5wcm9wKGZpZWxkTmFtZSk7XG4gICAgICAgICAgdmFyIGRpcmVjdGl2ZXMgPSBhc3QuZGlyZWN0aXZlcy5tYXAoZnVuY3Rpb24gKGRpcmVjdGl2ZUFzdCkgeyByZXR1cm4gZGlyZWN0aXZlQXN0LmRpcmVjdGl2ZTsgfSk7XG4gICAgICAgICAgdmFyIGNvbXBvbmVudCA9IGRpcmVjdGl2ZXMuZmluZChmdW5jdGlvbiAoZGlyZWN0aXZlKSB7IHJldHVybiBkaXJlY3RpdmUuaXNDb21wb25lbnQ7IH0pO1xuICAgICAgICAgIHZhciBodG1sQXR0cnMgPSBfcmVhZEh0bWxBdHRycyhhc3QuYXR0cnMpO1xuICAgICAgICAgIHZhciBhdHRyTmFtZUFuZFZhbHVlcyA9IF9tZXJnZUh0bWxBbmREaXJlY3RpdmVBdHRycyhodG1sQXR0cnMsIGRpcmVjdGl2ZXMpO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0ck5hbWVBbmRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIGF0dHJOYW1lID0gYXR0ck5hbWVBbmRWYWx1ZXNbaV1bMF07XG4gICAgICAgICAgICAgIGlmIChhc3QubmFtZSAhPT0gTkdfQ09OVEFJTkVSX1RBRykge1xuICAgICAgICAgICAgICAgICAgLy8gPG5nLWNvbnRhaW5lcj4gYXJlIG5vdCByZW5kZXJlZCBpbiB0aGUgRE9NXG4gICAgICAgICAgICAgICAgICB2YXIgYXR0clZhbHVlID0gYXR0ck5hbWVBbmRWYWx1ZXNbaV1bMV07XG4gICAgICAgICAgICAgICAgICB0aGlzLnZpZXcuY3JlYXRlTWV0aG9kLmFkZFN0bXQoVmlld1Byb3BlcnRpZXMucmVuZGVyZXJcbiAgICAgICAgICAgICAgICAgICAgICAuY2FsbE1ldGhvZCgnc2V0RWxlbWVudEF0dHJpYnV0ZScsIFtyZW5kZXJOb2RlLCBsaXRlcmFsKGF0dHJOYW1lKSwgbGl0ZXJhbChhdHRyVmFsdWUpXSlcbiAgICAgICAgICAgICAgICAgICAgICAudG9TdG10KCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBjb21waWxlRWxlbWVudCA9IG5ldyBDb21waWxlRWxlbWVudChwYXJlbnQsIHRoaXMudmlldywgbm9kZUluZGV4LCByZW5kZXJOb2RlLCBhc3QsIGNvbXBvbmVudCwgZGlyZWN0aXZlcywgYXN0LnByb3ZpZGVycywgYXN0Lmhhc1ZpZXdDb250YWluZXIsIGZhbHNlLCBhc3QucmVmZXJlbmNlcywgdGhpcy50YXJnZXREZXBlbmRlbmNpZXMpO1xuICAgICAgICAgIHRoaXMudmlldy5ub2Rlcy5wdXNoKGNvbXBpbGVFbGVtZW50KTtcbiAgICAgICAgICB2YXIgY29tcFZpZXdFeHByID0gbnVsbDtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KGNvbXBvbmVudCkpIHtcbiAgICAgICAgICAgICAgdmFyIG5lc3RlZENvbXBvbmVudElkZW50aWZpZXIgPSBuZXcgQ29tcGlsZUlkZW50aWZpZXJNZXRhZGF0YSh7IG5hbWU6IGdldFZpZXdGYWN0b3J5TmFtZShjb21wb25lbnQsIDApIH0pO1xuICAgICAgICAgICAgICB0aGlzLnRhcmdldERlcGVuZGVuY2llcy5wdXNoKG5ldyBWaWV3RmFjdG9yeURlcGVuZGVuY3koY29tcG9uZW50LnR5cGUsIG5lc3RlZENvbXBvbmVudElkZW50aWZpZXIpKTtcbiAgICAgICAgICAgICAgY29tcFZpZXdFeHByID0gdmFyaWFibGUoXCJjb21wVmlld19cIiArIG5vZGVJbmRleCk7IC8vIGZpeCBoaWdobGlnaHRpbmc6IGBcbiAgICAgICAgICAgICAgY29tcGlsZUVsZW1lbnQuc2V0Q29tcG9uZW50Vmlldyhjb21wVmlld0V4cHIpO1xuICAgICAgICAgICAgICB0aGlzLnZpZXcuY3JlYXRlTWV0aG9kLmFkZFN0bXQoY29tcFZpZXdFeHByXG4gICAgICAgICAgICAgICAgICAuc2V0KGltcG9ydEV4cHIobmVzdGVkQ29tcG9uZW50SWRlbnRpZmllcikuY2FsbEZuKFtcbiAgICAgICAgICAgICAgICAgIFZpZXdQcm9wZXJ0aWVzLnZpZXdVdGlscywgY29tcGlsZUVsZW1lbnQuaW5qZWN0b3IsIGNvbXBpbGVFbGVtZW50LmFwcEVsZW1lbnRcbiAgICAgICAgICAgICAgXSkpXG4gICAgICAgICAgICAgICAgICAudG9EZWNsU3RtdCgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29tcGlsZUVsZW1lbnQuYmVmb3JlQ2hpbGRyZW4oKTtcbiAgICAgICAgICB0aGlzLl9hZGRSb290Tm9kZUFuZFByb2plY3QoY29tcGlsZUVsZW1lbnQpO1xuICAgICAgICAgIHRlbXBsYXRlVmlzaXRBbGwodGhpcywgYXN0LmNoaWxkcmVuLCBjb21waWxlRWxlbWVudCk7XG4gICAgICAgICAgY29tcGlsZUVsZW1lbnQuYWZ0ZXJDaGlsZHJlbih0aGlzLnZpZXcubm9kZXMubGVuZ3RoIC0gbm9kZUluZGV4IC0gMSk7XG4gICAgICAgICAgaWYgKGlzUHJlc2VudChjb21wVmlld0V4cHIpKSB7XG4gICAgICAgICAgICAgIHZhciBjb2RlR2VuQ29udGVudE5vZGVzO1xuICAgICAgICAgICAgICBpZiAodGhpcy52aWV3LmNvbXBvbmVudC50eXBlLmlzSG9zdCkge1xuICAgICAgICAgICAgICAgICAgY29kZUdlbkNvbnRlbnROb2RlcyA9IFZpZXdQcm9wZXJ0aWVzLnByb2plY3RhYmxlTm9kZXM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICBjb2RlR2VuQ29udGVudE5vZGVzID0gbGl0ZXJhbEFycihjb21waWxlRWxlbWVudC5jb250ZW50Tm9kZXNCeU5nQ29udGVudEluZGV4Lm1hcChmdW5jdGlvbiAobm9kZXMpIHsgcmV0dXJuIGNyZWF0ZUZsYXRBcnJheShub2Rlcyk7IH0pKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLnZpZXcuY3JlYXRlTWV0aG9kLmFkZFN0bXQoY29tcFZpZXdFeHByXG4gICAgICAgICAgICAgICAgICAuY2FsbE1ldGhvZCgnY3JlYXRlJywgW2NvbXBpbGVFbGVtZW50LmdldENvbXBvbmVudCgpLCBjb2RlR2VuQ29udGVudE5vZGVzLCBOVUxMX0VYUFJdKVxuICAgICAgICAgICAgICAgICAgLnRvU3RtdCgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgVmlld0J1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEVtYmVkZGVkVGVtcGxhdGUgPSBmdW5jdGlvbiAoYXN0LCBwYXJlbnQpIHtcbiAgICAgICAgICB2YXIgbm9kZUluZGV4ID0gdGhpcy52aWV3Lm5vZGVzLmxlbmd0aDtcbiAgICAgICAgICB2YXIgZmllbGROYW1lID0gXCJfYW5jaG9yX1wiICsgbm9kZUluZGV4O1xuICAgICAgICAgIHRoaXMudmlldy5maWVsZHMucHVzaChuZXcgQ2xhc3NGaWVsZChmaWVsZE5hbWUsIGltcG9ydFR5cGUodGhpcy52aWV3LmdlbkNvbmZpZy5yZW5kZXJUeXBlcy5yZW5kZXJDb21tZW50KSkpO1xuICAgICAgICAgIHRoaXMudmlldy5jcmVhdGVNZXRob2QuYWRkU3RtdChUSElTX0VYUFIucHJvcChmaWVsZE5hbWUpXG4gICAgICAgICAgICAgIC5zZXQoVmlld1Byb3BlcnRpZXMucmVuZGVyZXIuY2FsbE1ldGhvZCgnY3JlYXRlVGVtcGxhdGVBbmNob3InLCBbXG4gICAgICAgICAgICAgIHRoaXMuX2dldFBhcmVudFJlbmRlck5vZGUocGFyZW50KSxcbiAgICAgICAgICAgICAgdGhpcy52aWV3LmNyZWF0ZU1ldGhvZC5yZXNldERlYnVnSW5mb0V4cHIobm9kZUluZGV4LCBhc3QpXG4gICAgICAgICAgXSkpXG4gICAgICAgICAgICAgIC50b1N0bXQoKSk7XG4gICAgICAgICAgdmFyIHJlbmRlck5vZGUgPSBUSElTX0VYUFIucHJvcChmaWVsZE5hbWUpO1xuICAgICAgICAgIHZhciB0ZW1wbGF0ZVZhcmlhYmxlQmluZGluZ3MgPSBhc3QudmFyaWFibGVzLm1hcChmdW5jdGlvbiAodmFyQXN0KSB7IHJldHVybiBbdmFyQXN0LnZhbHVlLmxlbmd0aCA+IDAgPyB2YXJBc3QudmFsdWUgOiBJTVBMSUNJVF9URU1QTEFURV9WQVIsIHZhckFzdC5uYW1lXTsgfSk7XG4gICAgICAgICAgdmFyIGRpcmVjdGl2ZXMgPSBhc3QuZGlyZWN0aXZlcy5tYXAoZnVuY3Rpb24gKGRpcmVjdGl2ZUFzdCkgeyByZXR1cm4gZGlyZWN0aXZlQXN0LmRpcmVjdGl2ZTsgfSk7XG4gICAgICAgICAgdmFyIGNvbXBpbGVFbGVtZW50ID0gbmV3IENvbXBpbGVFbGVtZW50KHBhcmVudCwgdGhpcy52aWV3LCBub2RlSW5kZXgsIHJlbmRlck5vZGUsIGFzdCwgbnVsbCwgZGlyZWN0aXZlcywgYXN0LnByb3ZpZGVycywgYXN0Lmhhc1ZpZXdDb250YWluZXIsIHRydWUsIGFzdC5yZWZlcmVuY2VzLCB0aGlzLnRhcmdldERlcGVuZGVuY2llcyk7XG4gICAgICAgICAgdGhpcy52aWV3Lm5vZGVzLnB1c2goY29tcGlsZUVsZW1lbnQpO1xuICAgICAgICAgIHRoaXMubmVzdGVkVmlld0NvdW50Kys7XG4gICAgICAgICAgdmFyIGVtYmVkZGVkVmlldyA9IG5ldyBDb21waWxlVmlldyh0aGlzLnZpZXcuY29tcG9uZW50LCB0aGlzLnZpZXcuZ2VuQ29uZmlnLCB0aGlzLnZpZXcucGlwZU1ldGFzLCBOVUxMX0VYUFIsIHRoaXMudmlldy5hbmltYXRpb25zLCB0aGlzLnZpZXcudmlld0luZGV4ICsgdGhpcy5uZXN0ZWRWaWV3Q291bnQsIGNvbXBpbGVFbGVtZW50LCB0ZW1wbGF0ZVZhcmlhYmxlQmluZGluZ3MpO1xuICAgICAgICAgIHRoaXMubmVzdGVkVmlld0NvdW50ICs9IGJ1aWxkVmlldyhlbWJlZGRlZFZpZXcsIGFzdC5jaGlsZHJlbiwgdGhpcy50YXJnZXREZXBlbmRlbmNpZXMpO1xuICAgICAgICAgIGNvbXBpbGVFbGVtZW50LmJlZm9yZUNoaWxkcmVuKCk7XG4gICAgICAgICAgdGhpcy5fYWRkUm9vdE5vZGVBbmRQcm9qZWN0KGNvbXBpbGVFbGVtZW50KTtcbiAgICAgICAgICBjb21waWxlRWxlbWVudC5hZnRlckNoaWxkcmVuKDApO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIFZpZXdCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRBdHRyID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgVmlld0J1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdERpcmVjdGl2ZSA9IGZ1bmN0aW9uIChhc3QsIGN0eCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICAgIFZpZXdCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRFdmVudCA9IGZ1bmN0aW9uIChhc3QsIGV2ZW50VGFyZ2V0QW5kTmFtZXMpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBWaWV3QnVpbGRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UmVmZXJlbmNlID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgVmlld0J1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFZhcmlhYmxlID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgVmlld0J1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdERpcmVjdGl2ZVByb3BlcnR5ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICAgIFZpZXdCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRFbGVtZW50UHJvcGVydHkgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgcmV0dXJuIFZpZXdCdWlsZGVyVmlzaXRvcjtcbiAgfSgpKTtcbiAgLyoqXG4gICAqIFdhbGtzIHVwIHRoZSBub2RlcyB3aGlsZSB0aGUgZGlyZWN0IHBhcmVudCBpcyBhIGNvbnRhaW5lci5cbiAgICpcbiAgICogUmV0dXJucyB0aGUgb3V0ZXIgY29udGFpbmVyIG9yIHRoZSBub2RlIGl0c2VsZiB3aGVuIGl0IGlzIG5vdCBhIGRpcmVjdCBjaGlsZCBvZiBhIGNvbnRhaW5lci5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBmdW5jdGlvbiBfZ2V0T3V0ZXJDb250YWluZXJPclNlbGYobm9kZSkge1xuICAgICAgdmFyIHZpZXcgPSBub2RlLnZpZXc7XG4gICAgICB3aGlsZSAoX2lzTmdDb250YWluZXIobm9kZS5wYXJlbnQsIHZpZXcpKSB7XG4gICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgLyoqXG4gICAqIFdhbGtzIHVwIHRoZSBub2RlcyB3aGlsZSB0aGV5IGFyZSBjb250YWluZXIgYW5kIHJldHVybnMgdGhlIGZpcnN0IHBhcmVudCB3aGljaCBpcyBub3QuXG4gICAqXG4gICAqIFJldHVybnMgdGhlIHBhcmVudCBvZiB0aGUgb3V0ZXIgY29udGFpbmVyIG9yIHRoZSBub2RlIGl0c2VsZiB3aGVuIGl0IGlzIG5vdCBhIGNvbnRhaW5lci5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBmdW5jdGlvbiBfZ2V0T3V0ZXJDb250YWluZXJQYXJlbnRPclNlbGYoZWwpIHtcbiAgICAgIHZhciB2aWV3ID0gZWwudmlldztcbiAgICAgIHdoaWxlIChfaXNOZ0NvbnRhaW5lcihlbCwgdmlldykpIHtcbiAgICAgICAgICBlbCA9IGVsLnBhcmVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbDtcbiAgfVxuICBmdW5jdGlvbiBfaXNOZ0NvbnRhaW5lcihub2RlLCB2aWV3KSB7XG4gICAgICByZXR1cm4gIW5vZGUuaXNOdWxsKCkgJiYgbm9kZS5zb3VyY2VBc3QubmFtZSA9PT0gTkdfQ09OVEFJTkVSX1RBRyAmJlxuICAgICAgICAgIG5vZGUudmlldyA9PT0gdmlldztcbiAgfVxuICBmdW5jdGlvbiBfbWVyZ2VIdG1sQW5kRGlyZWN0aXZlQXR0cnMoZGVjbGFyZWRIdG1sQXR0cnMsIGRpcmVjdGl2ZXMpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIE9iamVjdC5rZXlzKGRlY2xhcmVkSHRtbEF0dHJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgcmVzdWx0W2tleV0gPSBkZWNsYXJlZEh0bWxBdHRyc1trZXldOyB9KTtcbiAgICAgIGRpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlyZWN0aXZlTWV0YSkge1xuICAgICAgICAgIE9iamVjdC5rZXlzKGRpcmVjdGl2ZU1ldGEuaG9zdEF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgdmFyIHZhbHVlID0gZGlyZWN0aXZlTWV0YS5ob3N0QXR0cmlidXRlc1tuYW1lXTtcbiAgICAgICAgICAgICAgdmFyIHByZXZWYWx1ZSA9IHJlc3VsdFtuYW1lXTtcbiAgICAgICAgICAgICAgcmVzdWx0W25hbWVdID0gaXNQcmVzZW50KHByZXZWYWx1ZSkgPyBtZXJnZUF0dHJpYnV0ZVZhbHVlKG5hbWUsIHByZXZWYWx1ZSwgdmFsdWUpIDogdmFsdWU7XG4gICAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBtYXBUb0tleVZhbHVlQXJyYXkocmVzdWx0KTtcbiAgfVxuICBmdW5jdGlvbiBfcmVhZEh0bWxBdHRycyhhdHRycykge1xuICAgICAgdmFyIGh0bWxBdHRycyA9IHt9O1xuICAgICAgYXR0cnMuZm9yRWFjaChmdW5jdGlvbiAoYXN0KSB7IGh0bWxBdHRyc1thc3QubmFtZV0gPSBhc3QudmFsdWU7IH0pO1xuICAgICAgcmV0dXJuIGh0bWxBdHRycztcbiAgfVxuICBmdW5jdGlvbiBtZXJnZUF0dHJpYnV0ZVZhbHVlKGF0dHJOYW1lLCBhdHRyVmFsdWUxLCBhdHRyVmFsdWUyKSB7XG4gICAgICBpZiAoYXR0ck5hbWUgPT0gQ0xBU1NfQVRUUiQxIHx8IGF0dHJOYW1lID09IFNUWUxFX0FUVFIpIHtcbiAgICAgICAgICByZXR1cm4gYXR0clZhbHVlMSArIFwiIFwiICsgYXR0clZhbHVlMjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBhdHRyVmFsdWUyO1xuICAgICAgfVxuICB9XG4gIGZ1bmN0aW9uIG1hcFRvS2V5VmFsdWVBcnJheShkYXRhKSB7XG4gICAgICB2YXIgZW50cnlBcnJheSA9IFtdO1xuICAgICAgT2JqZWN0LmtleXMoZGF0YSkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkgeyBlbnRyeUFycmF5LnB1c2goW25hbWUsIGRhdGFbbmFtZV1dKTsgfSk7XG4gICAgICAvLyBXZSBuZWVkIHRvIHNvcnQgdG8gZ2V0IGEgZGVmaW5lZCBvdXRwdXQgb3JkZXJcbiAgICAgIC8vIGZvciB0ZXN0cyBhbmQgZm9yIGNhY2hpbmcgZ2VuZXJhdGVkIGFydGlmYWN0cy4uLlxuICAgICAgTGlzdFdyYXBwZXIuc29ydChlbnRyeUFycmF5KTtcbiAgICAgIHJldHVybiBlbnRyeUFycmF5O1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZVZpZXdUb3BMZXZlbFN0bXRzKHZpZXcsIHRhcmdldFN0YXRlbWVudHMpIHtcbiAgICAgIHZhciBub2RlRGVidWdJbmZvc1ZhciA9IE5VTExfRVhQUjtcbiAgICAgIGlmICh2aWV3LmdlbkNvbmZpZy5nZW5EZWJ1Z0luZm8pIHtcbiAgICAgICAgICBub2RlRGVidWdJbmZvc1ZhciA9IHZhcmlhYmxlKFwibm9kZURlYnVnSW5mb3NfXCIgKyB2aWV3LmNvbXBvbmVudC50eXBlLm5hbWUgKyB2aWV3LnZpZXdJbmRleCk7IC8vIGZpeCBoaWdobGlnaHRpbmc6IGBcbiAgICAgICAgICB0YXJnZXRTdGF0ZW1lbnRzLnB1c2gobm9kZURlYnVnSW5mb3NWYXJcbiAgICAgICAgICAgICAgLnNldChsaXRlcmFsQXJyKHZpZXcubm9kZXMubWFwKGNyZWF0ZVN0YXRpY05vZGVEZWJ1Z0luZm8pLCBuZXcgQXJyYXlUeXBlKG5ldyBFeHRlcm5hbFR5cGUocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuU3RhdGljTm9kZURlYnVnSW5mbykpLCBbVHlwZU1vZGlmaWVyLkNvbnN0XSkpKVxuICAgICAgICAgICAgICAudG9EZWNsU3RtdChudWxsLCBbU3RtdE1vZGlmaWVyLkZpbmFsXSkpO1xuICAgICAgfVxuICAgICAgdmFyIHJlbmRlckNvbXBUeXBlVmFyID0gdmFyaWFibGUoXCJyZW5kZXJUeXBlX1wiICsgdmlldy5jb21wb25lbnQudHlwZS5uYW1lKTsgLy8gZml4IGhpZ2hsaWdodGluZzogYFxuICAgICAgaWYgKHZpZXcudmlld0luZGV4ID09PSAwKSB7XG4gICAgICAgICAgdGFyZ2V0U3RhdGVtZW50cy5wdXNoKHJlbmRlckNvbXBUeXBlVmFyLnNldChOVUxMX0VYUFIpXG4gICAgICAgICAgICAgIC50b0RlY2xTdG10KGltcG9ydFR5cGUocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuUmVuZGVyQ29tcG9uZW50VHlwZSkpKSk7XG4gICAgICB9XG4gICAgICB2YXIgdmlld0NsYXNzID0gY3JlYXRlVmlld0NsYXNzKHZpZXcsIHJlbmRlckNvbXBUeXBlVmFyLCBub2RlRGVidWdJbmZvc1Zhcik7XG4gICAgICB0YXJnZXRTdGF0ZW1lbnRzLnB1c2godmlld0NsYXNzKTtcbiAgICAgIHRhcmdldFN0YXRlbWVudHMucHVzaChjcmVhdGVWaWV3RmFjdG9yeSh2aWV3LCB2aWV3Q2xhc3MsIHJlbmRlckNvbXBUeXBlVmFyKSk7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlU3RhdGljTm9kZURlYnVnSW5mbyhub2RlKSB7XG4gICAgICB2YXIgY29tcGlsZUVsZW1lbnQgPSBub2RlIGluc3RhbmNlb2YgQ29tcGlsZUVsZW1lbnQgPyBub2RlIDogbnVsbDtcbiAgICAgIHZhciBwcm92aWRlclRva2VucyA9IFtdO1xuICAgICAgdmFyIGNvbXBvbmVudFRva2VuID0gTlVMTF9FWFBSO1xuICAgICAgdmFyIHZhclRva2VuRW50cmllcyA9IFtdO1xuICAgICAgaWYgKGlzUHJlc2VudChjb21waWxlRWxlbWVudCkpIHtcbiAgICAgICAgICBwcm92aWRlclRva2VucyA9IGNvbXBpbGVFbGVtZW50LmdldFByb3ZpZGVyVG9rZW5zKCk7XG4gICAgICAgICAgaWYgKGlzUHJlc2VudChjb21waWxlRWxlbWVudC5jb21wb25lbnQpKSB7XG4gICAgICAgICAgICAgIGNvbXBvbmVudFRva2VuID0gY3JlYXRlRGlUb2tlbkV4cHJlc3Npb24oaWRlbnRpZmllclRva2VuKGNvbXBpbGVFbGVtZW50LmNvbXBvbmVudC50eXBlKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIE9iamVjdC5rZXlzKGNvbXBpbGVFbGVtZW50LnJlZmVyZW5jZVRva2VucykuZm9yRWFjaChmdW5jdGlvbiAodmFyTmFtZSkge1xuICAgICAgICAgICAgICB2YXIgdG9rZW4gPSBjb21waWxlRWxlbWVudC5yZWZlcmVuY2VUb2tlbnNbdmFyTmFtZV07XG4gICAgICAgICAgICAgIHZhclRva2VuRW50cmllcy5wdXNoKFt2YXJOYW1lLCBpc1ByZXNlbnQodG9rZW4pID8gY3JlYXRlRGlUb2tlbkV4cHJlc3Npb24odG9rZW4pIDogTlVMTF9FWFBSXSk7XG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW1wb3J0RXhwcihyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5TdGF0aWNOb2RlRGVidWdJbmZvKSlcbiAgICAgICAgICAuaW5zdGFudGlhdGUoW1xuICAgICAgICAgIGxpdGVyYWxBcnIocHJvdmlkZXJUb2tlbnMsIG5ldyBBcnJheVR5cGUoRFlOQU1JQ19UWVBFLCBbVHlwZU1vZGlmaWVyLkNvbnN0XSkpLFxuICAgICAgICAgIGNvbXBvbmVudFRva2VuLFxuICAgICAgICAgIGxpdGVyYWxNYXAodmFyVG9rZW5FbnRyaWVzLCBuZXcgTWFwVHlwZShEWU5BTUlDX1RZUEUsIFtUeXBlTW9kaWZpZXIuQ29uc3RdKSlcbiAgICAgIF0sIGltcG9ydFR5cGUocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuU3RhdGljTm9kZURlYnVnSW5mbyksIG51bGwsIFtUeXBlTW9kaWZpZXIuQ29uc3RdKSk7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlVmlld0NsYXNzKHZpZXcsIHJlbmRlckNvbXBUeXBlVmFyLCBub2RlRGVidWdJbmZvc1Zhcikge1xuICAgICAgdmFyIHZpZXdDb25zdHJ1Y3RvckFyZ3MgPSBbXG4gICAgICAgICAgbmV3IEZuUGFyYW0oVmlld0NvbnN0cnVjdG9yVmFycy52aWV3VXRpbHMubmFtZSwgaW1wb3J0VHlwZShyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5WaWV3VXRpbHMpKSksXG4gICAgICAgICAgbmV3IEZuUGFyYW0oVmlld0NvbnN0cnVjdG9yVmFycy5wYXJlbnRJbmplY3Rvci5uYW1lLCBpbXBvcnRUeXBlKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLkluamVjdG9yKSkpLFxuICAgICAgICAgIG5ldyBGblBhcmFtKFZpZXdDb25zdHJ1Y3RvclZhcnMuZGVjbGFyYXRpb25FbC5uYW1lLCBpbXBvcnRUeXBlKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLkFwcEVsZW1lbnQpKSlcbiAgICAgIF07XG4gICAgICB2YXIgc3VwZXJDb25zdHJ1Y3RvckFyZ3MgPSBbXG4gICAgICAgICAgdmFyaWFibGUodmlldy5jbGFzc05hbWUpLCByZW5kZXJDb21wVHlwZVZhciwgVmlld1R5cGVFbnVtLmZyb21WYWx1ZSh2aWV3LnZpZXdUeXBlKSxcbiAgICAgICAgICBWaWV3Q29uc3RydWN0b3JWYXJzLnZpZXdVdGlscywgVmlld0NvbnN0cnVjdG9yVmFycy5wYXJlbnRJbmplY3RvcixcbiAgICAgICAgICBWaWV3Q29uc3RydWN0b3JWYXJzLmRlY2xhcmF0aW9uRWwsXG4gICAgICAgICAgQ2hhbmdlRGV0ZWN0b3JTdGF0dXNFbnVtLmZyb21WYWx1ZShnZXRDaGFuZ2VEZXRlY3Rpb25Nb2RlKHZpZXcpKVxuICAgICAgXTtcbiAgICAgIGlmICh2aWV3LmdlbkNvbmZpZy5nZW5EZWJ1Z0luZm8pIHtcbiAgICAgICAgICBzdXBlckNvbnN0cnVjdG9yQXJncy5wdXNoKG5vZGVEZWJ1Z0luZm9zVmFyKTtcbiAgICAgIH1cbiAgICAgIHZhciB2aWV3Q29uc3RydWN0b3IgPSBuZXcgQ2xhc3NNZXRob2QobnVsbCwgdmlld0NvbnN0cnVjdG9yQXJncywgW1NVUEVSX0VYUFIuY2FsbEZuKHN1cGVyQ29uc3RydWN0b3JBcmdzKS50b1N0bXQoKV0pO1xuICAgICAgdmFyIHZpZXdNZXRob2RzID0gW1xuICAgICAgICAgIG5ldyBDbGFzc01ldGhvZCgnY3JlYXRlSW50ZXJuYWwnLCBbbmV3IEZuUGFyYW0ocm9vdFNlbGVjdG9yVmFyLm5hbWUsIFNUUklOR19UWVBFKV0sIGdlbmVyYXRlQ3JlYXRlTWV0aG9kKHZpZXcpLCBpbXBvcnRUeXBlKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLkFwcEVsZW1lbnQpKSksXG4gICAgICAgICAgbmV3IENsYXNzTWV0aG9kKCdpbmplY3RvckdldEludGVybmFsJywgW1xuICAgICAgICAgICAgICBuZXcgRm5QYXJhbShJbmplY3RNZXRob2RWYXJzLnRva2VuLm5hbWUsIERZTkFNSUNfVFlQRSksXG4gICAgICAgICAgICAgIC8vIE5vdGU6IENhbid0IHVzZSBvLklOVF9UWVBFIGhlcmUgYXMgdGhlIG1ldGhvZCBpbiBBcHBWaWV3IHVzZXMgbnVtYmVyXG4gICAgICAgICAgICAgIG5ldyBGblBhcmFtKEluamVjdE1ldGhvZFZhcnMucmVxdWVzdE5vZGVJbmRleC5uYW1lLCBOVU1CRVJfVFlQRSksXG4gICAgICAgICAgICAgIG5ldyBGblBhcmFtKEluamVjdE1ldGhvZFZhcnMubm90Rm91bmRSZXN1bHQubmFtZSwgRFlOQU1JQ19UWVBFKVxuICAgICAgICAgIF0sIGFkZFJldHVyblZhbHVlZk5vdEVtcHR5KHZpZXcuaW5qZWN0b3JHZXRNZXRob2QuZmluaXNoKCksIEluamVjdE1ldGhvZFZhcnMubm90Rm91bmRSZXN1bHQpLCBEWU5BTUlDX1RZUEUpLFxuICAgICAgICAgIG5ldyBDbGFzc01ldGhvZCgnZGV0ZWN0Q2hhbmdlc0ludGVybmFsJywgW25ldyBGblBhcmFtKERldGVjdENoYW5nZXNWYXJzLnRocm93T25DaGFuZ2UubmFtZSwgQk9PTF9UWVBFKV0sIGdlbmVyYXRlRGV0ZWN0Q2hhbmdlc01ldGhvZCh2aWV3KSksXG4gICAgICAgICAgbmV3IENsYXNzTWV0aG9kKCdkaXJ0eVBhcmVudFF1ZXJpZXNJbnRlcm5hbCcsIFtdLCB2aWV3LmRpcnR5UGFyZW50UXVlcmllc01ldGhvZC5maW5pc2goKSksXG4gICAgICAgICAgbmV3IENsYXNzTWV0aG9kKCdkZXN0cm95SW50ZXJuYWwnLCBbXSwgdmlldy5kZXN0cm95TWV0aG9kLmZpbmlzaCgpKSxcbiAgICAgICAgICBuZXcgQ2xhc3NNZXRob2QoJ2RldGFjaEludGVybmFsJywgW10sIHZpZXcuZGV0YWNoTWV0aG9kLmZpbmlzaCgpKVxuICAgICAgXS5jb25jYXQodmlldy5ldmVudEhhbmRsZXJNZXRob2RzKTtcbiAgICAgIHZhciBzdXBlckNsYXNzID0gdmlldy5nZW5Db25maWcuZ2VuRGVidWdJbmZvID8gSWRlbnRpZmllcnMuRGVidWdBcHBWaWV3IDogSWRlbnRpZmllcnMuQXBwVmlldztcbiAgICAgIHZhciB2aWV3Q2xhc3MgPSBuZXcgQ2xhc3NTdG10KHZpZXcuY2xhc3NOYW1lLCBpbXBvcnRFeHByKHJlc29sdmVJZGVudGlmaWVyKHN1cGVyQ2xhc3MpLCBbZ2V0Q29udGV4dFR5cGUodmlldyldKSwgdmlldy5maWVsZHMsIHZpZXcuZ2V0dGVycywgdmlld0NvbnN0cnVjdG9yLCB2aWV3TWV0aG9kcy5maWx0ZXIoZnVuY3Rpb24gKG1ldGhvZCkgeyByZXR1cm4gbWV0aG9kLmJvZHkubGVuZ3RoID4gMDsgfSkpO1xuICAgICAgcmV0dXJuIHZpZXdDbGFzcztcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVWaWV3RmFjdG9yeSh2aWV3LCB2aWV3Q2xhc3MsIHJlbmRlckNvbXBUeXBlVmFyKSB7XG4gICAgICB2YXIgdmlld0ZhY3RvcnlBcmdzID0gW1xuICAgICAgICAgIG5ldyBGblBhcmFtKFZpZXdDb25zdHJ1Y3RvclZhcnMudmlld1V0aWxzLm5hbWUsIGltcG9ydFR5cGUocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuVmlld1V0aWxzKSkpLFxuICAgICAgICAgIG5ldyBGblBhcmFtKFZpZXdDb25zdHJ1Y3RvclZhcnMucGFyZW50SW5qZWN0b3IubmFtZSwgaW1wb3J0VHlwZShyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5JbmplY3RvcikpKSxcbiAgICAgICAgICBuZXcgRm5QYXJhbShWaWV3Q29uc3RydWN0b3JWYXJzLmRlY2xhcmF0aW9uRWwubmFtZSwgaW1wb3J0VHlwZShyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5BcHBFbGVtZW50KSkpXG4gICAgICBdO1xuICAgICAgdmFyIGluaXRSZW5kZXJDb21wVHlwZVN0bXRzID0gW107XG4gICAgICB2YXIgdGVtcGxhdGVVcmxJbmZvO1xuICAgICAgaWYgKHZpZXcuY29tcG9uZW50LnRlbXBsYXRlLnRlbXBsYXRlVXJsID09IHZpZXcuY29tcG9uZW50LnR5cGUubW9kdWxlVXJsKSB7XG4gICAgICAgICAgdGVtcGxhdGVVcmxJbmZvID1cbiAgICAgICAgICAgICAgdmlldy5jb21wb25lbnQudHlwZS5tb2R1bGVVcmwgKyBcIiBjbGFzcyBcIiArIHZpZXcuY29tcG9uZW50LnR5cGUubmFtZSArIFwiIC0gaW5saW5lIHRlbXBsYXRlXCI7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgICB0ZW1wbGF0ZVVybEluZm8gPSB2aWV3LmNvbXBvbmVudC50ZW1wbGF0ZS50ZW1wbGF0ZVVybDtcbiAgICAgIH1cbiAgICAgIGlmICh2aWV3LnZpZXdJbmRleCA9PT0gMCkge1xuICAgICAgICAgIHZhciBhbmltYXRpb25zRXhwciA9IGxpdGVyYWxNYXAodmlldy5hbmltYXRpb25zLm1hcChmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuIFtlbnRyeS5uYW1lLCBlbnRyeS5mbkV4cF07IH0pKTtcbiAgICAgICAgICBpbml0UmVuZGVyQ29tcFR5cGVTdG10cyA9IFtcbiAgICAgICAgICAgICAgbmV3IElmU3RtdChyZW5kZXJDb21wVHlwZVZhci5pZGVudGljYWwoTlVMTF9FWFBSKSwgW1xuICAgICAgICAgICAgICAgICAgcmVuZGVyQ29tcFR5cGVWYXJcbiAgICAgICAgICAgICAgICAgICAgICAuc2V0KFZpZXdDb25zdHJ1Y3RvclZhcnMudmlld1V0aWxzLmNhbGxNZXRob2QoJ2NyZWF0ZVJlbmRlckNvbXBvbmVudFR5cGUnLCBbXG4gICAgICAgICAgICAgICAgICAgICAgdmlldy5nZW5Db25maWcuZ2VuRGVidWdJbmZvID8gbGl0ZXJhbCh0ZW1wbGF0ZVVybEluZm8pIDogbGl0ZXJhbCgnJyksXG4gICAgICAgICAgICAgICAgICAgICAgbGl0ZXJhbCh2aWV3LmNvbXBvbmVudC50ZW1wbGF0ZS5uZ0NvbnRlbnRTZWxlY3RvcnMubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgICAgICBWaWV3RW5jYXBzdWxhdGlvbkVudW0uZnJvbVZhbHVlKHZpZXcuY29tcG9uZW50LnRlbXBsYXRlLmVuY2Fwc3VsYXRpb24pLFxuICAgICAgICAgICAgICAgICAgICAgIHZpZXcuc3R5bGVzLFxuICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbnNFeHByLFxuICAgICAgICAgICAgICAgICAgXSkpXG4gICAgICAgICAgICAgICAgICAgICAgLnRvU3RtdCgpLFxuICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZuKHZpZXdGYWN0b3J5QXJncywgaW5pdFJlbmRlckNvbXBUeXBlU3RtdHMuY29uY2F0KFtcbiAgICAgICAgICBuZXcgUmV0dXJuU3RhdGVtZW50KHZhcmlhYmxlKHZpZXdDbGFzcy5uYW1lKVxuICAgICAgICAgICAgICAuaW5zdGFudGlhdGUodmlld0NsYXNzLmNvbnN0cnVjdG9yTWV0aG9kLnBhcmFtcy5tYXAoZnVuY3Rpb24gKHBhcmFtKSB7IHJldHVybiB2YXJpYWJsZShwYXJhbS5uYW1lKTsgfSkpKSxcbiAgICAgIF0pLCBpbXBvcnRUeXBlKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLkFwcFZpZXcpLCBbZ2V0Q29udGV4dFR5cGUodmlldyldKSlcbiAgICAgICAgICAudG9EZWNsU3RtdCh2aWV3LnZpZXdGYWN0b3J5Lm5hbWUsIFtTdG10TW9kaWZpZXIuRmluYWxdKTtcbiAgfVxuICBmdW5jdGlvbiBnZW5lcmF0ZUNyZWF0ZU1ldGhvZCh2aWV3KSB7XG4gICAgICB2YXIgcGFyZW50UmVuZGVyTm9kZUV4cHIgPSBOVUxMX0VYUFI7XG4gICAgICB2YXIgcGFyZW50UmVuZGVyTm9kZVN0bXRzID0gW107XG4gICAgICBpZiAodmlldy52aWV3VHlwZSA9PT0gVmlld1R5cGUuQ09NUE9ORU5UKSB7XG4gICAgICAgICAgcGFyZW50UmVuZGVyTm9kZUV4cHIgPSBWaWV3UHJvcGVydGllcy5yZW5kZXJlci5jYWxsTWV0aG9kKCdjcmVhdGVWaWV3Um9vdCcsIFtUSElTX0VYUFIucHJvcCgnZGVjbGFyYXRpb25BcHBFbGVtZW50JykucHJvcCgnbmF0aXZlRWxlbWVudCcpXSk7XG4gICAgICAgICAgcGFyZW50UmVuZGVyTm9kZVN0bXRzID1cbiAgICAgICAgICAgICAgW3BhcmVudFJlbmRlck5vZGVWYXIuc2V0KHBhcmVudFJlbmRlck5vZGVFeHByKVxuICAgICAgICAgICAgICAgICAgICAgIC50b0RlY2xTdG10KGltcG9ydFR5cGUodmlldy5nZW5Db25maWcucmVuZGVyVHlwZXMucmVuZGVyTm9kZSksIFtTdG10TW9kaWZpZXIuRmluYWxdKV07XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0RXhwcjtcbiAgICAgIGlmICh2aWV3LnZpZXdUeXBlID09PSBWaWV3VHlwZS5IT1NUKSB7XG4gICAgICAgICAgcmVzdWx0RXhwciA9IHZpZXcubm9kZXNbMF0uYXBwRWxlbWVudDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgIHJlc3VsdEV4cHIgPSBOVUxMX0VYUFI7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyZW50UmVuZGVyTm9kZVN0bXRzLmNvbmNhdCh2aWV3LmNyZWF0ZU1ldGhvZC5maW5pc2goKSwgW1xuICAgICAgICAgIFRISVNfRVhQUlxuICAgICAgICAgICAgICAuY2FsbE1ldGhvZCgnaW5pdCcsIFtcbiAgICAgICAgICAgICAgY3JlYXRlRmxhdEFycmF5KHZpZXcucm9vdE5vZGVzT3JBcHBFbGVtZW50cyksXG4gICAgICAgICAgICAgIGxpdGVyYWxBcnIodmlldy5ub2Rlcy5tYXAoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUucmVuZGVyTm9kZTsgfSkpLCBsaXRlcmFsQXJyKHZpZXcuZGlzcG9zYWJsZXMpLFxuICAgICAgICAgICAgICBsaXRlcmFsQXJyKHZpZXcuc3Vic2NyaXB0aW9ucylcbiAgICAgICAgICBdKVxuICAgICAgICAgICAgICAudG9TdG10KCksXG4gICAgICAgICAgbmV3IFJldHVyblN0YXRlbWVudChyZXN1bHRFeHByKVxuICAgICAgXSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2VuZXJhdGVEZXRlY3RDaGFuZ2VzTWV0aG9kKHZpZXcpIHtcbiAgICAgIHZhciBzdG10cyA9IFtdO1xuICAgICAgaWYgKHZpZXcuYW5pbWF0aW9uQmluZGluZ3NNZXRob2QuaXNFbXB0eSgpICYmIHZpZXcuZGV0ZWN0Q2hhbmdlc0luSW5wdXRzTWV0aG9kLmlzRW1wdHkoKSAmJlxuICAgICAgICAgIHZpZXcudXBkYXRlQ29udGVudFF1ZXJpZXNNZXRob2QuaXNFbXB0eSgpICYmXG4gICAgICAgICAgdmlldy5hZnRlckNvbnRlbnRMaWZlY3ljbGVDYWxsYmFja3NNZXRob2QuaXNFbXB0eSgpICYmXG4gICAgICAgICAgdmlldy5kZXRlY3RDaGFuZ2VzUmVuZGVyUHJvcGVydGllc01ldGhvZC5pc0VtcHR5KCkgJiZcbiAgICAgICAgICB2aWV3LnVwZGF0ZVZpZXdRdWVyaWVzTWV0aG9kLmlzRW1wdHkoKSAmJiB2aWV3LmFmdGVyVmlld0xpZmVjeWNsZUNhbGxiYWNrc01ldGhvZC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICByZXR1cm4gc3RtdHM7XG4gICAgICB9XG4gICAgICBMaXN0V3JhcHBlci5hZGRBbGwoc3RtdHMsIHZpZXcuYW5pbWF0aW9uQmluZGluZ3NNZXRob2QuZmluaXNoKCkpO1xuICAgICAgTGlzdFdyYXBwZXIuYWRkQWxsKHN0bXRzLCB2aWV3LmRldGVjdENoYW5nZXNJbklucHV0c01ldGhvZC5maW5pc2goKSk7XG4gICAgICBzdG10cy5wdXNoKFRISVNfRVhQUi5jYWxsTWV0aG9kKCdkZXRlY3RDb250ZW50Q2hpbGRyZW5DaGFuZ2VzJywgW0RldGVjdENoYW5nZXNWYXJzLnRocm93T25DaGFuZ2VdKVxuICAgICAgICAgIC50b1N0bXQoKSk7XG4gICAgICB2YXIgYWZ0ZXJDb250ZW50U3RtdHMgPSB2aWV3LnVwZGF0ZUNvbnRlbnRRdWVyaWVzTWV0aG9kLmZpbmlzaCgpLmNvbmNhdCh2aWV3LmFmdGVyQ29udGVudExpZmVjeWNsZUNhbGxiYWNrc01ldGhvZC5maW5pc2goKSk7XG4gICAgICBpZiAoYWZ0ZXJDb250ZW50U3RtdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHN0bXRzLnB1c2gobmV3IElmU3RtdChub3QoRGV0ZWN0Q2hhbmdlc1ZhcnMudGhyb3dPbkNoYW5nZSksIGFmdGVyQ29udGVudFN0bXRzKSk7XG4gICAgICB9XG4gICAgICBMaXN0V3JhcHBlci5hZGRBbGwoc3RtdHMsIHZpZXcuZGV0ZWN0Q2hhbmdlc1JlbmRlclByb3BlcnRpZXNNZXRob2QuZmluaXNoKCkpO1xuICAgICAgc3RtdHMucHVzaChUSElTX0VYUFIuY2FsbE1ldGhvZCgnZGV0ZWN0Vmlld0NoaWxkcmVuQ2hhbmdlcycsIFtEZXRlY3RDaGFuZ2VzVmFycy50aHJvd09uQ2hhbmdlXSlcbiAgICAgICAgICAudG9TdG10KCkpO1xuICAgICAgdmFyIGFmdGVyVmlld1N0bXRzID0gdmlldy51cGRhdGVWaWV3UXVlcmllc01ldGhvZC5maW5pc2goKS5jb25jYXQodmlldy5hZnRlclZpZXdMaWZlY3ljbGVDYWxsYmFja3NNZXRob2QuZmluaXNoKCkpO1xuICAgICAgaWYgKGFmdGVyVmlld1N0bXRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBzdG10cy5wdXNoKG5ldyBJZlN0bXQobm90KERldGVjdENoYW5nZXNWYXJzLnRocm93T25DaGFuZ2UpLCBhZnRlclZpZXdTdG10cykpO1xuICAgICAgfVxuICAgICAgdmFyIHZhclN0bXRzID0gW107XG4gICAgICB2YXIgcmVhZFZhcnMgPSBmaW5kUmVhZFZhck5hbWVzKHN0bXRzKTtcbiAgICAgIGlmIChyZWFkVmFycy5oYXMoRGV0ZWN0Q2hhbmdlc1ZhcnMuY2hhbmdlZC5uYW1lKSkge1xuICAgICAgICAgIHZhclN0bXRzLnB1c2goRGV0ZWN0Q2hhbmdlc1ZhcnMuY2hhbmdlZC5zZXQobGl0ZXJhbCh0cnVlKSkudG9EZWNsU3RtdChCT09MX1RZUEUpKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZWFkVmFycy5oYXMoRGV0ZWN0Q2hhbmdlc1ZhcnMuY2hhbmdlcy5uYW1lKSkge1xuICAgICAgICAgIHZhclN0bXRzLnB1c2goRGV0ZWN0Q2hhbmdlc1ZhcnMuY2hhbmdlcy5zZXQoTlVMTF9FWFBSKVxuICAgICAgICAgICAgICAudG9EZWNsU3RtdChuZXcgTWFwVHlwZShpbXBvcnRUeXBlKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLlNpbXBsZUNoYW5nZSkpKSkpO1xuICAgICAgfVxuICAgICAgaWYgKHJlYWRWYXJzLmhhcyhEZXRlY3RDaGFuZ2VzVmFycy52YWxVbndyYXBwZXIubmFtZSkpIHtcbiAgICAgICAgICB2YXJTdG10cy5wdXNoKERldGVjdENoYW5nZXNWYXJzLnZhbFVud3JhcHBlclxuICAgICAgICAgICAgICAuc2V0KGltcG9ydEV4cHIocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuVmFsdWVVbndyYXBwZXIpKS5pbnN0YW50aWF0ZShbXSkpXG4gICAgICAgICAgICAgIC50b0RlY2xTdG10KG51bGwsIFtTdG10TW9kaWZpZXIuRmluYWxdKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFyU3RtdHMuY29uY2F0KHN0bXRzKTtcbiAgfVxuICBmdW5jdGlvbiBhZGRSZXR1cm5WYWx1ZWZOb3RFbXB0eShzdGF0ZW1lbnRzLCB2YWx1ZSkge1xuICAgICAgaWYgKHN0YXRlbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHJldHVybiBzdGF0ZW1lbnRzLmNvbmNhdChbbmV3IFJldHVyblN0YXRlbWVudCh2YWx1ZSldKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBzdGF0ZW1lbnRzO1xuICAgICAgfVxuICB9XG4gIGZ1bmN0aW9uIGdldENvbnRleHRUeXBlKHZpZXcpIHtcbiAgICAgIGlmICh2aWV3LnZpZXdUeXBlID09PSBWaWV3VHlwZS5DT01QT05FTlQpIHtcbiAgICAgICAgICByZXR1cm4gaW1wb3J0VHlwZSh2aWV3LmNvbXBvbmVudC50eXBlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBEWU5BTUlDX1RZUEU7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Q2hhbmdlRGV0ZWN0aW9uTW9kZSh2aWV3KSB7XG4gICAgICB2YXIgbW9kZTtcbiAgICAgIGlmICh2aWV3LnZpZXdUeXBlID09PSBWaWV3VHlwZS5DT01QT05FTlQpIHtcbiAgICAgICAgICBtb2RlID0gaXNEZWZhdWx0Q2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kodmlldy5jb21wb25lbnQuY2hhbmdlRGV0ZWN0aW9uKSA/XG4gICAgICAgICAgICAgIENoYW5nZURldGVjdG9yU3RhdHVzLkNoZWNrQWx3YXlzIDpcbiAgICAgICAgICAgICAgQ2hhbmdlRGV0ZWN0b3JTdGF0dXMuQ2hlY2tPbmNlO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICAgbW9kZSA9IENoYW5nZURldGVjdG9yU3RhdHVzLkNoZWNrQWx3YXlzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1vZGU7XG4gIH1cblxuICB2YXIgVmlld0NvbXBpbGVSZXN1bHQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gVmlld0NvbXBpbGVSZXN1bHQoc3RhdGVtZW50cywgdmlld0ZhY3RvcnlWYXIsIGRlcGVuZGVuY2llcykge1xuICAgICAgICAgIHRoaXMuc3RhdGVtZW50cyA9IHN0YXRlbWVudHM7XG4gICAgICAgICAgdGhpcy52aWV3RmFjdG9yeVZhciA9IHZpZXdGYWN0b3J5VmFyO1xuICAgICAgICAgIHRoaXMuZGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFZpZXdDb21waWxlUmVzdWx0O1xuICB9KCkpO1xuICB2YXIgVmlld0NvbXBpbGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFZpZXdDb21waWxlcihfZ2VuQ29uZmlnKSB7XG4gICAgICAgICAgdGhpcy5fZ2VuQ29uZmlnID0gX2dlbkNvbmZpZztcbiAgICAgIH1cbiAgICAgIFZpZXdDb21waWxlci5wcm90b3R5cGUuY29tcGlsZUNvbXBvbmVudCA9IGZ1bmN0aW9uIChjb21wb25lbnQsIHRlbXBsYXRlLCBzdHlsZXMsIHBpcGVzLCBjb21waWxlZEFuaW1hdGlvbnMpIHtcbiAgICAgICAgICB2YXIgZGVwZW5kZW5jaWVzID0gW107XG4gICAgICAgICAgdmFyIHZpZXcgPSBuZXcgQ29tcGlsZVZpZXcoY29tcG9uZW50LCB0aGlzLl9nZW5Db25maWcsIHBpcGVzLCBzdHlsZXMsIGNvbXBpbGVkQW5pbWF0aW9ucywgMCwgQ29tcGlsZUVsZW1lbnQuY3JlYXRlTnVsbCgpLCBbXSk7XG4gICAgICAgICAgdmFyIHN0YXRlbWVudHMgPSBbXTtcbiAgICAgICAgICBidWlsZFZpZXcodmlldywgdGVtcGxhdGUsIGRlcGVuZGVuY2llcyk7XG4gICAgICAgICAgLy8gTmVlZCB0byBzZXBhcmF0ZSBiaW5kaW5nIGZyb20gY3JlYXRpb24gdG8gYmUgYWJsZSB0byByZWZlciB0b1xuICAgICAgICAgIC8vIHZhcmlhYmxlcyB0aGF0IGhhdmUgYmVlbiBkZWNsYXJlZCBhZnRlciB1c2FnZS5cbiAgICAgICAgICBiaW5kVmlldyh2aWV3LCB0ZW1wbGF0ZSk7XG4gICAgICAgICAgZmluaXNoVmlldyh2aWV3LCBzdGF0ZW1lbnRzKTtcbiAgICAgICAgICByZXR1cm4gbmV3IFZpZXdDb21waWxlUmVzdWx0KHN0YXRlbWVudHMsIHZpZXcudmlld0ZhY3RvcnkubmFtZSwgZGVwZW5kZW5jaWVzKTtcbiAgICAgIH07XG4gICAgICBWaWV3Q29tcGlsZXIuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuICAgICAgXTtcbiAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgVmlld0NvbXBpbGVyLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgIHsgdHlwZTogQ29tcGlsZXJDb25maWcsIH0sXG4gICAgICBdO1xuICAgICAgcmV0dXJuIFZpZXdDb21waWxlcjtcbiAgfSgpKTtcblxuICB2YXIgU291cmNlTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFNvdXJjZU1vZHVsZShtb2R1bGVVcmwsIHNvdXJjZSkge1xuICAgICAgICAgIHRoaXMubW9kdWxlVXJsID0gbW9kdWxlVXJsO1xuICAgICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFNvdXJjZU1vZHVsZTtcbiAgfSgpKTtcbiAgdmFyIE5nTW9kdWxlc1N1bW1hcnkgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gTmdNb2R1bGVzU3VtbWFyeShuZ01vZHVsZUJ5RGlyZWN0aXZlLCBuZ01vZHVsZXMpIHtcbiAgICAgICAgICB0aGlzLm5nTW9kdWxlQnlEaXJlY3RpdmUgPSBuZ01vZHVsZUJ5RGlyZWN0aXZlO1xuICAgICAgICAgIHRoaXMubmdNb2R1bGVzID0gbmdNb2R1bGVzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE5nTW9kdWxlc1N1bW1hcnk7XG4gIH0oKSk7XG4gIGZ1bmN0aW9uIGFuYWx5emVNb2R1bGVzKG5nTW9kdWxlcywgbWV0YWRhdGFSZXNvbHZlcikge1xuICAgICAgdmFyIG5nTW9kdWxlQnlEaXJlY3RpdmUgPSBuZXcgTWFwKCk7XG4gICAgICB2YXIgbW9kdWxlcyA9IFtdO1xuICAgICAgbmdNb2R1bGVzLmZvckVhY2goZnVuY3Rpb24gKG5nTW9kdWxlKSB7XG4gICAgICAgICAgdmFyIG5nTW9kdWxlTWV0YSA9IG1ldGFkYXRhUmVzb2x2ZXIuZ2V0TmdNb2R1bGVNZXRhZGF0YShuZ01vZHVsZSk7XG4gICAgICAgICAgbW9kdWxlcy5wdXNoKG5nTW9kdWxlTWV0YSk7XG4gICAgICAgICAgbmdNb2R1bGVNZXRhLmRlY2xhcmVkRGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChkaXJNZXRhKSB7XG4gICAgICAgICAgICAgIG5nTW9kdWxlQnlEaXJlY3RpdmUuc2V0KGRpck1ldGEudHlwZS5yZWZlcmVuY2UsIG5nTW9kdWxlTWV0YSk7XG4gICAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuZXcgTmdNb2R1bGVzU3VtbWFyeShuZ01vZHVsZUJ5RGlyZWN0aXZlLCBtb2R1bGVzKTtcbiAgfVxuICB2YXIgT2ZmbGluZUNvbXBpbGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIE9mZmxpbmVDb21waWxlcihfbWV0YWRhdGFSZXNvbHZlciwgX2RpcmVjdGl2ZU5vcm1hbGl6ZXIsIF90ZW1wbGF0ZVBhcnNlciwgX3N0eWxlQ29tcGlsZXIsIF92aWV3Q29tcGlsZXIsIF9kaXJXcmFwcGVyQ29tcGlsZXIsIF9uZ01vZHVsZUNvbXBpbGVyLCBfb3V0cHV0RW1pdHRlciwgX2xvY2FsZUlkLCBfdHJhbnNsYXRpb25Gb3JtYXQpIHtcbiAgICAgICAgICB0aGlzLl9tZXRhZGF0YVJlc29sdmVyID0gX21ldGFkYXRhUmVzb2x2ZXI7XG4gICAgICAgICAgdGhpcy5fZGlyZWN0aXZlTm9ybWFsaXplciA9IF9kaXJlY3RpdmVOb3JtYWxpemVyO1xuICAgICAgICAgIHRoaXMuX3RlbXBsYXRlUGFyc2VyID0gX3RlbXBsYXRlUGFyc2VyO1xuICAgICAgICAgIHRoaXMuX3N0eWxlQ29tcGlsZXIgPSBfc3R5bGVDb21waWxlcjtcbiAgICAgICAgICB0aGlzLl92aWV3Q29tcGlsZXIgPSBfdmlld0NvbXBpbGVyO1xuICAgICAgICAgIHRoaXMuX2RpcldyYXBwZXJDb21waWxlciA9IF9kaXJXcmFwcGVyQ29tcGlsZXI7XG4gICAgICAgICAgdGhpcy5fbmdNb2R1bGVDb21waWxlciA9IF9uZ01vZHVsZUNvbXBpbGVyO1xuICAgICAgICAgIHRoaXMuX291dHB1dEVtaXR0ZXIgPSBfb3V0cHV0RW1pdHRlcjtcbiAgICAgICAgICB0aGlzLl9sb2NhbGVJZCA9IF9sb2NhbGVJZDtcbiAgICAgICAgICB0aGlzLl90cmFuc2xhdGlvbkZvcm1hdCA9IF90cmFuc2xhdGlvbkZvcm1hdDtcbiAgICAgICAgICB0aGlzLl9hbmltYXRpb25QYXJzZXIgPSBuZXcgQW5pbWF0aW9uUGFyc2VyKCk7XG4gICAgICAgICAgdGhpcy5fYW5pbWF0aW9uQ29tcGlsZXIgPSBuZXcgQW5pbWF0aW9uQ29tcGlsZXIoKTtcbiAgICAgIH1cbiAgICAgIE9mZmxpbmVDb21waWxlci5wcm90b3R5cGUuYW5hbHl6ZU1vZHVsZXMgPSBmdW5jdGlvbiAobmdNb2R1bGVzKSB7XG4gICAgICAgICAgcmV0dXJuIGFuYWx5emVNb2R1bGVzKG5nTW9kdWxlcywgdGhpcy5fbWV0YWRhdGFSZXNvbHZlcik7XG4gICAgICB9O1xuICAgICAgT2ZmbGluZUNvbXBpbGVyLnByb3RvdHlwZS5jbGVhckNhY2hlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMuX2RpcmVjdGl2ZU5vcm1hbGl6ZXIuY2xlYXJDYWNoZSgpO1xuICAgICAgICAgIHRoaXMuX21ldGFkYXRhUmVzb2x2ZXIuY2xlYXJDYWNoZSgpO1xuICAgICAgfTtcbiAgICAgIE9mZmxpbmVDb21waWxlci5wcm90b3R5cGUuY29tcGlsZSA9IGZ1bmN0aW9uIChtb2R1bGVVcmwsIG5nTW9kdWxlc1N1bW1hcnksIGRpcmVjdGl2ZXMsIG5nTW9kdWxlcykge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIGZpbGVTdWZmaXggPSBfc3BsaXRUeXBlc2NyaXB0U3VmZml4KG1vZHVsZVVybClbMV07XG4gICAgICAgICAgdmFyIHN0YXRlbWVudHMgPSBbXTtcbiAgICAgICAgICB2YXIgZXhwb3J0ZWRWYXJzID0gW107XG4gICAgICAgICAgdmFyIG91dHB1dFNvdXJjZU1vZHVsZXMgPSBbXTtcbiAgICAgICAgICAvLyBjb21waWxlIGFsbCBuZyBtb2R1bGVzXG4gICAgICAgICAgZXhwb3J0ZWRWYXJzLnB1c2guYXBwbHkoZXhwb3J0ZWRWYXJzLCBuZ01vZHVsZXMubWFwKGZ1bmN0aW9uIChuZ01vZHVsZVR5cGUpIHsgcmV0dXJuIF90aGlzLl9jb21waWxlTW9kdWxlKG5nTW9kdWxlVHlwZSwgc3RhdGVtZW50cyk7IH0pKTtcbiAgICAgICAgICAvLyBjb21waWxlIGRpcmVjdGl2ZSB3cmFwcGVyc1xuICAgICAgICAgIGV4cG9ydGVkVmFycy5wdXNoLmFwcGx5KGV4cG9ydGVkVmFycywgZGlyZWN0aXZlcy5tYXAoZnVuY3Rpb24gKGRpcmVjdGl2ZVR5cGUpIHsgcmV0dXJuIF90aGlzLl9jb21waWxlRGlyZWN0aXZlV3JhcHBlcihkaXJlY3RpdmVUeXBlLCBzdGF0ZW1lbnRzKTsgfSkpO1xuICAgICAgICAgIC8vIGNvbXBpbGUgY29tcG9uZW50c1xuICAgICAgICAgIHJldHVybiBQcm9taXNlXG4gICAgICAgICAgICAgIC5hbGwoZGlyZWN0aXZlcy5tYXAoZnVuY3Rpb24gKGRpclR5cGUpIHtcbiAgICAgICAgICAgICAgdmFyIGNvbXBNZXRhID0gX3RoaXMuX21ldGFkYXRhUmVzb2x2ZXIuZ2V0RGlyZWN0aXZlTWV0YWRhdGEoZGlyVHlwZSk7XG4gICAgICAgICAgICAgIGlmICghY29tcE1ldGEuaXNDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIG5nTW9kdWxlID0gbmdNb2R1bGVzU3VtbWFyeS5uZ01vZHVsZUJ5RGlyZWN0aXZlLmdldChkaXJUeXBlKTtcbiAgICAgICAgICAgICAgaWYgKCFuZ01vZHVsZSkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGRldGVybWluZSB0aGUgbW9kdWxlIGZvciBjb21wb25lbnQgXCIgKyBjb21wTWV0YS50eXBlLm5hbWUgKyBcIiFcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2VcbiAgICAgICAgICAgICAgICAgIC5hbGwoW2NvbXBNZXRhXS5jb25jYXQobmdNb2R1bGUudHJhbnNpdGl2ZU1vZHVsZS5kaXJlY3RpdmVzKS5tYXAoZnVuY3Rpb24gKGRpck1ldGEpIHsgcmV0dXJuIF90aGlzLl9kaXJlY3RpdmVOb3JtYWxpemVyLm5vcm1hbGl6ZURpcmVjdGl2ZShkaXJNZXRhKS5hc3luY1Jlc3VsdDsgfSkpXG4gICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAobm9ybWFsaXplZENvbXBXaXRoRGlyZWN0aXZlcykge1xuICAgICAgICAgICAgICAgICAgdmFyIGNvbXBNZXRhID0gbm9ybWFsaXplZENvbXBXaXRoRGlyZWN0aXZlc1swXSwgZGlyTWV0YXMgPSBub3JtYWxpemVkQ29tcFdpdGhEaXJlY3RpdmVzLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgICAgX2Fzc2VydENvbXBvbmVudChjb21wTWV0YSk7XG4gICAgICAgICAgICAgICAgICAvLyBjb21waWxlIHN0eWxlc1xuICAgICAgICAgICAgICAgICAgdmFyIHN0eWxlc0NvbXBpbGVSZXN1bHRzID0gX3RoaXMuX3N0eWxlQ29tcGlsZXIuY29tcGlsZUNvbXBvbmVudChjb21wTWV0YSk7XG4gICAgICAgICAgICAgICAgICBzdHlsZXNDb21waWxlUmVzdWx0cy5leHRlcm5hbFN0eWxlc2hlZXRzLmZvckVhY2goZnVuY3Rpb24gKGNvbXBpbGVkU3R5bGVTaGVldCkge1xuICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFNvdXJjZU1vZHVsZXMucHVzaChfdGhpcy5fY29kZ2VuU3R5bGVzKGNvbXBpbGVkU3R5bGVTaGVldCwgZmlsZVN1ZmZpeCkpO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAvLyBjb21waWxlIGNvbXBvbmVudHNcbiAgICAgICAgICAgICAgICAgIGV4cG9ydGVkVmFycy5wdXNoKF90aGlzLl9jb21waWxlQ29tcG9uZW50RmFjdG9yeShjb21wTWV0YSwgZmlsZVN1ZmZpeCwgc3RhdGVtZW50cyksIF90aGlzLl9jb21waWxlQ29tcG9uZW50KGNvbXBNZXRhLCBkaXJNZXRhcywgbmdNb2R1bGUudHJhbnNpdGl2ZU1vZHVsZS5waXBlcywgbmdNb2R1bGUuc2NoZW1hcywgc3R5bGVzQ29tcGlsZVJlc3VsdHMuY29tcG9uZW50U3R5bGVzaGVldCwgZmlsZVN1ZmZpeCwgc3RhdGVtZW50cykpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAoc3RhdGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICBvdXRwdXRTb3VyY2VNb2R1bGVzLnVuc2hpZnQoX3RoaXMuX2NvZGVnZW5Tb3VyY2VNb2R1bGUoX25nZmFjdG9yeU1vZHVsZVVybChtb2R1bGVVcmwpLCBzdGF0ZW1lbnRzLCBleHBvcnRlZFZhcnMpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gb3V0cHV0U291cmNlTW9kdWxlcztcbiAgICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBPZmZsaW5lQ29tcGlsZXIucHJvdG90eXBlLl9jb21waWxlTW9kdWxlID0gZnVuY3Rpb24gKG5nTW9kdWxlVHlwZSwgdGFyZ2V0U3RhdGVtZW50cykge1xuICAgICAgICAgIHZhciBuZ01vZHVsZSA9IHRoaXMuX21ldGFkYXRhUmVzb2x2ZXIuZ2V0TmdNb2R1bGVNZXRhZGF0YShuZ01vZHVsZVR5cGUpO1xuICAgICAgICAgIHZhciBwcm92aWRlcnMgPSBbXTtcbiAgICAgICAgICBpZiAodGhpcy5fbG9jYWxlSWQpIHtcbiAgICAgICAgICAgICAgcHJvdmlkZXJzLnB1c2gobmV3IENvbXBpbGVQcm92aWRlck1ldGFkYXRhKHtcbiAgICAgICAgICAgICAgICAgIHRva2VuOiByZXNvbHZlSWRlbnRpZmllclRva2VuKElkZW50aWZpZXJzLkxPQ0FMRV9JRCksXG4gICAgICAgICAgICAgICAgICB1c2VWYWx1ZTogdGhpcy5fbG9jYWxlSWQsXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuX3RyYW5zbGF0aW9uRm9ybWF0KSB7XG4gICAgICAgICAgICAgIHByb3ZpZGVycy5wdXNoKG5ldyBDb21waWxlUHJvdmlkZXJNZXRhZGF0YSh7XG4gICAgICAgICAgICAgICAgICB0b2tlbjogcmVzb2x2ZUlkZW50aWZpZXJUb2tlbihJZGVudGlmaWVycy5UUkFOU0xBVElPTlNfRk9STUFUKSxcbiAgICAgICAgICAgICAgICAgIHVzZVZhbHVlOiB0aGlzLl90cmFuc2xhdGlvbkZvcm1hdFxuICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBhcHBDb21waWxlUmVzdWx0ID0gdGhpcy5fbmdNb2R1bGVDb21waWxlci5jb21waWxlKG5nTW9kdWxlLCBwcm92aWRlcnMpO1xuICAgICAgICAgIGFwcENvbXBpbGVSZXN1bHQuZGVwZW5kZW5jaWVzLmZvckVhY2goZnVuY3Rpb24gKGRlcCkge1xuICAgICAgICAgICAgICBkZXAucGxhY2Vob2xkZXIubmFtZSA9IF9jb21wb25lbnRGYWN0b3J5TmFtZShkZXAuY29tcCk7XG4gICAgICAgICAgICAgIGRlcC5wbGFjZWhvbGRlci5tb2R1bGVVcmwgPSBfbmdmYWN0b3J5TW9kdWxlVXJsKGRlcC5jb21wLm1vZHVsZVVybCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGFyZ2V0U3RhdGVtZW50cy5wdXNoLmFwcGx5KHRhcmdldFN0YXRlbWVudHMsIGFwcENvbXBpbGVSZXN1bHQuc3RhdGVtZW50cyk7XG4gICAgICAgICAgcmV0dXJuIGFwcENvbXBpbGVSZXN1bHQubmdNb2R1bGVGYWN0b3J5VmFyO1xuICAgICAgfTtcbiAgICAgIE9mZmxpbmVDb21waWxlci5wcm90b3R5cGUuX2NvbXBpbGVEaXJlY3RpdmVXcmFwcGVyID0gZnVuY3Rpb24gKGRpcmVjdGl2ZVR5cGUsIHRhcmdldFN0YXRlbWVudHMpIHtcbiAgICAgICAgICB2YXIgZGlyTWV0YSA9IHRoaXMuX21ldGFkYXRhUmVzb2x2ZXIuZ2V0RGlyZWN0aXZlTWV0YWRhdGEoZGlyZWN0aXZlVHlwZSk7XG4gICAgICAgICAgdmFyIGRpckNvbXBpbGVSZXN1bHQgPSB0aGlzLl9kaXJXcmFwcGVyQ29tcGlsZXIuY29tcGlsZShkaXJNZXRhKTtcbiAgICAgICAgICB0YXJnZXRTdGF0ZW1lbnRzLnB1c2guYXBwbHkodGFyZ2V0U3RhdGVtZW50cywgZGlyQ29tcGlsZVJlc3VsdC5zdGF0ZW1lbnRzKTtcbiAgICAgICAgICByZXR1cm4gZGlyQ29tcGlsZVJlc3VsdC5kaXJXcmFwcGVyQ2xhc3NWYXI7XG4gICAgICB9O1xuICAgICAgT2ZmbGluZUNvbXBpbGVyLnByb3RvdHlwZS5fY29tcGlsZUNvbXBvbmVudEZhY3RvcnkgPSBmdW5jdGlvbiAoY29tcE1ldGEsIGZpbGVTdWZmaXgsIHRhcmdldFN0YXRlbWVudHMpIHtcbiAgICAgICAgICB2YXIgaG9zdE1ldGEgPSBjcmVhdGVIb3N0Q29tcG9uZW50TWV0YShjb21wTWV0YSk7XG4gICAgICAgICAgdmFyIGhvc3RWaWV3RmFjdG9yeVZhciA9IHRoaXMuX2NvbXBpbGVDb21wb25lbnQoaG9zdE1ldGEsIFtjb21wTWV0YV0sIFtdLCBbXSwgbnVsbCwgZmlsZVN1ZmZpeCwgdGFyZ2V0U3RhdGVtZW50cyk7XG4gICAgICAgICAgdmFyIGNvbXBGYWN0b3J5VmFyID0gX2NvbXBvbmVudEZhY3RvcnlOYW1lKGNvbXBNZXRhLnR5cGUpO1xuICAgICAgICAgIHRhcmdldFN0YXRlbWVudHMucHVzaCh2YXJpYWJsZShjb21wRmFjdG9yeVZhcilcbiAgICAgICAgICAgICAgLnNldChpbXBvcnRFeHByKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLkNvbXBvbmVudEZhY3RvcnkpLCBbaW1wb3J0VHlwZShjb21wTWV0YS50eXBlKV0pXG4gICAgICAgICAgICAgIC5pbnN0YW50aWF0ZShbXG4gICAgICAgICAgICAgIGxpdGVyYWwoY29tcE1ldGEuc2VsZWN0b3IpLFxuICAgICAgICAgICAgICB2YXJpYWJsZShob3N0Vmlld0ZhY3RvcnlWYXIpLFxuICAgICAgICAgICAgICBpbXBvcnRFeHByKGNvbXBNZXRhLnR5cGUpLFxuICAgICAgICAgIF0sIGltcG9ydFR5cGUocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuQ29tcG9uZW50RmFjdG9yeSksIFtpbXBvcnRUeXBlKGNvbXBNZXRhLnR5cGUpXSwgW1R5cGVNb2RpZmllci5Db25zdF0pKSlcbiAgICAgICAgICAgICAgLnRvRGVjbFN0bXQobnVsbCwgW1N0bXRNb2RpZmllci5GaW5hbF0pKTtcbiAgICAgICAgICByZXR1cm4gY29tcEZhY3RvcnlWYXI7XG4gICAgICB9O1xuICAgICAgT2ZmbGluZUNvbXBpbGVyLnByb3RvdHlwZS5fY29tcGlsZUNvbXBvbmVudCA9IGZ1bmN0aW9uIChjb21wTWV0YSwgZGlyZWN0aXZlcywgcGlwZXMsIHNjaGVtYXMsIGNvbXBvbmVudFN0eWxlcywgZmlsZVN1ZmZpeCwgdGFyZ2V0U3RhdGVtZW50cykge1xuICAgICAgICAgIHZhciBwYXJzZWRBbmltYXRpb25zID0gdGhpcy5fYW5pbWF0aW9uUGFyc2VyLnBhcnNlQ29tcG9uZW50KGNvbXBNZXRhKTtcbiAgICAgICAgICB2YXIgcGFyc2VkVGVtcGxhdGUgPSB0aGlzLl90ZW1wbGF0ZVBhcnNlci5wYXJzZShjb21wTWV0YSwgY29tcE1ldGEudGVtcGxhdGUudGVtcGxhdGUsIGRpcmVjdGl2ZXMsIHBpcGVzLCBzY2hlbWFzLCBjb21wTWV0YS50eXBlLm5hbWUpO1xuICAgICAgICAgIHZhciBzdHlsZXNFeHByID0gY29tcG9uZW50U3R5bGVzID8gdmFyaWFibGUoY29tcG9uZW50U3R5bGVzLnN0eWxlc1ZhcikgOiBsaXRlcmFsQXJyKFtdKTtcbiAgICAgICAgICB2YXIgY29tcGlsZWRBbmltYXRpb25zID0gdGhpcy5fYW5pbWF0aW9uQ29tcGlsZXIuY29tcGlsZShjb21wTWV0YS50eXBlLm5hbWUsIHBhcnNlZEFuaW1hdGlvbnMpO1xuICAgICAgICAgIHZhciB2aWV3UmVzdWx0ID0gdGhpcy5fdmlld0NvbXBpbGVyLmNvbXBpbGVDb21wb25lbnQoY29tcE1ldGEsIHBhcnNlZFRlbXBsYXRlLCBzdHlsZXNFeHByLCBwaXBlcywgY29tcGlsZWRBbmltYXRpb25zKTtcbiAgICAgICAgICBpZiAoY29tcG9uZW50U3R5bGVzKSB7XG4gICAgICAgICAgICAgIHRhcmdldFN0YXRlbWVudHMucHVzaC5hcHBseSh0YXJnZXRTdGF0ZW1lbnRzLCBfcmVzb2x2ZVN0eWxlU3RhdGVtZW50cyhjb21wb25lbnRTdHlsZXMsIGZpbGVTdWZmaXgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29tcGlsZWRBbmltYXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7IGVudHJ5LnN0YXRlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoc3RhdGVtZW50KSB7IHRhcmdldFN0YXRlbWVudHMucHVzaChzdGF0ZW1lbnQpOyB9KTsgfSk7XG4gICAgICAgICAgdGFyZ2V0U3RhdGVtZW50cy5wdXNoLmFwcGx5KHRhcmdldFN0YXRlbWVudHMsIF9yZXNvbHZlVmlld1N0YXRlbWVudHModmlld1Jlc3VsdCkpO1xuICAgICAgICAgIHJldHVybiB2aWV3UmVzdWx0LnZpZXdGYWN0b3J5VmFyO1xuICAgICAgfTtcbiAgICAgIE9mZmxpbmVDb21waWxlci5wcm90b3R5cGUuX2NvZGdlblN0eWxlcyA9IGZ1bmN0aW9uIChzdHlsZXNDb21waWxlUmVzdWx0LCBmaWxlU3VmZml4KSB7XG4gICAgICAgICAgX3Jlc29sdmVTdHlsZVN0YXRlbWVudHMoc3R5bGVzQ29tcGlsZVJlc3VsdCwgZmlsZVN1ZmZpeCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2NvZGVnZW5Tb3VyY2VNb2R1bGUoX3N0eWxlc01vZHVsZVVybChzdHlsZXNDb21waWxlUmVzdWx0Lm1ldGEubW9kdWxlVXJsLCBzdHlsZXNDb21waWxlUmVzdWx0LmlzU2hpbW1lZCwgZmlsZVN1ZmZpeCksIHN0eWxlc0NvbXBpbGVSZXN1bHQuc3RhdGVtZW50cywgW3N0eWxlc0NvbXBpbGVSZXN1bHQuc3R5bGVzVmFyXSk7XG4gICAgICB9O1xuICAgICAgT2ZmbGluZUNvbXBpbGVyLnByb3RvdHlwZS5fY29kZWdlblNvdXJjZU1vZHVsZSA9IGZ1bmN0aW9uIChtb2R1bGVVcmwsIHN0YXRlbWVudHMsIGV4cG9ydGVkVmFycykge1xuICAgICAgICAgIHJldHVybiBuZXcgU291cmNlTW9kdWxlKG1vZHVsZVVybCwgdGhpcy5fb3V0cHV0RW1pdHRlci5lbWl0U3RhdGVtZW50cyhtb2R1bGVVcmwsIHN0YXRlbWVudHMsIGV4cG9ydGVkVmFycykpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBPZmZsaW5lQ29tcGlsZXI7XG4gIH0oKSk7XG4gIGZ1bmN0aW9uIF9yZXNvbHZlVmlld1N0YXRlbWVudHMoY29tcGlsZVJlc3VsdCkge1xuICAgICAgY29tcGlsZVJlc3VsdC5kZXBlbmRlbmNpZXMuZm9yRWFjaChmdW5jdGlvbiAoZGVwKSB7XG4gICAgICAgICAgaWYgKGRlcCBpbnN0YW5jZW9mIFZpZXdGYWN0b3J5RGVwZW5kZW5jeSkge1xuICAgICAgICAgICAgICB2YXIgdmZkID0gZGVwO1xuICAgICAgICAgICAgICB2ZmQucGxhY2Vob2xkZXIubW9kdWxlVXJsID0gX25nZmFjdG9yeU1vZHVsZVVybCh2ZmQuY29tcC5tb2R1bGVVcmwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChkZXAgaW5zdGFuY2VvZiBDb21wb25lbnRGYWN0b3J5RGVwZW5kZW5jeSkge1xuICAgICAgICAgICAgICB2YXIgY2ZkID0gZGVwO1xuICAgICAgICAgICAgICBjZmQucGxhY2Vob2xkZXIubmFtZSA9IF9jb21wb25lbnRGYWN0b3J5TmFtZShjZmQuY29tcCk7XG4gICAgICAgICAgICAgIGNmZC5wbGFjZWhvbGRlci5tb2R1bGVVcmwgPSBfbmdmYWN0b3J5TW9kdWxlVXJsKGNmZC5jb21wLm1vZHVsZVVybCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGRlcCBpbnN0YW5jZW9mIERpcmVjdGl2ZVdyYXBwZXJEZXBlbmRlbmN5KSB7XG4gICAgICAgICAgICAgIHZhciBkd2QgPSBkZXA7XG4gICAgICAgICAgICAgIGR3ZC5wbGFjZWhvbGRlci5tb2R1bGVVcmwgPSBfbmdmYWN0b3J5TW9kdWxlVXJsKGR3ZC5kaXIubW9kdWxlVXJsKTtcbiAgICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjb21waWxlUmVzdWx0LnN0YXRlbWVudHM7XG4gIH1cbiAgZnVuY3Rpb24gX3Jlc29sdmVTdHlsZVN0YXRlbWVudHMoY29tcGlsZVJlc3VsdCwgZmlsZVN1ZmZpeCkge1xuICAgICAgY29tcGlsZVJlc3VsdC5kZXBlbmRlbmNpZXMuZm9yRWFjaChmdW5jdGlvbiAoZGVwKSB7XG4gICAgICAgICAgZGVwLnZhbHVlUGxhY2Vob2xkZXIubW9kdWxlVXJsID0gX3N0eWxlc01vZHVsZVVybChkZXAubW9kdWxlVXJsLCBkZXAuaXNTaGltbWVkLCBmaWxlU3VmZml4KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNvbXBpbGVSZXN1bHQuc3RhdGVtZW50cztcbiAgfVxuICBmdW5jdGlvbiBfbmdmYWN0b3J5TW9kdWxlVXJsKGRpclVybCkge1xuICAgICAgdmFyIHVybFdpdGhTdWZmaXggPSBfc3BsaXRUeXBlc2NyaXB0U3VmZml4KGRpclVybCk7XG4gICAgICByZXR1cm4gdXJsV2l0aFN1ZmZpeFswXSArIFwiLm5nZmFjdG9yeVwiICsgdXJsV2l0aFN1ZmZpeFsxXTtcbiAgfVxuICBmdW5jdGlvbiBfY29tcG9uZW50RmFjdG9yeU5hbWUoY29tcCkge1xuICAgICAgcmV0dXJuIGNvbXAubmFtZSArIFwiTmdGYWN0b3J5XCI7XG4gIH1cbiAgZnVuY3Rpb24gX3N0eWxlc01vZHVsZVVybChzdHlsZXNoZWV0VXJsLCBzaGltLCBzdWZmaXgpIHtcbiAgICAgIHJldHVybiBzaGltID8gc3R5bGVzaGVldFVybCArIFwiLnNoaW1cIiArIHN1ZmZpeCA6IFwiXCIgKyBzdHlsZXNoZWV0VXJsICsgc3VmZml4O1xuICB9XG4gIGZ1bmN0aW9uIF9hc3NlcnRDb21wb25lbnQobWV0YSkge1xuICAgICAgaWYgKCFtZXRhLmlzQ29tcG9uZW50KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGNvbXBpbGUgJ1wiICsgbWV0YS50eXBlLm5hbWUgKyBcIicgYmVjYXVzZSBpdCBpcyBub3QgYSBjb21wb25lbnQuXCIpO1xuICAgICAgfVxuICB9XG4gIGZ1bmN0aW9uIF9zcGxpdFR5cGVzY3JpcHRTdWZmaXgocGF0aCkge1xuICAgICAgaWYgKHBhdGguZW5kc1dpdGgoJy5kLnRzJykpIHtcbiAgICAgICAgICByZXR1cm4gW3BhdGguc2xpY2UoMCwgLTUpLCAnLnRzJ107XG4gICAgICB9XG4gICAgICB2YXIgbGFzdERvdCA9IHBhdGgubGFzdEluZGV4T2YoJy4nKTtcbiAgICAgIGlmIChsYXN0RG90ICE9PSAtMSkge1xuICAgICAgICAgIHJldHVybiBbcGF0aC5zdWJzdHJpbmcoMCwgbGFzdERvdCksIHBhdGguc3Vic3RyaW5nKGxhc3REb3QpXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbcGF0aCwgJyddO1xuICB9XG5cbiAgLyoqXG4gICAqIEBsaWNlbnNlXG4gICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgKlxuICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAqL1xuICAvKipcbiAgICogQW4gaW50ZXJmYWNlIGZvciByZXRyaWV2aW5nIGRvY3VtZW50cyBieSBVUkwgdGhhdCB0aGUgY29tcGlsZXIgdXNlc1xuICAgKiB0byBsb2FkIHRlbXBsYXRlcy5cbiAgICovXG4gIHZhciBSZXNvdXJjZUxvYWRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBSZXNvdXJjZUxvYWRlcigpIHtcbiAgICAgIH1cbiAgICAgIFJlc291cmNlTG9hZGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodXJsKSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgcmV0dXJuIFJlc291cmNlTG9hZGVyO1xuICB9KCkpO1xuXG4gIHZhciBfQVNTRVRfU0NIRU1FID0gJ2Fzc2V0Oic7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSB7QGxpbmsgVXJsUmVzb2x2ZXJ9IHdpdGggbm8gcGFja2FnZSBwcmVmaXguXG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVVcmxSZXNvbHZlcldpdGhvdXRQYWNrYWdlUHJlZml4KCkge1xuICAgICAgcmV0dXJuIG5ldyBVcmxSZXNvbHZlcigpO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZU9mZmxpbmVDb21waWxlVXJsUmVzb2x2ZXIoKSB7XG4gICAgICByZXR1cm4gbmV3IFVybFJlc29sdmVyKF9BU1NFVF9TQ0hFTUUpO1xuICB9XG4gIC8qKlxuICAgKiBBIGRlZmF1bHQgcHJvdmlkZXIgZm9yIHtAbGluayBQQUNLQUdFX1JPT1RfVVJMfSB0aGF0IG1hcHMgdG8gJy8nLlxuICAgKi9cbiAgdmFyIERFRkFVTFRfUEFDS0FHRV9VUkxfUFJPVklERVIgPSB7XG4gICAgICBwcm92aWRlOiBfYW5ndWxhcl9jb3JlLlBBQ0tBR0VfUk9PVF9VUkwsXG4gICAgICB1c2VWYWx1ZTogJy8nXG4gIH07XG4gIC8qKlxuICAgKiBVc2VkIGJ5IHRoZSB7QGxpbmsgQ29tcGlsZXJ9IHdoZW4gcmVzb2x2aW5nIEhUTUwgYW5kIENTUyB0ZW1wbGF0ZSBVUkxzLlxuICAgKlxuICAgKiBUaGlzIGNsYXNzIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHRoZSBhcHBsaWNhdGlvbiBkZXZlbG9wZXIgdG8gY3JlYXRlIGN1c3RvbSBiZWhhdmlvci5cbiAgICpcbiAgICogU2VlIHtAbGluayBDb21waWxlcn1cbiAgICpcbiAgICogIyMgRXhhbXBsZVxuICAgKlxuICAgKiB7QGV4YW1wbGUgY29tcGlsZXIvdHMvdXJsX3Jlc29sdmVyL3VybF9yZXNvbHZlci50cyByZWdpb249J3VybF9yZXNvbHZlcid9XG4gICAqXG4gICAqIEBzZWN1cml0eSAgV2hlbiBjb21waWxpbmcgdGVtcGxhdGVzIGF0IHJ1bnRpbWUsIHlvdSBtdXN0XG4gICAqIGVuc3VyZSB0aGF0IHRoZSBlbnRpcmUgdGVtcGxhdGUgY29tZXMgZnJvbSBhIHRydXN0ZWQgc291cmNlLlxuICAgKiBBdHRhY2tlci1jb250cm9sbGVkIGRhdGEgaW50cm9kdWNlZCBieSBhIHRlbXBsYXRlIGNvdWxkIGV4cG9zZSB5b3VyXG4gICAqIGFwcGxpY2F0aW9uIHRvIFhTUyByaXNrcy4gRm9yIG1vcmUgZGV0YWlsLCBzZWUgdGhlIFtTZWN1cml0eSBHdWlkZV0oaHR0cDovL2cuY28vbmcvc2VjdXJpdHkpLlxuICAgKi9cbiAgdmFyIFVybFJlc29sdmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFVybFJlc29sdmVyKF9wYWNrYWdlUHJlZml4KSB7XG4gICAgICAgICAgaWYgKF9wYWNrYWdlUHJlZml4ID09PSB2b2lkIDApIHsgX3BhY2thZ2VQcmVmaXggPSBudWxsOyB9XG4gICAgICAgICAgdGhpcy5fcGFja2FnZVByZWZpeCA9IF9wYWNrYWdlUHJlZml4O1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBSZXNvbHZlcyB0aGUgYHVybGAgZ2l2ZW4gdGhlIGBiYXNlVXJsYDpcbiAgICAgICAqIC0gd2hlbiB0aGUgYHVybGAgaXMgbnVsbCwgdGhlIGBiYXNlVXJsYCBpcyByZXR1cm5lZCxcbiAgICAgICAqIC0gaWYgYHVybGAgaXMgcmVsYXRpdmUgKCdwYXRoL3RvL2hlcmUnLCAnLi9wYXRoL3RvL2hlcmUnKSwgdGhlIHJlc29sdmVkIHVybCBpcyBhIGNvbWJpbmF0aW9uIG9mXG4gICAgICAgKiBgYmFzZVVybGAgYW5kIGB1cmxgLFxuICAgICAgICogLSBpZiBgdXJsYCBpcyBhYnNvbHV0ZSAoaXQgaGFzIGEgc2NoZW1lOiAnaHR0cDovLycsICdodHRwczovLycgb3Igc3RhcnQgd2l0aCAnLycpLCB0aGUgYHVybGAgaXNcbiAgICAgICAqIHJldHVybmVkIGFzIGlzIChpZ25vcmluZyB0aGUgYGJhc2VVcmxgKVxuICAgICAgICovXG4gICAgICBVcmxSZXNvbHZlci5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uIChiYXNlVXJsLCB1cmwpIHtcbiAgICAgICAgICB2YXIgcmVzb2x2ZWRVcmwgPSB1cmw7XG4gICAgICAgICAgaWYgKGlzUHJlc2VudChiYXNlVXJsKSAmJiBiYXNlVXJsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZWRVcmwgPSBfcmVzb2x2ZVVybChiYXNlVXJsLCByZXNvbHZlZFVybCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByZXNvbHZlZFBhcnRzID0gX3NwbGl0KHJlc29sdmVkVXJsKTtcbiAgICAgICAgICB2YXIgcHJlZml4ID0gdGhpcy5fcGFja2FnZVByZWZpeDtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KHByZWZpeCkgJiYgaXNQcmVzZW50KHJlc29sdmVkUGFydHMpICYmXG4gICAgICAgICAgICAgIHJlc29sdmVkUGFydHNbX0NvbXBvbmVudEluZGV4LlNjaGVtZV0gPT0gJ3BhY2thZ2UnKSB7XG4gICAgICAgICAgICAgIHZhciBwYXRoID0gcmVzb2x2ZWRQYXJ0c1tfQ29tcG9uZW50SW5kZXguUGF0aF07XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9wYWNrYWdlUHJlZml4ID09PSBfQVNTRVRfU0NIRU1FKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcGF0aFNlZ2VtZW50cyA9IHBhdGguc3BsaXQoL1xcLy8pO1xuICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRVcmwgPSBcImFzc2V0OlwiICsgcGF0aFNlZ2VtZW50c1swXSArIFwiL2xpYi9cIiArIHBhdGhTZWdlbWVudHMuc2xpY2UoMSkuam9pbignLycpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcHJlZml4ID0gcHJlZml4LnJlcGxhY2UoL1xcLyskLywgJycpO1xuICAgICAgICAgICAgICAgICAgcGF0aCA9IHBhdGgucmVwbGFjZSgvXlxcLysvLCAnJyk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcHJlZml4ICsgXCIvXCIgKyBwYXRoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXNvbHZlZFVybDtcbiAgICAgIH07XG4gICAgICBVcmxSZXNvbHZlci5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG4gICAgICBdO1xuICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICBVcmxSZXNvbHZlci5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtfYW5ndWxhcl9jb3JlLlBBQ0tBR0VfUk9PVF9VUkwsXSB9LF0gfSxcbiAgICAgIF07XG4gICAgICByZXR1cm4gVXJsUmVzb2x2ZXI7XG4gIH0oKSk7XG4gIC8qKlxuICAgKiBFeHRyYWN0IHRoZSBzY2hlbWUgb2YgYSBVUkwuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRVcmxTY2hlbWUodXJsKSB7XG4gICAgICB2YXIgbWF0Y2ggPSBfc3BsaXQodXJsKTtcbiAgICAgIHJldHVybiAobWF0Y2ggJiYgbWF0Y2hbX0NvbXBvbmVudEluZGV4LlNjaGVtZV0pIHx8ICcnO1xuICB9XG4gIC8vIFRoZSBjb2RlIGJlbG93IGlzIGFkYXB0ZWQgZnJvbSBUcmFjZXVyOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL3RyYWNldXItY29tcGlsZXIvYmxvYi85NTExYzFkYWZhOTcyYmYwZGUxMjAyYThhODYzYmFkMDJmMGY5NWE4L3NyYy9ydW50aW1lL3VybC5qc1xuICAvKipcbiAgICogQnVpbGRzIGEgVVJJIHN0cmluZyBmcm9tIGFscmVhZHktZW5jb2RlZCBwYXJ0cy5cbiAgICpcbiAgICogTm8gZW5jb2RpbmcgaXMgcGVyZm9ybWVkLiAgQW55IGNvbXBvbmVudCBtYXkgYmUgb21pdHRlZCBhcyBlaXRoZXIgbnVsbCBvclxuICAgKiB1bmRlZmluZWQuXG4gICAqXG4gICAqIEBwYXJhbSBvcHRfc2NoZW1lIFRoZSBzY2hlbWUgc3VjaCBhcyAnaHR0cCcuXG4gICAqIEBwYXJhbSBvcHRfdXNlckluZm8gVGhlIHVzZXIgbmFtZSBiZWZvcmUgdGhlICdAJy5cbiAgICogQHBhcmFtIG9wdF9kb21haW4gVGhlIGRvbWFpbiBzdWNoIGFzICd3d3cuZ29vZ2xlLmNvbScsIGFscmVhZHlcbiAgICogICAgIFVSSS1lbmNvZGVkLlxuICAgKiBAcGFyYW0gb3B0X3BvcnQgVGhlIHBvcnQgbnVtYmVyLlxuICAgKiBAcGFyYW0gb3B0X3BhdGggVGhlIHBhdGgsIGFscmVhZHkgVVJJLWVuY29kZWQuICBJZiBpdCBpcyBub3RcbiAgICogICAgIGVtcHR5LCBpdCBtdXN0IGJlZ2luIHdpdGggYSBzbGFzaC5cbiAgICogQHBhcmFtIG9wdF9xdWVyeURhdGEgVGhlIFVSSS1lbmNvZGVkIHF1ZXJ5IGRhdGEuXG4gICAqIEBwYXJhbSBvcHRfZnJhZ21lbnQgVGhlIFVSSS1lbmNvZGVkIGZyYWdtZW50IGlkZW50aWZpZXIuXG4gICAqIEByZXR1cm4gVGhlIGZ1bGx5IGNvbWJpbmVkIFVSSS5cbiAgICovXG4gIGZ1bmN0aW9uIF9idWlsZEZyb21FbmNvZGVkUGFydHMob3B0X3NjaGVtZSwgb3B0X3VzZXJJbmZvLCBvcHRfZG9tYWluLCBvcHRfcG9ydCwgb3B0X3BhdGgsIG9wdF9xdWVyeURhdGEsIG9wdF9mcmFnbWVudCkge1xuICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgaWYgKGlzUHJlc2VudChvcHRfc2NoZW1lKSkge1xuICAgICAgICAgIG91dC5wdXNoKG9wdF9zY2hlbWUgKyAnOicpO1xuICAgICAgfVxuICAgICAgaWYgKGlzUHJlc2VudChvcHRfZG9tYWluKSkge1xuICAgICAgICAgIG91dC5wdXNoKCcvLycpO1xuICAgICAgICAgIGlmIChpc1ByZXNlbnQob3B0X3VzZXJJbmZvKSkge1xuICAgICAgICAgICAgICBvdXQucHVzaChvcHRfdXNlckluZm8gKyAnQCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXQucHVzaChvcHRfZG9tYWluKTtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KG9wdF9wb3J0KSkge1xuICAgICAgICAgICAgICBvdXQucHVzaCgnOicgKyBvcHRfcG9ydCk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzUHJlc2VudChvcHRfcGF0aCkpIHtcbiAgICAgICAgICBvdXQucHVzaChvcHRfcGF0aCk7XG4gICAgICB9XG4gICAgICBpZiAoaXNQcmVzZW50KG9wdF9xdWVyeURhdGEpKSB7XG4gICAgICAgICAgb3V0LnB1c2goJz8nICsgb3B0X3F1ZXJ5RGF0YSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNQcmVzZW50KG9wdF9mcmFnbWVudCkpIHtcbiAgICAgICAgICBvdXQucHVzaCgnIycgKyBvcHRfZnJhZ21lbnQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dC5qb2luKCcnKTtcbiAgfVxuICAvKipcbiAgICogQSByZWd1bGFyIGV4cHJlc3Npb24gZm9yIGJyZWFraW5nIGEgVVJJIGludG8gaXRzIGNvbXBvbmVudCBwYXJ0cy5cbiAgICpcbiAgICoge0BsaW5rIGh0dHA6Ly93d3cuZ2Jpdi5jb20vcHJvdG9jb2xzL3VyaS9yZmMvcmZjMzk4Ni5odG1sI1JGQzIyMzR9IHNheXNcbiAgICogQXMgdGhlIFwiZmlyc3QtbWF0Y2gtd2luc1wiIGFsZ29yaXRobSBpcyBpZGVudGljYWwgdG8gdGhlIFwiZ3JlZWR5XCJcbiAgICogZGlzYW1iaWd1YXRpb24gbWV0aG9kIHVzZWQgYnkgUE9TSVggcmVndWxhciBleHByZXNzaW9ucywgaXQgaXMgbmF0dXJhbCBhbmRcbiAgICogY29tbW9ucGxhY2UgdG8gdXNlIGEgcmVndWxhciBleHByZXNzaW9uIGZvciBwYXJzaW5nIHRoZSBwb3RlbnRpYWwgZml2ZVxuICAgKiBjb21wb25lbnRzIG9mIGEgVVJJIHJlZmVyZW5jZS5cbiAgICpcbiAgICogVGhlIGZvbGxvd2luZyBsaW5lIGlzIHRoZSByZWd1bGFyIGV4cHJlc3Npb24gZm9yIGJyZWFraW5nLWRvd24gYVxuICAgKiB3ZWxsLWZvcm1lZCBVUkkgcmVmZXJlbmNlIGludG8gaXRzIGNvbXBvbmVudHMuXG4gICAqXG4gICAqIDxwcmU+XG4gICAqIF4oKFteOi8/I10rKTopPygvLyhbXi8/I10qKSk/KFtePyNdKikoXFw/KFteI10qKSk/KCMoLiopKT9cbiAgICogIDEyICAgICAgICAgICAgMyAgNCAgICAgICAgICA1ICAgICAgIDYgIDcgICAgICAgIDggOVxuICAgKiA8L3ByZT5cbiAgICpcbiAgICogVGhlIG51bWJlcnMgaW4gdGhlIHNlY29uZCBsaW5lIGFib3ZlIGFyZSBvbmx5IHRvIGFzc2lzdCByZWFkYWJpbGl0eTsgdGhleVxuICAgKiBpbmRpY2F0ZSB0aGUgcmVmZXJlbmNlIHBvaW50cyBmb3IgZWFjaCBzdWJleHByZXNzaW9uIChpLmUuLCBlYWNoIHBhaXJlZFxuICAgKiBwYXJlbnRoZXNpcykuIFdlIHJlZmVyIHRvIHRoZSB2YWx1ZSBtYXRjaGVkIGZvciBzdWJleHByZXNzaW9uIDxuPiBhcyAkPG4+LlxuICAgKiBGb3IgZXhhbXBsZSwgbWF0Y2hpbmcgdGhlIGFib3ZlIGV4cHJlc3Npb24gdG9cbiAgICogPHByZT5cbiAgICogICAgIGh0dHA6Ly93d3cuaWNzLnVjaS5lZHUvcHViL2lldGYvdXJpLyNSZWxhdGVkXG4gICAqIDwvcHJlPlxuICAgKiByZXN1bHRzIGluIHRoZSBmb2xsb3dpbmcgc3ViZXhwcmVzc2lvbiBtYXRjaGVzOlxuICAgKiA8cHJlPlxuICAgKiAgICAkMSA9IGh0dHA6XG4gICAqICAgICQyID0gaHR0cFxuICAgKiAgICAkMyA9IC8vd3d3Lmljcy51Y2kuZWR1XG4gICAqICAgICQ0ID0gd3d3Lmljcy51Y2kuZWR1XG4gICAqICAgICQ1ID0gL3B1Yi9pZXRmL3VyaS9cbiAgICogICAgJDYgPSA8dW5kZWZpbmVkPlxuICAgKiAgICAkNyA9IDx1bmRlZmluZWQ+XG4gICAqICAgICQ4ID0gI1JlbGF0ZWRcbiAgICogICAgJDkgPSBSZWxhdGVkXG4gICAqIDwvcHJlPlxuICAgKiB3aGVyZSA8dW5kZWZpbmVkPiBpbmRpY2F0ZXMgdGhhdCB0aGUgY29tcG9uZW50IGlzIG5vdCBwcmVzZW50LCBhcyBpcyB0aGVcbiAgICogY2FzZSBmb3IgdGhlIHF1ZXJ5IGNvbXBvbmVudCBpbiB0aGUgYWJvdmUgZXhhbXBsZS4gVGhlcmVmb3JlLCB3ZSBjYW5cbiAgICogZGV0ZXJtaW5lIHRoZSB2YWx1ZSBvZiB0aGUgZml2ZSBjb21wb25lbnRzIGFzXG4gICAqIDxwcmU+XG4gICAqICAgIHNjaGVtZSAgICA9ICQyXG4gICAqICAgIGF1dGhvcml0eSA9ICQ0XG4gICAqICAgIHBhdGggICAgICA9ICQ1XG4gICAqICAgIHF1ZXJ5ICAgICA9ICQ3XG4gICAqICAgIGZyYWdtZW50ICA9ICQ5XG4gICAqIDwvcHJlPlxuICAgKlxuICAgKiBUaGUgcmVndWxhciBleHByZXNzaW9uIGhhcyBiZWVuIG1vZGlmaWVkIHNsaWdodGx5IHRvIGV4cG9zZSB0aGVcbiAgICogdXNlckluZm8sIGRvbWFpbiwgYW5kIHBvcnQgc2VwYXJhdGVseSBmcm9tIHRoZSBhdXRob3JpdHkuXG4gICAqIFRoZSBtb2RpZmllZCB2ZXJzaW9uIHlpZWxkc1xuICAgKiA8cHJlPlxuICAgKiAgICAkMSA9IGh0dHAgICAgICAgICAgICAgIHNjaGVtZVxuICAgKiAgICAkMiA9IDx1bmRlZmluZWQ+ICAgICAgIHVzZXJJbmZvIC1cXFxuICAgKiAgICAkMyA9IHd3dy5pY3MudWNpLmVkdSAgIGRvbWFpbiAgICAgfCBhdXRob3JpdHlcbiAgICogICAgJDQgPSA8dW5kZWZpbmVkPiAgICAgICBwb3J0ICAgICAtL1xuICAgKiAgICAkNSA9IC9wdWIvaWV0Zi91cmkvICAgIHBhdGhcbiAgICogICAgJDYgPSA8dW5kZWZpbmVkPiAgICAgICBxdWVyeSB3aXRob3V0ID9cbiAgICogICAgJDcgPSBSZWxhdGVkICAgICAgICAgICBmcmFnbWVudCB3aXRob3V0ICNcbiAgICogPC9wcmU+XG4gICAqIEB0eXBlIHshUmVnRXhwfVxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHZhciBfc3BsaXRSZSA9IG5ldyBSZWdFeHAoJ14nICtcbiAgICAgICcoPzonICtcbiAgICAgICcoW146Lz8jLl0rKScgK1xuICAgICAgLy8gdXNlZCBieSBvdGhlciBVUkwgcGFydHMgc3VjaCBhcyA6LFxuICAgICAgLy8gPywgLywgIywgYW5kIC5cbiAgICAgICc6KT8nICtcbiAgICAgICcoPzovLycgK1xuICAgICAgJyg/OihbXi8/I10qKUApPycgK1xuICAgICAgJyhbXFxcXHdcXFxcZFxcXFwtXFxcXHUwMTAwLVxcXFx1ZmZmZi4lXSopJyArXG4gICAgICAvLyBkaWdpdHMsIGRhc2hlcywgZG90cywgcGVyY2VudFxuICAgICAgLy8gZXNjYXBlcywgYW5kIHVuaWNvZGUgY2hhcmFjdGVycy5cbiAgICAgICcoPzo6KFswLTldKykpPycgK1xuICAgICAgJyk/JyArXG4gICAgICAnKFtePyNdKyk/JyArXG4gICAgICAnKD86XFxcXD8oW14jXSopKT8nICtcbiAgICAgICcoPzojKC4qKSk/JyArXG4gICAgICAnJCcpO1xuICAvKipcbiAgICogVGhlIGluZGV4IG9mIGVhY2ggVVJJIGNvbXBvbmVudCBpbiB0aGUgcmV0dXJuIHZhbHVlIG9mIGdvb2cudXJpLnV0aWxzLnNwbGl0LlxuICAgKiBAZW51bSB7bnVtYmVyfVxuICAgKi9cbiAgdmFyIF9Db21wb25lbnRJbmRleDtcbiAgKGZ1bmN0aW9uIChfQ29tcG9uZW50SW5kZXgpIHtcbiAgICAgIF9Db21wb25lbnRJbmRleFtfQ29tcG9uZW50SW5kZXhbXCJTY2hlbWVcIl0gPSAxXSA9IFwiU2NoZW1lXCI7XG4gICAgICBfQ29tcG9uZW50SW5kZXhbX0NvbXBvbmVudEluZGV4W1wiVXNlckluZm9cIl0gPSAyXSA9IFwiVXNlckluZm9cIjtcbiAgICAgIF9Db21wb25lbnRJbmRleFtfQ29tcG9uZW50SW5kZXhbXCJEb21haW5cIl0gPSAzXSA9IFwiRG9tYWluXCI7XG4gICAgICBfQ29tcG9uZW50SW5kZXhbX0NvbXBvbmVudEluZGV4W1wiUG9ydFwiXSA9IDRdID0gXCJQb3J0XCI7XG4gICAgICBfQ29tcG9uZW50SW5kZXhbX0NvbXBvbmVudEluZGV4W1wiUGF0aFwiXSA9IDVdID0gXCJQYXRoXCI7XG4gICAgICBfQ29tcG9uZW50SW5kZXhbX0NvbXBvbmVudEluZGV4W1wiUXVlcnlEYXRhXCJdID0gNl0gPSBcIlF1ZXJ5RGF0YVwiO1xuICAgICAgX0NvbXBvbmVudEluZGV4W19Db21wb25lbnRJbmRleFtcIkZyYWdtZW50XCJdID0gN10gPSBcIkZyYWdtZW50XCI7XG4gIH0pKF9Db21wb25lbnRJbmRleCB8fCAoX0NvbXBvbmVudEluZGV4ID0ge30pKTtcbiAgLyoqXG4gICAqIFNwbGl0cyBhIFVSSSBpbnRvIGl0cyBjb21wb25lbnQgcGFydHMuXG4gICAqXG4gICAqIEVhY2ggY29tcG9uZW50IGNhbiBiZSBhY2Nlc3NlZCB2aWEgdGhlIGNvbXBvbmVudCBpbmRpY2VzOyBmb3IgZXhhbXBsZTpcbiAgICogPHByZT5cbiAgICogZ29vZy51cmkudXRpbHMuc3BsaXQoc29tZVN0cilbZ29vZy51cmkudXRpbHMuQ29tcG9udGVudEluZGV4LlFVRVJZX0RBVEFdO1xuICAgKiA8L3ByZT5cbiAgICpcbiAgICogQHBhcmFtIHVyaSBUaGUgVVJJIHN0cmluZyB0byBleGFtaW5lLlxuICAgKiBAcmV0dXJuIEVhY2ggY29tcG9uZW50IHN0aWxsIFVSSS1lbmNvZGVkLlxuICAgKiAgICAgRWFjaCBjb21wb25lbnQgdGhhdCBpcyBwcmVzZW50IHdpbGwgY29udGFpbiB0aGUgZW5jb2RlZCB2YWx1ZSwgd2hlcmVhc1xuICAgKiAgICAgY29tcG9uZW50cyB0aGF0IGFyZSBub3QgcHJlc2VudCB3aWxsIGJlIHVuZGVmaW5lZCBvciBlbXB0eSwgZGVwZW5kaW5nXG4gICAqICAgICBvbiB0aGUgYnJvd3NlcidzIHJlZ3VsYXIgZXhwcmVzc2lvbiBpbXBsZW1lbnRhdGlvbi4gIE5ldmVyIG51bGwsIHNpbmNlXG4gICAqICAgICBhcmJpdHJhcnkgc3RyaW5ncyBtYXkgc3RpbGwgbG9vayBsaWtlIHBhdGggbmFtZXMuXG4gICAqL1xuICBmdW5jdGlvbiBfc3BsaXQodXJpKSB7XG4gICAgICByZXR1cm4gdXJpLm1hdGNoKF9zcGxpdFJlKTtcbiAgfVxuICAvKipcbiAgICAqIFJlbW92ZXMgZG90IHNlZ21lbnRzIGluIGdpdmVuIHBhdGggY29tcG9uZW50LCBhcyBkZXNjcmliZWQgaW5cbiAgICAqIFJGQyAzOTg2LCBzZWN0aW9uIDUuMi40LlxuICAgICpcbiAgICAqIEBwYXJhbSBwYXRoIEEgbm9uLWVtcHR5IHBhdGggY29tcG9uZW50LlxuICAgICogQHJldHVybiBQYXRoIGNvbXBvbmVudCB3aXRoIHJlbW92ZWQgZG90IHNlZ21lbnRzLlxuICAgICovXG4gIGZ1bmN0aW9uIF9yZW1vdmVEb3RTZWdtZW50cyhwYXRoKSB7XG4gICAgICBpZiAocGF0aCA9PSAnLycpXG4gICAgICAgICAgcmV0dXJuICcvJztcbiAgICAgIHZhciBsZWFkaW5nU2xhc2ggPSBwYXRoWzBdID09ICcvJyA/ICcvJyA6ICcnO1xuICAgICAgdmFyIHRyYWlsaW5nU2xhc2ggPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV0gPT09ICcvJyA/ICcvJyA6ICcnO1xuICAgICAgdmFyIHNlZ21lbnRzID0gcGF0aC5zcGxpdCgnLycpO1xuICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgdmFyIHVwID0gMDtcbiAgICAgIGZvciAodmFyIHBvcyA9IDA7IHBvcyA8IHNlZ21lbnRzLmxlbmd0aDsgcG9zKyspIHtcbiAgICAgICAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzW3Bvc107XG4gICAgICAgICAgc3dpdGNoIChzZWdtZW50KSB7XG4gICAgICAgICAgICAgIGNhc2UgJyc6XG4gICAgICAgICAgICAgIGNhc2UgJy4nOlxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJy4uJzpcbiAgICAgICAgICAgICAgICAgIGlmIChvdXQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgIG91dC5wb3AoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHVwKys7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIG91dC5wdXNoKHNlZ21lbnQpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChsZWFkaW5nU2xhc2ggPT0gJycpIHtcbiAgICAgICAgICB3aGlsZSAodXAtLSA+IDApIHtcbiAgICAgICAgICAgICAgb3V0LnVuc2hpZnQoJy4uJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvdXQubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICBvdXQucHVzaCgnLicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxlYWRpbmdTbGFzaCArIG91dC5qb2luKCcvJykgKyB0cmFpbGluZ1NsYXNoO1xuICB9XG4gIC8qKlxuICAgKiBUYWtlcyBhbiBhcnJheSBvZiB0aGUgcGFydHMgZnJvbSBzcGxpdCBhbmQgY2Fub25pY2FsaXplcyB0aGUgcGF0aCBwYXJ0XG4gICAqIGFuZCB0aGVuIGpvaW5zIGFsbCB0aGUgcGFydHMuXG4gICAqL1xuICBmdW5jdGlvbiBfam9pbkFuZENhbm9uaWNhbGl6ZVBhdGgocGFydHMpIHtcbiAgICAgIHZhciBwYXRoID0gcGFydHNbX0NvbXBvbmVudEluZGV4LlBhdGhdO1xuICAgICAgcGF0aCA9IGlzQmxhbmsocGF0aCkgPyAnJyA6IF9yZW1vdmVEb3RTZWdtZW50cyhwYXRoKTtcbiAgICAgIHBhcnRzW19Db21wb25lbnRJbmRleC5QYXRoXSA9IHBhdGg7XG4gICAgICByZXR1cm4gX2J1aWxkRnJvbUVuY29kZWRQYXJ0cyhwYXJ0c1tfQ29tcG9uZW50SW5kZXguU2NoZW1lXSwgcGFydHNbX0NvbXBvbmVudEluZGV4LlVzZXJJbmZvXSwgcGFydHNbX0NvbXBvbmVudEluZGV4LkRvbWFpbl0sIHBhcnRzW19Db21wb25lbnRJbmRleC5Qb3J0XSwgcGF0aCwgcGFydHNbX0NvbXBvbmVudEluZGV4LlF1ZXJ5RGF0YV0sIHBhcnRzW19Db21wb25lbnRJbmRleC5GcmFnbWVudF0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXNvbHZlcyBhIFVSTC5cbiAgICogQHBhcmFtIGJhc2UgVGhlIFVSTCBhY3RpbmcgYXMgdGhlIGJhc2UgVVJMLlxuICAgKiBAcGFyYW0gdG8gVGhlIFVSTCB0byByZXNvbHZlLlxuICAgKi9cbiAgZnVuY3Rpb24gX3Jlc29sdmVVcmwoYmFzZSwgdXJsKSB7XG4gICAgICB2YXIgcGFydHMgPSBfc3BsaXQoZW5jb2RlVVJJKHVybCkpO1xuICAgICAgdmFyIGJhc2VQYXJ0cyA9IF9zcGxpdChiYXNlKTtcbiAgICAgIGlmIChpc1ByZXNlbnQocGFydHNbX0NvbXBvbmVudEluZGV4LlNjaGVtZV0pKSB7XG4gICAgICAgICAgcmV0dXJuIF9qb2luQW5kQ2Fub25pY2FsaXplUGF0aChwYXJ0cyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgICBwYXJ0c1tfQ29tcG9uZW50SW5kZXguU2NoZW1lXSA9IGJhc2VQYXJ0c1tfQ29tcG9uZW50SW5kZXguU2NoZW1lXTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSBfQ29tcG9uZW50SW5kZXguU2NoZW1lOyBpIDw9IF9Db21wb25lbnRJbmRleC5Qb3J0OyBpKyspIHtcbiAgICAgICAgICBpZiAoaXNCbGFuayhwYXJ0c1tpXSkpIHtcbiAgICAgICAgICAgICAgcGFydHNbaV0gPSBiYXNlUGFydHNbaV07XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBhcnRzW19Db21wb25lbnRJbmRleC5QYXRoXVswXSA9PSAnLycpIHtcbiAgICAgICAgICByZXR1cm4gX2pvaW5BbmRDYW5vbmljYWxpemVQYXRoKHBhcnRzKTtcbiAgICAgIH1cbiAgICAgIHZhciBwYXRoID0gYmFzZVBhcnRzW19Db21wb25lbnRJbmRleC5QYXRoXTtcbiAgICAgIGlmIChpc0JsYW5rKHBhdGgpKVxuICAgICAgICAgIHBhdGggPSAnLyc7XG4gICAgICB2YXIgaW5kZXggPSBwYXRoLmxhc3RJbmRleE9mKCcvJyk7XG4gICAgICBwYXRoID0gcGF0aC5zdWJzdHJpbmcoMCwgaW5kZXggKyAxKSArIHBhcnRzW19Db21wb25lbnRJbmRleC5QYXRoXTtcbiAgICAgIHBhcnRzW19Db21wb25lbnRJbmRleC5QYXRoXSA9IHBhdGg7XG4gICAgICByZXR1cm4gX2pvaW5BbmRDYW5vbmljYWxpemVQYXRoKHBhcnRzKTtcbiAgfVxuXG4gIHZhciBEaXJlY3RpdmVOb3JtYWxpemVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIERpcmVjdGl2ZU5vcm1hbGl6ZXIoX3Jlc291cmNlTG9hZGVyLCBfdXJsUmVzb2x2ZXIsIF9odG1sUGFyc2VyLCBfY29uZmlnKSB7XG4gICAgICAgICAgdGhpcy5fcmVzb3VyY2VMb2FkZXIgPSBfcmVzb3VyY2VMb2FkZXI7XG4gICAgICAgICAgdGhpcy5fdXJsUmVzb2x2ZXIgPSBfdXJsUmVzb2x2ZXI7XG4gICAgICAgICAgdGhpcy5faHRtbFBhcnNlciA9IF9odG1sUGFyc2VyO1xuICAgICAgICAgIHRoaXMuX2NvbmZpZyA9IF9jb25maWc7XG4gICAgICAgICAgdGhpcy5fcmVzb3VyY2VMb2FkZXJDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgIH1cbiAgICAgIERpcmVjdGl2ZU5vcm1hbGl6ZXIucHJvdG90eXBlLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX3Jlc291cmNlTG9hZGVyQ2FjaGUuY2xlYXIoKTsgfTtcbiAgICAgIERpcmVjdGl2ZU5vcm1hbGl6ZXIucHJvdG90eXBlLmNsZWFyQ2FjaGVGb3IgPSBmdW5jdGlvbiAobm9ybWFsaXplZERpcmVjdGl2ZSkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgaWYgKCFub3JtYWxpemVkRGlyZWN0aXZlLmlzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fcmVzb3VyY2VMb2FkZXJDYWNoZS5kZWxldGUobm9ybWFsaXplZERpcmVjdGl2ZS50ZW1wbGF0ZS50ZW1wbGF0ZVVybCk7XG4gICAgICAgICAgbm9ybWFsaXplZERpcmVjdGl2ZS50ZW1wbGF0ZS5leHRlcm5hbFN0eWxlc2hlZXRzLmZvckVhY2goZnVuY3Rpb24gKHN0eWxlc2hlZXQpIHsgX3RoaXMuX3Jlc291cmNlTG9hZGVyQ2FjaGUuZGVsZXRlKHN0eWxlc2hlZXQubW9kdWxlVXJsKTsgfSk7XG4gICAgICB9O1xuICAgICAgRGlyZWN0aXZlTm9ybWFsaXplci5wcm90b3R5cGUuX2ZldGNoID0gZnVuY3Rpb24gKHVybCkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9yZXNvdXJjZUxvYWRlckNhY2hlLmdldCh1cmwpO1xuICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuX3Jlc291cmNlTG9hZGVyLmdldCh1cmwpO1xuICAgICAgICAgICAgICB0aGlzLl9yZXNvdXJjZUxvYWRlckNhY2hlLnNldCh1cmwsIHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgICAgRGlyZWN0aXZlTm9ybWFsaXplci5wcm90b3R5cGUubm9ybWFsaXplRGlyZWN0aXZlID0gZnVuY3Rpb24gKGRpcmVjdGl2ZSkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgaWYgKCFkaXJlY3RpdmUuaXNDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgLy8gRm9yIG5vbiBjb21wb25lbnRzIHRoZXJlIGlzIG5vdGhpbmcgdG8gYmUgbm9ybWFsaXplZCB5ZXQuXG4gICAgICAgICAgICAgIHJldHVybiBuZXcgU3luY0FzeW5jUmVzdWx0KGRpcmVjdGl2ZSwgUHJvbWlzZS5yZXNvbHZlKGRpcmVjdGl2ZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbm9ybWFsaXplZFRlbXBsYXRlU3luYyA9IG51bGw7XG4gICAgICAgICAgdmFyIG5vcm1hbGl6ZWRUZW1wbGF0ZUFzeW5jO1xuICAgICAgICAgIGlmIChpc1ByZXNlbnQoZGlyZWN0aXZlLnRlbXBsYXRlLnRlbXBsYXRlKSkge1xuICAgICAgICAgICAgICBub3JtYWxpemVkVGVtcGxhdGVTeW5jID0gdGhpcy5ub3JtYWxpemVUZW1wbGF0ZVN5bmMoZGlyZWN0aXZlLnR5cGUsIGRpcmVjdGl2ZS50ZW1wbGF0ZSk7XG4gICAgICAgICAgICAgIG5vcm1hbGl6ZWRUZW1wbGF0ZUFzeW5jID0gUHJvbWlzZS5yZXNvbHZlKG5vcm1hbGl6ZWRUZW1wbGF0ZVN5bmMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChkaXJlY3RpdmUudGVtcGxhdGUudGVtcGxhdGVVcmwpIHtcbiAgICAgICAgICAgICAgbm9ybWFsaXplZFRlbXBsYXRlQXN5bmMgPSB0aGlzLm5vcm1hbGl6ZVRlbXBsYXRlQXN5bmMoZGlyZWN0aXZlLnR5cGUsIGRpcmVjdGl2ZS50ZW1wbGF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyB0ZW1wbGF0ZSBzcGVjaWZpZWQgZm9yIGNvbXBvbmVudCBcIiArIGRpcmVjdGl2ZS50eXBlLm5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobm9ybWFsaXplZFRlbXBsYXRlU3luYyAmJiBub3JtYWxpemVkVGVtcGxhdGVTeW5jLnN0eWxlVXJscy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgLy8gc3luYyBjYXNlXG4gICAgICAgICAgICAgIHZhciBub3JtYWxpemVkRGlyZWN0aXZlID0gX2Nsb25lRGlyZWN0aXZlV2l0aFRlbXBsYXRlKGRpcmVjdGl2ZSwgbm9ybWFsaXplZFRlbXBsYXRlU3luYyk7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgU3luY0FzeW5jUmVzdWx0KG5vcm1hbGl6ZWREaXJlY3RpdmUsIFByb21pc2UucmVzb2x2ZShub3JtYWxpemVkRGlyZWN0aXZlKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAvLyBhc3luYyBjYXNlXG4gICAgICAgICAgICAgIHJldHVybiBuZXcgU3luY0FzeW5jUmVzdWx0KG51bGwsIG5vcm1hbGl6ZWRUZW1wbGF0ZUFzeW5jXG4gICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAobm9ybWFsaXplZFRlbXBsYXRlKSB7IHJldHVybiBfdGhpcy5ub3JtYWxpemVFeHRlcm5hbFN0eWxlc2hlZXRzKG5vcm1hbGl6ZWRUZW1wbGF0ZSk7IH0pXG4gICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAobm9ybWFsaXplZFRlbXBsYXRlKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2Nsb25lRGlyZWN0aXZlV2l0aFRlbXBsYXRlKGRpcmVjdGl2ZSwgbm9ybWFsaXplZFRlbXBsYXRlKTtcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBEaXJlY3RpdmVOb3JtYWxpemVyLnByb3RvdHlwZS5ub3JtYWxpemVUZW1wbGF0ZVN5bmMgPSBmdW5jdGlvbiAoZGlyZWN0aXZlVHlwZSwgdGVtcGxhdGUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5ub3JtYWxpemVMb2FkZWRUZW1wbGF0ZShkaXJlY3RpdmVUeXBlLCB0ZW1wbGF0ZSwgdGVtcGxhdGUudGVtcGxhdGUsIGRpcmVjdGl2ZVR5cGUubW9kdWxlVXJsKTtcbiAgICAgIH07XG4gICAgICBEaXJlY3RpdmVOb3JtYWxpemVyLnByb3RvdHlwZS5ub3JtYWxpemVUZW1wbGF0ZUFzeW5jID0gZnVuY3Rpb24gKGRpcmVjdGl2ZVR5cGUsIHRlbXBsYXRlKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgdGVtcGxhdGVVcmwgPSB0aGlzLl91cmxSZXNvbHZlci5yZXNvbHZlKGRpcmVjdGl2ZVR5cGUubW9kdWxlVXJsLCB0ZW1wbGF0ZS50ZW1wbGF0ZVVybCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2ZldGNoKHRlbXBsYXRlVXJsKVxuICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIF90aGlzLm5vcm1hbGl6ZUxvYWRlZFRlbXBsYXRlKGRpcmVjdGl2ZVR5cGUsIHRlbXBsYXRlLCB2YWx1ZSwgdGVtcGxhdGVVcmwpOyB9KTtcbiAgICAgIH07XG4gICAgICBEaXJlY3RpdmVOb3JtYWxpemVyLnByb3RvdHlwZS5ub3JtYWxpemVMb2FkZWRUZW1wbGF0ZSA9IGZ1bmN0aW9uIChkaXJlY3RpdmVUeXBlLCB0ZW1wbGF0ZU1ldGEsIHRlbXBsYXRlLCB0ZW1wbGF0ZUFic1VybCkge1xuICAgICAgICAgIHZhciBpbnRlcnBvbGF0aW9uQ29uZmlnID0gSW50ZXJwb2xhdGlvbkNvbmZpZy5mcm9tQXJyYXkodGVtcGxhdGVNZXRhLmludGVycG9sYXRpb24pO1xuICAgICAgICAgIHZhciByb290Tm9kZXNBbmRFcnJvcnMgPSB0aGlzLl9odG1sUGFyc2VyLnBhcnNlKHRlbXBsYXRlLCBkaXJlY3RpdmVUeXBlLm5hbWUsIGZhbHNlLCBpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgICBpZiAocm9vdE5vZGVzQW5kRXJyb3JzLmVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHZhciBlcnJvclN0cmluZyA9IHJvb3ROb2Rlc0FuZEVycm9ycy5lcnJvcnMuam9pbignXFxuJyk7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRlbXBsYXRlIHBhcnNlIGVycm9yczpcXG5cIiArIGVycm9yU3RyaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHRlbXBsYXRlTWV0YWRhdGFTdHlsZXMgPSB0aGlzLm5vcm1hbGl6ZVN0eWxlc2hlZXQobmV3IENvbXBpbGVTdHlsZXNoZWV0TWV0YWRhdGEoe1xuICAgICAgICAgICAgICBzdHlsZXM6IHRlbXBsYXRlTWV0YS5zdHlsZXMsXG4gICAgICAgICAgICAgIHN0eWxlVXJsczogdGVtcGxhdGVNZXRhLnN0eWxlVXJscyxcbiAgICAgICAgICAgICAgbW9kdWxlVXJsOiBkaXJlY3RpdmVUeXBlLm1vZHVsZVVybFxuICAgICAgICAgIH0pKTtcbiAgICAgICAgICB2YXIgdmlzaXRvciA9IG5ldyBUZW1wbGF0ZVByZXBhcnNlVmlzaXRvcigpO1xuICAgICAgICAgIHZpc2l0QWxsKHZpc2l0b3IsIHJvb3ROb2Rlc0FuZEVycm9ycy5yb290Tm9kZXMpO1xuICAgICAgICAgIHZhciB0ZW1wbGF0ZVN0eWxlcyA9IHRoaXMubm9ybWFsaXplU3R5bGVzaGVldChuZXcgQ29tcGlsZVN0eWxlc2hlZXRNZXRhZGF0YSh7IHN0eWxlczogdmlzaXRvci5zdHlsZXMsIHN0eWxlVXJsczogdmlzaXRvci5zdHlsZVVybHMsIG1vZHVsZVVybDogdGVtcGxhdGVBYnNVcmwgfSkpO1xuICAgICAgICAgIHZhciBlbmNhcHN1bGF0aW9uID0gdGVtcGxhdGVNZXRhLmVuY2Fwc3VsYXRpb247XG4gICAgICAgICAgaWYgKGlzQmxhbmsoZW5jYXBzdWxhdGlvbikpIHtcbiAgICAgICAgICAgICAgZW5jYXBzdWxhdGlvbiA9IHRoaXMuX2NvbmZpZy5kZWZhdWx0RW5jYXBzdWxhdGlvbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHN0eWxlcyA9IHRlbXBsYXRlTWV0YWRhdGFTdHlsZXMuc3R5bGVzLmNvbmNhdCh0ZW1wbGF0ZVN0eWxlcy5zdHlsZXMpO1xuICAgICAgICAgIHZhciBzdHlsZVVybHMgPSB0ZW1wbGF0ZU1ldGFkYXRhU3R5bGVzLnN0eWxlVXJscy5jb25jYXQodGVtcGxhdGVTdHlsZXMuc3R5bGVVcmxzKTtcbiAgICAgICAgICBpZiAoZW5jYXBzdWxhdGlvbiA9PT0gX2FuZ3VsYXJfY29yZS5WaWV3RW5jYXBzdWxhdGlvbi5FbXVsYXRlZCAmJiBzdHlsZXMubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgICAgIHN0eWxlVXJscy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgZW5jYXBzdWxhdGlvbiA9IF9hbmd1bGFyX2NvcmUuVmlld0VuY2Fwc3VsYXRpb24uTm9uZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBDb21waWxlVGVtcGxhdGVNZXRhZGF0YSh7XG4gICAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IGVuY2Fwc3VsYXRpb24sXG4gICAgICAgICAgICAgIHRlbXBsYXRlOiB0ZW1wbGF0ZSxcbiAgICAgICAgICAgICAgdGVtcGxhdGVVcmw6IHRlbXBsYXRlQWJzVXJsLCBzdHlsZXM6IHN0eWxlcywgc3R5bGVVcmxzOiBzdHlsZVVybHMsXG4gICAgICAgICAgICAgIGV4dGVybmFsU3R5bGVzaGVldHM6IHRlbXBsYXRlTWV0YS5leHRlcm5hbFN0eWxlc2hlZXRzLFxuICAgICAgICAgICAgICBuZ0NvbnRlbnRTZWxlY3RvcnM6IHZpc2l0b3IubmdDb250ZW50U2VsZWN0b3JzLFxuICAgICAgICAgICAgICBhbmltYXRpb25zOiB0ZW1wbGF0ZU1ldGEuYW5pbWF0aW9ucyxcbiAgICAgICAgICAgICAgaW50ZXJwb2xhdGlvbjogdGVtcGxhdGVNZXRhLmludGVycG9sYXRpb24sXG4gICAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgRGlyZWN0aXZlTm9ybWFsaXplci5wcm90b3R5cGUubm9ybWFsaXplRXh0ZXJuYWxTdHlsZXNoZWV0cyA9IGZ1bmN0aW9uICh0ZW1wbGF0ZU1ldGEpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fbG9hZE1pc3NpbmdFeHRlcm5hbFN0eWxlc2hlZXRzKHRlbXBsYXRlTWV0YS5zdHlsZVVybHMpXG4gICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChleHRlcm5hbFN0eWxlc2hlZXRzKSB7IHJldHVybiBuZXcgQ29tcGlsZVRlbXBsYXRlTWV0YWRhdGEoe1xuICAgICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiB0ZW1wbGF0ZU1ldGEuZW5jYXBzdWxhdGlvbixcbiAgICAgICAgICAgICAgdGVtcGxhdGU6IHRlbXBsYXRlTWV0YS50ZW1wbGF0ZSxcbiAgICAgICAgICAgICAgdGVtcGxhdGVVcmw6IHRlbXBsYXRlTWV0YS50ZW1wbGF0ZVVybCxcbiAgICAgICAgICAgICAgc3R5bGVzOiB0ZW1wbGF0ZU1ldGEuc3R5bGVzLFxuICAgICAgICAgICAgICBzdHlsZVVybHM6IHRlbXBsYXRlTWV0YS5zdHlsZVVybHMsXG4gICAgICAgICAgICAgIGV4dGVybmFsU3R5bGVzaGVldHM6IGV4dGVybmFsU3R5bGVzaGVldHMsXG4gICAgICAgICAgICAgIG5nQ29udGVudFNlbGVjdG9yczogdGVtcGxhdGVNZXRhLm5nQ29udGVudFNlbGVjdG9ycyxcbiAgICAgICAgICAgICAgYW5pbWF0aW9uczogdGVtcGxhdGVNZXRhLmFuaW1hdGlvbnMsXG4gICAgICAgICAgICAgIGludGVycG9sYXRpb246IHRlbXBsYXRlTWV0YS5pbnRlcnBvbGF0aW9uXG4gICAgICAgICAgfSk7IH0pO1xuICAgICAgfTtcbiAgICAgIERpcmVjdGl2ZU5vcm1hbGl6ZXIucHJvdG90eXBlLl9sb2FkTWlzc2luZ0V4dGVybmFsU3R5bGVzaGVldHMgPSBmdW5jdGlvbiAoc3R5bGVVcmxzLCBsb2FkZWRTdHlsZXNoZWV0cykge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgaWYgKGxvYWRlZFN0eWxlc2hlZXRzID09PSB2b2lkIDApIHsgbG9hZGVkU3R5bGVzaGVldHMgPSBuZXcgTWFwKCk7IH1cbiAgICAgICAgICByZXR1cm4gUHJvbWlzZVxuICAgICAgICAgICAgICAuYWxsKHN0eWxlVXJscy5maWx0ZXIoZnVuY3Rpb24gKHN0eWxlVXJsKSB7IHJldHVybiAhbG9hZGVkU3R5bGVzaGVldHMuaGFzKHN0eWxlVXJsKTsgfSlcbiAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoc3R5bGVVcmwpIHsgcmV0dXJuIF90aGlzLl9mZXRjaChzdHlsZVVybCkudGhlbihmdW5jdGlvbiAobG9hZGVkU3R5bGUpIHtcbiAgICAgICAgICAgICAgdmFyIHN0eWxlc2hlZXQgPSBfdGhpcy5ub3JtYWxpemVTdHlsZXNoZWV0KG5ldyBDb21waWxlU3R5bGVzaGVldE1ldGFkYXRhKHsgc3R5bGVzOiBbbG9hZGVkU3R5bGVdLCBtb2R1bGVVcmw6IHN0eWxlVXJsIH0pKTtcbiAgICAgICAgICAgICAgbG9hZGVkU3R5bGVzaGVldHMuc2V0KHN0eWxlVXJsLCBzdHlsZXNoZWV0KTtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9sb2FkTWlzc2luZ0V4dGVybmFsU3R5bGVzaGVldHMoc3R5bGVzaGVldC5zdHlsZVVybHMsIGxvYWRlZFN0eWxlc2hlZXRzKTtcbiAgICAgICAgICB9KTsgfSkpXG4gICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChfKSB7IHJldHVybiBNYXBXcmFwcGVyLnZhbHVlcyhsb2FkZWRTdHlsZXNoZWV0cyk7IH0pO1xuICAgICAgfTtcbiAgICAgIERpcmVjdGl2ZU5vcm1hbGl6ZXIucHJvdG90eXBlLm5vcm1hbGl6ZVN0eWxlc2hlZXQgPSBmdW5jdGlvbiAoc3R5bGVzaGVldCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIGFsbFN0eWxlVXJscyA9IHN0eWxlc2hlZXQuc3R5bGVVcmxzLmZpbHRlcihpc1N0eWxlVXJsUmVzb2x2YWJsZSlcbiAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAodXJsKSB7IHJldHVybiBfdGhpcy5fdXJsUmVzb2x2ZXIucmVzb2x2ZShzdHlsZXNoZWV0Lm1vZHVsZVVybCwgdXJsKTsgfSk7XG4gICAgICAgICAgdmFyIGFsbFN0eWxlcyA9IHN0eWxlc2hlZXQuc3R5bGVzLm1hcChmdW5jdGlvbiAoc3R5bGUpIHtcbiAgICAgICAgICAgICAgdmFyIHN0eWxlV2l0aEltcG9ydHMgPSBleHRyYWN0U3R5bGVVcmxzKF90aGlzLl91cmxSZXNvbHZlciwgc3R5bGVzaGVldC5tb2R1bGVVcmwsIHN0eWxlKTtcbiAgICAgICAgICAgICAgYWxsU3R5bGVVcmxzLnB1c2guYXBwbHkoYWxsU3R5bGVVcmxzLCBzdHlsZVdpdGhJbXBvcnRzLnN0eWxlVXJscyk7XG4gICAgICAgICAgICAgIHJldHVybiBzdHlsZVdpdGhJbXBvcnRzLnN0eWxlO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBuZXcgQ29tcGlsZVN0eWxlc2hlZXRNZXRhZGF0YSh7IHN0eWxlczogYWxsU3R5bGVzLCBzdHlsZVVybHM6IGFsbFN0eWxlVXJscywgbW9kdWxlVXJsOiBzdHlsZXNoZWV0Lm1vZHVsZVVybCB9KTtcbiAgICAgIH07XG4gICAgICBEaXJlY3RpdmVOb3JtYWxpemVyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcbiAgICAgIF07XG4gICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgIERpcmVjdGl2ZU5vcm1hbGl6ZXIuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgeyB0eXBlOiBSZXNvdXJjZUxvYWRlciwgfSxcbiAgICAgICAgICB7IHR5cGU6IFVybFJlc29sdmVyLCB9LFxuICAgICAgICAgIHsgdHlwZTogSHRtbFBhcnNlciwgfSxcbiAgICAgICAgICB7IHR5cGU6IENvbXBpbGVyQ29uZmlnLCB9LFxuICAgICAgXTtcbiAgICAgIHJldHVybiBEaXJlY3RpdmVOb3JtYWxpemVyO1xuICB9KCkpO1xuICB2YXIgVGVtcGxhdGVQcmVwYXJzZVZpc2l0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gVGVtcGxhdGVQcmVwYXJzZVZpc2l0b3IoKSB7XG4gICAgICAgICAgdGhpcy5uZ0NvbnRlbnRTZWxlY3RvcnMgPSBbXTtcbiAgICAgICAgICB0aGlzLnN0eWxlcyA9IFtdO1xuICAgICAgICAgIHRoaXMuc3R5bGVVcmxzID0gW107XG4gICAgICAgICAgdGhpcy5uZ05vbkJpbmRhYmxlU3RhY2tDb3VudCA9IDA7XG4gICAgICB9XG4gICAgICBUZW1wbGF0ZVByZXBhcnNlVmlzaXRvci5wcm90b3R5cGUudmlzaXRFbGVtZW50ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIHZhciBwcmVwYXJzZWRFbGVtZW50ID0gcHJlcGFyc2VFbGVtZW50KGFzdCk7XG4gICAgICAgICAgc3dpdGNoIChwcmVwYXJzZWRFbGVtZW50LnR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBQcmVwYXJzZWRFbGVtZW50VHlwZS5OR19DT05URU5UOlxuICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubmdOb25CaW5kYWJsZVN0YWNrQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5nQ29udGVudFNlbGVjdG9ycy5wdXNoKHByZXBhcnNlZEVsZW1lbnQuc2VsZWN0QXR0cik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBQcmVwYXJzZWRFbGVtZW50VHlwZS5TVFlMRTpcbiAgICAgICAgICAgICAgICAgIHZhciB0ZXh0Q29udGVudCA9ICcnO1xuICAgICAgICAgICAgICAgICAgYXN0LmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgVGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0Q29udGVudCArPSBjaGlsZC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVzLnB1c2godGV4dENvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgUHJlcGFyc2VkRWxlbWVudFR5cGUuU1RZTEVTSEVFVDpcbiAgICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVVcmxzLnB1c2gocHJlcGFyc2VkRWxlbWVudC5ocmVmQXR0cik7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocHJlcGFyc2VkRWxlbWVudC5ub25CaW5kYWJsZSkge1xuICAgICAgICAgICAgICB0aGlzLm5nTm9uQmluZGFibGVTdGFja0NvdW50Kys7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZpc2l0QWxsKHRoaXMsIGFzdC5jaGlsZHJlbik7XG4gICAgICAgICAgaWYgKHByZXBhcnNlZEVsZW1lbnQubm9uQmluZGFibGUpIHtcbiAgICAgICAgICAgICAgdGhpcy5uZ05vbkJpbmRhYmxlU3RhY2tDb3VudC0tO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBUZW1wbGF0ZVByZXBhcnNlVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb21tZW50ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICAgIFRlbXBsYXRlUHJlcGFyc2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgICBUZW1wbGF0ZVByZXBhcnNlVmlzaXRvci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICAgIFRlbXBsYXRlUHJlcGFyc2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbiA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgICBUZW1wbGF0ZVByZXBhcnNlVmlzaXRvci5wcm90b3R5cGUudmlzaXRFeHBhbnNpb25DYXNlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICAgIHJldHVybiBUZW1wbGF0ZVByZXBhcnNlVmlzaXRvcjtcbiAgfSgpKTtcbiAgZnVuY3Rpb24gX2Nsb25lRGlyZWN0aXZlV2l0aFRlbXBsYXRlKGRpcmVjdGl2ZSwgdGVtcGxhdGUpIHtcbiAgICAgIHJldHVybiBuZXcgQ29tcGlsZURpcmVjdGl2ZU1ldGFkYXRhKHtcbiAgICAgICAgICB0eXBlOiBkaXJlY3RpdmUudHlwZSxcbiAgICAgICAgICBpc0NvbXBvbmVudDogZGlyZWN0aXZlLmlzQ29tcG9uZW50LFxuICAgICAgICAgIHNlbGVjdG9yOiBkaXJlY3RpdmUuc2VsZWN0b3IsXG4gICAgICAgICAgZXhwb3J0QXM6IGRpcmVjdGl2ZS5leHBvcnRBcyxcbiAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IGRpcmVjdGl2ZS5jaGFuZ2VEZXRlY3Rpb24sXG4gICAgICAgICAgaW5wdXRzOiBkaXJlY3RpdmUuaW5wdXRzLFxuICAgICAgICAgIG91dHB1dHM6IGRpcmVjdGl2ZS5vdXRwdXRzLFxuICAgICAgICAgIGhvc3RMaXN0ZW5lcnM6IGRpcmVjdGl2ZS5ob3N0TGlzdGVuZXJzLFxuICAgICAgICAgIGhvc3RQcm9wZXJ0aWVzOiBkaXJlY3RpdmUuaG9zdFByb3BlcnRpZXMsXG4gICAgICAgICAgaG9zdEF0dHJpYnV0ZXM6IGRpcmVjdGl2ZS5ob3N0QXR0cmlidXRlcyxcbiAgICAgICAgICBwcm92aWRlcnM6IGRpcmVjdGl2ZS5wcm92aWRlcnMsXG4gICAgICAgICAgdmlld1Byb3ZpZGVyczogZGlyZWN0aXZlLnZpZXdQcm92aWRlcnMsXG4gICAgICAgICAgcXVlcmllczogZGlyZWN0aXZlLnF1ZXJpZXMsXG4gICAgICAgICAgdmlld1F1ZXJpZXM6IGRpcmVjdGl2ZS52aWV3UXVlcmllcyxcbiAgICAgICAgICBlbnRyeUNvbXBvbmVudHM6IGRpcmVjdGl2ZS5lbnRyeUNvbXBvbmVudHMsIHRlbXBsYXRlOiB0ZW1wbGF0ZSxcbiAgICAgIH0pO1xuICB9XG5cbiAgLypcbiAgICogUmVzb2x2ZSBhIGBUeXBlYCBmb3Ige0BsaW5rIERpcmVjdGl2ZX0uXG4gICAqXG4gICAqIFRoaXMgaW50ZXJmYWNlIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHRoZSBhcHBsaWNhdGlvbiBkZXZlbG9wZXIgdG8gY3JlYXRlIGN1c3RvbSBiZWhhdmlvci5cbiAgICpcbiAgICogU2VlIHtAbGluayBDb21waWxlcn1cbiAgICovXG4gIHZhciBEaXJlY3RpdmVSZXNvbHZlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBEaXJlY3RpdmVSZXNvbHZlcihfcmVmbGVjdG9yKSB7XG4gICAgICAgICAgaWYgKF9yZWZsZWN0b3IgPT09IHZvaWQgMCkgeyBfcmVmbGVjdG9yID0gcmVmbGVjdG9yOyB9XG4gICAgICAgICAgdGhpcy5fcmVmbGVjdG9yID0gX3JlZmxlY3RvcjtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJuIHtAbGluayBEaXJlY3RpdmV9IGZvciBhIGdpdmVuIGBUeXBlYC5cbiAgICAgICAqL1xuICAgICAgRGlyZWN0aXZlUmVzb2x2ZXIucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiAodHlwZSwgdGhyb3dJZk5vdEZvdW5kKSB7XG4gICAgICAgICAgaWYgKHRocm93SWZOb3RGb3VuZCA9PT0gdm9pZCAwKSB7IHRocm93SWZOb3RGb3VuZCA9IHRydWU7IH1cbiAgICAgICAgICB2YXIgdHlwZU1ldGFkYXRhID0gdGhpcy5fcmVmbGVjdG9yLmFubm90YXRpb25zKF9hbmd1bGFyX2NvcmUucmVzb2x2ZUZvcndhcmRSZWYodHlwZSkpO1xuICAgICAgICAgIGlmICh0eXBlTWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgdmFyIG1ldGFkYXRhID0gdHlwZU1ldGFkYXRhLmZpbmQoaXNEaXJlY3RpdmVNZXRhZGF0YSk7XG4gICAgICAgICAgICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5TWV0YWRhdGEgPSB0aGlzLl9yZWZsZWN0b3IucHJvcE1ldGFkYXRhKHR5cGUpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21lcmdlV2l0aFByb3BlcnR5TWV0YWRhdGEobWV0YWRhdGEsIHByb3BlcnR5TWV0YWRhdGEsIHR5cGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aHJvd0lmTm90Rm91bmQpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gRGlyZWN0aXZlIGFubm90YXRpb24gZm91bmQgb24gXCIgKyBzdHJpbmdpZnkodHlwZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBEaXJlY3RpdmVSZXNvbHZlci5wcm90b3R5cGUuX21lcmdlV2l0aFByb3BlcnR5TWV0YWRhdGEgPSBmdW5jdGlvbiAoZG0sIHByb3BlcnR5TWV0YWRhdGEsIGRpcmVjdGl2ZVR5cGUpIHtcbiAgICAgICAgICB2YXIgaW5wdXRzID0gW107XG4gICAgICAgICAgdmFyIG91dHB1dHMgPSBbXTtcbiAgICAgICAgICB2YXIgaG9zdCA9IHt9O1xuICAgICAgICAgIHZhciBxdWVyaWVzID0ge307XG4gICAgICAgICAgT2JqZWN0LmtleXMocHJvcGVydHlNZXRhZGF0YSkuZm9yRWFjaChmdW5jdGlvbiAocHJvcE5hbWUpIHtcbiAgICAgICAgICAgICAgcHJvcGVydHlNZXRhZGF0YVtwcm9wTmFtZV0uZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgICAgaWYgKGEgaW5zdGFuY2VvZiBfYW5ndWxhcl9jb3JlLklucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGEuYmluZGluZ1Byb3BlcnR5TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dHMucHVzaChwcm9wTmFtZSArIFwiOiBcIiArIGEuYmluZGluZ1Byb3BlcnR5TmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dHMucHVzaChwcm9wTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYSBpbnN0YW5jZW9mIF9hbmd1bGFyX2NvcmUuT3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIG91dHB1dCA9IGE7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKG91dHB1dC5iaW5kaW5nUHJvcGVydHlOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dHMucHVzaChwcm9wTmFtZSArIFwiOiBcIiArIG91dHB1dC5iaW5kaW5nUHJvcGVydHlOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dHMucHVzaChwcm9wTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYSBpbnN0YW5jZW9mIF9hbmd1bGFyX2NvcmUuSG9zdEJpbmRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgaG9zdEJpbmRpbmcgPSBhO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChob3N0QmluZGluZy5ob3N0UHJvcGVydHlOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGFydFdpdGggPSBob3N0QmluZGluZy5ob3N0UHJvcGVydHlOYW1lWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnRXaXRoID09PSAnKCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkBIb3N0QmluZGluZyBjYW4gbm90IGJpbmQgdG8gZXZlbnRzLiBVc2UgQEhvc3RMaXN0ZW5lciBpbnN0ZWFkLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzdGFydFdpdGggPT09ICdbJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQEhvc3RCaW5kaW5nIHBhcmFtZXRlciBzaG91bGQgYmUgYSBwcm9wZXJ0eSBuYW1lLCAnY2xhc3MuPG5hbWU+Jywgb3IgJ2F0dHIuPG5hbWU+Jy5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgaG9zdFsoXCJbXCIgKyBob3N0QmluZGluZy5ob3N0UHJvcGVydHlOYW1lICsgXCJdXCIpXSA9IHByb3BOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaG9zdFsoXCJbXCIgKyBwcm9wTmFtZSArIFwiXVwiKV0gPSBwcm9wTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIGlmIChhIGluc3RhbmNlb2YgX2FuZ3VsYXJfY29yZS5Ib3N0TGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgaG9zdExpc3RlbmVyID0gYTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IGhvc3RMaXN0ZW5lci5hcmdzIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICAgIGhvc3RbKFwiKFwiICsgaG9zdExpc3RlbmVyLmV2ZW50TmFtZSArIFwiKVwiKV0gPSBwcm9wTmFtZSArIFwiKFwiICsgYXJncy5qb2luKCcsJykgKyBcIilcIjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGEgaW5zdGFuY2VvZiBfYW5ndWxhcl9jb3JlLlF1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgcXVlcmllc1twcm9wTmFtZV0gPSBhO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fbWVyZ2UoZG0sIGlucHV0cywgb3V0cHV0cywgaG9zdCwgcXVlcmllcywgZGlyZWN0aXZlVHlwZSk7XG4gICAgICB9O1xuICAgICAgRGlyZWN0aXZlUmVzb2x2ZXIucHJvdG90eXBlLl9leHRyYWN0UHVibGljTmFtZSA9IGZ1bmN0aW9uIChkZWYpIHsgcmV0dXJuIHNwbGl0QXRDb2xvbihkZWYsIFtudWxsLCBkZWZdKVsxXS50cmltKCk7IH07XG4gICAgICBEaXJlY3RpdmVSZXNvbHZlci5wcm90b3R5cGUuX21lcmdlID0gZnVuY3Rpb24gKGRpcmVjdGl2ZSwgaW5wdXRzLCBvdXRwdXRzLCBob3N0LCBxdWVyaWVzLCBkaXJlY3RpdmVUeXBlKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgbWVyZ2VkSW5wdXRzID0gaW5wdXRzO1xuICAgICAgICAgIGlmIChkaXJlY3RpdmUuaW5wdXRzKSB7XG4gICAgICAgICAgICAgIHZhciBpbnB1dE5hbWVzXzEgPSBkaXJlY3RpdmUuaW5wdXRzLm1hcChmdW5jdGlvbiAoZGVmKSB7IHJldHVybiBfdGhpcy5fZXh0cmFjdFB1YmxpY05hbWUoZGVmKTsgfSk7XG4gICAgICAgICAgICAgIGlucHV0cy5mb3JFYWNoKGZ1bmN0aW9uIChpbnB1dERlZikge1xuICAgICAgICAgICAgICAgICAgdmFyIHB1YmxpY05hbWUgPSBfdGhpcy5fZXh0cmFjdFB1YmxpY05hbWUoaW5wdXREZWYpO1xuICAgICAgICAgICAgICAgICAgaWYgKGlucHV0TmFtZXNfMS5pbmRleE9mKHB1YmxpY05hbWUpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCAnXCIgKyBwdWJsaWNOYW1lICsgXCInIGRlZmluZWQgbXVsdGlwbGUgdGltZXMgaW4gJ1wiICsgc3RyaW5naWZ5KGRpcmVjdGl2ZVR5cGUpICsgXCInXCIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgbWVyZ2VkSW5wdXRzLnVuc2hpZnQuYXBwbHkobWVyZ2VkSW5wdXRzLCBkaXJlY3RpdmUuaW5wdXRzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG1lcmdlZE91dHB1dHMgPSBvdXRwdXRzO1xuICAgICAgICAgIGlmIChkaXJlY3RpdmUub3V0cHV0cykge1xuICAgICAgICAgICAgICB2YXIgb3V0cHV0TmFtZXNfMSA9IGRpcmVjdGl2ZS5vdXRwdXRzLm1hcChmdW5jdGlvbiAoZGVmKSB7IHJldHVybiBfdGhpcy5fZXh0cmFjdFB1YmxpY05hbWUoZGVmKTsgfSk7XG4gICAgICAgICAgICAgIG91dHB1dHMuZm9yRWFjaChmdW5jdGlvbiAob3V0cHV0RGVmKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcHVibGljTmFtZSA9IF90aGlzLl9leHRyYWN0UHVibGljTmFtZShvdXRwdXREZWYpO1xuICAgICAgICAgICAgICAgICAgaWYgKG91dHB1dE5hbWVzXzEuaW5kZXhPZihwdWJsaWNOYW1lKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT3V0cHV0IGV2ZW50ICdcIiArIHB1YmxpY05hbWUgKyBcIicgZGVmaW5lZCBtdWx0aXBsZSB0aW1lcyBpbiAnXCIgKyBzdHJpbmdpZnkoZGlyZWN0aXZlVHlwZSkgKyBcIidcIik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBtZXJnZWRPdXRwdXRzLnVuc2hpZnQuYXBwbHkobWVyZ2VkT3V0cHV0cywgZGlyZWN0aXZlLm91dHB1dHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbWVyZ2VkSG9zdCA9IGRpcmVjdGl2ZS5ob3N0ID8gU3RyaW5nTWFwV3JhcHBlci5tZXJnZShkaXJlY3RpdmUuaG9zdCwgaG9zdCkgOiBob3N0O1xuICAgICAgICAgIHZhciBtZXJnZWRRdWVyaWVzID0gZGlyZWN0aXZlLnF1ZXJpZXMgPyBTdHJpbmdNYXBXcmFwcGVyLm1lcmdlKGRpcmVjdGl2ZS5xdWVyaWVzLCBxdWVyaWVzKSA6IHF1ZXJpZXM7XG4gICAgICAgICAgaWYgKGRpcmVjdGl2ZSBpbnN0YW5jZW9mIF9hbmd1bGFyX2NvcmUuQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgX2FuZ3VsYXJfY29yZS5Db21wb25lbnQoe1xuICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6IGRpcmVjdGl2ZS5zZWxlY3RvcixcbiAgICAgICAgICAgICAgICAgIGlucHV0czogbWVyZ2VkSW5wdXRzLFxuICAgICAgICAgICAgICAgICAgb3V0cHV0czogbWVyZ2VkT3V0cHV0cyxcbiAgICAgICAgICAgICAgICAgIGhvc3Q6IG1lcmdlZEhvc3QsXG4gICAgICAgICAgICAgICAgICBleHBvcnRBczogZGlyZWN0aXZlLmV4cG9ydEFzLFxuICAgICAgICAgICAgICAgICAgbW9kdWxlSWQ6IGRpcmVjdGl2ZS5tb2R1bGVJZCxcbiAgICAgICAgICAgICAgICAgIHF1ZXJpZXM6IG1lcmdlZFF1ZXJpZXMsXG4gICAgICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IGRpcmVjdGl2ZS5jaGFuZ2VEZXRlY3Rpb24sXG4gICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IGRpcmVjdGl2ZS5wcm92aWRlcnMsXG4gICAgICAgICAgICAgICAgICB2aWV3UHJvdmlkZXJzOiBkaXJlY3RpdmUudmlld1Byb3ZpZGVycyxcbiAgICAgICAgICAgICAgICAgIGVudHJ5Q29tcG9uZW50czogZGlyZWN0aXZlLmVudHJ5Q29tcG9uZW50cyxcbiAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBkaXJlY3RpdmUudGVtcGxhdGUsXG4gICAgICAgICAgICAgICAgICB0ZW1wbGF0ZVVybDogZGlyZWN0aXZlLnRlbXBsYXRlVXJsLFxuICAgICAgICAgICAgICAgICAgc3R5bGVzOiBkaXJlY3RpdmUuc3R5bGVzLFxuICAgICAgICAgICAgICAgICAgc3R5bGVVcmxzOiBkaXJlY3RpdmUuc3R5bGVVcmxzLFxuICAgICAgICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogZGlyZWN0aXZlLmVuY2Fwc3VsYXRpb24sXG4gICAgICAgICAgICAgICAgICBhbmltYXRpb25zOiBkaXJlY3RpdmUuYW5pbWF0aW9ucyxcbiAgICAgICAgICAgICAgICAgIGludGVycG9sYXRpb246IGRpcmVjdGl2ZS5pbnRlcnBvbGF0aW9uXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSh7XG4gICAgICAgICAgICAgICAgICBzZWxlY3RvcjogZGlyZWN0aXZlLnNlbGVjdG9yLFxuICAgICAgICAgICAgICAgICAgaW5wdXRzOiBtZXJnZWRJbnB1dHMsXG4gICAgICAgICAgICAgICAgICBvdXRwdXRzOiBtZXJnZWRPdXRwdXRzLFxuICAgICAgICAgICAgICAgICAgaG9zdDogbWVyZ2VkSG9zdCxcbiAgICAgICAgICAgICAgICAgIGV4cG9ydEFzOiBkaXJlY3RpdmUuZXhwb3J0QXMsXG4gICAgICAgICAgICAgICAgICBxdWVyaWVzOiBtZXJnZWRRdWVyaWVzLFxuICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBkaXJlY3RpdmUucHJvdmlkZXJzXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBEaXJlY3RpdmVSZXNvbHZlci5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG4gICAgICBdO1xuICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICBEaXJlY3RpdmVSZXNvbHZlci5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICB7IHR5cGU6IFJlZmxlY3RvclJlYWRlciwgfSxcbiAgICAgIF07XG4gICAgICByZXR1cm4gRGlyZWN0aXZlUmVzb2x2ZXI7XG4gIH0oKSk7XG4gIGZ1bmN0aW9uIGlzRGlyZWN0aXZlTWV0YWRhdGEodHlwZSkge1xuICAgICAgcmV0dXJuIHR5cGUgaW5zdGFuY2VvZiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc0xpZmVjeWNsZUhvb2soaG9vaywgdG9rZW4pIHtcbiAgICAgIHJldHVybiByZWZsZWN0b3IuaGFzTGlmZWN5Y2xlSG9vayh0b2tlbiwgZ2V0SG9va05hbWUoaG9vaykpO1xuICB9XG4gIGZ1bmN0aW9uIGdldEhvb2tOYW1lKGhvb2spIHtcbiAgICAgIHN3aXRjaCAoaG9vaykge1xuICAgICAgICAgIGNhc2UgTGlmZWN5Y2xlSG9va3MuT25Jbml0OlxuICAgICAgICAgICAgICByZXR1cm4gJ25nT25Jbml0JztcbiAgICAgICAgICBjYXNlIExpZmVjeWNsZUhvb2tzLk9uRGVzdHJveTpcbiAgICAgICAgICAgICAgcmV0dXJuICduZ09uRGVzdHJveSc7XG4gICAgICAgICAgY2FzZSBMaWZlY3ljbGVIb29rcy5Eb0NoZWNrOlxuICAgICAgICAgICAgICByZXR1cm4gJ25nRG9DaGVjayc7XG4gICAgICAgICAgY2FzZSBMaWZlY3ljbGVIb29rcy5PbkNoYW5nZXM6XG4gICAgICAgICAgICAgIHJldHVybiAnbmdPbkNoYW5nZXMnO1xuICAgICAgICAgIGNhc2UgTGlmZWN5Y2xlSG9va3MuQWZ0ZXJDb250ZW50SW5pdDpcbiAgICAgICAgICAgICAgcmV0dXJuICduZ0FmdGVyQ29udGVudEluaXQnO1xuICAgICAgICAgIGNhc2UgTGlmZWN5Y2xlSG9va3MuQWZ0ZXJDb250ZW50Q2hlY2tlZDpcbiAgICAgICAgICAgICAgcmV0dXJuICduZ0FmdGVyQ29udGVudENoZWNrZWQnO1xuICAgICAgICAgIGNhc2UgTGlmZWN5Y2xlSG9va3MuQWZ0ZXJWaWV3SW5pdDpcbiAgICAgICAgICAgICAgcmV0dXJuICduZ0FmdGVyVmlld0luaXQnO1xuICAgICAgICAgIGNhc2UgTGlmZWN5Y2xlSG9va3MuQWZ0ZXJWaWV3Q2hlY2tlZDpcbiAgICAgICAgICAgICAgcmV0dXJuICduZ0FmdGVyVmlld0NoZWNrZWQnO1xuICAgICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2lzTmdNb2R1bGVNZXRhZGF0YShvYmopIHtcbiAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBfYW5ndWxhcl9jb3JlLk5nTW9kdWxlO1xuICB9XG4gIC8qKlxuICAgKiBSZXNvbHZlcyB0eXBlcyB0byB7QGxpbmsgTmdNb2R1bGV9LlxuICAgKi9cbiAgdmFyIE5nTW9kdWxlUmVzb2x2ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gTmdNb2R1bGVSZXNvbHZlcihfcmVmbGVjdG9yKSB7XG4gICAgICAgICAgaWYgKF9yZWZsZWN0b3IgPT09IHZvaWQgMCkgeyBfcmVmbGVjdG9yID0gcmVmbGVjdG9yOyB9XG4gICAgICAgICAgdGhpcy5fcmVmbGVjdG9yID0gX3JlZmxlY3RvcjtcbiAgICAgIH1cbiAgICAgIE5nTW9kdWxlUmVzb2x2ZXIucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiAodHlwZSwgdGhyb3dJZk5vdEZvdW5kKSB7XG4gICAgICAgICAgaWYgKHRocm93SWZOb3RGb3VuZCA9PT0gdm9pZCAwKSB7IHRocm93SWZOb3RGb3VuZCA9IHRydWU7IH1cbiAgICAgICAgICB2YXIgbmdNb2R1bGVNZXRhID0gdGhpcy5fcmVmbGVjdG9yLmFubm90YXRpb25zKHR5cGUpLmZpbmQoX2lzTmdNb2R1bGVNZXRhZGF0YSk7XG4gICAgICAgICAgaWYgKGlzUHJlc2VudChuZ01vZHVsZU1ldGEpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZ01vZHVsZU1ldGE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBpZiAodGhyb3dJZk5vdEZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBOZ01vZHVsZSBtZXRhZGF0YSBmb3VuZCBmb3IgJ1wiICsgc3RyaW5naWZ5KHR5cGUpICsgXCInLlwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgTmdNb2R1bGVSZXNvbHZlci5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG4gICAgICBdO1xuICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICBOZ01vZHVsZVJlc29sdmVyLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgIHsgdHlwZTogUmVmbGVjdG9yUmVhZGVyLCB9LFxuICAgICAgXTtcbiAgICAgIHJldHVybiBOZ01vZHVsZVJlc29sdmVyO1xuICB9KCkpO1xuXG4gIGZ1bmN0aW9uIF9pc1BpcGVNZXRhZGF0YSh0eXBlKSB7XG4gICAgICByZXR1cm4gdHlwZSBpbnN0YW5jZW9mIF9hbmd1bGFyX2NvcmUuUGlwZTtcbiAgfVxuICAvKipcbiAgICogUmVzb2x2ZSBhIGBUeXBlYCBmb3Ige0BsaW5rIFBpcGV9LlxuICAgKlxuICAgKiBUaGlzIGludGVyZmFjZSBjYW4gYmUgb3ZlcnJpZGRlbiBieSB0aGUgYXBwbGljYXRpb24gZGV2ZWxvcGVyIHRvIGNyZWF0ZSBjdXN0b20gYmVoYXZpb3IuXG4gICAqXG4gICAqIFNlZSB7QGxpbmsgQ29tcGlsZXJ9XG4gICAqL1xuICB2YXIgUGlwZVJlc29sdmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFBpcGVSZXNvbHZlcihfcmVmbGVjdG9yKSB7XG4gICAgICAgICAgaWYgKF9yZWZsZWN0b3IgPT09IHZvaWQgMCkgeyBfcmVmbGVjdG9yID0gcmVmbGVjdG9yOyB9XG4gICAgICAgICAgdGhpcy5fcmVmbGVjdG9yID0gX3JlZmxlY3RvcjtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJuIHtAbGluayBQaXBlfSBmb3IgYSBnaXZlbiBgVHlwZWAuXG4gICAgICAgKi9cbiAgICAgIFBpcGVSZXNvbHZlci5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uICh0eXBlLCB0aHJvd0lmTm90Rm91bmQpIHtcbiAgICAgICAgICBpZiAodGhyb3dJZk5vdEZvdW5kID09PSB2b2lkIDApIHsgdGhyb3dJZk5vdEZvdW5kID0gdHJ1ZTsgfVxuICAgICAgICAgIHZhciBtZXRhcyA9IHRoaXMuX3JlZmxlY3Rvci5hbm5vdGF0aW9ucyhfYW5ndWxhcl9jb3JlLnJlc29sdmVGb3J3YXJkUmVmKHR5cGUpKTtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KG1ldGFzKSkge1xuICAgICAgICAgICAgICB2YXIgYW5ub3RhdGlvbiA9IG1ldGFzLmZpbmQoX2lzUGlwZU1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudChhbm5vdGF0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGFubm90YXRpb247XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRocm93SWZOb3RGb3VuZCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBQaXBlIGRlY29yYXRvciBmb3VuZCBvbiBcIiArIHN0cmluZ2lmeSh0eXBlKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIFBpcGVSZXNvbHZlci5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG4gICAgICBdO1xuICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICBQaXBlUmVzb2x2ZXIuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgeyB0eXBlOiBSZWZsZWN0b3JSZWFkZXIsIH0sXG4gICAgICBdO1xuICAgICAgcmV0dXJuIFBpcGVSZXNvbHZlcjtcbiAgfSgpKTtcblxuICAvKipcbiAgICogQGxpY2Vuc2VcbiAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAqXG4gICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICovXG4gIHZhciBfX2V4dGVuZHMkMTYgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gIH07XG4gIHZhciBDb21waWxlTWV0YWRhdGFSZXNvbHZlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBDb21waWxlTWV0YWRhdGFSZXNvbHZlcihfbmdNb2R1bGVSZXNvbHZlciwgX2RpcmVjdGl2ZVJlc29sdmVyLCBfcGlwZVJlc29sdmVyLCBfc2NoZW1hUmVnaXN0cnksIF9yZWZsZWN0b3IpIHtcbiAgICAgICAgICBpZiAoX3JlZmxlY3RvciA9PT0gdm9pZCAwKSB7IF9yZWZsZWN0b3IgPSByZWZsZWN0b3I7IH1cbiAgICAgICAgICB0aGlzLl9uZ01vZHVsZVJlc29sdmVyID0gX25nTW9kdWxlUmVzb2x2ZXI7XG4gICAgICAgICAgdGhpcy5fZGlyZWN0aXZlUmVzb2x2ZXIgPSBfZGlyZWN0aXZlUmVzb2x2ZXI7XG4gICAgICAgICAgdGhpcy5fcGlwZVJlc29sdmVyID0gX3BpcGVSZXNvbHZlcjtcbiAgICAgICAgICB0aGlzLl9zY2hlbWFSZWdpc3RyeSA9IF9zY2hlbWFSZWdpc3RyeTtcbiAgICAgICAgICB0aGlzLl9yZWZsZWN0b3IgPSBfcmVmbGVjdG9yO1xuICAgICAgICAgIHRoaXMuX2RpcmVjdGl2ZUNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICAgIHRoaXMuX3BpcGVDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgICB0aGlzLl9uZ01vZHVsZUNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICAgIHRoaXMuX25nTW9kdWxlT2ZUeXBlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICB0aGlzLl9hbm9ueW1vdXNUeXBlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICB0aGlzLl9hbm9ueW1vdXNUeXBlSW5kZXggPSAwO1xuICAgICAgfVxuICAgICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLnNhbml0aXplVG9rZW5OYW1lID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgICAgdmFyIGlkZW50aWZpZXIgPSBzdHJpbmdpZnkodG9rZW4pO1xuICAgICAgICAgIGlmIChpZGVudGlmaWVyLmluZGV4T2YoJygnKSA+PSAwKSB7XG4gICAgICAgICAgICAgIC8vIGNhc2U6IGFub255bW91cyBmdW5jdGlvbnMhXG4gICAgICAgICAgICAgIHZhciBmb3VuZCA9IHRoaXMuX2Fub255bW91c1R5cGVzLmdldCh0b2tlbik7XG4gICAgICAgICAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2Fub255bW91c1R5cGVzLnNldCh0b2tlbiwgdGhpcy5fYW5vbnltb3VzVHlwZUluZGV4KyspO1xuICAgICAgICAgICAgICAgICAgZm91bmQgPSB0aGlzLl9hbm9ueW1vdXNUeXBlcy5nZXQodG9rZW4pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlkZW50aWZpZXIgPSBcImFub255bW91c190b2tlbl9cIiArIGZvdW5kICsgXCJfXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzYW5pdGl6ZUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgICB9O1xuICAgICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmNsZWFyQ2FjaGVGb3IgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgIHRoaXMuX2RpcmVjdGl2ZUNhY2hlLmRlbGV0ZSh0eXBlKTtcbiAgICAgICAgICB0aGlzLl9waXBlQ2FjaGUuZGVsZXRlKHR5cGUpO1xuICAgICAgICAgIHRoaXMuX25nTW9kdWxlT2ZUeXBlcy5kZWxldGUodHlwZSk7XG4gICAgICAgICAgLy8gQ2xlYXIgYWxsIG9mIHRoZSBOZ01vZHVsZSBhcyB0aGV5IGNvbnRhaW4gdHJhbnNpdGl2ZSBpbmZvcm1hdGlvbiFcbiAgICAgICAgICB0aGlzLl9uZ01vZHVsZUNhY2hlLmNsZWFyKCk7XG4gICAgICB9O1xuICAgICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy5fZGlyZWN0aXZlQ2FjaGUuY2xlYXIoKTtcbiAgICAgICAgICB0aGlzLl9waXBlQ2FjaGUuY2xlYXIoKTtcbiAgICAgICAgICB0aGlzLl9uZ01vZHVsZUNhY2hlLmNsZWFyKCk7XG4gICAgICAgICAgdGhpcy5fbmdNb2R1bGVPZlR5cGVzLmNsZWFyKCk7XG4gICAgICB9O1xuICAgICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmdldEFuaW1hdGlvbkVudHJ5TWV0YWRhdGEgPSBmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBkZWZzID0gZW50cnkuZGVmaW5pdGlvbnMubWFwKGZ1bmN0aW9uIChkZWYpIHsgcmV0dXJuIF90aGlzLmdldEFuaW1hdGlvblN0YXRlTWV0YWRhdGEoZGVmKTsgfSk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBDb21waWxlQW5pbWF0aW9uRW50cnlNZXRhZGF0YShlbnRyeS5uYW1lLCBkZWZzKTtcbiAgICAgIH07XG4gICAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuZ2V0QW5pbWF0aW9uU3RhdGVNZXRhZGF0YSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIF9hbmd1bGFyX2NvcmUuQW5pbWF0aW9uU3RhdGVEZWNsYXJhdGlvbk1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgIHZhciBzdHlsZXMgPSB0aGlzLmdldEFuaW1hdGlvblN0eWxlTWV0YWRhdGEodmFsdWUuc3R5bGVzKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21waWxlQW5pbWF0aW9uU3RhdGVEZWNsYXJhdGlvbk1ldGFkYXRhKHZhbHVlLnN0YXRlTmFtZUV4cHIsIHN0eWxlcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIF9hbmd1bGFyX2NvcmUuQW5pbWF0aW9uU3RhdGVUcmFuc2l0aW9uTWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21waWxlQW5pbWF0aW9uU3RhdGVUcmFuc2l0aW9uTWV0YWRhdGEodmFsdWUuc3RhdGVDaGFuZ2VFeHByLCB0aGlzLmdldEFuaW1hdGlvbk1ldGFkYXRhKHZhbHVlLnN0ZXBzKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5nZXRBbmltYXRpb25TdHlsZU1ldGFkYXRhID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBDb21waWxlQW5pbWF0aW9uU3R5bGVNZXRhZGF0YSh2YWx1ZS5vZmZzZXQsIHZhbHVlLnN0eWxlcyk7XG4gICAgICB9O1xuICAgICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmdldEFuaW1hdGlvbk1ldGFkYXRhID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBfYW5ndWxhcl9jb3JlLkFuaW1hdGlvblN0eWxlTWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QW5pbWF0aW9uU3R5bGVNZXRhZGF0YSh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIF9hbmd1bGFyX2NvcmUuQW5pbWF0aW9uS2V5ZnJhbWVzU2VxdWVuY2VNZXRhZGF0YSkge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbXBpbGVBbmltYXRpb25LZXlmcmFtZXNTZXF1ZW5jZU1ldGFkYXRhKHZhbHVlLnN0ZXBzLm1hcChmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuIF90aGlzLmdldEFuaW1hdGlvblN0eWxlTWV0YWRhdGEoZW50cnkpOyB9KSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIF9hbmd1bGFyX2NvcmUuQW5pbWF0aW9uQW5pbWF0ZU1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgIHZhciBhbmltYXRlRGF0YSA9IHRoaXNcbiAgICAgICAgICAgICAgICAgIC5nZXRBbmltYXRpb25NZXRhZGF0YSh2YWx1ZS5zdHlsZXMpO1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbXBpbGVBbmltYXRpb25BbmltYXRlTWV0YWRhdGEodmFsdWUudGltaW5ncywgYW5pbWF0ZURhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBfYW5ndWxhcl9jb3JlLkFuaW1hdGlvbldpdGhTdGVwc01ldGFkYXRhKSB7XG4gICAgICAgICAgICAgIHZhciBzdGVwcyA9IHZhbHVlLnN0ZXBzLm1hcChmdW5jdGlvbiAoc3RlcCkgeyByZXR1cm4gX3RoaXMuZ2V0QW5pbWF0aW9uTWV0YWRhdGEoc3RlcCk7IH0pO1xuICAgICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBfYW5ndWxhcl9jb3JlLkFuaW1hdGlvbkdyb3VwTWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcGlsZUFuaW1hdGlvbkdyb3VwTWV0YWRhdGEoc3RlcHMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcGlsZUFuaW1hdGlvblNlcXVlbmNlTWV0YWRhdGEoc3RlcHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuZ2V0RGlyZWN0aXZlTWV0YWRhdGEgPSBmdW5jdGlvbiAoZGlyZWN0aXZlVHlwZSwgdGhyb3dJZk5vdEZvdW5kKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICBpZiAodGhyb3dJZk5vdEZvdW5kID09PSB2b2lkIDApIHsgdGhyb3dJZk5vdEZvdW5kID0gdHJ1ZTsgfVxuICAgICAgICAgIGRpcmVjdGl2ZVR5cGUgPSBfYW5ndWxhcl9jb3JlLnJlc29sdmVGb3J3YXJkUmVmKGRpcmVjdGl2ZVR5cGUpO1xuICAgICAgICAgIHZhciBtZXRhID0gdGhpcy5fZGlyZWN0aXZlQ2FjaGUuZ2V0KGRpcmVjdGl2ZVR5cGUpO1xuICAgICAgICAgIGlmICghbWV0YSkge1xuICAgICAgICAgICAgICB2YXIgZGlyTWV0YSA9IHRoaXMuX2RpcmVjdGl2ZVJlc29sdmVyLnJlc29sdmUoZGlyZWN0aXZlVHlwZSwgdGhyb3dJZk5vdEZvdW5kKTtcbiAgICAgICAgICAgICAgaWYgKCFkaXJNZXRhKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgdGVtcGxhdGVNZXRhID0gbnVsbDtcbiAgICAgICAgICAgICAgdmFyIGNoYW5nZURldGVjdGlvblN0cmF0ZWd5ID0gbnVsbDtcbiAgICAgICAgICAgICAgdmFyIHZpZXdQcm92aWRlcnMgPSBbXTtcbiAgICAgICAgICAgICAgdmFyIG1vZHVsZVVybCA9IHN0YXRpY1R5cGVNb2R1bGVVcmwoZGlyZWN0aXZlVHlwZSk7XG4gICAgICAgICAgICAgIHZhciBlbnRyeUNvbXBvbmVudE1ldGFkYXRhID0gW107XG4gICAgICAgICAgICAgIHZhciBzZWxlY3RvciA9IGRpck1ldGEuc2VsZWN0b3I7XG4gICAgICAgICAgICAgIGlmIChkaXJNZXRhIGluc3RhbmNlb2YgX2FuZ3VsYXJfY29yZS5Db21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgIC8vIENvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgYXNzZXJ0QXJyYXlPZlN0cmluZ3MoJ3N0eWxlcycsIGRpck1ldGEuc3R5bGVzKTtcbiAgICAgICAgICAgICAgICAgIGFzc2VydEFycmF5T2ZTdHJpbmdzKCdzdHlsZVVybHMnLCBkaXJNZXRhLnN0eWxlVXJscyk7XG4gICAgICAgICAgICAgICAgICBhc3NlcnRJbnRlcnBvbGF0aW9uU3ltYm9scygnaW50ZXJwb2xhdGlvbicsIGRpck1ldGEuaW50ZXJwb2xhdGlvbik7XG4gICAgICAgICAgICAgICAgICB2YXIgYW5pbWF0aW9ucyA9IGRpck1ldGEuYW5pbWF0aW9ucyA/XG4gICAgICAgICAgICAgICAgICAgICAgZGlyTWV0YS5hbmltYXRpb25zLm1hcChmdW5jdGlvbiAoZSkgeyByZXR1cm4gX3RoaXMuZ2V0QW5pbWF0aW9uRW50cnlNZXRhZGF0YShlKTsgfSkgOlxuICAgICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgICAgICAgICAgICAgICB0ZW1wbGF0ZU1ldGEgPSBuZXcgQ29tcGlsZVRlbXBsYXRlTWV0YWRhdGEoe1xuICAgICAgICAgICAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IGRpck1ldGEuZW5jYXBzdWxhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogZGlyTWV0YS50ZW1wbGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZVVybDogZGlyTWV0YS50ZW1wbGF0ZVVybCxcbiAgICAgICAgICAgICAgICAgICAgICBzdHlsZXM6IGRpck1ldGEuc3R5bGVzLFxuICAgICAgICAgICAgICAgICAgICAgIHN0eWxlVXJsczogZGlyTWV0YS5zdHlsZVVybHMsXG4gICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uczogYW5pbWF0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICBpbnRlcnBvbGF0aW9uOiBkaXJNZXRhLmludGVycG9sYXRpb25cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kgPSBkaXJNZXRhLmNoYW5nZURldGVjdGlvbjtcbiAgICAgICAgICAgICAgICAgIGlmIChkaXJNZXRhLnZpZXdQcm92aWRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2aWV3UHJvdmlkZXJzID0gdGhpcy5nZXRQcm92aWRlcnNNZXRhZGF0YShkaXJNZXRhLnZpZXdQcm92aWRlcnMsIGVudHJ5Q29tcG9uZW50TWV0YWRhdGEsIFwidmlld1Byb3ZpZGVycyBmb3IgXFxcIlwiICsgc3RyaW5naWZ5KGRpcmVjdGl2ZVR5cGUpICsgXCJcXFwiXCIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgbW9kdWxlVXJsID0gY29tcG9uZW50TW9kdWxlVXJsKHRoaXMuX3JlZmxlY3RvciwgZGlyZWN0aXZlVHlwZSwgZGlyTWV0YSk7XG4gICAgICAgICAgICAgICAgICBpZiAoZGlyTWV0YS5lbnRyeUNvbXBvbmVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICBlbnRyeUNvbXBvbmVudE1ldGFkYXRhID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgZmxhdHRlbkFycmF5KGRpck1ldGEuZW50cnlDb21wb25lbnRzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gX3RoaXMuZ2V0VHlwZU1ldGFkYXRhKHR5cGUsIHN0YXRpY1R5cGVNb2R1bGVVcmwodHlwZSkpOyB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChlbnRyeUNvbXBvbmVudE1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmICghc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvciA9IHRoaXMuX3NjaGVtYVJlZ2lzdHJ5LmdldERlZmF1bHRDb21wb25lbnRFbGVtZW50TmFtZSgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLy8gRGlyZWN0aXZlXG4gICAgICAgICAgICAgICAgICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlyZWN0aXZlIFwiICsgc3RyaW5naWZ5KGRpcmVjdGl2ZVR5cGUpICsgXCIgaGFzIG5vIHNlbGVjdG9yLCBwbGVhc2UgYWRkIGl0IVwiKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgcHJvdmlkZXJzID0gW107XG4gICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoZGlyTWV0YS5wcm92aWRlcnMpKSB7XG4gICAgICAgICAgICAgICAgICBwcm92aWRlcnMgPSB0aGlzLmdldFByb3ZpZGVyc01ldGFkYXRhKGRpck1ldGEucHJvdmlkZXJzLCBlbnRyeUNvbXBvbmVudE1ldGFkYXRhLCBcInByb3ZpZGVycyBmb3IgXFxcIlwiICsgc3RyaW5naWZ5KGRpcmVjdGl2ZVR5cGUpICsgXCJcXFwiXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBxdWVyaWVzID0gW107XG4gICAgICAgICAgICAgIHZhciB2aWV3UXVlcmllcyA9IFtdO1xuICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KGRpck1ldGEucXVlcmllcykpIHtcbiAgICAgICAgICAgICAgICAgIHF1ZXJpZXMgPSB0aGlzLmdldFF1ZXJpZXNNZXRhZGF0YShkaXJNZXRhLnF1ZXJpZXMsIGZhbHNlLCBkaXJlY3RpdmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgIHZpZXdRdWVyaWVzID0gdGhpcy5nZXRRdWVyaWVzTWV0YWRhdGEoZGlyTWV0YS5xdWVyaWVzLCB0cnVlLCBkaXJlY3RpdmVUeXBlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBtZXRhID0gQ29tcGlsZURpcmVjdGl2ZU1ldGFkYXRhLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICBzZWxlY3Rvcjogc2VsZWN0b3IsXG4gICAgICAgICAgICAgICAgICBleHBvcnRBczogZGlyTWV0YS5leHBvcnRBcyxcbiAgICAgICAgICAgICAgICAgIGlzQ29tcG9uZW50OiAhIXRlbXBsYXRlTWV0YSxcbiAgICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMuZ2V0VHlwZU1ldGFkYXRhKGRpcmVjdGl2ZVR5cGUsIG1vZHVsZVVybCksXG4gICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogdGVtcGxhdGVNZXRhLFxuICAgICAgICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBjaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgICAgICAgICAgICAgICAgIGlucHV0czogZGlyTWV0YS5pbnB1dHMsXG4gICAgICAgICAgICAgICAgICBvdXRwdXRzOiBkaXJNZXRhLm91dHB1dHMsXG4gICAgICAgICAgICAgICAgICBob3N0OiBkaXJNZXRhLmhvc3QsXG4gICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IHByb3ZpZGVycyxcbiAgICAgICAgICAgICAgICAgIHZpZXdQcm92aWRlcnM6IHZpZXdQcm92aWRlcnMsXG4gICAgICAgICAgICAgICAgICBxdWVyaWVzOiBxdWVyaWVzLFxuICAgICAgICAgICAgICAgICAgdmlld1F1ZXJpZXM6IHZpZXdRdWVyaWVzLFxuICAgICAgICAgICAgICAgICAgZW50cnlDb21wb25lbnRzOiBlbnRyeUNvbXBvbmVudE1ldGFkYXRhXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB0aGlzLl9kaXJlY3RpdmVDYWNoZS5zZXQoZGlyZWN0aXZlVHlwZSwgbWV0YSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtZXRhO1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5nZXROZ01vZHVsZU1ldGFkYXRhID0gZnVuY3Rpb24gKG1vZHVsZVR5cGUsIHRocm93SWZOb3RGb3VuZCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgaWYgKHRocm93SWZOb3RGb3VuZCA9PT0gdm9pZCAwKSB7IHRocm93SWZOb3RGb3VuZCA9IHRydWU7IH1cbiAgICAgICAgICBtb2R1bGVUeXBlID0gX2FuZ3VsYXJfY29yZS5yZXNvbHZlRm9yd2FyZFJlZihtb2R1bGVUeXBlKTtcbiAgICAgICAgICB2YXIgY29tcGlsZU1ldGEgPSB0aGlzLl9uZ01vZHVsZUNhY2hlLmdldChtb2R1bGVUeXBlKTtcbiAgICAgICAgICBpZiAoIWNvbXBpbGVNZXRhKSB7XG4gICAgICAgICAgICAgIHZhciBtZXRhID0gdGhpcy5fbmdNb2R1bGVSZXNvbHZlci5yZXNvbHZlKG1vZHVsZVR5cGUsIHRocm93SWZOb3RGb3VuZCk7XG4gICAgICAgICAgICAgIGlmICghbWV0YSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIGRlY2xhcmVkRGlyZWN0aXZlc18xID0gW107XG4gICAgICAgICAgICAgIHZhciBleHBvcnRlZERpcmVjdGl2ZXNfMSA9IFtdO1xuICAgICAgICAgICAgICB2YXIgZGVjbGFyZWRQaXBlc18xID0gW107XG4gICAgICAgICAgICAgIHZhciBleHBvcnRlZFBpcGVzXzEgPSBbXTtcbiAgICAgICAgICAgICAgdmFyIGltcG9ydGVkTW9kdWxlc18xID0gW107XG4gICAgICAgICAgICAgIHZhciBleHBvcnRlZE1vZHVsZXNfMSA9IFtdO1xuICAgICAgICAgICAgICB2YXIgcHJvdmlkZXJzXzEgPSBbXTtcbiAgICAgICAgICAgICAgdmFyIGVudHJ5Q29tcG9uZW50c18xID0gW107XG4gICAgICAgICAgICAgIHZhciBib290c3RyYXBDb21wb25lbnRzID0gW107XG4gICAgICAgICAgICAgIHZhciBzY2hlbWFzID0gW107XG4gICAgICAgICAgICAgIGlmIChtZXRhLmltcG9ydHMpIHtcbiAgICAgICAgICAgICAgICAgIGZsYXR0ZW5BcnJheShtZXRhLmltcG9ydHMpLmZvckVhY2goZnVuY3Rpb24gKGltcG9ydGVkVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBpbXBvcnRlZE1vZHVsZVR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmFsaWRUeXBlKGltcG9ydGVkVHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaW1wb3J0ZWRNb2R1bGVUeXBlID0gaW1wb3J0ZWRUeXBlO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpbXBvcnRlZFR5cGUgJiYgaW1wb3J0ZWRUeXBlLm5nTW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtb2R1bGVXaXRoUHJvdmlkZXJzID0gaW1wb3J0ZWRUeXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpbXBvcnRlZE1vZHVsZVR5cGUgPSBtb2R1bGVXaXRoUHJvdmlkZXJzLm5nTW9kdWxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9kdWxlV2l0aFByb3ZpZGVycy5wcm92aWRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyc18xLnB1c2guYXBwbHkocHJvdmlkZXJzXzEsIF90aGlzLmdldFByb3ZpZGVyc01ldGFkYXRhKG1vZHVsZVdpdGhQcm92aWRlcnMucHJvdmlkZXJzLCBlbnRyeUNvbXBvbmVudHNfMSwgXCJwcm92aWRlciBmb3IgdGhlIE5nTW9kdWxlICdcIiArIHN0cmluZ2lmeShpbXBvcnRlZE1vZHVsZVR5cGUpICsgXCInXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBpZiAoaW1wb3J0ZWRNb2R1bGVUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbXBvcnRlZE1ldGEgPSBfdGhpcy5nZXROZ01vZHVsZU1ldGFkYXRhKGltcG9ydGVkTW9kdWxlVHlwZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW1wb3J0ZWRNZXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIFwiICsgX3RoaXMuX2dldFR5cGVEZXNjcmlwdG9yKGltcG9ydGVkVHlwZSkgKyBcIiAnXCIgKyBzdHJpbmdpZnkoaW1wb3J0ZWRUeXBlKSArIFwiJyBpbXBvcnRlZCBieSB0aGUgbW9kdWxlICdcIiArIHN0cmluZ2lmeShtb2R1bGVUeXBlKSArIFwiJ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICBpbXBvcnRlZE1vZHVsZXNfMS5wdXNoKGltcG9ydGVkTWV0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIHZhbHVlICdcIiArIHN0cmluZ2lmeShpbXBvcnRlZFR5cGUpICsgXCInIGltcG9ydGVkIGJ5IHRoZSBtb2R1bGUgJ1wiICsgc3RyaW5naWZ5KG1vZHVsZVR5cGUpICsgXCInXCIpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChtZXRhLmV4cG9ydHMpIHtcbiAgICAgICAgICAgICAgICAgIGZsYXR0ZW5BcnJheShtZXRhLmV4cG9ydHMpLmZvckVhY2goZnVuY3Rpb24gKGV4cG9ydGVkVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZFR5cGUoZXhwb3J0ZWRUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIHZhbHVlICdcIiArIHN0cmluZ2lmeShleHBvcnRlZFR5cGUpICsgXCInIGV4cG9ydGVkIGJ5IHRoZSBtb2R1bGUgJ1wiICsgc3RyaW5naWZ5KG1vZHVsZVR5cGUpICsgXCInXCIpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB2YXIgZXhwb3J0ZWREaXJNZXRhO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBleHBvcnRlZFBpcGVNZXRhO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBleHBvcnRlZE1vZHVsZU1ldGE7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGV4cG9ydGVkRGlyTWV0YSA9IF90aGlzLmdldERpcmVjdGl2ZU1ldGFkYXRhKGV4cG9ydGVkVHlwZSwgZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9ydGVkRGlyZWN0aXZlc18xLnB1c2goZXhwb3J0ZWREaXJNZXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZXhwb3J0ZWRQaXBlTWV0YSA9IF90aGlzLmdldFBpcGVNZXRhZGF0YShleHBvcnRlZFR5cGUsIGZhbHNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBleHBvcnRlZFBpcGVzXzEucHVzaChleHBvcnRlZFBpcGVNZXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZXhwb3J0ZWRNb2R1bGVNZXRhID0gX3RoaXMuZ2V0TmdNb2R1bGVNZXRhZGF0YShleHBvcnRlZFR5cGUsIGZhbHNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBleHBvcnRlZE1vZHVsZXNfMS5wdXNoKGV4cG9ydGVkTW9kdWxlTWV0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIFwiICsgX3RoaXMuX2dldFR5cGVEZXNjcmlwdG9yKGV4cG9ydGVkVHlwZSkgKyBcIiAnXCIgKyBzdHJpbmdpZnkoZXhwb3J0ZWRUeXBlKSArIFwiJyBleHBvcnRlZCBieSB0aGUgbW9kdWxlICdcIiArIHN0cmluZ2lmeShtb2R1bGVUeXBlKSArIFwiJ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBOb3RlOiBUaGlzIHdpbGwgYmUgbW9kaWZpZWQgbGF0ZXIsIHNvIHdlIHJlbHkgb25cbiAgICAgICAgICAgICAgLy8gZ2V0dGluZyBhIG5ldyBpbnN0YW5jZSBldmVyeSB0aW1lIVxuICAgICAgICAgICAgICB2YXIgdHJhbnNpdGl2ZU1vZHVsZV8xID0gdGhpcy5fZ2V0VHJhbnNpdGl2ZU5nTW9kdWxlTWV0YWRhdGEoaW1wb3J0ZWRNb2R1bGVzXzEsIGV4cG9ydGVkTW9kdWxlc18xKTtcbiAgICAgICAgICAgICAgaWYgKG1ldGEuZGVjbGFyYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgICBmbGF0dGVuQXJyYXkobWV0YS5kZWNsYXJhdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKGRlY2xhcmVkVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZFR5cGUoZGVjbGFyZWRUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIHZhbHVlICdcIiArIHN0cmluZ2lmeShkZWNsYXJlZFR5cGUpICsgXCInIGRlY2xhcmVkIGJ5IHRoZSBtb2R1bGUgJ1wiICsgc3RyaW5naWZ5KG1vZHVsZVR5cGUpICsgXCInXCIpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVjbGFyZWREaXJNZXRhO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWNsYXJlZFBpcGVNZXRhO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWNsYXJlZERpck1ldGEgPSBfdGhpcy5nZXREaXJlY3RpdmVNZXRhZGF0YShkZWNsYXJlZFR5cGUsIGZhbHNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYWRkRGlyZWN0aXZlVG9Nb2R1bGUoZGVjbGFyZWREaXJNZXRhLCBtb2R1bGVUeXBlLCB0cmFuc2l0aXZlTW9kdWxlXzEsIGRlY2xhcmVkRGlyZWN0aXZlc18xLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZGVjbGFyZWRQaXBlTWV0YSA9IF90aGlzLmdldFBpcGVNZXRhZGF0YShkZWNsYXJlZFR5cGUsIGZhbHNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYWRkUGlwZVRvTW9kdWxlKGRlY2xhcmVkUGlwZU1ldGEsIG1vZHVsZVR5cGUsIHRyYW5zaXRpdmVNb2R1bGVfMSwgZGVjbGFyZWRQaXBlc18xLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgXCIgKyBfdGhpcy5fZ2V0VHlwZURlc2NyaXB0b3IoZGVjbGFyZWRUeXBlKSArIFwiICdcIiArIHN0cmluZ2lmeShkZWNsYXJlZFR5cGUpICsgXCInIGRlY2xhcmVkIGJ5IHRoZSBtb2R1bGUgJ1wiICsgc3RyaW5naWZ5KG1vZHVsZVR5cGUpICsgXCInXCIpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIFRoZSBwcm92aWRlcnMgb2YgdGhlIG1vZHVsZSBoYXZlIHRvIGdvIGxhc3RcbiAgICAgICAgICAgICAgLy8gc28gdGhhdCB0aGV5IG92ZXJ3cml0ZSBhbnkgb3RoZXIgcHJvdmlkZXIgd2UgYWxyZWFkeSBhZGRlZC5cbiAgICAgICAgICAgICAgaWYgKG1ldGEucHJvdmlkZXJzKSB7XG4gICAgICAgICAgICAgICAgICBwcm92aWRlcnNfMS5wdXNoLmFwcGx5KHByb3ZpZGVyc18xLCB0aGlzLmdldFByb3ZpZGVyc01ldGFkYXRhKG1ldGEucHJvdmlkZXJzLCBlbnRyeUNvbXBvbmVudHNfMSwgXCJwcm92aWRlciBmb3IgdGhlIE5nTW9kdWxlICdcIiArIHN0cmluZ2lmeShtb2R1bGVUeXBlKSArIFwiJ1wiKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKG1ldGEuZW50cnlDb21wb25lbnRzKSB7XG4gICAgICAgICAgICAgICAgICBlbnRyeUNvbXBvbmVudHNfMS5wdXNoLmFwcGx5KGVudHJ5Q29tcG9uZW50c18xLCBmbGF0dGVuQXJyYXkobWV0YS5lbnRyeUNvbXBvbmVudHMpXG4gICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gX3RoaXMuZ2V0VHlwZU1ldGFkYXRhKHR5cGUsIHN0YXRpY1R5cGVNb2R1bGVVcmwodHlwZSkpOyB9KSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKG1ldGEuYm9vdHN0cmFwKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgdHlwZU1ldGFkYXRhID0gZmxhdHRlbkFycmF5KG1ldGEuYm9vdHN0cmFwKS5tYXAoZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRUeXBlKHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgdmFsdWUgJ1wiICsgc3RyaW5naWZ5KHR5cGUpICsgXCInIHVzZWQgaW4gdGhlIGJvb3RzdHJhcCBwcm9wZXJ0eSBvZiBtb2R1bGUgJ1wiICsgc3RyaW5naWZ5KG1vZHVsZVR5cGUpICsgXCInXCIpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZ2V0VHlwZU1ldGFkYXRhKHR5cGUsIHN0YXRpY1R5cGVNb2R1bGVVcmwodHlwZSkpO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBib290c3RyYXBDb21wb25lbnRzLnB1c2guYXBwbHkoYm9vdHN0cmFwQ29tcG9uZW50cywgdHlwZU1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbnRyeUNvbXBvbmVudHNfMS5wdXNoLmFwcGx5KGVudHJ5Q29tcG9uZW50c18xLCBib290c3RyYXBDb21wb25lbnRzKTtcbiAgICAgICAgICAgICAgaWYgKG1ldGEuc2NoZW1hcykge1xuICAgICAgICAgICAgICAgICAgc2NoZW1hcy5wdXNoLmFwcGx5KHNjaGVtYXMsIGZsYXR0ZW5BcnJheShtZXRhLnNjaGVtYXMpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAoX2EgPSB0cmFuc2l0aXZlTW9kdWxlXzEuZW50cnlDb21wb25lbnRzKS5wdXNoLmFwcGx5KF9hLCBlbnRyeUNvbXBvbmVudHNfMSk7XG4gICAgICAgICAgICAgIChfYiA9IHRyYW5zaXRpdmVNb2R1bGVfMS5wcm92aWRlcnMpLnB1c2guYXBwbHkoX2IsIHByb3ZpZGVyc18xKTtcbiAgICAgICAgICAgICAgY29tcGlsZU1ldGEgPSBuZXcgQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGEoe1xuICAgICAgICAgICAgICAgICAgdHlwZTogdGhpcy5nZXRUeXBlTWV0YWRhdGEobW9kdWxlVHlwZSwgc3RhdGljVHlwZU1vZHVsZVVybChtb2R1bGVUeXBlKSksXG4gICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IHByb3ZpZGVyc18xLFxuICAgICAgICAgICAgICAgICAgZW50cnlDb21wb25lbnRzOiBlbnRyeUNvbXBvbmVudHNfMSxcbiAgICAgICAgICAgICAgICAgIGJvb3RzdHJhcENvbXBvbmVudHM6IGJvb3RzdHJhcENvbXBvbmVudHMsXG4gICAgICAgICAgICAgICAgICBzY2hlbWFzOiBzY2hlbWFzLFxuICAgICAgICAgICAgICAgICAgZGVjbGFyZWREaXJlY3RpdmVzOiBkZWNsYXJlZERpcmVjdGl2ZXNfMSxcbiAgICAgICAgICAgICAgICAgIGV4cG9ydGVkRGlyZWN0aXZlczogZXhwb3J0ZWREaXJlY3RpdmVzXzEsXG4gICAgICAgICAgICAgICAgICBkZWNsYXJlZFBpcGVzOiBkZWNsYXJlZFBpcGVzXzEsXG4gICAgICAgICAgICAgICAgICBleHBvcnRlZFBpcGVzOiBleHBvcnRlZFBpcGVzXzEsXG4gICAgICAgICAgICAgICAgICBpbXBvcnRlZE1vZHVsZXM6IGltcG9ydGVkTW9kdWxlc18xLFxuICAgICAgICAgICAgICAgICAgZXhwb3J0ZWRNb2R1bGVzOiBleHBvcnRlZE1vZHVsZXNfMSxcbiAgICAgICAgICAgICAgICAgIHRyYW5zaXRpdmVNb2R1bGU6IHRyYW5zaXRpdmVNb2R1bGVfMSxcbiAgICAgICAgICAgICAgICAgIGlkOiBtZXRhLmlkLFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgdHJhbnNpdGl2ZU1vZHVsZV8xLm1vZHVsZXMucHVzaChjb21waWxlTWV0YSk7XG4gICAgICAgICAgICAgIHRoaXMuX3ZlcmlmeU1vZHVsZShjb21waWxlTWV0YSk7XG4gICAgICAgICAgICAgIHRoaXMuX25nTW9kdWxlQ2FjaGUuc2V0KG1vZHVsZVR5cGUsIGNvbXBpbGVNZXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNvbXBpbGVNZXRhO1xuICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICB9O1xuICAgICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLl92ZXJpZnlNb2R1bGUgPSBmdW5jdGlvbiAobW9kdWxlTWV0YSkge1xuICAgICAgICAgIG1vZHVsZU1ldGEuZXhwb3J0ZWREaXJlY3RpdmVzLmZvckVhY2goZnVuY3Rpb24gKGRpck1ldGEpIHtcbiAgICAgICAgICAgICAgaWYgKCFtb2R1bGVNZXRhLnRyYW5zaXRpdmVNb2R1bGUuZGlyZWN0aXZlc1NldC5oYXMoZGlyTWV0YS50eXBlLnJlZmVyZW5jZSkpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGV4cG9ydCBkaXJlY3RpdmUgXCIgKyBzdHJpbmdpZnkoZGlyTWV0YS50eXBlLnJlZmVyZW5jZSkgKyBcIiBmcm9tIFwiICsgc3RyaW5naWZ5KG1vZHVsZU1ldGEudHlwZS5yZWZlcmVuY2UpICsgXCIgYXMgaXQgd2FzIG5laXRoZXIgZGVjbGFyZWQgbm9yIGltcG9ydGVkIVwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG1vZHVsZU1ldGEuZXhwb3J0ZWRQaXBlcy5mb3JFYWNoKGZ1bmN0aW9uIChwaXBlTWV0YSkge1xuICAgICAgICAgICAgICBpZiAoIW1vZHVsZU1ldGEudHJhbnNpdGl2ZU1vZHVsZS5waXBlc1NldC5oYXMocGlwZU1ldGEudHlwZS5yZWZlcmVuY2UpKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBleHBvcnQgcGlwZSBcIiArIHN0cmluZ2lmeShwaXBlTWV0YS50eXBlLnJlZmVyZW5jZSkgKyBcIiBmcm9tIFwiICsgc3RyaW5naWZ5KG1vZHVsZU1ldGEudHlwZS5yZWZlcmVuY2UpICsgXCIgYXMgaXQgd2FzIG5laXRoZXIgZGVjbGFyZWQgbm9yIGltcG9ydGVkIVwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5fZ2V0VHlwZURlc2NyaXB0b3IgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgIGlmICh0aGlzLl9kaXJlY3RpdmVSZXNvbHZlci5yZXNvbHZlKHR5cGUsIGZhbHNlKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gJ2RpcmVjdGl2ZSc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLl9waXBlUmVzb2x2ZXIucmVzb2x2ZSh0eXBlLCBmYWxzZSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICdwaXBlJztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuX25nTW9kdWxlUmVzb2x2ZXIucmVzb2x2ZSh0eXBlLCBmYWxzZSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICdtb2R1bGUnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZS5wcm92aWRlKSB7XG4gICAgICAgICAgICAgIHJldHVybiAncHJvdmlkZXInO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gJ3ZhbHVlJztcbiAgICAgIH07XG4gICAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuX2FkZFR5cGVUb01vZHVsZSA9IGZ1bmN0aW9uICh0eXBlLCBtb2R1bGVUeXBlKSB7XG4gICAgICAgICAgdmFyIG9sZE1vZHVsZSA9IHRoaXMuX25nTW9kdWxlT2ZUeXBlcy5nZXQodHlwZSk7XG4gICAgICAgICAgaWYgKG9sZE1vZHVsZSAmJiBvbGRNb2R1bGUgIT09IG1vZHVsZVR5cGUpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKChcIlR5cGUgXCIgKyBzdHJpbmdpZnkodHlwZSkgKyBcIiBpcyBwYXJ0IG9mIHRoZSBkZWNsYXJhdGlvbnMgb2YgMiBtb2R1bGVzOiBcIiArIHN0cmluZ2lmeShvbGRNb2R1bGUpICsgXCIgYW5kIFwiICsgc3RyaW5naWZ5KG1vZHVsZVR5cGUpICsgXCIhIFwiKSArXG4gICAgICAgICAgICAgICAgICAoXCJQbGVhc2UgY29uc2lkZXIgbW92aW5nIFwiICsgc3RyaW5naWZ5KHR5cGUpICsgXCIgdG8gYSBoaWdoZXIgbW9kdWxlIHRoYXQgaW1wb3J0cyBcIiArIHN0cmluZ2lmeShvbGRNb2R1bGUpICsgXCIgYW5kIFwiICsgc3RyaW5naWZ5KG1vZHVsZVR5cGUpICsgXCIuIFwiKSArXG4gICAgICAgICAgICAgICAgICAoXCJZb3UgY2FuIGFsc28gY3JlYXRlIGEgbmV3IE5nTW9kdWxlIHRoYXQgZXhwb3J0cyBhbmQgaW5jbHVkZXMgXCIgKyBzdHJpbmdpZnkodHlwZSkgKyBcIiB0aGVuIGltcG9ydCB0aGF0IE5nTW9kdWxlIGluIFwiICsgc3RyaW5naWZ5KG9sZE1vZHVsZSkgKyBcIiBhbmQgXCIgKyBzdHJpbmdpZnkobW9kdWxlVHlwZSkgKyBcIi5cIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9uZ01vZHVsZU9mVHlwZXMuc2V0KHR5cGUsIG1vZHVsZVR5cGUpO1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5fZ2V0VHJhbnNpdGl2ZU5nTW9kdWxlTWV0YWRhdGEgPSBmdW5jdGlvbiAoaW1wb3J0ZWRNb2R1bGVzLCBleHBvcnRlZE1vZHVsZXMpIHtcbiAgICAgICAgICAvLyBjb2xsZWN0IGBwcm92aWRlcnNgIC8gYGVudHJ5Q29tcG9uZW50c2AgZnJvbSBhbGwgaW1wb3J0ZWQgYW5kIGFsbCBleHBvcnRlZCBtb2R1bGVzXG4gICAgICAgICAgdmFyIHRyYW5zaXRpdmVNb2R1bGVzID0gZ2V0VHJhbnNpdGl2ZU1vZHVsZXMoaW1wb3J0ZWRNb2R1bGVzLmNvbmNhdChleHBvcnRlZE1vZHVsZXMpLCB0cnVlKTtcbiAgICAgICAgICB2YXIgcHJvdmlkZXJzID0gZmxhdHRlbkFycmF5KHRyYW5zaXRpdmVNb2R1bGVzLm1hcChmdW5jdGlvbiAobmdNb2R1bGUpIHsgcmV0dXJuIG5nTW9kdWxlLnByb3ZpZGVyczsgfSkpO1xuICAgICAgICAgIHZhciBlbnRyeUNvbXBvbmVudHMgPSBmbGF0dGVuQXJyYXkodHJhbnNpdGl2ZU1vZHVsZXMubWFwKGZ1bmN0aW9uIChuZ01vZHVsZSkgeyByZXR1cm4gbmdNb2R1bGUuZW50cnlDb21wb25lbnRzOyB9KSk7XG4gICAgICAgICAgdmFyIHRyYW5zaXRpdmVFeHBvcnRlZE1vZHVsZXMgPSBnZXRUcmFuc2l0aXZlTW9kdWxlcyhpbXBvcnRlZE1vZHVsZXMsIGZhbHNlKTtcbiAgICAgICAgICB2YXIgZGlyZWN0aXZlcyA9IGZsYXR0ZW5BcnJheSh0cmFuc2l0aXZlRXhwb3J0ZWRNb2R1bGVzLm1hcChmdW5jdGlvbiAobmdNb2R1bGUpIHsgcmV0dXJuIG5nTW9kdWxlLmV4cG9ydGVkRGlyZWN0aXZlczsgfSkpO1xuICAgICAgICAgIHZhciBwaXBlcyA9IGZsYXR0ZW5BcnJheSh0cmFuc2l0aXZlRXhwb3J0ZWRNb2R1bGVzLm1hcChmdW5jdGlvbiAobmdNb2R1bGUpIHsgcmV0dXJuIG5nTW9kdWxlLmV4cG9ydGVkUGlwZXM7IH0pKTtcbiAgICAgICAgICByZXR1cm4gbmV3IFRyYW5zaXRpdmVDb21waWxlTmdNb2R1bGVNZXRhZGF0YSh0cmFuc2l0aXZlTW9kdWxlcywgcHJvdmlkZXJzLCBlbnRyeUNvbXBvbmVudHMsIGRpcmVjdGl2ZXMsIHBpcGVzKTtcbiAgICAgIH07XG4gICAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuX2FkZERpcmVjdGl2ZVRvTW9kdWxlID0gZnVuY3Rpb24gKGRpck1ldGEsIG1vZHVsZVR5cGUsIHRyYW5zaXRpdmVNb2R1bGUsIGRlY2xhcmVkRGlyZWN0aXZlcywgZm9yY2UpIHtcbiAgICAgICAgICBpZiAoZm9yY2UgPT09IHZvaWQgMCkgeyBmb3JjZSA9IGZhbHNlOyB9XG4gICAgICAgICAgaWYgKGZvcmNlIHx8ICF0cmFuc2l0aXZlTW9kdWxlLmRpcmVjdGl2ZXNTZXQuaGFzKGRpck1ldGEudHlwZS5yZWZlcmVuY2UpKSB7XG4gICAgICAgICAgICAgIHRyYW5zaXRpdmVNb2R1bGUuZGlyZWN0aXZlc1NldC5hZGQoZGlyTWV0YS50eXBlLnJlZmVyZW5jZSk7XG4gICAgICAgICAgICAgIHRyYW5zaXRpdmVNb2R1bGUuZGlyZWN0aXZlcy5wdXNoKGRpck1ldGEpO1xuICAgICAgICAgICAgICBkZWNsYXJlZERpcmVjdGl2ZXMucHVzaChkaXJNZXRhKTtcbiAgICAgICAgICAgICAgdGhpcy5fYWRkVHlwZVRvTW9kdWxlKGRpck1ldGEudHlwZS5yZWZlcmVuY2UsIG1vZHVsZVR5cGUpO1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5fYWRkUGlwZVRvTW9kdWxlID0gZnVuY3Rpb24gKHBpcGVNZXRhLCBtb2R1bGVUeXBlLCB0cmFuc2l0aXZlTW9kdWxlLCBkZWNsYXJlZFBpcGVzLCBmb3JjZSkge1xuICAgICAgICAgIGlmIChmb3JjZSA9PT0gdm9pZCAwKSB7IGZvcmNlID0gZmFsc2U7IH1cbiAgICAgICAgICBpZiAoZm9yY2UgfHwgIXRyYW5zaXRpdmVNb2R1bGUucGlwZXNTZXQuaGFzKHBpcGVNZXRhLnR5cGUucmVmZXJlbmNlKSkge1xuICAgICAgICAgICAgICB0cmFuc2l0aXZlTW9kdWxlLnBpcGVzU2V0LmFkZChwaXBlTWV0YS50eXBlLnJlZmVyZW5jZSk7XG4gICAgICAgICAgICAgIHRyYW5zaXRpdmVNb2R1bGUucGlwZXMucHVzaChwaXBlTWV0YSk7XG4gICAgICAgICAgICAgIGRlY2xhcmVkUGlwZXMucHVzaChwaXBlTWV0YSk7XG4gICAgICAgICAgICAgIHRoaXMuX2FkZFR5cGVUb01vZHVsZShwaXBlTWV0YS50eXBlLnJlZmVyZW5jZSwgbW9kdWxlVHlwZSk7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuICAgICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmdldFR5cGVNZXRhZGF0YSA9IGZ1bmN0aW9uICh0eXBlLCBtb2R1bGVVcmwsIGRlcGVuZGVuY2llcykge1xuICAgICAgICAgIGlmIChkZXBlbmRlbmNpZXMgPT09IHZvaWQgMCkgeyBkZXBlbmRlbmNpZXMgPSBudWxsOyB9XG4gICAgICAgICAgdHlwZSA9IF9hbmd1bGFyX2NvcmUucmVzb2x2ZUZvcndhcmRSZWYodHlwZSk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBDb21waWxlVHlwZU1ldGFkYXRhKHtcbiAgICAgICAgICAgICAgbmFtZTogdGhpcy5zYW5pdGl6ZVRva2VuTmFtZSh0eXBlKSxcbiAgICAgICAgICAgICAgbW9kdWxlVXJsOiBtb2R1bGVVcmwsXG4gICAgICAgICAgICAgIHJlZmVyZW5jZTogdHlwZSxcbiAgICAgICAgICAgICAgZGlEZXBzOiB0aGlzLmdldERlcGVuZGVuY2llc01ldGFkYXRhKHR5cGUsIGRlcGVuZGVuY2llcyksXG4gICAgICAgICAgICAgIGxpZmVjeWNsZUhvb2tzOiBMSUZFQ1lDTEVfSE9PS1NfVkFMVUVTLmZpbHRlcihmdW5jdGlvbiAoaG9vaykgeyByZXR1cm4gaGFzTGlmZWN5Y2xlSG9vayhob29rLCB0eXBlKTsgfSksXG4gICAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmdldEZhY3RvcnlNZXRhZGF0YSA9IGZ1bmN0aW9uIChmYWN0b3J5LCBtb2R1bGVVcmwsIGRlcGVuZGVuY2llcykge1xuICAgICAgICAgIGlmIChkZXBlbmRlbmNpZXMgPT09IHZvaWQgMCkgeyBkZXBlbmRlbmNpZXMgPSBudWxsOyB9XG4gICAgICAgICAgZmFjdG9yeSA9IF9hbmd1bGFyX2NvcmUucmVzb2x2ZUZvcndhcmRSZWYoZmFjdG9yeSk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBDb21waWxlRmFjdG9yeU1ldGFkYXRhKHtcbiAgICAgICAgICAgICAgbmFtZTogdGhpcy5zYW5pdGl6ZVRva2VuTmFtZShmYWN0b3J5KSxcbiAgICAgICAgICAgICAgbW9kdWxlVXJsOiBtb2R1bGVVcmwsXG4gICAgICAgICAgICAgIHJlZmVyZW5jZTogZmFjdG9yeSxcbiAgICAgICAgICAgICAgZGlEZXBzOiB0aGlzLmdldERlcGVuZGVuY2llc01ldGFkYXRhKGZhY3RvcnksIGRlcGVuZGVuY2llcylcbiAgICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuZ2V0UGlwZU1ldGFkYXRhID0gZnVuY3Rpb24gKHBpcGVUeXBlLCB0aHJvd0lmTm90Rm91bmQpIHtcbiAgICAgICAgICBpZiAodGhyb3dJZk5vdEZvdW5kID09PSB2b2lkIDApIHsgdGhyb3dJZk5vdEZvdW5kID0gdHJ1ZTsgfVxuICAgICAgICAgIHBpcGVUeXBlID0gX2FuZ3VsYXJfY29yZS5yZXNvbHZlRm9yd2FyZFJlZihwaXBlVHlwZSk7XG4gICAgICAgICAgdmFyIG1ldGEgPSB0aGlzLl9waXBlQ2FjaGUuZ2V0KHBpcGVUeXBlKTtcbiAgICAgICAgICBpZiAoIW1ldGEpIHtcbiAgICAgICAgICAgICAgdmFyIHBpcGVNZXRhID0gdGhpcy5fcGlwZVJlc29sdmVyLnJlc29sdmUocGlwZVR5cGUsIHRocm93SWZOb3RGb3VuZCk7XG4gICAgICAgICAgICAgIGlmICghcGlwZU1ldGEpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG1ldGEgPSBuZXcgQ29tcGlsZVBpcGVNZXRhZGF0YSh7XG4gICAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLmdldFR5cGVNZXRhZGF0YShwaXBlVHlwZSwgc3RhdGljVHlwZU1vZHVsZVVybChwaXBlVHlwZSkpLFxuICAgICAgICAgICAgICAgICAgbmFtZTogcGlwZU1ldGEubmFtZSxcbiAgICAgICAgICAgICAgICAgIHB1cmU6IHBpcGVNZXRhLnB1cmVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHRoaXMuX3BpcGVDYWNoZS5zZXQocGlwZVR5cGUsIG1ldGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWV0YTtcbiAgICAgIH07XG4gICAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuZ2V0RGVwZW5kZW5jaWVzTWV0YWRhdGEgPSBmdW5jdGlvbiAodHlwZU9yRnVuYywgZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgaGFzVW5rbm93bkRlcHMgPSBmYWxzZTtcbiAgICAgICAgICB2YXIgcGFyYW1zID0gZGVwZW5kZW5jaWVzIHx8IHRoaXMuX3JlZmxlY3Rvci5wYXJhbWV0ZXJzKHR5cGVPckZ1bmMpIHx8IFtdO1xuICAgICAgICAgIHZhciBkZXBlbmRlbmNpZXNNZXRhZGF0YSA9IHBhcmFtcy5tYXAoZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICAgICAgICAgIHZhciBpc0F0dHJpYnV0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICB2YXIgaXNIb3N0ID0gZmFsc2U7XG4gICAgICAgICAgICAgIHZhciBpc1NlbGYgPSBmYWxzZTtcbiAgICAgICAgICAgICAgdmFyIGlzU2tpcFNlbGYgPSBmYWxzZTtcbiAgICAgICAgICAgICAgdmFyIGlzT3B0aW9uYWwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgdmFyIHF1ZXJ5ID0gbnVsbDtcbiAgICAgICAgICAgICAgdmFyIHZpZXdRdWVyeSA9IG51bGw7XG4gICAgICAgICAgICAgIHZhciB0b2tlbiA9IG51bGw7XG4gICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtKSkge1xuICAgICAgICAgICAgICAgICAgcGFyYW0uZm9yRWFjaChmdW5jdGlvbiAocGFyYW1FbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbUVudHJ5IGluc3RhbmNlb2YgX2FuZ3VsYXJfY29yZS5Ib3N0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlzSG9zdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtRW50cnkgaW5zdGFuY2VvZiBfYW5ndWxhcl9jb3JlLlNlbGYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaXNTZWxmID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyYW1FbnRyeSBpbnN0YW5jZW9mIF9hbmd1bGFyX2NvcmUuU2tpcFNlbGYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaXNTa2lwU2VsZiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtRW50cnkgaW5zdGFuY2VvZiBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlzT3B0aW9uYWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJhbUVudHJ5IGluc3RhbmNlb2YgX2FuZ3VsYXJfY29yZS5BdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaXNBdHRyaWJ1dGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHBhcmFtRW50cnkuYXR0cmlidXRlTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyYW1FbnRyeSBpbnN0YW5jZW9mIF9hbmd1bGFyX2NvcmUuUXVlcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtRW50cnkuaXNWaWV3UXVlcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdRdWVyeSA9IHBhcmFtRW50cnk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeSA9IHBhcmFtRW50cnk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyYW1FbnRyeSBpbnN0YW5jZW9mIF9hbmd1bGFyX2NvcmUuSW5qZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gcGFyYW1FbnRyeS50b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNWYWxpZFR5cGUocGFyYW1FbnRyeSkgJiYgaXNCbGFuayh0b2tlbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSBwYXJhbUVudHJ5O1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdG9rZW4gPSBwYXJhbTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaXNCbGFuayh0b2tlbikpIHtcbiAgICAgICAgICAgICAgICAgIGhhc1Vua25vd25EZXBzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcGlsZURpRGVwZW5kZW5jeU1ldGFkYXRhKHtcbiAgICAgICAgICAgICAgICAgIGlzQXR0cmlidXRlOiBpc0F0dHJpYnV0ZSxcbiAgICAgICAgICAgICAgICAgIGlzSG9zdDogaXNIb3N0LFxuICAgICAgICAgICAgICAgICAgaXNTZWxmOiBpc1NlbGYsXG4gICAgICAgICAgICAgICAgICBpc1NraXBTZWxmOiBpc1NraXBTZWxmLFxuICAgICAgICAgICAgICAgICAgaXNPcHRpb25hbDogaXNPcHRpb25hbCxcbiAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeSA/IF90aGlzLmdldFF1ZXJ5TWV0YWRhdGEocXVlcnksIG51bGwsIHR5cGVPckZ1bmMpIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgIHZpZXdRdWVyeTogdmlld1F1ZXJ5ID8gX3RoaXMuZ2V0UXVlcnlNZXRhZGF0YSh2aWV3UXVlcnksIG51bGwsIHR5cGVPckZ1bmMpIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgIHRva2VuOiBfdGhpcy5nZXRUb2tlbk1ldGFkYXRhKHRva2VuKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoaGFzVW5rbm93bkRlcHMpIHtcbiAgICAgICAgICAgICAgdmFyIGRlcHNUb2tlbnMgPSBkZXBlbmRlbmNpZXNNZXRhZGF0YS5tYXAoZnVuY3Rpb24gKGRlcCkgeyByZXR1cm4gZGVwID8gc3RyaW5naWZ5KGRlcC50b2tlbikgOiAnPyc7IH0pLmpvaW4oJywgJyk7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHJlc29sdmUgYWxsIHBhcmFtZXRlcnMgZm9yIFwiICsgc3RyaW5naWZ5KHR5cGVPckZ1bmMpICsgXCI6IChcIiArIGRlcHNUb2tlbnMgKyBcIikuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZGVwZW5kZW5jaWVzTWV0YWRhdGE7XG4gICAgICB9O1xuICAgICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmdldFRva2VuTWV0YWRhdGEgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgICB0b2tlbiA9IF9hbmd1bGFyX2NvcmUucmVzb2x2ZUZvcndhcmRSZWYodG9rZW4pO1xuICAgICAgICAgIHZhciBjb21waWxlVG9rZW47XG4gICAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgY29tcGlsZVRva2VuID0gbmV3IENvbXBpbGVUb2tlbk1ldGFkYXRhKHsgdmFsdWU6IHRva2VuIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgY29tcGlsZVRva2VuID0gbmV3IENvbXBpbGVUb2tlbk1ldGFkYXRhKHtcbiAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXI6IG5ldyBDb21waWxlSWRlbnRpZmllck1ldGFkYXRhKHtcbiAgICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2U6IHRva2VuLFxuICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMuc2FuaXRpemVUb2tlbk5hbWUodG9rZW4pLFxuICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZVVybDogc3RhdGljVHlwZU1vZHVsZVVybCh0b2tlbilcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY29tcGlsZVRva2VuO1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5nZXRQcm92aWRlcnNNZXRhZGF0YSA9IGZ1bmN0aW9uIChwcm92aWRlcnMsIHRhcmdldEVudHJ5Q29tcG9uZW50cywgZGVidWdJbmZvKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgY29tcGlsZVByb3ZpZGVycyA9IFtdO1xuICAgICAgICAgIHByb3ZpZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChwcm92aWRlciwgcHJvdmlkZXJJZHgpIHtcbiAgICAgICAgICAgICAgcHJvdmlkZXIgPSBfYW5ndWxhcl9jb3JlLnJlc29sdmVGb3J3YXJkUmVmKHByb3ZpZGVyKTtcbiAgICAgICAgICAgICAgaWYgKHByb3ZpZGVyICYmIHR5cGVvZiBwcm92aWRlciA9PSAnb2JqZWN0JyAmJiBwcm92aWRlci5oYXNPd25Qcm9wZXJ0eSgncHJvdmlkZScpKSB7XG4gICAgICAgICAgICAgICAgICBwcm92aWRlciA9IG5ldyBQcm92aWRlck1ldGEocHJvdmlkZXIucHJvdmlkZSwgcHJvdmlkZXIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBjb21waWxlUHJvdmlkZXI7XG4gICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3ZpZGVyKSkge1xuICAgICAgICAgICAgICAgICAgY29tcGlsZVByb3ZpZGVyID0gX3RoaXMuZ2V0UHJvdmlkZXJzTWV0YWRhdGEocHJvdmlkZXIsIHRhcmdldEVudHJ5Q29tcG9uZW50cywgZGVidWdJbmZvKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmIChwcm92aWRlciBpbnN0YW5jZW9mIFByb3ZpZGVyTWV0YSkge1xuICAgICAgICAgICAgICAgICAgdmFyIHRva2VuTWV0YSA9IF90aGlzLmdldFRva2VuTWV0YWRhdGEocHJvdmlkZXIudG9rZW4pO1xuICAgICAgICAgICAgICAgICAgaWYgKHRva2VuTWV0YS5yZWZlcmVuY2UgPT09XG4gICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZUlkZW50aWZpZXJUb2tlbihJZGVudGlmaWVycy5BTkFMWVpFX0ZPUl9FTlRSWV9DT01QT05FTlRTKS5yZWZlcmVuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRFbnRyeUNvbXBvbmVudHMucHVzaC5hcHBseSh0YXJnZXRFbnRyeUNvbXBvbmVudHMsIF90aGlzLl9nZXRFbnRyeUNvbXBvbmVudHNGcm9tUHJvdmlkZXIocHJvdmlkZXIpKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbXBpbGVQcm92aWRlciA9IF90aGlzLmdldFByb3ZpZGVyTWV0YWRhdGEocHJvdmlkZXIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKGlzVmFsaWRUeXBlKHByb3ZpZGVyKSkge1xuICAgICAgICAgICAgICAgICAgY29tcGlsZVByb3ZpZGVyID0gX3RoaXMuZ2V0VHlwZU1ldGFkYXRhKHByb3ZpZGVyLCBzdGF0aWNUeXBlTW9kdWxlVXJsKHByb3ZpZGVyKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcHJvdmlkZXJzSW5mbyA9IHByb3ZpZGVycy5yZWR1Y2UoZnVuY3Rpb24gKHNvRmFyLCBzZWVuUHJvdmlkZXIsIHNlZW5Qcm92aWRlcklkeCkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWVuUHJvdmlkZXJJZHggPCBwcm92aWRlcklkeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzb0Zhci5wdXNoKFwiXCIgKyBzdHJpbmdpZnkoc2VlblByb3ZpZGVyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNlZW5Qcm92aWRlcklkeCA9PSBwcm92aWRlcklkeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzb0Zhci5wdXNoKFwiP1wiICsgc3RyaW5naWZ5KHNlZW5Qcm92aWRlcikgKyBcIj9cIik7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNlZW5Qcm92aWRlcklkeCA9PSBwcm92aWRlcklkeCArIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc29GYXIucHVzaCgnLi4uJyk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzb0ZhcjtcbiAgICAgICAgICAgICAgICAgIH0sIFtdKVxuICAgICAgICAgICAgICAgICAgICAgIC5qb2luKCcsICcpO1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBcIiArIChkZWJ1Z0luZm8gPyBkZWJ1Z0luZm8gOiAncHJvdmlkZXInKSArIFwiIC0gb25seSBpbnN0YW5jZXMgb2YgUHJvdmlkZXIgYW5kIFR5cGUgYXJlIGFsbG93ZWQsIGdvdDogW1wiICsgcHJvdmlkZXJzSW5mbyArIFwiXVwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoY29tcGlsZVByb3ZpZGVyKSB7XG4gICAgICAgICAgICAgICAgICBjb21waWxlUHJvdmlkZXJzLnB1c2goY29tcGlsZVByb3ZpZGVyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBjb21waWxlUHJvdmlkZXJzO1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5fZ2V0RW50cnlDb21wb25lbnRzRnJvbVByb3ZpZGVyID0gZnVuY3Rpb24gKHByb3ZpZGVyKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgY29tcG9uZW50cyA9IFtdO1xuICAgICAgICAgIHZhciBjb2xsZWN0ZWRJZGVudGlmaWVycyA9IFtdO1xuICAgICAgICAgIGlmIChwcm92aWRlci51c2VGYWN0b3J5IHx8IHByb3ZpZGVyLnVzZUV4aXN0aW5nIHx8IHByb3ZpZGVyLnVzZUNsYXNzKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBBTkFMWVpFX0ZPUl9FTlRSWV9DT01QT05FTlRTIHRva2VuIG9ubHkgc3VwcG9ydHMgdXNlVmFsdWUhXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXByb3ZpZGVyLm11bHRpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBBTkFMWVpFX0ZPUl9FTlRSWV9DT01QT05FTlRTIHRva2VuIG9ubHkgc3VwcG9ydHMgJ211bHRpID0gdHJ1ZSchXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb252ZXJ0VG9Db21waWxlVmFsdWUocHJvdmlkZXIudXNlVmFsdWUsIGNvbGxlY3RlZElkZW50aWZpZXJzKTtcbiAgICAgICAgICBjb2xsZWN0ZWRJZGVudGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChpZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAgIHZhciBkaXJNZXRhID0gX3RoaXMuZ2V0RGlyZWN0aXZlTWV0YWRhdGEoaWRlbnRpZmllci5yZWZlcmVuY2UsIGZhbHNlKTtcbiAgICAgICAgICAgICAgaWYgKGRpck1ldGEpIHtcbiAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHMucHVzaChkaXJNZXRhLnR5cGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIGNvbXBvbmVudHM7XG4gICAgICB9O1xuICAgICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmdldFByb3ZpZGVyTWV0YWRhdGEgPSBmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgICAgICB2YXIgY29tcGlsZURlcHM7XG4gICAgICAgICAgdmFyIGNvbXBpbGVUeXBlTWV0YWRhdGEgPSBudWxsO1xuICAgICAgICAgIHZhciBjb21waWxlRmFjdG9yeU1ldGFkYXRhID0gbnVsbDtcbiAgICAgICAgICBpZiAocHJvdmlkZXIudXNlQ2xhc3MpIHtcbiAgICAgICAgICAgICAgY29tcGlsZVR5cGVNZXRhZGF0YSA9IHRoaXMuZ2V0VHlwZU1ldGFkYXRhKHByb3ZpZGVyLnVzZUNsYXNzLCBzdGF0aWNUeXBlTW9kdWxlVXJsKHByb3ZpZGVyLnVzZUNsYXNzKSwgcHJvdmlkZXIuZGVwZW5kZW5jaWVzKTtcbiAgICAgICAgICAgICAgY29tcGlsZURlcHMgPSBjb21waWxlVHlwZU1ldGFkYXRhLmRpRGVwcztcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAocHJvdmlkZXIudXNlRmFjdG9yeSkge1xuICAgICAgICAgICAgICBjb21waWxlRmFjdG9yeU1ldGFkYXRhID0gdGhpcy5nZXRGYWN0b3J5TWV0YWRhdGEocHJvdmlkZXIudXNlRmFjdG9yeSwgc3RhdGljVHlwZU1vZHVsZVVybChwcm92aWRlci51c2VGYWN0b3J5KSwgcHJvdmlkZXIuZGVwZW5kZW5jaWVzKTtcbiAgICAgICAgICAgICAgY29tcGlsZURlcHMgPSBjb21waWxlRmFjdG9yeU1ldGFkYXRhLmRpRGVwcztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBDb21waWxlUHJvdmlkZXJNZXRhZGF0YSh7XG4gICAgICAgICAgICAgIHRva2VuOiB0aGlzLmdldFRva2VuTWV0YWRhdGEocHJvdmlkZXIudG9rZW4pLFxuICAgICAgICAgICAgICB1c2VDbGFzczogY29tcGlsZVR5cGVNZXRhZGF0YSxcbiAgICAgICAgICAgICAgdXNlVmFsdWU6IGNvbnZlcnRUb0NvbXBpbGVWYWx1ZShwcm92aWRlci51c2VWYWx1ZSwgW10pLFxuICAgICAgICAgICAgICB1c2VGYWN0b3J5OiBjb21waWxlRmFjdG9yeU1ldGFkYXRhLFxuICAgICAgICAgICAgICB1c2VFeGlzdGluZzogcHJvdmlkZXIudXNlRXhpc3RpbmcgPyB0aGlzLmdldFRva2VuTWV0YWRhdGEocHJvdmlkZXIudXNlRXhpc3RpbmcpIDogbnVsbCxcbiAgICAgICAgICAgICAgZGVwczogY29tcGlsZURlcHMsXG4gICAgICAgICAgICAgIG11bHRpOiBwcm92aWRlci5tdWx0aVxuICAgICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5nZXRRdWVyaWVzTWV0YWRhdGEgPSBmdW5jdGlvbiAocXVlcmllcywgaXNWaWV3UXVlcnksIGRpcmVjdGl2ZVR5cGUpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciByZXMgPSBbXTtcbiAgICAgICAgICBPYmplY3Qua2V5cyhxdWVyaWVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgICAgICAgdmFyIHF1ZXJ5ID0gcXVlcmllc1twcm9wZXJ0eU5hbWVdO1xuICAgICAgICAgICAgICBpZiAocXVlcnkuaXNWaWV3UXVlcnkgPT09IGlzVmlld1F1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgICByZXMucHVzaChfdGhpcy5nZXRRdWVyeU1ldGFkYXRhKHF1ZXJ5LCBwcm9wZXJ0eU5hbWUsIGRpcmVjdGl2ZVR5cGUpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICB9O1xuICAgICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLl9xdWVyeVZhckJpbmRpbmdzID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7IHJldHVybiBzZWxlY3Rvci5zcGxpdCgvXFxzKixcXHMqLyk7IH07XG4gICAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuZ2V0UXVlcnlNZXRhZGF0YSA9IGZ1bmN0aW9uIChxLCBwcm9wZXJ0eU5hbWUsIHR5cGVPckZ1bmMpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBzZWxlY3RvcnM7XG4gICAgICAgICAgaWYgKHR5cGVvZiBxLnNlbGVjdG9yID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBzZWxlY3RvcnMgPSB0aGlzLl9xdWVyeVZhckJpbmRpbmdzKHEuc2VsZWN0b3IpLm1hcChmdW5jdGlvbiAodmFyTmFtZSkgeyByZXR1cm4gX3RoaXMuZ2V0VG9rZW5NZXRhZGF0YSh2YXJOYW1lKTsgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoIXEuc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGNvbnN0cnVjdCBhIHF1ZXJ5IGZvciB0aGUgcHJvcGVydHkgXFxcIlwiICsgcHJvcGVydHlOYW1lICsgXCJcXFwiIG9mIFxcXCJcIiArIHN0cmluZ2lmeSh0eXBlT3JGdW5jKSArIFwiXFxcIiBzaW5jZSB0aGUgcXVlcnkgc2VsZWN0b3Igd2Fzbid0IGRlZmluZWQuXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHNlbGVjdG9ycyA9IFt0aGlzLmdldFRva2VuTWV0YWRhdGEocS5zZWxlY3RvcildO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IENvbXBpbGVRdWVyeU1ldGFkYXRhKHtcbiAgICAgICAgICAgICAgc2VsZWN0b3JzOiBzZWxlY3RvcnMsXG4gICAgICAgICAgICAgIGZpcnN0OiBxLmZpcnN0LFxuICAgICAgICAgICAgICBkZXNjZW5kYW50czogcS5kZXNjZW5kYW50cywgcHJvcGVydHlOYW1lOiBwcm9wZXJ0eU5hbWUsXG4gICAgICAgICAgICAgIHJlYWQ6IHEucmVhZCA/IHRoaXMuZ2V0VG9rZW5NZXRhZGF0YShxLnJlYWQpIDogbnVsbFxuICAgICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcbiAgICAgIF07XG4gICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgIHsgdHlwZTogTmdNb2R1bGVSZXNvbHZlciwgfSxcbiAgICAgICAgICB7IHR5cGU6IERpcmVjdGl2ZVJlc29sdmVyLCB9LFxuICAgICAgICAgIHsgdHlwZTogUGlwZVJlc29sdmVyLCB9LFxuICAgICAgICAgIHsgdHlwZTogRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LCB9LFxuICAgICAgICAgIHsgdHlwZTogUmVmbGVjdG9yUmVhZGVyLCB9LFxuICAgICAgXTtcbiAgICAgIHJldHVybiBDb21waWxlTWV0YWRhdGFSZXNvbHZlcjtcbiAgfSgpKTtcbiAgZnVuY3Rpb24gZ2V0VHJhbnNpdGl2ZU1vZHVsZXMobW9kdWxlcywgaW5jbHVkZUltcG9ydHMsIHRhcmdldE1vZHVsZXMsIHZpc2l0ZWRNb2R1bGVzKSB7XG4gICAgICBpZiAodGFyZ2V0TW9kdWxlcyA9PT0gdm9pZCAwKSB7IHRhcmdldE1vZHVsZXMgPSBbXTsgfVxuICAgICAgaWYgKHZpc2l0ZWRNb2R1bGVzID09PSB2b2lkIDApIHsgdmlzaXRlZE1vZHVsZXMgPSBuZXcgU2V0KCk7IH1cbiAgICAgIG1vZHVsZXMuZm9yRWFjaChmdW5jdGlvbiAobmdNb2R1bGUpIHtcbiAgICAgICAgICBpZiAoIXZpc2l0ZWRNb2R1bGVzLmhhcyhuZ01vZHVsZS50eXBlLnJlZmVyZW5jZSkpIHtcbiAgICAgICAgICAgICAgdmlzaXRlZE1vZHVsZXMuYWRkKG5nTW9kdWxlLnR5cGUucmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgdmFyIG5lc3RlZE1vZHVsZXMgPSBpbmNsdWRlSW1wb3J0cyA/XG4gICAgICAgICAgICAgICAgICBuZ01vZHVsZS5pbXBvcnRlZE1vZHVsZXMuY29uY2F0KG5nTW9kdWxlLmV4cG9ydGVkTW9kdWxlcykgOlxuICAgICAgICAgICAgICAgICAgbmdNb2R1bGUuZXhwb3J0ZWRNb2R1bGVzO1xuICAgICAgICAgICAgICBnZXRUcmFuc2l0aXZlTW9kdWxlcyhuZXN0ZWRNb2R1bGVzLCBpbmNsdWRlSW1wb3J0cywgdGFyZ2V0TW9kdWxlcywgdmlzaXRlZE1vZHVsZXMpO1xuICAgICAgICAgICAgICAvLyBBZGQgYWZ0ZXIgcmVjdXJzaW5nIHNvIGltcG9ydGVkL2V4cG9ydGVkIG1vZHVsZXMgYXJlIGJlZm9yZSB0aGUgbW9kdWxlIGl0c2VsZi5cbiAgICAgICAgICAgICAgLy8gVGhpcyBpcyBpbXBvcnRhbnQgZm9yIG92ZXJ3cml0aW5nIHByb3ZpZGVycyBvZiBpbXBvcnRlZCBtb2R1bGVzIVxuICAgICAgICAgICAgICB0YXJnZXRNb2R1bGVzLnB1c2gobmdNb2R1bGUpO1xuICAgICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRhcmdldE1vZHVsZXM7XG4gIH1cbiAgZnVuY3Rpb24gZmxhdHRlbkFycmF5KHRyZWUsIG91dCkge1xuICAgICAgaWYgKG91dCA9PT0gdm9pZCAwKSB7IG91dCA9IFtdOyB9XG4gICAgICBpZiAodHJlZSkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJlZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YXIgaXRlbSA9IF9hbmd1bGFyX2NvcmUucmVzb2x2ZUZvcndhcmRSZWYodHJlZVtpXSk7XG4gICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICBmbGF0dGVuQXJyYXkoaXRlbSwgb3V0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG91dC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG91dDtcbiAgfVxuICBmdW5jdGlvbiBpc1ZhbGlkVHlwZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzU3RhdGljU3ltYm9sKHZhbHVlKSB8fCAodmFsdWUgaW5zdGFuY2VvZiBfYW5ndWxhcl9jb3JlLlR5cGUpO1xuICB9XG4gIGZ1bmN0aW9uIHN0YXRpY1R5cGVNb2R1bGVVcmwodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc1N0YXRpY1N5bWJvbCh2YWx1ZSkgPyB2YWx1ZS5maWxlUGF0aCA6IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gY29tcG9uZW50TW9kdWxlVXJsKHJlZmxlY3RvciwgdHlwZSwgY21wTWV0YWRhdGEpIHtcbiAgICAgIGlmIChpc1N0YXRpY1N5bWJvbCh0eXBlKSkge1xuICAgICAgICAgIHJldHVybiBzdGF0aWNUeXBlTW9kdWxlVXJsKHR5cGUpO1xuICAgICAgfVxuICAgICAgdmFyIG1vZHVsZUlkID0gY21wTWV0YWRhdGEubW9kdWxlSWQ7XG4gICAgICBpZiAodHlwZW9mIG1vZHVsZUlkID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHZhciBzY2hlbWUgPSBnZXRVcmxTY2hlbWUobW9kdWxlSWQpO1xuICAgICAgICAgIHJldHVybiBzY2hlbWUgPyBtb2R1bGVJZCA6IFwicGFja2FnZTpcIiArIG1vZHVsZUlkICsgTU9EVUxFX1NVRkZJWDtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG1vZHVsZUlkICE9PSBudWxsICYmIG1vZHVsZUlkICE9PSB2b2lkIDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKFwibW9kdWxlSWQgc2hvdWxkIGJlIGEgc3RyaW5nIGluIFxcXCJcIiArIHN0cmluZ2lmeSh0eXBlKSArIFwiXFxcIi4gU2VlIGh0dHBzOi8vZ29vLmdsL3dJRERpTCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cXG5cIikgK1xuICAgICAgICAgICAgICBcIklmIHlvdSdyZSB1c2luZyBXZWJwYWNrIHlvdSBzaG91bGQgaW5saW5lIHRoZSB0ZW1wbGF0ZSBhbmQgdGhlIHN0eWxlcywgc2VlIGh0dHBzOi8vZ29vLmdsL1gySjh6Yy5cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVmbGVjdG9yLmltcG9ydFVyaSh0eXBlKTtcbiAgfVxuICBmdW5jdGlvbiBjb252ZXJ0VG9Db21waWxlVmFsdWUodmFsdWUsIHRhcmdldElkZW50aWZpZXJzKSB7XG4gICAgICByZXR1cm4gdmlzaXRWYWx1ZSh2YWx1ZSwgbmV3IF9Db21waWxlVmFsdWVDb252ZXJ0ZXIoKSwgdGFyZ2V0SWRlbnRpZmllcnMpO1xuICB9XG4gIHZhciBfQ29tcGlsZVZhbHVlQ29udmVydGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQxNihfQ29tcGlsZVZhbHVlQ29udmVydGVyLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gX0NvbXBpbGVWYWx1ZUNvbnZlcnRlcigpIHtcbiAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIF9Db21waWxlVmFsdWVDb252ZXJ0ZXIucHJvdG90eXBlLnZpc2l0T3RoZXIgPSBmdW5jdGlvbiAodmFsdWUsIHRhcmdldElkZW50aWZpZXJzKSB7XG4gICAgICAgICAgdmFyIGlkZW50aWZpZXI7XG4gICAgICAgICAgaWYgKGlzU3RhdGljU3ltYm9sKHZhbHVlKSkge1xuICAgICAgICAgICAgICBpZGVudGlmaWVyID0gbmV3IENvbXBpbGVJZGVudGlmaWVyTWV0YWRhdGEoeyBuYW1lOiB2YWx1ZS5uYW1lLCBtb2R1bGVVcmw6IHZhbHVlLmZpbGVQYXRoLCByZWZlcmVuY2U6IHZhbHVlIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgaWRlbnRpZmllciA9IG5ldyBDb21waWxlSWRlbnRpZmllck1ldGFkYXRhKHsgcmVmZXJlbmNlOiB2YWx1ZSB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGFyZ2V0SWRlbnRpZmllcnMucHVzaChpZGVudGlmaWVyKTtcbiAgICAgICAgICByZXR1cm4gaWRlbnRpZmllcjtcbiAgICAgIH07XG4gICAgICByZXR1cm4gX0NvbXBpbGVWYWx1ZUNvbnZlcnRlcjtcbiAgfShWYWx1ZVRyYW5zZm9ybWVyKSk7XG5cbiAgdmFyIENvbXBvbmVudEZhY3RvcnlEZXBlbmRlbmN5JDEgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQ29tcG9uZW50RmFjdG9yeURlcGVuZGVuY3koY29tcCwgcGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICB0aGlzLmNvbXAgPSBjb21wO1xuICAgICAgICAgIHRoaXMucGxhY2Vob2xkZXIgPSBwbGFjZWhvbGRlcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBDb21wb25lbnRGYWN0b3J5RGVwZW5kZW5jeTtcbiAgfSgpKTtcbiAgdmFyIE5nTW9kdWxlQ29tcGlsZVJlc3VsdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBOZ01vZHVsZUNvbXBpbGVSZXN1bHQoc3RhdGVtZW50cywgbmdNb2R1bGVGYWN0b3J5VmFyLCBkZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlbWVudHMgPSBzdGF0ZW1lbnRzO1xuICAgICAgICAgIHRoaXMubmdNb2R1bGVGYWN0b3J5VmFyID0gbmdNb2R1bGVGYWN0b3J5VmFyO1xuICAgICAgICAgIHRoaXMuZGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE5nTW9kdWxlQ29tcGlsZVJlc3VsdDtcbiAgfSgpKTtcbiAgdmFyIE5nTW9kdWxlQ29tcGlsZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gTmdNb2R1bGVDb21waWxlcigpIHtcbiAgICAgIH1cbiAgICAgIE5nTW9kdWxlQ29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGUgPSBmdW5jdGlvbiAobmdNb2R1bGVNZXRhLCBleHRyYVByb3ZpZGVycykge1xuICAgICAgICAgIHZhciBzb3VyY2VGaWxlTmFtZSA9IGlzUHJlc2VudChuZ01vZHVsZU1ldGEudHlwZS5tb2R1bGVVcmwpID9cbiAgICAgICAgICAgICAgXCJpbiBOZ01vZHVsZSBcIiArIG5nTW9kdWxlTWV0YS50eXBlLm5hbWUgKyBcIiBpbiBcIiArIG5nTW9kdWxlTWV0YS50eXBlLm1vZHVsZVVybCA6XG4gICAgICAgICAgICAgIFwiaW4gTmdNb2R1bGUgXCIgKyBuZ01vZHVsZU1ldGEudHlwZS5uYW1lO1xuICAgICAgICAgIHZhciBzb3VyY2VGaWxlID0gbmV3IFBhcnNlU291cmNlRmlsZSgnJywgc291cmNlRmlsZU5hbWUpO1xuICAgICAgICAgIHZhciBzb3VyY2VTcGFuID0gbmV3IFBhcnNlU291cmNlU3BhbihuZXcgUGFyc2VMb2NhdGlvbihzb3VyY2VGaWxlLCBudWxsLCBudWxsLCBudWxsKSwgbmV3IFBhcnNlTG9jYXRpb24oc291cmNlRmlsZSwgbnVsbCwgbnVsbCwgbnVsbCkpO1xuICAgICAgICAgIHZhciBkZXBzID0gW107XG4gICAgICAgICAgdmFyIGJvb3RzdHJhcENvbXBvbmVudEZhY3RvcmllcyA9IFtdO1xuICAgICAgICAgIHZhciBlbnRyeUNvbXBvbmVudEZhY3RvcmllcyA9IG5nTW9kdWxlTWV0YS50cmFuc2l0aXZlTW9kdWxlLmVudHJ5Q29tcG9uZW50cy5tYXAoZnVuY3Rpb24gKGVudHJ5Q29tcG9uZW50KSB7XG4gICAgICAgICAgICAgIHZhciBpZCA9IG5ldyBDb21waWxlSWRlbnRpZmllck1ldGFkYXRhKHsgbmFtZTogZW50cnlDb21wb25lbnQubmFtZSB9KTtcbiAgICAgICAgICAgICAgaWYgKG5nTW9kdWxlTWV0YS5ib290c3RyYXBDb21wb25lbnRzLmluZGV4T2YoZW50cnlDb21wb25lbnQpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgIGJvb3RzdHJhcENvbXBvbmVudEZhY3Rvcmllcy5wdXNoKGlkKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkZXBzLnB1c2gobmV3IENvbXBvbmVudEZhY3RvcnlEZXBlbmRlbmN5JDEoZW50cnlDb21wb25lbnQsIGlkKSk7XG4gICAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgYnVpbGRlciA9IG5ldyBfSW5qZWN0b3JCdWlsZGVyKG5nTW9kdWxlTWV0YSwgZW50cnlDb21wb25lbnRGYWN0b3JpZXMsIGJvb3RzdHJhcENvbXBvbmVudEZhY3Rvcmllcywgc291cmNlU3Bhbik7XG4gICAgICAgICAgdmFyIHByb3ZpZGVyUGFyc2VyID0gbmV3IE5nTW9kdWxlUHJvdmlkZXJBbmFseXplcihuZ01vZHVsZU1ldGEsIGV4dHJhUHJvdmlkZXJzLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICBwcm92aWRlclBhcnNlci5wYXJzZSgpLmZvckVhY2goZnVuY3Rpb24gKHByb3ZpZGVyKSB7IHJldHVybiBidWlsZGVyLmFkZFByb3ZpZGVyKHByb3ZpZGVyKTsgfSk7XG4gICAgICAgICAgdmFyIGluamVjdG9yQ2xhc3MgPSBidWlsZGVyLmJ1aWxkKCk7XG4gICAgICAgICAgdmFyIG5nTW9kdWxlRmFjdG9yeVZhciA9IG5nTW9kdWxlTWV0YS50eXBlLm5hbWUgKyBcIk5nRmFjdG9yeVwiO1xuICAgICAgICAgIHZhciBuZ01vZHVsZUZhY3RvcnlTdG10ID0gdmFyaWFibGUobmdNb2R1bGVGYWN0b3J5VmFyKVxuICAgICAgICAgICAgICAuc2V0KGltcG9ydEV4cHIocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuTmdNb2R1bGVGYWN0b3J5KSlcbiAgICAgICAgICAgICAgLmluc3RhbnRpYXRlKFt2YXJpYWJsZShpbmplY3RvckNsYXNzLm5hbWUpLCBpbXBvcnRFeHByKG5nTW9kdWxlTWV0YS50eXBlKV0sIGltcG9ydFR5cGUocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuTmdNb2R1bGVGYWN0b3J5KSwgW2ltcG9ydFR5cGUobmdNb2R1bGVNZXRhLnR5cGUpXSwgW1R5cGVNb2RpZmllci5Db25zdF0pKSlcbiAgICAgICAgICAgICAgLnRvRGVjbFN0bXQobnVsbCwgW1N0bXRNb2RpZmllci5GaW5hbF0pO1xuICAgICAgICAgIHZhciBzdG10cyA9IFtpbmplY3RvckNsYXNzLCBuZ01vZHVsZUZhY3RvcnlTdG10XTtcbiAgICAgICAgICBpZiAobmdNb2R1bGVNZXRhLmlkKSB7XG4gICAgICAgICAgICAgIHZhciByZWdpc3RlckZhY3RvcnlTdG10ID0gaW1wb3J0RXhwcihyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5SZWdpc3Rlck1vZHVsZUZhY3RvcnlGbikpXG4gICAgICAgICAgICAgICAgICAuY2FsbEZuKFtsaXRlcmFsKG5nTW9kdWxlTWV0YS5pZCksIHZhcmlhYmxlKG5nTW9kdWxlRmFjdG9yeVZhcildKVxuICAgICAgICAgICAgICAgICAgLnRvU3RtdCgpO1xuICAgICAgICAgICAgICBzdG10cy5wdXNoKHJlZ2lzdGVyRmFjdG9yeVN0bXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IE5nTW9kdWxlQ29tcGlsZVJlc3VsdChzdG10cywgbmdNb2R1bGVGYWN0b3J5VmFyLCBkZXBzKTtcbiAgICAgIH07XG4gICAgICBOZ01vZHVsZUNvbXBpbGVyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcbiAgICAgIF07XG4gICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgIE5nTW9kdWxlQ29tcGlsZXIuY3RvclBhcmFtZXRlcnMgPSBbXTtcbiAgICAgIHJldHVybiBOZ01vZHVsZUNvbXBpbGVyO1xuICB9KCkpO1xuICB2YXIgX0luamVjdG9yQnVpbGRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBfSW5qZWN0b3JCdWlsZGVyKF9uZ01vZHVsZU1ldGEsIF9lbnRyeUNvbXBvbmVudEZhY3RvcmllcywgX2Jvb3RzdHJhcENvbXBvbmVudEZhY3RvcmllcywgX3NvdXJjZVNwYW4pIHtcbiAgICAgICAgICB0aGlzLl9uZ01vZHVsZU1ldGEgPSBfbmdNb2R1bGVNZXRhO1xuICAgICAgICAgIHRoaXMuX2VudHJ5Q29tcG9uZW50RmFjdG9yaWVzID0gX2VudHJ5Q29tcG9uZW50RmFjdG9yaWVzO1xuICAgICAgICAgIHRoaXMuX2Jvb3RzdHJhcENvbXBvbmVudEZhY3RvcmllcyA9IF9ib290c3RyYXBDb21wb25lbnRGYWN0b3JpZXM7XG4gICAgICAgICAgdGhpcy5fc291cmNlU3BhbiA9IF9zb3VyY2VTcGFuO1xuICAgICAgICAgIHRoaXMuX3Rva2VucyA9IFtdO1xuICAgICAgICAgIHRoaXMuX2luc3RhbmNlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICB0aGlzLl9maWVsZHMgPSBbXTtcbiAgICAgICAgICB0aGlzLl9jcmVhdGVTdG10cyA9IFtdO1xuICAgICAgICAgIHRoaXMuX2Rlc3Ryb3lTdG10cyA9IFtdO1xuICAgICAgICAgIHRoaXMuX2dldHRlcnMgPSBbXTtcbiAgICAgIH1cbiAgICAgIF9JbmplY3RvckJ1aWxkZXIucHJvdG90eXBlLmFkZFByb3ZpZGVyID0gZnVuY3Rpb24gKHJlc29sdmVkUHJvdmlkZXIpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBwcm92aWRlclZhbHVlRXhwcmVzc2lvbnMgPSByZXNvbHZlZFByb3ZpZGVyLnByb3ZpZGVycy5tYXAoZnVuY3Rpb24gKHByb3ZpZGVyKSB7IHJldHVybiBfdGhpcy5fZ2V0UHJvdmlkZXJWYWx1ZShwcm92aWRlcik7IH0pO1xuICAgICAgICAgIHZhciBwcm9wTmFtZSA9IFwiX1wiICsgcmVzb2x2ZWRQcm92aWRlci50b2tlbi5uYW1lICsgXCJfXCIgKyB0aGlzLl9pbnN0YW5jZXMuc2l6ZTtcbiAgICAgICAgICB2YXIgaW5zdGFuY2UgPSB0aGlzLl9jcmVhdGVQcm92aWRlclByb3BlcnR5KHByb3BOYW1lLCByZXNvbHZlZFByb3ZpZGVyLCBwcm92aWRlclZhbHVlRXhwcmVzc2lvbnMsIHJlc29sdmVkUHJvdmlkZXIubXVsdGlQcm92aWRlciwgcmVzb2x2ZWRQcm92aWRlci5lYWdlcik7XG4gICAgICAgICAgaWYgKHJlc29sdmVkUHJvdmlkZXIubGlmZWN5Y2xlSG9va3MuaW5kZXhPZihMaWZlY3ljbGVIb29rcy5PbkRlc3Ryb3kpICE9PSAtMSkge1xuICAgICAgICAgICAgICB0aGlzLl9kZXN0cm95U3RtdHMucHVzaChpbnN0YW5jZS5jYWxsTWV0aG9kKCduZ09uRGVzdHJveScsIFtdKS50b1N0bXQoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3Rva2Vucy5wdXNoKHJlc29sdmVkUHJvdmlkZXIudG9rZW4pO1xuICAgICAgICAgIHRoaXMuX2luc3RhbmNlcy5zZXQocmVzb2x2ZWRQcm92aWRlci50b2tlbi5yZWZlcmVuY2UsIGluc3RhbmNlKTtcbiAgICAgIH07XG4gICAgICBfSW5qZWN0b3JCdWlsZGVyLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBnZXRNZXRob2RTdG10cyA9IHRoaXMuX3Rva2Vucy5tYXAoZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgICAgICAgIHZhciBwcm92aWRlckV4cHIgPSBfdGhpcy5faW5zdGFuY2VzLmdldCh0b2tlbi5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IElmU3RtdChJbmplY3RNZXRob2RWYXJzJDEudG9rZW4uaWRlbnRpY2FsKGNyZWF0ZURpVG9rZW5FeHByZXNzaW9uKHRva2VuKSksIFtuZXcgUmV0dXJuU3RhdGVtZW50KHByb3ZpZGVyRXhwcildKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgbWV0aG9kcyA9IFtcbiAgICAgICAgICAgICAgbmV3IENsYXNzTWV0aG9kKCdjcmVhdGVJbnRlcm5hbCcsIFtdLCB0aGlzLl9jcmVhdGVTdG10cy5jb25jYXQobmV3IFJldHVyblN0YXRlbWVudCh0aGlzLl9pbnN0YW5jZXMuZ2V0KHRoaXMuX25nTW9kdWxlTWV0YS50eXBlLnJlZmVyZW5jZSkpKSwgaW1wb3J0VHlwZSh0aGlzLl9uZ01vZHVsZU1ldGEudHlwZSkpLFxuICAgICAgICAgICAgICBuZXcgQ2xhc3NNZXRob2QoJ2dldEludGVybmFsJywgW1xuICAgICAgICAgICAgICAgICAgbmV3IEZuUGFyYW0oSW5qZWN0TWV0aG9kVmFycyQxLnRva2VuLm5hbWUsIERZTkFNSUNfVFlQRSksXG4gICAgICAgICAgICAgICAgICBuZXcgRm5QYXJhbShJbmplY3RNZXRob2RWYXJzJDEubm90Rm91bmRSZXN1bHQubmFtZSwgRFlOQU1JQ19UWVBFKVxuICAgICAgICAgICAgICBdLCBnZXRNZXRob2RTdG10cy5jb25jYXQoW25ldyBSZXR1cm5TdGF0ZW1lbnQoSW5qZWN0TWV0aG9kVmFycyQxLm5vdEZvdW5kUmVzdWx0KV0pLCBEWU5BTUlDX1RZUEUpLFxuICAgICAgICAgICAgICBuZXcgQ2xhc3NNZXRob2QoJ2Rlc3Ryb3lJbnRlcm5hbCcsIFtdLCB0aGlzLl9kZXN0cm95U3RtdHMpLFxuICAgICAgICAgIF07XG4gICAgICAgICAgdmFyIGN0b3IgPSBuZXcgQ2xhc3NNZXRob2QobnVsbCwgW25ldyBGblBhcmFtKEluamVjdG9yUHJvcHMucGFyZW50Lm5hbWUsIGltcG9ydFR5cGUocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuSW5qZWN0b3IpKSldLCBbU1VQRVJfRVhQUlxuICAgICAgICAgICAgICAgICAgLmNhbGxGbihbXG4gICAgICAgICAgICAgICAgICB2YXJpYWJsZShJbmplY3RvclByb3BzLnBhcmVudC5uYW1lKSxcbiAgICAgICAgICAgICAgICAgIGxpdGVyYWxBcnIodGhpcy5fZW50cnlDb21wb25lbnRGYWN0b3JpZXMubWFwKGZ1bmN0aW9uIChjb21wb25lbnRGYWN0b3J5KSB7IHJldHVybiBpbXBvcnRFeHByKGNvbXBvbmVudEZhY3RvcnkpOyB9KSksXG4gICAgICAgICAgICAgICAgICBsaXRlcmFsQXJyKHRoaXMuX2Jvb3RzdHJhcENvbXBvbmVudEZhY3Rvcmllcy5tYXAoZnVuY3Rpb24gKGNvbXBvbmVudEZhY3RvcnkpIHsgcmV0dXJuIGltcG9ydEV4cHIoY29tcG9uZW50RmFjdG9yeSk7IH0pKVxuICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgLnRvU3RtdCgpXSk7XG4gICAgICAgICAgdmFyIGluakNsYXNzTmFtZSA9IHRoaXMuX25nTW9kdWxlTWV0YS50eXBlLm5hbWUgKyBcIkluamVjdG9yXCI7XG4gICAgICAgICAgcmV0dXJuIG5ldyBDbGFzc1N0bXQoaW5qQ2xhc3NOYW1lLCBpbXBvcnRFeHByKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLk5nTW9kdWxlSW5qZWN0b3IpLCBbaW1wb3J0VHlwZSh0aGlzLl9uZ01vZHVsZU1ldGEudHlwZSldKSwgdGhpcy5fZmllbGRzLCB0aGlzLl9nZXR0ZXJzLCBjdG9yLCBtZXRob2RzKTtcbiAgICAgIH07XG4gICAgICBfSW5qZWN0b3JCdWlsZGVyLnByb3RvdHlwZS5fZ2V0UHJvdmlkZXJWYWx1ZSA9IGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KHByb3ZpZGVyLnVzZUV4aXN0aW5nKSkge1xuICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9nZXREZXBlbmRlbmN5KG5ldyBDb21waWxlRGlEZXBlbmRlbmN5TWV0YWRhdGEoeyB0b2tlbjogcHJvdmlkZXIudXNlRXhpc3RpbmcgfSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChpc1ByZXNlbnQocHJvdmlkZXIudXNlRmFjdG9yeSkpIHtcbiAgICAgICAgICAgICAgdmFyIGRlcHMgPSBwcm92aWRlci5kZXBzIHx8IHByb3ZpZGVyLnVzZUZhY3RvcnkuZGlEZXBzO1xuICAgICAgICAgICAgICB2YXIgZGVwc0V4cHIgPSBkZXBzLm1hcChmdW5jdGlvbiAoZGVwKSB7IHJldHVybiBfdGhpcy5fZ2V0RGVwZW5kZW5jeShkZXApOyB9KTtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gaW1wb3J0RXhwcihwcm92aWRlci51c2VGYWN0b3J5KS5jYWxsRm4oZGVwc0V4cHIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChpc1ByZXNlbnQocHJvdmlkZXIudXNlQ2xhc3MpKSB7XG4gICAgICAgICAgICAgIHZhciBkZXBzID0gcHJvdmlkZXIuZGVwcyB8fCBwcm92aWRlci51c2VDbGFzcy5kaURlcHM7XG4gICAgICAgICAgICAgIHZhciBkZXBzRXhwciA9IGRlcHMubWFwKGZ1bmN0aW9uIChkZXApIHsgcmV0dXJuIF90aGlzLl9nZXREZXBlbmRlbmN5KGRlcCk7IH0pO1xuICAgICAgICAgICAgICByZXN1bHQgPVxuICAgICAgICAgICAgICAgICAgaW1wb3J0RXhwcihwcm92aWRlci51c2VDbGFzcykuaW5zdGFudGlhdGUoZGVwc0V4cHIsIGltcG9ydFR5cGUocHJvdmlkZXIudXNlQ2xhc3MpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IGNvbnZlcnRWYWx1ZVRvT3V0cHV0QXN0KHByb3ZpZGVyLnVzZVZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgICBfSW5qZWN0b3JCdWlsZGVyLnByb3RvdHlwZS5fY3JlYXRlUHJvdmlkZXJQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wTmFtZSwgcHJvdmlkZXIsIHByb3ZpZGVyVmFsdWVFeHByZXNzaW9ucywgaXNNdWx0aSwgaXNFYWdlcikge1xuICAgICAgICAgIHZhciByZXNvbHZlZFByb3ZpZGVyVmFsdWVFeHByO1xuICAgICAgICAgIHZhciB0eXBlO1xuICAgICAgICAgIGlmIChpc011bHRpKSB7XG4gICAgICAgICAgICAgIHJlc29sdmVkUHJvdmlkZXJWYWx1ZUV4cHIgPSBsaXRlcmFsQXJyKHByb3ZpZGVyVmFsdWVFeHByZXNzaW9ucyk7XG4gICAgICAgICAgICAgIHR5cGUgPSBuZXcgQXJyYXlUeXBlKERZTkFNSUNfVFlQRSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICByZXNvbHZlZFByb3ZpZGVyVmFsdWVFeHByID0gcHJvdmlkZXJWYWx1ZUV4cHJlc3Npb25zWzBdO1xuICAgICAgICAgICAgICB0eXBlID0gcHJvdmlkZXJWYWx1ZUV4cHJlc3Npb25zWzBdLnR5cGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgICAgICB0eXBlID0gRFlOQU1JQ19UWVBFO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNFYWdlcikge1xuICAgICAgICAgICAgICB0aGlzLl9maWVsZHMucHVzaChuZXcgQ2xhc3NGaWVsZChwcm9wTmFtZSwgdHlwZSkpO1xuICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVTdG10cy5wdXNoKFRISVNfRVhQUi5wcm9wKHByb3BOYW1lKS5zZXQocmVzb2x2ZWRQcm92aWRlclZhbHVlRXhwcikudG9TdG10KCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIGludGVybmFsRmllbGQgPSBcIl9cIiArIHByb3BOYW1lO1xuICAgICAgICAgICAgICB0aGlzLl9maWVsZHMucHVzaChuZXcgQ2xhc3NGaWVsZChpbnRlcm5hbEZpZWxkLCB0eXBlKSk7XG4gICAgICAgICAgICAgIC8vIE5vdGU6IEVxdWFscyBpcyBpbXBvcnRhbnQgZm9yIEpTIHNvIHRoYXQgaXQgYWxzbyBjaGVja3MgdGhlIHVuZGVmaW5lZCBjYXNlIVxuICAgICAgICAgICAgICB2YXIgZ2V0dGVyU3RtdHMgPSBbXG4gICAgICAgICAgICAgICAgICBuZXcgSWZTdG10KFRISVNfRVhQUi5wcm9wKGludGVybmFsRmllbGQpLmlzQmxhbmsoKSwgW1RISVNfRVhQUi5wcm9wKGludGVybmFsRmllbGQpLnNldChyZXNvbHZlZFByb3ZpZGVyVmFsdWVFeHByKS50b1N0bXQoKV0pLFxuICAgICAgICAgICAgICAgICAgbmV3IFJldHVyblN0YXRlbWVudChUSElTX0VYUFIucHJvcChpbnRlcm5hbEZpZWxkKSlcbiAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgdGhpcy5fZ2V0dGVycy5wdXNoKG5ldyBDbGFzc0dldHRlcihwcm9wTmFtZSwgZ2V0dGVyU3RtdHMsIHR5cGUpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFRISVNfRVhQUi5wcm9wKHByb3BOYW1lKTtcbiAgICAgIH07XG4gICAgICBfSW5qZWN0b3JCdWlsZGVyLnByb3RvdHlwZS5fZ2V0RGVwZW5kZW5jeSA9IGZ1bmN0aW9uIChkZXApIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICBpZiAoZGVwLmlzVmFsdWUpIHtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gbGl0ZXJhbChkZXAudmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWRlcC5pc1NraXBTZWxmKSB7XG4gICAgICAgICAgICAgIGlmIChkZXAudG9rZW4gJiZcbiAgICAgICAgICAgICAgICAgIChkZXAudG9rZW4ucmVmZXJlbmNlID09PSByZXNvbHZlSWRlbnRpZmllclRva2VuKElkZW50aWZpZXJzLkluamVjdG9yKS5yZWZlcmVuY2UgfHxcbiAgICAgICAgICAgICAgICAgICAgICBkZXAudG9rZW4ucmVmZXJlbmNlID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlSWRlbnRpZmllclRva2VuKElkZW50aWZpZXJzLkNvbXBvbmVudEZhY3RvcnlSZXNvbHZlcikucmVmZXJlbmNlKSkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gVEhJU19FWFBSO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9pbnN0YW5jZXMuZ2V0KGRlcC50b2tlbi5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgIHZhciBhcmdzID0gW2NyZWF0ZURpVG9rZW5FeHByZXNzaW9uKGRlcC50b2tlbildO1xuICAgICAgICAgICAgICBpZiAoZGVwLmlzT3B0aW9uYWwpIHtcbiAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaChOVUxMX0VYUFIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc3VsdCA9IEluamVjdG9yUHJvcHMucGFyZW50LmNhbGxNZXRob2QoJ2dldCcsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICAgIHJldHVybiBfSW5qZWN0b3JCdWlsZGVyO1xuICB9KCkpO1xuICB2YXIgSW5qZWN0b3JQcm9wcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBJbmplY3RvclByb3BzKCkge1xuICAgICAgfVxuICAgICAgSW5qZWN0b3JQcm9wcy5wYXJlbnQgPSBUSElTX0VYUFIucHJvcCgncGFyZW50Jyk7XG4gICAgICByZXR1cm4gSW5qZWN0b3JQcm9wcztcbiAgfSgpKTtcbiAgdmFyIEluamVjdE1ldGhvZFZhcnMkMSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBJbmplY3RNZXRob2RWYXJzKCkge1xuICAgICAgfVxuICAgICAgSW5qZWN0TWV0aG9kVmFycy50b2tlbiA9IHZhcmlhYmxlKCd0b2tlbicpO1xuICAgICAgSW5qZWN0TWV0aG9kVmFycy5ub3RGb3VuZFJlc3VsdCA9IHZhcmlhYmxlKCdub3RGb3VuZFJlc3VsdCcpO1xuICAgICAgcmV0dXJuIEluamVjdE1ldGhvZFZhcnM7XG4gIH0oKSk7XG5cbiAgdmFyIF9TSU5HTEVfUVVPVEVfRVNDQVBFX1NUUklOR19SRSA9IC8nfFxcXFx8XFxufFxccnxcXCQvZztcbiAgdmFyIF9MRUdBTF9JREVOVElGSUVSX1JFID0gL15bJEEtWl9dWzAtOUEtWl8kXSokL2k7XG4gIHZhciBDQVRDSF9FUlJPUl9WQVIkMiA9IHZhcmlhYmxlKCdlcnJvcicpO1xuICB2YXIgQ0FUQ0hfU1RBQ0tfVkFSJDIgPSB2YXJpYWJsZSgnc3RhY2snKTtcbiAgdmFyIF9FbWl0dGVkTGluZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBfRW1pdHRlZExpbmUoaW5kZW50KSB7XG4gICAgICAgICAgdGhpcy5pbmRlbnQgPSBpbmRlbnQ7XG4gICAgICAgICAgdGhpcy5wYXJ0cyA9IFtdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9FbWl0dGVkTGluZTtcbiAgfSgpKTtcbiAgdmFyIEVtaXR0ZXJWaXNpdG9yQ29udGV4dCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBFbWl0dGVyVmlzaXRvckNvbnRleHQoX2V4cG9ydGVkVmFycywgX2luZGVudCkge1xuICAgICAgICAgIHRoaXMuX2V4cG9ydGVkVmFycyA9IF9leHBvcnRlZFZhcnM7XG4gICAgICAgICAgdGhpcy5faW5kZW50ID0gX2luZGVudDtcbiAgICAgICAgICB0aGlzLl9jbGFzc2VzID0gW107XG4gICAgICAgICAgdGhpcy5fbGluZXMgPSBbbmV3IF9FbWl0dGVkTGluZShfaW5kZW50KV07XG4gICAgICB9XG4gICAgICBFbWl0dGVyVmlzaXRvckNvbnRleHQuY3JlYXRlUm9vdCA9IGZ1bmN0aW9uIChleHBvcnRlZFZhcnMpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEVtaXR0ZXJWaXNpdG9yQ29udGV4dChleHBvcnRlZFZhcnMsIDApO1xuICAgICAgfTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFbWl0dGVyVmlzaXRvckNvbnRleHQucHJvdG90eXBlLCBcIl9jdXJyZW50TGluZVwiLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9saW5lc1t0aGlzLl9saW5lcy5sZW5ndGggLSAxXTsgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBFbWl0dGVyVmlzaXRvckNvbnRleHQucHJvdG90eXBlLmlzRXhwb3J0ZWRWYXIgPSBmdW5jdGlvbiAodmFyTmFtZSkgeyByZXR1cm4gdGhpcy5fZXhwb3J0ZWRWYXJzLmluZGV4T2YodmFyTmFtZSkgIT09IC0xOyB9O1xuICAgICAgRW1pdHRlclZpc2l0b3JDb250ZXh0LnByb3RvdHlwZS5wcmludGxuID0gZnVuY3Rpb24gKGxhc3RQYXJ0KSB7XG4gICAgICAgICAgaWYgKGxhc3RQYXJ0ID09PSB2b2lkIDApIHsgbGFzdFBhcnQgPSAnJzsgfVxuICAgICAgICAgIHRoaXMucHJpbnQobGFzdFBhcnQsIHRydWUpO1xuICAgICAgfTtcbiAgICAgIEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5wcm90b3R5cGUubGluZUlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jdXJyZW50TGluZS5wYXJ0cy5sZW5ndGggPT09IDA7IH07XG4gICAgICBFbWl0dGVyVmlzaXRvckNvbnRleHQucHJvdG90eXBlLnByaW50ID0gZnVuY3Rpb24gKHBhcnQsIG5ld0xpbmUpIHtcbiAgICAgICAgICBpZiAobmV3TGluZSA9PT0gdm9pZCAwKSB7IG5ld0xpbmUgPSBmYWxzZTsgfVxuICAgICAgICAgIGlmIChwYXJ0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5fY3VycmVudExpbmUucGFydHMucHVzaChwYXJ0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG5ld0xpbmUpIHtcbiAgICAgICAgICAgICAgdGhpcy5fbGluZXMucHVzaChuZXcgX0VtaXR0ZWRMaW5lKHRoaXMuX2luZGVudCkpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBFbWl0dGVyVmlzaXRvckNvbnRleHQucHJvdG90eXBlLnJlbW92ZUVtcHR5TGFzdExpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKHRoaXMubGluZUlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICB0aGlzLl9saW5lcy5wb3AoKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgRW1pdHRlclZpc2l0b3JDb250ZXh0LnByb3RvdHlwZS5pbmNJbmRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy5faW5kZW50Kys7XG4gICAgICAgICAgdGhpcy5fY3VycmVudExpbmUuaW5kZW50ID0gdGhpcy5faW5kZW50O1xuICAgICAgfTtcbiAgICAgIEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5wcm90b3R5cGUuZGVjSW5kZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMuX2luZGVudC0tO1xuICAgICAgICAgIHRoaXMuX2N1cnJlbnRMaW5lLmluZGVudCA9IHRoaXMuX2luZGVudDtcbiAgICAgIH07XG4gICAgICBFbWl0dGVyVmlzaXRvckNvbnRleHQucHJvdG90eXBlLnB1c2hDbGFzcyA9IGZ1bmN0aW9uIChjbGF6eikgeyB0aGlzLl9jbGFzc2VzLnB1c2goY2xhenopOyB9O1xuICAgICAgRW1pdHRlclZpc2l0b3JDb250ZXh0LnByb3RvdHlwZS5wb3BDbGFzcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NsYXNzZXMucG9wKCk7IH07XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRW1pdHRlclZpc2l0b3JDb250ZXh0LnByb3RvdHlwZSwgXCJjdXJyZW50Q2xhc3NcIiwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2xhc3Nlcy5sZW5ndGggPiAwID8gdGhpcy5fY2xhc3Nlc1t0aGlzLl9jbGFzc2VzLmxlbmd0aCAtIDFdIDogbnVsbDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5wcm90b3R5cGUudG9Tb3VyY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGxpbmVzID0gdGhpcy5fbGluZXM7XG4gICAgICAgICAgaWYgKGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdLnBhcnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICBsaW5lcyA9IGxpbmVzLnNsaWNlKDAsIGxpbmVzLmxlbmd0aCAtIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbGluZXNcbiAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAobGluZSkge1xuICAgICAgICAgICAgICBpZiAobGluZS5wYXJ0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2NyZWF0ZUluZGVudChsaW5lLmluZGVudCkgKyBsaW5lLnBhcnRzLmpvaW4oJycpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgICAgICAgLmpvaW4oJ1xcbicpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBFbWl0dGVyVmlzaXRvckNvbnRleHQ7XG4gIH0oKSk7XG4gIHZhciBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIEFic3RyYWN0RW1pdHRlclZpc2l0b3IoX2VzY2FwZURvbGxhckluU3RyaW5ncykge1xuICAgICAgICAgIHRoaXMuX2VzY2FwZURvbGxhckluU3RyaW5ncyA9IF9lc2NhcGVEb2xsYXJJblN0cmluZ3M7XG4gICAgICB9XG4gICAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb25TdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICAgIHN0bXQuZXhwci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICBjdHgucHJpbnRsbignOycpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UmV0dXJuU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgICBjdHgucHJpbnQoXCJyZXR1cm4gXCIpO1xuICAgICAgICAgIHN0bXQudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgICAgY3R4LnByaW50bG4oJzsnKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdElmU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgICBjdHgucHJpbnQoXCJpZiAoXCIpO1xuICAgICAgICAgIHN0bXQuY29uZGl0aW9uLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgIGN0eC5wcmludChcIikge1wiKTtcbiAgICAgICAgICB2YXIgaGFzRWxzZUNhc2UgPSBpc1ByZXNlbnQoc3RtdC5mYWxzZUNhc2UpICYmIHN0bXQuZmFsc2VDYXNlLmxlbmd0aCA+IDA7XG4gICAgICAgICAgaWYgKHN0bXQudHJ1ZUNhc2UubGVuZ3RoIDw9IDEgJiYgIWhhc0Vsc2VDYXNlKSB7XG4gICAgICAgICAgICAgIGN0eC5wcmludChcIiBcIik7XG4gICAgICAgICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQudHJ1ZUNhc2UsIGN0eCk7XG4gICAgICAgICAgICAgIGN0eC5yZW1vdmVFbXB0eUxhc3RMaW5lKCk7XG4gICAgICAgICAgICAgIGN0eC5wcmludChcIiBcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBjdHgucHJpbnRsbigpO1xuICAgICAgICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQudHJ1ZUNhc2UsIGN0eCk7XG4gICAgICAgICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgICAgICAgaWYgKGhhc0Vsc2VDYXNlKSB7XG4gICAgICAgICAgICAgICAgICBjdHgucHJpbnRsbihcIn0gZWxzZSB7XCIpO1xuICAgICAgICAgICAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICAgICAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5mYWxzZUNhc2UsIGN0eCk7XG4gICAgICAgICAgICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY3R4LnByaW50bG4oXCJ9XCIpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGhyb3dTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICAgIGN0eC5wcmludChcInRocm93IFwiKTtcbiAgICAgICAgICBzdG10LmVycm9yLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgIGN0eC5wcmludGxuKFwiO1wiKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbW1lbnRTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICAgIHZhciBsaW5lcyA9IHN0bXQuY29tbWVudC5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgbGluZXMuZm9yRWFjaChmdW5jdGlvbiAobGluZSkgeyBjdHgucHJpbnRsbihcIi8vIFwiICsgbGluZSk7IH0pO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0V3JpdGVWYXJFeHByID0gZnVuY3Rpb24gKGV4cHIsIGN0eCkge1xuICAgICAgICAgIHZhciBsaW5lV2FzRW1wdHkgPSBjdHgubGluZUlzRW1wdHkoKTtcbiAgICAgICAgICBpZiAoIWxpbmVXYXNFbXB0eSkge1xuICAgICAgICAgICAgICBjdHgucHJpbnQoJygnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3R4LnByaW50KGV4cHIubmFtZSArIFwiID0gXCIpO1xuICAgICAgICAgIGV4cHIudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgICAgaWYgKCFsaW5lV2FzRW1wdHkpIHtcbiAgICAgICAgICAgICAgY3R4LnByaW50KCcpJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0V3JpdGVLZXlFeHByID0gZnVuY3Rpb24gKGV4cHIsIGN0eCkge1xuICAgICAgICAgIHZhciBsaW5lV2FzRW1wdHkgPSBjdHgubGluZUlzRW1wdHkoKTtcbiAgICAgICAgICBpZiAoIWxpbmVXYXNFbXB0eSkge1xuICAgICAgICAgICAgICBjdHgucHJpbnQoJygnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwci5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICBjdHgucHJpbnQoXCJbXCIpO1xuICAgICAgICAgIGV4cHIuaW5kZXgudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgICAgY3R4LnByaW50KFwiXSA9IFwiKTtcbiAgICAgICAgICBleHByLnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgIGlmICghbGluZVdhc0VtcHR5KSB7XG4gICAgICAgICAgICAgIGN0eC5wcmludCgnKScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFdyaXRlUHJvcEV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY3R4KSB7XG4gICAgICAgICAgdmFyIGxpbmVXYXNFbXB0eSA9IGN0eC5saW5lSXNFbXB0eSgpO1xuICAgICAgICAgIGlmICghbGluZVdhc0VtcHR5KSB7XG4gICAgICAgICAgICAgIGN0eC5wcmludCgnKCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBleHByLnJlY2VpdmVyLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgIGN0eC5wcmludChcIi5cIiArIGV4cHIubmFtZSArIFwiID0gXCIpO1xuICAgICAgICAgIGV4cHIudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgICAgaWYgKCFsaW5lV2FzRW1wdHkpIHtcbiAgICAgICAgICAgICAgY3R4LnByaW50KCcpJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0SW52b2tlTWV0aG9kRXhwciA9IGZ1bmN0aW9uIChleHByLCBjdHgpIHtcbiAgICAgICAgICBleHByLnJlY2VpdmVyLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgIHZhciBuYW1lID0gZXhwci5uYW1lO1xuICAgICAgICAgIGlmIChpc1ByZXNlbnQoZXhwci5idWlsdGluKSkge1xuICAgICAgICAgICAgICBuYW1lID0gdGhpcy5nZXRCdWlsdGluTWV0aG9kTmFtZShleHByLmJ1aWx0aW4pO1xuICAgICAgICAgICAgICBpZiAoaXNCbGFuayhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgLy8gc29tZSBidWlsdGlucyBqdXN0IG1lYW4gdG8gc2tpcCB0aGUgY2FsbC5cbiAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGN0eC5wcmludChcIi5cIiArIG5hbWUgKyBcIihcIik7XG4gICAgICAgICAgdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGV4cHIuYXJncywgY3R4LCBcIixcIik7XG4gICAgICAgICAgY3R4LnByaW50KFwiKVwiKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEludm9rZUZ1bmN0aW9uRXhwciA9IGZ1bmN0aW9uIChleHByLCBjdHgpIHtcbiAgICAgICAgICBleHByLmZuLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgIGN0eC5wcmludChcIihcIik7XG4gICAgICAgICAgdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGV4cHIuYXJncywgY3R4LCAnLCcpO1xuICAgICAgICAgIGN0eC5wcmludChcIilcIik7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRSZWFkVmFyRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICAgIHZhciB2YXJOYW1lID0gYXN0Lm5hbWU7XG4gICAgICAgICAgaWYgKGlzUHJlc2VudChhc3QuYnVpbHRpbikpIHtcbiAgICAgICAgICAgICAgc3dpdGNoIChhc3QuYnVpbHRpbikge1xuICAgICAgICAgICAgICAgICAgY2FzZSBCdWlsdGluVmFyLlN1cGVyOlxuICAgICAgICAgICAgICAgICAgICAgIHZhck5hbWUgPSAnc3VwZXInO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBCdWlsdGluVmFyLlRoaXM6XG4gICAgICAgICAgICAgICAgICAgICAgdmFyTmFtZSA9ICd0aGlzJztcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgQnVpbHRpblZhci5DYXRjaEVycm9yOlxuICAgICAgICAgICAgICAgICAgICAgIHZhck5hbWUgPSBDQVRDSF9FUlJPUl9WQVIkMi5uYW1lO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBCdWlsdGluVmFyLkNhdGNoU3RhY2s6XG4gICAgICAgICAgICAgICAgICAgICAgdmFyTmFtZSA9IENBVENIX1NUQUNLX1ZBUiQyLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gYnVpbHRpbiB2YXJpYWJsZSBcIiArIGFzdC5idWlsdGluKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjdHgucHJpbnQodmFyTmFtZSk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRJbnN0YW50aWF0ZUV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgICBjdHgucHJpbnQoXCJuZXcgXCIpO1xuICAgICAgICAgIGFzdC5jbGFzc0V4cHIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgICAgY3R4LnByaW50KFwiKFwiKTtcbiAgICAgICAgICB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoYXN0LmFyZ3MsIGN0eCwgJywnKTtcbiAgICAgICAgICBjdHgucHJpbnQoXCIpXCIpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0TGl0ZXJhbEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgsIGFic2VudFZhbHVlKSB7XG4gICAgICAgICAgaWYgKGFic2VudFZhbHVlID09PSB2b2lkIDApIHsgYWJzZW50VmFsdWUgPSAnbnVsbCc7IH1cbiAgICAgICAgICB2YXIgdmFsdWUgPSBhc3QudmFsdWU7XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgY3R4LnByaW50KGVzY2FwZUlkZW50aWZpZXIodmFsdWUsIHRoaXMuX2VzY2FwZURvbGxhckluU3RyaW5ncykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChpc0JsYW5rKHZhbHVlKSkge1xuICAgICAgICAgICAgICBjdHgucHJpbnQoYWJzZW50VmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgY3R4LnByaW50KFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q29uZGl0aW9uYWxFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgICAgY3R4LnByaW50KFwiKFwiKTtcbiAgICAgICAgICBhc3QuY29uZGl0aW9uLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgIGN0eC5wcmludCgnPyAnKTtcbiAgICAgICAgICBhc3QudHJ1ZUNhc2UudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgICAgY3R4LnByaW50KCc6ICcpO1xuICAgICAgICAgIGFzdC5mYWxzZUNhc2UudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgICAgY3R4LnByaW50KFwiKVwiKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdE5vdEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgICBjdHgucHJpbnQoJyEnKTtcbiAgICAgICAgICBhc3QuY29uZGl0aW9uLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0QmluYXJ5T3BlcmF0b3JFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgICAgdmFyIG9wU3RyO1xuICAgICAgICAgIHN3aXRjaCAoYXN0Lm9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuRXF1YWxzOlxuICAgICAgICAgICAgICAgICAgb3BTdHIgPSAnPT0nO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuSWRlbnRpY2FsOlxuICAgICAgICAgICAgICAgICAgb3BTdHIgPSAnPT09JztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLk5vdEVxdWFsczpcbiAgICAgICAgICAgICAgICAgIG9wU3RyID0gJyE9JztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLk5vdElkZW50aWNhbDpcbiAgICAgICAgICAgICAgICAgIG9wU3RyID0gJyE9PSc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5BbmQ6XG4gICAgICAgICAgICAgICAgICBvcFN0ciA9ICcmJic7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5PcjpcbiAgICAgICAgICAgICAgICAgIG9wU3RyID0gJ3x8JztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLlBsdXM6XG4gICAgICAgICAgICAgICAgICBvcFN0ciA9ICcrJztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLk1pbnVzOlxuICAgICAgICAgICAgICAgICAgb3BTdHIgPSAnLSc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5EaXZpZGU6XG4gICAgICAgICAgICAgICAgICBvcFN0ciA9ICcvJztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLk11bHRpcGx5OlxuICAgICAgICAgICAgICAgICAgb3BTdHIgPSAnKic7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5Nb2R1bG86XG4gICAgICAgICAgICAgICAgICBvcFN0ciA9ICclJztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLkxvd2VyOlxuICAgICAgICAgICAgICAgICAgb3BTdHIgPSAnPCc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5Mb3dlckVxdWFsczpcbiAgICAgICAgICAgICAgICAgIG9wU3RyID0gJzw9JztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLkJpZ2dlcjpcbiAgICAgICAgICAgICAgICAgIG9wU3RyID0gJz4nO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuQmlnZ2VyRXF1YWxzOlxuICAgICAgICAgICAgICAgICAgb3BTdHIgPSAnPj0nO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9wZXJhdG9yIFwiICsgYXN0Lm9wZXJhdG9yKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3R4LnByaW50KFwiKFwiKTtcbiAgICAgICAgICBhc3QubGhzLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgIGN0eC5wcmludChcIiBcIiArIG9wU3RyICsgXCIgXCIpO1xuICAgICAgICAgIGFzdC5yaHMudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgICAgY3R4LnByaW50KFwiKVwiKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFJlYWRQcm9wRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICAgIGFzdC5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICBjdHgucHJpbnQoXCIuXCIpO1xuICAgICAgICAgIGN0eC5wcmludChhc3QubmFtZSk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRSZWFkS2V5RXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICAgIGFzdC5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICBjdHgucHJpbnQoXCJbXCIpO1xuICAgICAgICAgIGFzdC5pbmRleC52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICBjdHgucHJpbnQoXCJdXCIpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0TGl0ZXJhbEFycmF5RXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICAgIHZhciB1c2VOZXdMaW5lID0gYXN0LmVudHJpZXMubGVuZ3RoID4gMTtcbiAgICAgICAgICBjdHgucHJpbnQoXCJbXCIsIHVzZU5ld0xpbmUpO1xuICAgICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgICB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoYXN0LmVudHJpZXMsIGN0eCwgJywnLCB1c2VOZXdMaW5lKTtcbiAgICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgICAgY3R4LnByaW50KFwiXVwiLCB1c2VOZXdMaW5lKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdExpdGVyYWxNYXBFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgdXNlTmV3TGluZSA9IGFzdC5lbnRyaWVzLmxlbmd0aCA+IDE7XG4gICAgICAgICAgY3R4LnByaW50KFwie1wiLCB1c2VOZXdMaW5lKTtcbiAgICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgICAgdGhpcy52aXNpdEFsbE9iamVjdHMoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICAgIGN0eC5wcmludChlc2NhcGVJZGVudGlmaWVyKGVudHJ5WzBdLCBfdGhpcy5fZXNjYXBlRG9sbGFySW5TdHJpbmdzLCBmYWxzZSkgKyBcIjogXCIpO1xuICAgICAgICAgICAgICBlbnRyeVsxXS52aXNpdEV4cHJlc3Npb24oX3RoaXMsIGN0eCk7XG4gICAgICAgICAgfSwgYXN0LmVudHJpZXMsIGN0eCwgJywnLCB1c2VOZXdMaW5lKTtcbiAgICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgICAgY3R4LnByaW50KFwifVwiLCB1c2VOZXdMaW5lKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEFsbEV4cHJlc3Npb25zID0gZnVuY3Rpb24gKGV4cHJlc3Npb25zLCBjdHgsIHNlcGFyYXRvciwgbmV3TGluZSkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgaWYgKG5ld0xpbmUgPT09IHZvaWQgMCkgeyBuZXdMaW5lID0gZmFsc2U7IH1cbiAgICAgICAgICB0aGlzLnZpc2l0QWxsT2JqZWN0cyhmdW5jdGlvbiAoZXhwcikgeyByZXR1cm4gZXhwci52aXNpdEV4cHJlc3Npb24oX3RoaXMsIGN0eCk7IH0sIGV4cHJlc3Npb25zLCBjdHgsIHNlcGFyYXRvciwgbmV3TGluZSk7XG4gICAgICB9O1xuICAgICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRBbGxPYmplY3RzID0gZnVuY3Rpb24gKGhhbmRsZXIsIGV4cHJlc3Npb25zLCBjdHgsIHNlcGFyYXRvciwgbmV3TGluZSkge1xuICAgICAgICAgIGlmIChuZXdMaW5lID09PSB2b2lkIDApIHsgbmV3TGluZSA9IGZhbHNlOyB9XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHByZXNzaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICAgIGN0eC5wcmludChzZXBhcmF0b3IsIG5ld0xpbmUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGhhbmRsZXIoZXhwcmVzc2lvbnNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobmV3TGluZSkge1xuICAgICAgICAgICAgICBjdHgucHJpbnRsbigpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEFsbFN0YXRlbWVudHMgPSBmdW5jdGlvbiAoc3RhdGVtZW50cywgY3R4KSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICBzdGF0ZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKHN0bXQpIHsgcmV0dXJuIHN0bXQudmlzaXRTdGF0ZW1lbnQoX3RoaXMsIGN0eCk7IH0pO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yO1xuICB9KCkpO1xuICBmdW5jdGlvbiBlc2NhcGVJZGVudGlmaWVyKGlucHV0LCBlc2NhcGVEb2xsYXIsIGFsd2F5c1F1b3RlKSB7XG4gICAgICBpZiAoYWx3YXlzUXVvdGUgPT09IHZvaWQgMCkgeyBhbHdheXNRdW90ZSA9IHRydWU7IH1cbiAgICAgIGlmIChpc0JsYW5rKGlucHV0KSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIGJvZHkgPSBpbnB1dC5yZXBsYWNlKF9TSU5HTEVfUVVPVEVfRVNDQVBFX1NUUklOR19SRSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBtYXRjaCA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgIG1hdGNoW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWF0Y2hbMF0gPT0gJyQnKSB7XG4gICAgICAgICAgICAgIHJldHVybiBlc2NhcGVEb2xsYXIgPyAnXFxcXCQnIDogJyQnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChtYXRjaFswXSA9PSAnXFxuJykge1xuICAgICAgICAgICAgICByZXR1cm4gJ1xcXFxuJztcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAobWF0Y2hbMF0gPT0gJ1xccicpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICdcXFxccic7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gXCJcXFxcXCIgKyBtYXRjaFswXTtcbiAgICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHZhciByZXF1aXJlc1F1b3RlcyA9IGFsd2F5c1F1b3RlIHx8ICFfTEVHQUxfSURFTlRJRklFUl9SRS50ZXN0KGJvZHkpO1xuICAgICAgcmV0dXJuIHJlcXVpcmVzUXVvdGVzID8gXCInXCIgKyBib2R5ICsgXCInXCIgOiBib2R5O1xuICB9XG4gIGZ1bmN0aW9uIF9jcmVhdGVJbmRlbnQoY291bnQpIHtcbiAgICAgIHZhciByZXMgPSAnJztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgIHJlcyArPSAnICAnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAbGljZW5zZVxuICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICpcbiAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgKi9cbiAgdmFyIF9fZXh0ZW5kcyQxNyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgfTtcbiAgdmFyIF9kZWJ1Z01vZHVsZVVybCA9ICdhc3NldDovL2RlYnVnL2xpYic7XG4gIGZ1bmN0aW9uIGRlYnVnT3V0cHV0QXN0QXNUeXBlU2NyaXB0KGFzdCkge1xuICAgICAgdmFyIGNvbnZlcnRlciA9IG5ldyBfVHNFbWl0dGVyVmlzaXRvcihfZGVidWdNb2R1bGVVcmwpO1xuICAgICAgdmFyIGN0eCA9IEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5jcmVhdGVSb290KFtdKTtcbiAgICAgIHZhciBhc3RzID0gQXJyYXkuaXNBcnJheShhc3QpID8gYXN0IDogW2FzdF07XG4gICAgICBhc3RzLmZvckVhY2goZnVuY3Rpb24gKGFzdCkge1xuICAgICAgICAgIGlmIChhc3QgaW5zdGFuY2VvZiBTdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgICAgYXN0LnZpc2l0U3RhdGVtZW50KGNvbnZlcnRlciwgY3R4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoYXN0IGluc3RhbmNlb2YgRXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICBhc3QudmlzaXRFeHByZXNzaW9uKGNvbnZlcnRlciwgY3R4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoYXN0IGluc3RhbmNlb2YgVHlwZSQxKSB7XG4gICAgICAgICAgICAgIGFzdC52aXNpdFR5cGUoY29udmVydGVyLCBjdHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRG9uJ3Qga25vdyBob3cgdG8gcHJpbnQgZGVidWcgaW5mbyBmb3IgXCIgKyBhc3QpO1xuICAgICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGN0eC50b1NvdXJjZSgpO1xuICB9XG4gIHZhciBUeXBlU2NyaXB0RW1pdHRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBUeXBlU2NyaXB0RW1pdHRlcihfaW1wb3J0R2VuZXJhdG9yKSB7XG4gICAgICAgICAgdGhpcy5faW1wb3J0R2VuZXJhdG9yID0gX2ltcG9ydEdlbmVyYXRvcjtcbiAgICAgIH1cbiAgICAgIFR5cGVTY3JpcHRFbWl0dGVyLnByb3RvdHlwZS5lbWl0U3RhdGVtZW50cyA9IGZ1bmN0aW9uIChtb2R1bGVVcmwsIHN0bXRzLCBleHBvcnRlZFZhcnMpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBjb252ZXJ0ZXIgPSBuZXcgX1RzRW1pdHRlclZpc2l0b3IobW9kdWxlVXJsKTtcbiAgICAgICAgICB2YXIgY3R4ID0gRW1pdHRlclZpc2l0b3JDb250ZXh0LmNyZWF0ZVJvb3QoZXhwb3J0ZWRWYXJzKTtcbiAgICAgICAgICBjb252ZXJ0ZXIudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXRzLCBjdHgpO1xuICAgICAgICAgIHZhciBzcmNQYXJ0cyA9IFtdO1xuICAgICAgICAgIGNvbnZlcnRlci5pbXBvcnRzV2l0aFByZWZpeGVzLmZvckVhY2goZnVuY3Rpb24gKHByZWZpeCwgaW1wb3J0ZWRNb2R1bGVVcmwpIHtcbiAgICAgICAgICAgICAgLy8gTm90ZTogY2FuJ3Qgd3JpdGUgdGhlIHJlYWwgd29yZCBmb3IgaW1wb3J0IGFzIGl0IHNjcmV3cyB1cCBzeXN0ZW0uanMgYXV0byBkZXRlY3Rpb24uLi5cbiAgICAgICAgICAgICAgc3JjUGFydHMucHVzaChcImltcFwiICtcbiAgICAgICAgICAgICAgICAgIChcIm9ydCAqIGFzIFwiICsgcHJlZml4ICsgXCIgZnJvbSAnXCIgKyBfdGhpcy5faW1wb3J0R2VuZXJhdG9yLmdldEltcG9ydFBhdGgobW9kdWxlVXJsLCBpbXBvcnRlZE1vZHVsZVVybCkgKyBcIic7XCIpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzcmNQYXJ0cy5wdXNoKGN0eC50b1NvdXJjZSgpKTtcbiAgICAgICAgICByZXR1cm4gc3JjUGFydHMuam9pbignXFxuJyk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFR5cGVTY3JpcHRFbWl0dGVyO1xuICB9KCkpO1xuICB2YXIgX1RzRW1pdHRlclZpc2l0b3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDE3KF9Uc0VtaXR0ZXJWaXNpdG9yLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gX1RzRW1pdHRlclZpc2l0b3IoX21vZHVsZVVybCkge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGZhbHNlKTtcbiAgICAgICAgICB0aGlzLl9tb2R1bGVVcmwgPSBfbW9kdWxlVXJsO1xuICAgICAgICAgIHRoaXMuaW1wb3J0c1dpdGhQcmVmaXhlcyA9IG5ldyBNYXAoKTtcbiAgICAgIH1cbiAgICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFR5cGUgPSBmdW5jdGlvbiAodCwgY3R4LCBkZWZhdWx0VHlwZSkge1xuICAgICAgICAgIGlmIChkZWZhdWx0VHlwZSA9PT0gdm9pZCAwKSB7IGRlZmF1bHRUeXBlID0gJ2FueSc7IH1cbiAgICAgICAgICBpZiAoaXNQcmVzZW50KHQpKSB7XG4gICAgICAgICAgICAgIHQudmlzaXRUeXBlKHRoaXMsIGN0eCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBjdHgucHJpbnQoZGVmYXVsdFR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRMaXRlcmFsRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUudmlzaXRMaXRlcmFsRXhwci5jYWxsKHRoaXMsIGFzdCwgY3R4LCAnKG51bGwgYXMgYW55KScpO1xuICAgICAgfTtcbiAgICAgIC8vIFRlbXBvcmFyeSB3b3JrYXJvdW5kIHRvIHN1cHBvcnQgc3RyaWN0TnVsbENoZWNrIGVuYWJsZWQgY29uc3VtZXJzIG9mIG5nYyBlbWl0LlxuICAgICAgLy8gSW4gU05DIG1vZGUsIFtdIGhhdmUgdGhlIHR5cGUgbmV2ZXJbXSwgc28gd2UgY2FzdCBoZXJlIHRvIGFueVtdLlxuICAgICAgLy8gVE9ETzogbmFycm93IHRoZSBjYXN0IHRvIGEgbW9yZSBleHBsaWNpdCB0eXBlLCBvciB1c2UgYSBwYXR0ZXJuIHRoYXQgZG9lcyBub3RcbiAgICAgIC8vIHN0YXJ0IHdpdGggW10uY29uY2F0LiBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9wdWxsLzExODQ2XG4gICAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRMaXRlcmFsQXJyYXlFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgICAgaWYgKGFzdC5lbnRyaWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICBjdHgucHJpbnQoJygnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IF9zdXBlci5wcm90b3R5cGUudmlzaXRMaXRlcmFsQXJyYXlFeHByLmNhbGwodGhpcywgYXN0LCBjdHgpO1xuICAgICAgICAgIGlmIChhc3QuZW50cmllcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgY3R4LnByaW50KCcgYXMgYW55W10pJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXh0ZXJuYWxFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgICAgdGhpcy5fdmlzaXRJZGVudGlmaWVyKGFzdC52YWx1ZSwgYXN0LnR5cGVQYXJhbXMsIGN0eCk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RGVjbGFyZVZhclN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgICAgaWYgKGN0eC5pc0V4cG9ydGVkVmFyKHN0bXQubmFtZSkpIHtcbiAgICAgICAgICAgICAgY3R4LnByaW50KFwiZXhwb3J0IFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0bXQuaGFzTW9kaWZpZXIoU3RtdE1vZGlmaWVyLkZpbmFsKSkge1xuICAgICAgICAgICAgICBjdHgucHJpbnQoXCJjb25zdFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGN0eC5wcmludChcInZhclwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3R4LnByaW50KFwiIFwiICsgc3RtdC5uYW1lICsgXCI6XCIpO1xuICAgICAgICAgIHRoaXMudmlzaXRUeXBlKHN0bXQudHlwZSwgY3R4KTtcbiAgICAgICAgICBjdHgucHJpbnQoXCIgPSBcIik7XG4gICAgICAgICAgc3RtdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICBjdHgucHJpbnRsbihcIjtcIik7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q2FzdEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgICBjdHgucHJpbnQoXCIoPFwiKTtcbiAgICAgICAgICBhc3QudHlwZS52aXNpdFR5cGUodGhpcywgY3R4KTtcbiAgICAgICAgICBjdHgucHJpbnQoXCI+XCIpO1xuICAgICAgICAgIGFzdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICBjdHgucHJpbnQoXCIpXCIpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdERlY2xhcmVDbGFzc1N0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICBjdHgucHVzaENsYXNzKHN0bXQpO1xuICAgICAgICAgIGlmIChjdHguaXNFeHBvcnRlZFZhcihzdG10Lm5hbWUpKSB7XG4gICAgICAgICAgICAgIGN0eC5wcmludChcImV4cG9ydCBcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN0eC5wcmludChcImNsYXNzIFwiICsgc3RtdC5uYW1lKTtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KHN0bXQucGFyZW50KSkge1xuICAgICAgICAgICAgICBjdHgucHJpbnQoXCIgZXh0ZW5kcyBcIik7XG4gICAgICAgICAgICAgIHN0bXQucGFyZW50LnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdHgucHJpbnRsbihcIiB7XCIpO1xuICAgICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgICBzdG10LmZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCkgeyByZXR1cm4gX3RoaXMuX3Zpc2l0Q2xhc3NGaWVsZChmaWVsZCwgY3R4KTsgfSk7XG4gICAgICAgICAgaWYgKGlzUHJlc2VudChzdG10LmNvbnN0cnVjdG9yTWV0aG9kKSkge1xuICAgICAgICAgICAgICB0aGlzLl92aXNpdENsYXNzQ29uc3RydWN0b3Ioc3RtdCwgY3R4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RtdC5nZXR0ZXJzLmZvckVhY2goZnVuY3Rpb24gKGdldHRlcikgeyByZXR1cm4gX3RoaXMuX3Zpc2l0Q2xhc3NHZXR0ZXIoZ2V0dGVyLCBjdHgpOyB9KTtcbiAgICAgICAgICBzdG10Lm1ldGhvZHMuZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7IHJldHVybiBfdGhpcy5fdmlzaXRDbGFzc01ldGhvZChtZXRob2QsIGN0eCk7IH0pO1xuICAgICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgICBjdHgucHJpbnRsbihcIn1cIik7XG4gICAgICAgICAgY3R4LnBvcENsYXNzKCk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLl92aXNpdENsYXNzRmllbGQgPSBmdW5jdGlvbiAoZmllbGQsIGN0eCkge1xuICAgICAgICAgIGlmIChmaWVsZC5oYXNNb2RpZmllcihTdG10TW9kaWZpZXIuUHJpdmF0ZSkpIHtcbiAgICAgICAgICAgICAgLy8gY29tbWVudCBvdXQgYXMgYSB3b3JrYXJvdW5kIGZvciAjMTA5NjdcbiAgICAgICAgICAgICAgY3R4LnByaW50KFwiLypwcml2YXRlKi8gXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdHgucHJpbnQoZmllbGQubmFtZSk7XG4gICAgICAgICAgY3R4LnByaW50KCc6Jyk7XG4gICAgICAgICAgdGhpcy52aXNpdFR5cGUoZmllbGQudHlwZSwgY3R4KTtcbiAgICAgICAgICBjdHgucHJpbnRsbihcIjtcIik7XG4gICAgICB9O1xuICAgICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLl92aXNpdENsYXNzR2V0dGVyID0gZnVuY3Rpb24gKGdldHRlciwgY3R4KSB7XG4gICAgICAgICAgaWYgKGdldHRlci5oYXNNb2RpZmllcihTdG10TW9kaWZpZXIuUHJpdmF0ZSkpIHtcbiAgICAgICAgICAgICAgY3R4LnByaW50KFwicHJpdmF0ZSBcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN0eC5wcmludChcImdldCBcIiArIGdldHRlci5uYW1lICsgXCIoKVwiKTtcbiAgICAgICAgICBjdHgucHJpbnQoJzonKTtcbiAgICAgICAgICB0aGlzLnZpc2l0VHlwZShnZXR0ZXIudHlwZSwgY3R4KTtcbiAgICAgICAgICBjdHgucHJpbnRsbihcIiB7XCIpO1xuICAgICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhnZXR0ZXIuYm9keSwgY3R4KTtcbiAgICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgICAgY3R4LnByaW50bG4oXCJ9XCIpO1xuICAgICAgfTtcbiAgICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS5fdmlzaXRDbGFzc0NvbnN0cnVjdG9yID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICAgIGN0eC5wcmludChcImNvbnN0cnVjdG9yKFwiKTtcbiAgICAgICAgICB0aGlzLl92aXNpdFBhcmFtcyhzdG10LmNvbnN0cnVjdG9yTWV0aG9kLnBhcmFtcywgY3R4KTtcbiAgICAgICAgICBjdHgucHJpbnRsbihcIikge1wiKTtcbiAgICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5jb25zdHJ1Y3Rvck1ldGhvZC5ib2R5LCBjdHgpO1xuICAgICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgICBjdHgucHJpbnRsbihcIn1cIik7XG4gICAgICB9O1xuICAgICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLl92aXNpdENsYXNzTWV0aG9kID0gZnVuY3Rpb24gKG1ldGhvZCwgY3R4KSB7XG4gICAgICAgICAgaWYgKG1ldGhvZC5oYXNNb2RpZmllcihTdG10TW9kaWZpZXIuUHJpdmF0ZSkpIHtcbiAgICAgICAgICAgICAgY3R4LnByaW50KFwicHJpdmF0ZSBcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN0eC5wcmludChtZXRob2QubmFtZSArIFwiKFwiKTtcbiAgICAgICAgICB0aGlzLl92aXNpdFBhcmFtcyhtZXRob2QucGFyYW1zLCBjdHgpO1xuICAgICAgICAgIGN0eC5wcmludChcIik6XCIpO1xuICAgICAgICAgIHRoaXMudmlzaXRUeXBlKG1ldGhvZC50eXBlLCBjdHgsICd2b2lkJyk7XG4gICAgICAgICAgY3R4LnByaW50bG4oXCIge1wiKTtcbiAgICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMobWV0aG9kLmJvZHksIGN0eCk7XG4gICAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICAgIGN0eC5wcmludGxuKFwifVwiKTtcbiAgICAgIH07XG4gICAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRGdW5jdGlvbkV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgICBjdHgucHJpbnQoXCIoXCIpO1xuICAgICAgICAgIHRoaXMuX3Zpc2l0UGFyYW1zKGFzdC5wYXJhbXMsIGN0eCk7XG4gICAgICAgICAgY3R4LnByaW50KFwiKTpcIik7XG4gICAgICAgICAgdGhpcy52aXNpdFR5cGUoYXN0LnR5cGUsIGN0eCwgJ3ZvaWQnKTtcbiAgICAgICAgICBjdHgucHJpbnRsbihcIiA9PiB7XCIpO1xuICAgICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhhc3Quc3RhdGVtZW50cywgY3R4KTtcbiAgICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgICAgY3R4LnByaW50KFwifVwiKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXREZWNsYXJlRnVuY3Rpb25TdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICAgIGlmIChjdHguaXNFeHBvcnRlZFZhcihzdG10Lm5hbWUpKSB7XG4gICAgICAgICAgICAgIGN0eC5wcmludChcImV4cG9ydCBcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN0eC5wcmludChcImZ1bmN0aW9uIFwiICsgc3RtdC5uYW1lICsgXCIoXCIpO1xuICAgICAgICAgIHRoaXMuX3Zpc2l0UGFyYW1zKHN0bXQucGFyYW1zLCBjdHgpO1xuICAgICAgICAgIGN0eC5wcmludChcIik6XCIpO1xuICAgICAgICAgIHRoaXMudmlzaXRUeXBlKHN0bXQudHlwZSwgY3R4LCAndm9pZCcpO1xuICAgICAgICAgIGN0eC5wcmludGxuKFwiIHtcIik7XG4gICAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuc3RhdGVtZW50cywgY3R4KTtcbiAgICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgICAgY3R4LnByaW50bG4oXCJ9XCIpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRyeUNhdGNoU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgICBjdHgucHJpbnRsbihcInRyeSB7XCIpO1xuICAgICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LmJvZHlTdG10cywgY3R4KTtcbiAgICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgICAgY3R4LnByaW50bG4oXCJ9IGNhdGNoIChcIiArIENBVENIX0VSUk9SX1ZBUiQyLm5hbWUgKyBcIikge1wiKTtcbiAgICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgICAgdmFyIGNhdGNoU3RtdHMgPSBbQ0FUQ0hfU1RBQ0tfVkFSJDIuc2V0KENBVENIX0VSUk9SX1ZBUiQyLnByb3AoJ3N0YWNrJykpLnRvRGVjbFN0bXQobnVsbCwgW1xuICAgICAgICAgICAgICAgICAgU3RtdE1vZGlmaWVyLkZpbmFsXG4gICAgICAgICAgICAgIF0pXS5jb25jYXQoc3RtdC5jYXRjaFN0bXRzKTtcbiAgICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhjYXRjaFN0bXRzLCBjdHgpO1xuICAgICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgICBjdHgucHJpbnRsbihcIn1cIik7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0QnVpbHRpbnRUeXBlID0gZnVuY3Rpb24gKHR5cGUsIGN0eCkge1xuICAgICAgICAgIHZhciB0eXBlU3RyO1xuICAgICAgICAgIHN3aXRjaCAodHlwZS5uYW1lKSB7XG4gICAgICAgICAgICAgIGNhc2UgQnVpbHRpblR5cGVOYW1lLkJvb2w6XG4gICAgICAgICAgICAgICAgICB0eXBlU3RyID0gJ2Jvb2xlYW4nO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgQnVpbHRpblR5cGVOYW1lLkR5bmFtaWM6XG4gICAgICAgICAgICAgICAgICB0eXBlU3RyID0gJ2FueSc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBCdWlsdGluVHlwZU5hbWUuRnVuY3Rpb246XG4gICAgICAgICAgICAgICAgICB0eXBlU3RyID0gJ0Z1bmN0aW9uJztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIEJ1aWx0aW5UeXBlTmFtZS5OdW1iZXI6XG4gICAgICAgICAgICAgICAgICB0eXBlU3RyID0gJ251bWJlcic7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBCdWlsdGluVHlwZU5hbWUuSW50OlxuICAgICAgICAgICAgICAgICAgdHlwZVN0ciA9ICdudW1iZXInO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgQnVpbHRpblR5cGVOYW1lLlN0cmluZzpcbiAgICAgICAgICAgICAgICAgIHR5cGVTdHIgPSAnc3RyaW5nJztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgYnVpbHRpbiB0eXBlIFwiICsgdHlwZS5uYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3R4LnByaW50KHR5cGVTdHIpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4dGVybmFsVHlwZSA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICAgIHRoaXMuX3Zpc2l0SWRlbnRpZmllcihhc3QudmFsdWUsIGFzdC50eXBlUGFyYW1zLCBjdHgpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEFycmF5VHlwZSA9IGZ1bmN0aW9uICh0eXBlLCBjdHgpIHtcbiAgICAgICAgICB0aGlzLnZpc2l0VHlwZSh0eXBlLm9mLCBjdHgpO1xuICAgICAgICAgIGN0eC5wcmludChcIltdXCIpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdE1hcFR5cGUgPSBmdW5jdGlvbiAodHlwZSwgY3R4KSB7XG4gICAgICAgICAgY3R4LnByaW50KFwie1trZXk6IHN0cmluZ106XCIpO1xuICAgICAgICAgIHRoaXMudmlzaXRUeXBlKHR5cGUudmFsdWVUeXBlLCBjdHgpO1xuICAgICAgICAgIGN0eC5wcmludChcIn1cIik7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLmdldEJ1aWx0aW5NZXRob2ROYW1lID0gZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICAgIHZhciBuYW1lO1xuICAgICAgICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICAgICAgICAgIGNhc2UgQnVpbHRpbk1ldGhvZC5Db25jYXRBcnJheTpcbiAgICAgICAgICAgICAgICAgIG5hbWUgPSAnY29uY2F0JztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIEJ1aWx0aW5NZXRob2QuU3Vic2NyaWJlT2JzZXJ2YWJsZTpcbiAgICAgICAgICAgICAgICAgIG5hbWUgPSAnc3Vic2NyaWJlJztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIEJ1aWx0aW5NZXRob2QuQmluZDpcbiAgICAgICAgICAgICAgICAgIG5hbWUgPSAnYmluZCc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gYnVpbHRpbiBtZXRob2Q6IFwiICsgbWV0aG9kKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICB9O1xuICAgICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLl92aXNpdFBhcmFtcyA9IGZ1bmN0aW9uIChwYXJhbXMsIGN0eCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdGhpcy52aXNpdEFsbE9iamVjdHMoZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICAgICAgICAgIGN0eC5wcmludChwYXJhbS5uYW1lKTtcbiAgICAgICAgICAgICAgY3R4LnByaW50KCc6Jyk7XG4gICAgICAgICAgICAgIF90aGlzLnZpc2l0VHlwZShwYXJhbS50eXBlLCBjdHgpO1xuICAgICAgICAgIH0sIHBhcmFtcywgY3R4LCAnLCcpO1xuICAgICAgfTtcbiAgICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS5fdmlzaXRJZGVudGlmaWVyID0gZnVuY3Rpb24gKHZhbHVlLCB0eXBlUGFyYW1zLCBjdHgpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIGlmIChpc0JsYW5rKHZhbHVlLm5hbWUpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludGVybmFsIGVycm9yOiB1bmtub3duIGlkZW50aWZpZXIgXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1ByZXNlbnQodmFsdWUubW9kdWxlVXJsKSAmJiB2YWx1ZS5tb2R1bGVVcmwgIT0gdGhpcy5fbW9kdWxlVXJsKSB7XG4gICAgICAgICAgICAgIHZhciBwcmVmaXggPSB0aGlzLmltcG9ydHNXaXRoUHJlZml4ZXMuZ2V0KHZhbHVlLm1vZHVsZVVybCk7XG4gICAgICAgICAgICAgIGlmIChpc0JsYW5rKHByZWZpeCkpIHtcbiAgICAgICAgICAgICAgICAgIHByZWZpeCA9IFwiaW1wb3J0XCIgKyB0aGlzLmltcG9ydHNXaXRoUHJlZml4ZXMuc2l6ZTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuaW1wb3J0c1dpdGhQcmVmaXhlcy5zZXQodmFsdWUubW9kdWxlVXJsLCBwcmVmaXgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGN0eC5wcmludChwcmVmaXggKyBcIi5cIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWx1ZS5yZWZlcmVuY2UgJiYgdmFsdWUucmVmZXJlbmNlLm1lbWJlcnMpIHtcbiAgICAgICAgICAgICAgY3R4LnByaW50KHZhbHVlLnJlZmVyZW5jZS5uYW1lKTtcbiAgICAgICAgICAgICAgY3R4LnByaW50KCcuJyk7XG4gICAgICAgICAgICAgIGN0eC5wcmludCh2YWx1ZS5yZWZlcmVuY2UubWVtYmVycy5qb2luKCcuJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgY3R4LnByaW50KHZhbHVlLm5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNQcmVzZW50KHR5cGVQYXJhbXMpICYmIHR5cGVQYXJhbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBjdHgucHJpbnQoXCI8XCIpO1xuICAgICAgICAgICAgICB0aGlzLnZpc2l0QWxsT2JqZWN0cyhmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gdHlwZS52aXNpdFR5cGUoX3RoaXMsIGN0eCk7IH0sIHR5cGVQYXJhbXMsIGN0eCwgJywnKTtcbiAgICAgICAgICAgICAgY3R4LnByaW50KFwiPlwiKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIF9Uc0VtaXR0ZXJWaXNpdG9yO1xuICB9KEFic3RyYWN0RW1pdHRlclZpc2l0b3IpKTtcblxuICBmdW5jdGlvbiBpbnRlcnByZXRTdGF0ZW1lbnRzKHN0YXRlbWVudHMsIHJlc3VsdFZhcikge1xuICAgICAgdmFyIHN0bXRzV2l0aFJldHVybiA9IHN0YXRlbWVudHMuY29uY2F0KFtuZXcgUmV0dXJuU3RhdGVtZW50KHZhcmlhYmxlKHJlc3VsdFZhcikpXSk7XG4gICAgICB2YXIgY3R4ID0gbmV3IF9FeGVjdXRpb25Db250ZXh0KG51bGwsIG51bGwsIG51bGwsIG5ldyBNYXAoKSk7XG4gICAgICB2YXIgdmlzaXRvciA9IG5ldyBTdGF0ZW1lbnRJbnRlcnByZXRlcigpO1xuICAgICAgdmFyIHJlc3VsdCA9IHZpc2l0b3IudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXRzV2l0aFJldHVybiwgY3R4KTtcbiAgICAgIHJldHVybiBpc1ByZXNlbnQocmVzdWx0KSA/IHJlc3VsdC52YWx1ZSA6IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gX2V4ZWN1dGVGdW5jdGlvblN0YXRlbWVudHModmFyTmFtZXMsIHZhclZhbHVlcywgc3RhdGVtZW50cywgY3R4LCB2aXNpdG9yKSB7XG4gICAgICB2YXIgY2hpbGRDdHggPSBjdHguY3JlYXRlQ2hpbGRXaWh0TG9jYWxWYXJzKCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhck5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY2hpbGRDdHgudmFycy5zZXQodmFyTmFtZXNbaV0sIHZhclZhbHVlc1tpXSk7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gdmlzaXRvci52aXNpdEFsbFN0YXRlbWVudHMoc3RhdGVtZW50cywgY2hpbGRDdHgpO1xuICAgICAgcmV0dXJuIGlzUHJlc2VudChyZXN1bHQpID8gcmVzdWx0LnZhbHVlIDogbnVsbDtcbiAgfVxuICB2YXIgX0V4ZWN1dGlvbkNvbnRleHQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gX0V4ZWN1dGlvbkNvbnRleHQocGFyZW50LCBpbnN0YW5jZSwgY2xhc3NOYW1lLCB2YXJzKSB7XG4gICAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgICAgdGhpcy5pbnN0YW5jZSA9IGluc3RhbmNlO1xuICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICAgICAgICAgIHRoaXMudmFycyA9IHZhcnM7XG4gICAgICB9XG4gICAgICBfRXhlY3V0aW9uQ29udGV4dC5wcm90b3R5cGUuY3JlYXRlQ2hpbGRXaWh0TG9jYWxWYXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBuZXcgX0V4ZWN1dGlvbkNvbnRleHQodGhpcywgdGhpcy5pbnN0YW5jZSwgdGhpcy5jbGFzc05hbWUsIG5ldyBNYXAoKSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIF9FeGVjdXRpb25Db250ZXh0O1xuICB9KCkpO1xuICB2YXIgUmV0dXJuVmFsdWUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gUmV0dXJuVmFsdWUodmFsdWUpIHtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gUmV0dXJuVmFsdWU7XG4gIH0oKSk7XG4gIGZ1bmN0aW9uIGNyZWF0ZUR5bmFtaWNDbGFzcyhfY2xhc3NTdG10LCBfY3R4LCBfdmlzaXRvcikge1xuICAgICAgdmFyIHByb3BlcnR5RGVzY3JpcHRvcnMgPSB7fTtcbiAgICAgIF9jbGFzc1N0bXQuZ2V0dGVycy5mb3JFYWNoKGZ1bmN0aW9uIChnZXR0ZXIpIHtcbiAgICAgICAgICAvLyBOb3RlOiB1c2UgYGZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGFycm93IGZ1bmN0aW9uIHRvIGNhcHR1cmUgYHRoaXNgXG4gICAgICAgICAgcHJvcGVydHlEZXNjcmlwdG9yc1tnZXR0ZXIubmFtZV0gPSB7XG4gICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlQ3R4ID0gbmV3IF9FeGVjdXRpb25Db250ZXh0KF9jdHgsIHRoaXMsIF9jbGFzc1N0bXQubmFtZSwgX2N0eC52YXJzKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfZXhlY3V0ZUZ1bmN0aW9uU3RhdGVtZW50cyhbXSwgW10sIGdldHRlci5ib2R5LCBpbnN0YW5jZUN0eCwgX3Zpc2l0b3IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgX2NsYXNzU3RtdC5tZXRob2RzLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICAgIHZhciBwYXJhbU5hbWVzID0gbWV0aG9kLnBhcmFtcy5tYXAoZnVuY3Rpb24gKHBhcmFtKSB7IHJldHVybiBwYXJhbS5uYW1lOyB9KTtcbiAgICAgICAgICAvLyBOb3RlOiB1c2UgYGZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGFycm93IGZ1bmN0aW9uIHRvIGNhcHR1cmUgYHRoaXNgXG4gICAgICAgICAgcHJvcGVydHlEZXNjcmlwdG9yc1ttZXRob2QubmFtZV0gPSB7XG4gICAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICAgIGFyZ3NbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2VDdHggPSBuZXcgX0V4ZWN1dGlvbkNvbnRleHQoX2N0eCwgdGhpcywgX2NsYXNzU3RtdC5uYW1lLCBfY3R4LnZhcnMpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9leGVjdXRlRnVuY3Rpb25TdGF0ZW1lbnRzKHBhcmFtTmFtZXMsIGFyZ3MsIG1ldGhvZC5ib2R5LCBpbnN0YW5jZUN0eCwgX3Zpc2l0b3IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgdmFyIGN0b3JQYXJhbU5hbWVzID0gX2NsYXNzU3RtdC5jb25zdHJ1Y3Rvck1ldGhvZC5wYXJhbXMubWFwKGZ1bmN0aW9uIChwYXJhbSkgeyByZXR1cm4gcGFyYW0ubmFtZTsgfSk7XG4gICAgICAvLyBOb3RlOiB1c2UgYGZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGFycm93IGZ1bmN0aW9uIHRvIGNhcHR1cmUgYHRoaXNgXG4gICAgICB2YXIgY3RvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgYXJnc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGluc3RhbmNlQ3R4ID0gbmV3IF9FeGVjdXRpb25Db250ZXh0KF9jdHgsIHRoaXMsIF9jbGFzc1N0bXQubmFtZSwgX2N0eC52YXJzKTtcbiAgICAgICAgICBfY2xhc3NTdG10LmZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCkgeyBfdGhpc1tmaWVsZC5uYW1lXSA9IHVuZGVmaW5lZDsgfSk7XG4gICAgICAgICAgX2V4ZWN1dGVGdW5jdGlvblN0YXRlbWVudHMoY3RvclBhcmFtTmFtZXMsIGFyZ3MsIF9jbGFzc1N0bXQuY29uc3RydWN0b3JNZXRob2QuYm9keSwgaW5zdGFuY2VDdHgsIF92aXNpdG9yKTtcbiAgICAgIH07XG4gICAgICB2YXIgc3VwZXJDbGFzcyA9IF9jbGFzc1N0bXQucGFyZW50ID8gX2NsYXNzU3RtdC5wYXJlbnQudmlzaXRFeHByZXNzaW9uKF92aXNpdG9yLCBfY3R4KSA6IE9iamVjdDtcbiAgICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSwgcHJvcGVydHlEZXNjcmlwdG9ycyk7XG4gICAgICByZXR1cm4gY3RvcjtcbiAgfVxuICB2YXIgU3RhdGVtZW50SW50ZXJwcmV0ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gU3RhdGVtZW50SW50ZXJwcmV0ZXIoKSB7XG4gICAgICB9XG4gICAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUuZGVidWdBc3QgPSBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBkZWJ1Z091dHB1dEFzdEFzVHlwZVNjcmlwdChhc3QpOyB9O1xuICAgICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0RGVjbGFyZVZhclN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgICAgY3R4LnZhcnMuc2V0KHN0bXQubmFtZSwgc3RtdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KSk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0V3JpdGVWYXJFeHByID0gZnVuY3Rpb24gKGV4cHIsIGN0eCkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGV4cHIudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgICAgdmFyIGN1cnJDdHggPSBjdHg7XG4gICAgICAgICAgd2hpbGUgKGN1cnJDdHggIT0gbnVsbCkge1xuICAgICAgICAgICAgICBpZiAoY3VyckN0eC52YXJzLmhhcyhleHByLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICBjdXJyQ3R4LnZhcnMuc2V0KGV4cHIubmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGN1cnJDdHggPSBjdXJyQ3R4LnBhcmVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGRlY2xhcmVkIHZhcmlhYmxlIFwiICsgZXhwci5uYW1lKTtcbiAgICAgIH07XG4gICAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRSZWFkVmFyRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICAgIHZhciB2YXJOYW1lID0gYXN0Lm5hbWU7XG4gICAgICAgICAgaWYgKGlzUHJlc2VudChhc3QuYnVpbHRpbikpIHtcbiAgICAgICAgICAgICAgc3dpdGNoIChhc3QuYnVpbHRpbikge1xuICAgICAgICAgICAgICAgICAgY2FzZSBCdWlsdGluVmFyLlN1cGVyOlxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdHguaW5zdGFuY2UuX19wcm90b19fO1xuICAgICAgICAgICAgICAgICAgY2FzZSBCdWlsdGluVmFyLlRoaXM6XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN0eC5pbnN0YW5jZTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgQnVpbHRpblZhci5DYXRjaEVycm9yOlxuICAgICAgICAgICAgICAgICAgICAgIHZhck5hbWUgPSBDQVRDSF9FUlJPUl9WQVIkMTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgQnVpbHRpblZhci5DYXRjaFN0YWNrOlxuICAgICAgICAgICAgICAgICAgICAgIHZhck5hbWUgPSBDQVRDSF9TVEFDS19WQVIkMTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBidWlsdGluIHZhcmlhYmxlIFwiICsgYXN0LmJ1aWx0aW4pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBjdXJyQ3R4ID0gY3R4O1xuICAgICAgICAgIHdoaWxlIChjdXJyQ3R4ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgaWYgKGN1cnJDdHgudmFycy5oYXModmFyTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJyQ3R4LnZhcnMuZ2V0KHZhck5hbWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGN1cnJDdHggPSBjdXJyQ3R4LnBhcmVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGRlY2xhcmVkIHZhcmlhYmxlIFwiICsgdmFyTmFtZSk7XG4gICAgICB9O1xuICAgICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0V3JpdGVLZXlFeHByID0gZnVuY3Rpb24gKGV4cHIsIGN0eCkge1xuICAgICAgICAgIHZhciByZWNlaXZlciA9IGV4cHIucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgICAgdmFyIGluZGV4ID0gZXhwci5pbmRleC52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBleHByLnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgIHJlY2VpdmVyW2luZGV4XSA9IHZhbHVlO1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH07XG4gICAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRXcml0ZVByb3BFeHByID0gZnVuY3Rpb24gKGV4cHIsIGN0eCkge1xuICAgICAgICAgIHZhciByZWNlaXZlciA9IGV4cHIucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgICAgdmFyIHZhbHVlID0gZXhwci52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICByZWNlaXZlcltleHByLm5hbWVdID0gdmFsdWU7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfTtcbiAgICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdEludm9rZU1ldGhvZEV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY3R4KSB7XG4gICAgICAgICAgdmFyIHJlY2VpdmVyID0gZXhwci5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICB2YXIgYXJncyA9IHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhleHByLmFyZ3MsIGN0eCk7XG4gICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KGV4cHIuYnVpbHRpbikpIHtcbiAgICAgICAgICAgICAgc3dpdGNoIChleHByLmJ1aWx0aW4pIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgQnVpbHRpbk1ldGhvZC5Db25jYXRBcnJheTpcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBMaXN0V3JhcHBlci5jb25jYXQocmVjZWl2ZXIsIGFyZ3NbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBCdWlsdGluTWV0aG9kLlN1YnNjcmliZU9ic2VydmFibGU6XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVjZWl2ZXIuc3Vic2NyaWJlKHsgbmV4dDogYXJnc1swXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgQnVpbHRpbk1ldGhvZC5CaW5kOlxuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlY2VpdmVyLmJpbmQoYXJnc1swXSk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gYnVpbHRpbiBtZXRob2QgXCIgKyBleHByLmJ1aWx0aW4pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQgPSByZWNlaXZlcltleHByLm5hbWVdLmFwcGx5KHJlY2VpdmVyLCBhcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRJbnZva2VGdW5jdGlvbkV4cHIgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoc3RtdC5hcmdzLCBjdHgpO1xuICAgICAgICAgIHZhciBmbkV4cHIgPSBzdG10LmZuO1xuICAgICAgICAgIGlmIChmbkV4cHIgaW5zdGFuY2VvZiBSZWFkVmFyRXhwciAmJiBmbkV4cHIuYnVpbHRpbiA9PT0gQnVpbHRpblZhci5TdXBlcikge1xuICAgICAgICAgICAgICBjdHguaW5zdGFuY2UuY29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yLmFwcGx5KGN0eC5pbnN0YW5jZSwgYXJncyk7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIGZuID0gc3RtdC5mbi52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRSZXR1cm5TdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICAgIHJldHVybiBuZXcgUmV0dXJuVmFsdWUoc3RtdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KSk7XG4gICAgICB9O1xuICAgICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0RGVjbGFyZUNsYXNzU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgICB2YXIgY2xhenogPSBjcmVhdGVEeW5hbWljQ2xhc3Moc3RtdCwgY3R4LCB0aGlzKTtcbiAgICAgICAgICBjdHgudmFycy5zZXQoc3RtdC5uYW1lLCBjbGF6eik7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvblN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgICAgcmV0dXJuIHN0bXQuZXhwci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgIH07XG4gICAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRJZlN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgICAgdmFyIGNvbmRpdGlvbiA9IHN0bXQuY29uZGl0aW9uLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgIGlmIChjb25kaXRpb24pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQudHJ1ZUNhc2UsIGN0eCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGlzUHJlc2VudChzdG10LmZhbHNlQ2FzZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuZmFsc2VDYXNlLCBjdHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRUcnlDYXRjaFN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuYm9keVN0bXRzLCBjdHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICB2YXIgY2hpbGRDdHggPSBjdHguY3JlYXRlQ2hpbGRXaWh0TG9jYWxWYXJzKCk7XG4gICAgICAgICAgICAgIGNoaWxkQ3R4LnZhcnMuc2V0KENBVENIX0VSUk9SX1ZBUiQxLCBlKTtcbiAgICAgICAgICAgICAgY2hpbGRDdHgudmFycy5zZXQoQ0FUQ0hfU1RBQ0tfVkFSJDEsIGUuc3RhY2spO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5jYXRjaFN0bXRzLCBjaGlsZEN0eCk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdFRocm93U3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgICB0aHJvdyBzdG10LmVycm9yLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgfTtcbiAgICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdENvbW1lbnRTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRJbnN0YW50aWF0ZUV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgICB2YXIgYXJncyA9IHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhhc3QuYXJncywgY3R4KTtcbiAgICAgICAgICB2YXIgY2xhenogPSBhc3QuY2xhc3NFeHByLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgIHJldHVybiBuZXcgKGNsYXp6LmJpbmQuYXBwbHkoY2xhenosIFt2b2lkIDBdLmNvbmNhdChhcmdzKSkpKCk7XG4gICAgICB9O1xuICAgICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0TGl0ZXJhbEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHsgcmV0dXJuIGFzdC52YWx1ZTsgfTtcbiAgICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdEV4dGVybmFsRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICAgIHJldHVybiBhc3QudmFsdWUucmVmZXJlbmNlO1xuICAgICAgfTtcbiAgICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdENvbmRpdGlvbmFsRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICAgIGlmIChhc3QuY29uZGl0aW9uLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhc3QudHJ1ZUNhc2UudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGlzUHJlc2VudChhc3QuZmFsc2VDYXNlKSkge1xuICAgICAgICAgICAgICByZXR1cm4gYXN0LmZhbHNlQ2FzZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0Tm90RXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICAgIHJldHVybiAhYXN0LmNvbmRpdGlvbi52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgIH07XG4gICAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRDYXN0RXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICAgIHJldHVybiBhc3QudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICB9O1xuICAgICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0RnVuY3Rpb25FeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgICAgdmFyIHBhcmFtTmFtZXMgPSBhc3QucGFyYW1zLm1hcChmdW5jdGlvbiAocGFyYW0pIHsgcmV0dXJuIHBhcmFtLm5hbWU7IH0pO1xuICAgICAgICAgIHJldHVybiBfZGVjbGFyZUZuKHBhcmFtTmFtZXMsIGFzdC5zdGF0ZW1lbnRzLCBjdHgsIHRoaXMpO1xuICAgICAgfTtcbiAgICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdERlY2xhcmVGdW5jdGlvblN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgICAgdmFyIHBhcmFtTmFtZXMgPSBzdG10LnBhcmFtcy5tYXAoZnVuY3Rpb24gKHBhcmFtKSB7IHJldHVybiBwYXJhbS5uYW1lOyB9KTtcbiAgICAgICAgICBjdHgudmFycy5zZXQoc3RtdC5uYW1lLCBfZGVjbGFyZUZuKHBhcmFtTmFtZXMsIHN0bXQuc3RhdGVtZW50cywgY3R4LCB0aGlzKSk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0QmluYXJ5T3BlcmF0b3JFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgbGhzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gYXN0Lmxocy52aXNpdEV4cHJlc3Npb24oX3RoaXMsIGN0eCk7IH07XG4gICAgICAgICAgdmFyIHJocyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFzdC5yaHMudmlzaXRFeHByZXNzaW9uKF90aGlzLCBjdHgpOyB9O1xuICAgICAgICAgIHN3aXRjaCAoYXN0Lm9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuRXF1YWxzOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGxocygpID09IHJocygpO1xuICAgICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLklkZW50aWNhbDpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBsaHMoKSA9PT0gcmhzKCk7XG4gICAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuTm90RXF1YWxzOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGxocygpICE9IHJocygpO1xuICAgICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLk5vdElkZW50aWNhbDpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBsaHMoKSAhPT0gcmhzKCk7XG4gICAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuQW5kOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGxocygpICYmIHJocygpO1xuICAgICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLk9yOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGxocygpIHx8IHJocygpO1xuICAgICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLlBsdXM6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbGhzKCkgKyByaHMoKTtcbiAgICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5NaW51czpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBsaHMoKSAtIHJocygpO1xuICAgICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLkRpdmlkZTpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBsaHMoKSAvIHJocygpO1xuICAgICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLk11bHRpcGx5OlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGxocygpICogcmhzKCk7XG4gICAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuTW9kdWxvOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGxocygpICUgcmhzKCk7XG4gICAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuTG93ZXI6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbGhzKCkgPCByaHMoKTtcbiAgICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5Mb3dlckVxdWFsczpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBsaHMoKSA8PSByaHMoKTtcbiAgICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5CaWdnZXI6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbGhzKCkgPiByaHMoKTtcbiAgICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5CaWdnZXJFcXVhbHM6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbGhzKCkgPj0gcmhzKCk7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9wZXJhdG9yIFwiICsgYXN0Lm9wZXJhdG9yKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0UmVhZFByb3BFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICB2YXIgcmVjZWl2ZXIgPSBhc3QucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgICAgcmVzdWx0ID0gcmVjZWl2ZXJbYXN0Lm5hbWVdO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0UmVhZEtleUV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgICB2YXIgcmVjZWl2ZXIgPSBhc3QucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgICAgdmFyIHByb3AgPSBhc3QuaW5kZXgudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgICAgcmV0dXJuIHJlY2VpdmVyW3Byb3BdO1xuICAgICAgfTtcbiAgICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdExpdGVyYWxBcnJheUV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5lbnRyaWVzLCBjdHgpO1xuICAgICAgfTtcbiAgICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdExpdGVyYWxNYXBFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgICAgYXN0LmVudHJpZXMuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuIHJlc3VsdFtlbnRyeVswXV0gPVxuICAgICAgICAgICAgICBlbnRyeVsxXS52aXNpdEV4cHJlc3Npb24oX3RoaXMsIGN0eCk7IH0pO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0QWxsRXhwcmVzc2lvbnMgPSBmdW5jdGlvbiAoZXhwcmVzc2lvbnMsIGN0eCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgcmV0dXJuIGV4cHJlc3Npb25zLm1hcChmdW5jdGlvbiAoZXhwcikgeyByZXR1cm4gZXhwci52aXNpdEV4cHJlc3Npb24oX3RoaXMsIGN0eCk7IH0pO1xuICAgICAgfTtcbiAgICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdEFsbFN0YXRlbWVudHMgPSBmdW5jdGlvbiAoc3RhdGVtZW50cywgY3R4KSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBzdG10ID0gc3RhdGVtZW50c1tpXTtcbiAgICAgICAgICAgICAgdmFyIHZhbCA9IHN0bXQudmlzaXRTdGF0ZW1lbnQodGhpcywgY3R4KTtcbiAgICAgICAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIFJldHVyblZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBTdGF0ZW1lbnRJbnRlcnByZXRlcjtcbiAgfSgpKTtcbiAgZnVuY3Rpb24gX2RlY2xhcmVGbih2YXJOYW1lcywgc3RhdGVtZW50cywgY3R4LCB2aXNpdG9yKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgYXJnc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIF9leGVjdXRlRnVuY3Rpb25TdGF0ZW1lbnRzKHZhck5hbWVzLCBhcmdzLCBzdGF0ZW1lbnRzLCBjdHgsIHZpc2l0b3IpO1xuICAgICAgfTtcbiAgfVxuICB2YXIgQ0FUQ0hfRVJST1JfVkFSJDEgPSAnZXJyb3InO1xuICB2YXIgQ0FUQ0hfU1RBQ0tfVkFSJDEgPSAnc3RhY2snO1xuXG4gIC8qKlxuICAgKiBAbGljZW5zZVxuICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICpcbiAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgKi9cbiAgdmFyIF9fZXh0ZW5kcyQxOSA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgfTtcbiAgdmFyIEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMTkoQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yKCkge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXREZWNsYXJlQ2xhc3NTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgY3R4LnB1c2hDbGFzcyhzdG10KTtcbiAgICAgICAgICB0aGlzLl92aXNpdENsYXNzQ29uc3RydWN0b3Ioc3RtdCwgY3R4KTtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KHN0bXQucGFyZW50KSkge1xuICAgICAgICAgICAgICBjdHgucHJpbnQoc3RtdC5uYW1lICsgXCIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShcIik7XG4gICAgICAgICAgICAgIHN0bXQucGFyZW50LnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgICAgICBjdHgucHJpbnRsbihcIi5wcm90b3R5cGUpO1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RtdC5nZXR0ZXJzLmZvckVhY2goZnVuY3Rpb24gKGdldHRlcikgeyByZXR1cm4gX3RoaXMuX3Zpc2l0Q2xhc3NHZXR0ZXIoc3RtdCwgZ2V0dGVyLCBjdHgpOyB9KTtcbiAgICAgICAgICBzdG10Lm1ldGhvZHMuZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7IHJldHVybiBfdGhpcy5fdmlzaXRDbGFzc01ldGhvZChzdG10LCBtZXRob2QsIGN0eCk7IH0pO1xuICAgICAgICAgIGN0eC5wb3BDbGFzcygpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUuX3Zpc2l0Q2xhc3NDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgICBjdHgucHJpbnQoXCJmdW5jdGlvbiBcIiArIHN0bXQubmFtZSArIFwiKFwiKTtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KHN0bXQuY29uc3RydWN0b3JNZXRob2QpKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3Zpc2l0UGFyYW1zKHN0bXQuY29uc3RydWN0b3JNZXRob2QucGFyYW1zLCBjdHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdHgucHJpbnRsbihcIikge1wiKTtcbiAgICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgICAgaWYgKGlzUHJlc2VudChzdG10LmNvbnN0cnVjdG9yTWV0aG9kKSkge1xuICAgICAgICAgICAgICBpZiAoc3RtdC5jb25zdHJ1Y3Rvck1ldGhvZC5ib2R5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIGN0eC5wcmludGxuKFwidmFyIHNlbGYgPSB0aGlzO1wiKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuY29uc3RydWN0b3JNZXRob2QuYm9keSwgY3R4KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgICAgY3R4LnByaW50bG4oXCJ9XCIpO1xuICAgICAgfTtcbiAgICAgIEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUuX3Zpc2l0Q2xhc3NHZXR0ZXIgPSBmdW5jdGlvbiAoc3RtdCwgZ2V0dGVyLCBjdHgpIHtcbiAgICAgICAgICBjdHgucHJpbnRsbihcIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShcIiArIHN0bXQubmFtZSArIFwiLnByb3RvdHlwZSwgJ1wiICsgZ2V0dGVyLm5hbWUgKyBcIicsIHsgZ2V0OiBmdW5jdGlvbigpIHtcIik7XG4gICAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICAgIGlmIChnZXR0ZXIuYm9keS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGN0eC5wcmludGxuKFwidmFyIHNlbGYgPSB0aGlzO1wiKTtcbiAgICAgICAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoZ2V0dGVyLmJvZHksIGN0eCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgICBjdHgucHJpbnRsbihcIn19KTtcIik7XG4gICAgICB9O1xuICAgICAgQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS5fdmlzaXRDbGFzc01ldGhvZCA9IGZ1bmN0aW9uIChzdG10LCBtZXRob2QsIGN0eCkge1xuICAgICAgICAgIGN0eC5wcmludChzdG10Lm5hbWUgKyBcIi5wcm90b3R5cGUuXCIgKyBtZXRob2QubmFtZSArIFwiID0gZnVuY3Rpb24oXCIpO1xuICAgICAgICAgIHRoaXMuX3Zpc2l0UGFyYW1zKG1ldGhvZC5wYXJhbXMsIGN0eCk7XG4gICAgICAgICAgY3R4LnByaW50bG4oXCIpIHtcIik7XG4gICAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICAgIGlmIChtZXRob2QuYm9keS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGN0eC5wcmludGxuKFwidmFyIHNlbGYgPSB0aGlzO1wiKTtcbiAgICAgICAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMobWV0aG9kLmJvZHksIGN0eCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgICBjdHgucHJpbnRsbihcIn07XCIpO1xuICAgICAgfTtcbiAgICAgIEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRSZWFkVmFyRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICAgIGlmIChhc3QuYnVpbHRpbiA9PT0gQnVpbHRpblZhci5UaGlzKSB7XG4gICAgICAgICAgICAgIGN0eC5wcmludCgnc2VsZicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChhc3QuYnVpbHRpbiA9PT0gQnVpbHRpblZhci5TdXBlcikge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCInc3VwZXInIG5lZWRzIHRvIGJlIGhhbmRsZWQgYXQgYSBwYXJlbnQgYXN0IG5vZGUsIG5vdCBhdCB0aGUgdmFyaWFibGUgbGV2ZWwhXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS52aXNpdFJlYWRWYXJFeHByLmNhbGwodGhpcywgYXN0LCBjdHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBBYnN0cmFjdEpzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RGVjbGFyZVZhclN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgICAgY3R4LnByaW50KFwidmFyIFwiICsgc3RtdC5uYW1lICsgXCIgPSBcIik7XG4gICAgICAgICAgc3RtdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICBjdHgucHJpbnRsbihcIjtcIik7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdENhc3RFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgICAgYXN0LnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRJbnZva2VGdW5jdGlvbkV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY3R4KSB7XG4gICAgICAgICAgdmFyIGZuRXhwciA9IGV4cHIuZm47XG4gICAgICAgICAgaWYgKGZuRXhwciBpbnN0YW5jZW9mIFJlYWRWYXJFeHByICYmIGZuRXhwci5idWlsdGluID09PSBCdWlsdGluVmFyLlN1cGVyKSB7XG4gICAgICAgICAgICAgIGN0eC5jdXJyZW50Q2xhc3MucGFyZW50LnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgICAgICBjdHgucHJpbnQoXCIuY2FsbCh0aGlzXCIpO1xuICAgICAgICAgICAgICBpZiAoZXhwci5hcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIGN0eC5wcmludChcIiwgXCIpO1xuICAgICAgICAgICAgICAgICAgdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGV4cHIuYXJncywgY3R4LCAnLCcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGN0eC5wcmludChcIilcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLnZpc2l0SW52b2tlRnVuY3Rpb25FeHByLmNhbGwodGhpcywgZXhwciwgY3R4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEZ1bmN0aW9uRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICAgIGN0eC5wcmludChcImZ1bmN0aW9uKFwiKTtcbiAgICAgICAgICB0aGlzLl92aXNpdFBhcmFtcyhhc3QucGFyYW1zLCBjdHgpO1xuICAgICAgICAgIGN0eC5wcmludGxuKFwiKSB7XCIpO1xuICAgICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhhc3Quc3RhdGVtZW50cywgY3R4KTtcbiAgICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgICAgY3R4LnByaW50KFwifVwiKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBBYnN0cmFjdEpzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RGVjbGFyZUZ1bmN0aW9uU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgICBjdHgucHJpbnQoXCJmdW5jdGlvbiBcIiArIHN0bXQubmFtZSArIFwiKFwiKTtcbiAgICAgICAgICB0aGlzLl92aXNpdFBhcmFtcyhzdG10LnBhcmFtcywgY3R4KTtcbiAgICAgICAgICBjdHgucHJpbnRsbihcIikge1wiKTtcbiAgICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5zdGF0ZW1lbnRzLCBjdHgpO1xuICAgICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgICBjdHgucHJpbnRsbihcIn1cIik7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRyeUNhdGNoU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgICBjdHgucHJpbnRsbihcInRyeSB7XCIpO1xuICAgICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LmJvZHlTdG10cywgY3R4KTtcbiAgICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgICAgY3R4LnByaW50bG4oXCJ9IGNhdGNoIChcIiArIENBVENIX0VSUk9SX1ZBUiQyLm5hbWUgKyBcIikge1wiKTtcbiAgICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgICAgdmFyIGNhdGNoU3RtdHMgPSBbQ0FUQ0hfU1RBQ0tfVkFSJDIuc2V0KENBVENIX0VSUk9SX1ZBUiQyLnByb3AoJ3N0YWNrJykpLnRvRGVjbFN0bXQobnVsbCwgW1xuICAgICAgICAgICAgICAgICAgU3RtdE1vZGlmaWVyLkZpbmFsXG4gICAgICAgICAgICAgIF0pXS5jb25jYXQoc3RtdC5jYXRjaFN0bXRzKTtcbiAgICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhjYXRjaFN0bXRzLCBjdHgpO1xuICAgICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgICBjdHgucHJpbnRsbihcIn1cIik7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS5fdmlzaXRQYXJhbXMgPSBmdW5jdGlvbiAocGFyYW1zLCBjdHgpIHtcbiAgICAgICAgICB0aGlzLnZpc2l0QWxsT2JqZWN0cyhmdW5jdGlvbiAocGFyYW0pIHsgcmV0dXJuIGN0eC5wcmludChwYXJhbS5uYW1lKTsgfSwgcGFyYW1zLCBjdHgsICcsJyk7XG4gICAgICB9O1xuICAgICAgQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS5nZXRCdWlsdGluTWV0aG9kTmFtZSA9IGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgICB2YXIgbmFtZTtcbiAgICAgICAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgICAgICAgICBjYXNlIEJ1aWx0aW5NZXRob2QuQ29uY2F0QXJyYXk6XG4gICAgICAgICAgICAgICAgICBuYW1lID0gJ2NvbmNhdCc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBCdWlsdGluTWV0aG9kLlN1YnNjcmliZU9ic2VydmFibGU6XG4gICAgICAgICAgICAgICAgICBuYW1lID0gJ3N1YnNjcmliZSc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBCdWlsdGluTWV0aG9kLkJpbmQ6XG4gICAgICAgICAgICAgICAgICBuYW1lID0gJ2JpbmQnO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGJ1aWx0aW4gbWV0aG9kOiBcIiArIG1ldGhvZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBBYnN0cmFjdEpzRW1pdHRlclZpc2l0b3I7XG4gIH0oQWJzdHJhY3RFbWl0dGVyVmlzaXRvcikpO1xuXG4gIC8qKlxuICAgKiBAbGljZW5zZVxuICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICpcbiAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgKi9cbiAgdmFyIF9fZXh0ZW5kcyQxOCA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgfTtcbiAgZnVuY3Rpb24gZXZhbEV4cHJlc3Npb24oc291cmNlVXJsLCBleHByLCBkZWNsYXJhdGlvbnMsIHZhcnMpIHtcbiAgICAgIHZhciBmbkJvZHkgPSBkZWNsYXJhdGlvbnMgKyBcIlxcbnJldHVybiBcIiArIGV4cHIgKyBcIlxcbi8vIyBzb3VyY2VVUkw9XCIgKyBzb3VyY2VVcmw7XG4gICAgICB2YXIgZm5BcmdOYW1lcyA9IFtdO1xuICAgICAgdmFyIGZuQXJnVmFsdWVzID0gW107XG4gICAgICBmb3IgKHZhciBhcmdOYW1lIGluIHZhcnMpIHtcbiAgICAgICAgICBmbkFyZ05hbWVzLnB1c2goYXJnTmFtZSk7XG4gICAgICAgICAgZm5BcmdWYWx1ZXMucHVzaCh2YXJzW2FyZ05hbWVdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLmJpbmQuYXBwbHkoRnVuY3Rpb24sIFt2b2lkIDBdLmNvbmNhdChmbkFyZ05hbWVzLmNvbmNhdChmbkJvZHkpKSkpKCkuYXBwbHkodm9pZCAwLCBmbkFyZ1ZhbHVlcyk7XG4gIH1cbiAgZnVuY3Rpb24gaml0U3RhdGVtZW50cyhzb3VyY2VVcmwsIHN0YXRlbWVudHMsIHJlc3VsdFZhcikge1xuICAgICAgdmFyIGNvbnZlcnRlciA9IG5ldyBKaXRFbWl0dGVyVmlzaXRvcigpO1xuICAgICAgdmFyIGN0eCA9IEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5jcmVhdGVSb290KFtyZXN1bHRWYXJdKTtcbiAgICAgIGNvbnZlcnRlci52aXNpdEFsbFN0YXRlbWVudHMoc3RhdGVtZW50cywgY3R4KTtcbiAgICAgIHJldHVybiBldmFsRXhwcmVzc2lvbihzb3VyY2VVcmwsIHJlc3VsdFZhciwgY3R4LnRvU291cmNlKCksIGNvbnZlcnRlci5nZXRBcmdzKCkpO1xuICB9XG4gIHZhciBKaXRFbWl0dGVyVmlzaXRvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMTgoSml0RW1pdHRlclZpc2l0b3IsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBKaXRFbWl0dGVyVmlzaXRvcigpIHtcbiAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICB0aGlzLl9ldmFsQXJnTmFtZXMgPSBbXTtcbiAgICAgICAgICB0aGlzLl9ldmFsQXJnVmFsdWVzID0gW107XG4gICAgICB9XG4gICAgICBKaXRFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUuZ2V0QXJncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9ldmFsQXJnTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgcmVzdWx0W3RoaXMuX2V2YWxBcmdOYW1lc1tpXV0gPSB0aGlzLl9ldmFsQXJnVmFsdWVzW2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICAgIEppdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4dGVybmFsRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGFzdC52YWx1ZS5yZWZlcmVuY2U7XG4gICAgICAgICAgdmFyIGlkID0gdGhpcy5fZXZhbEFyZ1ZhbHVlcy5pbmRleE9mKHZhbHVlKTtcbiAgICAgICAgICBpZiAoaWQgPT09IC0xKSB7XG4gICAgICAgICAgICAgIGlkID0gdGhpcy5fZXZhbEFyZ1ZhbHVlcy5sZW5ndGg7XG4gICAgICAgICAgICAgIHRoaXMuX2V2YWxBcmdWYWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgIHZhciBuYW1lID0gaXNQcmVzZW50KGFzdC52YWx1ZS5uYW1lKSA/IHNhbml0aXplSWRlbnRpZmllcihhc3QudmFsdWUubmFtZSkgOiAndmFsJztcbiAgICAgICAgICAgICAgdGhpcy5fZXZhbEFyZ05hbWVzLnB1c2goc2FuaXRpemVJZGVudGlmaWVyKFwiaml0X1wiICsgbmFtZSArIGlkKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN0eC5wcmludCh0aGlzLl9ldmFsQXJnTmFtZXNbaWRdKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICByZXR1cm4gSml0RW1pdHRlclZpc2l0b3I7XG4gIH0oQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yKSk7XG5cbiAgLyoqXG4gICAqIEBsaWNlbnNlXG4gICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgKlxuICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAqL1xuICAvKipcbiAgICogVGhpcyBmaWxlIGlzIGEgcG9ydCBvZiBzaGFkb3dDU1MgZnJvbSB3ZWJjb21wb25lbnRzLmpzIHRvIFR5cGVTY3JpcHQuXG4gICAqXG4gICAqIFBsZWFzZSBtYWtlIHN1cmUgdG8ga2VlcCB0byBlZGl0cyBpbiBzeW5jIHdpdGggdGhlIHNvdXJjZSBmaWxlLlxuICAgKlxuICAgKiBTb3VyY2U6XG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJjb21wb25lbnRzL3dlYmNvbXBvbmVudHNqcy9ibG9iLzRlZmVjZDdlMGUvc3JjL1NoYWRvd0NTUy9TaGFkb3dDU1MuanNcbiAgICpcbiAgICogVGhlIG9yaWdpbmFsIGZpbGUgbGV2ZWwgY29tbWVudCBpcyByZXByb2R1Y2VkIGJlbG93XG4gICAqL1xuICAvKlxuICAgIFRoaXMgaXMgYSBsaW1pdGVkIHNoaW0gZm9yIFNoYWRvd0RPTSBjc3Mgc3R5bGluZy5cbiAgICBodHRwczovL2R2Y3MudzMub3JnL2hnL3dlYmNvbXBvbmVudHMvcmF3LWZpbGUvdGlwL3NwZWMvc2hhZG93L2luZGV4Lmh0bWwjc3R5bGVzXG5cbiAgICBUaGUgaW50ZW50aW9uIGhlcmUgaXMgdG8gc3VwcG9ydCBvbmx5IHRoZSBzdHlsaW5nIGZlYXR1cmVzIHdoaWNoIGNhbiBiZVxuICAgIHJlbGF0aXZlbHkgc2ltcGx5IGltcGxlbWVudGVkLiBUaGUgZ29hbCBpcyB0byBhbGxvdyB1c2VycyB0byBhdm9pZCB0aGVcbiAgICBtb3N0IG9idmlvdXMgcGl0ZmFsbHMgYW5kIGRvIHNvIHdpdGhvdXQgY29tcHJvbWlzaW5nIHBlcmZvcm1hbmNlIHNpZ25pZmljYW50bHkuXG4gICAgRm9yIFNoYWRvd0RPTSBzdHlsaW5nIHRoYXQncyBub3QgY292ZXJlZCBoZXJlLCBhIHNldCBvZiBiZXN0IHByYWN0aWNlc1xuICAgIGNhbiBiZSBwcm92aWRlZCB0aGF0IHNob3VsZCBhbGxvdyB1c2VycyB0byBhY2NvbXBsaXNoIG1vcmUgY29tcGxleCBzdHlsaW5nLlxuXG4gICAgVGhlIGZvbGxvd2luZyBpcyBhIGxpc3Qgb2Ygc3BlY2lmaWMgU2hhZG93RE9NIHN0eWxpbmcgZmVhdHVyZXMgYW5kIGEgYnJpZWZcbiAgICBkaXNjdXNzaW9uIG9mIHRoZSBhcHByb2FjaCB1c2VkIHRvIHNoaW0uXG5cbiAgICBTaGltbWVkIGZlYXR1cmVzOlxuXG4gICAgKiA6aG9zdCwgOmhvc3QtY29udGV4dDogU2hhZG93RE9NIGFsbG93cyBzdHlsaW5nIG9mIHRoZSBzaGFkb3dSb290J3MgaG9zdFxuICAgIGVsZW1lbnQgdXNpbmcgdGhlIDpob3N0IHJ1bGUuIFRvIHNoaW0gdGhpcyBmZWF0dXJlLCB0aGUgOmhvc3Qgc3R5bGVzIGFyZVxuICAgIHJlZm9ybWF0dGVkIGFuZCBwcmVmaXhlZCB3aXRoIGEgZ2l2ZW4gc2NvcGUgbmFtZSBhbmQgcHJvbW90ZWQgdG8gYVxuICAgIGRvY3VtZW50IGxldmVsIHN0eWxlc2hlZXQuXG4gICAgRm9yIGV4YW1wbGUsIGdpdmVuIGEgc2NvcGUgbmFtZSBvZiAuZm9vLCBhIHJ1bGUgbGlrZSB0aGlzOlxuXG4gICAgICA6aG9zdCB7XG4gICAgICAgICAgYmFja2dyb3VuZDogcmVkO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICBiZWNvbWVzOlxuXG4gICAgICAuZm9vIHtcbiAgICAgICAgYmFja2dyb3VuZDogcmVkO1xuICAgICAgfVxuXG4gICAgKiBlbmNhcHN1bGF0aW9uOiBTdHlsZXMgZGVmaW5lZCB3aXRoaW4gU2hhZG93RE9NLCBhcHBseSBvbmx5IHRvXG4gICAgZG9tIGluc2lkZSB0aGUgU2hhZG93RE9NLiBQb2x5bWVyIHVzZXMgb25lIG9mIHR3byB0ZWNobmlxdWVzIHRvIGltcGxlbWVudFxuICAgIHRoaXMgZmVhdHVyZS5cblxuICAgIEJ5IGRlZmF1bHQsIHJ1bGVzIGFyZSBwcmVmaXhlZCB3aXRoIHRoZSBob3N0IGVsZW1lbnQgdGFnIG5hbWVcbiAgICBhcyBhIGRlc2NlbmRhbnQgc2VsZWN0b3IuIFRoaXMgZW5zdXJlcyBzdHlsaW5nIGRvZXMgbm90IGxlYWsgb3V0IG9mIHRoZSAndG9wJ1xuICAgIG9mIHRoZSBlbGVtZW50J3MgU2hhZG93RE9NLiBGb3IgZXhhbXBsZSxcblxuICAgIGRpdiB7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgfVxuXG4gICAgYmVjb21lczpcblxuICAgIHgtZm9vIGRpdiB7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgfVxuXG4gICAgYmVjb21lczpcblxuXG4gICAgQWx0ZXJuYXRpdmVseSwgaWYgV2ViQ29tcG9uZW50cy5TaGFkb3dDU1Muc3RyaWN0U3R5bGluZyBpcyBzZXQgdG8gdHJ1ZSB0aGVuXG4gICAgc2VsZWN0b3JzIGFyZSBzY29wZWQgYnkgYWRkaW5nIGFuIGF0dHJpYnV0ZSBzZWxlY3RvciBzdWZmaXggdG8gZWFjaFxuICAgIHNpbXBsZSBzZWxlY3RvciB0aGF0IGNvbnRhaW5zIHRoZSBob3N0IGVsZW1lbnQgdGFnIG5hbWUuIEVhY2ggZWxlbWVudFxuICAgIGluIHRoZSBlbGVtZW50J3MgU2hhZG93RE9NIHRlbXBsYXRlIGlzIGFsc28gZ2l2ZW4gdGhlIHNjb3BlIGF0dHJpYnV0ZS5cbiAgICBUaHVzLCB0aGVzZSBydWxlcyBtYXRjaCBvbmx5IGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgc2NvcGUgYXR0cmlidXRlLlxuICAgIEZvciBleGFtcGxlLCBnaXZlbiBhIHNjb3BlIG5hbWUgb2YgeC1mb28sIGEgcnVsZSBsaWtlIHRoaXM6XG5cbiAgICAgIGRpdiB7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgfVxuXG4gICAgYmVjb21lczpcblxuICAgICAgZGl2W3gtZm9vXSB7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgfVxuXG4gICAgTm90ZSB0aGF0IGVsZW1lbnRzIHRoYXQgYXJlIGR5bmFtaWNhbGx5IGFkZGVkIHRvIGEgc2NvcGUgbXVzdCBoYXZlIHRoZSBzY29wZVxuICAgIHNlbGVjdG9yIGFkZGVkIHRvIHRoZW0gbWFudWFsbHkuXG5cbiAgICAqIHVwcGVyL2xvd2VyIGJvdW5kIGVuY2Fwc3VsYXRpb246IFN0eWxlcyB3aGljaCBhcmUgZGVmaW5lZCBvdXRzaWRlIGFcbiAgICBzaGFkb3dSb290IHNob3VsZCBub3QgY3Jvc3MgdGhlIFNoYWRvd0RPTSBib3VuZGFyeSBhbmQgc2hvdWxkIG5vdCBhcHBseVxuICAgIGluc2lkZSBhIHNoYWRvd1Jvb3QuXG5cbiAgICBUaGlzIHN0eWxpbmcgYmVoYXZpb3IgaXMgbm90IGVtdWxhdGVkLiBTb21lIHBvc3NpYmxlIHdheXMgdG8gZG8gdGhpcyB0aGF0XG4gICAgd2VyZSByZWplY3RlZCBkdWUgdG8gY29tcGxleGl0eSBhbmQvb3IgcGVyZm9ybWFuY2UgY29uY2VybnMgaW5jbHVkZTogKDEpIHJlc2V0XG4gICAgZXZlcnkgcG9zc2libGUgcHJvcGVydHkgZm9yIGV2ZXJ5IHBvc3NpYmxlIHNlbGVjdG9yIGZvciBhIGdpdmVuIHNjb3BlIG5hbWU7XG4gICAgKDIpIHJlLWltcGxlbWVudCBjc3MgaW4gamF2YXNjcmlwdC5cblxuICAgIEFzIGFuIGFsdGVybmF0aXZlLCB1c2VycyBzaG91bGQgbWFrZSBzdXJlIHRvIHVzZSBzZWxlY3RvcnNcbiAgICBzcGVjaWZpYyB0byB0aGUgc2NvcGUgaW4gd2hpY2ggdGhleSBhcmUgd29ya2luZy5cblxuICAgICogOjpkaXN0cmlidXRlZDogVGhpcyBiZWhhdmlvciBpcyBub3QgZW11bGF0ZWQuIEl0J3Mgb2Z0ZW4gbm90IG5lY2Vzc2FyeVxuICAgIHRvIHN0eWxlIHRoZSBjb250ZW50cyBvZiBhIHNwZWNpZmljIGluc2VydGlvbiBwb2ludCBhbmQgaW5zdGVhZCwgZGVzY2VuZGFudHNcbiAgICBvZiB0aGUgaG9zdCBlbGVtZW50IGNhbiBiZSBzdHlsZWQgc2VsZWN0aXZlbHkuIFVzZXJzIGNhbiBhbHNvIGNyZWF0ZSBhblxuICAgIGV4dHJhIG5vZGUgYXJvdW5kIGFuIGluc2VydGlvbiBwb2ludCBhbmQgc3R5bGUgdGhhdCBub2RlJ3MgY29udGVudHNcbiAgICB2aWEgZGVzY2VuZGVudCBzZWxlY3RvcnMuIEZvciBleGFtcGxlLCB3aXRoIGEgc2hhZG93Um9vdCBsaWtlIHRoaXM6XG5cbiAgICAgIDxzdHlsZT5cbiAgICAgICAgOjpjb250ZW50KGRpdikge1xuICAgICAgICAgIGJhY2tncm91bmQ6IHJlZDtcbiAgICAgICAgfVxuICAgICAgPC9zdHlsZT5cbiAgICAgIDxjb250ZW50PjwvY29udGVudD5cblxuICAgIGNvdWxkIGJlY29tZTpcblxuICAgICAgPHN0eWxlPlxuICAgICAgICAvICpAcG9seWZpbGwgLmNvbnRlbnQtY29udGFpbmVyIGRpdiAqIC9cbiAgICAgICAgOjpjb250ZW50KGRpdikge1xuICAgICAgICAgIGJhY2tncm91bmQ6IHJlZDtcbiAgICAgICAgfVxuICAgICAgPC9zdHlsZT5cbiAgICAgIDxkaXYgY2xhc3M9XCJjb250ZW50LWNvbnRhaW5lclwiPlxuICAgICAgICA8Y29udGVudD48L2NvbnRlbnQ+XG4gICAgICA8L2Rpdj5cblxuICAgIE5vdGUgdGhlIHVzZSBvZiBAcG9seWZpbGwgaW4gdGhlIGNvbW1lbnQgYWJvdmUgYSBTaGFkb3dET00gc3BlY2lmaWMgc3R5bGVcbiAgICBkZWNsYXJhdGlvbi4gVGhpcyBpcyBhIGRpcmVjdGl2ZSB0byB0aGUgc3R5bGluZyBzaGltIHRvIHVzZSB0aGUgc2VsZWN0b3JcbiAgICBpbiBjb21tZW50cyBpbiBsaWV1IG9mIHRoZSBuZXh0IHNlbGVjdG9yIHdoZW4gcnVubmluZyB1bmRlciBwb2x5ZmlsbC5cbiAgKi9cbiAgdmFyIFNoYWRvd0NzcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBTaGFkb3dDc3MoKSB7XG4gICAgICAgICAgdGhpcy5zdHJpY3RTdHlsaW5nID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIC8qXG4gICAgICAqIFNoaW0gc29tZSBjc3NUZXh0IHdpdGggdGhlIGdpdmVuIHNlbGVjdG9yLiBSZXR1cm5zIGNzc1RleHQgdGhhdCBjYW5cbiAgICAgICogYmUgaW5jbHVkZWQgaW4gdGhlIGRvY3VtZW50IHZpYSBXZWJDb21wb25lbnRzLlNoYWRvd0NTUy5hZGRDc3NUb0RvY3VtZW50KGNzcykuXG4gICAgICAqXG4gICAgICAqIFdoZW4gc3RyaWN0U3R5bGluZyBpcyB0cnVlOlxuICAgICAgKiAtIHNlbGVjdG9yIGlzIHRoZSBhdHRyaWJ1dGUgYWRkZWQgdG8gYWxsIGVsZW1lbnRzIGluc2lkZSB0aGUgaG9zdCxcbiAgICAgICogLSBob3N0U2VsZWN0b3IgaXMgdGhlIGF0dHJpYnV0ZSBhZGRlZCB0byB0aGUgaG9zdCBpdHNlbGYuXG4gICAgICAqL1xuICAgICAgU2hhZG93Q3NzLnByb3RvdHlwZS5zaGltQ3NzVGV4dCA9IGZ1bmN0aW9uIChjc3NUZXh0LCBzZWxlY3RvciwgaG9zdFNlbGVjdG9yKSB7XG4gICAgICAgICAgaWYgKGhvc3RTZWxlY3RvciA9PT0gdm9pZCAwKSB7IGhvc3RTZWxlY3RvciA9ICcnOyB9XG4gICAgICAgICAgdmFyIHNvdXJjZU1hcHBpbmdVcmwgPSBleHRyYWN0U291cmNlTWFwcGluZ1VybChjc3NUZXh0KTtcbiAgICAgICAgICBjc3NUZXh0ID0gc3RyaXBDb21tZW50cyhjc3NUZXh0KTtcbiAgICAgICAgICBjc3NUZXh0ID0gdGhpcy5faW5zZXJ0RGlyZWN0aXZlcyhjc3NUZXh0KTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fc2NvcGVDc3NUZXh0KGNzc1RleHQsIHNlbGVjdG9yLCBob3N0U2VsZWN0b3IpICsgc291cmNlTWFwcGluZ1VybDtcbiAgICAgIH07XG4gICAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9pbnNlcnREaXJlY3RpdmVzID0gZnVuY3Rpb24gKGNzc1RleHQpIHtcbiAgICAgICAgICBjc3NUZXh0ID0gdGhpcy5faW5zZXJ0UG9seWZpbGxEaXJlY3RpdmVzSW5Dc3NUZXh0KGNzc1RleHQpO1xuICAgICAgICAgIHJldHVybiB0aGlzLl9pbnNlcnRQb2x5ZmlsbFJ1bGVzSW5Dc3NUZXh0KGNzc1RleHQpO1xuICAgICAgfTtcbiAgICAgIC8qXG4gICAgICAgKiBQcm9jZXNzIHN0eWxlcyB0byBjb252ZXJ0IG5hdGl2ZSBTaGFkb3dET00gcnVsZXMgdGhhdCB3aWxsIHRyaXBcbiAgICAgICAqIHVwIHRoZSBjc3MgcGFyc2VyOyB3ZSByZWx5IG9uIGRlY29yYXRpbmcgdGhlIHN0eWxlc2hlZXQgd2l0aCBpbmVydCBydWxlcy5cbiAgICAgICAqXG4gICAgICAgKiBGb3IgZXhhbXBsZSwgd2UgY29udmVydCB0aGlzIHJ1bGU6XG4gICAgICAgKlxuICAgICAgICogcG9seWZpbGwtbmV4dC1zZWxlY3RvciB7IGNvbnRlbnQ6ICc6aG9zdCBtZW51LWl0ZW0nOyB9XG4gICAgICAgKiA6OmNvbnRlbnQgbWVudS1pdGVtIHtcbiAgICAgICAqXG4gICAgICAgKiB0byB0aGlzOlxuICAgICAgICpcbiAgICAgICAqIHNjb3BlTmFtZSBtZW51LWl0ZW0ge1xuICAgICAgICpcbiAgICAgICoqL1xuICAgICAgU2hhZG93Q3NzLnByb3RvdHlwZS5faW5zZXJ0UG9seWZpbGxEaXJlY3RpdmVzSW5Dc3NUZXh0ID0gZnVuY3Rpb24gKGNzc1RleHQpIHtcbiAgICAgICAgICAvLyBEaWZmZXJlbmNlIHdpdGggd2ViY29tcG9uZW50cy5qczogZG9lcyBub3QgaGFuZGxlIGNvbW1lbnRzXG4gICAgICAgICAgcmV0dXJuIGNzc1RleHQucmVwbGFjZShfY3NzQ29udGVudE5leHRTZWxlY3RvclJlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciBtID0gW107XG4gICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICBtW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBtWzJdICsgJ3snO1xuICAgICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIC8qXG4gICAgICAgKiBQcm9jZXNzIHN0eWxlcyB0byBhZGQgcnVsZXMgd2hpY2ggd2lsbCBvbmx5IGFwcGx5IHVuZGVyIHRoZSBwb2x5ZmlsbFxuICAgICAgICpcbiAgICAgICAqIEZvciBleGFtcGxlLCB3ZSBjb252ZXJ0IHRoaXMgcnVsZTpcbiAgICAgICAqXG4gICAgICAgKiBwb2x5ZmlsbC1ydWxlIHtcbiAgICAgICAqICAgY29udGVudDogJzpob3N0IG1lbnUtaXRlbSc7XG4gICAgICAgKiAuLi5cbiAgICAgICAqIH1cbiAgICAgICAqXG4gICAgICAgKiB0byB0aGlzOlxuICAgICAgICpcbiAgICAgICAqIHNjb3BlTmFtZSBtZW51LWl0ZW0gey4uLn1cbiAgICAgICAqXG4gICAgICAqKi9cbiAgICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX2luc2VydFBvbHlmaWxsUnVsZXNJbkNzc1RleHQgPSBmdW5jdGlvbiAoY3NzVGV4dCkge1xuICAgICAgICAgIC8vIERpZmZlcmVuY2Ugd2l0aCB3ZWJjb21wb25lbnRzLmpzOiBkb2VzIG5vdCBoYW5kbGUgY29tbWVudHNcbiAgICAgICAgICByZXR1cm4gY3NzVGV4dC5yZXBsYWNlKF9jc3NDb250ZW50UnVsZVJlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciBtID0gW107XG4gICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICBtW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBydWxlID0gbVswXS5yZXBsYWNlKG1bMV0sICcnKS5yZXBsYWNlKG1bMl0sICcnKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG1bNF0gKyBydWxlO1xuICAgICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIC8qIEVuc3VyZSBzdHlsZXMgYXJlIHNjb3BlZC4gUHNldWRvLXNjb3BpbmcgdGFrZXMgYSBydWxlIGxpa2U6XG4gICAgICAgKlxuICAgICAgICogIC5mb28gey4uLiB9XG4gICAgICAgKlxuICAgICAgICogIGFuZCBjb252ZXJ0cyB0aGlzIHRvXG4gICAgICAgKlxuICAgICAgICogIHNjb3BlTmFtZSAuZm9vIHsgLi4uIH1cbiAgICAgICovXG4gICAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9zY29wZUNzc1RleHQgPSBmdW5jdGlvbiAoY3NzVGV4dCwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yKSB7XG4gICAgICAgICAgdmFyIHVuc2NvcGVkUnVsZXMgPSB0aGlzLl9leHRyYWN0VW5zY29wZWRSdWxlc0Zyb21Dc3NUZXh0KGNzc1RleHQpO1xuICAgICAgICAgIC8vIHJlcGxhY2UgOmhvc3QgYW5kIDpob3N0LWNvbnRleHQgLXNoYWRvd2Nzc2hvc3QgYW5kIC1zaGFkb3djc3Nob3N0IHJlc3BlY3RpdmVseVxuICAgICAgICAgIGNzc1RleHQgPSB0aGlzLl9pbnNlcnRQb2x5ZmlsbEhvc3RJbkNzc1RleHQoY3NzVGV4dCk7XG4gICAgICAgICAgY3NzVGV4dCA9IHRoaXMuX2NvbnZlcnRDb2xvbkhvc3QoY3NzVGV4dCk7XG4gICAgICAgICAgY3NzVGV4dCA9IHRoaXMuX2NvbnZlcnRDb2xvbkhvc3RDb250ZXh0KGNzc1RleHQpO1xuICAgICAgICAgIGNzc1RleHQgPSB0aGlzLl9jb252ZXJ0U2hhZG93RE9NU2VsZWN0b3JzKGNzc1RleHQpO1xuICAgICAgICAgIGlmIChzY29wZVNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgIGNzc1RleHQgPSB0aGlzLl9zY29wZVNlbGVjdG9ycyhjc3NUZXh0LCBzY29wZVNlbGVjdG9yLCBob3N0U2VsZWN0b3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjc3NUZXh0ID0gY3NzVGV4dCArICdcXG4nICsgdW5zY29wZWRSdWxlcztcbiAgICAgICAgICByZXR1cm4gY3NzVGV4dC50cmltKCk7XG4gICAgICB9O1xuICAgICAgLypcbiAgICAgICAqIFByb2Nlc3Mgc3R5bGVzIHRvIGFkZCBydWxlcyB3aGljaCB3aWxsIG9ubHkgYXBwbHkgdW5kZXIgdGhlIHBvbHlmaWxsXG4gICAgICAgKiBhbmQgZG8gbm90IHByb2Nlc3MgdmlhIENTU09NLiAoQ1NTT00gaXMgZGVzdHJ1Y3RpdmUgdG8gcnVsZXMgb24gcmFyZVxuICAgICAgICogb2NjYXNpb25zLCBlLmcuIC13ZWJraXQtY2FsYyBvbiBTYWZhcmkuKVxuICAgICAgICogRm9yIGV4YW1wbGUsIHdlIGNvbnZlcnQgdGhpcyBydWxlOlxuICAgICAgICpcbiAgICAgICAqIEBwb2x5ZmlsbC11bnNjb3BlZC1ydWxlIHtcbiAgICAgICAqICAgY29udGVudDogJ21lbnUtaXRlbSc7XG4gICAgICAgKiAuLi4gfVxuICAgICAgICpcbiAgICAgICAqIHRvIHRoaXM6XG4gICAgICAgKlxuICAgICAgICogbWVudS1pdGVtIHsuLi59XG4gICAgICAgKlxuICAgICAgKiovXG4gICAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9leHRyYWN0VW5zY29wZWRSdWxlc0Zyb21Dc3NUZXh0ID0gZnVuY3Rpb24gKGNzc1RleHQpIHtcbiAgICAgICAgICAvLyBEaWZmZXJlbmNlIHdpdGggd2ViY29tcG9uZW50cy5qczogZG9lcyBub3QgaGFuZGxlIGNvbW1lbnRzXG4gICAgICAgICAgdmFyIHIgPSAnJztcbiAgICAgICAgICB2YXIgbTtcbiAgICAgICAgICBfY3NzQ29udGVudFVuc2NvcGVkUnVsZVJlLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgd2hpbGUgKChtID0gX2Nzc0NvbnRlbnRVbnNjb3BlZFJ1bGVSZS5leGVjKGNzc1RleHQpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB2YXIgcnVsZSA9IG1bMF0ucmVwbGFjZShtWzJdLCAnJykucmVwbGFjZShtWzFdLCBtWzRdKTtcbiAgICAgICAgICAgICAgciArPSBydWxlICsgJ1xcblxcbic7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByO1xuICAgICAgfTtcbiAgICAgIC8qXG4gICAgICAgKiBjb252ZXJ0IGEgcnVsZSBsaWtlIDpob3N0KC5mb28pID4gLmJhciB7IH1cbiAgICAgICAqXG4gICAgICAgKiB0b1xuICAgICAgICpcbiAgICAgICAqIC5mb288c2NvcGVOYW1lPiA+IC5iYXJcbiAgICAgICovXG4gICAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9jb252ZXJ0Q29sb25Ib3N0ID0gZnVuY3Rpb24gKGNzc1RleHQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fY29udmVydENvbG9uUnVsZShjc3NUZXh0LCBfY3NzQ29sb25Ib3N0UmUsIHRoaXMuX2NvbG9uSG9zdFBhcnRSZXBsYWNlcik7XG4gICAgICB9O1xuICAgICAgLypcbiAgICAgICAqIGNvbnZlcnQgYSBydWxlIGxpa2UgOmhvc3QtY29udGV4dCguZm9vKSA+IC5iYXIgeyB9XG4gICAgICAgKlxuICAgICAgICogdG9cbiAgICAgICAqXG4gICAgICAgKiAuZm9vPHNjb3BlTmFtZT4gPiAuYmFyLCAuZm9vIHNjb3BlTmFtZSA+IC5iYXIgeyB9XG4gICAgICAgKlxuICAgICAgICogYW5kXG4gICAgICAgKlxuICAgICAgICogOmhvc3QtY29udGV4dCguZm9vOmhvc3QpIC5iYXIgeyAuLi4gfVxuICAgICAgICpcbiAgICAgICAqIHRvXG4gICAgICAgKlxuICAgICAgICogLmZvbzxzY29wZU5hbWU+IC5iYXIgeyAuLi4gfVxuICAgICAgKi9cbiAgICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX2NvbnZlcnRDb2xvbkhvc3RDb250ZXh0ID0gZnVuY3Rpb24gKGNzc1RleHQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fY29udmVydENvbG9uUnVsZShjc3NUZXh0LCBfY3NzQ29sb25Ib3N0Q29udGV4dFJlLCB0aGlzLl9jb2xvbkhvc3RDb250ZXh0UGFydFJlcGxhY2VyKTtcbiAgICAgIH07XG4gICAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9jb252ZXJ0Q29sb25SdWxlID0gZnVuY3Rpb24gKGNzc1RleHQsIHJlZ0V4cCwgcGFydFJlcGxhY2VyKSB7XG4gICAgICAgICAgLy8gbVsxXSA9IDpob3N0KC1jb250ZXh0KSwgbVsyXSA9IGNvbnRlbnRzIG9mICgpLCBtWzNdIHJlc3Qgb2YgcnVsZVxuICAgICAgICAgIHJldHVybiBjc3NUZXh0LnJlcGxhY2UocmVnRXhwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciBtID0gW107XG4gICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICBtW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChtWzJdKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcGFydHMgPSBtWzJdLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICAgICAgICB2YXIgciA9IFtdO1xuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0gcGFydHNbaV0udHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICAgIGlmICghcClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgci5wdXNoKHBhcnRSZXBsYWNlcihfcG9seWZpbGxIb3N0Tm9Db21iaW5hdG9yLCBwLCBtWzNdKSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXR1cm4gci5qb2luKCcsJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX3BvbHlmaWxsSG9zdE5vQ29tYmluYXRvciArIG1bM107XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9jb2xvbkhvc3RDb250ZXh0UGFydFJlcGxhY2VyID0gZnVuY3Rpb24gKGhvc3QsIHBhcnQsIHN1ZmZpeCkge1xuICAgICAgICAgIGlmIChwYXJ0LmluZGV4T2YoX3BvbHlmaWxsSG9zdCkgPiAtMSkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY29sb25Ib3N0UGFydFJlcGxhY2VyKGhvc3QsIHBhcnQsIHN1ZmZpeCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gaG9zdCArIHBhcnQgKyBzdWZmaXggKyAnLCAnICsgcGFydCArICcgJyArIGhvc3QgKyBzdWZmaXg7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX2NvbG9uSG9zdFBhcnRSZXBsYWNlciA9IGZ1bmN0aW9uIChob3N0LCBwYXJ0LCBzdWZmaXgpIHtcbiAgICAgICAgICByZXR1cm4gaG9zdCArIHBhcnQucmVwbGFjZShfcG9seWZpbGxIb3N0LCAnJykgKyBzdWZmaXg7XG4gICAgICB9O1xuICAgICAgLypcbiAgICAgICAqIENvbnZlcnQgY29tYmluYXRvcnMgbGlrZSA6OnNoYWRvdyBhbmQgcHNldWRvLWVsZW1lbnRzIGxpa2UgOjpjb250ZW50XG4gICAgICAgKiBieSByZXBsYWNpbmcgd2l0aCBzcGFjZS5cbiAgICAgICovXG4gICAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9jb252ZXJ0U2hhZG93RE9NU2VsZWN0b3JzID0gZnVuY3Rpb24gKGNzc1RleHQpIHtcbiAgICAgICAgICByZXR1cm4gX3NoYWRvd0RPTVNlbGVjdG9yc1JlLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBwYXR0ZXJuKSB7IHJldHVybiByZXN1bHQucmVwbGFjZShwYXR0ZXJuLCAnICcpOyB9LCBjc3NUZXh0KTtcbiAgICAgIH07XG4gICAgICAvLyBjaGFuZ2UgYSBzZWxlY3RvciBsaWtlICdkaXYnIHRvICduYW1lIGRpdidcbiAgICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX3Njb3BlU2VsZWN0b3JzID0gZnVuY3Rpb24gKGNzc1RleHQsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3Rvcikge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgcmV0dXJuIHByb2Nlc3NSdWxlcyhjc3NUZXh0LCBmdW5jdGlvbiAocnVsZSkge1xuICAgICAgICAgICAgICB2YXIgc2VsZWN0b3IgPSBydWxlLnNlbGVjdG9yO1xuICAgICAgICAgICAgICB2YXIgY29udGVudCA9IHJ1bGUuY29udGVudDtcbiAgICAgICAgICAgICAgaWYgKHJ1bGUuc2VsZWN0b3JbMF0gIT0gJ0AnKSB7XG4gICAgICAgICAgICAgICAgICBzZWxlY3RvciA9XG4gICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3Njb3BlU2VsZWN0b3IocnVsZS5zZWxlY3Rvciwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yLCBfdGhpcy5zdHJpY3RTdHlsaW5nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmIChydWxlLnNlbGVjdG9yLnN0YXJ0c1dpdGgoJ0BtZWRpYScpIHx8IHJ1bGUuc2VsZWN0b3Iuc3RhcnRzV2l0aCgnQHN1cHBvcnRzJykgfHxcbiAgICAgICAgICAgICAgICAgIHJ1bGUuc2VsZWN0b3Iuc3RhcnRzV2l0aCgnQHBhZ2UnKSB8fCBydWxlLnNlbGVjdG9yLnN0YXJ0c1dpdGgoJ0Bkb2N1bWVudCcpKSB7XG4gICAgICAgICAgICAgICAgICBjb250ZW50ID0gX3RoaXMuX3Njb3BlU2VsZWN0b3JzKHJ1bGUuY29udGVudCwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gbmV3IENzc1J1bGUoc2VsZWN0b3IsIGNvbnRlbnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX3Njb3BlU2VsZWN0b3IgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3Rvciwgc3RyaWN0KSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICByZXR1cm4gc2VsZWN0b3Iuc3BsaXQoJywnKVxuICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChwYXJ0KSB7IHJldHVybiBwYXJ0LnRyaW0oKS5zcGxpdChfc2hhZG93RGVlcFNlbGVjdG9ycyk7IH0pXG4gICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGRlZXBQYXJ0cykge1xuICAgICAgICAgICAgICB2YXIgc2hhbGxvd1BhcnQgPSBkZWVwUGFydHNbMF0sIG90aGVyUGFydHMgPSBkZWVwUGFydHMuc2xpY2UoMSk7XG4gICAgICAgICAgICAgIHZhciBhcHBseVNjb3BlID0gZnVuY3Rpb24gKHNoYWxsb3dQYXJ0KSB7XG4gICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX3NlbGVjdG9yTmVlZHNTY29waW5nKHNoYWxsb3dQYXJ0LCBzY29wZVNlbGVjdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJpY3QgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYXBwbHlTdHJpY3RTZWxlY3RvclNjb3BlKHNoYWxsb3dQYXJ0LCBzY29wZVNlbGVjdG9yLCBob3N0U2VsZWN0b3IpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2FwcGx5U2VsZWN0b3JTY29wZShzaGFsbG93UGFydCwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzaGFsbG93UGFydDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgcmV0dXJuIFthcHBseVNjb3BlKHNoYWxsb3dQYXJ0KV0uY29uY2F0KG90aGVyUGFydHMpLmpvaW4oJyAnKTtcbiAgICAgICAgICB9KVxuICAgICAgICAgICAgICAuam9pbignLCAnKTtcbiAgICAgIH07XG4gICAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9zZWxlY3Rvck5lZWRzU2NvcGluZyA9IGZ1bmN0aW9uIChzZWxlY3Rvciwgc2NvcGVTZWxlY3Rvcikge1xuICAgICAgICAgIHZhciByZSA9IHRoaXMuX21ha2VTY29wZU1hdGNoZXIoc2NvcGVTZWxlY3Rvcik7XG4gICAgICAgICAgcmV0dXJuICFyZS50ZXN0KHNlbGVjdG9yKTtcbiAgICAgIH07XG4gICAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9tYWtlU2NvcGVNYXRjaGVyID0gZnVuY3Rpb24gKHNjb3BlU2VsZWN0b3IpIHtcbiAgICAgICAgICB2YXIgbHJlID0gL1xcWy9nO1xuICAgICAgICAgIHZhciBycmUgPSAvXFxdL2c7XG4gICAgICAgICAgc2NvcGVTZWxlY3RvciA9IHNjb3BlU2VsZWN0b3IucmVwbGFjZShscmUsICdcXFxcWycpLnJlcGxhY2UocnJlLCAnXFxcXF0nKTtcbiAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cCgnXignICsgc2NvcGVTZWxlY3RvciArICcpJyArIF9zZWxlY3RvclJlU3VmZml4LCAnbScpO1xuICAgICAgfTtcbiAgICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX2FwcGx5U2VsZWN0b3JTY29wZSA9IGZ1bmN0aW9uIChzZWxlY3Rvciwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yKSB7XG4gICAgICAgICAgLy8gRGlmZmVyZW5jZSBmcm9tIHdlYmNvbXBvbmVudHMuanM6IHNjb3BlU2VsZWN0b3IgY291bGQgbm90IGJlIGFuIGFycmF5XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5U2ltcGxlU2VsZWN0b3JTY29wZShzZWxlY3Rvciwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yKTtcbiAgICAgIH07XG4gICAgICAvLyBzY29wZSB2aWEgbmFtZSBhbmQgW2lzPW5hbWVdXG4gICAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9hcHBseVNpbXBsZVNlbGVjdG9yU2NvcGUgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3Rvcikge1xuICAgICAgICAgIC8vIEluIEFuZHJvaWQgYnJvd3NlciwgdGhlIGxhc3RJbmRleCBpcyBub3QgcmVzZXQgd2hlbiB0aGUgcmVnZXggaXMgdXNlZCBpbiBTdHJpbmcucmVwbGFjZSgpXG4gICAgICAgICAgX3BvbHlmaWxsSG9zdFJlLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgaWYgKF9wb2x5ZmlsbEhvc3RSZS50ZXN0KHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgICB2YXIgcmVwbGFjZUJ5XzEgPSB0aGlzLnN0cmljdFN0eWxpbmcgPyBcIltcIiArIGhvc3RTZWxlY3RvciArIFwiXVwiIDogc2NvcGVTZWxlY3RvcjtcbiAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdG9yXG4gICAgICAgICAgICAgICAgICAucmVwbGFjZShfcG9seWZpbGxIb3N0Tm9Db21iaW5hdG9yUmUsIGZ1bmN0aW9uIChobmMsIHNlbGVjdG9yKSB7IHJldHVybiBzZWxlY3RvclswXSA9PT0gJzonID8gcmVwbGFjZUJ5XzEgKyBzZWxlY3RvciA6IHNlbGVjdG9yICsgcmVwbGFjZUJ5XzE7IH0pXG4gICAgICAgICAgICAgICAgICAucmVwbGFjZShfcG9seWZpbGxIb3N0UmUsIHJlcGxhY2VCeV8xICsgJyAnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHNjb3BlU2VsZWN0b3IgKyAnICcgKyBzZWxlY3RvcjtcbiAgICAgIH07XG4gICAgICAvLyByZXR1cm4gYSBzZWxlY3RvciB3aXRoIFtuYW1lXSBzdWZmaXggb24gZWFjaCBzaW1wbGUgc2VsZWN0b3JcbiAgICAgIC8vIGUuZy4gLmZvby5iYXIgPiAuem90IGJlY29tZXMgLmZvb1tuYW1lXS5iYXJbbmFtZV0gPiAuem90W25hbWVdICAvKiogQGludGVybmFsICovXG4gICAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9hcHBseVN0cmljdFNlbGVjdG9yU2NvcGUgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3Rvcikge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIGlzUmUgPSAvXFxbaXM9KFteXFxdXSopXFxdL2c7XG4gICAgICAgICAgc2NvcGVTZWxlY3RvciA9IHNjb3BlU2VsZWN0b3IucmVwbGFjZShpc1JlLCBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgICB2YXIgcGFydHMgPSBbXTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgIHBhcnRzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBwYXJ0c1swXTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgYXR0ck5hbWUgPSAnWycgKyBzY29wZVNlbGVjdG9yICsgJ10nO1xuICAgICAgICAgIHZhciBfc2NvcGVTZWxlY3RvclBhcnQgPSBmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgICB2YXIgc2NvcGVkUCA9IHAudHJpbSgpO1xuICAgICAgICAgICAgICBpZiAoIXNjb3BlZFApIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocC5pbmRleE9mKF9wb2x5ZmlsbEhvc3ROb0NvbWJpbmF0b3IpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgIHNjb3BlZFAgPSBfdGhpcy5fYXBwbHlTaW1wbGVTZWxlY3RvclNjb3BlKHAsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3Rvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvLyByZW1vdmUgOmhvc3Qgc2luY2UgaXQgc2hvdWxkIGJlIHVubmVjZXNzYXJ5XG4gICAgICAgICAgICAgICAgICB2YXIgdCA9IHAucmVwbGFjZShfcG9seWZpbGxIb3N0UmUsICcnKTtcbiAgICAgICAgICAgICAgICAgIGlmICh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IHQubWF0Y2goLyhbXjpdKikoOiopKC4qKS8pO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlZFAgPSBtYXRjaGVzWzFdICsgYXR0ck5hbWUgKyBtYXRjaGVzWzJdICsgbWF0Y2hlc1szXTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHNjb3BlZFA7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgYXR0clNlbGVjdG9ySW5kZXggPSAwO1xuICAgICAgICAgIHZhciBhdHRyU2VsZWN0b3JzID0gW107XG4gICAgICAgICAgLy8gcmVwbGFjZSBhdHRyaWJ1dGUgc2VsZWN0b3JzIHdpdGggcGxhY2Vob2xkZXJzIHRvIGF2b2lkIGlzc3VlIHdpdGggd2hpdGUgc3BhY2UgYmVpbmcgdHJlYXRlZFxuICAgICAgICAgIC8vIGFzIHNlcGFyYXRvclxuICAgICAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3IucmVwbGFjZSgvXFxbW15cXF1dKlxcXS9nLCBmdW5jdGlvbiAoYXR0clNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgIHZhciByZXBsYWNlQnkgPSBcIl9fYXR0cl9zZWxfXCIgKyBhdHRyU2VsZWN0b3JJbmRleCArIFwiX19cIjtcbiAgICAgICAgICAgICAgYXR0clNlbGVjdG9ycy5wdXNoKGF0dHJTZWxlY3Rvcik7XG4gICAgICAgICAgICAgIGF0dHJTZWxlY3RvckluZGV4Kys7XG4gICAgICAgICAgICAgIHJldHVybiByZXBsYWNlQnk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIHNjb3BlZFNlbGVjdG9yID0gJyc7XG4gICAgICAgICAgdmFyIHN0YXJ0SW5kZXggPSAwO1xuICAgICAgICAgIHZhciByZXM7XG4gICAgICAgICAgdmFyIHNlcCA9IC8oIHw+fFxcK3x+KD8hPSkpXFxzKi9nO1xuICAgICAgICAgIHZhciBzY29wZUFmdGVyID0gc2VsZWN0b3IuaW5kZXhPZihfcG9seWZpbGxIb3N0Tm9Db21iaW5hdG9yKTtcbiAgICAgICAgICB3aGlsZSAoKHJlcyA9IHNlcC5leGVjKHNlbGVjdG9yKSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdmFyIHNlcGFyYXRvciA9IHJlc1sxXTtcbiAgICAgICAgICAgICAgdmFyIHBhcnQgPSBzZWxlY3Rvci5zbGljZShzdGFydEluZGV4LCByZXMuaW5kZXgpLnRyaW0oKTtcbiAgICAgICAgICAgICAgLy8gaWYgYSBzZWxlY3RvciBhcHBlYXJzIGJlZm9yZSA6aG9zdC1jb250ZXh0IGl0IHNob3VsZCBub3QgYmUgc2hpbW1lZCBhcyBpdFxuICAgICAgICAgICAgICAvLyBtYXRjaGVzIG9uIGFuY2VzdG9yIGVsZW1lbnRzIGFuZCBub3Qgb24gZWxlbWVudHMgaW4gdGhlIGhvc3QncyBzaGFkb3dcbiAgICAgICAgICAgICAgdmFyIHNjb3BlZFBhcnQgPSBzdGFydEluZGV4ID49IHNjb3BlQWZ0ZXIgPyBfc2NvcGVTZWxlY3RvclBhcnQocGFydCkgOiBwYXJ0O1xuICAgICAgICAgICAgICBzY29wZWRTZWxlY3RvciArPSBzY29wZWRQYXJ0ICsgXCIgXCIgKyBzZXBhcmF0b3IgKyBcIiBcIjtcbiAgICAgICAgICAgICAgc3RhcnRJbmRleCA9IHNlcC5sYXN0SW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNjb3BlZFNlbGVjdG9yICs9IF9zY29wZVNlbGVjdG9yUGFydChzZWxlY3Rvci5zdWJzdHJpbmcoc3RhcnRJbmRleCkpO1xuICAgICAgICAgIC8vIHJlcGxhY2UgdGhlIHBsYWNlaG9sZGVycyB3aXRoIHRoZWlyIG9yaWdpbmFsIHZhbHVlc1xuICAgICAgICAgIHJldHVybiBzY29wZWRTZWxlY3Rvci5yZXBsYWNlKC9fX2F0dHJfc2VsXyhcXGQrKV9fL2csIGZ1bmN0aW9uIChwaCwgaW5kZXgpIHsgcmV0dXJuIGF0dHJTZWxlY3RvcnNbK2luZGV4XTsgfSk7XG4gICAgICB9O1xuICAgICAgU2hhZG93Q3NzLnByb3RvdHlwZS5faW5zZXJ0UG9seWZpbGxIb3N0SW5Dc3NUZXh0ID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGVjdG9yLnJlcGxhY2UoX2NvbG9uSG9zdENvbnRleHRSZSwgX3BvbHlmaWxsSG9zdENvbnRleHQpXG4gICAgICAgICAgICAgIC5yZXBsYWNlKF9jb2xvbkhvc3RSZSwgX3BvbHlmaWxsSG9zdCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFNoYWRvd0NzcztcbiAgfSgpKTtcbiAgdmFyIF9jc3NDb250ZW50TmV4dFNlbGVjdG9yUmUgPSAvcG9seWZpbGwtbmV4dC1zZWxlY3RvcltefV0qY29udGVudDpbXFxzXSo/KFsnXCJdKSguKj8pXFwxWztcXHNdKn0oW157XSo/KXsvZ2ltO1xuICB2YXIgX2Nzc0NvbnRlbnRSdWxlUmUgPSAvKHBvbHlmaWxsLXJ1bGUpW159XSooY29udGVudDpbXFxzXSooWydcIl0pKC4qPylcXDMpWztcXHNdKltefV0qfS9naW07XG4gIHZhciBfY3NzQ29udGVudFVuc2NvcGVkUnVsZVJlID0gLyhwb2x5ZmlsbC11bnNjb3BlZC1ydWxlKVtefV0qKGNvbnRlbnQ6W1xcc10qKFsnXCJdKSguKj8pXFwzKVs7XFxzXSpbXn1dKn0vZ2ltO1xuICB2YXIgX3BvbHlmaWxsSG9zdCA9ICctc2hhZG93Y3NzaG9zdCc7XG4gIC8vIG5vdGU6IDpob3N0LWNvbnRleHQgcHJlLXByb2Nlc3NlZCB0byAtc2hhZG93Y3NzaG9zdGNvbnRleHQuXG4gIHZhciBfcG9seWZpbGxIb3N0Q29udGV4dCA9ICctc2hhZG93Y3NzY29udGV4dCc7XG4gIHZhciBfcGFyZW5TdWZmaXggPSAnKSg/OlxcXFwoKCcgK1xuICAgICAgJyg/OlxcXFwoW14pKF0qXFxcXCl8W14pKF0qKSs/JyArXG4gICAgICAnKVxcXFwpKT8oW14se10qKSc7XG4gIHZhciBfY3NzQ29sb25Ib3N0UmUgPSBuZXcgUmVnRXhwKCcoJyArIF9wb2x5ZmlsbEhvc3QgKyBfcGFyZW5TdWZmaXgsICdnaW0nKTtcbiAgdmFyIF9jc3NDb2xvbkhvc3RDb250ZXh0UmUgPSBuZXcgUmVnRXhwKCcoJyArIF9wb2x5ZmlsbEhvc3RDb250ZXh0ICsgX3BhcmVuU3VmZml4LCAnZ2ltJyk7XG4gIHZhciBfcG9seWZpbGxIb3N0Tm9Db21iaW5hdG9yID0gX3BvbHlmaWxsSG9zdCArICctbm8tY29tYmluYXRvcic7XG4gIHZhciBfcG9seWZpbGxIb3N0Tm9Db21iaW5hdG9yUmUgPSAvLXNoYWRvd2Nzc2hvc3Qtbm8tY29tYmluYXRvcihbXlxcc10qKS87XG4gIHZhciBfc2hhZG93RE9NU2VsZWN0b3JzUmUgPSBbXG4gICAgICAvOjpzaGFkb3cvZyxcbiAgICAgIC86OmNvbnRlbnQvZyxcbiAgICAgIC8vIERlcHJlY2F0ZWQgc2VsZWN0b3JzXG4gICAgICAvXFwvc2hhZG93LWRlZXBcXC8vZyxcbiAgICAgIC9cXC9zaGFkb3dcXC8vZyxcbiAgXTtcbiAgdmFyIF9zaGFkb3dEZWVwU2VsZWN0b3JzID0gLyg/Oj4+Pil8KD86XFwvZGVlcFxcLykvZztcbiAgdmFyIF9zZWxlY3RvclJlU3VmZml4ID0gJyhbPlxcXFxzfitcXFsuLHs6XVtcXFxcc1xcXFxTXSopPyQnO1xuICB2YXIgX3BvbHlmaWxsSG9zdFJlID0gLy1zaGFkb3djc3Nob3N0L2dpbTtcbiAgdmFyIF9jb2xvbkhvc3RSZSA9IC86aG9zdC9naW07XG4gIHZhciBfY29sb25Ib3N0Q29udGV4dFJlID0gLzpob3N0LWNvbnRleHQvZ2ltO1xuICB2YXIgX2NvbW1lbnRSZSA9IC9cXC9cXCpcXHMqW1xcc1xcU10qP1xcKlxcLy9nO1xuICBmdW5jdGlvbiBzdHJpcENvbW1lbnRzKGlucHV0KSB7XG4gICAgICByZXR1cm4gaW5wdXQucmVwbGFjZShfY29tbWVudFJlLCAnJyk7XG4gIH1cbiAgLy8gYWxsIGNvbW1lbnRzIGV4Y2VwdCBpbmxpbmUgc291cmNlIG1hcHBpbmdcbiAgdmFyIF9zb3VyY2VNYXBwaW5nVXJsUmUgPSAvXFwvXFwqXFxzKiNcXHMqc291cmNlTWFwcGluZ1VSTD1bXFxzXFxTXSs/XFwqXFwvLztcbiAgZnVuY3Rpb24gZXh0cmFjdFNvdXJjZU1hcHBpbmdVcmwoaW5wdXQpIHtcbiAgICAgIHZhciBtYXRjaGVyID0gaW5wdXQubWF0Y2goX3NvdXJjZU1hcHBpbmdVcmxSZSk7XG4gICAgICByZXR1cm4gbWF0Y2hlciA/IG1hdGNoZXJbMF0gOiAnJztcbiAgfVxuICB2YXIgX3J1bGVSZSA9IC8oXFxzKikoW147XFx7XFx9XSs/KShcXHMqKSgoPzp7JUJMT0NLJX0/XFxzKjs/KXwoPzpcXHMqOykpL2c7XG4gIHZhciBfY3VybHlSZSA9IC8oW3t9XSkvZztcbiAgdmFyIE9QRU5fQ1VSTFkgPSAneyc7XG4gIHZhciBDTE9TRV9DVVJMWSA9ICd9JztcbiAgdmFyIEJMT0NLX1BMQUNFSE9MREVSID0gJyVCTE9DSyUnO1xuICB2YXIgQ3NzUnVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBDc3NSdWxlKHNlbGVjdG9yLCBjb250ZW50KSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgICAgICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gQ3NzUnVsZTtcbiAgfSgpKTtcbiAgZnVuY3Rpb24gcHJvY2Vzc1J1bGVzKGlucHV0LCBydWxlQ2FsbGJhY2spIHtcbiAgICAgIHZhciBpbnB1dFdpdGhFc2NhcGVkQmxvY2tzID0gZXNjYXBlQmxvY2tzKGlucHV0KTtcbiAgICAgIHZhciBuZXh0QmxvY2tJbmRleCA9IDA7XG4gICAgICByZXR1cm4gaW5wdXRXaXRoRXNjYXBlZEJsb2Nrcy5lc2NhcGVkU3RyaW5nLnJlcGxhY2UoX3J1bGVSZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBtID0gW107XG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgbVtfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHNlbGVjdG9yID0gbVsyXTtcbiAgICAgICAgICB2YXIgY29udGVudCA9ICcnO1xuICAgICAgICAgIHZhciBzdWZmaXggPSBtWzRdO1xuICAgICAgICAgIHZhciBjb250ZW50UHJlZml4ID0gJyc7XG4gICAgICAgICAgaWYgKHN1ZmZpeCAmJiBzdWZmaXguc3RhcnRzV2l0aCgneycgKyBCTE9DS19QTEFDRUhPTERFUikpIHtcbiAgICAgICAgICAgICAgY29udGVudCA9IGlucHV0V2l0aEVzY2FwZWRCbG9ja3MuYmxvY2tzW25leHRCbG9ja0luZGV4KytdO1xuICAgICAgICAgICAgICBzdWZmaXggPSBzdWZmaXguc3Vic3RyaW5nKEJMT0NLX1BMQUNFSE9MREVSLmxlbmd0aCArIDEpO1xuICAgICAgICAgICAgICBjb250ZW50UHJlZml4ID0gJ3snO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcnVsZSA9IHJ1bGVDYWxsYmFjayhuZXcgQ3NzUnVsZShzZWxlY3RvciwgY29udGVudCkpO1xuICAgICAgICAgIHJldHVybiBcIlwiICsgbVsxXSArIHJ1bGUuc2VsZWN0b3IgKyBtWzNdICsgY29udGVudFByZWZpeCArIHJ1bGUuY29udGVudCArIHN1ZmZpeDtcbiAgICAgIH0pO1xuICB9XG4gIHZhciBTdHJpbmdXaXRoRXNjYXBlZEJsb2NrcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBTdHJpbmdXaXRoRXNjYXBlZEJsb2Nrcyhlc2NhcGVkU3RyaW5nLCBibG9ja3MpIHtcbiAgICAgICAgICB0aGlzLmVzY2FwZWRTdHJpbmcgPSBlc2NhcGVkU3RyaW5nO1xuICAgICAgICAgIHRoaXMuYmxvY2tzID0gYmxvY2tzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFN0cmluZ1dpdGhFc2NhcGVkQmxvY2tzO1xuICB9KCkpO1xuICBmdW5jdGlvbiBlc2NhcGVCbG9ja3MoaW5wdXQpIHtcbiAgICAgIHZhciBpbnB1dFBhcnRzID0gaW5wdXQuc3BsaXQoX2N1cmx5UmUpO1xuICAgICAgdmFyIHJlc3VsdFBhcnRzID0gW107XG4gICAgICB2YXIgZXNjYXBlZEJsb2NrcyA9IFtdO1xuICAgICAgdmFyIGJyYWNrZXRDb3VudCA9IDA7XG4gICAgICB2YXIgY3VycmVudEJsb2NrUGFydHMgPSBbXTtcbiAgICAgIGZvciAodmFyIHBhcnRJbmRleCA9IDA7IHBhcnRJbmRleCA8IGlucHV0UGFydHMubGVuZ3RoOyBwYXJ0SW5kZXgrKykge1xuICAgICAgICAgIHZhciBwYXJ0ID0gaW5wdXRQYXJ0c1twYXJ0SW5kZXhdO1xuICAgICAgICAgIGlmIChwYXJ0ID09IENMT1NFX0NVUkxZKSB7XG4gICAgICAgICAgICAgIGJyYWNrZXRDb3VudC0tO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYnJhY2tldENvdW50ID4gMCkge1xuICAgICAgICAgICAgICBjdXJyZW50QmxvY2tQYXJ0cy5wdXNoKHBhcnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGN1cnJlbnRCbG9ja1BhcnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIGVzY2FwZWRCbG9ja3MucHVzaChjdXJyZW50QmxvY2tQYXJ0cy5qb2luKCcnKSk7XG4gICAgICAgICAgICAgICAgICByZXN1bHRQYXJ0cy5wdXNoKEJMT0NLX1BMQUNFSE9MREVSKTtcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRCbG9ja1BhcnRzID0gW107XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzdWx0UGFydHMucHVzaChwYXJ0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHBhcnQgPT0gT1BFTl9DVVJMWSkge1xuICAgICAgICAgICAgICBicmFja2V0Q291bnQrKztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudEJsb2NrUGFydHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGVzY2FwZWRCbG9ja3MucHVzaChjdXJyZW50QmxvY2tQYXJ0cy5qb2luKCcnKSk7XG4gICAgICAgICAgcmVzdWx0UGFydHMucHVzaChCTE9DS19QTEFDRUhPTERFUik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFN0cmluZ1dpdGhFc2NhcGVkQmxvY2tzKHJlc3VsdFBhcnRzLmpvaW4oJycpLCBlc2NhcGVkQmxvY2tzKTtcbiAgfVxuXG4gIHZhciBDT01QT05FTlRfVkFSSUFCTEUgPSAnJUNPTVAlJztcbiAgdmFyIEhPU1RfQVRUUiA9IFwiX25naG9zdC1cIiArIENPTVBPTkVOVF9WQVJJQUJMRTtcbiAgdmFyIENPTlRFTlRfQVRUUiA9IFwiX25nY29udGVudC1cIiArIENPTVBPTkVOVF9WQVJJQUJMRTtcbiAgdmFyIFN0eWxlc0NvbXBpbGVEZXBlbmRlbmN5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFN0eWxlc0NvbXBpbGVEZXBlbmRlbmN5KG1vZHVsZVVybCwgaXNTaGltbWVkLCB2YWx1ZVBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgdGhpcy5tb2R1bGVVcmwgPSBtb2R1bGVVcmw7XG4gICAgICAgICAgdGhpcy5pc1NoaW1tZWQgPSBpc1NoaW1tZWQ7XG4gICAgICAgICAgdGhpcy52YWx1ZVBsYWNlaG9sZGVyID0gdmFsdWVQbGFjZWhvbGRlcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBTdHlsZXNDb21waWxlRGVwZW5kZW5jeTtcbiAgfSgpKTtcbiAgdmFyIFN0eWxlc0NvbXBpbGVSZXN1bHQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gU3R5bGVzQ29tcGlsZVJlc3VsdChjb21wb25lbnRTdHlsZXNoZWV0LCBleHRlcm5hbFN0eWxlc2hlZXRzKSB7XG4gICAgICAgICAgdGhpcy5jb21wb25lbnRTdHlsZXNoZWV0ID0gY29tcG9uZW50U3R5bGVzaGVldDtcbiAgICAgICAgICB0aGlzLmV4dGVybmFsU3R5bGVzaGVldHMgPSBleHRlcm5hbFN0eWxlc2hlZXRzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFN0eWxlc0NvbXBpbGVSZXN1bHQ7XG4gIH0oKSk7XG4gIHZhciBDb21waWxlZFN0eWxlc2hlZXQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQ29tcGlsZWRTdHlsZXNoZWV0KHN0YXRlbWVudHMsIHN0eWxlc1ZhciwgZGVwZW5kZW5jaWVzLCBpc1NoaW1tZWQsIG1ldGEpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlbWVudHMgPSBzdGF0ZW1lbnRzO1xuICAgICAgICAgIHRoaXMuc3R5bGVzVmFyID0gc3R5bGVzVmFyO1xuICAgICAgICAgIHRoaXMuZGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzO1xuICAgICAgICAgIHRoaXMuaXNTaGltbWVkID0gaXNTaGltbWVkO1xuICAgICAgICAgIHRoaXMubWV0YSA9IG1ldGE7XG4gICAgICB9XG4gICAgICByZXR1cm4gQ29tcGlsZWRTdHlsZXNoZWV0O1xuICB9KCkpO1xuICB2YXIgU3R5bGVDb21waWxlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBTdHlsZUNvbXBpbGVyKF91cmxSZXNvbHZlcikge1xuICAgICAgICAgIHRoaXMuX3VybFJlc29sdmVyID0gX3VybFJlc29sdmVyO1xuICAgICAgICAgIHRoaXMuX3NoYWRvd0NzcyA9IG5ldyBTaGFkb3dDc3MoKTtcbiAgICAgIH1cbiAgICAgIFN0eWxlQ29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGVDb21wb25lbnQgPSBmdW5jdGlvbiAoY29tcCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIGV4dGVybmFsU3R5bGVzaGVldHMgPSBbXTtcbiAgICAgICAgICB2YXIgY29tcG9uZW50U3R5bGVzaGVldCA9IHRoaXMuX2NvbXBpbGVTdHlsZXMoY29tcCwgbmV3IENvbXBpbGVTdHlsZXNoZWV0TWV0YWRhdGEoe1xuICAgICAgICAgICAgICBzdHlsZXM6IGNvbXAudGVtcGxhdGUuc3R5bGVzLFxuICAgICAgICAgICAgICBzdHlsZVVybHM6IGNvbXAudGVtcGxhdGUuc3R5bGVVcmxzLFxuICAgICAgICAgICAgICBtb2R1bGVVcmw6IGNvbXAudHlwZS5tb2R1bGVVcmxcbiAgICAgICAgICB9KSwgdHJ1ZSk7XG4gICAgICAgICAgY29tcC50ZW1wbGF0ZS5leHRlcm5hbFN0eWxlc2hlZXRzLmZvckVhY2goZnVuY3Rpb24gKHN0eWxlc2hlZXRNZXRhKSB7XG4gICAgICAgICAgICAgIHZhciBjb21waWxlZFN0eWxlc2hlZXQgPSBfdGhpcy5fY29tcGlsZVN0eWxlcyhjb21wLCBzdHlsZXNoZWV0TWV0YSwgZmFsc2UpO1xuICAgICAgICAgICAgICBleHRlcm5hbFN0eWxlc2hlZXRzLnB1c2goY29tcGlsZWRTdHlsZXNoZWV0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gbmV3IFN0eWxlc0NvbXBpbGVSZXN1bHQoY29tcG9uZW50U3R5bGVzaGVldCwgZXh0ZXJuYWxTdHlsZXNoZWV0cyk7XG4gICAgICB9O1xuICAgICAgU3R5bGVDb21waWxlci5wcm90b3R5cGUuX2NvbXBpbGVTdHlsZXMgPSBmdW5jdGlvbiAoY29tcCwgc3R5bGVzaGVldCwgaXNDb21wb25lbnRTdHlsZXNoZWV0KSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgc2hpbSA9IGNvbXAudGVtcGxhdGUuZW5jYXBzdWxhdGlvbiA9PT0gX2FuZ3VsYXJfY29yZS5WaWV3RW5jYXBzdWxhdGlvbi5FbXVsYXRlZDtcbiAgICAgICAgICB2YXIgc3R5bGVFeHByZXNzaW9ucyA9IHN0eWxlc2hlZXQuc3R5bGVzLm1hcChmdW5jdGlvbiAocGxhaW5TdHlsZSkgeyByZXR1cm4gbGl0ZXJhbChfdGhpcy5fc2hpbUlmTmVlZGVkKHBsYWluU3R5bGUsIHNoaW0pKTsgfSk7XG4gICAgICAgICAgdmFyIGRlcGVuZGVuY2llcyA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzaGVldC5zdHlsZVVybHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIGlkZW50aWZpZXIgPSBuZXcgQ29tcGlsZUlkZW50aWZpZXJNZXRhZGF0YSh7IG5hbWU6IGdldFN0eWxlc1Zhck5hbWUobnVsbCkgfSk7XG4gICAgICAgICAgICAgIGRlcGVuZGVuY2llcy5wdXNoKG5ldyBTdHlsZXNDb21waWxlRGVwZW5kZW5jeShzdHlsZXNoZWV0LnN0eWxlVXJsc1tpXSwgc2hpbSwgaWRlbnRpZmllcikpO1xuICAgICAgICAgICAgICBzdHlsZUV4cHJlc3Npb25zLnB1c2gobmV3IEV4dGVybmFsRXhwcihpZGVudGlmaWVyKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHN0eWxlcyB2YXJpYWJsZSBjb250YWlucyBwbGFpbiBzdHJpbmdzIGFuZCBhcnJheXMgb2Ygb3RoZXIgc3R5bGVzIGFycmF5cyAocmVjdXJzaXZlKSxcbiAgICAgICAgICAvLyBzbyB3ZSBzZXQgaXRzIHR5cGUgdG8gZHluYW1pYy5cbiAgICAgICAgICB2YXIgc3R5bGVzVmFyID0gZ2V0U3R5bGVzVmFyTmFtZShpc0NvbXBvbmVudFN0eWxlc2hlZXQgPyBjb21wIDogbnVsbCk7XG4gICAgICAgICAgdmFyIHN0bXQgPSB2YXJpYWJsZShzdHlsZXNWYXIpXG4gICAgICAgICAgICAgIC5zZXQobGl0ZXJhbEFycihzdHlsZUV4cHJlc3Npb25zLCBuZXcgQXJyYXlUeXBlKERZTkFNSUNfVFlQRSwgW1R5cGVNb2RpZmllci5Db25zdF0pKSlcbiAgICAgICAgICAgICAgLnRvRGVjbFN0bXQobnVsbCwgW1N0bXRNb2RpZmllci5GaW5hbF0pO1xuICAgICAgICAgIHJldHVybiBuZXcgQ29tcGlsZWRTdHlsZXNoZWV0KFtzdG10XSwgc3R5bGVzVmFyLCBkZXBlbmRlbmNpZXMsIHNoaW0sIHN0eWxlc2hlZXQpO1xuICAgICAgfTtcbiAgICAgIFN0eWxlQ29tcGlsZXIucHJvdG90eXBlLl9zaGltSWZOZWVkZWQgPSBmdW5jdGlvbiAoc3R5bGUsIHNoaW0pIHtcbiAgICAgICAgICByZXR1cm4gc2hpbSA/IHRoaXMuX3NoYWRvd0Nzcy5zaGltQ3NzVGV4dChzdHlsZSwgQ09OVEVOVF9BVFRSLCBIT1NUX0FUVFIpIDogc3R5bGU7XG4gICAgICB9O1xuICAgICAgU3R5bGVDb21waWxlci5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG4gICAgICBdO1xuICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICBTdHlsZUNvbXBpbGVyLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgIHsgdHlwZTogVXJsUmVzb2x2ZXIsIH0sXG4gICAgICBdO1xuICAgICAgcmV0dXJuIFN0eWxlQ29tcGlsZXI7XG4gIH0oKSk7XG4gIGZ1bmN0aW9uIGdldFN0eWxlc1Zhck5hbWUoY29tcG9uZW50KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gXCJzdHlsZXNcIjtcbiAgICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgICAgICByZXN1bHQgKz0gXCJfXCIgKyBjb21wb25lbnQudHlwZS5uYW1lO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbiBpbnRlcm5hbCBtb2R1bGUgb2YgdGhlIEFuZ3VsYXIgY29tcGlsZXIgdGhhdCBiZWdpbnMgd2l0aCBjb21wb25lbnQgdHlwZXMsXG4gICAqIGV4dHJhY3RzIHRlbXBsYXRlcywgYW5kIGV2ZW50dWFsbHkgcHJvZHVjZXMgYSBjb21waWxlZCB2ZXJzaW9uIG9mIHRoZSBjb21wb25lbnRcbiAgICogcmVhZHkgZm9yIGxpbmtpbmcgaW50byBhbiBhcHBsaWNhdGlvbi5cbiAgICpcbiAgICogQHNlY3VyaXR5ICBXaGVuIGNvbXBpbGluZyB0ZW1wbGF0ZXMgYXQgcnVudGltZSwgeW91IG11c3QgZW5zdXJlIHRoYXQgdGhlIGVudGlyZSB0ZW1wbGF0ZSBjb21lc1xuICAgKiBmcm9tIGEgdHJ1c3RlZCBzb3VyY2UuIEF0dGFja2VyLWNvbnRyb2xsZWQgZGF0YSBpbnRyb2R1Y2VkIGJ5IGEgdGVtcGxhdGUgY291bGQgZXhwb3NlIHlvdXJcbiAgICogYXBwbGljYXRpb24gdG8gWFNTIHJpc2tzLiAgRm9yIG1vcmUgZGV0YWlsLCBzZWUgdGhlIFtTZWN1cml0eSBHdWlkZV0oaHR0cDovL2cuY28vbmcvc2VjdXJpdHkpLlxuICAgKi9cbiAgdmFyIFJ1bnRpbWVDb21waWxlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBSdW50aW1lQ29tcGlsZXIoX2luamVjdG9yLCBfbWV0YWRhdGFSZXNvbHZlciwgX3RlbXBsYXRlTm9ybWFsaXplciwgX3RlbXBsYXRlUGFyc2VyLCBfc3R5bGVDb21waWxlciwgX3ZpZXdDb21waWxlciwgX25nTW9kdWxlQ29tcGlsZXIsIF9kaXJlY3RpdmVXcmFwcGVyQ29tcGlsZXIsIF9jb21waWxlckNvbmZpZykge1xuICAgICAgICAgIHRoaXMuX2luamVjdG9yID0gX2luamVjdG9yO1xuICAgICAgICAgIHRoaXMuX21ldGFkYXRhUmVzb2x2ZXIgPSBfbWV0YWRhdGFSZXNvbHZlcjtcbiAgICAgICAgICB0aGlzLl90ZW1wbGF0ZU5vcm1hbGl6ZXIgPSBfdGVtcGxhdGVOb3JtYWxpemVyO1xuICAgICAgICAgIHRoaXMuX3RlbXBsYXRlUGFyc2VyID0gX3RlbXBsYXRlUGFyc2VyO1xuICAgICAgICAgIHRoaXMuX3N0eWxlQ29tcGlsZXIgPSBfc3R5bGVDb21waWxlcjtcbiAgICAgICAgICB0aGlzLl92aWV3Q29tcGlsZXIgPSBfdmlld0NvbXBpbGVyO1xuICAgICAgICAgIHRoaXMuX25nTW9kdWxlQ29tcGlsZXIgPSBfbmdNb2R1bGVDb21waWxlcjtcbiAgICAgICAgICB0aGlzLl9kaXJlY3RpdmVXcmFwcGVyQ29tcGlsZXIgPSBfZGlyZWN0aXZlV3JhcHBlckNvbXBpbGVyO1xuICAgICAgICAgIHRoaXMuX2NvbXBpbGVyQ29uZmlnID0gX2NvbXBpbGVyQ29uZmlnO1xuICAgICAgICAgIHRoaXMuX2NvbXBpbGVkVGVtcGxhdGVDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgICB0aGlzLl9jb21waWxlZEhvc3RUZW1wbGF0ZUNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICAgIHRoaXMuX2NvbXBpbGVkRGlyZWN0aXZlV3JhcHBlckNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICAgIHRoaXMuX2NvbXBpbGVkTmdNb2R1bGVDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgICB0aGlzLl9hbmltYXRpb25QYXJzZXIgPSBuZXcgQW5pbWF0aW9uUGFyc2VyKCk7XG4gICAgICAgICAgdGhpcy5fYW5pbWF0aW9uQ29tcGlsZXIgPSBuZXcgQW5pbWF0aW9uQ29tcGlsZXIoKTtcbiAgICAgIH1cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSdW50aW1lQ29tcGlsZXIucHJvdG90eXBlLCBcImluamVjdG9yXCIsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2luamVjdG9yOyB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIFJ1bnRpbWVDb21waWxlci5wcm90b3R5cGUuY29tcGlsZU1vZHVsZVN5bmMgPSBmdW5jdGlvbiAobW9kdWxlVHlwZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9jb21waWxlTW9kdWxlQW5kQ29tcG9uZW50cyhtb2R1bGVUeXBlLCB0cnVlKS5zeW5jUmVzdWx0O1xuICAgICAgfTtcbiAgICAgIFJ1bnRpbWVDb21waWxlci5wcm90b3R5cGUuY29tcGlsZU1vZHVsZUFzeW5jID0gZnVuY3Rpb24gKG1vZHVsZVR5cGUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fY29tcGlsZU1vZHVsZUFuZENvbXBvbmVudHMobW9kdWxlVHlwZSwgZmFsc2UpLmFzeW5jUmVzdWx0O1xuICAgICAgfTtcbiAgICAgIFJ1bnRpbWVDb21waWxlci5wcm90b3R5cGUuY29tcGlsZU1vZHVsZUFuZEFsbENvbXBvbmVudHNTeW5jID0gZnVuY3Rpb24gKG1vZHVsZVR5cGUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fY29tcGlsZU1vZHVsZUFuZEFsbENvbXBvbmVudHMobW9kdWxlVHlwZSwgdHJ1ZSkuc3luY1Jlc3VsdDtcbiAgICAgIH07XG4gICAgICBSdW50aW1lQ29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGVNb2R1bGVBbmRBbGxDb21wb25lbnRzQXN5bmMgPSBmdW5jdGlvbiAobW9kdWxlVHlwZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9jb21waWxlTW9kdWxlQW5kQWxsQ29tcG9uZW50cyhtb2R1bGVUeXBlLCBmYWxzZSkuYXN5bmNSZXN1bHQ7XG4gICAgICB9O1xuICAgICAgUnVudGltZUNvbXBpbGVyLnByb3RvdHlwZS5fY29tcGlsZU1vZHVsZUFuZENvbXBvbmVudHMgPSBmdW5jdGlvbiAobW9kdWxlVHlwZSwgaXNTeW5jKSB7XG4gICAgICAgICAgdmFyIGNvbXBvbmVudFByb21pc2UgPSB0aGlzLl9jb21waWxlQ29tcG9uZW50cyhtb2R1bGVUeXBlLCBpc1N5bmMpO1xuICAgICAgICAgIHZhciBuZ01vZHVsZUZhY3RvcnkgPSB0aGlzLl9jb21waWxlTW9kdWxlKG1vZHVsZVR5cGUpO1xuICAgICAgICAgIHJldHVybiBuZXcgU3luY0FzeW5jUmVzdWx0KG5nTW9kdWxlRmFjdG9yeSwgY29tcG9uZW50UHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5nTW9kdWxlRmFjdG9yeTsgfSkpO1xuICAgICAgfTtcbiAgICAgIFJ1bnRpbWVDb21waWxlci5wcm90b3R5cGUuX2NvbXBpbGVNb2R1bGVBbmRBbGxDb21wb25lbnRzID0gZnVuY3Rpb24gKG1vZHVsZVR5cGUsIGlzU3luYykge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIGNvbXBvbmVudFByb21pc2UgPSB0aGlzLl9jb21waWxlQ29tcG9uZW50cyhtb2R1bGVUeXBlLCBpc1N5bmMpO1xuICAgICAgICAgIHZhciBuZ01vZHVsZUZhY3RvcnkgPSB0aGlzLl9jb21waWxlTW9kdWxlKG1vZHVsZVR5cGUpO1xuICAgICAgICAgIHZhciBtb2R1bGVNZXRhID0gdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXROZ01vZHVsZU1ldGFkYXRhKG1vZHVsZVR5cGUpO1xuICAgICAgICAgIHZhciBjb21wb25lbnRGYWN0b3JpZXMgPSBbXTtcbiAgICAgICAgICB2YXIgdGVtcGxhdGVzID0gbmV3IFNldCgpO1xuICAgICAgICAgIG1vZHVsZU1ldGEudHJhbnNpdGl2ZU1vZHVsZS5tb2R1bGVzLmZvckVhY2goZnVuY3Rpb24gKGxvY2FsTW9kdWxlTWV0YSkge1xuICAgICAgICAgICAgICBsb2NhbE1vZHVsZU1ldGEuZGVjbGFyZWREaXJlY3RpdmVzLmZvckVhY2goZnVuY3Rpb24gKGRpck1ldGEpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChkaXJNZXRhLmlzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXBsYXRlID0gX3RoaXMuX2NyZWF0ZUNvbXBpbGVkSG9zdFRlbXBsYXRlKGRpck1ldGEudHlwZS5yZWZlcmVuY2UsIGxvY2FsTW9kdWxlTWV0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVzLmFkZCh0ZW1wbGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RmFjdG9yaWVzLnB1c2godGVtcGxhdGUucHJveHlDb21wb25lbnRGYWN0b3J5KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIHN5bmNSZXN1bHQgPSBuZXcgX2FuZ3VsYXJfY29yZS5Nb2R1bGVXaXRoQ29tcG9uZW50RmFjdG9yaWVzKG5nTW9kdWxlRmFjdG9yeSwgY29tcG9uZW50RmFjdG9yaWVzKTtcbiAgICAgICAgICAvLyBOb3RlOiBob3N0IGNvbXBvbmVudHMgdGhlbXNlbHZlcyBjYW4gYWx3YXlzIGJlIGNvbXBpbGVkIHN5bmNocm9ub3VzbHkgYXMgdGhleSBoYXZlIGFuXG4gICAgICAgICAgLy8gaW5saW5lIHRlbXBsYXRlLiBIb3dldmVyLCB3ZSBzdGlsbCBuZWVkIHRvIHdhaXQgZm9yIHRoZSBjb21wb25lbnRzIHRoYXQgdGhleVxuICAgICAgICAgIC8vIHJlZmVyZW5jZSB0byBiZSBsb2FkZWQgLyBjb21waWxlZC5cbiAgICAgICAgICB2YXIgY29tcGlsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdGVtcGxhdGVzLmZvckVhY2goZnVuY3Rpb24gKHRlbXBsYXRlKSB7IF90aGlzLl9jb21waWxlVGVtcGxhdGUodGVtcGxhdGUpOyB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuIHN5bmNSZXN1bHQ7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgYXN5bmNSZXN1bHQgPSBpc1N5bmMgPyBQcm9taXNlLnJlc29sdmUoY29tcGlsZSgpKSA6IGNvbXBvbmVudFByb21pc2UudGhlbihjb21waWxlKTtcbiAgICAgICAgICByZXR1cm4gbmV3IFN5bmNBc3luY1Jlc3VsdChzeW5jUmVzdWx0LCBhc3luY1Jlc3VsdCk7XG4gICAgICB9O1xuICAgICAgUnVudGltZUNvbXBpbGVyLnByb3RvdHlwZS5fY29tcGlsZU1vZHVsZSA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgbmdNb2R1bGVGYWN0b3J5ID0gdGhpcy5fY29tcGlsZWROZ01vZHVsZUNhY2hlLmdldChtb2R1bGVUeXBlKTtcbiAgICAgICAgICBpZiAoIW5nTW9kdWxlRmFjdG9yeSkge1xuICAgICAgICAgICAgICB2YXIgbW9kdWxlTWV0YV8xID0gdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXROZ01vZHVsZU1ldGFkYXRhKG1vZHVsZVR5cGUpO1xuICAgICAgICAgICAgICAvLyBBbHdheXMgcHJvdmlkZSBhIGJvdW5kIENvbXBpbGVyXG4gICAgICAgICAgICAgIHZhciBleHRyYVByb3ZpZGVycyA9IFt0aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldFByb3ZpZGVyTWV0YWRhdGEobmV3IFByb3ZpZGVyTWV0YShfYW5ndWxhcl9jb3JlLkNvbXBpbGVyLCB7IHVzZUZhY3Rvcnk6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBNb2R1bGVCb3VuZENvbXBpbGVyKF90aGlzLCBtb2R1bGVNZXRhXzEudHlwZS5yZWZlcmVuY2UpOyB9IH0pKV07XG4gICAgICAgICAgICAgIHZhciBjb21waWxlUmVzdWx0ID0gdGhpcy5fbmdNb2R1bGVDb21waWxlci5jb21waWxlKG1vZHVsZU1ldGFfMSwgZXh0cmFQcm92aWRlcnMpO1xuICAgICAgICAgICAgICBjb21waWxlUmVzdWx0LmRlcGVuZGVuY2llcy5mb3JFYWNoKGZ1bmN0aW9uIChkZXApIHtcbiAgICAgICAgICAgICAgICAgIGRlcC5wbGFjZWhvbGRlci5yZWZlcmVuY2UgPVxuICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9hc3NlcnRDb21wb25lbnRLbm93bihkZXAuY29tcC5yZWZlcmVuY2UsIHRydWUpLnByb3h5Q29tcG9uZW50RmFjdG9yeTtcbiAgICAgICAgICAgICAgICAgIGRlcC5wbGFjZWhvbGRlci5uYW1lID0gXCJjb21wRmFjdG9yeV9cIiArIGRlcC5jb21wLm5hbWU7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBpZiAoIXRoaXMuX2NvbXBpbGVyQ29uZmlnLnVzZUppdCkge1xuICAgICAgICAgICAgICAgICAgbmdNb2R1bGVGYWN0b3J5ID1cbiAgICAgICAgICAgICAgICAgICAgICBpbnRlcnByZXRTdGF0ZW1lbnRzKGNvbXBpbGVSZXN1bHQuc3RhdGVtZW50cywgY29tcGlsZVJlc3VsdC5uZ01vZHVsZUZhY3RvcnlWYXIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgbmdNb2R1bGVGYWN0b3J5ID0gaml0U3RhdGVtZW50cyhcIi9cIiArIG1vZHVsZU1ldGFfMS50eXBlLm5hbWUgKyBcIi9tb2R1bGUubmdmYWN0b3J5LmpzXCIsIGNvbXBpbGVSZXN1bHQuc3RhdGVtZW50cywgY29tcGlsZVJlc3VsdC5uZ01vZHVsZUZhY3RvcnlWYXIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuX2NvbXBpbGVkTmdNb2R1bGVDYWNoZS5zZXQobW9kdWxlTWV0YV8xLnR5cGUucmVmZXJlbmNlLCBuZ01vZHVsZUZhY3RvcnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmdNb2R1bGVGYWN0b3J5O1xuICAgICAgfTtcbiAgICAgIC8qKlxuICAgICAgICogQGludGVybmFsXG4gICAgICAgKi9cbiAgICAgIFJ1bnRpbWVDb21waWxlci5wcm90b3R5cGUuX2NvbXBpbGVDb21wb25lbnRzID0gZnVuY3Rpb24gKG1haW5Nb2R1bGUsIGlzU3luYykge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIHRlbXBsYXRlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICB2YXIgbG9hZGluZ1Byb21pc2VzID0gW107XG4gICAgICAgICAgdmFyIG5nTW9kdWxlID0gdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXROZ01vZHVsZU1ldGFkYXRhKG1haW5Nb2R1bGUpO1xuICAgICAgICAgIHZhciBtb2R1bGVCeURpcmVjdGl2ZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgICBuZ01vZHVsZS50cmFuc2l0aXZlTW9kdWxlLm1vZHVsZXMuZm9yRWFjaChmdW5jdGlvbiAobG9jYWxNb2R1bGVNZXRhKSB7XG4gICAgICAgICAgICAgIGxvY2FsTW9kdWxlTWV0YS5kZWNsYXJlZERpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlyTWV0YSkge1xuICAgICAgICAgICAgICAgICAgbW9kdWxlQnlEaXJlY3RpdmUuc2V0KGRpck1ldGEudHlwZS5yZWZlcmVuY2UsIGxvY2FsTW9kdWxlTWV0YSk7XG4gICAgICAgICAgICAgICAgICBfdGhpcy5fY29tcGlsZURpcmVjdGl2ZVdyYXBwZXIoZGlyTWV0YSwgbG9jYWxNb2R1bGVNZXRhKTtcbiAgICAgICAgICAgICAgICAgIGlmIChkaXJNZXRhLmlzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVzLmFkZChfdGhpcy5fY3JlYXRlQ29tcGlsZWRUZW1wbGF0ZShkaXJNZXRhLCBsb2NhbE1vZHVsZU1ldGEpKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbmdNb2R1bGUudHJhbnNpdGl2ZU1vZHVsZS5tb2R1bGVzLmZvckVhY2goZnVuY3Rpb24gKGxvY2FsTW9kdWxlTWV0YSkge1xuICAgICAgICAgICAgICBsb2NhbE1vZHVsZU1ldGEuZGVjbGFyZWREaXJlY3RpdmVzLmZvckVhY2goZnVuY3Rpb24gKGRpck1ldGEpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChkaXJNZXRhLmlzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgZGlyTWV0YS5lbnRyeUNvbXBvbmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZW50cnlDb21wb25lbnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtb2R1bGVNZXRhID0gbW9kdWxlQnlEaXJlY3RpdmUuZ2V0KGVudHJ5Q29tcG9uZW50VHlwZS5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZXMuYWRkKF90aGlzLl9jcmVhdGVDb21waWxlZEhvc3RUZW1wbGF0ZShlbnRyeUNvbXBvbmVudFR5cGUucmVmZXJlbmNlLCBtb2R1bGVNZXRhKSk7XG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBsb2NhbE1vZHVsZU1ldGEuZW50cnlDb21wb25lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5Q29tcG9uZW50VHlwZSkge1xuICAgICAgICAgICAgICAgICAgdmFyIG1vZHVsZU1ldGEgPSBtb2R1bGVCeURpcmVjdGl2ZS5nZXQoZW50cnlDb21wb25lbnRUeXBlLnJlZmVyZW5jZSk7XG4gICAgICAgICAgICAgICAgICB0ZW1wbGF0ZXMuYWRkKF90aGlzLl9jcmVhdGVDb21waWxlZEhvc3RUZW1wbGF0ZShlbnRyeUNvbXBvbmVudFR5cGUucmVmZXJlbmNlLCBtb2R1bGVNZXRhKSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRlbXBsYXRlcy5mb3JFYWNoKGZ1bmN0aW9uICh0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgICBpZiAodGVtcGxhdGUubG9hZGluZykge1xuICAgICAgICAgICAgICAgICAgaWYgKGlzU3luYykge1xuICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBDb21wb25lbnRTdGlsbExvYWRpbmdFcnJvcih0ZW1wbGF0ZS5jb21wVHlwZS5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgbG9hZGluZ1Byb21pc2VzLnB1c2godGVtcGxhdGUubG9hZGluZyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgY29tcGlsZSA9IGZ1bmN0aW9uICgpIHsgdGVtcGxhdGVzLmZvckVhY2goZnVuY3Rpb24gKHRlbXBsYXRlKSB7IF90aGlzLl9jb21waWxlVGVtcGxhdGUodGVtcGxhdGUpOyB9KTsgfTtcbiAgICAgICAgICBpZiAoaXNTeW5jKSB7XG4gICAgICAgICAgICAgIGNvbXBpbGUoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChsb2FkaW5nUHJvbWlzZXMpLnRoZW4oY29tcGlsZSk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIFJ1bnRpbWVDb21waWxlci5wcm90b3R5cGUuY2xlYXJDYWNoZUZvciA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgdGhpcy5fY29tcGlsZWROZ01vZHVsZUNhY2hlLmRlbGV0ZSh0eXBlKTtcbiAgICAgICAgICB0aGlzLl9tZXRhZGF0YVJlc29sdmVyLmNsZWFyQ2FjaGVGb3IodHlwZSk7XG4gICAgICAgICAgdGhpcy5fY29tcGlsZWRIb3N0VGVtcGxhdGVDYWNoZS5kZWxldGUodHlwZSk7XG4gICAgICAgICAgdmFyIGNvbXBpbGVkVGVtcGxhdGUgPSB0aGlzLl9jb21waWxlZFRlbXBsYXRlQ2FjaGUuZ2V0KHR5cGUpO1xuICAgICAgICAgIGlmIChjb21waWxlZFRlbXBsYXRlKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRlTm9ybWFsaXplci5jbGVhckNhY2hlRm9yKGNvbXBpbGVkVGVtcGxhdGUubm9ybWFsaXplZENvbXBNZXRhKTtcbiAgICAgICAgICAgICAgdGhpcy5fY29tcGlsZWRUZW1wbGF0ZUNhY2hlLmRlbGV0ZSh0eXBlKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgUnVudGltZUNvbXBpbGVyLnByb3RvdHlwZS5jbGVhckNhY2hlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMuX21ldGFkYXRhUmVzb2x2ZXIuY2xlYXJDYWNoZSgpO1xuICAgICAgICAgIHRoaXMuX2NvbXBpbGVkVGVtcGxhdGVDYWNoZS5jbGVhcigpO1xuICAgICAgICAgIHRoaXMuX2NvbXBpbGVkSG9zdFRlbXBsYXRlQ2FjaGUuY2xlYXIoKTtcbiAgICAgICAgICB0aGlzLl90ZW1wbGF0ZU5vcm1hbGl6ZXIuY2xlYXJDYWNoZSgpO1xuICAgICAgICAgIHRoaXMuX2NvbXBpbGVkTmdNb2R1bGVDYWNoZS5jbGVhcigpO1xuICAgICAgfTtcbiAgICAgIFJ1bnRpbWVDb21waWxlci5wcm90b3R5cGUuX2NyZWF0ZUNvbXBpbGVkSG9zdFRlbXBsYXRlID0gZnVuY3Rpb24gKGNvbXBUeXBlLCBuZ01vZHVsZSkge1xuICAgICAgICAgIGlmICghbmdNb2R1bGUpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29tcG9uZW50IFwiICsgc3RyaW5naWZ5KGNvbXBUeXBlKSArIFwiIGlzIG5vdCBwYXJ0IG9mIGFueSBOZ01vZHVsZSBvciB0aGUgbW9kdWxlIGhhcyBub3QgYmVlbiBpbXBvcnRlZCBpbnRvIHlvdXIgbW9kdWxlLlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGNvbXBpbGVkVGVtcGxhdGUgPSB0aGlzLl9jb21waWxlZEhvc3RUZW1wbGF0ZUNhY2hlLmdldChjb21wVHlwZSk7XG4gICAgICAgICAgaWYgKCFjb21waWxlZFRlbXBsYXRlKSB7XG4gICAgICAgICAgICAgIHZhciBjb21wTWV0YSA9IHRoaXMuX21ldGFkYXRhUmVzb2x2ZXIuZ2V0RGlyZWN0aXZlTWV0YWRhdGEoY29tcFR5cGUpO1xuICAgICAgICAgICAgICBhc3NlcnRDb21wb25lbnQoY29tcE1ldGEpO1xuICAgICAgICAgICAgICB2YXIgaG9zdE1ldGEgPSBjcmVhdGVIb3N0Q29tcG9uZW50TWV0YShjb21wTWV0YSk7XG4gICAgICAgICAgICAgIGNvbXBpbGVkVGVtcGxhdGUgPSBuZXcgQ29tcGlsZWRUZW1wbGF0ZSh0cnVlLCBjb21wTWV0YS5zZWxlY3RvciwgY29tcE1ldGEudHlwZSwgbmdNb2R1bGUsIFtjb21wTWV0YV0sIHRoaXMuX3RlbXBsYXRlTm9ybWFsaXplci5ub3JtYWxpemVEaXJlY3RpdmUoaG9zdE1ldGEpKTtcbiAgICAgICAgICAgICAgdGhpcy5fY29tcGlsZWRIb3N0VGVtcGxhdGVDYWNoZS5zZXQoY29tcFR5cGUsIGNvbXBpbGVkVGVtcGxhdGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY29tcGlsZWRUZW1wbGF0ZTtcbiAgICAgIH07XG4gICAgICBSdW50aW1lQ29tcGlsZXIucHJvdG90eXBlLl9jcmVhdGVDb21waWxlZFRlbXBsYXRlID0gZnVuY3Rpb24gKGNvbXBNZXRhLCBuZ01vZHVsZSkge1xuICAgICAgICAgIHZhciBjb21waWxlZFRlbXBsYXRlID0gdGhpcy5fY29tcGlsZWRUZW1wbGF0ZUNhY2hlLmdldChjb21wTWV0YS50eXBlLnJlZmVyZW5jZSk7XG4gICAgICAgICAgaWYgKCFjb21waWxlZFRlbXBsYXRlKSB7XG4gICAgICAgICAgICAgIGFzc2VydENvbXBvbmVudChjb21wTWV0YSk7XG4gICAgICAgICAgICAgIGNvbXBpbGVkVGVtcGxhdGUgPSBuZXcgQ29tcGlsZWRUZW1wbGF0ZShmYWxzZSwgY29tcE1ldGEuc2VsZWN0b3IsIGNvbXBNZXRhLnR5cGUsIG5nTW9kdWxlLCBuZ01vZHVsZS50cmFuc2l0aXZlTW9kdWxlLmRpcmVjdGl2ZXMsIHRoaXMuX3RlbXBsYXRlTm9ybWFsaXplci5ub3JtYWxpemVEaXJlY3RpdmUoY29tcE1ldGEpKTtcbiAgICAgICAgICAgICAgdGhpcy5fY29tcGlsZWRUZW1wbGF0ZUNhY2hlLnNldChjb21wTWV0YS50eXBlLnJlZmVyZW5jZSwgY29tcGlsZWRUZW1wbGF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjb21waWxlZFRlbXBsYXRlO1xuICAgICAgfTtcbiAgICAgIFJ1bnRpbWVDb21waWxlci5wcm90b3R5cGUuX2Fzc2VydENvbXBvbmVudEtub3duID0gZnVuY3Rpb24gKGNvbXBUeXBlLCBpc0hvc3QpIHtcbiAgICAgICAgICB2YXIgY29tcGlsZWRUZW1wbGF0ZSA9IGlzSG9zdCA/IHRoaXMuX2NvbXBpbGVkSG9zdFRlbXBsYXRlQ2FjaGUuZ2V0KGNvbXBUeXBlKSA6XG4gICAgICAgICAgICAgIHRoaXMuX2NvbXBpbGVkVGVtcGxhdGVDYWNoZS5nZXQoY29tcFR5cGUpO1xuICAgICAgICAgIGlmICghY29tcGlsZWRUZW1wbGF0ZSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIHN0YXRlOiBDb21waWxlZCB2aWV3IGZvciBjb21wb25lbnQgXCIgKyBzdHJpbmdpZnkoY29tcFR5cGUpICsgXCIgZG9lcyBub3QgZXhpc3QhXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY29tcGlsZWRUZW1wbGF0ZTtcbiAgICAgIH07XG4gICAgICBSdW50aW1lQ29tcGlsZXIucHJvdG90eXBlLl9hc3NlcnRDb21wb25lbnRMb2FkZWQgPSBmdW5jdGlvbiAoY29tcFR5cGUsIGlzSG9zdCkge1xuICAgICAgICAgIHZhciBjb21waWxlZFRlbXBsYXRlID0gdGhpcy5fYXNzZXJ0Q29tcG9uZW50S25vd24oY29tcFR5cGUsIGlzSG9zdCk7XG4gICAgICAgICAgaWYgKGNvbXBpbGVkVGVtcGxhdGUubG9hZGluZykge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIHN0YXRlOiBDb21waWxlZFRlbXBsYXRlIGZvciBcIiArIHN0cmluZ2lmeShjb21wVHlwZSkgKyBcIiAoaXNIb3N0OiBcIiArIGlzSG9zdCArIFwiKSBpcyBzdGlsbCBsb2FkaW5nIVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNvbXBpbGVkVGVtcGxhdGU7XG4gICAgICB9O1xuICAgICAgUnVudGltZUNvbXBpbGVyLnByb3RvdHlwZS5fYXNzZXJ0RGlyZWN0aXZlV3JhcHBlciA9IGZ1bmN0aW9uIChkaXJUeXBlKSB7XG4gICAgICAgICAgdmFyIGRpcldyYXBwZXIgPSB0aGlzLl9jb21waWxlZERpcmVjdGl2ZVdyYXBwZXJDYWNoZS5nZXQoZGlyVHlwZSk7XG4gICAgICAgICAgaWYgKCFkaXJXcmFwcGVyKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklsbGVnYWwgc3RhdGU6IERpcmVjdGl2ZSB3cmFwcGVyIGZvciBcIiArIHN0cmluZ2lmeShkaXJUeXBlKSArIFwiIGhhcyBub3QgYmVlbiBjb21waWxlZCFcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBkaXJXcmFwcGVyO1xuICAgICAgfTtcbiAgICAgIFJ1bnRpbWVDb21waWxlci5wcm90b3R5cGUuX2NvbXBpbGVEaXJlY3RpdmVXcmFwcGVyID0gZnVuY3Rpb24gKGRpck1ldGEsIG1vZHVsZU1ldGEpIHtcbiAgICAgICAgICB2YXIgY29tcGlsZVJlc3VsdCA9IHRoaXMuX2RpcmVjdGl2ZVdyYXBwZXJDb21waWxlci5jb21waWxlKGRpck1ldGEpO1xuICAgICAgICAgIHZhciBzdGF0ZW1lbnRzID0gY29tcGlsZVJlc3VsdC5zdGF0ZW1lbnRzO1xuICAgICAgICAgIHZhciBkaXJlY3RpdmVXcmFwcGVyQ2xhc3M7XG4gICAgICAgICAgaWYgKCF0aGlzLl9jb21waWxlckNvbmZpZy51c2VKaXQpIHtcbiAgICAgICAgICAgICAgZGlyZWN0aXZlV3JhcHBlckNsYXNzID0gaW50ZXJwcmV0U3RhdGVtZW50cyhzdGF0ZW1lbnRzLCBjb21waWxlUmVzdWx0LmRpcldyYXBwZXJDbGFzc1Zhcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBkaXJlY3RpdmVXcmFwcGVyQ2xhc3MgPSBqaXRTdGF0ZW1lbnRzKFwiL1wiICsgbW9kdWxlTWV0YS50eXBlLm5hbWUgKyBcIi9cIiArIGRpck1ldGEudHlwZS5uYW1lICsgXCIvd3JhcHBlci5uZ2ZhY3RvcnkuanNcIiwgc3RhdGVtZW50cywgY29tcGlsZVJlc3VsdC5kaXJXcmFwcGVyQ2xhc3NWYXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9jb21waWxlZERpcmVjdGl2ZVdyYXBwZXJDYWNoZS5zZXQoZGlyTWV0YS50eXBlLnJlZmVyZW5jZSwgZGlyZWN0aXZlV3JhcHBlckNsYXNzKTtcbiAgICAgIH07XG4gICAgICBSdW50aW1lQ29tcGlsZXIucHJvdG90eXBlLl9jb21waWxlVGVtcGxhdGUgPSBmdW5jdGlvbiAodGVtcGxhdGUpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIGlmICh0ZW1wbGF0ZS5pc0NvbXBpbGVkKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGNvbXBNZXRhID0gdGVtcGxhdGUubm9ybWFsaXplZENvbXBNZXRhO1xuICAgICAgICAgIHZhciBleHRlcm5hbFN0eWxlc2hlZXRzQnlNb2R1bGVVcmwgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgdmFyIHN0eWxlc0NvbXBpbGVSZXN1bHQgPSB0aGlzLl9zdHlsZUNvbXBpbGVyLmNvbXBpbGVDb21wb25lbnQoY29tcE1ldGEpO1xuICAgICAgICAgIHN0eWxlc0NvbXBpbGVSZXN1bHQuZXh0ZXJuYWxTdHlsZXNoZWV0cy5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IGV4dGVybmFsU3R5bGVzaGVldHNCeU1vZHVsZVVybC5zZXQoci5tZXRhLm1vZHVsZVVybCwgcik7IH0pO1xuICAgICAgICAgIHRoaXMuX3Jlc29sdmVTdHlsZXNDb21waWxlUmVzdWx0KHN0eWxlc0NvbXBpbGVSZXN1bHQuY29tcG9uZW50U3R5bGVzaGVldCwgZXh0ZXJuYWxTdHlsZXNoZWV0c0J5TW9kdWxlVXJsKTtcbiAgICAgICAgICB2YXIgdmlld0NvbXBNZXRhcyA9IHRlbXBsYXRlLnZpZXdDb21wb25lbnRUeXBlcy5tYXAoZnVuY3Rpb24gKGNvbXBUeXBlKSB7IHJldHVybiBfdGhpcy5fYXNzZXJ0Q29tcG9uZW50TG9hZGVkKGNvbXBUeXBlLCBmYWxzZSkubm9ybWFsaXplZENvbXBNZXRhOyB9KTtcbiAgICAgICAgICB2YXIgcGFyc2VkQW5pbWF0aW9ucyA9IHRoaXMuX2FuaW1hdGlvblBhcnNlci5wYXJzZUNvbXBvbmVudChjb21wTWV0YSk7XG4gICAgICAgICAgdmFyIHBhcnNlZFRlbXBsYXRlID0gdGhpcy5fdGVtcGxhdGVQYXJzZXIucGFyc2UoY29tcE1ldGEsIGNvbXBNZXRhLnRlbXBsYXRlLnRlbXBsYXRlLCB0ZW1wbGF0ZS52aWV3RGlyZWN0aXZlcy5jb25jYXQodmlld0NvbXBNZXRhcyksIHRlbXBsYXRlLnZpZXdQaXBlcywgdGVtcGxhdGUuc2NoZW1hcywgY29tcE1ldGEudHlwZS5uYW1lKTtcbiAgICAgICAgICB2YXIgY29tcGlsZWRBbmltYXRpb25zID0gdGhpcy5fYW5pbWF0aW9uQ29tcGlsZXIuY29tcGlsZShjb21wTWV0YS50eXBlLm5hbWUsIHBhcnNlZEFuaW1hdGlvbnMpO1xuICAgICAgICAgIHZhciBjb21waWxlUmVzdWx0ID0gdGhpcy5fdmlld0NvbXBpbGVyLmNvbXBpbGVDb21wb25lbnQoY29tcE1ldGEsIHBhcnNlZFRlbXBsYXRlLCB2YXJpYWJsZShzdHlsZXNDb21waWxlUmVzdWx0LmNvbXBvbmVudFN0eWxlc2hlZXQuc3R5bGVzVmFyKSwgdGVtcGxhdGUudmlld1BpcGVzLCBjb21waWxlZEFuaW1hdGlvbnMpO1xuICAgICAgICAgIGNvbXBpbGVSZXN1bHQuZGVwZW5kZW5jaWVzLmZvckVhY2goZnVuY3Rpb24gKGRlcCkge1xuICAgICAgICAgICAgICB2YXIgZGVwVGVtcGxhdGU7XG4gICAgICAgICAgICAgIGlmIChkZXAgaW5zdGFuY2VvZiBWaWV3RmFjdG9yeURlcGVuZGVuY3kpIHtcbiAgICAgICAgICAgICAgICAgIHZhciB2ZmQgPSBkZXA7XG4gICAgICAgICAgICAgICAgICBkZXBUZW1wbGF0ZSA9IF90aGlzLl9hc3NlcnRDb21wb25lbnRMb2FkZWQodmZkLmNvbXAucmVmZXJlbmNlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICB2ZmQucGxhY2Vob2xkZXIucmVmZXJlbmNlID0gZGVwVGVtcGxhdGUucHJveHlWaWV3RmFjdG9yeTtcbiAgICAgICAgICAgICAgICAgIHZmZC5wbGFjZWhvbGRlci5uYW1lID0gXCJ2aWV3RmFjdG9yeV9cIiArIHZmZC5jb21wLm5hbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAoZGVwIGluc3RhbmNlb2YgQ29tcG9uZW50RmFjdG9yeURlcGVuZGVuY3kpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBjZmQgPSBkZXA7XG4gICAgICAgICAgICAgICAgICBkZXBUZW1wbGF0ZSA9IF90aGlzLl9hc3NlcnRDb21wb25lbnRMb2FkZWQoY2ZkLmNvbXAucmVmZXJlbmNlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgIGNmZC5wbGFjZWhvbGRlci5yZWZlcmVuY2UgPSBkZXBUZW1wbGF0ZS5wcm94eUNvbXBvbmVudEZhY3Rvcnk7XG4gICAgICAgICAgICAgICAgICBjZmQucGxhY2Vob2xkZXIubmFtZSA9IFwiY29tcEZhY3RvcnlfXCIgKyBjZmQuY29tcC5uYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKGRlcCBpbnN0YW5jZW9mIERpcmVjdGl2ZVdyYXBwZXJEZXBlbmRlbmN5KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZHdkID0gZGVwO1xuICAgICAgICAgICAgICAgICAgZHdkLnBsYWNlaG9sZGVyLnJlZmVyZW5jZSA9IF90aGlzLl9hc3NlcnREaXJlY3RpdmVXcmFwcGVyKGR3ZC5kaXIucmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBzdGF0ZW1lbnRzID0gc3R5bGVzQ29tcGlsZVJlc3VsdC5jb21wb25lbnRTdHlsZXNoZWV0LnN0YXRlbWVudHMuY29uY2F0KGNvbXBpbGVSZXN1bHQuc3RhdGVtZW50cyk7XG4gICAgICAgICAgY29tcGlsZWRBbmltYXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7IGVudHJ5LnN0YXRlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoc3RhdGVtZW50KSB7IHN0YXRlbWVudHMucHVzaChzdGF0ZW1lbnQpOyB9KTsgfSk7XG4gICAgICAgICAgdmFyIGZhY3Rvcnk7XG4gICAgICAgICAgaWYgKCF0aGlzLl9jb21waWxlckNvbmZpZy51c2VKaXQpIHtcbiAgICAgICAgICAgICAgZmFjdG9yeSA9IGludGVycHJldFN0YXRlbWVudHMoc3RhdGVtZW50cywgY29tcGlsZVJlc3VsdC52aWV3RmFjdG9yeVZhcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBmYWN0b3J5ID0gaml0U3RhdGVtZW50cyhcIi9cIiArIHRlbXBsYXRlLm5nTW9kdWxlLnR5cGUubmFtZSArIFwiL1wiICsgdGVtcGxhdGUuY29tcFR5cGUubmFtZSArIFwiL1wiICsgKHRlbXBsYXRlLmlzSG9zdCA/ICdob3N0JyA6ICdjb21wb25lbnQnKSArIFwiLm5nZmFjdG9yeS5qc1wiLCBzdGF0ZW1lbnRzLCBjb21waWxlUmVzdWx0LnZpZXdGYWN0b3J5VmFyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGVtcGxhdGUuY29tcGlsZWQoZmFjdG9yeSk7XG4gICAgICB9O1xuICAgICAgUnVudGltZUNvbXBpbGVyLnByb3RvdHlwZS5fcmVzb2x2ZVN0eWxlc0NvbXBpbGVSZXN1bHQgPSBmdW5jdGlvbiAocmVzdWx0LCBleHRlcm5hbFN0eWxlc2hlZXRzQnlNb2R1bGVVcmwpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHJlc3VsdC5kZXBlbmRlbmNpZXMuZm9yRWFjaChmdW5jdGlvbiAoZGVwLCBpKSB7XG4gICAgICAgICAgICAgIHZhciBuZXN0ZWRDb21waWxlUmVzdWx0ID0gZXh0ZXJuYWxTdHlsZXNoZWV0c0J5TW9kdWxlVXJsLmdldChkZXAubW9kdWxlVXJsKTtcbiAgICAgICAgICAgICAgdmFyIG5lc3RlZFN0eWxlc0FyciA9IF90aGlzLl9yZXNvbHZlQW5kRXZhbFN0eWxlc0NvbXBpbGVSZXN1bHQobmVzdGVkQ29tcGlsZVJlc3VsdCwgZXh0ZXJuYWxTdHlsZXNoZWV0c0J5TW9kdWxlVXJsKTtcbiAgICAgICAgICAgICAgZGVwLnZhbHVlUGxhY2Vob2xkZXIucmVmZXJlbmNlID0gbmVzdGVkU3R5bGVzQXJyO1xuICAgICAgICAgICAgICBkZXAudmFsdWVQbGFjZWhvbGRlci5uYW1lID0gXCJpbXBvcnRlZFN0eWxlc1wiICsgaTtcbiAgICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBSdW50aW1lQ29tcGlsZXIucHJvdG90eXBlLl9yZXNvbHZlQW5kRXZhbFN0eWxlc0NvbXBpbGVSZXN1bHQgPSBmdW5jdGlvbiAocmVzdWx0LCBleHRlcm5hbFN0eWxlc2hlZXRzQnlNb2R1bGVVcmwpIHtcbiAgICAgICAgICB0aGlzLl9yZXNvbHZlU3R5bGVzQ29tcGlsZVJlc3VsdChyZXN1bHQsIGV4dGVybmFsU3R5bGVzaGVldHNCeU1vZHVsZVVybCk7XG4gICAgICAgICAgaWYgKCF0aGlzLl9jb21waWxlckNvbmZpZy51c2VKaXQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGludGVycHJldFN0YXRlbWVudHMocmVzdWx0LnN0YXRlbWVudHMsIHJlc3VsdC5zdHlsZXNWYXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGppdFN0YXRlbWVudHMoXCIvXCIgKyByZXN1bHQubWV0YS5tb2R1bGVVcmwgKyBcIi5jc3MuanNcIiwgcmVzdWx0LnN0YXRlbWVudHMsIHJlc3VsdC5zdHlsZXNWYXIpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBSdW50aW1lQ29tcGlsZXIuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuICAgICAgXTtcbiAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgUnVudGltZUNvbXBpbGVyLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RvciwgfSxcbiAgICAgICAgICB7IHR5cGU6IENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLCB9LFxuICAgICAgICAgIHsgdHlwZTogRGlyZWN0aXZlTm9ybWFsaXplciwgfSxcbiAgICAgICAgICB7IHR5cGU6IFRlbXBsYXRlUGFyc2VyLCB9LFxuICAgICAgICAgIHsgdHlwZTogU3R5bGVDb21waWxlciwgfSxcbiAgICAgICAgICB7IHR5cGU6IFZpZXdDb21waWxlciwgfSxcbiAgICAgICAgICB7IHR5cGU6IE5nTW9kdWxlQ29tcGlsZXIsIH0sXG4gICAgICAgICAgeyB0eXBlOiBEaXJlY3RpdmVXcmFwcGVyQ29tcGlsZXIsIH0sXG4gICAgICAgICAgeyB0eXBlOiBDb21waWxlckNvbmZpZywgfSxcbiAgICAgIF07XG4gICAgICByZXR1cm4gUnVudGltZUNvbXBpbGVyO1xuICB9KCkpO1xuICB2YXIgQ29tcGlsZWRUZW1wbGF0ZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBDb21waWxlZFRlbXBsYXRlKGlzSG9zdCwgc2VsZWN0b3IsIGNvbXBUeXBlLCBuZ01vZHVsZSwgdmlld0RpcmVjdGl2ZUFuZENvbXBvbmVudHMsIF9ub3JtYWxpemVSZXN1bHQpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHRoaXMuaXNIb3N0ID0gaXNIb3N0O1xuICAgICAgICAgIHRoaXMuY29tcFR5cGUgPSBjb21wVHlwZTtcbiAgICAgICAgICB0aGlzLm5nTW9kdWxlID0gbmdNb2R1bGU7XG4gICAgICAgICAgdGhpcy5fdmlld0ZhY3RvcnkgPSBudWxsO1xuICAgICAgICAgIHRoaXMubG9hZGluZyA9IG51bGw7XG4gICAgICAgICAgdGhpcy5fbm9ybWFsaXplZENvbXBNZXRhID0gbnVsbDtcbiAgICAgICAgICB0aGlzLmlzQ29tcGlsZWQgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmlzQ29tcGlsZWRXaXRoRGVwcyA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMudmlld0NvbXBvbmVudFR5cGVzID0gW107XG4gICAgICAgICAgdGhpcy52aWV3RGlyZWN0aXZlcyA9IFtdO1xuICAgICAgICAgIHRoaXMudmlld1BpcGVzID0gbmdNb2R1bGUudHJhbnNpdGl2ZU1vZHVsZS5waXBlcztcbiAgICAgICAgICB0aGlzLnNjaGVtYXMgPSBuZ01vZHVsZS5zY2hlbWFzO1xuICAgICAgICAgIHZpZXdEaXJlY3RpdmVBbmRDb21wb25lbnRzLmZvckVhY2goZnVuY3Rpb24gKGRpck1ldGEpIHtcbiAgICAgICAgICAgICAgaWYgKGRpck1ldGEuaXNDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzLnZpZXdDb21wb25lbnRUeXBlcy5wdXNoKGRpck1ldGEudHlwZS5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgX3RoaXMudmlld0RpcmVjdGl2ZXMucHVzaChkaXJNZXRhKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMucHJveHlWaWV3RmFjdG9yeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgIGFyZ3NbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFfdGhpcy5fdmlld0ZhY3RvcnkpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklsbGVnYWwgc3RhdGU6IENvbXBpbGVkVGVtcGxhdGUgZm9yIFwiICsgc3RyaW5naWZ5KF90aGlzLmNvbXBUeXBlKSArIFwiIGlzIG5vdCBjb21waWxlZCB5ZXQhXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fdmlld0ZhY3RvcnkuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB0aGlzLnByb3h5Q29tcG9uZW50RmFjdG9yeSA9IGlzSG9zdCA/XG4gICAgICAgICAgICAgIG5ldyBfYW5ndWxhcl9jb3JlLkNvbXBvbmVudEZhY3Rvcnkoc2VsZWN0b3IsIHRoaXMucHJveHlWaWV3RmFjdG9yeSwgY29tcFR5cGUucmVmZXJlbmNlKSA6XG4gICAgICAgICAgICAgIG51bGw7XG4gICAgICAgICAgaWYgKF9ub3JtYWxpemVSZXN1bHQuc3luY1Jlc3VsdCkge1xuICAgICAgICAgICAgICB0aGlzLl9ub3JtYWxpemVkQ29tcE1ldGEgPSBfbm9ybWFsaXplUmVzdWx0LnN5bmNSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLmxvYWRpbmcgPSBfbm9ybWFsaXplUmVzdWx0LmFzeW5jUmVzdWx0LnRoZW4oZnVuY3Rpb24gKG5vcm1hbGl6ZWRDb21wTWV0YSkge1xuICAgICAgICAgICAgICAgICAgX3RoaXMuX25vcm1hbGl6ZWRDb21wTWV0YSA9IG5vcm1hbGl6ZWRDb21wTWV0YTtcbiAgICAgICAgICAgICAgICAgIF90aGlzLmxvYWRpbmcgPSBudWxsO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcGlsZWRUZW1wbGF0ZS5wcm90b3R5cGUsIFwibm9ybWFsaXplZENvbXBNZXRhXCIsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMubG9hZGluZykge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGVtcGxhdGUgaXMgc3RpbGwgbG9hZGluZyBmb3IgXCIgKyB0aGlzLmNvbXBUeXBlLm5hbWUgKyBcIiFcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25vcm1hbGl6ZWRDb21wTWV0YTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIENvbXBpbGVkVGVtcGxhdGUucHJvdG90eXBlLmNvbXBpbGVkID0gZnVuY3Rpb24gKHZpZXdGYWN0b3J5KSB7XG4gICAgICAgICAgdGhpcy5fdmlld0ZhY3RvcnkgPSB2aWV3RmFjdG9yeTtcbiAgICAgICAgICB0aGlzLmlzQ29tcGlsZWQgPSB0cnVlO1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVkVGVtcGxhdGUucHJvdG90eXBlLmRlcHNDb21waWxlZCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5pc0NvbXBpbGVkV2l0aERlcHMgPSB0cnVlOyB9O1xuICAgICAgcmV0dXJuIENvbXBpbGVkVGVtcGxhdGU7XG4gIH0oKSk7XG4gIGZ1bmN0aW9uIGFzc2VydENvbXBvbmVudChtZXRhKSB7XG4gICAgICBpZiAoIW1ldGEuaXNDb21wb25lbnQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgY29tcGlsZSAnXCIgKyBtZXRhLnR5cGUubmFtZSArIFwiJyBiZWNhdXNlIGl0IGlzIG5vdCBhIGNvbXBvbmVudC5cIik7XG4gICAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEltcGxlbWVudHMgYENvbXBpbGVyYCBieSBkZWxlZ2F0aW5nIHRvIHRoZSBSdW50aW1lQ29tcGlsZXIgdXNpbmcgYSBrbm93biBtb2R1bGUuXG4gICAqL1xuICB2YXIgTW9kdWxlQm91bmRDb21waWxlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBNb2R1bGVCb3VuZENvbXBpbGVyKF9kZWxlZ2F0ZSwgX25nTW9kdWxlKSB7XG4gICAgICAgICAgdGhpcy5fZGVsZWdhdGUgPSBfZGVsZWdhdGU7XG4gICAgICAgICAgdGhpcy5fbmdNb2R1bGUgPSBfbmdNb2R1bGU7XG4gICAgICB9XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlQm91bmRDb21waWxlci5wcm90b3R5cGUsIFwiX2luamVjdG9yXCIsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RlbGVnYXRlLmluamVjdG9yOyB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIE1vZHVsZUJvdW5kQ29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGVNb2R1bGVTeW5jID0gZnVuY3Rpb24gKG1vZHVsZVR5cGUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZGVsZWdhdGUuY29tcGlsZU1vZHVsZVN5bmMobW9kdWxlVHlwZSk7XG4gICAgICB9O1xuICAgICAgTW9kdWxlQm91bmRDb21waWxlci5wcm90b3R5cGUuY29tcGlsZU1vZHVsZUFzeW5jID0gZnVuY3Rpb24gKG1vZHVsZVR5cGUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZGVsZWdhdGUuY29tcGlsZU1vZHVsZUFzeW5jKG1vZHVsZVR5cGUpO1xuICAgICAgfTtcbiAgICAgIE1vZHVsZUJvdW5kQ29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGVNb2R1bGVBbmRBbGxDb21wb25lbnRzU3luYyA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2RlbGVnYXRlLmNvbXBpbGVNb2R1bGVBbmRBbGxDb21wb25lbnRzU3luYyhtb2R1bGVUeXBlKTtcbiAgICAgIH07XG4gICAgICBNb2R1bGVCb3VuZENvbXBpbGVyLnByb3RvdHlwZS5jb21waWxlTW9kdWxlQW5kQWxsQ29tcG9uZW50c0FzeW5jID0gZnVuY3Rpb24gKG1vZHVsZVR5cGUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZGVsZWdhdGUuY29tcGlsZU1vZHVsZUFuZEFsbENvbXBvbmVudHNBc3luYyhtb2R1bGVUeXBlKTtcbiAgICAgIH07XG4gICAgICAvKipcbiAgICAgICAqIENsZWFycyBhbGwgY2FjaGVzXG4gICAgICAgKi9cbiAgICAgIE1vZHVsZUJvdW5kQ29tcGlsZXIucHJvdG90eXBlLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX2RlbGVnYXRlLmNsZWFyQ2FjaGUoKTsgfTtcbiAgICAgIC8qKlxuICAgICAgICogQ2xlYXJzIHRoZSBjYWNoZSBmb3IgdGhlIGdpdmVuIGNvbXBvbmVudC9uZ01vZHVsZS5cbiAgICAgICAqL1xuICAgICAgTW9kdWxlQm91bmRDb21waWxlci5wcm90b3R5cGUuY2xlYXJDYWNoZUZvciA9IGZ1bmN0aW9uICh0eXBlKSB7IHRoaXMuX2RlbGVnYXRlLmNsZWFyQ2FjaGVGb3IodHlwZSk7IH07XG4gICAgICByZXR1cm4gTW9kdWxlQm91bmRDb21waWxlcjtcbiAgfSgpKTtcblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gPT09PT09PT09PT0gUyBUIE8gUCAgIC0gIFMgVCBPIFAgICAtICBTIFQgTyBQICAgLSAgUyBUIE8gUCAgIC0gIFMgVCBPIFAgICAtICBTIFQgTyBQICA9PT09PT09PT09PVxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy9cbiAgLy8gICAgICAgIERPIE5PVCBFRElUIFRISVMgTElTVCBPRiBTRUNVUklUWSBTRU5TSVRJVkUgUFJPUEVSVElFUyBXSVRIT1VUIEEgU0VDVVJJVFkgUkVWSUVXIVxuICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFjaCBvdXQgdG8gbXByb2JzdCBmb3IgZGV0YWlscy5cbiAgLy9cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvKiogTWFwIGZyb20gdGFnTmFtZXxwcm9wZXJ0eU5hbWUgU2VjdXJpdHlDb250ZXh0LiBQcm9wZXJ0aWVzIGFwcGx5aW5nIHRvIGFsbCB0YWdzIHVzZSAnKicuICovXG4gIHZhciBTRUNVUklUWV9TQ0hFTUEgPSB7fTtcbiAgZnVuY3Rpb24gcmVnaXN0ZXJDb250ZXh0KGN0eCwgc3BlY3MpIHtcbiAgICAgIGZvciAodmFyIF9pID0gMCwgc3BlY3NfMSA9IHNwZWNzOyBfaSA8IHNwZWNzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgdmFyIHNwZWMgPSBzcGVjc18xW19pXTtcbiAgICAgICAgICBTRUNVUklUWV9TQ0hFTUFbc3BlYy50b0xvd2VyQ2FzZSgpXSA9IGN0eDtcbiAgICAgIH1cbiAgfVxuICAvLyBDYXNlIGlzIGluc2lnbmlmaWNhbnQgYmVsb3csIGFsbCBlbGVtZW50IGFuZCBhdHRyaWJ1dGUgbmFtZXMgYXJlIGxvd2VyLWNhc2VkIGZvciBsb29rdXAuXG4gIHJlZ2lzdGVyQ29udGV4dChfYW5ndWxhcl9jb3JlLlNlY3VyaXR5Q29udGV4dC5IVE1MLCBbXG4gICAgICAnaWZyYW1lfHNyY2RvYycsXG4gICAgICAnKnxpbm5lckhUTUwnLFxuICAgICAgJyp8b3V0ZXJIVE1MJyxcbiAgXSk7XG4gIHJlZ2lzdGVyQ29udGV4dChfYW5ndWxhcl9jb3JlLlNlY3VyaXR5Q29udGV4dC5TVFlMRSwgWycqfHN0eWxlJ10pO1xuICAvLyBOQjogbm8gU0NSSVBUIGNvbnRleHRzIGhlcmUsIHRoZXkgYXJlIG5ldmVyIGFsbG93ZWQgZHVlIHRvIHRoZSBwYXJzZXIgc3RyaXBwaW5nIHRoZW0uXG4gIHJlZ2lzdGVyQ29udGV4dChfYW5ndWxhcl9jb3JlLlNlY3VyaXR5Q29udGV4dC5VUkwsIFtcbiAgICAgICcqfGZvcm1BY3Rpb24nLCAnYXJlYXxocmVmJywgJ2FyZWF8cGluZycsICdhdWRpb3xzcmMnLCAnYXxocmVmJyxcbiAgICAgICdhfHBpbmcnLCAnYmxvY2txdW90ZXxjaXRlJywgJ2JvZHl8YmFja2dyb3VuZCcsICdkZWx8Y2l0ZScsICdmb3JtfGFjdGlvbicsXG4gICAgICAnaW1nfHNyYycsICdpbWd8c3Jjc2V0JywgJ2lucHV0fHNyYycsICdpbnN8Y2l0ZScsICdxfGNpdGUnLFxuICAgICAgJ3NvdXJjZXxzcmMnLCAnc291cmNlfHNyY3NldCcsICd0cmFja3xzcmMnLCAndmlkZW98cG9zdGVyJywgJ3ZpZGVvfHNyYycsXG4gIF0pO1xuICByZWdpc3RlckNvbnRleHQoX2FuZ3VsYXJfY29yZS5TZWN1cml0eUNvbnRleHQuUkVTT1VSQ0VfVVJMLCBbXG4gICAgICAnYXBwbGV0fGNvZGUnLFxuICAgICAgJ2FwcGxldHxjb2RlYmFzZScsXG4gICAgICAnYmFzZXxocmVmJyxcbiAgICAgICdlbWJlZHxzcmMnLFxuICAgICAgJ2ZyYW1lfHNyYycsXG4gICAgICAnaGVhZHxwcm9maWxlJyxcbiAgICAgICdodG1sfG1hbmlmZXN0JyxcbiAgICAgICdpZnJhbWV8c3JjJyxcbiAgICAgICdsaW5rfGhyZWYnLFxuICAgICAgJ21lZGlhfHNyYycsXG4gICAgICAnb2JqZWN0fGNvZGViYXNlJyxcbiAgICAgICdvYmplY3R8ZGF0YScsXG4gICAgICAnc2NyaXB0fHNyYycsXG4gIF0pO1xuXG4gIC8qKlxuICAgKiBAbGljZW5zZVxuICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICpcbiAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgKi9cbiAgdmFyIF9fZXh0ZW5kcyQyMCA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgfTtcbiAgdmFyIEJPT0xFQU4gPSAnYm9vbGVhbic7XG4gIHZhciBOVU1CRVIgPSAnbnVtYmVyJztcbiAgdmFyIFNUUklORyA9ICdzdHJpbmcnO1xuICB2YXIgT0JKRUNUID0gJ29iamVjdCc7XG4gIC8qKlxuICAgKiBUaGlzIGFycmF5IHJlcHJlc2VudHMgdGhlIERPTSBzY2hlbWEuIEl0IGVuY29kZXMgaW5oZXJpdGFuY2UsIHByb3BlcnRpZXMsIGFuZCBldmVudHMuXG4gICAqXG4gICAqICMjIE92ZXJ2aWV3XG4gICAqXG4gICAqIEVhY2ggbGluZSByZXByZXNlbnRzIG9uZSBraW5kIG9mIGVsZW1lbnQuIFRoZSBgZWxlbWVudF9pbmhlcml0YW5jZWAgYW5kIHByb3BlcnRpZXMgYXJlIGpvaW5lZFxuICAgKiB1c2luZyBgZWxlbWVudF9pbmhlcml0YW5jZXxwcm9wZXJ0aWVzYCBzeW50YXguXG4gICAqXG4gICAqICMjIEVsZW1lbnQgSW5oZXJpdGFuY2VcbiAgICpcbiAgICogVGhlIGBlbGVtZW50X2luaGVyaXRhbmNlYCBjYW4gYmUgZnVydGhlciBzdWJkaXZpZGVkIGFzIGBlbGVtZW50MSxlbGVtZW50MiwuLi5ecGFyZW50RWxlbWVudGAuXG4gICAqIEhlcmUgdGhlIGluZGl2aWR1YWwgZWxlbWVudHMgYXJlIHNlcGFyYXRlZCBieSBgLGAgKGNvbW1hcykuIEV2ZXJ5IGVsZW1lbnQgaW4gdGhlIGxpc3RcbiAgICogaGFzIGlkZW50aWNhbCBwcm9wZXJ0aWVzLlxuICAgKlxuICAgKiBBbiBgZWxlbWVudGAgbWF5IGluaGVyaXQgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIGZyb20gYHBhcmVudEVsZW1lbnRgIElmIG5vIGBecGFyZW50RWxlbWVudGAgaXNcbiAgICogc3BlY2lmaWVkIHRoZW4gYFwiXCJgIChibGFuaykgZWxlbWVudCBpcyBhc3N1bWVkLlxuICAgKlxuICAgKiBOT1RFOiBUaGUgYmxhbmsgZWxlbWVudCBpbmhlcml0cyBmcm9tIHJvb3QgYFtFbGVtZW50XWAgZWxlbWVudCwgdGhlIHN1cGVyIGVsZW1lbnQgb2YgYWxsXG4gICAqIGVsZW1lbnRzLlxuICAgKlxuICAgKiBOT1RFIGFuIGVsZW1lbnQgcHJlZml4IHN1Y2ggYXMgYDpzdmc6YCBoYXMgbm8gc3BlY2lhbCBtZWFuaW5nIHRvIHRoZSBzY2hlbWEuXG4gICAqXG4gICAqICMjIFByb3BlcnRpZXNcbiAgICpcbiAgICogRWFjaCBlbGVtZW50IGhhcyBhIHNldCBvZiBwcm9wZXJ0aWVzIHNlcGFyYXRlZCBieSBgLGAgKGNvbW1hcykuIEVhY2ggcHJvcGVydHkgY2FuIGJlIHByZWZpeGVkXG4gICAqIGJ5IGEgc3BlY2lhbCBjaGFyYWN0ZXIgZGVzaWduYXRpbmcgaXRzIHR5cGU6XG4gICAqXG4gICAqIC0gKG5vIHByZWZpeCk6IHByb3BlcnR5IGlzIGEgc3RyaW5nLlxuICAgKiAtIGAqYDogcHJvcGVydHkgcmVwcmVzZW50cyBhbiBldmVudC5cbiAgICogLSBgIWA6IHByb3BlcnR5IGlzIGEgYm9vbGVhbi5cbiAgICogLSBgI2A6IHByb3BlcnR5IGlzIGEgbnVtYmVyLlxuICAgKiAtIGAlYDogcHJvcGVydHkgaXMgYW4gb2JqZWN0LlxuICAgKlxuICAgKiAjIyBRdWVyeVxuICAgKlxuICAgKiBUaGUgY2xhc3MgY3JlYXRlcyBhbiBpbnRlcm5hbCBzcXVhcyByZXByZXNlbnRhdGlvbiB3aGljaCBhbGxvd3MgdG8gZWFzaWx5IGFuc3dlciB0aGUgcXVlcnkgb2ZcbiAgICogaWYgYSBnaXZlbiBwcm9wZXJ0eSBleGlzdCBvbiBhIGdpdmVuIGVsZW1lbnQuXG4gICAqXG4gICAqIE5PVEU6IFdlIGRvbid0IHlldCBzdXBwb3J0IHF1ZXJ5aW5nIGZvciB0eXBlcyBvciBldmVudHMuXG4gICAqIE5PVEU6IFRoaXMgc2NoZW1hIGlzIGF1dG8gZXh0cmFjdGVkIGZyb20gYHNjaGVtYV9leHRyYWN0b3IudHNgIGxvY2F0ZWQgaW4gdGhlIHRlc3QgZm9sZGVyLFxuICAgKiAgICAgICBzZWUgZG9tX2VsZW1lbnRfc2NoZW1hX3JlZ2lzdHJ5X3NwZWMudHNcbiAgICovXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyA9PT09PT09PT09PSBTIFQgTyBQICAgLSAgUyBUIE8gUCAgIC0gIFMgVCBPIFAgICAtICBTIFQgTyBQICAgLSAgUyBUIE8gUCAgIC0gIFMgVCBPIFAgID09PT09PT09PT09XG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvL1xuICAvLyAgICAgICAgICAgICAgICAgICAgICAgRE8gTk9UIEVESVQgVEhJUyBET00gU0NIRU1BIFdJVEhPVVQgQSBTRUNVUklUWSBSRVZJRVchXG4gIC8vXG4gIC8vIE5ld2x5IGFkZGVkIHByb3BlcnRpZXMgbXVzdCBiZSBzZWN1cml0eSByZXZpZXdlZCBhbmQgYXNzaWduZWQgYW4gYXBwcm9wcmlhdGUgU2VjdXJpdHlDb250ZXh0IGluXG4gIC8vIGRvbV9zZWN1cml0eV9zY2hlbWEudHMuIFJlYWNoIG91dCB0byBtcHJvYnN0ICYgcmphbWV0IGZvciBkZXRhaWxzLlxuICAvL1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIHZhciBTQ0hFTUEgPSBbXG4gICAgICAnW0VsZW1lbnRdfHRleHRDb250ZW50LCVjbGFzc0xpc3QsY2xhc3NOYW1lLGlkLGlubmVySFRNTCwqYmVmb3JlY29weSwqYmVmb3JlY3V0LCpiZWZvcmVwYXN0ZSwqY29weSwqY3V0LCpwYXN0ZSwqc2VhcmNoLCpzZWxlY3RzdGFydCwqd2Via2l0ZnVsbHNjcmVlbmNoYW5nZSwqd2Via2l0ZnVsbHNjcmVlbmVycm9yLCp3aGVlbCxvdXRlckhUTUwsI3Njcm9sbExlZnQsI3Njcm9sbFRvcCcsXG4gICAgICAnW0hUTUxFbGVtZW50XV5bRWxlbWVudF18YWNjZXNzS2V5LGNvbnRlbnRFZGl0YWJsZSxkaXIsIWRyYWdnYWJsZSwhaGlkZGVuLGlubmVyVGV4dCxsYW5nLCphYm9ydCwqYmVmb3JlY29weSwqYmVmb3JlY3V0LCpiZWZvcmVwYXN0ZSwqYmx1ciwqY2FuY2VsLCpjYW5wbGF5LCpjYW5wbGF5dGhyb3VnaCwqY2hhbmdlLCpjbGljaywqY2xvc2UsKmNvbnRleHRtZW51LCpjb3B5LCpjdWVjaGFuZ2UsKmN1dCwqZGJsY2xpY2ssKmRyYWcsKmRyYWdlbmQsKmRyYWdlbnRlciwqZHJhZ2xlYXZlLCpkcmFnb3ZlciwqZHJhZ3N0YXJ0LCpkcm9wLCpkdXJhdGlvbmNoYW5nZSwqZW1wdGllZCwqZW5kZWQsKmVycm9yLCpmb2N1cywqaW5wdXQsKmludmFsaWQsKmtleWRvd24sKmtleXByZXNzLCprZXl1cCwqbG9hZCwqbG9hZGVkZGF0YSwqbG9hZGVkbWV0YWRhdGEsKmxvYWRzdGFydCwqbWVzc2FnZSwqbW91c2Vkb3duLCptb3VzZWVudGVyLCptb3VzZWxlYXZlLCptb3VzZW1vdmUsKm1vdXNlb3V0LCptb3VzZW92ZXIsKm1vdXNldXAsKm1vdXNld2hlZWwsKm1vemZ1bGxzY3JlZW5jaGFuZ2UsKm1vemZ1bGxzY3JlZW5lcnJvciwqbW96cG9pbnRlcmxvY2tjaGFuZ2UsKm1venBvaW50ZXJsb2NrZXJyb3IsKnBhc3RlLCpwYXVzZSwqcGxheSwqcGxheWluZywqcHJvZ3Jlc3MsKnJhdGVjaGFuZ2UsKnJlc2V0LCpyZXNpemUsKnNjcm9sbCwqc2VhcmNoLCpzZWVrZWQsKnNlZWtpbmcsKnNlbGVjdCwqc2VsZWN0c3RhcnQsKnNob3csKnN0YWxsZWQsKnN1Ym1pdCwqc3VzcGVuZCwqdGltZXVwZGF0ZSwqdG9nZ2xlLCp2b2x1bWVjaGFuZ2UsKndhaXRpbmcsKndlYmdsY29udGV4dGNyZWF0aW9uZXJyb3IsKndlYmdsY29udGV4dGxvc3QsKndlYmdsY29udGV4dHJlc3RvcmVkLCp3ZWJraXRmdWxsc2NyZWVuY2hhbmdlLCp3ZWJraXRmdWxsc2NyZWVuZXJyb3IsKndoZWVsLG91dGVyVGV4dCwhc3BlbGxjaGVjaywlc3R5bGUsI3RhYkluZGV4LHRpdGxlLCF0cmFuc2xhdGUnLFxuICAgICAgJ2FiYnIsYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGIsYmRpLGJkbyxjaXRlLGNvZGUsZGQsZGZuLGR0LGVtLGZpZ2NhcHRpb24sZmlndXJlLGZvb3RlcixoZWFkZXIsaSxrYmQsbWFpbixtYXJrLG5hdixub3NjcmlwdCxyYixycCxydCxydGMscnVieSxzLHNhbXAsc2VjdGlvbixzbWFsbCxzdHJvbmcsc3ViLHN1cCx1LHZhcix3YnJeW0hUTUxFbGVtZW50XXxhY2Nlc3NLZXksY29udGVudEVkaXRhYmxlLGRpciwhZHJhZ2dhYmxlLCFoaWRkZW4saW5uZXJUZXh0LGxhbmcsKmFib3J0LCpiZWZvcmVjb3B5LCpiZWZvcmVjdXQsKmJlZm9yZXBhc3RlLCpibHVyLCpjYW5jZWwsKmNhbnBsYXksKmNhbnBsYXl0aHJvdWdoLCpjaGFuZ2UsKmNsaWNrLCpjbG9zZSwqY29udGV4dG1lbnUsKmNvcHksKmN1ZWNoYW5nZSwqY3V0LCpkYmxjbGljaywqZHJhZywqZHJhZ2VuZCwqZHJhZ2VudGVyLCpkcmFnbGVhdmUsKmRyYWdvdmVyLCpkcmFnc3RhcnQsKmRyb3AsKmR1cmF0aW9uY2hhbmdlLCplbXB0aWVkLCplbmRlZCwqZXJyb3IsKmZvY3VzLCppbnB1dCwqaW52YWxpZCwqa2V5ZG93biwqa2V5cHJlc3MsKmtleXVwLCpsb2FkLCpsb2FkZWRkYXRhLCpsb2FkZWRtZXRhZGF0YSwqbG9hZHN0YXJ0LCptZXNzYWdlLCptb3VzZWRvd24sKm1vdXNlZW50ZXIsKm1vdXNlbGVhdmUsKm1vdXNlbW92ZSwqbW91c2VvdXQsKm1vdXNlb3ZlciwqbW91c2V1cCwqbW91c2V3aGVlbCwqbW96ZnVsbHNjcmVlbmNoYW5nZSwqbW96ZnVsbHNjcmVlbmVycm9yLCptb3pwb2ludGVybG9ja2NoYW5nZSwqbW96cG9pbnRlcmxvY2tlcnJvciwqcGFzdGUsKnBhdXNlLCpwbGF5LCpwbGF5aW5nLCpwcm9ncmVzcywqcmF0ZWNoYW5nZSwqcmVzZXQsKnJlc2l6ZSwqc2Nyb2xsLCpzZWFyY2gsKnNlZWtlZCwqc2Vla2luZywqc2VsZWN0LCpzZWxlY3RzdGFydCwqc2hvdywqc3RhbGxlZCwqc3VibWl0LCpzdXNwZW5kLCp0aW1ldXBkYXRlLCp0b2dnbGUsKnZvbHVtZWNoYW5nZSwqd2FpdGluZywqd2ViZ2xjb250ZXh0Y3JlYXRpb25lcnJvciwqd2ViZ2xjb250ZXh0bG9zdCwqd2ViZ2xjb250ZXh0cmVzdG9yZWQsKndlYmtpdGZ1bGxzY3JlZW5jaGFuZ2UsKndlYmtpdGZ1bGxzY3JlZW5lcnJvciwqd2hlZWwsb3V0ZXJUZXh0LCFzcGVsbGNoZWNrLCVzdHlsZSwjdGFiSW5kZXgsdGl0bGUsIXRyYW5zbGF0ZScsXG4gICAgICAnbWVkaWFeW0hUTUxFbGVtZW50XXwhYXV0b3BsYXksIWNvbnRyb2xzLCVjcm9zc09yaWdpbiwjY3VycmVudFRpbWUsIWRlZmF1bHRNdXRlZCwjZGVmYXVsdFBsYXliYWNrUmF0ZSwhZGlzYWJsZVJlbW90ZVBsYXliYWNrLCFsb29wLCFtdXRlZCwqZW5jcnlwdGVkLCNwbGF5YmFja1JhdGUscHJlbG9hZCxzcmMsJXNyY09iamVjdCwjdm9sdW1lJyxcbiAgICAgICc6c3ZnOl5bSFRNTEVsZW1lbnRdfCphYm9ydCwqYmx1ciwqY2FuY2VsLCpjYW5wbGF5LCpjYW5wbGF5dGhyb3VnaCwqY2hhbmdlLCpjbGljaywqY2xvc2UsKmNvbnRleHRtZW51LCpjdWVjaGFuZ2UsKmRibGNsaWNrLCpkcmFnLCpkcmFnZW5kLCpkcmFnZW50ZXIsKmRyYWdsZWF2ZSwqZHJhZ292ZXIsKmRyYWdzdGFydCwqZHJvcCwqZHVyYXRpb25jaGFuZ2UsKmVtcHRpZWQsKmVuZGVkLCplcnJvciwqZm9jdXMsKmlucHV0LCppbnZhbGlkLCprZXlkb3duLCprZXlwcmVzcywqa2V5dXAsKmxvYWQsKmxvYWRlZGRhdGEsKmxvYWRlZG1ldGFkYXRhLCpsb2Fkc3RhcnQsKm1vdXNlZG93biwqbW91c2VlbnRlciwqbW91c2VsZWF2ZSwqbW91c2Vtb3ZlLCptb3VzZW91dCwqbW91c2VvdmVyLCptb3VzZXVwLCptb3VzZXdoZWVsLCpwYXVzZSwqcGxheSwqcGxheWluZywqcHJvZ3Jlc3MsKnJhdGVjaGFuZ2UsKnJlc2V0LCpyZXNpemUsKnNjcm9sbCwqc2Vla2VkLCpzZWVraW5nLCpzZWxlY3QsKnNob3csKnN0YWxsZWQsKnN1Ym1pdCwqc3VzcGVuZCwqdGltZXVwZGF0ZSwqdG9nZ2xlLCp2b2x1bWVjaGFuZ2UsKndhaXRpbmcsJXN0eWxlLCN0YWJJbmRleCcsXG4gICAgICAnOnN2ZzpncmFwaGljc146c3ZnOnwnLFxuICAgICAgJzpzdmc6YW5pbWF0aW9uXjpzdmc6fCpiZWdpbiwqZW5kLCpyZXBlYXQnLFxuICAgICAgJzpzdmc6Z2VvbWV0cnleOnN2Zzp8JyxcbiAgICAgICc6c3ZnOmNvbXBvbmVudFRyYW5zZmVyRnVuY3Rpb25eOnN2Zzp8JyxcbiAgICAgICc6c3ZnOmdyYWRpZW50Xjpzdmc6fCcsXG4gICAgICAnOnN2Zzp0ZXh0Q29udGVudF46c3ZnOmdyYXBoaWNzfCcsXG4gICAgICAnOnN2Zzp0ZXh0UG9zaXRpb25pbmdeOnN2Zzp0ZXh0Q29udGVudHwnLFxuICAgICAgJ2FeW0hUTUxFbGVtZW50XXxjaGFyc2V0LGNvb3Jkcyxkb3dubG9hZCxoYXNoLGhvc3QsaG9zdG5hbWUsaHJlZixocmVmbGFuZyxuYW1lLHBhc3N3b3JkLHBhdGhuYW1lLHBpbmcscG9ydCxwcm90b2NvbCxyZWZlcnJlclBvbGljeSxyZWwscmV2LHNlYXJjaCxzaGFwZSx0YXJnZXQsdGV4dCx0eXBlLHVzZXJuYW1lJyxcbiAgICAgICdhcmVhXltIVE1MRWxlbWVudF18YWx0LGNvb3JkcyxoYXNoLGhvc3QsaG9zdG5hbWUsaHJlZiwhbm9IcmVmLHBhc3N3b3JkLHBhdGhuYW1lLHBpbmcscG9ydCxwcm90b2NvbCxyZWZlcnJlclBvbGljeSxzZWFyY2gsc2hhcGUsdGFyZ2V0LHVzZXJuYW1lJyxcbiAgICAgICdhdWRpb15tZWRpYXwnLFxuICAgICAgJ2JyXltIVE1MRWxlbWVudF18Y2xlYXInLFxuICAgICAgJ2Jhc2VeW0hUTUxFbGVtZW50XXxocmVmLHRhcmdldCcsXG4gICAgICAnYm9keV5bSFRNTEVsZW1lbnRdfGFMaW5rLGJhY2tncm91bmQsYmdDb2xvcixsaW5rLCpiZWZvcmV1bmxvYWQsKmJsdXIsKmVycm9yLCpmb2N1cywqaGFzaGNoYW5nZSwqbGFuZ3VhZ2VjaGFuZ2UsKmxvYWQsKm1lc3NhZ2UsKm9mZmxpbmUsKm9ubGluZSwqcGFnZWhpZGUsKnBhZ2VzaG93LCpwb3BzdGF0ZSwqcmVqZWN0aW9uaGFuZGxlZCwqcmVzaXplLCpzY3JvbGwsKnN0b3JhZ2UsKnVuaGFuZGxlZHJlamVjdGlvbiwqdW5sb2FkLHRleHQsdkxpbmsnLFxuICAgICAgJ2J1dHRvbl5bSFRNTEVsZW1lbnRdfCFhdXRvZm9jdXMsIWRpc2FibGVkLGZvcm1BY3Rpb24sZm9ybUVuY3R5cGUsZm9ybU1ldGhvZCwhZm9ybU5vVmFsaWRhdGUsZm9ybVRhcmdldCxuYW1lLHR5cGUsdmFsdWUnLFxuICAgICAgJ2NhbnZhc15bSFRNTEVsZW1lbnRdfCNoZWlnaHQsI3dpZHRoJyxcbiAgICAgICdjb250ZW50XltIVE1MRWxlbWVudF18c2VsZWN0JyxcbiAgICAgICdkbF5bSFRNTEVsZW1lbnRdfCFjb21wYWN0JyxcbiAgICAgICdkYXRhbGlzdF5bSFRNTEVsZW1lbnRdfCcsXG4gICAgICAnZGV0YWlsc15bSFRNTEVsZW1lbnRdfCFvcGVuJyxcbiAgICAgICdkaWFsb2deW0hUTUxFbGVtZW50XXwhb3BlbixyZXR1cm5WYWx1ZScsXG4gICAgICAnZGlyXltIVE1MRWxlbWVudF18IWNvbXBhY3QnLFxuICAgICAgJ2Rpdl5bSFRNTEVsZW1lbnRdfGFsaWduJyxcbiAgICAgICdlbWJlZF5bSFRNTEVsZW1lbnRdfGFsaWduLGhlaWdodCxuYW1lLHNyYyx0eXBlLHdpZHRoJyxcbiAgICAgICdmaWVsZHNldF5bSFRNTEVsZW1lbnRdfCFkaXNhYmxlZCxuYW1lJyxcbiAgICAgICdmb250XltIVE1MRWxlbWVudF18Y29sb3IsZmFjZSxzaXplJyxcbiAgICAgICdmb3JtXltIVE1MRWxlbWVudF18YWNjZXB0Q2hhcnNldCxhY3Rpb24sYXV0b2NvbXBsZXRlLGVuY29kaW5nLGVuY3R5cGUsbWV0aG9kLG5hbWUsIW5vVmFsaWRhdGUsdGFyZ2V0JyxcbiAgICAgICdmcmFtZV5bSFRNTEVsZW1lbnRdfGZyYW1lQm9yZGVyLGxvbmdEZXNjLG1hcmdpbkhlaWdodCxtYXJnaW5XaWR0aCxuYW1lLCFub1Jlc2l6ZSxzY3JvbGxpbmcsc3JjJyxcbiAgICAgICdmcmFtZXNldF5bSFRNTEVsZW1lbnRdfGNvbHMsKmJlZm9yZXVubG9hZCwqYmx1ciwqZXJyb3IsKmZvY3VzLCpoYXNoY2hhbmdlLCpsYW5ndWFnZWNoYW5nZSwqbG9hZCwqbWVzc2FnZSwqb2ZmbGluZSwqb25saW5lLCpwYWdlaGlkZSwqcGFnZXNob3csKnBvcHN0YXRlLCpyZWplY3Rpb25oYW5kbGVkLCpyZXNpemUsKnNjcm9sbCwqc3RvcmFnZSwqdW5oYW5kbGVkcmVqZWN0aW9uLCp1bmxvYWQscm93cycsXG4gICAgICAnaHJeW0hUTUxFbGVtZW50XXxhbGlnbixjb2xvciwhbm9TaGFkZSxzaXplLHdpZHRoJyxcbiAgICAgICdoZWFkXltIVE1MRWxlbWVudF18JyxcbiAgICAgICdoMSxoMixoMyxoNCxoNSxoNl5bSFRNTEVsZW1lbnRdfGFsaWduJyxcbiAgICAgICdodG1sXltIVE1MRWxlbWVudF18dmVyc2lvbicsXG4gICAgICAnaWZyYW1lXltIVE1MRWxlbWVudF18YWxpZ24sIWFsbG93RnVsbHNjcmVlbixmcmFtZUJvcmRlcixoZWlnaHQsbG9uZ0Rlc2MsbWFyZ2luSGVpZ2h0LG1hcmdpbldpZHRoLG5hbWUscmVmZXJyZXJQb2xpY3ksJXNhbmRib3gsc2Nyb2xsaW5nLHNyYyxzcmNkb2Msd2lkdGgnLFxuICAgICAgJ2ltZ15bSFRNTEVsZW1lbnRdfGFsaWduLGFsdCxib3JkZXIsJWNyb3NzT3JpZ2luLCNoZWlnaHQsI2hzcGFjZSwhaXNNYXAsbG9uZ0Rlc2MsbG93c3JjLG5hbWUscmVmZXJyZXJQb2xpY3ksc2l6ZXMsc3JjLHNyY3NldCx1c2VNYXAsI3ZzcGFjZSwjd2lkdGgnLFxuICAgICAgJ2lucHV0XltIVE1MRWxlbWVudF18YWNjZXB0LGFsaWduLGFsdCxhdXRvY2FwaXRhbGl6ZSxhdXRvY29tcGxldGUsIWF1dG9mb2N1cywhY2hlY2tlZCwhZGVmYXVsdENoZWNrZWQsZGVmYXVsdFZhbHVlLGRpck5hbWUsIWRpc2FibGVkLCVmaWxlcyxmb3JtQWN0aW9uLGZvcm1FbmN0eXBlLGZvcm1NZXRob2QsIWZvcm1Ob1ZhbGlkYXRlLGZvcm1UYXJnZXQsI2hlaWdodCwhaW5jcmVtZW50YWwsIWluZGV0ZXJtaW5hdGUsbWF4LCNtYXhMZW5ndGgsbWluLCNtaW5MZW5ndGgsIW11bHRpcGxlLG5hbWUscGF0dGVybixwbGFjZWhvbGRlciwhcmVhZE9ubHksIXJlcXVpcmVkLHNlbGVjdGlvbkRpcmVjdGlvbiwjc2VsZWN0aW9uRW5kLCNzZWxlY3Rpb25TdGFydCwjc2l6ZSxzcmMsc3RlcCx0eXBlLHVzZU1hcCx2YWx1ZSwldmFsdWVBc0RhdGUsI3ZhbHVlQXNOdW1iZXIsI3dpZHRoJyxcbiAgICAgICdrZXlnZW5eW0hUTUxFbGVtZW50XXwhYXV0b2ZvY3VzLGNoYWxsZW5nZSwhZGlzYWJsZWQsa2V5dHlwZSxuYW1lJyxcbiAgICAgICdsaV5bSFRNTEVsZW1lbnRdfHR5cGUsI3ZhbHVlJyxcbiAgICAgICdsYWJlbF5bSFRNTEVsZW1lbnRdfGh0bWxGb3InLFxuICAgICAgJ2xlZ2VuZF5bSFRNTEVsZW1lbnRdfGFsaWduJyxcbiAgICAgICdsaW5rXltIVE1MRWxlbWVudF18YXMsY2hhcnNldCwlY3Jvc3NPcmlnaW4sIWRpc2FibGVkLGhyZWYsaHJlZmxhbmcsaW50ZWdyaXR5LG1lZGlhLHJlbCwlcmVsTGlzdCxyZXYsJXNpemVzLHRhcmdldCx0eXBlJyxcbiAgICAgICdtYXBeW0hUTUxFbGVtZW50XXxuYW1lJyxcbiAgICAgICdtYXJxdWVlXltIVE1MRWxlbWVudF18YmVoYXZpb3IsYmdDb2xvcixkaXJlY3Rpb24saGVpZ2h0LCNoc3BhY2UsI2xvb3AsI3Njcm9sbEFtb3VudCwjc2Nyb2xsRGVsYXksIXRydWVTcGVlZCwjdnNwYWNlLHdpZHRoJyxcbiAgICAgICdtZW51XltIVE1MRWxlbWVudF18IWNvbXBhY3QnLFxuICAgICAgJ21ldGFeW0hUTUxFbGVtZW50XXxjb250ZW50LGh0dHBFcXVpdixuYW1lLHNjaGVtZScsXG4gICAgICAnbWV0ZXJeW0hUTUxFbGVtZW50XXwjaGlnaCwjbG93LCNtYXgsI21pbiwjb3B0aW11bSwjdmFsdWUnLFxuICAgICAgJ2lucyxkZWxeW0hUTUxFbGVtZW50XXxjaXRlLGRhdGVUaW1lJyxcbiAgICAgICdvbF5bSFRNTEVsZW1lbnRdfCFjb21wYWN0LCFyZXZlcnNlZCwjc3RhcnQsdHlwZScsXG4gICAgICAnb2JqZWN0XltIVE1MRWxlbWVudF18YWxpZ24sYXJjaGl2ZSxib3JkZXIsY29kZSxjb2RlQmFzZSxjb2RlVHlwZSxkYXRhLCFkZWNsYXJlLGhlaWdodCwjaHNwYWNlLG5hbWUsc3RhbmRieSx0eXBlLHVzZU1hcCwjdnNwYWNlLHdpZHRoJyxcbiAgICAgICdvcHRncm91cF5bSFRNTEVsZW1lbnRdfCFkaXNhYmxlZCxsYWJlbCcsXG4gICAgICAnb3B0aW9uXltIVE1MRWxlbWVudF18IWRlZmF1bHRTZWxlY3RlZCwhZGlzYWJsZWQsbGFiZWwsIXNlbGVjdGVkLHRleHQsdmFsdWUnLFxuICAgICAgJ291dHB1dF5bSFRNTEVsZW1lbnRdfGRlZmF1bHRWYWx1ZSwlaHRtbEZvcixuYW1lLHZhbHVlJyxcbiAgICAgICdwXltIVE1MRWxlbWVudF18YWxpZ24nLFxuICAgICAgJ3BhcmFtXltIVE1MRWxlbWVudF18bmFtZSx0eXBlLHZhbHVlLHZhbHVlVHlwZScsXG4gICAgICAncGljdHVyZV5bSFRNTEVsZW1lbnRdfCcsXG4gICAgICAncHJlXltIVE1MRWxlbWVudF18I3dpZHRoJyxcbiAgICAgICdwcm9ncmVzc15bSFRNTEVsZW1lbnRdfCNtYXgsI3ZhbHVlJyxcbiAgICAgICdxLGJsb2NrcXVvdGUsY2l0ZV5bSFRNTEVsZW1lbnRdfCcsXG4gICAgICAnc2NyaXB0XltIVE1MRWxlbWVudF18IWFzeW5jLGNoYXJzZXQsJWNyb3NzT3JpZ2luLCFkZWZlcixldmVudCxodG1sRm9yLGludGVncml0eSxzcmMsdGV4dCx0eXBlJyxcbiAgICAgICdzZWxlY3ReW0hUTUxFbGVtZW50XXwhYXV0b2ZvY3VzLCFkaXNhYmxlZCwjbGVuZ3RoLCFtdWx0aXBsZSxuYW1lLCFyZXF1aXJlZCwjc2VsZWN0ZWRJbmRleCwjc2l6ZSx2YWx1ZScsXG4gICAgICAnc2hhZG93XltIVE1MRWxlbWVudF18JyxcbiAgICAgICdzb3VyY2VeW0hUTUxFbGVtZW50XXxtZWRpYSxzaXplcyxzcmMsc3Jjc2V0LHR5cGUnLFxuICAgICAgJ3NwYW5eW0hUTUxFbGVtZW50XXwnLFxuICAgICAgJ3N0eWxlXltIVE1MRWxlbWVudF18IWRpc2FibGVkLG1lZGlhLHR5cGUnLFxuICAgICAgJ2NhcHRpb25eW0hUTUxFbGVtZW50XXxhbGlnbicsXG4gICAgICAndGgsdGReW0hUTUxFbGVtZW50XXxhYmJyLGFsaWduLGF4aXMsYmdDb2xvcixjaCxjaE9mZiwjY29sU3BhbixoZWFkZXJzLGhlaWdodCwhbm9XcmFwLCNyb3dTcGFuLHNjb3BlLHZBbGlnbix3aWR0aCcsXG4gICAgICAnY29sLGNvbGdyb3VwXltIVE1MRWxlbWVudF18YWxpZ24sY2gsY2hPZmYsI3NwYW4sdkFsaWduLHdpZHRoJyxcbiAgICAgICd0YWJsZV5bSFRNTEVsZW1lbnRdfGFsaWduLGJnQ29sb3IsYm9yZGVyLCVjYXB0aW9uLGNlbGxQYWRkaW5nLGNlbGxTcGFjaW5nLGZyYW1lLHJ1bGVzLHN1bW1hcnksJXRGb290LCV0SGVhZCx3aWR0aCcsXG4gICAgICAndHJeW0hUTUxFbGVtZW50XXxhbGlnbixiZ0NvbG9yLGNoLGNoT2ZmLHZBbGlnbicsXG4gICAgICAndGZvb3QsdGhlYWQsdGJvZHleW0hUTUxFbGVtZW50XXxhbGlnbixjaCxjaE9mZix2QWxpZ24nLFxuICAgICAgJ3RlbXBsYXRlXltIVE1MRWxlbWVudF18JyxcbiAgICAgICd0ZXh0YXJlYV5bSFRNTEVsZW1lbnRdfGF1dG9jYXBpdGFsaXplLCFhdXRvZm9jdXMsI2NvbHMsZGVmYXVsdFZhbHVlLGRpck5hbWUsIWRpc2FibGVkLCNtYXhMZW5ndGgsI21pbkxlbmd0aCxuYW1lLHBsYWNlaG9sZGVyLCFyZWFkT25seSwhcmVxdWlyZWQsI3Jvd3Msc2VsZWN0aW9uRGlyZWN0aW9uLCNzZWxlY3Rpb25FbmQsI3NlbGVjdGlvblN0YXJ0LHZhbHVlLHdyYXAnLFxuICAgICAgJ3RpdGxlXltIVE1MRWxlbWVudF18dGV4dCcsXG4gICAgICAndHJhY2teW0hUTUxFbGVtZW50XXwhZGVmYXVsdCxraW5kLGxhYmVsLHNyYyxzcmNsYW5nJyxcbiAgICAgICd1bF5bSFRNTEVsZW1lbnRdfCFjb21wYWN0LHR5cGUnLFxuICAgICAgJ3Vua25vd25eW0hUTUxFbGVtZW50XXwnLFxuICAgICAgJ3ZpZGVvXm1lZGlhfCNoZWlnaHQscG9zdGVyLCN3aWR0aCcsXG4gICAgICAnOnN2ZzphXjpzdmc6Z3JhcGhpY3N8JyxcbiAgICAgICc6c3ZnOmFuaW1hdGVeOnN2ZzphbmltYXRpb258JyxcbiAgICAgICc6c3ZnOmFuaW1hdGVNb3Rpb25eOnN2ZzphbmltYXRpb258JyxcbiAgICAgICc6c3ZnOmFuaW1hdGVUcmFuc2Zvcm1eOnN2ZzphbmltYXRpb258JyxcbiAgICAgICc6c3ZnOmNpcmNsZV46c3ZnOmdlb21ldHJ5fCcsXG4gICAgICAnOnN2ZzpjbGlwUGF0aF46c3ZnOmdyYXBoaWNzfCcsXG4gICAgICAnOnN2ZzpjdXJzb3JeOnN2Zzp8JyxcbiAgICAgICc6c3ZnOmRlZnNeOnN2ZzpncmFwaGljc3wnLFxuICAgICAgJzpzdmc6ZGVzY146c3ZnOnwnLFxuICAgICAgJzpzdmc6ZGlzY2FyZF46c3ZnOnwnLFxuICAgICAgJzpzdmc6ZWxsaXBzZV46c3ZnOmdlb21ldHJ5fCcsXG4gICAgICAnOnN2ZzpmZUJsZW5kXjpzdmc6fCcsXG4gICAgICAnOnN2ZzpmZUNvbG9yTWF0cml4Xjpzdmc6fCcsXG4gICAgICAnOnN2ZzpmZUNvbXBvbmVudFRyYW5zZmVyXjpzdmc6fCcsXG4gICAgICAnOnN2ZzpmZUNvbXBvc2l0ZV46c3ZnOnwnLFxuICAgICAgJzpzdmc6ZmVDb252b2x2ZU1hdHJpeF46c3ZnOnwnLFxuICAgICAgJzpzdmc6ZmVEaWZmdXNlTGlnaHRpbmdeOnN2Zzp8JyxcbiAgICAgICc6c3ZnOmZlRGlzcGxhY2VtZW50TWFwXjpzdmc6fCcsXG4gICAgICAnOnN2ZzpmZURpc3RhbnRMaWdodF46c3ZnOnwnLFxuICAgICAgJzpzdmc6ZmVEcm9wU2hhZG93Xjpzdmc6fCcsXG4gICAgICAnOnN2ZzpmZUZsb29kXjpzdmc6fCcsXG4gICAgICAnOnN2ZzpmZUZ1bmNBXjpzdmc6Y29tcG9uZW50VHJhbnNmZXJGdW5jdGlvbnwnLFxuICAgICAgJzpzdmc6ZmVGdW5jQl46c3ZnOmNvbXBvbmVudFRyYW5zZmVyRnVuY3Rpb258JyxcbiAgICAgICc6c3ZnOmZlRnVuY0deOnN2Zzpjb21wb25lbnRUcmFuc2ZlckZ1bmN0aW9ufCcsXG4gICAgICAnOnN2ZzpmZUZ1bmNSXjpzdmc6Y29tcG9uZW50VHJhbnNmZXJGdW5jdGlvbnwnLFxuICAgICAgJzpzdmc6ZmVHYXVzc2lhbkJsdXJeOnN2Zzp8JyxcbiAgICAgICc6c3ZnOmZlSW1hZ2VeOnN2Zzp8JyxcbiAgICAgICc6c3ZnOmZlTWVyZ2VeOnN2Zzp8JyxcbiAgICAgICc6c3ZnOmZlTWVyZ2VOb2RlXjpzdmc6fCcsXG4gICAgICAnOnN2ZzpmZU1vcnBob2xvZ3leOnN2Zzp8JyxcbiAgICAgICc6c3ZnOmZlT2Zmc2V0Xjpzdmc6fCcsXG4gICAgICAnOnN2ZzpmZVBvaW50TGlnaHReOnN2Zzp8JyxcbiAgICAgICc6c3ZnOmZlU3BlY3VsYXJMaWdodGluZ146c3ZnOnwnLFxuICAgICAgJzpzdmc6ZmVTcG90TGlnaHReOnN2Zzp8JyxcbiAgICAgICc6c3ZnOmZlVGlsZV46c3ZnOnwnLFxuICAgICAgJzpzdmc6ZmVUdXJidWxlbmNlXjpzdmc6fCcsXG4gICAgICAnOnN2ZzpmaWx0ZXJeOnN2Zzp8JyxcbiAgICAgICc6c3ZnOmZvcmVpZ25PYmplY3ReOnN2ZzpncmFwaGljc3wnLFxuICAgICAgJzpzdmc6Z146c3ZnOmdyYXBoaWNzfCcsXG4gICAgICAnOnN2ZzppbWFnZV46c3ZnOmdyYXBoaWNzfCcsXG4gICAgICAnOnN2ZzpsaW5lXjpzdmc6Z2VvbWV0cnl8JyxcbiAgICAgICc6c3ZnOmxpbmVhckdyYWRpZW50Xjpzdmc6Z3JhZGllbnR8JyxcbiAgICAgICc6c3ZnOm1wYXRoXjpzdmc6fCcsXG4gICAgICAnOnN2ZzptYXJrZXJeOnN2Zzp8JyxcbiAgICAgICc6c3ZnOm1hc2teOnN2Zzp8JyxcbiAgICAgICc6c3ZnOm1ldGFkYXRhXjpzdmc6fCcsXG4gICAgICAnOnN2ZzpwYXRoXjpzdmc6Z2VvbWV0cnl8JyxcbiAgICAgICc6c3ZnOnBhdHRlcm5eOnN2Zzp8JyxcbiAgICAgICc6c3ZnOnBvbHlnb25eOnN2ZzpnZW9tZXRyeXwnLFxuICAgICAgJzpzdmc6cG9seWxpbmVeOnN2ZzpnZW9tZXRyeXwnLFxuICAgICAgJzpzdmc6cmFkaWFsR3JhZGllbnReOnN2ZzpncmFkaWVudHwnLFxuICAgICAgJzpzdmc6cmVjdF46c3ZnOmdlb21ldHJ5fCcsXG4gICAgICAnOnN2ZzpzdmdeOnN2ZzpncmFwaGljc3wjY3VycmVudFNjYWxlLCN6b29tQW5kUGFuJyxcbiAgICAgICc6c3ZnOnNjcmlwdF46c3ZnOnx0eXBlJyxcbiAgICAgICc6c3ZnOnNldF46c3ZnOmFuaW1hdGlvbnwnLFxuICAgICAgJzpzdmc6c3RvcF46c3ZnOnwnLFxuICAgICAgJzpzdmc6c3R5bGVeOnN2Zzp8IWRpc2FibGVkLG1lZGlhLHRpdGxlLHR5cGUnLFxuICAgICAgJzpzdmc6c3dpdGNoXjpzdmc6Z3JhcGhpY3N8JyxcbiAgICAgICc6c3ZnOnN5bWJvbF46c3ZnOnwnLFxuICAgICAgJzpzdmc6dHNwYW5eOnN2Zzp0ZXh0UG9zaXRpb25pbmd8JyxcbiAgICAgICc6c3ZnOnRleHReOnN2Zzp0ZXh0UG9zaXRpb25pbmd8JyxcbiAgICAgICc6c3ZnOnRleHRQYXRoXjpzdmc6dGV4dENvbnRlbnR8JyxcbiAgICAgICc6c3ZnOnRpdGxlXjpzdmc6fCcsXG4gICAgICAnOnN2Zzp1c2VeOnN2ZzpncmFwaGljc3wnLFxuICAgICAgJzpzdmc6dmlld146c3ZnOnwjem9vbUFuZFBhbicsXG4gICAgICAnZGF0YV5bSFRNTEVsZW1lbnRdfHZhbHVlJyxcbiAgICAgICdtZW51aXRlbV5bSFRNTEVsZW1lbnRdfHR5cGUsbGFiZWwsaWNvbiwhZGlzYWJsZWQsIWNoZWNrZWQscmFkaW9ncm91cCwhZGVmYXVsdCcsXG4gICAgICAnc3VtbWFyeV5bSFRNTEVsZW1lbnRdfCcsXG4gICAgICAndGltZV5bSFRNTEVsZW1lbnRdfGRhdGVUaW1lJyxcbiAgXTtcbiAgdmFyIF9BVFRSX1RPX1BST1AgPSB7XG4gICAgICAnY2xhc3MnOiAnY2xhc3NOYW1lJyxcbiAgICAgICdmb3JtYWN0aW9uJzogJ2Zvcm1BY3Rpb24nLFxuICAgICAgJ2lubmVySHRtbCc6ICdpbm5lckhUTUwnLFxuICAgICAgJ3JlYWRvbmx5JzogJ3JlYWRPbmx5JyxcbiAgICAgICd0YWJpbmRleCc6ICd0YWJJbmRleCcsXG4gIH07XG4gIHZhciBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnkgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDIwKERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeSwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeSgpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgIHRoaXMuX3NjaGVtYSA9IHt9O1xuICAgICAgICAgIFNDSEVNQS5mb3JFYWNoKGZ1bmN0aW9uIChlbmNvZGVkVHlwZSkge1xuICAgICAgICAgICAgICB2YXIgdHlwZSA9IHt9O1xuICAgICAgICAgICAgICB2YXIgX2EgPSBlbmNvZGVkVHlwZS5zcGxpdCgnfCcpLCBzdHJUeXBlID0gX2FbMF0sIHN0clByb3BlcnRpZXMgPSBfYVsxXTtcbiAgICAgICAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBzdHJQcm9wZXJ0aWVzLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICAgIHZhciBfYiA9IHN0clR5cGUuc3BsaXQoJ14nKSwgdHlwZU5hbWVzID0gX2JbMF0sIHN1cGVyTmFtZSA9IF9iWzFdO1xuICAgICAgICAgICAgICB0eXBlTmFtZXMuc3BsaXQoJywnKS5mb3JFYWNoKGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIF90aGlzLl9zY2hlbWFbdGFnLnRvTG93ZXJDYXNlKCldID0gdHlwZTsgfSk7XG4gICAgICAgICAgICAgIHZhciBzdXBlclR5cGUgPSBzdXBlck5hbWUgJiYgX3RoaXMuX3NjaGVtYVtzdXBlck5hbWUudG9Mb3dlckNhc2UoKV07XG4gICAgICAgICAgICAgIGlmIChzdXBlclR5cGUpIHtcbiAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHN1cGVyVHlwZSkuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkgeyB0eXBlW3Byb3BdID0gc3VwZXJUeXBlW3Byb3BdOyB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwcm9wZXJ0aWVzLmZvckVhY2goZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgICBpZiAocHJvcGVydHkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAocHJvcGVydHlbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCB5ZXQgc3VwcG9ydCBldmVudHMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBldmVyIGFsbG93aW5nIHRvIGJpbmQgdG8gZXZlbnRzLCBHTyBUSFJPVUdIIEEgU0VDVVJJVFkgUkVWSUVXLCBhbGxvd2luZyBldmVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdpbGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsbW9zdCBjZXJ0YWlubHkgaW50cm9kdWNlIGJhZCBYU1MgdnVsbmVyYWJpbGl0aWVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHlwZVtwcm9wZXJ0eS5zdWJzdHJpbmcoMSldID0gRVZFTlQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnISc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlW3Byb3BlcnR5LnN1YnN0cmluZygxKV0gPSBCT09MRUFOO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJyMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZVtwcm9wZXJ0eS5zdWJzdHJpbmcoMSldID0gTlVNQkVSO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJyUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZVtwcm9wZXJ0eS5zdWJzdHJpbmcoMSldID0gT0JKRUNUO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlW3Byb3BlcnR5XSA9IFNUUklORztcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LnByb3RvdHlwZS5oYXNQcm9wZXJ0eSA9IGZ1bmN0aW9uICh0YWdOYW1lLCBwcm9wTmFtZSwgc2NoZW1hTWV0YXMpIHtcbiAgICAgICAgICBpZiAoc2NoZW1hTWV0YXMuc29tZShmdW5jdGlvbiAoc2NoZW1hKSB7IHJldHVybiBzY2hlbWEubmFtZSA9PT0gX2FuZ3VsYXJfY29yZS5OT19FUlJPUlNfU0NIRU1BLm5hbWU7IH0pKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGFnTmFtZS5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgICAgICAgICBpZiAodGFnTmFtZSA9PT0gJ25nLWNvbnRhaW5lcicgfHwgdGFnTmFtZSA9PT0gJ25nLWNvbnRlbnQnKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHNjaGVtYU1ldGFzLnNvbWUoZnVuY3Rpb24gKHNjaGVtYSkgeyByZXR1cm4gc2NoZW1hLm5hbWUgPT09IF9hbmd1bGFyX2NvcmUuQ1VTVE9NX0VMRU1FTlRTX1NDSEVNQS5uYW1lOyB9KSkge1xuICAgICAgICAgICAgICAgICAgLy8gQ2FuJ3QgdGVsbCBub3cgYXMgd2UgZG9uJ3Qga25vdyB3aGljaCBwcm9wZXJ0aWVzIGEgY3VzdG9tIGVsZW1lbnQgd2lsbCBnZXRcbiAgICAgICAgICAgICAgICAgIC8vIG9uY2UgaXQgaXMgaW5zdGFudGlhdGVkXG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZWxlbWVudFByb3BlcnRpZXMgPSB0aGlzLl9zY2hlbWFbdGFnTmFtZS50b0xvd2VyQ2FzZSgpXSB8fCB0aGlzLl9zY2hlbWFbJ3Vua25vd24nXTtcbiAgICAgICAgICByZXR1cm4gISFlbGVtZW50UHJvcGVydGllc1twcm9wTmFtZV07XG4gICAgICB9O1xuICAgICAgRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LnByb3RvdHlwZS5oYXNFbGVtZW50ID0gZnVuY3Rpb24gKHRhZ05hbWUsIHNjaGVtYU1ldGFzKSB7XG4gICAgICAgICAgaWYgKHNjaGVtYU1ldGFzLnNvbWUoZnVuY3Rpb24gKHNjaGVtYSkgeyByZXR1cm4gc2NoZW1hLm5hbWUgPT09IF9hbmd1bGFyX2NvcmUuTk9fRVJST1JTX1NDSEVNQS5uYW1lOyB9KSkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRhZ05hbWUuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgICAgICAgICAgaWYgKHRhZ05hbWUgPT09ICduZy1jb250YWluZXInIHx8IHRhZ05hbWUgPT09ICduZy1jb250ZW50Jykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHNjaGVtYU1ldGFzLnNvbWUoZnVuY3Rpb24gKHNjaGVtYSkgeyByZXR1cm4gc2NoZW1hLm5hbWUgPT09IF9hbmd1bGFyX2NvcmUuQ1VTVE9NX0VMRU1FTlRTX1NDSEVNQS5uYW1lOyB9KSkge1xuICAgICAgICAgICAgICAgICAgLy8gQWxsb3cgYW55IGN1c3RvbSBlbGVtZW50c1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuICEhdGhpcy5fc2NoZW1hW3RhZ05hbWUudG9Mb3dlckNhc2UoKV07XG4gICAgICB9O1xuICAgICAgLyoqXG4gICAgICAgKiBzZWN1cml0eUNvbnRleHQgcmV0dXJucyB0aGUgc2VjdXJpdHkgY29udGV4dCBmb3IgdGhlIGdpdmVuIHByb3BlcnR5IG9uIHRoZSBnaXZlbiBET00gdGFnLlxuICAgICAgICpcbiAgICAgICAqIFRhZyBhbmQgcHJvcGVydHkgbmFtZSBhcmUgc3RhdGljYWxseSBrbm93biBhbmQgY2Fubm90IGNoYW5nZSBhdCBydW50aW1lLCBpLmUuIGl0IGlzIG5vdFxuICAgICAgICogcG9zc2libGUgdG8gYmluZCBhIHZhbHVlIGludG8gYSBjaGFuZ2luZyBhdHRyaWJ1dGUgb3IgdGFnIG5hbWUuXG4gICAgICAgKlxuICAgICAgICogVGhlIGZpbHRlcmluZyBpcyB3aGl0ZSBsaXN0IGJhc2VkLiBBbGwgYXR0cmlidXRlcyBpbiB0aGUgc2NoZW1hIGFib3ZlIGFyZSBhc3N1bWVkIHRvIGhhdmUgdGhlXG4gICAgICAgKiAnTk9ORScgc2VjdXJpdHkgY29udGV4dCwgaS5lLiB0aGF0IHRoZXkgYXJlIHNhZmUgaW5lcnQgc3RyaW5nIHZhbHVlcy4gT25seSBzcGVjaWZpYyB3ZWxsIGtub3duXG4gICAgICAgKiBhdHRhY2sgdmVjdG9ycyBhcmUgYXNzaWduZWQgdGhlaXIgYXBwcm9wcmlhdGUgY29udGV4dC5cbiAgICAgICAqL1xuICAgICAgRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LnByb3RvdHlwZS5zZWN1cml0eUNvbnRleHQgPSBmdW5jdGlvbiAodGFnTmFtZSwgcHJvcE5hbWUpIHtcbiAgICAgICAgICAvLyBNYWtlIHN1cmUgY29tcGFyaXNvbnMgYXJlIGNhc2UgaW5zZW5zaXRpdmUsIHNvIHRoYXQgY2FzZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGF0dHJpYnV0ZSBhbmRcbiAgICAgICAgICAvLyBwcm9wZXJ0eSBuYW1lcyBkbyBub3QgaGF2ZSBhIHNlY3VyaXR5IGltcGFjdC5cbiAgICAgICAgICB0YWdOYW1lID0gdGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIHByb3BOYW1lID0gcHJvcE5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICB2YXIgY3R4ID0gU0VDVVJJVFlfU0NIRU1BW3RhZ05hbWUgKyAnfCcgKyBwcm9wTmFtZV07XG4gICAgICAgICAgaWYgKGN0eCkge1xuICAgICAgICAgICAgICByZXR1cm4gY3R4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdHggPSBTRUNVUklUWV9TQ0hFTUFbJyp8JyArIHByb3BOYW1lXTtcbiAgICAgICAgICByZXR1cm4gY3R4ID8gY3R4IDogX2FuZ3VsYXJfY29yZS5TZWN1cml0eUNvbnRleHQuTk9ORTtcbiAgICAgIH07XG4gICAgICBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnkucHJvdG90eXBlLmdldE1hcHBlZFByb3BOYW1lID0gZnVuY3Rpb24gKHByb3BOYW1lKSB7IHJldHVybiBfQVRUUl9UT19QUk9QW3Byb3BOYW1lXSB8fCBwcm9wTmFtZTsgfTtcbiAgICAgIERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeS5wcm90b3R5cGUuZ2V0RGVmYXVsdENvbXBvbmVudEVsZW1lbnROYW1lID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJ25nLWNvbXBvbmVudCc7IH07XG4gICAgICBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnkucHJvdG90eXBlLnZhbGlkYXRlUHJvcGVydHkgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgIGlmIChuYW1lLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgnb24nKSkge1xuICAgICAgICAgICAgICB2YXIgbXNnID0gKFwiQmluZGluZyB0byBldmVudCBwcm9wZXJ0eSAnXCIgKyBuYW1lICsgXCInIGlzIGRpc2FsbG93ZWQgZm9yIHNlY3VyaXR5IHJlYXNvbnMsIFwiKSArXG4gICAgICAgICAgICAgICAgICAoXCJwbGVhc2UgdXNlIChcIiArIG5hbWUuc2xpY2UoMikgKyBcIik9Li4uXCIpICtcbiAgICAgICAgICAgICAgICAgIChcIlxcbklmICdcIiArIG5hbWUgKyBcIicgaXMgYSBkaXJlY3RpdmUgaW5wdXQsIG1ha2Ugc3VyZSB0aGUgZGlyZWN0aXZlIGlzIGltcG9ydGVkIGJ5IHRoZVwiKSArXG4gICAgICAgICAgICAgICAgICBcIiBjdXJyZW50IG1vZHVsZS5cIjtcbiAgICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3I6IHRydWUsIG1zZzogbXNnIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4geyBlcnJvcjogZmFsc2UgfTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LnByb3RvdHlwZS52YWxpZGF0ZUF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgaWYgKG5hbWUudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKCdvbicpKSB7XG4gICAgICAgICAgICAgIHZhciBtc2cgPSAoXCJCaW5kaW5nIHRvIGV2ZW50IGF0dHJpYnV0ZSAnXCIgKyBuYW1lICsgXCInIGlzIGRpc2FsbG93ZWQgZm9yIHNlY3VyaXR5IHJlYXNvbnMsIFwiKSArXG4gICAgICAgICAgICAgICAgICAoXCJwbGVhc2UgdXNlIChcIiArIG5hbWUuc2xpY2UoMikgKyBcIik9Li4uXCIpO1xuICAgICAgICAgICAgICByZXR1cm4geyBlcnJvcjogdHJ1ZSwgbXNnOiBtc2cgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiB7IGVycm9yOiBmYWxzZSB9O1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnkuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuICAgICAgXTtcbiAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LmN0b3JQYXJhbWV0ZXJzID0gW107XG4gICAgICByZXR1cm4gRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5O1xuICB9KEVsZW1lbnRTY2hlbWFSZWdpc3RyeSkpO1xuXG4gIHZhciBfTk9fUkVTT1VSQ0VfTE9BREVSID0ge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gUmVzb3VyY2VMb2FkZXIgaW1wbGVtZW50YXRpb24gaGFzIGJlZW4gcHJvdmlkZWQuIENhbid0IHJlYWQgdGhlIHVybCBcXFwiXCIgKyB1cmwgKyBcIlxcXCJcIik7XG4gICAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBBIHNldCBvZiBwcm92aWRlcnMgdGhhdCBwcm92aWRlIGBSdW50aW1lQ29tcGlsZXJgIGFuZCBpdHMgZGVwZW5kZW5jaWVzIHRvIHVzZSBmb3JcbiAgICogdGVtcGxhdGUgY29tcGlsYXRpb24uXG4gICAqL1xuICB2YXIgQ09NUElMRVJfUFJPVklERVJTID0gW1xuICAgICAgeyBwcm92aWRlOiBSZWZsZWN0b3IsIHVzZVZhbHVlOiByZWZsZWN0b3IgfSxcbiAgICAgIHsgcHJvdmlkZTogUmVmbGVjdG9yUmVhZGVyLCB1c2VFeGlzdGluZzogUmVmbGVjdG9yIH0sXG4gICAgICB7IHByb3ZpZGU6IFJlc291cmNlTG9hZGVyLCB1c2VWYWx1ZTogX05PX1JFU09VUkNFX0xPQURFUiB9LFxuICAgICAgQ29uc29sZSxcbiAgICAgIExleGVyLFxuICAgICAgUGFyc2VyLFxuICAgICAgSHRtbFBhcnNlcixcbiAgICAgIHtcbiAgICAgICAgICBwcm92aWRlOiBJMThOSHRtbFBhcnNlcixcbiAgICAgICAgICB1c2VGYWN0b3J5OiBmdW5jdGlvbiAocGFyc2VyLCB0cmFuc2xhdGlvbnMsIGZvcm1hdCkge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IEkxOE5IdG1sUGFyc2VyKHBhcnNlciwgdHJhbnNsYXRpb25zLCBmb3JtYXQpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZGVwczogW1xuICAgICAgICAgICAgICBIdG1sUGFyc2VyLFxuICAgICAgICAgICAgICBbbmV3IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwoKSwgbmV3IF9hbmd1bGFyX2NvcmUuSW5qZWN0KF9hbmd1bGFyX2NvcmUuVFJBTlNMQVRJT05TKV0sXG4gICAgICAgICAgICAgIFtuZXcgX2FuZ3VsYXJfY29yZS5PcHRpb25hbCgpLCBuZXcgX2FuZ3VsYXJfY29yZS5JbmplY3QoX2FuZ3VsYXJfY29yZS5UUkFOU0xBVElPTlNfRk9STUFUKV0sXG4gICAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIFRlbXBsYXRlUGFyc2VyLFxuICAgICAgRGlyZWN0aXZlTm9ybWFsaXplcixcbiAgICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLFxuICAgICAgREVGQVVMVF9QQUNLQUdFX1VSTF9QUk9WSURFUixcbiAgICAgIFN0eWxlQ29tcGlsZXIsXG4gICAgICBWaWV3Q29tcGlsZXIsXG4gICAgICBOZ01vZHVsZUNvbXBpbGVyLFxuICAgICAgRGlyZWN0aXZlV3JhcHBlckNvbXBpbGVyLFxuICAgICAgeyBwcm92aWRlOiBDb21waWxlckNvbmZpZywgdXNlVmFsdWU6IG5ldyBDb21waWxlckNvbmZpZygpIH0sXG4gICAgICBSdW50aW1lQ29tcGlsZXIsXG4gICAgICB7IHByb3ZpZGU6IF9hbmd1bGFyX2NvcmUuQ29tcGlsZXIsIHVzZUV4aXN0aW5nOiBSdW50aW1lQ29tcGlsZXIgfSxcbiAgICAgIERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeSxcbiAgICAgIHsgcHJvdmlkZTogRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LCB1c2VFeGlzdGluZzogRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5IH0sXG4gICAgICBVcmxSZXNvbHZlcixcbiAgICAgIERpcmVjdGl2ZVJlc29sdmVyLFxuICAgICAgUGlwZVJlc29sdmVyLFxuICAgICAgTmdNb2R1bGVSZXNvbHZlclxuICBdO1xuICB2YXIgUnVudGltZUNvbXBpbGVyRmFjdG9yeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBSdW50aW1lQ29tcGlsZXJGYWN0b3J5KGRlZmF1bHRPcHRpb25zKSB7XG4gICAgICAgICAgdGhpcy5fZGVmYXVsdE9wdGlvbnMgPSBbe1xuICAgICAgICAgICAgICAgICAgdXNlRGVidWc6IF9hbmd1bGFyX2NvcmUuaXNEZXZNb2RlKCksXG4gICAgICAgICAgICAgICAgICB1c2VKaXQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICBkZWZhdWx0RW5jYXBzdWxhdGlvbjogX2FuZ3VsYXJfY29yZS5WaWV3RW5jYXBzdWxhdGlvbi5FbXVsYXRlZFxuICAgICAgICAgICAgICB9XS5jb25jYXQoZGVmYXVsdE9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgUnVudGltZUNvbXBpbGVyRmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlQ29tcGlsZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IFtdOyB9XG4gICAgICAgICAgdmFyIG1lcmdlZE9wdGlvbnMgPSBfbWVyZ2VPcHRpb25zKHRoaXMuX2RlZmF1bHRPcHRpb25zLmNvbmNhdChvcHRpb25zKSk7XG4gICAgICAgICAgdmFyIGluamVjdG9yID0gX2FuZ3VsYXJfY29yZS5SZWZsZWN0aXZlSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbXG4gICAgICAgICAgICAgIENPTVBJTEVSX1BST1ZJREVSUywge1xuICAgICAgICAgICAgICAgICAgcHJvdmlkZTogQ29tcGlsZXJDb25maWcsXG4gICAgICAgICAgICAgICAgICB1c2VGYWN0b3J5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21waWxlckNvbmZpZyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxldCBleHBsaWNpdCB2YWx1ZXMgZnJvbSB0aGUgY29tcGlsZXIgb3B0aW9ucyBvdmVyd3JpdGUgb3B0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmcm9tIHRoZSBhcHAgcHJvdmlkZXJzLiBFLmcuIGltcG9ydGFudCBmb3IgdGhlIHRlc3RpbmcgcGxhdGZvcm0uXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGdlbkRlYnVnSW5mbzogbWVyZ2VkT3B0aW9ucy51c2VEZWJ1ZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGV0IGV4cGxpY2l0IHZhbHVlcyBmcm9tIHRoZSBjb21waWxlciBvcHRpb25zIG92ZXJ3cml0ZSBvcHRpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZyb20gdGhlIGFwcCBwcm92aWRlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlSml0OiBtZXJnZWRPcHRpb25zLnVzZUppdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGV0IGV4cGxpY2l0IHZhbHVlcyBmcm9tIHRoZSBjb21waWxlciBvcHRpb25zIG92ZXJ3cml0ZSBvcHRpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZyb20gdGhlIGFwcCBwcm92aWRlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdEVuY2Fwc3VsYXRpb246IG1lcmdlZE9wdGlvbnMuZGVmYXVsdEVuY2Fwc3VsYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ0JpbmRpbmdVcGRhdGU6IG1lcmdlZE9wdGlvbnMudXNlRGVidWdcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBkZXBzOiBbXVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBtZXJnZWRPcHRpb25zLnByb3ZpZGVyc1xuICAgICAgICAgIF0pO1xuICAgICAgICAgIHJldHVybiBpbmplY3Rvci5nZXQoX2FuZ3VsYXJfY29yZS5Db21waWxlcik7XG4gICAgICB9O1xuICAgICAgUnVudGltZUNvbXBpbGVyRmFjdG9yeS5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG4gICAgICBdO1xuICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICBSdW50aW1lQ29tcGlsZXJGYWN0b3J5LmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgIHsgdHlwZTogQXJyYXksIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbX2FuZ3VsYXJfY29yZS5DT01QSUxFUl9PUFRJT05TLF0gfSxdIH0sXG4gICAgICBdO1xuICAgICAgcmV0dXJuIFJ1bnRpbWVDb21waWxlckZhY3Rvcnk7XG4gIH0oKSk7XG4gIGZ1bmN0aW9uIF9pbml0UmVmbGVjdG9yKCkge1xuICAgICAgcmVmbGVjdG9yLnJlZmxlY3Rpb25DYXBhYmlsaXRpZXMgPSBuZXcgUmVmbGVjdGlvbkNhcGFiaWxpdGllcygpO1xuICB9XG4gIC8qKlxuICAgKiBBIHBsYXRmb3JtIHRoYXQgaW5jbHVkZWQgY29yZVBsYXRmb3JtIGFuZCB0aGUgY29tcGlsZXIuXG4gICAqXG4gICAqIEBleHBlcmltZW50YWxcbiAgICovXG4gIHZhciBwbGF0Zm9ybUNvcmVEeW5hbWljID0gX2FuZ3VsYXJfY29yZS5jcmVhdGVQbGF0Zm9ybUZhY3RvcnkoX2FuZ3VsYXJfY29yZS5wbGF0Zm9ybUNvcmUsICdjb3JlRHluYW1pYycsIFtcbiAgICAgIHsgcHJvdmlkZTogX2FuZ3VsYXJfY29yZS5DT01QSUxFUl9PUFRJT05TLCB1c2VWYWx1ZToge30sIG11bHRpOiB0cnVlIH0sXG4gICAgICB7IHByb3ZpZGU6IF9hbmd1bGFyX2NvcmUuQ29tcGlsZXJGYWN0b3J5LCB1c2VDbGFzczogUnVudGltZUNvbXBpbGVyRmFjdG9yeSB9LFxuICAgICAgeyBwcm92aWRlOiBfYW5ndWxhcl9jb3JlLlBMQVRGT1JNX0lOSVRJQUxJWkVSLCB1c2VWYWx1ZTogX2luaXRSZWZsZWN0b3IsIG11bHRpOiB0cnVlIH0sXG4gIF0pO1xuICBmdW5jdGlvbiBfbWVyZ2VPcHRpb25zKG9wdGlvbnNBcnIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgdXNlRGVidWc6IF9sYXN0RGVmaW5lZChvcHRpb25zQXJyLm1hcChmdW5jdGlvbiAob3B0aW9ucykgeyByZXR1cm4gb3B0aW9ucy51c2VEZWJ1ZzsgfSkpLFxuICAgICAgICAgIHVzZUppdDogX2xhc3REZWZpbmVkKG9wdGlvbnNBcnIubWFwKGZ1bmN0aW9uIChvcHRpb25zKSB7IHJldHVybiBvcHRpb25zLnVzZUppdDsgfSkpLFxuICAgICAgICAgIGRlZmF1bHRFbmNhcHN1bGF0aW9uOiBfbGFzdERlZmluZWQob3B0aW9uc0Fyci5tYXAoZnVuY3Rpb24gKG9wdGlvbnMpIHsgcmV0dXJuIG9wdGlvbnMuZGVmYXVsdEVuY2Fwc3VsYXRpb247IH0pKSxcbiAgICAgICAgICBwcm92aWRlcnM6IF9tZXJnZUFycmF5cyhvcHRpb25zQXJyLm1hcChmdW5jdGlvbiAob3B0aW9ucykgeyByZXR1cm4gb3B0aW9ucy5wcm92aWRlcnM7IH0pKVxuICAgICAgfTtcbiAgfVxuICBmdW5jdGlvbiBfbGFzdERlZmluZWQoYXJncykge1xuICAgICAgZm9yICh2YXIgaSA9IGFyZ3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAoYXJnc1tpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhcmdzW2ldO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgZnVuY3Rpb24gX21lcmdlQXJyYXlzKHBhcnRzKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBwYXJ0cy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJ0KSB7IHJldHVybiBwYXJ0ICYmIHJlc3VsdC5wdXNoLmFwcGx5KHJlc3VsdCwgcGFydCk7IH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbGljZW5zZVxuICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICpcbiAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgKi9cbiAgLy8gYXNzZXQ6PHBhY2thZ2UtbmFtZT4vPHJlYWxtPi88cGF0aC10by1tb2R1bGU+XG4gIHZhciBfQVNTRVRfVVJMX1JFID0gL2Fzc2V0OihbXlxcL10rKVxcLyhbXlxcL10rKVxcLyguKykvO1xuICAvKipcbiAgICogSW50ZXJmYWNlIHRoYXQgZGVmaW5lcyBob3cgaW1wb3J0IHN0YXRlbWVudHMgc2hvdWxkIGJlIGdlbmVyYXRlZC5cbiAgICovXG4gIHZhciBJbXBvcnRHZW5lcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gSW1wb3J0R2VuZXJhdG9yKCkge1xuICAgICAgfVxuICAgICAgSW1wb3J0R2VuZXJhdG9yLnBhcnNlQXNzZXRVcmwgPSBmdW5jdGlvbiAodXJsKSB7IHJldHVybiBBc3NldFVybC5wYXJzZSh1cmwpOyB9O1xuICAgICAgcmV0dXJuIEltcG9ydEdlbmVyYXRvcjtcbiAgfSgpKTtcbiAgdmFyIEFzc2V0VXJsID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIEFzc2V0VXJsKHBhY2thZ2VOYW1lLCBmaXJzdExldmVsRGlyLCBtb2R1bGVQYXRoKSB7XG4gICAgICAgICAgdGhpcy5wYWNrYWdlTmFtZSA9IHBhY2thZ2VOYW1lO1xuICAgICAgICAgIHRoaXMuZmlyc3RMZXZlbERpciA9IGZpcnN0TGV2ZWxEaXI7XG4gICAgICAgICAgdGhpcy5tb2R1bGVQYXRoID0gbW9kdWxlUGF0aDtcbiAgICAgIH1cbiAgICAgIEFzc2V0VXJsLnBhcnNlID0gZnVuY3Rpb24gKHVybCwgYWxsb3dOb25NYXRjaGluZykge1xuICAgICAgICAgIGlmIChhbGxvd05vbk1hdGNoaW5nID09PSB2b2lkIDApIHsgYWxsb3dOb25NYXRjaGluZyA9IHRydWU7IH1cbiAgICAgICAgICB2YXIgbWF0Y2ggPSB1cmwubWF0Y2goX0FTU0VUX1VSTF9SRSk7XG4gICAgICAgICAgaWYgKG1hdGNoICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgQXNzZXRVcmwobWF0Y2hbMV0sIG1hdGNoWzJdLCBtYXRjaFszXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhbGxvd05vbk1hdGNoaW5nKSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVcmwgXCIgKyB1cmwgKyBcIiBpcyBub3QgYSB2YWxpZCBhc3NldDogdXJsXCIpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBBc3NldFVybDtcbiAgfSgpKTtcblxuICBleHBvcnRzLlRFTVBMQVRFX1RSQU5TRk9STVMgPSBURU1QTEFURV9UUkFOU0ZPUk1TO1xuICBleHBvcnRzLkNvbXBpbGVyQ29uZmlnID0gQ29tcGlsZXJDb25maWc7XG4gIGV4cG9ydHMuUmVuZGVyVHlwZXMgPSBSZW5kZXJUeXBlcztcbiAgZXhwb3J0cy5SdW50aW1lQ29tcGlsZXIgPSBSdW50aW1lQ29tcGlsZXI7XG4gIGV4cG9ydHMuRGlyZWN0aXZlUmVzb2x2ZXIgPSBEaXJlY3RpdmVSZXNvbHZlcjtcbiAgZXhwb3J0cy5QaXBlUmVzb2x2ZXIgPSBQaXBlUmVzb2x2ZXI7XG4gIGV4cG9ydHMuTmdNb2R1bGVSZXNvbHZlciA9IE5nTW9kdWxlUmVzb2x2ZXI7XG4gIGV4cG9ydHMuREVGQVVMVF9JTlRFUlBPTEFUSU9OX0NPTkZJRyA9IERFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUc7XG4gIGV4cG9ydHMuSW50ZXJwb2xhdGlvbkNvbmZpZyA9IEludGVycG9sYXRpb25Db25maWc7XG4gIGV4cG9ydHMuRWxlbWVudFNjaGVtYVJlZ2lzdHJ5ID0gRWxlbWVudFNjaGVtYVJlZ2lzdHJ5O1xuICBleHBvcnRzLk5nTW9kdWxlQ29tcGlsZXIgPSBOZ01vZHVsZUNvbXBpbGVyO1xuICBleHBvcnRzLkRpcmVjdGl2ZVdyYXBwZXJDb21waWxlciA9IERpcmVjdGl2ZVdyYXBwZXJDb21waWxlcjtcbiAgZXhwb3J0cy5WaWV3Q29tcGlsZXIgPSBWaWV3Q29tcGlsZXI7XG4gIGV4cG9ydHMuVGV4dEFzdCA9IFRleHRBc3Q7XG4gIGV4cG9ydHMuQm91bmRUZXh0QXN0ID0gQm91bmRUZXh0QXN0O1xuICBleHBvcnRzLkF0dHJBc3QgPSBBdHRyQXN0O1xuICBleHBvcnRzLkJvdW5kRWxlbWVudFByb3BlcnR5QXN0ID0gQm91bmRFbGVtZW50UHJvcGVydHlBc3Q7XG4gIGV4cG9ydHMuQm91bmRFdmVudEFzdCA9IEJvdW5kRXZlbnRBc3Q7XG4gIGV4cG9ydHMuUmVmZXJlbmNlQXN0ID0gUmVmZXJlbmNlQXN0O1xuICBleHBvcnRzLlZhcmlhYmxlQXN0ID0gVmFyaWFibGVBc3Q7XG4gIGV4cG9ydHMuRWxlbWVudEFzdCA9IEVsZW1lbnRBc3Q7XG4gIGV4cG9ydHMuRW1iZWRkZWRUZW1wbGF0ZUFzdCA9IEVtYmVkZGVkVGVtcGxhdGVBc3Q7XG4gIGV4cG9ydHMuQm91bmREaXJlY3RpdmVQcm9wZXJ0eUFzdCA9IEJvdW5kRGlyZWN0aXZlUHJvcGVydHlBc3Q7XG4gIGV4cG9ydHMuRGlyZWN0aXZlQXN0ID0gRGlyZWN0aXZlQXN0O1xuICBleHBvcnRzLlByb3ZpZGVyQXN0ID0gUHJvdmlkZXJBc3Q7XG4gIGV4cG9ydHMuTmdDb250ZW50QXN0ID0gTmdDb250ZW50QXN0O1xuICBleHBvcnRzLnRlbXBsYXRlVmlzaXRBbGwgPSB0ZW1wbGF0ZVZpc2l0QWxsO1xuICBleHBvcnRzLkNvbXBpbGVNZXRhZGF0YVdpdGhJZGVudGlmaWVyID0gQ29tcGlsZU1ldGFkYXRhV2l0aElkZW50aWZpZXI7XG4gIGV4cG9ydHMuQ29tcGlsZUFuaW1hdGlvbkVudHJ5TWV0YWRhdGEgPSBDb21waWxlQW5pbWF0aW9uRW50cnlNZXRhZGF0YTtcbiAgZXhwb3J0cy5Db21waWxlQW5pbWF0aW9uU3RhdGVNZXRhZGF0YSA9IENvbXBpbGVBbmltYXRpb25TdGF0ZU1ldGFkYXRhO1xuICBleHBvcnRzLkNvbXBpbGVBbmltYXRpb25TdGF0ZURlY2xhcmF0aW9uTWV0YWRhdGEgPSBDb21waWxlQW5pbWF0aW9uU3RhdGVEZWNsYXJhdGlvbk1ldGFkYXRhO1xuICBleHBvcnRzLkNvbXBpbGVBbmltYXRpb25TdGF0ZVRyYW5zaXRpb25NZXRhZGF0YSA9IENvbXBpbGVBbmltYXRpb25TdGF0ZVRyYW5zaXRpb25NZXRhZGF0YTtcbiAgZXhwb3J0cy5Db21waWxlQW5pbWF0aW9uTWV0YWRhdGEgPSBDb21waWxlQW5pbWF0aW9uTWV0YWRhdGE7XG4gIGV4cG9ydHMuQ29tcGlsZUFuaW1hdGlvbktleWZyYW1lc1NlcXVlbmNlTWV0YWRhdGEgPSBDb21waWxlQW5pbWF0aW9uS2V5ZnJhbWVzU2VxdWVuY2VNZXRhZGF0YTtcbiAgZXhwb3J0cy5Db21waWxlQW5pbWF0aW9uU3R5bGVNZXRhZGF0YSA9IENvbXBpbGVBbmltYXRpb25TdHlsZU1ldGFkYXRhO1xuICBleHBvcnRzLkNvbXBpbGVBbmltYXRpb25BbmltYXRlTWV0YWRhdGEgPSBDb21waWxlQW5pbWF0aW9uQW5pbWF0ZU1ldGFkYXRhO1xuICBleHBvcnRzLkNvbXBpbGVBbmltYXRpb25XaXRoU3RlcHNNZXRhZGF0YSA9IENvbXBpbGVBbmltYXRpb25XaXRoU3RlcHNNZXRhZGF0YTtcbiAgZXhwb3J0cy5Db21waWxlQW5pbWF0aW9uU2VxdWVuY2VNZXRhZGF0YSA9IENvbXBpbGVBbmltYXRpb25TZXF1ZW5jZU1ldGFkYXRhO1xuICBleHBvcnRzLkNvbXBpbGVBbmltYXRpb25Hcm91cE1ldGFkYXRhID0gQ29tcGlsZUFuaW1hdGlvbkdyb3VwTWV0YWRhdGE7XG4gIGV4cG9ydHMuQ29tcGlsZUlkZW50aWZpZXJNZXRhZGF0YSA9IENvbXBpbGVJZGVudGlmaWVyTWV0YWRhdGE7XG4gIGV4cG9ydHMuQ29tcGlsZURpRGVwZW5kZW5jeU1ldGFkYXRhID0gQ29tcGlsZURpRGVwZW5kZW5jeU1ldGFkYXRhO1xuICBleHBvcnRzLkNvbXBpbGVQcm92aWRlck1ldGFkYXRhID0gQ29tcGlsZVByb3ZpZGVyTWV0YWRhdGE7XG4gIGV4cG9ydHMuQ29tcGlsZUZhY3RvcnlNZXRhZGF0YSA9IENvbXBpbGVGYWN0b3J5TWV0YWRhdGE7XG4gIGV4cG9ydHMuQ29tcGlsZVRva2VuTWV0YWRhdGEgPSBDb21waWxlVG9rZW5NZXRhZGF0YTtcbiAgZXhwb3J0cy5Db21waWxlVHlwZU1ldGFkYXRhID0gQ29tcGlsZVR5cGVNZXRhZGF0YTtcbiAgZXhwb3J0cy5Db21waWxlUXVlcnlNZXRhZGF0YSA9IENvbXBpbGVRdWVyeU1ldGFkYXRhO1xuICBleHBvcnRzLkNvbXBpbGVTdHlsZXNoZWV0TWV0YWRhdGEgPSBDb21waWxlU3R5bGVzaGVldE1ldGFkYXRhO1xuICBleHBvcnRzLkNvbXBpbGVUZW1wbGF0ZU1ldGFkYXRhID0gQ29tcGlsZVRlbXBsYXRlTWV0YWRhdGE7XG4gIGV4cG9ydHMuQ29tcGlsZURpcmVjdGl2ZU1ldGFkYXRhID0gQ29tcGlsZURpcmVjdGl2ZU1ldGFkYXRhO1xuICBleHBvcnRzLmNyZWF0ZUhvc3RDb21wb25lbnRNZXRhID0gY3JlYXRlSG9zdENvbXBvbmVudE1ldGE7XG4gIGV4cG9ydHMuQ29tcGlsZVBpcGVNZXRhZGF0YSA9IENvbXBpbGVQaXBlTWV0YWRhdGE7XG4gIGV4cG9ydHMuQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGEgPSBDb21waWxlTmdNb2R1bGVNZXRhZGF0YTtcbiAgZXhwb3J0cy5UcmFuc2l0aXZlQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGEgPSBUcmFuc2l0aXZlQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGE7XG4gIGV4cG9ydHMucmVtb3ZlSWRlbnRpZmllckR1cGxpY2F0ZXMgPSByZW1vdmVJZGVudGlmaWVyRHVwbGljYXRlcztcbiAgZXhwb3J0cy5pc1N0YXRpY1N5bWJvbCA9IGlzU3RhdGljU3ltYm9sO1xuICBleHBvcnRzLlByb3ZpZGVyTWV0YSA9IFByb3ZpZGVyTWV0YTtcbiAgZXhwb3J0cy5Tb3VyY2VNb2R1bGUgPSBTb3VyY2VNb2R1bGU7XG4gIGV4cG9ydHMuTmdNb2R1bGVzU3VtbWFyeSA9IE5nTW9kdWxlc1N1bW1hcnk7XG4gIGV4cG9ydHMuYW5hbHl6ZU1vZHVsZXMgPSBhbmFseXplTW9kdWxlcztcbiAgZXhwb3J0cy5PZmZsaW5lQ29tcGlsZXIgPSBPZmZsaW5lQ29tcGlsZXI7XG4gIGV4cG9ydHMuY3JlYXRlVXJsUmVzb2x2ZXJXaXRob3V0UGFja2FnZVByZWZpeCA9IGNyZWF0ZVVybFJlc29sdmVyV2l0aG91dFBhY2thZ2VQcmVmaXg7XG4gIGV4cG9ydHMuY3JlYXRlT2ZmbGluZUNvbXBpbGVVcmxSZXNvbHZlciA9IGNyZWF0ZU9mZmxpbmVDb21waWxlVXJsUmVzb2x2ZXI7XG4gIGV4cG9ydHMuREVGQVVMVF9QQUNLQUdFX1VSTF9QUk9WSURFUiA9IERFRkFVTFRfUEFDS0FHRV9VUkxfUFJPVklERVI7XG4gIGV4cG9ydHMuVXJsUmVzb2x2ZXIgPSBVcmxSZXNvbHZlcjtcbiAgZXhwb3J0cy5nZXRVcmxTY2hlbWUgPSBnZXRVcmxTY2hlbWU7XG4gIGV4cG9ydHMuUmVzb3VyY2VMb2FkZXIgPSBSZXNvdXJjZUxvYWRlcjtcbiAgZXhwb3J0cy5DT01QSUxFUl9QUk9WSURFUlMgPSBDT01QSUxFUl9QUk9WSURFUlM7XG4gIGV4cG9ydHMuUnVudGltZUNvbXBpbGVyRmFjdG9yeSA9IFJ1bnRpbWVDb21waWxlckZhY3Rvcnk7XG4gIGV4cG9ydHMucGxhdGZvcm1Db3JlRHluYW1pYyA9IHBsYXRmb3JtQ29yZUR5bmFtaWM7XG4gIGV4cG9ydHMuSTE4Tkh0bWxQYXJzZXIgPSBJMThOSHRtbFBhcnNlcjtcbiAgZXhwb3J0cy5NZXNzYWdlQnVuZGxlID0gTWVzc2FnZUJ1bmRsZTtcbiAgZXhwb3J0cy5YbGlmZiA9IFhsaWZmO1xuICBleHBvcnRzLlhtYiA9IFhtYjtcbiAgZXhwb3J0cy5YdGIgPSBYdGI7XG4gIGV4cG9ydHMuRGlyZWN0aXZlTm9ybWFsaXplciA9IERpcmVjdGl2ZU5vcm1hbGl6ZXI7XG4gIGV4cG9ydHMuTGV4ZXIgPSBMZXhlcjtcbiAgZXhwb3J0cy5Ub2tlbiA9IFRva2VuO1xuICBleHBvcnRzLkVPRiA9IEVPRjtcbiAgZXhwb3J0cy5pc0lkZW50aWZpZXIgPSBpc0lkZW50aWZpZXI7XG4gIGV4cG9ydHMuaXNRdW90ZSA9IGlzUXVvdGU7XG4gIGV4cG9ydHMuU3BsaXRJbnRlcnBvbGF0aW9uID0gU3BsaXRJbnRlcnBvbGF0aW9uO1xuICBleHBvcnRzLlRlbXBsYXRlQmluZGluZ1BhcnNlUmVzdWx0ID0gVGVtcGxhdGVCaW5kaW5nUGFyc2VSZXN1bHQ7XG4gIGV4cG9ydHMuUGFyc2VyID0gUGFyc2VyO1xuICBleHBvcnRzLl9QYXJzZUFTVCA9IF9QYXJzZUFTVDtcbiAgZXhwb3J0cy5Db21waWxlTWV0YWRhdGFSZXNvbHZlciA9IENvbXBpbGVNZXRhZGF0YVJlc29sdmVyO1xuICBleHBvcnRzLkh0bWxQYXJzZXIgPSBIdG1sUGFyc2VyO1xuICBleHBvcnRzLlBhcnNlVHJlZVJlc3VsdCA9IFBhcnNlVHJlZVJlc3VsdDtcbiAgZXhwb3J0cy5UcmVlRXJyb3IgPSBUcmVlRXJyb3I7XG4gIGV4cG9ydHMuSW1wb3J0R2VuZXJhdG9yID0gSW1wb3J0R2VuZXJhdG9yO1xuICBleHBvcnRzLkFzc2V0VXJsID0gQXNzZXRVcmw7XG4gIGV4cG9ydHMuZGVidWdPdXRwdXRBc3RBc1R5cGVTY3JpcHQgPSBkZWJ1Z091dHB1dEFzdEFzVHlwZVNjcmlwdDtcbiAgZXhwb3J0cy5UeXBlU2NyaXB0RW1pdHRlciA9IFR5cGVTY3JpcHRFbWl0dGVyO1xuICBleHBvcnRzLlBhcnNlTG9jYXRpb24gPSBQYXJzZUxvY2F0aW9uO1xuICBleHBvcnRzLlBhcnNlU291cmNlRmlsZSA9IFBhcnNlU291cmNlRmlsZTtcbiAgZXhwb3J0cy5QYXJzZVNvdXJjZVNwYW4gPSBQYXJzZVNvdXJjZVNwYW47XG4gIGV4cG9ydHMuUGFyc2VFcnJvciA9IFBhcnNlRXJyb3I7XG4gIGV4cG9ydHMuRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5ID0gRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5O1xuICBleHBvcnRzLkNzc1NlbGVjdG9yID0gQ3NzU2VsZWN0b3I7XG4gIGV4cG9ydHMuU2VsZWN0b3JNYXRjaGVyID0gU2VsZWN0b3JNYXRjaGVyO1xuICBleHBvcnRzLlNlbGVjdG9yTGlzdENvbnRleHQgPSBTZWxlY3Rvckxpc3RDb250ZXh0O1xuICBleHBvcnRzLlNlbGVjdG9yQ29udGV4dCA9IFNlbGVjdG9yQ29udGV4dDtcbiAgZXhwb3J0cy5TdHlsZXNDb21waWxlRGVwZW5kZW5jeSA9IFN0eWxlc0NvbXBpbGVEZXBlbmRlbmN5O1xuICBleHBvcnRzLlN0eWxlc0NvbXBpbGVSZXN1bHQgPSBTdHlsZXNDb21waWxlUmVzdWx0O1xuICBleHBvcnRzLkNvbXBpbGVkU3R5bGVzaGVldCA9IENvbXBpbGVkU3R5bGVzaGVldDtcbiAgZXhwb3J0cy5TdHlsZUNvbXBpbGVyID0gU3R5bGVDb21waWxlcjtcbiAgZXhwb3J0cy5UZW1wbGF0ZVBhcnNlRXJyb3IgPSBUZW1wbGF0ZVBhcnNlRXJyb3I7XG4gIGV4cG9ydHMuVGVtcGxhdGVQYXJzZVJlc3VsdCA9IFRlbXBsYXRlUGFyc2VSZXN1bHQ7XG4gIGV4cG9ydHMuVGVtcGxhdGVQYXJzZXIgPSBUZW1wbGF0ZVBhcnNlcjtcbiAgZXhwb3J0cy5zcGxpdENsYXNzZXMgPSBzcGxpdENsYXNzZXM7XG4gIGV4cG9ydHMuUGlwZUNvbGxlY3RvciA9IFBpcGVDb2xsZWN0b3I7XG5cbn0pKTtcbiIsIi8qKlxuICogQGxpY2Vuc2UgQW5ndWxhciB2Mi4xLjFcbiAqIChjKSAyMDEwLTIwMTYgR29vZ2xlLCBJbmMuIGh0dHBzOi8vYW5ndWxhci5pby9cbiAqIExpY2Vuc2U6IE1JVFxuICovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cywgcmVxdWlyZSgncnhqcy9TdWJqZWN0JyksIHJlcXVpcmUoJ3J4anMvT2JzZXJ2YWJsZScpKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cycsICdyeGpzL1N1YmplY3QnLCAncnhqcy9PYnNlcnZhYmxlJ10sIGZhY3RvcnkpIDpcbiAgICAoZmFjdG9yeSgoZ2xvYmFsLm5nID0gZ2xvYmFsLm5nIHx8IHt9LCBnbG9iYWwubmcuY29yZSA9IGdsb2JhbC5uZy5jb3JlIHx8IHt9KSxnbG9iYWwuUngsZ2xvYmFsLlJ4KSk7XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzLHJ4anNfU3ViamVjdCxyeGpzX09ic2VydmFibGUpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBnbG9iYWxTY29wZTtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZiBpbnN0YW5jZW9mIFdvcmtlckdsb2JhbFNjb3BlKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBSZXBsYWNlIGFueSB3aXRoIFdvcmtlckdsb2JhbFNjb3BlIGZyb20gbGliLndlYndvcmtlci5kLnRzICMzNDkyXG4gICAgICAgICAgICBnbG9iYWxTY29wZSA9IHNlbGY7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBnbG9iYWxTY29wZSA9IGdsb2JhbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ2xvYmFsU2NvcGUgPSB3aW5kb3c7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlTWljcm9UYXNrKGZuKSB7XG4gICAgICAgIFpvbmUuY3VycmVudC5zY2hlZHVsZU1pY3JvVGFzaygnc2NoZWR1bGVNaWNyb3Rhc2snLCBmbik7XG4gICAgfVxuICAgIC8vIE5lZWQgdG8gZGVjbGFyZSBhIG5ldyB2YXJpYWJsZSBmb3IgZ2xvYmFsIGhlcmUgc2luY2UgVHlwZVNjcmlwdFxuICAgIC8vIGV4cG9ydHMgdGhlIG9yaWdpbmFsIHZhbHVlIG9mIHRoZSBzeW1ib2wuXG4gICAgdmFyIGdsb2JhbCQxID0gZ2xvYmFsU2NvcGU7XG4gICAgZnVuY3Rpb24gZ2V0VHlwZU5hbWVGb3JEZWJ1Z2dpbmcodHlwZSkge1xuICAgICAgICByZXR1cm4gdHlwZVsnbmFtZSddIHx8IHR5cGVvZiB0eXBlO1xuICAgIH1cbiAgICAvLyBUT0RPOiByZW1vdmUgY2FsbHMgdG8gYXNzZXJ0IGluIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRcbiAgICAvLyBOb3RlOiBDYW4ndCBqdXN0IGV4cG9ydCB0aGlzIGFuZCBpbXBvcnQgaW4gaW4gb3RoZXIgZmlsZXNcbiAgICAvLyBhcyBgYXNzZXJ0YCBpcyBhIHJlc2VydmVkIGtleXdvcmQgaW4gRGFydFxuICAgIGdsb2JhbCQxLmFzc2VydCA9IGZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24pIHtcbiAgICAgICAgLy8gVE9ETzogdG8gYmUgZml4ZWQgcHJvcGVybHkgdmlhICMyODMwLCBub29wIGZvciBub3dcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGlzUHJlc2VudChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiAhPT0gdW5kZWZpbmVkICYmIG9iaiAhPT0gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNCbGFuayhvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiA9PT0gdW5kZWZpbmVkIHx8IG9iaiA9PT0gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RyaW5naWZ5KHRva2VuKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuID09PSB1bmRlZmluZWQgfHwgdG9rZW4gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAnJyArIHRva2VuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbi5vdmVycmlkZGVuTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuLm92ZXJyaWRkZW5OYW1lO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbi5uYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW4ubmFtZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzID0gdG9rZW4udG9TdHJpbmcoKTtcbiAgICAgICAgdmFyIG5ld0xpbmVJbmRleCA9IHJlcy5pbmRleE9mKCdcXG4nKTtcbiAgICAgICAgcmV0dXJuIG5ld0xpbmVJbmRleCA9PT0gLTEgPyByZXMgOiByZXMuc3Vic3RyaW5nKDAsIG5ld0xpbmVJbmRleCk7XG4gICAgfVxuICAgIC8vIEpTIGhhcyBOYU4gIT09IE5hTlxuICAgIGZ1bmN0aW9uIGxvb3NlSWRlbnRpY2FsKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgPT09IGIgfHwgdHlwZW9mIGEgPT09ICdudW1iZXInICYmIHR5cGVvZiBiID09PSAnbnVtYmVyJyAmJiBpc05hTihhKSAmJiBpc05hTihiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNKc09iamVjdChvKSB7XG4gICAgICAgIHJldHVybiBvICE9PSBudWxsICYmICh0eXBlb2YgbyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgbyA9PT0gJ29iamVjdCcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcmludChvYmopIHtcbiAgICAgICAgY29uc29sZS5sb2cob2JqKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd2FybihvYmopIHtcbiAgICAgICAgY29uc29sZS53YXJuKG9iaik7XG4gICAgfVxuICAgIHZhciBfc3ltYm9sSXRlcmF0b3IgPSBudWxsO1xuICAgIGZ1bmN0aW9uIGdldFN5bWJvbEl0ZXJhdG9yKCkge1xuICAgICAgICBpZiAoaXNCbGFuayhfc3ltYm9sSXRlcmF0b3IpKSB7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KGdsb2JhbFNjb3BlLlN5bWJvbCkgJiYgaXNQcmVzZW50KFN5bWJvbC5pdGVyYXRvcikpIHtcbiAgICAgICAgICAgICAgICBfc3ltYm9sSXRlcmF0b3IgPSBTeW1ib2wuaXRlcmF0b3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBlczYtc2hpbSBzcGVjaWZpYyBsb2dpY1xuICAgICAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTWFwLnByb3RvdHlwZSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ICE9PSAnZW50cmllcycgJiYga2V5ICE9PSAnc2l6ZScgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIE1hcC5wcm90b3R5cGVba2V5XSA9PT0gTWFwLnByb3RvdHlwZVsnZW50cmllcyddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfc3ltYm9sSXRlcmF0b3IgPSBrZXk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9zeW1ib2xJdGVyYXRvcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNQcmltaXRpdmUob2JqKSB7XG4gICAgICAgIHJldHVybiAhaXNKc09iamVjdChvYmopO1xuICAgIH1cblxuICAgIHZhciBfbmV4dENsYXNzSWQgPSAwO1xuICAgIHZhciBSZWZsZWN0ID0gZ2xvYmFsJDEuUmVmbGVjdDtcbiAgICBmdW5jdGlvbiBleHRyYWN0QW5ub3RhdGlvbihhbm5vdGF0aW9uKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYW5ub3RhdGlvbiA9PT0gJ2Z1bmN0aW9uJyAmJiBhbm5vdGF0aW9uLmhhc093blByb3BlcnR5KCdhbm5vdGF0aW9uJykpIHtcbiAgICAgICAgICAgIC8vIGl0IGlzIGEgZGVjb3JhdG9yLCBleHRyYWN0IGFubm90YXRpb25cbiAgICAgICAgICAgIGFubm90YXRpb24gPSBhbm5vdGF0aW9uLmFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFubm90YXRpb247XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFwcGx5UGFyYW1zKGZuT3JBcnJheSwga2V5KSB7XG4gICAgICAgIGlmIChmbk9yQXJyYXkgPT09IE9iamVjdCB8fCBmbk9yQXJyYXkgPT09IFN0cmluZyB8fCBmbk9yQXJyYXkgPT09IEZ1bmN0aW9uIHx8XG4gICAgICAgICAgICBmbk9yQXJyYXkgPT09IE51bWJlciB8fCBmbk9yQXJyYXkgPT09IEFycmF5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IHVzZSBuYXRpdmUgXCIgKyBzdHJpbmdpZnkoZm5PckFycmF5KSArIFwiIGFzIGNvbnN0cnVjdG9yXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZm5PckFycmF5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gZm5PckFycmF5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZuT3JBcnJheSkpIHtcbiAgICAgICAgICAgIHZhciBhbm5vdGF0aW9ucyA9IGZuT3JBcnJheTtcbiAgICAgICAgICAgIHZhciBhbm5vTGVuZ3RoID0gYW5ub3RhdGlvbnMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHZhciBmbiA9IGZuT3JBcnJheVthbm5vTGVuZ3RoXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMYXN0IHBvc2l0aW9uIG9mIENsYXNzIG1ldGhvZCBhcnJheSBtdXN0IGJlIEZ1bmN0aW9uIGluIGtleSBcIiArIGtleSArIFwiIHdhcyAnXCIgKyBzdHJpbmdpZnkoZm4pICsgXCInXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFubm9MZW5ndGggIT0gZm4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTnVtYmVyIG9mIGFubm90YXRpb25zIChcIiArIGFubm9MZW5ndGggKyBcIikgZG9lcyBub3QgbWF0Y2ggbnVtYmVyIG9mIGFyZ3VtZW50cyAoXCIgKyBmbi5sZW5ndGggKyBcIikgaW4gdGhlIGZ1bmN0aW9uOiBcIiArIHN0cmluZ2lmeShmbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHBhcmFtc0Fubm90YXRpb25zID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBhbm5vdGF0aW9ucy5sZW5ndGggLSAxOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBwYXJhbUFubm90YXRpb25zID0gW107XG4gICAgICAgICAgICAgICAgcGFyYW1zQW5ub3RhdGlvbnMucHVzaChwYXJhbUFubm90YXRpb25zKTtcbiAgICAgICAgICAgICAgICB2YXIgYW5ub3RhdGlvbiA9IGFubm90YXRpb25zW2ldO1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFubm90YXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYW5ub3RhdGlvbi5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1Bbm5vdGF0aW9ucy5wdXNoKGV4dHJhY3RBbm5vdGF0aW9uKGFubm90YXRpb25bal0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYW5ub3RhdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbUFubm90YXRpb25zLnB1c2goZXh0cmFjdEFubm90YXRpb24oYW5ub3RhdGlvbikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1Bbm5vdGF0aW9ucy5wdXNoKGFubm90YXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJlZmxlY3QuZGVmaW5lTWV0YWRhdGEoJ3BhcmFtZXRlcnMnLCBwYXJhbXNBbm5vdGF0aW9ucywgZm4pO1xuICAgICAgICAgICAgcmV0dXJuIGZuO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9ubHkgRnVuY3Rpb24gb3IgQXJyYXkgaXMgc3VwcG9ydGVkIGluIENsYXNzIGRlZmluaXRpb24gZm9yIGtleSAnXCIgKyBrZXkgKyBcIicgaXMgJ1wiICsgc3RyaW5naWZ5KGZuT3JBcnJheSkgKyBcIidcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGEgd2F5IGZvciBleHByZXNzaW5nIEVTNiBjbGFzc2VzIHdpdGggcGFyYW1ldGVyIGFubm90YXRpb25zIGluIEVTNS5cbiAgICAgKlxuICAgICAqICMjIEJhc2ljIEV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIHZhciBHcmVldGVyID0gbmcuQ2xhc3Moe1xuICAgICAqICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgKiAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgKiAgIH0sXG4gICAgICpcbiAgICAgKiAgIGdyZWV0OiBmdW5jdGlvbigpIHtcbiAgICAgKiAgICAgYWxlcnQoJ0hlbGxvICcgKyB0aGlzLm5hbWUgKyAnIScpO1xuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogaXMgZXF1aXZhbGVudCB0byBFUzY6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBjbGFzcyBHcmVldGVyIHtcbiAgICAgKiAgIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICAgKiAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgKiAgIH1cbiAgICAgKlxuICAgICAqICAgZ3JlZXQoKSB7XG4gICAgICogICAgIGFsZXJ0KCdIZWxsbyAnICsgdGhpcy5uYW1lICsgJyEnKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBvciBlcXVpdmFsZW50IHRvIEVTNTpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIHZhciBHcmVldGVyID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgKiAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICogfVxuICAgICAqXG4gICAgICogR3JlZXRlci5wcm90b3R5cGUuZ3JlZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICogICBhbGVydCgnSGVsbG8gJyArIHRoaXMubmFtZSArICchJyk7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGUgd2l0aCBwYXJhbWV0ZXIgYW5ub3RhdGlvbnNcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIHZhciBNeVNlcnZpY2UgPSBuZy5DbGFzcyh7XG4gICAgICogICBjb25zdHJ1Y3RvcjogW1N0cmluZywgW25ldyBPcHRpb25hbCgpLCBTZXJ2aWNlXSwgZnVuY3Rpb24obmFtZSwgbXlTZXJ2aWNlKSB7XG4gICAgICogICAgIC4uLlxuICAgICAqICAgfV1cbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIGlzIGVxdWl2YWxlbnQgdG8gRVM2OlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogY2xhc3MgTXlTZXJ2aWNlIHtcbiAgICAgKiAgIGNvbnN0cnVjdG9yKG5hbWU6IHN0cmluZywgQE9wdGlvbmFsKCkgbXlTZXJ2aWNlOiBTZXJ2aWNlKSB7XG4gICAgICogICAgIC4uLlxuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlIHdpdGggaW5oZXJpdGFuY2VcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIHZhciBTaGFwZSA9IG5nLkNsYXNzKHtcbiAgICAgKiAgIGNvbnN0cnVjdG9yOiAoY29sb3IpIHtcbiAgICAgKiAgICAgdGhpcy5jb2xvciA9IGNvbG9yO1xuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogdmFyIFNxdWFyZSA9IG5nLkNsYXNzKHtcbiAgICAgKiAgIGV4dGVuZHM6IFNoYXBlLFxuICAgICAqICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uKGNvbG9yLCBzaXplKSB7XG4gICAgICogICAgIFNoYXBlLmNhbGwodGhpcywgY29sb3IpO1xuICAgICAqICAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDbGFzcyhjbHNEZWYpIHtcbiAgICAgICAgdmFyIGNvbnN0cnVjdG9yID0gYXBwbHlQYXJhbXMoY2xzRGVmLmhhc093blByb3BlcnR5KCdjb25zdHJ1Y3RvcicpID8gY2xzRGVmLmNvbnN0cnVjdG9yIDogdW5kZWZpbmVkLCAnY29uc3RydWN0b3InKTtcbiAgICAgICAgdmFyIHByb3RvID0gY29uc3RydWN0b3IucHJvdG90eXBlO1xuICAgICAgICBpZiAoY2xzRGVmLmhhc093blByb3BlcnR5KCdleHRlbmRzJykpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2xzRGVmLmV4dGVuZHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBwcm90byA9XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5jcmVhdGUoY2xzRGVmLmV4dGVuZHMucHJvdG90eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNsYXNzIGRlZmluaXRpb24gJ2V4dGVuZHMnIHByb3BlcnR5IG11c3QgYmUgYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiB3YXM6IFwiICsgc3RyaW5naWZ5KGNsc0RlZi5leHRlbmRzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIga2V5IGluIGNsc0RlZikge1xuICAgICAgICAgICAgaWYgKGtleSAhPT0gJ2V4dGVuZHMnICYmIGtleSAhPT0gJ3Byb3RvdHlwZScgJiYgY2xzRGVmLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBwcm90b1trZXldID0gYXBwbHlQYXJhbXMoY2xzRGVmW2tleV0sIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMgJiYgdGhpcy5hbm5vdGF0aW9ucyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICBSZWZsZWN0LmRlZmluZU1ldGFkYXRhKCdhbm5vdGF0aW9ucycsIHRoaXMuYW5ub3RhdGlvbnMsIGNvbnN0cnVjdG9yKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29uc3RydWN0b3JOYW1lID0gY29uc3RydWN0b3JbJ25hbWUnXTtcbiAgICAgICAgaWYgKCFjb25zdHJ1Y3Rvck5hbWUgfHwgY29uc3RydWN0b3JOYW1lID09PSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgICAgICBjb25zdHJ1Y3Rvclsnb3ZlcnJpZGRlbk5hbWUnXSA9IFwiY2xhc3NcIiArIF9uZXh0Q2xhc3NJZCsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25zdHJ1Y3RvcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFrZURlY29yYXRvcihuYW1lLCBwcm9wcywgcGFyZW50Q2xhc3MsIGNoYWluRm4pIHtcbiAgICAgICAgaWYgKGNoYWluRm4gPT09IHZvaWQgMCkgeyBjaGFpbkZuID0gbnVsbDsgfVxuICAgICAgICB2YXIgbWV0YUN0b3IgPSBtYWtlTWV0YWRhdGFDdG9yKFtwcm9wc10pO1xuICAgICAgICBmdW5jdGlvbiBEZWNvcmF0b3JGYWN0b3J5KG9iak9yVHlwZSkge1xuICAgICAgICAgICAgaWYgKCEoUmVmbGVjdCAmJiBSZWZsZWN0LmdldE1ldGFkYXRhKSkge1xuICAgICAgICAgICAgICAgIHRocm93ICdyZWZsZWN0LW1ldGFkYXRhIHNoaW0gaXMgcmVxdWlyZWQgd2hlbiB1c2luZyBjbGFzcyBkZWNvcmF0b3JzJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgRGVjb3JhdG9yRmFjdG9yeSkge1xuICAgICAgICAgICAgICAgIG1ldGFDdG9yLmNhbGwodGhpcywgb2JqT3JUeXBlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBhbm5vdGF0aW9uSW5zdGFuY2UgPSBuZXcgRGVjb3JhdG9yRmFjdG9yeShvYmpPclR5cGUpO1xuICAgICAgICAgICAgdmFyIGNoYWluQW5ub3RhdGlvbiA9IHR5cGVvZiB0aGlzID09PSAnZnVuY3Rpb24nICYmIEFycmF5LmlzQXJyYXkodGhpcy5hbm5vdGF0aW9ucykgPyB0aGlzLmFubm90YXRpb25zIDogW107XG4gICAgICAgICAgICBjaGFpbkFubm90YXRpb24ucHVzaChhbm5vdGF0aW9uSW5zdGFuY2UpO1xuICAgICAgICAgICAgdmFyIFR5cGVEZWNvcmF0b3IgPSBmdW5jdGlvbiBUeXBlRGVjb3JhdG9yKGNscykge1xuICAgICAgICAgICAgICAgIHZhciBhbm5vdGF0aW9ucyA9IFJlZmxlY3QuZ2V0T3duTWV0YWRhdGEoJ2Fubm90YXRpb25zJywgY2xzKSB8fCBbXTtcbiAgICAgICAgICAgICAgICBhbm5vdGF0aW9ucy5wdXNoKGFubm90YXRpb25JbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgUmVmbGVjdC5kZWZpbmVNZXRhZGF0YSgnYW5ub3RhdGlvbnMnLCBhbm5vdGF0aW9ucywgY2xzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFR5cGVEZWNvcmF0b3IuYW5ub3RhdGlvbnMgPSBjaGFpbkFubm90YXRpb247XG4gICAgICAgICAgICBUeXBlRGVjb3JhdG9yLkNsYXNzID0gQ2xhc3M7XG4gICAgICAgICAgICBpZiAoY2hhaW5GbilcbiAgICAgICAgICAgICAgICBjaGFpbkZuKFR5cGVEZWNvcmF0b3IpO1xuICAgICAgICAgICAgcmV0dXJuIFR5cGVEZWNvcmF0b3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmVudENsYXNzKSB7XG4gICAgICAgICAgICBEZWNvcmF0b3JGYWN0b3J5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUocGFyZW50Q2xhc3MucHJvdG90eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBEZWNvcmF0b3JGYWN0b3J5LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIChcIkBcIiArIG5hbWUpOyB9O1xuICAgICAgICBEZWNvcmF0b3JGYWN0b3J5LmFubm90YXRpb25DbHMgPSBEZWNvcmF0b3JGYWN0b3J5O1xuICAgICAgICByZXR1cm4gRGVjb3JhdG9yRmFjdG9yeTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFrZU1ldGFkYXRhQ3Rvcihwcm9wcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gY3RvcigpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvcHMuZm9yRWFjaChmdW5jdGlvbiAocHJvcCwgaSkge1xuICAgICAgICAgICAgICAgIHZhciBhcmdWYWwgPSBhcmdzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHBsYWluIHBhcmFtZXRlclxuICAgICAgICAgICAgICAgICAgICBfdGhpc1twcm9wWzBdXSA9IGFyZ1ZhbCA9PT0gdW5kZWZpbmVkID8gcHJvcFsxXSA6IGFyZ1ZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHByb3BOYW1lIGluIHByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzW3Byb3BOYW1lXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnVmFsICYmIGFyZ1ZhbC5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkgPyBhcmdWYWxbcHJvcE5hbWVdIDogcHJvcFtwcm9wTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFrZVBhcmFtRGVjb3JhdG9yKG5hbWUsIHByb3BzLCBwYXJlbnRDbGFzcykge1xuICAgICAgICB2YXIgbWV0YUN0b3IgPSBtYWtlTWV0YWRhdGFDdG9yKHByb3BzKTtcbiAgICAgICAgZnVuY3Rpb24gUGFyYW1EZWNvcmF0b3JGYWN0b3J5KCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgUGFyYW1EZWNvcmF0b3JGYWN0b3J5KSB7XG4gICAgICAgICAgICAgICAgbWV0YUN0b3IuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYW5ub3RhdGlvbkluc3RhbmNlID0gbmV3ICgoX2EgPSBQYXJhbURlY29yYXRvckZhY3RvcnkpLmJpbmQuYXBwbHkoX2EsIFt2b2lkIDBdLmNvbmNhdChhcmdzKSkpKCk7XG4gICAgICAgICAgICBQYXJhbURlY29yYXRvci5hbm5vdGF0aW9uID0gYW5ub3RhdGlvbkluc3RhbmNlO1xuICAgICAgICAgICAgcmV0dXJuIFBhcmFtRGVjb3JhdG9yO1xuICAgICAgICAgICAgZnVuY3Rpb24gUGFyYW1EZWNvcmF0b3IoY2xzLCB1bnVzZWRLZXksIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtZXRlcnMgPSBSZWZsZWN0LmdldE1ldGFkYXRhKCdwYXJhbWV0ZXJzJywgY2xzKSB8fCBbXTtcbiAgICAgICAgICAgICAgICAvLyB0aGVyZSBtaWdodCBiZSBnYXBzIGlmIHNvbWUgaW4gYmV0d2VlbiBwYXJhbWV0ZXJzIGRvIG5vdCBoYXZlIGFubm90YXRpb25zLlxuICAgICAgICAgICAgICAgIC8vIHdlIHBhZCB3aXRoIG51bGxzLlxuICAgICAgICAgICAgICAgIHdoaWxlIChwYXJhbWV0ZXJzLmxlbmd0aCA8PSBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLnB1c2gobnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnNbaW5kZXhdID0gcGFyYW1ldGVyc1tpbmRleF0gfHwgW107XG4gICAgICAgICAgICAgICAgcGFyYW1ldGVyc1tpbmRleF0ucHVzaChhbm5vdGF0aW9uSW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgIFJlZmxlY3QuZGVmaW5lTWV0YWRhdGEoJ3BhcmFtZXRlcnMnLCBwYXJhbWV0ZXJzLCBjbHMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjbHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmVudENsYXNzKSB7XG4gICAgICAgICAgICBQYXJhbURlY29yYXRvckZhY3RvcnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRDbGFzcy5wcm90b3R5cGUpO1xuICAgICAgICB9XG4gICAgICAgIFBhcmFtRGVjb3JhdG9yRmFjdG9yeS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoXCJAXCIgKyBuYW1lKTsgfTtcbiAgICAgICAgUGFyYW1EZWNvcmF0b3JGYWN0b3J5LmFubm90YXRpb25DbHMgPSBQYXJhbURlY29yYXRvckZhY3Rvcnk7XG4gICAgICAgIHJldHVybiBQYXJhbURlY29yYXRvckZhY3Rvcnk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1ha2VQcm9wRGVjb3JhdG9yKG5hbWUsIHByb3BzLCBwYXJlbnRDbGFzcykge1xuICAgICAgICB2YXIgbWV0YUN0b3IgPSBtYWtlTWV0YWRhdGFDdG9yKHByb3BzKTtcbiAgICAgICAgZnVuY3Rpb24gUHJvcERlY29yYXRvckZhY3RvcnkoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBQcm9wRGVjb3JhdG9yRmFjdG9yeSkge1xuICAgICAgICAgICAgICAgIG1ldGFDdG9yLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGRlY29yYXRvckluc3RhbmNlID0gbmV3ICgoX2EgPSBQcm9wRGVjb3JhdG9yRmFjdG9yeSkuYmluZC5hcHBseShfYSwgW3ZvaWQgMF0uY29uY2F0KGFyZ3MpKSkoKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBQcm9wRGVjb3JhdG9yKHRhcmdldCwgbmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBtZXRhID0gUmVmbGVjdC5nZXRPd25NZXRhZGF0YSgncHJvcE1ldGFkYXRhJywgdGFyZ2V0LmNvbnN0cnVjdG9yKSB8fCB7fTtcbiAgICAgICAgICAgICAgICBtZXRhW25hbWVdID0gbWV0YS5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBtZXRhW25hbWVdIHx8IFtdO1xuICAgICAgICAgICAgICAgIG1ldGFbbmFtZV0udW5zaGlmdChkZWNvcmF0b3JJbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgUmVmbGVjdC5kZWZpbmVNZXRhZGF0YSgncHJvcE1ldGFkYXRhJywgbWV0YSwgdGFyZ2V0LmNvbnN0cnVjdG9yKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmVudENsYXNzKSB7XG4gICAgICAgICAgICBQcm9wRGVjb3JhdG9yRmFjdG9yeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHBhcmVudENsYXNzLnByb3RvdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgUHJvcERlY29yYXRvckZhY3RvcnkucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKFwiQFwiICsgbmFtZSk7IH07XG4gICAgICAgIFByb3BEZWNvcmF0b3JGYWN0b3J5LmFubm90YXRpb25DbHMgPSBQcm9wRGVjb3JhdG9yRmFjdG9yeTtcbiAgICAgICAgcmV0dXJuIFByb3BEZWNvcmF0b3JGYWN0b3J5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluamVjdCBkZWNvcmF0b3IgYW5kIG1ldGFkYXRhLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqIEBBbm5vdGF0aW9uXG4gICAgICovXG4gICAgdmFyIEluamVjdCA9IG1ha2VQYXJhbURlY29yYXRvcignSW5qZWN0JywgW1sndG9rZW4nLCB1bmRlZmluZWRdXSk7XG4gICAgLyoqXG4gICAgICogT3B0aW9uYWwgZGVjb3JhdG9yIGFuZCBtZXRhZGF0YS5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKiBAQW5ub3RhdGlvblxuICAgICAqL1xuICAgIHZhciBPcHRpb25hbCA9IG1ha2VQYXJhbURlY29yYXRvcignT3B0aW9uYWwnLCBbXSk7XG4gICAgLyoqXG4gICAgICogSW5qZWN0YWJsZSBkZWNvcmF0b3IgYW5kIG1ldGFkYXRhLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqIEBBbm5vdGF0aW9uXG4gICAgICovXG4gICAgdmFyIEluamVjdGFibGUgPSBtYWtlUGFyYW1EZWNvcmF0b3IoJ0luamVjdGFibGUnLCBbXSk7XG4gICAgLyoqXG4gICAgICogU2VsZiBkZWNvcmF0b3IgYW5kIG1ldGFkYXRhLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqIEBBbm5vdGF0aW9uXG4gICAgICovXG4gICAgdmFyIFNlbGYgPSBtYWtlUGFyYW1EZWNvcmF0b3IoJ1NlbGYnLCBbXSk7XG4gICAgLyoqXG4gICAgICogU2tpcFNlbGYgZGVjb3JhdG9yIGFuZCBtZXRhZGF0YS5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKiBAQW5ub3RhdGlvblxuICAgICAqL1xuICAgIHZhciBTa2lwU2VsZiA9IG1ha2VQYXJhbURlY29yYXRvcignU2tpcFNlbGYnLCBbXSk7XG4gICAgLyoqXG4gICAgICogSG9zdCBkZWNvcmF0b3IgYW5kIG1ldGFkYXRhLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqIEBBbm5vdGF0aW9uXG4gICAgICovXG4gICAgdmFyIEhvc3QgPSBtYWtlUGFyYW1EZWNvcmF0b3IoJ0hvc3QnLCBbXSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgdG9rZW4gdGhhdCBjYW4gYmUgdXNlZCBpbiBhIERJIFByb3ZpZGVyLlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L1lzOWV6WHBqMk1ub3kzVWM4S0JwP3A9cHJldmlldykpXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdmFyIHQgPSBuZXcgT3BhcXVlVG9rZW4oXCJ2YWx1ZVwiKTtcbiAgICAgKlxuICAgICAqIHZhciBpbmplY3RvciA9IEluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW1xuICAgICAqICAge3Byb3ZpZGU6IHQsIHVzZVZhbHVlOiBcImJpbmRpbmdWYWx1ZVwifVxuICAgICAqIF0pO1xuICAgICAqXG4gICAgICogZXhwZWN0KGluamVjdG9yLmdldCh0KSkudG9FcXVhbChcImJpbmRpbmdWYWx1ZVwiKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFVzaW5nIGFuIGBPcGFxdWVUb2tlbmAgaXMgcHJlZmVyYWJsZSB0byB1c2luZyBzdHJpbmdzIGFzIHRva2VucyBiZWNhdXNlIG9mIHBvc3NpYmxlIGNvbGxpc2lvbnNcbiAgICAgKiBjYXVzZWQgYnkgbXVsdGlwbGUgcHJvdmlkZXJzIHVzaW5nIHRoZSBzYW1lIHN0cmluZyBhcyB0d28gZGlmZmVyZW50IHRva2Vucy5cbiAgICAgKlxuICAgICAqIFVzaW5nIGFuIGBPcGFxdWVUb2tlbmAgaXMgcHJlZmVyYWJsZSB0byB1c2luZyBhbiBgT2JqZWN0YCBhcyB0b2tlbnMgYmVjYXVzZSBpdCBwcm92aWRlcyBiZXR0ZXJcbiAgICAgKiBlcnJvciBtZXNzYWdlcy5cbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgLy8gc28gdGhhdCBtZXRhZGF0YSBpcyBnYXRoZXJlZCBmb3IgdGhpcyBjbGFzc1xuICAgIHZhciBPcGFxdWVUb2tlbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE9wYXF1ZVRva2VuKF9kZXNjKSB7XG4gICAgICAgICAgICB0aGlzLl9kZXNjID0gX2Rlc2M7XG4gICAgICAgIH1cbiAgICAgICAgT3BhcXVlVG9rZW4ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJUb2tlbiBcIiArIHRoaXMuX2Rlc2M7IH07XG4gICAgICAgIE9wYXF1ZVRva2VuLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IEluamVjdGFibGUgfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIE9wYXF1ZVRva2VuLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIE9wYXF1ZVRva2VuO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIHRva2VuIGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSBhIHZpcnR1YWwgcHJvdmlkZXIgdGhhdCB3aWxsIHBvcHVsYXRlIHRoZVxuICAgICAqIGBlbnRyeUNvbXBvbmVudHNgIGZpZWxkcyBvZiBjb21wb25lbnRzIGFuZCBuZyBtb2R1bGVzIGJhc2VkIG9uIGl0cyBgdXNlVmFsdWVgLlxuICAgICAqIEFsbCBjb21wb25lbnRzIHRoYXQgYXJlIHJlZmVyZW5jZWQgaW4gdGhlIGB1c2VWYWx1ZWAgdmFsdWUgKGVpdGhlciBkaXJlY3RseVxuICAgICAqIG9yIGluIGEgbmVzdGVkIGFycmF5IG9yIG1hcCkgd2lsbCBiZSBhZGRlZCB0byB0aGUgYGVudHJ5Q29tcG9uZW50c2AgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqIFRoZSBmb2xsb3dpbmcgZXhhbXBsZSBzaG93cyBob3cgdGhlIHJvdXRlciBjYW4gcG9wdWxhdGUgdGhlIGBlbnRyeUNvbXBvbmVudHNgXG4gICAgICogZmllbGQgb2YgYW4gTmdNb2R1bGUgYmFzZWQgb24gdGhlIHJvdXRlciBjb25maWd1cmF0aW9uIHdoaWNoIHJlZmVyc1xuICAgICAqIHRvIGNvbXBvbmVudHMuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogLy8gaGVscGVyIGZ1bmN0aW9uIGluc2lkZSB0aGUgcm91dGVyXG4gICAgICogZnVuY3Rpb24gcHJvdmlkZVJvdXRlcyhyb3V0ZXMpIHtcbiAgICAgKiAgIHJldHVybiBbXG4gICAgICogICAgIHtwcm92aWRlOiBST1VURVMsIHVzZVZhbHVlOiByb3V0ZXN9LFxuICAgICAqICAgICB7cHJvdmlkZTogQU5BTFlaRV9GT1JfRU5UUllfQ09NUE9ORU5UUywgdXNlVmFsdWU6IHJvdXRlcywgbXVsdGk6IHRydWV9XG4gICAgICogICBdO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIC8vIHVzZXIgY29kZVxuICAgICAqIGxldCByb3V0ZXMgPSBbXG4gICAgICogICB7cGF0aDogJy9yb290JywgY29tcG9uZW50OiBSb290Q29tcH0sXG4gICAgICogICB7cGF0aDogJy90ZWFtcycsIGNvbXBvbmVudDogVGVhbXNDb21wfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBATmdNb2R1bGUoe1xuICAgICAqICAgcHJvdmlkZXJzOiBbcHJvdmlkZVJvdXRlcyhyb3V0ZXMpXVxuICAgICAqIH0pXG4gICAgICogY2xhc3MgTW9kdWxlV2l0aFJvdXRlcyB7fVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBBTkFMWVpFX0ZPUl9FTlRSWV9DT01QT05FTlRTID0gbmV3IE9wYXF1ZVRva2VuKCdBbmFseXplRm9yRW50cnlDb21wb25lbnRzJyk7XG4gICAgLyoqXG4gICAgICogQXR0cmlidXRlIGRlY29yYXRvciBhbmQgbWV0YWRhdGEuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICogQEFubm90YXRpb25cbiAgICAgKi9cbiAgICB2YXIgQXR0cmlidXRlID0gbWFrZVBhcmFtRGVjb3JhdG9yKCdBdHRyaWJ1dGUnLCBbWydhdHRyaWJ1dGVOYW1lJywgdW5kZWZpbmVkXV0pO1xuICAgIC8qKlxuICAgICAqIEJhc2UgY2xhc3MgZm9yIHF1ZXJ5IG1ldGFkYXRhLlxuICAgICAqXG4gICAgICogU2VlIHtAbGluayBDb250ZW50Q2hpbGRyZW59LCB7QGxpbmsgQ29udGVudENoaWxkfSwge0BsaW5rIFZpZXdDaGlsZHJlbn0sIHtAbGluayBWaWV3Q2hpbGR9IGZvclxuICAgICAqIG1vcmUgaW5mb3JtYXRpb24uXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIFF1ZXJ5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUXVlcnkoKSB7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFF1ZXJ5O1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogQ29udGVudENoaWxkcmVuIGRlY29yYXRvciBhbmQgbWV0YWRhdGEuXG4gICAgICpcbiAgICAgKiAgQHN0YWJsZVxuICAgICAqICBAQW5ub3RhdGlvblxuICAgICAqL1xuICAgIHZhciBDb250ZW50Q2hpbGRyZW4gPSBtYWtlUHJvcERlY29yYXRvcignQ29udGVudENoaWxkcmVuJywgW1xuICAgICAgICBbJ3NlbGVjdG9yJywgdW5kZWZpbmVkXSwge1xuICAgICAgICAgICAgZmlyc3Q6IGZhbHNlLFxuICAgICAgICAgICAgaXNWaWV3UXVlcnk6IGZhbHNlLFxuICAgICAgICAgICAgZGVzY2VuZGFudHM6IGZhbHNlLFxuICAgICAgICAgICAgcmVhZDogdW5kZWZpbmVkLFxuICAgICAgICB9XG4gICAgXSwgUXVlcnkpO1xuICAgIC8qKlxuICAgICAqIEB3aGF0SXREb2VzIENvbmZpZ3VyZXMgYSBjb250ZW50IHF1ZXJ5LlxuICAgICAqXG4gICAgICogQGhvd1RvVXNlXG4gICAgICpcbiAgICAgKiB7QGV4YW1wbGUgY29yZS9kaS90cy9jb250ZW50Q2hpbGQvY29udGVudF9jaGlsZF9ob3d0by50cyByZWdpb249J0hvd1RvJ31cbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogWW91IGNhbiB1c2UgQ29udGVudENoaWxkIHRvIGdldCB0aGUgZmlyc3QgZWxlbWVudCBvciB0aGUgZGlyZWN0aXZlIG1hdGNoaW5nIHRoZSBzZWxlY3RvciBmcm9tIHRoZVxuICAgICAqIGNvbnRlbnQgRE9NLiBJZiB0aGUgY29udGVudCBET00gY2hhbmdlcywgYW5kIGEgbmV3IGNoaWxkIG1hdGNoZXMgdGhlIHNlbGVjdG9yLFxuICAgICAqIHRoZSBwcm9wZXJ0eSB3aWxsIGJlIHVwZGF0ZWQuXG4gICAgICpcbiAgICAgKiBDb250ZW50IHF1ZXJpZXMgYXJlIHNldCBiZWZvcmUgdGhlIGBuZ0FmdGVyQ29udGVudEluaXRgIGNhbGxiYWNrIGlzIGNhbGxlZC5cbiAgICAgKlxuICAgICAqICoqTWV0YWRhdGEgUHJvcGVydGllcyoqOlxuICAgICAqXG4gICAgICogKiAqKnNlbGVjdG9yKiogLSB0aGUgZGlyZWN0aXZlIHR5cGUgb3IgdGhlIG5hbWUgdXNlZCBmb3IgcXVlcnlpbmcuXG4gICAgICogKiAqKnJlYWQqKiAtIHJlYWQgYSBkaWZmZXJlbnQgdG9rZW4gZnJvbSB0aGUgcXVlcmllZCBlbGVtZW50LlxuICAgICAqXG4gICAgICogTGV0J3MgbG9vayBhdCBhbiBleGFtcGxlOlxuICAgICAqXG4gICAgICoge0BleGFtcGxlIGNvcmUvZGkvdHMvY29udGVudENoaWxkL2NvbnRlbnRfY2hpbGRfZXhhbXBsZS50cyByZWdpb249J0NvbXBvbmVudCd9XG4gICAgICpcbiAgICAgKiAqKm5wbSBwYWNrYWdlKio6IGBAYW5ndWxhci9jb3JlYFxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqIEBBbm5vdGF0aW9uXG4gICAgICovXG4gICAgdmFyIENvbnRlbnRDaGlsZCA9IG1ha2VQcm9wRGVjb3JhdG9yKCdDb250ZW50Q2hpbGQnLCBbXG4gICAgICAgIFsnc2VsZWN0b3InLCB1bmRlZmluZWRdLCB7XG4gICAgICAgICAgICBmaXJzdDogdHJ1ZSxcbiAgICAgICAgICAgIGlzVmlld1F1ZXJ5OiBmYWxzZSxcbiAgICAgICAgICAgIGRlc2NlbmRhbnRzOiB0cnVlLFxuICAgICAgICAgICAgcmVhZDogdW5kZWZpbmVkLFxuICAgICAgICB9XG4gICAgXSwgUXVlcnkpO1xuICAgIC8qKlxuICAgICAqIEB3aGF0SXREb2VzIENvbmZpZ3VyZXMgYSB2aWV3IHF1ZXJ5LlxuICAgICAqXG4gICAgICogQGhvd1RvVXNlXG4gICAgICpcbiAgICAgKiB7QGV4YW1wbGUgY29yZS9kaS90cy92aWV3Q2hpbGRyZW4vdmlld19jaGlsZHJlbl9ob3d0by50cyByZWdpb249J0hvd1RvJ31cbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogWW91IGNhbiB1c2UgVmlld0NoaWxkcmVuIHRvIGdldCB0aGUge0BsaW5rIFF1ZXJ5TGlzdH0gb2YgZWxlbWVudHMgb3IgZGlyZWN0aXZlcyBmcm9tIHRoZVxuICAgICAqIHZpZXcgRE9NLiBBbnkgdGltZSBhIGNoaWxkIGVsZW1lbnQgaXMgYWRkZWQsIHJlbW92ZWQsIG9yIG1vdmVkLCB0aGUgcXVlcnkgbGlzdCB3aWxsIGJlIHVwZGF0ZWQsXG4gICAgICogYW5kIHRoZSBjaGFuZ2VzIG9ic2VydmFibGUgb2YgdGhlIHF1ZXJ5IGxpc3Qgd2lsbCBlbWl0IGEgbmV3IHZhbHVlLlxuICAgICAqXG4gICAgICogVmlldyBxdWVyaWVzIGFyZSBzZXQgYmVmb3JlIHRoZSBgbmdBZnRlclZpZXdJbml0YCBjYWxsYmFjayBpcyBjYWxsZWQuXG4gICAgICpcbiAgICAgKiAqKk1ldGFkYXRhIFByb3BlcnRpZXMqKjpcbiAgICAgKlxuICAgICAqICogKipzZWxlY3RvcioqIC0gdGhlIGRpcmVjdGl2ZSB0eXBlIG9yIHRoZSBuYW1lIHVzZWQgZm9yIHF1ZXJ5aW5nLlxuICAgICAqICogKipyZWFkKiogLSByZWFkIGEgZGlmZmVyZW50IHRva2VuIGZyb20gdGhlIHF1ZXJpZWQgZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBMZXQncyBsb29rIGF0IGFuIGV4YW1wbGU6XG4gICAgICpcbiAgICAgKiB7QGV4YW1wbGUgY29yZS9kaS90cy92aWV3Q2hpbGRyZW4vdmlld19jaGlsZHJlbl9leGFtcGxlLnRzIHJlZ2lvbj0nQ29tcG9uZW50J31cbiAgICAgKlxuICAgICAqICoqbnBtIHBhY2thZ2UqKjogYEBhbmd1bGFyL2NvcmVgXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICogQEFubm90YXRpb25cbiAgICAgKi9cbiAgICB2YXIgVmlld0NoaWxkcmVuID0gbWFrZVByb3BEZWNvcmF0b3IoJ1ZpZXdDaGlsZHJlbicsIFtcbiAgICAgICAgWydzZWxlY3RvcicsIHVuZGVmaW5lZF0sIHtcbiAgICAgICAgICAgIGZpcnN0OiBmYWxzZSxcbiAgICAgICAgICAgIGlzVmlld1F1ZXJ5OiB0cnVlLFxuICAgICAgICAgICAgZGVzY2VuZGFudHM6IHRydWUsXG4gICAgICAgICAgICByZWFkOiB1bmRlZmluZWQsXG4gICAgICAgIH1cbiAgICBdLCBRdWVyeSk7XG4gICAgLyoqXG4gICAgICogVmlld0NoaWxkIGRlY29yYXRvciBhbmQgbWV0YWRhdGEuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICogQEFubm90YXRpb25cbiAgICAgKi9cbiAgICB2YXIgVmlld0NoaWxkID0gbWFrZVByb3BEZWNvcmF0b3IoJ1ZpZXdDaGlsZCcsIFtcbiAgICAgICAgWydzZWxlY3RvcicsIHVuZGVmaW5lZF0sIHtcbiAgICAgICAgICAgIGZpcnN0OiB0cnVlLFxuICAgICAgICAgICAgaXNWaWV3UXVlcnk6IHRydWUsXG4gICAgICAgICAgICBkZXNjZW5kYW50czogdHJ1ZSxcbiAgICAgICAgICAgIHJlYWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgfVxuICAgIF0sIFF1ZXJ5KTtcblxuICAgIC8qKlxuICAgICAqIERlc2NyaWJlcyB3aXRoaW4gdGhlIGNoYW5nZSBkZXRlY3RvciB3aGljaCBzdHJhdGVneSB3aWxsIGJlIHVzZWQgdGhlIG5leHQgdGltZSBjaGFuZ2VcbiAgICAgKiBkZXRlY3Rpb24gaXMgdHJpZ2dlcmVkLlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICBleHBvcnRzLkNoYW5nZURldGVjdGlvblN0cmF0ZWd5O1xuICAgIChmdW5jdGlvbiAoQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGBPblB1c2hgIG1lYW5zIHRoYXQgdGhlIGNoYW5nZSBkZXRlY3RvcidzIG1vZGUgd2lsbCBiZSBzZXQgdG8gYENoZWNrT25jZWAgZHVyaW5nIGh5ZHJhdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIENoYW5nZURldGVjdGlvblN0cmF0ZWd5W0NoYW5nZURldGVjdGlvblN0cmF0ZWd5W1wiT25QdXNoXCJdID0gMF0gPSBcIk9uUHVzaFwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogYERlZmF1bHRgIG1lYW5zIHRoYXQgdGhlIGNoYW5nZSBkZXRlY3RvcidzIG1vZGUgd2lsbCBiZSBzZXQgdG8gYENoZWNrQWx3YXlzYCBkdXJpbmcgaHlkcmF0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3lbQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3lbXCJEZWZhdWx0XCJdID0gMV0gPSBcIkRlZmF1bHRcIjtcbiAgICB9KShleHBvcnRzLkNoYW5nZURldGVjdGlvblN0cmF0ZWd5IHx8IChleHBvcnRzLkNoYW5nZURldGVjdGlvblN0cmF0ZWd5ID0ge30pKTtcbiAgICAvKipcbiAgICAgKiBEZXNjcmliZXMgdGhlIHN0YXR1cyBvZiB0aGUgZGV0ZWN0b3IuXG4gICAgICovXG4gICAgdmFyIENoYW5nZURldGVjdG9yU3RhdHVzO1xuICAgIChmdW5jdGlvbiAoQ2hhbmdlRGV0ZWN0b3JTdGF0dXMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGBDaGVja2VkT25jZWAgbWVhbnMgdGhhdCBhZnRlciBjYWxsaW5nIGRldGVjdENoYW5nZXMgdGhlIG1vZGUgb2YgdGhlIGNoYW5nZSBkZXRlY3RvclxuICAgICAgICAgKiB3aWxsIGJlY29tZSBgQ2hlY2tlZGAuXG4gICAgICAgICAqL1xuICAgICAgICBDaGFuZ2VEZXRlY3RvclN0YXR1c1tDaGFuZ2VEZXRlY3RvclN0YXR1c1tcIkNoZWNrT25jZVwiXSA9IDBdID0gXCJDaGVja09uY2VcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGBDaGVja2VkYCBtZWFucyB0aGF0IHRoZSBjaGFuZ2UgZGV0ZWN0b3Igc2hvdWxkIGJlIHNraXBwZWQgdW50aWwgaXRzIG1vZGUgY2hhbmdlcyB0b1xuICAgICAgICAgKiBgQ2hlY2tPbmNlYC5cbiAgICAgICAgICovXG4gICAgICAgIENoYW5nZURldGVjdG9yU3RhdHVzW0NoYW5nZURldGVjdG9yU3RhdHVzW1wiQ2hlY2tlZFwiXSA9IDFdID0gXCJDaGVja2VkXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBgQ2hlY2tBbHdheXNgIG1lYW5zIHRoYXQgYWZ0ZXIgY2FsbGluZyBkZXRlY3RDaGFuZ2VzIHRoZSBtb2RlIG9mIHRoZSBjaGFuZ2UgZGV0ZWN0b3JcbiAgICAgICAgICogd2lsbCByZW1haW4gYENoZWNrQWx3YXlzYC5cbiAgICAgICAgICovXG4gICAgICAgIENoYW5nZURldGVjdG9yU3RhdHVzW0NoYW5nZURldGVjdG9yU3RhdHVzW1wiQ2hlY2tBbHdheXNcIl0gPSAyXSA9IFwiQ2hlY2tBbHdheXNcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGBEZXRhY2hlZGAgbWVhbnMgdGhhdCB0aGUgY2hhbmdlIGRldGVjdG9yIHN1YiB0cmVlIGlzIG5vdCBhIHBhcnQgb2YgdGhlIG1haW4gdHJlZSBhbmRcbiAgICAgICAgICogc2hvdWxkIGJlIHNraXBwZWQuXG4gICAgICAgICAqL1xuICAgICAgICBDaGFuZ2VEZXRlY3RvclN0YXR1c1tDaGFuZ2VEZXRlY3RvclN0YXR1c1tcIkRldGFjaGVkXCJdID0gM10gPSBcIkRldGFjaGVkXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBgRXJyb3JlZGAgbWVhbnMgdGhhdCB0aGUgY2hhbmdlIGRldGVjdG9yIGVuY291bnRlcmVkIGFuIGVycm9yIGNoZWNraW5nIGEgYmluZGluZ1xuICAgICAgICAgKiBvciBjYWxsaW5nIGEgZGlyZWN0aXZlIGxpZmVjeWNsZSBtZXRob2QgYW5kIGlzIG5vdyBpbiBhbiBpbmNvbnNpc3RlbnQgc3RhdGUuIENoYW5nZVxuICAgICAgICAgKiBkZXRlY3RvcnMgaW4gdGhpcyBzdGF0ZSB3aWxsIG5vIGxvbmdlciBkZXRlY3QgY2hhbmdlcy5cbiAgICAgICAgICovXG4gICAgICAgIENoYW5nZURldGVjdG9yU3RhdHVzW0NoYW5nZURldGVjdG9yU3RhdHVzW1wiRXJyb3JlZFwiXSA9IDRdID0gXCJFcnJvcmVkXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBgRGVzdHJveWVkYCBtZWFucyB0aGF0IHRoZSBjaGFuZ2UgZGV0ZWN0b3IgaXMgZGVzdHJveWVkLlxuICAgICAgICAgKi9cbiAgICAgICAgQ2hhbmdlRGV0ZWN0b3JTdGF0dXNbQ2hhbmdlRGV0ZWN0b3JTdGF0dXNbXCJEZXN0cm95ZWRcIl0gPSA1XSA9IFwiRGVzdHJveWVkXCI7XG4gICAgfSkoQ2hhbmdlRGV0ZWN0b3JTdGF0dXMgfHwgKENoYW5nZURldGVjdG9yU3RhdHVzID0ge30pKTtcbiAgICBmdW5jdGlvbiBpc0RlZmF1bHRDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneShjaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSkge1xuICAgICAgICByZXR1cm4gaXNCbGFuayhjaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSkgfHxcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvblN0cmF0ZWd5ID09PSBleHBvcnRzLkNoYW5nZURldGVjdGlvblN0cmF0ZWd5LkRlZmF1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGlyZWN0aXZlIGRlY29yYXRvciBhbmQgbWV0YWRhdGEuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICogQEFubm90YXRpb25cbiAgICAgKi9cbiAgICB2YXIgRGlyZWN0aXZlID0gbWFrZURlY29yYXRvcignRGlyZWN0aXZlJywge1xuICAgICAgICBzZWxlY3RvcjogdW5kZWZpbmVkLFxuICAgICAgICBpbnB1dHM6IHVuZGVmaW5lZCxcbiAgICAgICAgb3V0cHV0czogdW5kZWZpbmVkLFxuICAgICAgICBob3N0OiB1bmRlZmluZWQsXG4gICAgICAgIHByb3ZpZGVyczogdW5kZWZpbmVkLFxuICAgICAgICBleHBvcnRBczogdW5kZWZpbmVkLFxuICAgICAgICBxdWVyaWVzOiB1bmRlZmluZWRcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBDb21wb25lbnQgZGVjb3JhdG9yIGFuZCBtZXRhZGF0YS5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKiBAQW5ub3RhdGlvblxuICAgICAqL1xuICAgIHZhciBDb21wb25lbnQgPSBtYWtlRGVjb3JhdG9yKCdDb21wb25lbnQnLCB7XG4gICAgICAgIHNlbGVjdG9yOiB1bmRlZmluZWQsXG4gICAgICAgIGlucHV0czogdW5kZWZpbmVkLFxuICAgICAgICBvdXRwdXRzOiB1bmRlZmluZWQsXG4gICAgICAgIGhvc3Q6IHVuZGVmaW5lZCxcbiAgICAgICAgZXhwb3J0QXM6IHVuZGVmaW5lZCxcbiAgICAgICAgbW9kdWxlSWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgcHJvdmlkZXJzOiB1bmRlZmluZWQsXG4gICAgICAgIHZpZXdQcm92aWRlcnM6IHVuZGVmaW5lZCxcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBleHBvcnRzLkNoYW5nZURldGVjdGlvblN0cmF0ZWd5LkRlZmF1bHQsXG4gICAgICAgIHF1ZXJpZXM6IHVuZGVmaW5lZCxcbiAgICAgICAgdGVtcGxhdGVVcmw6IHVuZGVmaW5lZCxcbiAgICAgICAgdGVtcGxhdGU6IHVuZGVmaW5lZCxcbiAgICAgICAgc3R5bGVVcmxzOiB1bmRlZmluZWQsXG4gICAgICAgIHN0eWxlczogdW5kZWZpbmVkLFxuICAgICAgICBhbmltYXRpb25zOiB1bmRlZmluZWQsXG4gICAgICAgIGVuY2Fwc3VsYXRpb246IHVuZGVmaW5lZCxcbiAgICAgICAgaW50ZXJwb2xhdGlvbjogdW5kZWZpbmVkLFxuICAgICAgICBlbnRyeUNvbXBvbmVudHM6IHVuZGVmaW5lZFxuICAgIH0sIERpcmVjdGl2ZSk7XG4gICAgLyoqXG4gICAgICogUGlwZSBkZWNvcmF0b3IgYW5kIG1ldGFkYXRhLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqIEBBbm5vdGF0aW9uXG4gICAgICovXG4gICAgdmFyIFBpcGUgPSBtYWtlRGVjb3JhdG9yKCdQaXBlJywge1xuICAgICAgICBuYW1lOiB1bmRlZmluZWQsXG4gICAgICAgIHB1cmU6IHRydWUsXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogSW5wdXQgZGVjb3JhdG9yIGFuZCBtZXRhZGF0YS5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKiBAQW5ub3RhdGlvblxuICAgICAqL1xuICAgIHZhciBJbnB1dCA9IG1ha2VQcm9wRGVjb3JhdG9yKCdJbnB1dCcsIFtbJ2JpbmRpbmdQcm9wZXJ0eU5hbWUnLCB1bmRlZmluZWRdXSk7XG4gICAgLyoqXG4gICAgICogT3V0cHV0IGRlY29yYXRvciBhbmQgbWV0YWRhdGEuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICogQEFubm90YXRpb25cbiAgICAgKi9cbiAgICB2YXIgT3V0cHV0ID0gbWFrZVByb3BEZWNvcmF0b3IoJ091dHB1dCcsIFtbJ2JpbmRpbmdQcm9wZXJ0eU5hbWUnLCB1bmRlZmluZWRdXSk7XG4gICAgLyoqXG4gICAgICogSG9zdEJpbmRpbmcgZGVjb3JhdG9yIGFuZCBtZXRhZGF0YS5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKiBAQW5ub3RhdGlvblxuICAgICAqL1xuICAgIHZhciBIb3N0QmluZGluZyA9IG1ha2VQcm9wRGVjb3JhdG9yKCdIb3N0QmluZGluZycsIFtbJ2hvc3RQcm9wZXJ0eU5hbWUnLCB1bmRlZmluZWRdXSk7XG4gICAgLyoqXG4gICAgICogSG9zdEJpbmRpbmcgZGVjb3JhdG9yIGFuZCBtZXRhZGF0YS5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKiBAQW5ub3RhdGlvblxuICAgICAqL1xuICAgIHZhciBIb3N0TGlzdGVuZXIgPSBtYWtlUHJvcERlY29yYXRvcignSG9zdExpc3RlbmVyJywgW1snZXZlbnROYW1lJywgdW5kZWZpbmVkXSwgWydhcmdzJywgW11dXSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBMaWZlY3ljbGVIb29rcztcbiAgICAoZnVuY3Rpb24gKExpZmVjeWNsZUhvb2tzKSB7XG4gICAgICAgIExpZmVjeWNsZUhvb2tzW0xpZmVjeWNsZUhvb2tzW1wiT25Jbml0XCJdID0gMF0gPSBcIk9uSW5pdFwiO1xuICAgICAgICBMaWZlY3ljbGVIb29rc1tMaWZlY3ljbGVIb29rc1tcIk9uRGVzdHJveVwiXSA9IDFdID0gXCJPbkRlc3Ryb3lcIjtcbiAgICAgICAgTGlmZWN5Y2xlSG9va3NbTGlmZWN5Y2xlSG9va3NbXCJEb0NoZWNrXCJdID0gMl0gPSBcIkRvQ2hlY2tcIjtcbiAgICAgICAgTGlmZWN5Y2xlSG9va3NbTGlmZWN5Y2xlSG9va3NbXCJPbkNoYW5nZXNcIl0gPSAzXSA9IFwiT25DaGFuZ2VzXCI7XG4gICAgICAgIExpZmVjeWNsZUhvb2tzW0xpZmVjeWNsZUhvb2tzW1wiQWZ0ZXJDb250ZW50SW5pdFwiXSA9IDRdID0gXCJBZnRlckNvbnRlbnRJbml0XCI7XG4gICAgICAgIExpZmVjeWNsZUhvb2tzW0xpZmVjeWNsZUhvb2tzW1wiQWZ0ZXJDb250ZW50Q2hlY2tlZFwiXSA9IDVdID0gXCJBZnRlckNvbnRlbnRDaGVja2VkXCI7XG4gICAgICAgIExpZmVjeWNsZUhvb2tzW0xpZmVjeWNsZUhvb2tzW1wiQWZ0ZXJWaWV3SW5pdFwiXSA9IDZdID0gXCJBZnRlclZpZXdJbml0XCI7XG4gICAgICAgIExpZmVjeWNsZUhvb2tzW0xpZmVjeWNsZUhvb2tzW1wiQWZ0ZXJWaWV3Q2hlY2tlZFwiXSA9IDddID0gXCJBZnRlclZpZXdDaGVja2VkXCI7XG4gICAgfSkoTGlmZWN5Y2xlSG9va3MgfHwgKExpZmVjeWNsZUhvb2tzID0ge30pKTtcbiAgICB2YXIgTElGRUNZQ0xFX0hPT0tTX1ZBTFVFUyA9IFtcbiAgICAgICAgTGlmZWN5Y2xlSG9va3MuT25Jbml0LCBMaWZlY3ljbGVIb29rcy5PbkRlc3Ryb3ksIExpZmVjeWNsZUhvb2tzLkRvQ2hlY2ssIExpZmVjeWNsZUhvb2tzLk9uQ2hhbmdlcyxcbiAgICAgICAgTGlmZWN5Y2xlSG9va3MuQWZ0ZXJDb250ZW50SW5pdCwgTGlmZWN5Y2xlSG9va3MuQWZ0ZXJDb250ZW50Q2hlY2tlZCwgTGlmZWN5Y2xlSG9va3MuQWZ0ZXJWaWV3SW5pdCxcbiAgICAgICAgTGlmZWN5Y2xlSG9va3MuQWZ0ZXJWaWV3Q2hlY2tlZFxuICAgIF07XG4gICAgLyoqXG4gICAgICogQHdoYXRJdERvZXMgTGlmZWN5Y2xlIGhvb2sgdGhhdCBpcyBjYWxsZWQgd2hlbiBhbnkgZGF0YS1ib3VuZCBwcm9wZXJ0eSBvZiBhIGRpcmVjdGl2ZSBjaGFuZ2VzLlxuICAgICAqIEBob3dUb1VzZVxuICAgICAqIHtAZXhhbXBsZSBjb3JlL3RzL21ldGFkYXRhL2xpZmVjeWNsZV9ob29rc19zcGVjLnRzIHJlZ2lvbj0nT25DaGFuZ2VzJ31cbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIGBuZ09uQ2hhbmdlc2AgaXMgY2FsbGVkIHJpZ2h0IGFmdGVyIHRoZSBkYXRhLWJvdW5kIHByb3BlcnRpZXMgaGF2ZSBiZWVuIGNoZWNrZWQgYW5kIGJlZm9yZSB2aWV3XG4gICAgICogYW5kIGNvbnRlbnQgY2hpbGRyZW4gYXJlIGNoZWNrZWQgaWYgYXQgbGVhc3Qgb25lIG9mIHRoZW0gaGFzIGNoYW5nZWQuXG4gICAgICogVGhlIGBjaGFuZ2VzYCBwYXJhbWV0ZXIgY29udGFpbnMgdGhlIGNoYW5nZWQgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIFNlZSB7QGxpbmtEb2NzIGd1aWRlL2xpZmVjeWNsZS1ob29rcyNvbmNoYW5nZXMgXCJMaWZlY3ljbGUgSG9va3MgR3VpZGVcIn0uXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIE9uQ2hhbmdlcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE9uQ2hhbmdlcygpIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT25DaGFuZ2VzO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogQHdoYXRJdERvZXMgTGlmZWN5Y2xlIGhvb2sgdGhhdCBpcyBjYWxsZWQgYWZ0ZXIgZGF0YS1ib3VuZCBwcm9wZXJ0aWVzIG9mIGEgZGlyZWN0aXZlIGFyZVxuICAgICAqIGluaXRpYWxpemVkLlxuICAgICAqIEBob3dUb1VzZVxuICAgICAqIHtAZXhhbXBsZSBjb3JlL3RzL21ldGFkYXRhL2xpZmVjeWNsZV9ob29rc19zcGVjLnRzIHJlZ2lvbj0nT25Jbml0J31cbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIGBuZ09uSW5pdGAgaXMgY2FsbGVkIHJpZ2h0IGFmdGVyIHRoZSBkaXJlY3RpdmUncyBkYXRhLWJvdW5kIHByb3BlcnRpZXMgaGF2ZSBiZWVuIGNoZWNrZWQgZm9yIHRoZVxuICAgICAqIGZpcnN0IHRpbWUsIGFuZCBiZWZvcmUgYW55IG9mIGl0cyBjaGlsZHJlbiBoYXZlIGJlZW4gY2hlY2tlZC4gSXQgaXMgaW52b2tlZCBvbmx5IG9uY2Ugd2hlbiB0aGVcbiAgICAgKiBkaXJlY3RpdmUgaXMgaW5zdGFudGlhdGVkLlxuICAgICAqXG4gICAgICogU2VlIHtAbGlua0RvY3MgZ3VpZGUvbGlmZWN5Y2xlLWhvb2tzIFwiTGlmZWN5Y2xlIEhvb2tzIEd1aWRlXCJ9LlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBPbkluaXQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBPbkluaXQoKSB7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9uSW5pdDtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIEB3aGF0SXREb2VzIExpZmVjeWNsZSBob29rIHRoYXQgaXMgY2FsbGVkIHdoZW4gQW5ndWxhciBkaXJ0eSBjaGVja3MgYSBkaXJlY3RpdmUuXG4gICAgICogQGhvd1RvVXNlXG4gICAgICoge0BleGFtcGxlIGNvcmUvdHMvbWV0YWRhdGEvbGlmZWN5Y2xlX2hvb2tzX3NwZWMudHMgcmVnaW9uPSdEb0NoZWNrJ31cbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIGBuZ0RvQ2hlY2tgIGdldHMgY2FsbGVkIHRvIGNoZWNrIHRoZSBjaGFuZ2VzIGluIHRoZSBkaXJlY3RpdmVzIGluIGFkZGl0aW9uIHRvIHRoZSBkZWZhdWx0XG4gICAgICogYWxnb3JpdGhtLiBUaGUgZGVmYXVsdCBjaGFuZ2UgZGV0ZWN0aW9uIGFsZ29yaXRobSBsb29rcyBmb3IgZGlmZmVyZW5jZXMgYnkgY29tcGFyaW5nXG4gICAgICogYm91bmQtcHJvcGVydHkgdmFsdWVzIGJ5IHJlZmVyZW5jZSBhY3Jvc3MgY2hhbmdlIGRldGVjdGlvbiBydW5zLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IGEgZGlyZWN0aXZlIHR5cGljYWxseSBzaG91bGQgbm90IHVzZSBib3RoIGBEb0NoZWNrYCBhbmQge0BsaW5rIE9uQ2hhbmdlc30gdG8gcmVzcG9uZCB0b1xuICAgICAqIGNoYW5nZXMgb24gdGhlIHNhbWUgaW5wdXQsIGFzIGBuZ09uQ2hhbmdlc2Agd2lsbCBjb250aW51ZSB0byBiZSBjYWxsZWQgd2hlbiB0aGUgZGVmYXVsdCBjaGFuZ2VcbiAgICAgKiBkZXRlY3RvciBkZXRlY3RzIGNoYW5nZXMuXG4gICAgICpcbiAgICAgKiBTZWUge0BsaW5rIEtleVZhbHVlRGlmZmVyc30gYW5kIHtAbGluayBJdGVyYWJsZURpZmZlcnN9IGZvciBpbXBsZW1lbnRpbmcgY3VzdG9tIGRpcnR5IGNoZWNraW5nXG4gICAgICogZm9yIGNvbGxlY3Rpb25zLlxuICAgICAqXG4gICAgICogU2VlIHtAbGlua0RvY3MgZ3VpZGUvbGlmZWN5Y2xlLWhvb2tzI2RvY2hlY2sgXCJMaWZlY3ljbGUgSG9va3MgR3VpZGVcIn0uXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIERvQ2hlY2sgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBEb0NoZWNrKCkge1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBEb0NoZWNrO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogQHdoYXRJdERvZXMgTGlmZWN5Y2xlIGhvb2sgdGhhdCBpcyBjYWxsZWQgd2hlbiBhIGRpcmVjdGl2ZSBvciBwaXBlIGlzIGRlc3Ryb3llZC5cbiAgICAgKiBAaG93VG9Vc2VcbiAgICAgKiB7QGV4YW1wbGUgY29yZS90cy9tZXRhZGF0YS9saWZlY3ljbGVfaG9va3Nfc3BlYy50cyByZWdpb249J09uRGVzdHJveSd9XG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBgbmdPbkRlc3Ryb3lgIGNhbGxiYWNrIGlzIHR5cGljYWxseSB1c2VkIGZvciBhbnkgY3VzdG9tIGNsZWFudXAgdGhhdCBuZWVkcyB0byBvY2N1ciB3aGVuIHRoZVxuICAgICAqIGluc3RhbmNlIGlzIGRlc3Ryb3llZC5cbiAgICAgKlxuICAgICAqIFNlZSB7QGxpbmtEb2NzIGd1aWRlL2xpZmVjeWNsZS1ob29rcyBcIkxpZmVjeWNsZSBIb29rcyBHdWlkZVwifS5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgT25EZXN0cm95ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gT25EZXN0cm95KCkge1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPbkRlc3Ryb3k7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEB3aGF0SXREb2VzIExpZmVjeWNsZSBob29rIHRoYXQgaXMgY2FsbGVkIGFmdGVyIGEgZGlyZWN0aXZlJ3MgY29udGVudCBoYXMgYmVlbiBmdWxseVxuICAgICAqIGluaXRpYWxpemVkLlxuICAgICAqIEBob3dUb1VzZVxuICAgICAqIHtAZXhhbXBsZSBjb3JlL3RzL21ldGFkYXRhL2xpZmVjeWNsZV9ob29rc19zcGVjLnRzIHJlZ2lvbj0nQWZ0ZXJDb250ZW50SW5pdCd9XG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBTZWUge0BsaW5rRG9jcyBndWlkZS9saWZlY3ljbGUtaG9va3MjYWZ0ZXJjb250ZW50IFwiTGlmZWN5Y2xlIEhvb2tzIEd1aWRlXCJ9LlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBBZnRlckNvbnRlbnRJbml0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQWZ0ZXJDb250ZW50SW5pdDtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIEB3aGF0SXREb2VzIExpZmVjeWNsZSBob29rIHRoYXQgaXMgY2FsbGVkIGFmdGVyIGV2ZXJ5IGNoZWNrIG9mIGEgZGlyZWN0aXZlJ3MgY29udGVudC5cbiAgICAgKiBAaG93VG9Vc2VcbiAgICAgKiB7QGV4YW1wbGUgY29yZS90cy9tZXRhZGF0YS9saWZlY3ljbGVfaG9va3Nfc3BlYy50cyByZWdpb249J0FmdGVyQ29udGVudENoZWNrZWQnfVxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogU2VlIHtAbGlua0RvY3MgZ3VpZGUvbGlmZWN5Y2xlLWhvb2tzI2FmdGVyY29udGVudCBcIkxpZmVjeWNsZSBIb29rcyBHdWlkZVwifS5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgQWZ0ZXJDb250ZW50Q2hlY2tlZCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEFmdGVyQ29udGVudENoZWNrZWQoKSB7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFmdGVyQ29udGVudENoZWNrZWQ7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBAd2hhdEl0RG9lcyBMaWZlY3ljbGUgaG9vayB0aGF0IGlzIGNhbGxlZCBhZnRlciBhIGNvbXBvbmVudCdzIHZpZXcgaGFzIGJlZW4gZnVsbHlcbiAgICAgKiBpbml0aWFsaXplZC5cbiAgICAgKiBAaG93VG9Vc2VcbiAgICAgKiB7QGV4YW1wbGUgY29yZS90cy9tZXRhZGF0YS9saWZlY3ljbGVfaG9va3Nfc3BlYy50cyByZWdpb249J0FmdGVyVmlld0luaXQnfVxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogU2VlIHtAbGlua0RvY3MgZ3VpZGUvbGlmZWN5Y2xlLWhvb2tzI2FmdGVydmlldyBcIkxpZmVjeWNsZSBIb29rcyBHdWlkZVwifS5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgQWZ0ZXJWaWV3SW5pdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEFmdGVyVmlld0luaXQoKSB7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFmdGVyVmlld0luaXQ7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBAd2hhdEl0RG9lcyBMaWZlY3ljbGUgaG9vayB0aGF0IGlzIGNhbGxlZCBhZnRlciBldmVyeSBjaGVjayBvZiBhIGNvbXBvbmVudCdzIHZpZXcuXG4gICAgICogQGhvd1RvVXNlXG4gICAgICoge0BleGFtcGxlIGNvcmUvdHMvbWV0YWRhdGEvbGlmZWN5Y2xlX2hvb2tzX3NwZWMudHMgcmVnaW9uPSdBZnRlclZpZXdDaGVja2VkJ31cbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFNlZSB7QGxpbmtEb2NzIGd1aWRlL2xpZmVjeWNsZS1ob29rcyNhZnRlcnZpZXcgXCJMaWZlY3ljbGUgSG9va3MgR3VpZGVcIn0uXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEFmdGVyVmlld0NoZWNrZWQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBBZnRlclZpZXdDaGVja2VkKCkge1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBZnRlclZpZXdDaGVja2VkO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIGEgc2NoZW1hIHRoYXQgd2lsbCBhbGxvdzpcbiAgICAgKiAtIGFueSBub24tQW5ndWxhciBlbGVtZW50cyB3aXRoIGEgYC1gIGluIHRoZWlyIG5hbWUsXG4gICAgICogLSBhbnkgcHJvcGVydGllcyBvbiBlbGVtZW50cyB3aXRoIGEgYC1gIGluIHRoZWlyIG5hbWUgd2hpY2ggaXMgdGhlIGNvbW1vbiBydWxlIGZvciBjdXN0b21cbiAgICAgKiBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgQ1VTVE9NX0VMRU1FTlRTX1NDSEVNQSA9IHtcbiAgICAgICAgbmFtZTogJ2N1c3RvbS1lbGVtZW50cydcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERlZmluZXMgYSBzY2hlbWEgdGhhdCB3aWxsIGFsbG93IGFueSBwcm9wZXJ0eSBvbiBhbnkgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgTk9fRVJST1JTX1NDSEVNQSA9IHtcbiAgICAgICAgbmFtZTogJ25vLWVycm9ycy1zY2hlbWEnXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBOZ01vZHVsZSBkZWNvcmF0b3IgYW5kIG1ldGFkYXRhLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqIEBBbm5vdGF0aW9uXG4gICAgICovXG4gICAgdmFyIE5nTW9kdWxlID0gbWFrZURlY29yYXRvcignTmdNb2R1bGUnLCB7XG4gICAgICAgIHByb3ZpZGVyczogdW5kZWZpbmVkLFxuICAgICAgICBkZWNsYXJhdGlvbnM6IHVuZGVmaW5lZCxcbiAgICAgICAgaW1wb3J0czogdW5kZWZpbmVkLFxuICAgICAgICBleHBvcnRzOiB1bmRlZmluZWQsXG4gICAgICAgIGVudHJ5Q29tcG9uZW50czogdW5kZWZpbmVkLFxuICAgICAgICBib290c3RyYXA6IHVuZGVmaW5lZCxcbiAgICAgICAgc2NoZW1hczogdW5kZWZpbmVkLFxuICAgICAgICBpZDogdW5kZWZpbmVkLFxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIERlZmluZXMgdGVtcGxhdGUgYW5kIHN0eWxlIGVuY2Fwc3VsYXRpb24gb3B0aW9ucyBhdmFpbGFibGUgZm9yIENvbXBvbmVudCdzIHtAbGluayBDb21wb25lbnR9LlxuICAgICAqXG4gICAgICogU2VlIHtAbGluayBWaWV3TWV0YWRhdGEjZW5jYXBzdWxhdGlvbn0uXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIGV4cG9ydHMuVmlld0VuY2Fwc3VsYXRpb247XG4gICAgKGZ1bmN0aW9uIChWaWV3RW5jYXBzdWxhdGlvbikge1xuICAgICAgICAvKipcbiAgICAgICAgICogRW11bGF0ZSBgTmF0aXZlYCBzY29waW5nIG9mIHN0eWxlcyBieSBhZGRpbmcgYW4gYXR0cmlidXRlIGNvbnRhaW5pbmcgc3Vycm9nYXRlIGlkIHRvIHRoZSBIb3N0XG4gICAgICAgICAqIEVsZW1lbnQgYW5kIHByZS1wcm9jZXNzaW5nIHRoZSBzdHlsZSBydWxlcyBwcm92aWRlZCB2aWFcbiAgICAgICAgICoge0BsaW5rIFZpZXdNZXRhZGF0YSNzdHlsZXN9IG9yIHtAbGluayBWaWV3TWV0YWRhdGEjc3R5bGVzVXJsc30sIGFuZCBhZGRpbmcgdGhlIG5ldyBIb3N0IEVsZW1lbnRcbiAgICAgICAgICogYXR0cmlidXRlIHRvIGFsbCBzZWxlY3RvcnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgaXMgdGhlIGRlZmF1bHQgb3B0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgVmlld0VuY2Fwc3VsYXRpb25bVmlld0VuY2Fwc3VsYXRpb25bXCJFbXVsYXRlZFwiXSA9IDBdID0gXCJFbXVsYXRlZFwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogVXNlIHRoZSBuYXRpdmUgZW5jYXBzdWxhdGlvbiBtZWNoYW5pc20gb2YgdGhlIHJlbmRlcmVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgdGhlIERPTSB0aGlzIG1lYW5zIHVzaW5nIFtTaGFkb3cgRE9NXShodHRwczovL3czYy5naXRodWIuaW8vd2ViY29tcG9uZW50cy9zcGVjL3NoYWRvdy8pIGFuZFxuICAgICAgICAgKiBjcmVhdGluZyBhIFNoYWRvd1Jvb3QgZm9yIENvbXBvbmVudCdzIEhvc3QgRWxlbWVudC5cbiAgICAgICAgICovXG4gICAgICAgIFZpZXdFbmNhcHN1bGF0aW9uW1ZpZXdFbmNhcHN1bGF0aW9uW1wiTmF0aXZlXCJdID0gMV0gPSBcIk5hdGl2ZVwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogRG9uJ3QgcHJvdmlkZSBhbnkgdGVtcGxhdGUgb3Igc3R5bGUgZW5jYXBzdWxhdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIFZpZXdFbmNhcHN1bGF0aW9uW1ZpZXdFbmNhcHN1bGF0aW9uW1wiTm9uZVwiXSA9IDJdID0gXCJOb25lXCI7XG4gICAgfSkoZXhwb3J0cy5WaWV3RW5jYXBzdWxhdGlvbiB8fCAoZXhwb3J0cy5WaWV3RW5jYXBzdWxhdGlvbiA9IHt9KSk7XG4gICAgLyoqXG4gICAgICogTWV0YWRhdGEgcHJvcGVydGllcyBhdmFpbGFibGUgZm9yIGNvbmZpZ3VyaW5nIFZpZXdzLlxuICAgICAqXG4gICAgICogRm9yIGRldGFpbHMgb24gdGhlIGBAQ29tcG9uZW50YCBhbm5vdGF0aW9uLCBzZWUge0BsaW5rIENvbXBvbmVudH0uXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogQENvbXBvbmVudCh7XG4gICAgICogICBzZWxlY3RvcjogJ2dyZWV0JyxcbiAgICAgKiAgIHRlbXBsYXRlOiAnSGVsbG8ge3tuYW1lfX0hJyxcbiAgICAgKiB9KVxuICAgICAqIGNsYXNzIEdyZWV0IHtcbiAgICAgKiAgIG5hbWU6IHN0cmluZztcbiAgICAgKlxuICAgICAqICAgY29uc3RydWN0b3IoKSB7XG4gICAgICogICAgIHRoaXMubmFtZSA9ICdXb3JsZCc7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIENvbXBvbmVudCBpbnN0ZWFkLlxuICAgICAqXG4gICAgICoge0BsaW5rIENvbXBvbmVudH1cbiAgICAgKi9cbiAgICB2YXIgVmlld01ldGFkYXRhID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gVmlld01ldGFkYXRhKF9hKSB7XG4gICAgICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgdGVtcGxhdGVVcmwgPSBfYi50ZW1wbGF0ZVVybCwgdGVtcGxhdGUgPSBfYi50ZW1wbGF0ZSwgZW5jYXBzdWxhdGlvbiA9IF9iLmVuY2Fwc3VsYXRpb24sIHN0eWxlcyA9IF9iLnN0eWxlcywgc3R5bGVVcmxzID0gX2Iuc3R5bGVVcmxzLCBhbmltYXRpb25zID0gX2IuYW5pbWF0aW9ucywgaW50ZXJwb2xhdGlvbiA9IF9iLmludGVycG9sYXRpb247XG4gICAgICAgICAgICB0aGlzLnRlbXBsYXRlVXJsID0gdGVtcGxhdGVVcmw7XG4gICAgICAgICAgICB0aGlzLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgICAgICAgICB0aGlzLnN0eWxlVXJscyA9IHN0eWxlVXJscztcbiAgICAgICAgICAgIHRoaXMuc3R5bGVzID0gc3R5bGVzO1xuICAgICAgICAgICAgdGhpcy5lbmNhcHN1bGF0aW9uID0gZW5jYXBzdWxhdGlvbjtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9ucyA9IGFuaW1hdGlvbnM7XG4gICAgICAgICAgICB0aGlzLmludGVycG9sYXRpb24gPSBpbnRlcnBvbGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBWaWV3TWV0YWRhdGE7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEFsbG93cyB0byByZWZlciB0byByZWZlcmVuY2VzIHdoaWNoIGFyZSBub3QgeWV0IGRlZmluZWQuXG4gICAgICpcbiAgICAgKiBGb3IgaW5zdGFuY2UsIGBmb3J3YXJkUmVmYCBpcyB1c2VkIHdoZW4gdGhlIGB0b2tlbmAgd2hpY2ggd2UgbmVlZCB0byByZWZlciB0byBmb3IgdGhlIHB1cnBvc2VzIG9mXG4gICAgICogREkgaXMgZGVjbGFyZWQsXG4gICAgICogYnV0IG5vdCB5ZXQgZGVmaW5lZC4gSXQgaXMgYWxzbyB1c2VkIHdoZW4gdGhlIGB0b2tlbmAgd2hpY2ggd2UgdXNlIHdoZW4gY3JlYXRpbmcgYSBxdWVyeSBpcyBub3RcbiAgICAgKiB5ZXQgZGVmaW5lZC5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICoge0BleGFtcGxlIGNvcmUvZGkvdHMvZm9yd2FyZF9yZWYvZm9yd2FyZF9yZWZfc3BlYy50cyByZWdpb249J2ZvcndhcmRfcmVmJ31cbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9yd2FyZFJlZihmb3J3YXJkUmVmRm4pIHtcbiAgICAgICAgZm9yd2FyZFJlZkZuLl9fZm9yd2FyZF9yZWZfXyA9IGZvcndhcmRSZWY7XG4gICAgICAgIGZvcndhcmRSZWZGbi50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0cmluZ2lmeSh0aGlzKCkpOyB9O1xuICAgICAgICByZXR1cm4gZm9yd2FyZFJlZkZuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMYXppbHkgcmV0cmlldmVzIHRoZSByZWZlcmVuY2UgdmFsdWUgZnJvbSBhIGZvcndhcmRSZWYuXG4gICAgICpcbiAgICAgKiBBY3RzIGFzIHRoZSBpZGVudGl0eSBmdW5jdGlvbiB3aGVuIGdpdmVuIGEgbm9uLWZvcndhcmQtcmVmIHZhbHVlLlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L0dVNzJtSnJrMWZpb2RDaGNtaURSP3A9cHJldmlldykpXG4gICAgICpcbiAgICAgKiB7QGV4YW1wbGUgY29yZS9kaS90cy9mb3J3YXJkX3JlZi9mb3J3YXJkX3JlZl9zcGVjLnRzIHJlZ2lvbj0ncmVzb2x2ZV9mb3J3YXJkX3JlZid9XG4gICAgICpcbiAgICAgKiBTZWU6IHtAbGluayBmb3J3YXJkUmVmfVxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXNvbHZlRm9yd2FyZFJlZih0eXBlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlLmhhc093blByb3BlcnR5KCdfX2ZvcndhcmRfcmVmX18nKSAmJlxuICAgICAgICAgICAgdHlwZS5fX2ZvcndhcmRfcmVmX18gPT09IGZvcndhcmRSZWYpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gdW5pbXBsZW1lbnRlZCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmltcGxlbWVudGVkJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgQmFzZUVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKEJhc2VFcnJvciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gQmFzZUVycm9yKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIC8vIEVycm9ycyBkb24ndCB1c2UgY3VycmVudCB0aGlzLCBpbnN0ZWFkIHRoZXkgY3JlYXRlIGEgbmV3IGluc3RhbmNlLlxuICAgICAgICAgICAgLy8gV2UgaGF2ZSB0byBkbyBmb3J3YXJkIGFsbCBvZiBvdXIgYXBpIHRvIHRoZSBuYXRpdmVJbnN0YW5jZS5cbiAgICAgICAgICAgIHZhciBuYXRpdmVFcnJvciA9IF9zdXBlci5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgdGhpcy5fbmF0aXZlRXJyb3IgPSBuYXRpdmVFcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZUVycm9yLnByb3RvdHlwZSwgXCJtZXNzYWdlXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbmF0aXZlRXJyb3IubWVzc2FnZTsgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKG1lc3NhZ2UpIHsgdGhpcy5fbmF0aXZlRXJyb3IubWVzc2FnZSA9IG1lc3NhZ2U7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZUVycm9yLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbmF0aXZlRXJyb3IubmFtZTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNlRXJyb3IucHJvdG90eXBlLCBcInN0YWNrXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbmF0aXZlRXJyb3Iuc3RhY2s7IH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyB0aGlzLl9uYXRpdmVFcnJvci5zdGFjayA9IHZhbHVlOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgQmFzZUVycm9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX25hdGl2ZUVycm9yLnRvU3RyaW5nKCk7IH07XG4gICAgICAgIHJldHVybiBCYXNlRXJyb3I7XG4gICAgfShFcnJvcikpO1xuICAgIC8qKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgV3JhcHBlZEVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKFdyYXBwZWRFcnJvciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gV3JhcHBlZEVycm9yKG1lc3NhZ2UsIGVycm9yKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlICsgXCIgY2F1c2VkIGJ5OiBcIiArIChlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IGVycm9yKSk7XG4gICAgICAgICAgICB0aGlzLm9yaWdpbmFsRXJyb3IgPSBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JhcHBlZEVycm9yLnByb3RvdHlwZSwgXCJzdGFja1wiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMub3JpZ2luYWxFcnJvciBpbnN0YW5jZW9mIEVycm9yID8gdGhpcy5vcmlnaW5hbEVycm9yIDogdGhpcy5fbmF0aXZlRXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIC5zdGFjaztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gV3JhcHBlZEVycm9yO1xuICAgIH0oQmFzZUVycm9yKSk7XG5cbiAgICB2YXIgX1RIUk9XX0lGX05PVF9GT1VORCA9IG5ldyBPYmplY3QoKTtcbiAgICB2YXIgVEhST1dfSUZfTk9UX0ZPVU5EID0gX1RIUk9XX0lGX05PVF9GT1VORDtcbiAgICB2YXIgX051bGxJbmplY3RvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIF9OdWxsSW5qZWN0b3IoKSB7XG4gICAgICAgIH1cbiAgICAgICAgX051bGxJbmplY3Rvci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHRva2VuLCBub3RGb3VuZFZhbHVlKSB7XG4gICAgICAgICAgICBpZiAobm90Rm91bmRWYWx1ZSA9PT0gdm9pZCAwKSB7IG5vdEZvdW5kVmFsdWUgPSBfVEhST1dfSUZfTk9UX0ZPVU5EOyB9XG4gICAgICAgICAgICBpZiAobm90Rm91bmRWYWx1ZSA9PT0gX1RIUk9XX0lGX05PVF9GT1VORCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHByb3ZpZGVyIGZvciBcIiArIHN0cmluZ2lmeSh0b2tlbikgKyBcIiFcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbm90Rm91bmRWYWx1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF9OdWxsSW5qZWN0b3I7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBAd2hhdEl0RG9lcyBJbmplY3RvciBpbnRlcmZhY2VcbiAgICAgKiBAaG93VG9Vc2VcbiAgICAgKiBgYGBcbiAgICAgKiBjb25zdCBpbmplY3RvcjogSW5qZWN0b3IgPSAuLi47XG4gICAgICogaW5qZWN0b3IuZ2V0KC4uLik7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBGb3IgbW9yZSBkZXRhaWxzLCBzZWUgdGhlIHtAbGlua0RvY3MgZ3VpZGUvZGVwZW5kZW5jeS1pbmplY3Rpb24gXCJEZXBlbmRlbmN5IEluamVjdGlvbiBHdWlkZVwifS5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiB7QGV4YW1wbGUgY29yZS9kaS90cy9pbmplY3Rvcl9zcGVjLnRzIHJlZ2lvbj0nSW5qZWN0b3InfVxuICAgICAqXG4gICAgICogYEluamVjdG9yYCByZXR1cm5zIGl0c2VsZiB3aGVuIGdpdmVuIGBJbmplY3RvcmAgYXMgYSB0b2tlbjpcbiAgICAgKiB7QGV4YW1wbGUgY29yZS9kaS90cy9pbmplY3Rvcl9zcGVjLnRzIHJlZ2lvbj0naW5qZWN0SW5qZWN0b3InfVxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBJbmplY3RvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEluamVjdG9yKCkge1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXRyaWV2ZXMgYW4gaW5zdGFuY2UgZnJvbSB0aGUgaW5qZWN0b3IgYmFzZWQgb24gdGhlIHByb3ZpZGVkIHRva2VuLlxuICAgICAgICAgKiBJZiBub3QgZm91bmQ6XG4gICAgICAgICAqIC0gVGhyb3dzIHtAbGluayBOb1Byb3ZpZGVyRXJyb3J9IGlmIG5vIGBub3RGb3VuZFZhbHVlYCB0aGF0IGlzIG5vdCBlcXVhbCB0b1xuICAgICAgICAgKiBJbmplY3Rvci5USFJPV19JRl9OT1RfRk9VTkQgaXMgZ2l2ZW5cbiAgICAgICAgICogLSBSZXR1cm5zIHRoZSBgbm90Rm91bmRWYWx1ZWAgb3RoZXJ3aXNlXG4gICAgICAgICAqL1xuICAgICAgICBJbmplY3Rvci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHRva2VuLCBub3RGb3VuZFZhbHVlKSB7IHJldHVybiB1bmltcGxlbWVudGVkKCk7IH07XG4gICAgICAgIEluamVjdG9yLlRIUk9XX0lGX05PVF9GT1VORCA9IF9USFJPV19JRl9OT1RfRk9VTkQ7XG4gICAgICAgIEluamVjdG9yLk5VTEwgPSBuZXcgX051bGxJbmplY3RvcigpO1xuICAgICAgICByZXR1cm4gSW5qZWN0b3I7XG4gICAgfSgpKTtcblxuICAgIC8vIFNhZmFyaSBkb2Vzbid0IGltcGxlbWVudCBNYXBJdGVyYXRvci5uZXh0KCksIHdoaWNoIGlzIHVzZWQgaXMgVHJhY2V1cidzIHBvbHlmaWxsIG9mIEFycmF5LmZyb21cbiAgICAvLyBUT0RPKG1sYXZhbCk6IHJlbW92ZSB0aGUgd29yayBhcm91bmQgb25jZSB3ZSBoYXZlIGEgd29ya2luZyBwb2x5ZmlsbCBvZiBBcnJheS5mcm9tXG4gICAgdmFyIF9hcnJheUZyb21NYXAgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKChuZXcgTWFwKCkpLnZhbHVlcygpLm5leHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlQXJyYXlGcm9tTWFwKG0sIGdldFZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0VmFsdWVzID8gQXJyYXkuZnJvbShtLnZhbHVlcygpKSA6IEFycmF5LmZyb20obS5rZXlzKCkpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlQXJyYXlGcm9tTWFwV2l0aEZvcmVhY2gobSwgZ2V0VmFsdWVzKSB7XG4gICAgICAgICAgICB2YXIgcmVzID0gbmV3IEFycmF5KG0uc2l6ZSksIGkgPSAwO1xuICAgICAgICAgICAgbS5mb3JFYWNoKGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgICAgICAgICAgICAgcmVzW2ldID0gZ2V0VmFsdWVzID8gdiA6IGs7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9O1xuICAgIH0pKCk7XG4gICAgdmFyIE1hcFdyYXBwZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBNYXBXcmFwcGVyKCkge1xuICAgICAgICB9XG4gICAgICAgIE1hcFdyYXBwZXIuY3JlYXRlRnJvbVN0cmluZ01hcCA9IGZ1bmN0aW9uIChzdHJpbmdNYXApIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIHN0cmluZ01hcCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQocHJvcCwgc3RyaW5nTWFwW3Byb3BdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICAgIE1hcFdyYXBwZXIua2V5cyA9IGZ1bmN0aW9uIChtKSB7IHJldHVybiBfYXJyYXlGcm9tTWFwKG0sIGZhbHNlKTsgfTtcbiAgICAgICAgTWFwV3JhcHBlci52YWx1ZXMgPSBmdW5jdGlvbiAobSkgeyByZXR1cm4gX2FycmF5RnJvbU1hcChtLCB0cnVlKTsgfTtcbiAgICAgICAgcmV0dXJuIE1hcFdyYXBwZXI7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBXcmFwcyBKYXZhc2NyaXB0IE9iamVjdHNcbiAgICAgKi9cbiAgICB2YXIgU3RyaW5nTWFwV3JhcHBlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFN0cmluZ01hcFdyYXBwZXIoKSB7XG4gICAgICAgIH1cbiAgICAgICAgU3RyaW5nTWFwV3JhcHBlci5tZXJnZSA9IGZ1bmN0aW9uIChtMSwgbTIpIHtcbiAgICAgICAgICAgIHZhciBtID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gT2JqZWN0LmtleXMobTEpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBrID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIG1ba10gPSBtMVtrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSBPYmplY3Qua2V5cyhtMik7IF9iIDwgX2MubGVuZ3RoOyBfYisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGsgPSBfY1tfYl07XG4gICAgICAgICAgICAgICAgbVtrXSA9IG0yW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgIH07XG4gICAgICAgIFN0cmluZ01hcFdyYXBwZXIuZXF1YWxzID0gZnVuY3Rpb24gKG0xLCBtMikge1xuICAgICAgICAgICAgdmFyIGsxID0gT2JqZWN0LmtleXMobTEpO1xuICAgICAgICAgICAgdmFyIGsyID0gT2JqZWN0LmtleXMobTIpO1xuICAgICAgICAgICAgaWYgKGsxLmxlbmd0aCAhPSBrMi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGsxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGsxW2ldO1xuICAgICAgICAgICAgICAgIGlmIChtMVtrZXldICE9PSBtMltrZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFN0cmluZ01hcFdyYXBwZXI7XG4gICAgfSgpKTtcbiAgICB2YXIgTGlzdFdyYXBwZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBMaXN0V3JhcHBlcigpIHtcbiAgICAgICAgfVxuICAgICAgICAvLyBKUyBoYXMgbm8gd2F5IHRvIGV4cHJlc3MgYSBzdGF0aWNhbGx5IGZpeGVkIHNpemUgbGlzdCwgYnV0IGRhcnQgZG9lcyBzbyB3ZVxuICAgICAgICAvLyBrZWVwIGJvdGggbWV0aG9kcy5cbiAgICAgICAgTGlzdFdyYXBwZXIuY3JlYXRlRml4ZWRTaXplID0gZnVuY3Rpb24gKHNpemUpIHsgcmV0dXJuIG5ldyBBcnJheShzaXplKTsgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIuY3JlYXRlR3Jvd2FibGVTaXplID0gZnVuY3Rpb24gKHNpemUpIHsgcmV0dXJuIG5ldyBBcnJheShzaXplKTsgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIuY2xvbmUgPSBmdW5jdGlvbiAoYXJyYXkpIHsgcmV0dXJuIGFycmF5LnNsaWNlKDApOyB9O1xuICAgICAgICBMaXN0V3JhcHBlci5mb3JFYWNoV2l0aEluZGV4ID0gZnVuY3Rpb24gKGFycmF5LCBmbikge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGZuKGFycmF5W2ldLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIuZmlyc3QgPSBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICAgICAgICAgIGlmICghYXJyYXkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByZXR1cm4gYXJyYXlbMF07XG4gICAgICAgIH07XG4gICAgICAgIExpc3RXcmFwcGVyLmxhc3QgPSBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICAgICAgICAgIGlmICghYXJyYXkgfHwgYXJyYXkubGVuZ3RoID09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByZXR1cm4gYXJyYXlbYXJyYXkubGVuZ3RoIC0gMV07XG4gICAgICAgIH07XG4gICAgICAgIExpc3RXcmFwcGVyLmluZGV4T2YgPSBmdW5jdGlvbiAoYXJyYXksIHZhbHVlLCBzdGFydEluZGV4KSB7XG4gICAgICAgICAgICBpZiAoc3RhcnRJbmRleCA9PT0gdm9pZCAwKSB7IHN0YXJ0SW5kZXggPSAwOyB9XG4gICAgICAgICAgICByZXR1cm4gYXJyYXkuaW5kZXhPZih2YWx1ZSwgc3RhcnRJbmRleCk7XG4gICAgICAgIH07XG4gICAgICAgIExpc3RXcmFwcGVyLmNvbnRhaW5zID0gZnVuY3Rpb24gKGxpc3QsIGVsKSB7IHJldHVybiBsaXN0LmluZGV4T2YoZWwpICE9PSAtMTsgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIucmV2ZXJzZWQgPSBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICAgICAgICAgIHZhciBhID0gTGlzdFdyYXBwZXIuY2xvbmUoYXJyYXkpO1xuICAgICAgICAgICAgcmV0dXJuIGEucmV2ZXJzZSgpO1xuICAgICAgICB9O1xuICAgICAgICBMaXN0V3JhcHBlci5jb25jYXQgPSBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5jb25jYXQoYik7IH07XG4gICAgICAgIExpc3RXcmFwcGVyLmluc2VydCA9IGZ1bmN0aW9uIChsaXN0LCBpbmRleCwgdmFsdWUpIHsgbGlzdC5zcGxpY2UoaW5kZXgsIDAsIHZhbHVlKTsgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIucmVtb3ZlQXQgPSBmdW5jdGlvbiAobGlzdCwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciByZXMgPSBsaXN0W2luZGV4XTtcbiAgICAgICAgICAgIGxpc3Quc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH07XG4gICAgICAgIExpc3RXcmFwcGVyLnJlbW92ZUFsbCA9IGZ1bmN0aW9uIChsaXN0LCBpdGVtcykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGxpc3QuaW5kZXhPZihpdGVtc1tpXSk7XG4gICAgICAgICAgICAgICAgbGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBMaXN0V3JhcHBlci5yZW1vdmUgPSBmdW5jdGlvbiAobGlzdCwgZWwpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGxpc3QuaW5kZXhPZihlbCk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgIGxpc3Quc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIuY2xlYXIgPSBmdW5jdGlvbiAobGlzdCkgeyBsaXN0Lmxlbmd0aCA9IDA7IH07XG4gICAgICAgIExpc3RXcmFwcGVyLmlzRW1wdHkgPSBmdW5jdGlvbiAobGlzdCkgeyByZXR1cm4gbGlzdC5sZW5ndGggPT0gMDsgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIuZmlsbCA9IGZ1bmN0aW9uIChsaXN0LCB2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICAgICAgICAgICAgaWYgKHN0YXJ0ID09PSB2b2lkIDApIHsgc3RhcnQgPSAwOyB9XG4gICAgICAgICAgICBpZiAoZW5kID09PSB2b2lkIDApIHsgZW5kID0gbnVsbDsgfVxuICAgICAgICAgICAgbGlzdC5maWxsKHZhbHVlLCBzdGFydCwgZW5kID09PSBudWxsID8gbGlzdC5sZW5ndGggOiBlbmQpO1xuICAgICAgICB9O1xuICAgICAgICBMaXN0V3JhcHBlci5lcXVhbHMgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmIChhW2ldICE9PSBiW2ldKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIuc2xpY2UgPSBmdW5jdGlvbiAobCwgZnJvbSwgdG8pIHtcbiAgICAgICAgICAgIGlmIChmcm9tID09PSB2b2lkIDApIHsgZnJvbSA9IDA7IH1cbiAgICAgICAgICAgIGlmICh0byA9PT0gdm9pZCAwKSB7IHRvID0gbnVsbDsgfVxuICAgICAgICAgICAgcmV0dXJuIGwuc2xpY2UoZnJvbSwgdG8gPT09IG51bGwgPyB1bmRlZmluZWQgOiB0byk7XG4gICAgICAgIH07XG4gICAgICAgIExpc3RXcmFwcGVyLnNwbGljZSA9IGZ1bmN0aW9uIChsLCBmcm9tLCBsZW5ndGgpIHsgcmV0dXJuIGwuc3BsaWNlKGZyb20sIGxlbmd0aCk7IH07XG4gICAgICAgIExpc3RXcmFwcGVyLnNvcnQgPSBmdW5jdGlvbiAobCwgY29tcGFyZUZuKSB7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KGNvbXBhcmVGbikpIHtcbiAgICAgICAgICAgICAgICBsLnNvcnQoY29tcGFyZUZuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGwuc29ydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBMaXN0V3JhcHBlci50b1N0cmluZyA9IGZ1bmN0aW9uIChsKSB7IHJldHVybiBsLnRvU3RyaW5nKCk7IH07XG4gICAgICAgIExpc3RXcmFwcGVyLnRvSlNPTiA9IGZ1bmN0aW9uIChsKSB7IHJldHVybiBKU09OLnN0cmluZ2lmeShsKTsgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIubWF4aW11bSA9IGZ1bmN0aW9uIChsaXN0LCBwcmVkaWNhdGUpIHtcbiAgICAgICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc29sdXRpb24gPSBudWxsO1xuICAgICAgICAgICAgdmFyIG1heFZhbHVlID0gLUluZmluaXR5O1xuICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxpc3QubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IGxpc3RbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmIChpc0JsYW5rKGNhbmRpZGF0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjYW5kaWRhdGVWYWx1ZSA9IHByZWRpY2F0ZShjYW5kaWRhdGUpO1xuICAgICAgICAgICAgICAgIGlmIChjYW5kaWRhdGVWYWx1ZSA+IG1heFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNvbHV0aW9uID0gY2FuZGlkYXRlO1xuICAgICAgICAgICAgICAgICAgICBtYXhWYWx1ZSA9IGNhbmRpZGF0ZVZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzb2x1dGlvbjtcbiAgICAgICAgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIuZmxhdHRlbiA9IGZ1bmN0aW9uIChsaXN0KSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gW107XG4gICAgICAgICAgICBfZmxhdHRlbkFycmF5KGxpc3QsIHRhcmdldCk7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICB9O1xuICAgICAgICBMaXN0V3JhcHBlci5hZGRBbGwgPSBmdW5jdGlvbiAobGlzdCwgc291cmNlKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvdXJjZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxpc3QucHVzaChzb3VyY2VbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gTGlzdFdyYXBwZXI7XG4gICAgfSgpKTtcbiAgICBmdW5jdGlvbiBfZmxhdHRlbkFycmF5KHNvdXJjZSwgdGFyZ2V0KSB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQoc291cmNlKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IHNvdXJjZVtpXTtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xuICAgICAgICAgICAgICAgICAgICBfZmxhdHRlbkFycmF5KGl0ZW0sIHRhcmdldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNMaXN0TGlrZUl0ZXJhYmxlKG9iaikge1xuICAgICAgICBpZiAoIWlzSnNPYmplY3Qob2JqKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkob2JqKSB8fFxuICAgICAgICAgICAgKCEob2JqIGluc3RhbmNlb2YgTWFwKSAmJlxuICAgICAgICAgICAgICAgIGdldFN5bWJvbEl0ZXJhdG9yKCkgaW4gb2JqKTsgLy8gSlMgSXRlcmFibGUgaGF2ZSBhIFN5bWJvbC5pdGVyYXRvciBwcm9wXG4gICAgfVxuICAgIGZ1bmN0aW9uIGFyZUl0ZXJhYmxlc0VxdWFsKGEsIGIsIGNvbXBhcmF0b3IpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yMSA9IGFbZ2V0U3ltYm9sSXRlcmF0b3IoKV0oKTtcbiAgICAgICAgdmFyIGl0ZXJhdG9yMiA9IGJbZ2V0U3ltYm9sSXRlcmF0b3IoKV0oKTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIHZhciBpdGVtMSA9IGl0ZXJhdG9yMS5uZXh0KCk7XG4gICAgICAgICAgICB2YXIgaXRlbTIgPSBpdGVyYXRvcjIubmV4dCgpO1xuICAgICAgICAgICAgaWYgKGl0ZW0xLmRvbmUgJiYgaXRlbTIuZG9uZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChpdGVtMS5kb25lIHx8IGl0ZW0yLmRvbmUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKCFjb21wYXJhdG9yKGl0ZW0xLnZhbHVlLCBpdGVtMi52YWx1ZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGl0ZXJhdGVMaXN0TGlrZShvYmosIGZuKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm4ob2JqW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBpdGVyYXRvciA9IG9ialtnZXRTeW1ib2xJdGVyYXRvcigpXSgpO1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSB2b2lkIDA7XG4gICAgICAgICAgICB3aGlsZSAoISgoaXRlbSA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkpIHtcbiAgICAgICAgICAgICAgICBmbihpdGVtLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDEgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBmaW5kRmlyc3RDbG9zZWRDeWNsZShrZXlzKSB7XG4gICAgICAgIHZhciByZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoTGlzdFdyYXBwZXIuY29udGFpbnMocmVzLCBrZXlzW2ldKSkge1xuICAgICAgICAgICAgICAgIHJlcy5wdXNoKGtleXNbaV0pO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXMucHVzaChrZXlzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb25zdHJ1Y3RSZXNvbHZpbmdQYXRoKGtleXMpIHtcbiAgICAgICAgaWYgKGtleXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdmFyIHJldmVyc2VkID0gZmluZEZpcnN0Q2xvc2VkQ3ljbGUoTGlzdFdyYXBwZXIucmV2ZXJzZWQoa2V5cykpO1xuICAgICAgICAgICAgdmFyIHRva2VuU3RycyA9IHJldmVyc2VkLm1hcChmdW5jdGlvbiAoaykgeyByZXR1cm4gc3RyaW5naWZ5KGsudG9rZW4pOyB9KTtcbiAgICAgICAgICAgIHJldHVybiAnICgnICsgdG9rZW5TdHJzLmpvaW4oJyAtPiAnKSArICcpJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJhc2UgY2xhc3MgZm9yIGFsbCBlcnJvcnMgYXJpc2luZyBmcm9tIG1pc2NvbmZpZ3VyZWQgcHJvdmlkZXJzLlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgQWJzdHJhY3RQcm92aWRlckVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDEoQWJzdHJhY3RQcm92aWRlckVycm9yLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBBYnN0cmFjdFByb3ZpZGVyRXJyb3IoaW5qZWN0b3IsIGtleSwgY29uc3RydWN0UmVzb2x2aW5nTWVzc2FnZSkge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgJ0RJIEVycm9yJyk7XG4gICAgICAgICAgICB0aGlzLmtleXMgPSBba2V5XTtcbiAgICAgICAgICAgIHRoaXMuaW5qZWN0b3JzID0gW2luamVjdG9yXTtcbiAgICAgICAgICAgIHRoaXMuY29uc3RydWN0UmVzb2x2aW5nTWVzc2FnZSA9IGNvbnN0cnVjdFJlc29sdmluZ01lc3NhZ2U7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSB0aGlzLmNvbnN0cnVjdFJlc29sdmluZ01lc3NhZ2UodGhpcy5rZXlzKTtcbiAgICAgICAgfVxuICAgICAgICBBYnN0cmFjdFByb3ZpZGVyRXJyb3IucHJvdG90eXBlLmFkZEtleSA9IGZ1bmN0aW9uIChpbmplY3Rvciwga2V5KSB7XG4gICAgICAgICAgICB0aGlzLmluamVjdG9ycy5wdXNoKGluamVjdG9yKTtcbiAgICAgICAgICAgIHRoaXMua2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSB0aGlzLmNvbnN0cnVjdFJlc29sdmluZ01lc3NhZ2UodGhpcy5rZXlzKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEFic3RyYWN0UHJvdmlkZXJFcnJvcjtcbiAgICB9KEJhc2VFcnJvcikpO1xuICAgIC8qKlxuICAgICAqIFRocm93biB3aGVuIHRyeWluZyB0byByZXRyaWV2ZSBhIGRlcGVuZGVuY3kgYnkga2V5IGZyb20ge0BsaW5rIEluamVjdG9yfSwgYnV0IHRoZVxuICAgICAqIHtAbGluayBJbmplY3Rvcn0gZG9lcyBub3QgaGF2ZSBhIHtAbGluayBQcm92aWRlcn0gZm9yIHRoZSBnaXZlbiBrZXkuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvdnE4RDNGUkI5YUdibldKcXRFUEU/cD1wcmV2aWV3KSlcbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjbGFzcyBBIHtcbiAgICAgKiAgIGNvbnN0cnVjdG9yKGI6Qikge31cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBleHBlY3QoKCkgPT4gSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbQV0pKS50b1Rocm93RXJyb3IoKTtcbiAgICAgKiBgYGBcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIE5vUHJvdmlkZXJFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQxKE5vUHJvdmlkZXJFcnJvciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gTm9Qcm92aWRlckVycm9yKGluamVjdG9yLCBrZXkpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGluamVjdG9yLCBrZXksIGZ1bmN0aW9uIChrZXlzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpcnN0ID0gc3RyaW5naWZ5KExpc3RXcmFwcGVyLmZpcnN0KGtleXMpLnRva2VuKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJObyBwcm92aWRlciBmb3IgXCIgKyBmaXJzdCArIFwiIVwiICsgY29uc3RydWN0UmVzb2x2aW5nUGF0aChrZXlzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBOb1Byb3ZpZGVyRXJyb3I7XG4gICAgfShBYnN0cmFjdFByb3ZpZGVyRXJyb3IpKTtcbiAgICAvKipcbiAgICAgKiBUaHJvd24gd2hlbiBkZXBlbmRlbmNpZXMgZm9ybSBhIGN5Y2xlLlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L3dZUWROb3MwVHpxbDNlaTFFVjlqP3A9aW5mbykpXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdmFyIGluamVjdG9yID0gSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbXG4gICAgICogICB7cHJvdmlkZTogXCJvbmVcIiwgdXNlRmFjdG9yeTogKHR3bykgPT4gXCJ0d29cIiwgZGVwczogW1tuZXcgSW5qZWN0KFwidHdvXCIpXV19LFxuICAgICAqICAge3Byb3ZpZGU6IFwidHdvXCIsIHVzZUZhY3Rvcnk6IChvbmUpID0+IFwib25lXCIsIGRlcHM6IFtbbmV3IEluamVjdChcIm9uZVwiKV1dfVxuICAgICAqIF0pO1xuICAgICAqXG4gICAgICogZXhwZWN0KCgpID0+IGluamVjdG9yLmdldChcIm9uZVwiKSkudG9UaHJvd0Vycm9yKCk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBSZXRyaWV2aW5nIGBBYCBvciBgQmAgdGhyb3dzIGEgYEN5Y2xpY0RlcGVuZGVuY3lFcnJvcmAgYXMgdGhlIGdyYXBoIGFib3ZlIGNhbm5vdCBiZSBjb25zdHJ1Y3RlZC5cbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEN5Y2xpY0RlcGVuZGVuY3lFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQxKEN5Y2xpY0RlcGVuZGVuY3lFcnJvciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gQ3ljbGljRGVwZW5kZW5jeUVycm9yKGluamVjdG9yLCBrZXkpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGluamVjdG9yLCBrZXksIGZ1bmN0aW9uIChrZXlzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiQ2Fubm90IGluc3RhbnRpYXRlIGN5Y2xpYyBkZXBlbmRlbmN5IVwiICsgY29uc3RydWN0UmVzb2x2aW5nUGF0aChrZXlzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBDeWNsaWNEZXBlbmRlbmN5RXJyb3I7XG4gICAgfShBYnN0cmFjdFByb3ZpZGVyRXJyb3IpKTtcbiAgICAvKipcbiAgICAgKiBUaHJvd24gd2hlbiBhIGNvbnN0cnVjdGluZyB0eXBlIHJldHVybnMgd2l0aCBhbiBFcnJvci5cbiAgICAgKlxuICAgICAqIFRoZSBgSW5zdGFudGlhdGlvbkVycm9yYCBjbGFzcyBjb250YWlucyB0aGUgb3JpZ2luYWwgZXJyb3IgcGx1cyB0aGUgZGVwZW5kZW5jeSBncmFwaCB3aGljaCBjYXVzZWRcbiAgICAgKiB0aGlzIG9iamVjdCB0byBiZSBpbnN0YW50aWF0ZWQuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvN2FXWWRjcVRRc1AwZU5xRWRVQWY/cD1wcmV2aWV3KSlcbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjbGFzcyBBIHtcbiAgICAgKiAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAqICAgICB0aHJvdyBuZXcgRXJyb3IoJ21lc3NhZ2UnKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgaW5qZWN0b3IgPSBJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtBXSk7XG5cbiAgICAgKiB0cnkge1xuICAgICAqICAgaW5qZWN0b3IuZ2V0KEEpO1xuICAgICAqIH0gY2F0Y2ggKGUpIHtcbiAgICAgKiAgIGV4cGVjdChlIGluc3RhbmNlb2YgSW5zdGFudGlhdGlvbkVycm9yKS50b0JlKHRydWUpO1xuICAgICAqICAgZXhwZWN0KGUub3JpZ2luYWxFeGNlcHRpb24ubWVzc2FnZSkudG9FcXVhbChcIm1lc3NhZ2VcIik7XG4gICAgICogICBleHBlY3QoZS5vcmlnaW5hbFN0YWNrKS50b0JlRGVmaW5lZCgpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEluc3RhbnRpYXRpb25FcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQxKEluc3RhbnRpYXRpb25FcnJvciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gSW5zdGFudGlhdGlvbkVycm9yKGluamVjdG9yLCBvcmlnaW5hbEV4Y2VwdGlvbiwgb3JpZ2luYWxTdGFjaywga2V5KSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCAnREkgRXJyb3InLCBvcmlnaW5hbEV4Y2VwdGlvbik7XG4gICAgICAgICAgICB0aGlzLmtleXMgPSBba2V5XTtcbiAgICAgICAgICAgIHRoaXMuaW5qZWN0b3JzID0gW2luamVjdG9yXTtcbiAgICAgICAgfVxuICAgICAgICBJbnN0YW50aWF0aW9uRXJyb3IucHJvdG90eXBlLmFkZEtleSA9IGZ1bmN0aW9uIChpbmplY3Rvciwga2V5KSB7XG4gICAgICAgICAgICB0aGlzLmluamVjdG9ycy5wdXNoKGluamVjdG9yKTtcbiAgICAgICAgICAgIHRoaXMua2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbnN0YW50aWF0aW9uRXJyb3IucHJvdG90eXBlLCBcIm1lc3NhZ2VcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpcnN0ID0gc3RyaW5naWZ5KExpc3RXcmFwcGVyLmZpcnN0KHRoaXMua2V5cykudG9rZW4pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9yaWdpbmFsRXJyb3IubWVzc2FnZSArIFwiOiBFcnJvciBkdXJpbmcgaW5zdGFudGlhdGlvbiBvZiBcIiArIGZpcnN0ICsgXCIhXCIgKyBjb25zdHJ1Y3RSZXNvbHZpbmdQYXRoKHRoaXMua2V5cykgKyBcIi5cIjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSW5zdGFudGlhdGlvbkVycm9yLnByb3RvdHlwZSwgXCJjYXVzZUtleVwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMua2V5c1swXTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBJbnN0YW50aWF0aW9uRXJyb3I7XG4gICAgfShXcmFwcGVkRXJyb3IpKTtcbiAgICAvKipcbiAgICAgKiBUaHJvd24gd2hlbiBhbiBvYmplY3Qgb3RoZXIgdGhlbiB7QGxpbmsgUHJvdmlkZXJ9IChvciBgVHlwZWApIGlzIHBhc3NlZCB0byB7QGxpbmsgSW5qZWN0b3J9XG4gICAgICogY3JlYXRpb24uXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvWWF0Q0ZiUEFNQ0wwSlNTUTRtdkg/cD1wcmV2aWV3KSlcbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBleHBlY3QoKCkgPT4gSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbXCJub3QgYSB0eXBlXCJdKSkudG9UaHJvd0Vycm9yKCk7XG4gICAgICogYGBgXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBJbnZhbGlkUHJvdmlkZXJFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQxKEludmFsaWRQcm92aWRlckVycm9yLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBJbnZhbGlkUHJvdmlkZXJFcnJvcihwcm92aWRlcikge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgXCJJbnZhbGlkIHByb3ZpZGVyIC0gb25seSBpbnN0YW5jZXMgb2YgUHJvdmlkZXIgYW5kIFR5cGUgYXJlIGFsbG93ZWQsIGdvdDogXCIgKyBwcm92aWRlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEludmFsaWRQcm92aWRlckVycm9yO1xuICAgIH0oQmFzZUVycm9yKSk7XG4gICAgLyoqXG4gICAgICogVGhyb3duIHdoZW4gdGhlIGNsYXNzIGhhcyBubyBhbm5vdGF0aW9uIGluZm9ybWF0aW9uLlxuICAgICAqXG4gICAgICogTGFjayBvZiBhbm5vdGF0aW9uIGluZm9ybWF0aW9uIHByZXZlbnRzIHRoZSB7QGxpbmsgSW5qZWN0b3J9IGZyb20gZGV0ZXJtaW5pbmcgd2hpY2ggZGVwZW5kZW5jaWVzXG4gICAgICogbmVlZCB0byBiZSBpbmplY3RlZCBpbnRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9ySG5adGxOUzd2Sk9QUTZwY1ZrbT9wPXByZXZpZXcpKVxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNsYXNzIEEge1xuICAgICAqICAgY29uc3RydWN0b3IoYikge31cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBleHBlY3QoKCkgPT4gSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbQV0pKS50b1Rocm93RXJyb3IoKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFRoaXMgZXJyb3IgaXMgYWxzbyB0aHJvd24gd2hlbiB0aGUgY2xhc3Mgbm90IG1hcmtlZCB3aXRoIHtAbGluayBJbmplY3RhYmxlfSBoYXMgcGFyYW1ldGVyIHR5cGVzLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNsYXNzIEIge31cbiAgICAgKlxuICAgICAqIGNsYXNzIEEge1xuICAgICAqICAgY29uc3RydWN0b3IoYjpCKSB7fSAvLyBubyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcGFyYW1ldGVyIHR5cGVzIG9mIEEgaXMgYXZhaWxhYmxlIGF0IHJ1bnRpbWUuXG4gICAgICogfVxuICAgICAqXG4gICAgICogZXhwZWN0KCgpID0+IEluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW0EsQl0pKS50b1Rocm93RXJyb3IoKTtcbiAgICAgKiBgYGBcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIE5vQW5ub3RhdGlvbkVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDEoTm9Bbm5vdGF0aW9uRXJyb3IsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIE5vQW5ub3RhdGlvbkVycm9yKHR5cGVPckZ1bmMsIHBhcmFtcykge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgTm9Bbm5vdGF0aW9uRXJyb3IuX2dlbk1lc3NhZ2UodHlwZU9yRnVuYywgcGFyYW1zKSk7XG4gICAgICAgIH1cbiAgICAgICAgTm9Bbm5vdGF0aW9uRXJyb3IuX2dlbk1lc3NhZ2UgPSBmdW5jdGlvbiAodHlwZU9yRnVuYywgcGFyYW1zKSB7XG4gICAgICAgICAgICB2YXIgc2lnbmF0dXJlID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBwYXJhbXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBwYXJhbWV0ZXIgPSBwYXJhbXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJhbWV0ZXIgfHwgcGFyYW1ldGVyLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZS5wdXNoKCc/Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmUucHVzaChwYXJhbWV0ZXIubWFwKHN0cmluZ2lmeSkuam9pbignICcpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJ0Nhbm5vdCByZXNvbHZlIGFsbCBwYXJhbWV0ZXJzIGZvciBcXCcnICsgc3RyaW5naWZ5KHR5cGVPckZ1bmMpICsgJ1xcJygnICtcbiAgICAgICAgICAgICAgICBzaWduYXR1cmUuam9pbignLCAnKSArICcpLiAnICtcbiAgICAgICAgICAgICAgICAnTWFrZSBzdXJlIHRoYXQgYWxsIHRoZSBwYXJhbWV0ZXJzIGFyZSBkZWNvcmF0ZWQgd2l0aCBJbmplY3Qgb3IgaGF2ZSB2YWxpZCB0eXBlIGFubm90YXRpb25zIGFuZCB0aGF0IFxcJycgK1xuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSh0eXBlT3JGdW5jKSArICdcXCcgaXMgZGVjb3JhdGVkIHdpdGggSW5qZWN0YWJsZS4nO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gTm9Bbm5vdGF0aW9uRXJyb3I7XG4gICAgfShCYXNlRXJyb3IpKTtcbiAgICAvKipcbiAgICAgKiBUaHJvd24gd2hlbiBnZXR0aW5nIGFuIG9iamVjdCBieSBpbmRleC5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9iUnMwU1gyT1RRaUp6cXZqZ2w4UD9wPXByZXZpZXcpKVxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNsYXNzIEEge31cbiAgICAgKlxuICAgICAqIHZhciBpbmplY3RvciA9IEluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW0FdKTtcbiAgICAgKlxuICAgICAqIGV4cGVjdCgoKSA9PiBpbmplY3Rvci5nZXRBdCgxMDApKS50b1Rocm93RXJyb3IoKTtcbiAgICAgKiBgYGBcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIE91dE9mQm91bmRzRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMShPdXRPZkJvdW5kc0Vycm9yLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBPdXRPZkJvdW5kc0Vycm9yKGluZGV4KSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBcIkluZGV4IFwiICsgaW5kZXggKyBcIiBpcyBvdXQtb2YtYm91bmRzLlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT3V0T2ZCb3VuZHNFcnJvcjtcbiAgICB9KEJhc2VFcnJvcikpO1xuICAgIC8vIFRPRE86IGFkZCBhIHdvcmtpbmcgZXhhbXBsZSBhZnRlciBhbHBoYTM4IGlzIHJlbGVhc2VkXG4gICAgLyoqXG4gICAgICogVGhyb3duIHdoZW4gYSBtdWx0aSBwcm92aWRlciBhbmQgYSByZWd1bGFyIHByb3ZpZGVyIGFyZSBib3VuZCB0byB0aGUgc2FtZSB0b2tlbi5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogZXhwZWN0KCgpID0+IEluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW1xuICAgICAqICAgeyBwcm92aWRlOiBcIlN0cmluZ3NcIiwgdXNlVmFsdWU6IFwic3RyaW5nMVwiLCBtdWx0aTogdHJ1ZX0sXG4gICAgICogICB7IHByb3ZpZGU6IFwiU3RyaW5nc1wiLCB1c2VWYWx1ZTogXCJzdHJpbmcyXCIsIG11bHRpOiBmYWxzZX1cbiAgICAgKiBdKSkudG9UaHJvd0Vycm9yKCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgdmFyIE1peGluZ011bHRpUHJvdmlkZXJzV2l0aFJlZ3VsYXJQcm92aWRlcnNFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQxKE1peGluZ011bHRpUHJvdmlkZXJzV2l0aFJlZ3VsYXJQcm92aWRlcnNFcnJvciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gTWl4aW5nTXVsdGlQcm92aWRlcnNXaXRoUmVndWxhclByb3ZpZGVyc0Vycm9yKHByb3ZpZGVyMSwgcHJvdmlkZXIyKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCAnQ2Fubm90IG1peCBtdWx0aSBwcm92aWRlcnMgYW5kIHJlZ3VsYXIgcHJvdmlkZXJzLCBnb3Q6ICcgKyBwcm92aWRlcjEudG9TdHJpbmcoKSArICcgJyArXG4gICAgICAgICAgICAgICAgcHJvdmlkZXIyLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNaXhpbmdNdWx0aVByb3ZpZGVyc1dpdGhSZWd1bGFyUHJvdmlkZXJzRXJyb3I7XG4gICAgfShCYXNlRXJyb3IpKTtcblxuICAgIC8qKlxuICAgICAqIEEgdW5pcXVlIG9iamVjdCB1c2VkIGZvciByZXRyaWV2aW5nIGl0ZW1zIGZyb20gdGhlIHtAbGluayBSZWZsZWN0aXZlSW5qZWN0b3J9LlxuICAgICAqXG4gICAgICogS2V5cyBoYXZlOlxuICAgICAqIC0gYSBzeXN0ZW0td2lkZSB1bmlxdWUgYGlkYC5cbiAgICAgKiAtIGEgYHRva2VuYC5cbiAgICAgKlxuICAgICAqIGBLZXlgIGlzIHVzZWQgaW50ZXJuYWxseSBieSB7QGxpbmsgUmVmbGVjdGl2ZUluamVjdG9yfSBiZWNhdXNlIGl0cyBzeXN0ZW0td2lkZSB1bmlxdWUgYGlkYCBhbGxvd3NcbiAgICAgKiB0aGVcbiAgICAgKiBpbmplY3RvciB0byBzdG9yZSBjcmVhdGVkIG9iamVjdHMgaW4gYSBtb3JlIGVmZmljaWVudCB3YXkuXG4gICAgICpcbiAgICAgKiBgS2V5YCBzaG91bGQgbm90IGJlIGNyZWF0ZWQgZGlyZWN0bHkuIHtAbGluayBSZWZsZWN0aXZlSW5qZWN0b3J9IGNyZWF0ZXMga2V5cyBhdXRvbWF0aWNhbGx5IHdoZW5cbiAgICAgKiByZXNvbHZpbmdcbiAgICAgKiBwcm92aWRlcnMuXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBSZWZsZWN0aXZlS2V5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIFJlZmxlY3RpdmVLZXkodG9rZW4sIGlkKSB7XG4gICAgICAgICAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgICAgICBpZiAoIXRva2VuKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUb2tlbiBtdXN0IGJlIGRlZmluZWQhJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlZmxlY3RpdmVLZXkucHJvdG90eXBlLCBcImRpc3BsYXlOYW1lXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmV0dXJucyBhIHN0cmluZ2lmaWVkIHRva2VuLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0cmluZ2lmeSh0aGlzLnRva2VuKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXRyaWV2ZXMgYSBgS2V5YCBmb3IgYSB0b2tlbi5cbiAgICAgICAgICovXG4gICAgICAgIFJlZmxlY3RpdmVLZXkuZ2V0ID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgICAgICByZXR1cm4gX2dsb2JhbEtleVJlZ2lzdHJ5LmdldChyZXNvbHZlRm9yd2FyZFJlZih0b2tlbikpO1xuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVmbGVjdGl2ZUtleSwgXCJudW1iZXJPZktleXNcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB0aGUgbnVtYmVyIG9mIGtleXMgcmVnaXN0ZXJlZCBpbiB0aGUgc3lzdGVtLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9nbG9iYWxLZXlSZWdpc3RyeS5udW1iZXJPZktleXM7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUmVmbGVjdGl2ZUtleTtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHZhciBLZXlSZWdpc3RyeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEtleVJlZ2lzdHJ5KCkge1xuICAgICAgICAgICAgdGhpcy5fYWxsS2V5cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgfVxuICAgICAgICBLZXlSZWdpc3RyeS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgICAgICBpZiAodG9rZW4gaW5zdGFuY2VvZiBSZWZsZWN0aXZlS2V5KVxuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgICAgIGlmICh0aGlzLl9hbGxLZXlzLmhhcyh0b2tlbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYWxsS2V5cy5nZXQodG9rZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG5ld0tleSA9IG5ldyBSZWZsZWN0aXZlS2V5KHRva2VuLCBSZWZsZWN0aXZlS2V5Lm51bWJlck9mS2V5cyk7XG4gICAgICAgICAgICB0aGlzLl9hbGxLZXlzLnNldCh0b2tlbiwgbmV3S2V5KTtcbiAgICAgICAgICAgIHJldHVybiBuZXdLZXk7XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShLZXlSZWdpc3RyeS5wcm90b3R5cGUsIFwibnVtYmVyT2ZLZXlzXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fYWxsS2V5cy5zaXplOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIEtleVJlZ2lzdHJ5O1xuICAgIH0oKSk7XG4gICAgdmFyIF9nbG9iYWxLZXlSZWdpc3RyeSA9IG5ldyBLZXlSZWdpc3RyeSgpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEB3aGF0SXREb2VzIFJlcHJlc2VudHMgYSB0eXBlIHRoYXQgYSBDb21wb25lbnQgb3Igb3RoZXIgb2JqZWN0IGlzIGluc3RhbmNlcyBvZi5cbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogQW4gZXhhbXBsZSBvZiBhIGBUeXBlYCBpcyBgTXlDdXN0b21Db21wb25lbnRgIGNsYXNzLCB3aGljaCBpbiBKYXZhU2NyaXB0IGlzIGJlIHJlcHJlc2VudGVkIGJ5XG4gICAgICogdGhlIGBNeUN1c3RvbUNvbXBvbmVudGAgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIFR5cGUgPSBGdW5jdGlvbjtcblxuICAgIHZhciBSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUmVmbGVjdGlvbkNhcGFiaWxpdGllcyhyZWZsZWN0KSB7XG4gICAgICAgICAgICB0aGlzLl9yZWZsZWN0ID0gcmVmbGVjdCB8fCBnbG9iYWwkMS5SZWZsZWN0O1xuICAgICAgICB9XG4gICAgICAgIFJlZmxlY3Rpb25DYXBhYmlsaXRpZXMucHJvdG90eXBlLmlzUmVmbGVjdGlvbkVuYWJsZWQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9O1xuICAgICAgICBSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLnByb3RvdHlwZS5mYWN0b3J5ID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIGFyZ3NbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3ICh0LmJpbmQuYXBwbHkodCwgW3ZvaWQgMF0uY29uY2F0KGFyZ3MpKSkoKTtcbiAgICAgICAgfTsgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLnByb3RvdHlwZS5femlwVHlwZXNBbmRBbm5vdGF0aW9ucyA9IGZ1bmN0aW9uIChwYXJhbVR5cGVzLCBwYXJhbUFubm90YXRpb25zKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJhbVR5cGVzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBBcnJheShwYXJhbUFubm90YXRpb25zLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgQXJyYXkocGFyYW1UeXBlcy5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBUUyBvdXRwdXRzIE9iamVjdCBmb3IgcGFyYW1ldGVycyB3aXRob3V0IHR5cGVzLCB3aGlsZSBUcmFjZXVyIG9taXRzXG4gICAgICAgICAgICAgICAgLy8gdGhlIGFubm90YXRpb25zLiBGb3Igbm93IHdlIHByZXNlcnZlIHRoZSBUcmFjZXVyIGJlaGF2aW9yIHRvIGFpZFxuICAgICAgICAgICAgICAgIC8vIG1pZ3JhdGlvbiwgYnV0IHRoaXMgY2FuIGJlIHJldmlzaXRlZC5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBhcmFtVHlwZXMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJhbVR5cGVzW2ldICE9IE9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSBbcGFyYW1UeXBlc1tpXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtQW5ub3RhdGlvbnMgJiYgaXNQcmVzZW50KHBhcmFtQW5ub3RhdGlvbnNbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IHJlc3VsdFtpXS5jb25jYXQocGFyYW1Bbm5vdGF0aW9uc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgUmVmbGVjdGlvbkNhcGFiaWxpdGllcy5wcm90b3R5cGUucGFyYW1ldGVycyA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgICAvLyBQcmVmZXIgdGhlIGRpcmVjdCBBUEkuXG4gICAgICAgICAgICBpZiAodHlwZS5wYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGUucGFyYW1ldGVycztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFQSSBvZiB0c2lja2xlIGZvciBsb3dlcmluZyBkZWNvcmF0b3JzIHRvIHByb3BlcnRpZXMgb24gdGhlIGNsYXNzLlxuICAgICAgICAgICAgaWYgKHR5cGUuY3RvclBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3RvclBhcmFtZXRlcnMgPSB0eXBlLmN0b3JQYXJhbWV0ZXJzO1xuICAgICAgICAgICAgICAgIHZhciBwYXJhbVR5cGVzID0gY3RvclBhcmFtZXRlcnMubWFwKGZ1bmN0aW9uIChjdG9yUGFyYW0pIHsgcmV0dXJuIGN0b3JQYXJhbSAmJiBjdG9yUGFyYW0udHlwZTsgfSk7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtQW5ub3RhdGlvbnMgPSBjdG9yUGFyYW1ldGVycy5tYXAoZnVuY3Rpb24gKGN0b3JQYXJhbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3RvclBhcmFtICYmIGNvbnZlcnRUc2lja2xlRGVjb3JhdG9ySW50b01ldGFkYXRhKGN0b3JQYXJhbS5kZWNvcmF0b3JzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5femlwVHlwZXNBbmRBbm5vdGF0aW9ucyhwYXJhbVR5cGVzLCBwYXJhbUFubm90YXRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFQSSBmb3IgbWV0YWRhdGEgY3JlYXRlZCBieSBpbnZva2luZyB0aGUgZGVjb3JhdG9ycy5cbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5fcmVmbGVjdCkgJiYgaXNQcmVzZW50KHRoaXMuX3JlZmxlY3QuZ2V0TWV0YWRhdGEpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtQW5ub3RhdGlvbnMgPSB0aGlzLl9yZWZsZWN0LmdldE1ldGFkYXRhKCdwYXJhbWV0ZXJzJywgdHlwZSk7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtVHlwZXMgPSB0aGlzLl9yZWZsZWN0LmdldE1ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIHR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChwYXJhbVR5cGVzIHx8IHBhcmFtQW5ub3RhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ppcFR5cGVzQW5kQW5ub3RhdGlvbnMocGFyYW1UeXBlcywgcGFyYW1Bbm5vdGF0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGhlIGFycmF5IGhhcyB0byBiZSBmaWxsZWQgd2l0aCBgdW5kZWZpbmVkYCBiZWNhdXNlIGhvbGVzIHdvdWxkIGJlIHNraXBwZWQgYnkgYHNvbWVgXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFycmF5KHR5cGUubGVuZ3RoKS5maWxsKHVuZGVmaW5lZCk7XG4gICAgICAgIH07XG4gICAgICAgIFJlZmxlY3Rpb25DYXBhYmlsaXRpZXMucHJvdG90eXBlLmFubm90YXRpb25zID0gZnVuY3Rpb24gKHR5cGVPckZ1bmMpIHtcbiAgICAgICAgICAgIC8vIFByZWZlciB0aGUgZGlyZWN0IEFQSS5cbiAgICAgICAgICAgIGlmICh0eXBlT3JGdW5jLmFubm90YXRpb25zKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFubm90YXRpb25zID0gdHlwZU9yRnVuYy5hbm5vdGF0aW9ucztcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFubm90YXRpb25zID09PSAnZnVuY3Rpb24nICYmIGFubm90YXRpb25zLmFubm90YXRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIGFubm90YXRpb25zID0gYW5ub3RhdGlvbnMuYW5ub3RhdGlvbnM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhbm5vdGF0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFQSSBvZiB0c2lja2xlIGZvciBsb3dlcmluZyBkZWNvcmF0b3JzIHRvIHByb3BlcnRpZXMgb24gdGhlIGNsYXNzLlxuICAgICAgICAgICAgaWYgKHR5cGVPckZ1bmMuZGVjb3JhdG9ycykge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb252ZXJ0VHNpY2tsZURlY29yYXRvckludG9NZXRhZGF0YSh0eXBlT3JGdW5jLmRlY29yYXRvcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQVBJIGZvciBtZXRhZGF0YSBjcmVhdGVkIGJ5IGludm9raW5nIHRoZSBkZWNvcmF0b3JzLlxuICAgICAgICAgICAgaWYgKHRoaXMuX3JlZmxlY3QgJiYgdGhpcy5fcmVmbGVjdC5nZXRNZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgIHZhciBhbm5vdGF0aW9ucyA9IHRoaXMuX3JlZmxlY3QuZ2V0TWV0YWRhdGEoJ2Fubm90YXRpb25zJywgdHlwZU9yRnVuYyk7XG4gICAgICAgICAgICAgICAgaWYgKGFubm90YXRpb25zKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYW5ub3RhdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH07XG4gICAgICAgIFJlZmxlY3Rpb25DYXBhYmlsaXRpZXMucHJvdG90eXBlLnByb3BNZXRhZGF0YSA9IGZ1bmN0aW9uICh0eXBlT3JGdW5jKSB7XG4gICAgICAgICAgICAvLyBQcmVmZXIgdGhlIGRpcmVjdCBBUEkuXG4gICAgICAgICAgICBpZiAodHlwZU9yRnVuYy5wcm9wTWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcE1ldGFkYXRhID0gdHlwZU9yRnVuYy5wcm9wTWV0YWRhdGE7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wTWV0YWRhdGEgPT09ICdmdW5jdGlvbicgJiYgcHJvcE1ldGFkYXRhLnByb3BNZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBwcm9wTWV0YWRhdGEgPSBwcm9wTWV0YWRhdGEucHJvcE1ldGFkYXRhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvcE1ldGFkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQVBJIG9mIHRzaWNrbGUgZm9yIGxvd2VyaW5nIGRlY29yYXRvcnMgdG8gcHJvcGVydGllcyBvbiB0aGUgY2xhc3MuXG4gICAgICAgICAgICBpZiAodHlwZU9yRnVuYy5wcm9wRGVjb3JhdG9ycykge1xuICAgICAgICAgICAgICAgIHZhciBwcm9wRGVjb3JhdG9yc18xID0gdHlwZU9yRnVuYy5wcm9wRGVjb3JhdG9ycztcbiAgICAgICAgICAgICAgICB2YXIgcHJvcE1ldGFkYXRhXzEgPSB7fTtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhwcm9wRGVjb3JhdG9yc18xKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BNZXRhZGF0YV8xW3Byb3BdID0gY29udmVydFRzaWNrbGVEZWNvcmF0b3JJbnRvTWV0YWRhdGEocHJvcERlY29yYXRvcnNfMVtwcm9wXSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3BNZXRhZGF0YV8xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQVBJIGZvciBtZXRhZGF0YSBjcmVhdGVkIGJ5IGludm9raW5nIHRoZSBkZWNvcmF0b3JzLlxuICAgICAgICAgICAgaWYgKHRoaXMuX3JlZmxlY3QgJiYgdGhpcy5fcmVmbGVjdC5nZXRNZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgIHZhciBwcm9wTWV0YWRhdGEgPSB0aGlzLl9yZWZsZWN0LmdldE1ldGFkYXRhKCdwcm9wTWV0YWRhdGEnLCB0eXBlT3JGdW5jKTtcbiAgICAgICAgICAgICAgICBpZiAocHJvcE1ldGFkYXRhKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvcE1ldGFkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9O1xuICAgICAgICBSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLnByb3RvdHlwZS5oYXNMaWZlY3ljbGVIb29rID0gZnVuY3Rpb24gKHR5cGUsIGxjUHJvcGVydHkpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlIGluc3RhbmNlb2YgVHlwZSAmJiBsY1Byb3BlcnR5IGluIHR5cGUucHJvdG90eXBlO1xuICAgICAgICB9O1xuICAgICAgICBSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLnByb3RvdHlwZS5nZXR0ZXIgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gbmV3IEZ1bmN0aW9uKCdvJywgJ3JldHVybiBvLicgKyBuYW1lICsgJzsnKTsgfTtcbiAgICAgICAgUmVmbGVjdGlvbkNhcGFiaWxpdGllcy5wcm90b3R5cGUuc2V0dGVyID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24oJ28nLCAndicsICdyZXR1cm4gby4nICsgbmFtZSArICcgPSB2OycpO1xuICAgICAgICB9O1xuICAgICAgICBSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLnByb3RvdHlwZS5tZXRob2QgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgdmFyIGZ1bmN0aW9uQm9keSA9IFwiaWYgKCFvLlwiICsgbmFtZSArIFwiKSB0aHJvdyBuZXcgRXJyb3IoJ1xcXCJcIiArIG5hbWUgKyBcIlxcXCIgaXMgdW5kZWZpbmVkJyk7XFxuICAgICAgICByZXR1cm4gby5cIiArIG5hbWUgKyBcIi5hcHBseShvLCBhcmdzKTtcIjtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24oJ28nLCAnYXJncycsIGZ1bmN0aW9uQm9keSk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFRoZXJlIGlzIG5vdCBhIGNvbmNlcHQgb2YgaW1wb3J0IHVyaSBpbiBKcywgYnV0IHRoaXMgaXMgdXNlZnVsIGluIGRldmVsb3BpbmcgRGFydCBhcHBsaWNhdGlvbnMuXG4gICAgICAgIFJlZmxlY3Rpb25DYXBhYmlsaXRpZXMucHJvdG90eXBlLmltcG9ydFVyaSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgICAvLyBTdGF0aWNTeW1ib2xcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZVsnZmlsZVBhdGgnXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlWydmaWxlUGF0aCddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUnVudGltZSB0eXBlXG4gICAgICAgICAgICByZXR1cm4gXCIuL1wiICsgc3RyaW5naWZ5KHR5cGUpO1xuICAgICAgICB9O1xuICAgICAgICBSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLnByb3RvdHlwZS5yZXNvbHZlSWRlbnRpZmllciA9IGZ1bmN0aW9uIChuYW1lLCBtb2R1bGVVcmwsIHJ1bnRpbWUpIHsgcmV0dXJuIHJ1bnRpbWU7IH07XG4gICAgICAgIFJlZmxlY3Rpb25DYXBhYmlsaXRpZXMucHJvdG90eXBlLnJlc29sdmVFbnVtID0gZnVuY3Rpb24gKGVudW1JZGVudGlmaWVyLCBuYW1lKSB7IHJldHVybiBlbnVtSWRlbnRpZmllcltuYW1lXTsgfTtcbiAgICAgICAgcmV0dXJuIFJlZmxlY3Rpb25DYXBhYmlsaXRpZXM7XG4gICAgfSgpKTtcbiAgICBmdW5jdGlvbiBjb252ZXJ0VHNpY2tsZURlY29yYXRvckludG9NZXRhZGF0YShkZWNvcmF0b3JJbnZvY2F0aW9ucykge1xuICAgICAgICBpZiAoIWRlY29yYXRvckludm9jYXRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlY29yYXRvckludm9jYXRpb25zLm1hcChmdW5jdGlvbiAoZGVjb3JhdG9ySW52b2NhdGlvbikge1xuICAgICAgICAgICAgdmFyIGRlY29yYXRvclR5cGUgPSBkZWNvcmF0b3JJbnZvY2F0aW9uLnR5cGU7XG4gICAgICAgICAgICB2YXIgYW5ub3RhdGlvbkNscyA9IGRlY29yYXRvclR5cGUuYW5ub3RhdGlvbkNscztcbiAgICAgICAgICAgIHZhciBhbm5vdGF0aW9uQXJncyA9IGRlY29yYXRvckludm9jYXRpb24uYXJncyA/IGRlY29yYXRvckludm9jYXRpb24uYXJncyA6IFtdO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyAoYW5ub3RhdGlvbkNscy5iaW5kLmFwcGx5KGFubm90YXRpb25DbHMsIFt2b2lkIDBdLmNvbmNhdChhbm5vdGF0aW9uQXJncykpKSgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgcmVhZC1vbmx5IGFjY2VzcyB0byByZWZsZWN0aW9uIGRhdGEgYWJvdXQgc3ltYm9scy4gVXNlZCBpbnRlcm5hbGx5IGJ5IEFuZ3VsYXJcbiAgICAgKiB0byBwb3dlciBkZXBlbmRlbmN5IGluamVjdGlvbiBhbmQgY29tcGlsYXRpb24uXG4gICAgICovXG4gICAgdmFyIFJlZmxlY3RvclJlYWRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFJlZmxlY3RvclJlYWRlcigpIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUmVmbGVjdG9yUmVhZGVyO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQyID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgYWNjZXNzIHRvIHJlZmxlY3Rpb24gZGF0YSBhYm91dCBzeW1ib2xzLiBVc2VkIGludGVybmFsbHkgYnkgQW5ndWxhclxuICAgICAqIHRvIHBvd2VyIGRlcGVuZGVuY3kgaW5qZWN0aW9uIGFuZCBjb21waWxhdGlvbi5cbiAgICAgKi9cbiAgICB2YXIgUmVmbGVjdG9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDIoUmVmbGVjdG9yLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBSZWZsZWN0b3IocmVmbGVjdGlvbkNhcGFiaWxpdGllcykge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLnJlZmxlY3Rpb25DYXBhYmlsaXRpZXMgPSByZWZsZWN0aW9uQ2FwYWJpbGl0aWVzO1xuICAgICAgICB9XG4gICAgICAgIFJlZmxlY3Rvci5wcm90b3R5cGUudXBkYXRlQ2FwYWJpbGl0aWVzID0gZnVuY3Rpb24gKGNhcHMpIHsgdGhpcy5yZWZsZWN0aW9uQ2FwYWJpbGl0aWVzID0gY2FwczsgfTtcbiAgICAgICAgUmVmbGVjdG9yLnByb3RvdHlwZS5mYWN0b3J5ID0gZnVuY3Rpb24gKHR5cGUpIHsgcmV0dXJuIHRoaXMucmVmbGVjdGlvbkNhcGFiaWxpdGllcy5mYWN0b3J5KHR5cGUpOyB9O1xuICAgICAgICBSZWZsZWN0b3IucHJvdG90eXBlLnBhcmFtZXRlcnMgPSBmdW5jdGlvbiAodHlwZU9yRnVuYykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVmbGVjdGlvbkNhcGFiaWxpdGllcy5wYXJhbWV0ZXJzKHR5cGVPckZ1bmMpO1xuICAgICAgICB9O1xuICAgICAgICBSZWZsZWN0b3IucHJvdG90eXBlLmFubm90YXRpb25zID0gZnVuY3Rpb24gKHR5cGVPckZ1bmMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZmxlY3Rpb25DYXBhYmlsaXRpZXMuYW5ub3RhdGlvbnModHlwZU9yRnVuYyk7XG4gICAgICAgIH07XG4gICAgICAgIFJlZmxlY3Rvci5wcm90b3R5cGUucHJvcE1ldGFkYXRhID0gZnVuY3Rpb24gKHR5cGVPckZ1bmMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZmxlY3Rpb25DYXBhYmlsaXRpZXMucHJvcE1ldGFkYXRhKHR5cGVPckZ1bmMpO1xuICAgICAgICB9O1xuICAgICAgICBSZWZsZWN0b3IucHJvdG90eXBlLmhhc0xpZmVjeWNsZUhvb2sgPSBmdW5jdGlvbiAodHlwZSwgbGNQcm9wZXJ0eSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVmbGVjdGlvbkNhcGFiaWxpdGllcy5oYXNMaWZlY3ljbGVIb29rKHR5cGUsIGxjUHJvcGVydHkpO1xuICAgICAgICB9O1xuICAgICAgICBSZWZsZWN0b3IucHJvdG90eXBlLmdldHRlciA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiB0aGlzLnJlZmxlY3Rpb25DYXBhYmlsaXRpZXMuZ2V0dGVyKG5hbWUpOyB9O1xuICAgICAgICBSZWZsZWN0b3IucHJvdG90eXBlLnNldHRlciA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiB0aGlzLnJlZmxlY3Rpb25DYXBhYmlsaXRpZXMuc2V0dGVyKG5hbWUpOyB9O1xuICAgICAgICBSZWZsZWN0b3IucHJvdG90eXBlLm1ldGhvZCA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiB0aGlzLnJlZmxlY3Rpb25DYXBhYmlsaXRpZXMubWV0aG9kKG5hbWUpOyB9O1xuICAgICAgICBSZWZsZWN0b3IucHJvdG90eXBlLmltcG9ydFVyaSA9IGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiB0aGlzLnJlZmxlY3Rpb25DYXBhYmlsaXRpZXMuaW1wb3J0VXJpKHR5cGUpOyB9O1xuICAgICAgICBSZWZsZWN0b3IucHJvdG90eXBlLnJlc29sdmVJZGVudGlmaWVyID0gZnVuY3Rpb24gKG5hbWUsIG1vZHVsZVVybCwgcnVudGltZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVmbGVjdGlvbkNhcGFiaWxpdGllcy5yZXNvbHZlSWRlbnRpZmllcihuYW1lLCBtb2R1bGVVcmwsIHJ1bnRpbWUpO1xuICAgICAgICB9O1xuICAgICAgICBSZWZsZWN0b3IucHJvdG90eXBlLnJlc29sdmVFbnVtID0gZnVuY3Rpb24gKGlkZW50aWZpZXIsIG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZmxlY3Rpb25DYXBhYmlsaXRpZXMucmVzb2x2ZUVudW0oaWRlbnRpZmllciwgbmFtZSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBSZWZsZWN0b3I7XG4gICAgfShSZWZsZWN0b3JSZWFkZXIpKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB7QGxpbmsgUmVmbGVjdG9yfSB1c2VkIGludGVybmFsbHkgaW4gQW5ndWxhciB0byBhY2Nlc3MgbWV0YWRhdGFcbiAgICAgKiBhYm91dCBzeW1ib2xzLlxuICAgICAqL1xuICAgIHZhciByZWZsZWN0b3IgPSBuZXcgUmVmbGVjdG9yKG5ldyBSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzKCkpO1xuXG4gICAgLyoqXG4gICAgICogYERlcGVuZGVuY3lgIGlzIHVzZWQgYnkgdGhlIGZyYW1ld29yayB0byBleHRlbmQgREkuXG4gICAgICogVGhpcyBpcyBpbnRlcm5hbCB0byBBbmd1bGFyIGFuZCBzaG91bGQgbm90IGJlIHVzZWQgZGlyZWN0bHkuXG4gICAgICovXG4gICAgdmFyIFJlZmxlY3RpdmVEZXBlbmRlbmN5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUmVmbGVjdGl2ZURlcGVuZGVuY3koa2V5LCBvcHRpb25hbCwgbG93ZXJCb3VuZFZpc2liaWxpdHksIHVwcGVyQm91bmRWaXNpYmlsaXR5LCBwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgICAgIHRoaXMub3B0aW9uYWwgPSBvcHRpb25hbDtcbiAgICAgICAgICAgIHRoaXMubG93ZXJCb3VuZFZpc2liaWxpdHkgPSBsb3dlckJvdW5kVmlzaWJpbGl0eTtcbiAgICAgICAgICAgIHRoaXMudXBwZXJCb3VuZFZpc2liaWxpdHkgPSB1cHBlckJvdW5kVmlzaWJpbGl0eTtcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcyA9IHByb3BlcnRpZXM7XG4gICAgICAgIH1cbiAgICAgICAgUmVmbGVjdGl2ZURlcGVuZGVuY3kuZnJvbUtleSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVmbGVjdGl2ZURlcGVuZGVuY3koa2V5LCBmYWxzZSwgbnVsbCwgbnVsbCwgW10pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUmVmbGVjdGl2ZURlcGVuZGVuY3k7XG4gICAgfSgpKTtcbiAgICB2YXIgX0VNUFRZX0xJU1QgPSBbXTtcbiAgICB2YXIgUmVzb2x2ZWRSZWZsZWN0aXZlUHJvdmlkZXJfID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUmVzb2x2ZWRSZWZsZWN0aXZlUHJvdmlkZXJfKGtleSwgcmVzb2x2ZWRGYWN0b3JpZXMsIG11bHRpUHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZlZEZhY3RvcmllcyA9IHJlc29sdmVkRmFjdG9yaWVzO1xuICAgICAgICAgICAgdGhpcy5tdWx0aVByb3ZpZGVyID0gbXVsdGlQcm92aWRlcjtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVzb2x2ZWRSZWZsZWN0aXZlUHJvdmlkZXJfLnByb3RvdHlwZSwgXCJyZXNvbHZlZEZhY3RvcnlcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnJlc29sdmVkRmFjdG9yaWVzWzBdOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFJlc29sdmVkUmVmbGVjdGl2ZVByb3ZpZGVyXztcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIEFuIGludGVybmFsIHJlc29sdmVkIHJlcHJlc2VudGF0aW9uIG9mIGEgZmFjdG9yeSBmdW5jdGlvbiBjcmVhdGVkIGJ5IHJlc29sdmluZyB7QGxpbmtcbiAgICAgKiBQcm92aWRlcn0uXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBSZXNvbHZlZFJlZmxlY3RpdmVGYWN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUmVzb2x2ZWRSZWZsZWN0aXZlRmFjdG9yeShcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRmFjdG9yeSBmdW5jdGlvbiB3aGljaCBjYW4gcmV0dXJuIGFuIGluc3RhbmNlIG9mIGFuIG9iamVjdCByZXByZXNlbnRlZCBieSBhIGtleS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZmFjdG9yeSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQXJndW1lbnRzIChkZXBlbmRlbmNpZXMpIHRvIHRoZSBgZmFjdG9yeWAgZnVuY3Rpb24uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGRlcGVuZGVuY2llcykge1xuICAgICAgICAgICAgdGhpcy5mYWN0b3J5ID0gZmFjdG9yeTtcbiAgICAgICAgICAgIHRoaXMuZGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBSZXNvbHZlZFJlZmxlY3RpdmVGYWN0b3J5O1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogUmVzb2x2ZSBhIHNpbmdsZSBwcm92aWRlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXNvbHZlUmVmbGVjdGl2ZUZhY3RvcnkocHJvdmlkZXIpIHtcbiAgICAgICAgdmFyIGZhY3RvcnlGbjtcbiAgICAgICAgdmFyIHJlc29sdmVkRGVwcztcbiAgICAgICAgaWYgKGlzUHJlc2VudChwcm92aWRlci51c2VDbGFzcykpIHtcbiAgICAgICAgICAgIHZhciB1c2VDbGFzcyA9IHJlc29sdmVGb3J3YXJkUmVmKHByb3ZpZGVyLnVzZUNsYXNzKTtcbiAgICAgICAgICAgIGZhY3RvcnlGbiA9IHJlZmxlY3Rvci5mYWN0b3J5KHVzZUNsYXNzKTtcbiAgICAgICAgICAgIHJlc29sdmVkRGVwcyA9IF9kZXBlbmRlbmNpZXNGb3IodXNlQ2xhc3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzUHJlc2VudChwcm92aWRlci51c2VFeGlzdGluZykpIHtcbiAgICAgICAgICAgIGZhY3RvcnlGbiA9IGZ1bmN0aW9uIChhbGlhc0luc3RhbmNlKSB7IHJldHVybiBhbGlhc0luc3RhbmNlOyB9O1xuICAgICAgICAgICAgcmVzb2x2ZWREZXBzID0gW1JlZmxlY3RpdmVEZXBlbmRlbmN5LmZyb21LZXkoUmVmbGVjdGl2ZUtleS5nZXQocHJvdmlkZXIudXNlRXhpc3RpbmcpKV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNQcmVzZW50KHByb3ZpZGVyLnVzZUZhY3RvcnkpKSB7XG4gICAgICAgICAgICBmYWN0b3J5Rm4gPSBwcm92aWRlci51c2VGYWN0b3J5O1xuICAgICAgICAgICAgcmVzb2x2ZWREZXBzID0gY29uc3RydWN0RGVwZW5kZW5jaWVzKHByb3ZpZGVyLnVzZUZhY3RvcnksIHByb3ZpZGVyLmRlcHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZmFjdG9yeUZuID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdmlkZXIudXNlVmFsdWU7IH07XG4gICAgICAgICAgICByZXNvbHZlZERlcHMgPSBfRU1QVFlfTElTVDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJlc29sdmVkUmVmbGVjdGl2ZUZhY3RvcnkoZmFjdG9yeUZuLCByZXNvbHZlZERlcHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUge0BsaW5rIFByb3ZpZGVyfSBpbnRvIHtAbGluayBSZXNvbHZlZFByb3ZpZGVyfS5cbiAgICAgKlxuICAgICAqIHtAbGluayBJbmplY3Rvcn0gaW50ZXJuYWxseSBvbmx5IHVzZXMge0BsaW5rIFJlc29sdmVkUHJvdmlkZXJ9LCB7QGxpbmsgUHJvdmlkZXJ9IGNvbnRhaW5zXG4gICAgICogY29udmVuaWVuY2UgcHJvdmlkZXIgc3ludGF4LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc29sdmVSZWZsZWN0aXZlUHJvdmlkZXIocHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXNvbHZlZFJlZmxlY3RpdmVQcm92aWRlcl8oUmVmbGVjdGl2ZUtleS5nZXQocHJvdmlkZXIucHJvdmlkZSksIFtyZXNvbHZlUmVmbGVjdGl2ZUZhY3RvcnkocHJvdmlkZXIpXSwgcHJvdmlkZXIubXVsdGkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlIGEgbGlzdCBvZiBQcm92aWRlcnMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVzb2x2ZVJlZmxlY3RpdmVQcm92aWRlcnMocHJvdmlkZXJzKSB7XG4gICAgICAgIHZhciBub3JtYWxpemVkID0gX25vcm1hbGl6ZVByb3ZpZGVycyhwcm92aWRlcnMsIFtdKTtcbiAgICAgICAgdmFyIHJlc29sdmVkID0gbm9ybWFsaXplZC5tYXAocmVzb2x2ZVJlZmxlY3RpdmVQcm92aWRlcik7XG4gICAgICAgIHJldHVybiBNYXBXcmFwcGVyLnZhbHVlcyhtZXJnZVJlc29sdmVkUmVmbGVjdGl2ZVByb3ZpZGVycyhyZXNvbHZlZCwgbmV3IE1hcCgpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1lcmdlcyBhIGxpc3Qgb2YgUmVzb2x2ZWRQcm92aWRlcnMgaW50byBhIGxpc3Qgd2hlcmVcbiAgICAgKiBlYWNoIGtleSBpcyBjb250YWluZWQgZXhhY3RseSBvbmNlIGFuZCBtdWx0aSBwcm92aWRlcnNcbiAgICAgKiBoYXZlIGJlZW4gbWVyZ2VkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lcmdlUmVzb2x2ZWRSZWZsZWN0aXZlUHJvdmlkZXJzKHByb3ZpZGVycywgbm9ybWFsaXplZFByb3ZpZGVyc01hcCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3ZpZGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHByb3ZpZGVyID0gcHJvdmlkZXJzW2ldO1xuICAgICAgICAgICAgdmFyIGV4aXN0aW5nID0gbm9ybWFsaXplZFByb3ZpZGVyc01hcC5nZXQocHJvdmlkZXIua2V5LmlkKTtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoZXhpc3RpbmcpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3ZpZGVyLm11bHRpUHJvdmlkZXIgIT09IGV4aXN0aW5nLm11bHRpUHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE1peGluZ011bHRpUHJvdmlkZXJzV2l0aFJlZ3VsYXJQcm92aWRlcnNFcnJvcihleGlzdGluZywgcHJvdmlkZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocHJvdmlkZXIubXVsdGlQcm92aWRlcikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHByb3ZpZGVyLnJlc29sdmVkRmFjdG9yaWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5yZXNvbHZlZEZhY3Rvcmllcy5wdXNoKHByb3ZpZGVyLnJlc29sdmVkRmFjdG9yaWVzW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZFByb3ZpZGVyc01hcC5zZXQocHJvdmlkZXIua2V5LmlkLCBwcm92aWRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc29sdmVkUHJvdmlkZXI7XG4gICAgICAgICAgICAgICAgaWYgKHByb3ZpZGVyLm11bHRpUHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRQcm92aWRlciA9IG5ldyBSZXNvbHZlZFJlZmxlY3RpdmVQcm92aWRlcl8ocHJvdmlkZXIua2V5LCBMaXN0V3JhcHBlci5jbG9uZShwcm92aWRlci5yZXNvbHZlZEZhY3RvcmllcyksIHByb3ZpZGVyLm11bHRpUHJvdmlkZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRQcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub3JtYWxpemVkUHJvdmlkZXJzTWFwLnNldChwcm92aWRlci5rZXkuaWQsIHJlc29sdmVkUHJvdmlkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub3JtYWxpemVkUHJvdmlkZXJzTWFwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfbm9ybWFsaXplUHJvdmlkZXJzKHByb3ZpZGVycywgcmVzKSB7XG4gICAgICAgIHByb3ZpZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgICBpZiAoYiBpbnN0YW5jZW9mIFR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXMucHVzaCh7IHByb3ZpZGU6IGIsIHVzZUNsYXNzOiBiIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYiAmJiB0eXBlb2YgYiA9PSAnb2JqZWN0JyAmJiBiLnByb3ZpZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlcy5wdXNoKGIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYiBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgX25vcm1hbGl6ZVByb3ZpZGVycyhiLCByZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRQcm92aWRlckVycm9yKGIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgZnVuY3Rpb24gY29uc3RydWN0RGVwZW5kZW5jaWVzKHR5cGVPckZ1bmMsIGRlcGVuZGVuY2llcykge1xuICAgICAgICBpZiAoIWRlcGVuZGVuY2llcykge1xuICAgICAgICAgICAgcmV0dXJuIF9kZXBlbmRlbmNpZXNGb3IodHlwZU9yRnVuYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1zID0gZGVwZW5kZW5jaWVzLm1hcChmdW5jdGlvbiAodCkgeyByZXR1cm4gW3RdOyB9KTtcbiAgICAgICAgICAgIHJldHVybiBkZXBlbmRlbmNpZXMubWFwKGZ1bmN0aW9uICh0KSB7IHJldHVybiBfZXh0cmFjdFRva2VuKHR5cGVPckZ1bmMsIHQsIHBhcmFtcyk7IH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9kZXBlbmRlbmNpZXNGb3IodHlwZU9yRnVuYykge1xuICAgICAgICB2YXIgcGFyYW1zID0gcmVmbGVjdG9yLnBhcmFtZXRlcnModHlwZU9yRnVuYyk7XG4gICAgICAgIGlmICghcGFyYW1zKVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICBpZiAocGFyYW1zLnNvbWUoaXNCbGFuaykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOb0Fubm90YXRpb25FcnJvcih0eXBlT3JGdW5jLCBwYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJhbXMubWFwKGZ1bmN0aW9uIChwKSB7IHJldHVybiBfZXh0cmFjdFRva2VuKHR5cGVPckZ1bmMsIHAsIHBhcmFtcyk7IH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfZXh0cmFjdFRva2VuKHR5cGVPckZ1bmMgLyoqIFRPRE8gIzkxMDAgKi8sIG1ldGFkYXRhIC8qKiBUT0RPICM5MTAwICovIC8qYW55W10gfCBhbnkqLywgcGFyYW1zKSB7XG4gICAgICAgIHZhciBkZXBQcm9wcyA9IFtdO1xuICAgICAgICB2YXIgdG9rZW4gPSBudWxsO1xuICAgICAgICB2YXIgb3B0aW9uYWwgPSBmYWxzZTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1ldGFkYXRhKSkge1xuICAgICAgICAgICAgaWYgKG1ldGFkYXRhIGluc3RhbmNlb2YgSW5qZWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jcmVhdGVEZXBlbmRlbmN5KG1ldGFkYXRhLnRva2VuLCBvcHRpb25hbCwgbnVsbCwgbnVsbCwgZGVwUHJvcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jcmVhdGVEZXBlbmRlbmN5KG1ldGFkYXRhLCBvcHRpb25hbCwgbnVsbCwgbnVsbCwgZGVwUHJvcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBsb3dlckJvdW5kVmlzaWJpbGl0eSA9IG51bGw7XG4gICAgICAgIHZhciB1cHBlckJvdW5kVmlzaWJpbGl0eSA9IG51bGw7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWV0YWRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbU1ldGFkYXRhID0gbWV0YWRhdGFbaV07XG4gICAgICAgICAgICBpZiAocGFyYW1NZXRhZGF0YSBpbnN0YW5jZW9mIFR5cGUpIHtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHBhcmFtTWV0YWRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJhbU1ldGFkYXRhIGluc3RhbmNlb2YgSW5qZWN0KSB7XG4gICAgICAgICAgICAgICAgdG9rZW4gPSBwYXJhbU1ldGFkYXRhLnRva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFyYW1NZXRhZGF0YSBpbnN0YW5jZW9mIE9wdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uYWwgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFyYW1NZXRhZGF0YSBpbnN0YW5jZW9mIFNlbGYpIHtcbiAgICAgICAgICAgICAgICB1cHBlckJvdW5kVmlzaWJpbGl0eSA9IHBhcmFtTWV0YWRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJhbU1ldGFkYXRhIGluc3RhbmNlb2YgSG9zdCkge1xuICAgICAgICAgICAgICAgIHVwcGVyQm91bmRWaXNpYmlsaXR5ID0gcGFyYW1NZXRhZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtTWV0YWRhdGEgaW5zdGFuY2VvZiBTa2lwU2VsZikge1xuICAgICAgICAgICAgICAgIGxvd2VyQm91bmRWaXNpYmlsaXR5ID0gcGFyYW1NZXRhZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0b2tlbiA9IHJlc29sdmVGb3J3YXJkUmVmKHRva2VuKTtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0b2tlbikpIHtcbiAgICAgICAgICAgIHJldHVybiBfY3JlYXRlRGVwZW5kZW5jeSh0b2tlbiwgb3B0aW9uYWwsIGxvd2VyQm91bmRWaXNpYmlsaXR5LCB1cHBlckJvdW5kVmlzaWJpbGl0eSwgZGVwUHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE5vQW5ub3RhdGlvbkVycm9yKHR5cGVPckZ1bmMsIHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gX2NyZWF0ZURlcGVuZGVuY3kodG9rZW4gLyoqIFRPRE8gIzkxMDAgKi8sIG9wdGlvbmFsIC8qKiBUT0RPICM5MTAwICovLCBsb3dlckJvdW5kVmlzaWJpbGl0eSAvKiogVE9ETyAjOTEwMCAqLywgdXBwZXJCb3VuZFZpc2liaWxpdHkgLyoqIFRPRE8gIzkxMDAgKi8sIGRlcFByb3BzIC8qKiBUT0RPICM5MTAwICovKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVmbGVjdGl2ZURlcGVuZGVuY3koUmVmbGVjdGl2ZUtleS5nZXQodG9rZW4pLCBvcHRpb25hbCwgbG93ZXJCb3VuZFZpc2liaWxpdHksIHVwcGVyQm91bmRWaXNpYmlsaXR5LCBkZXBQcm9wcyk7XG4gICAgfVxuXG4gICAgLy8gYXZvaWQgdW51c2VkIGltcG9ydCB3aGVuIFR5cGUgdW5pb24gdHlwZXMgYXJlIGVyYXNlZFxuICAgIC8vIFRocmVzaG9sZCBmb3IgdGhlIGR5bmFtaWMgdmVyc2lvblxuICAgIHZhciBfTUFYX0NPTlNUUlVDVElPTl9DT1VOVEVSID0gMTA7XG4gICAgdmFyIFVOREVGSU5FRCA9IG5ldyBPYmplY3QoKTtcbiAgICB2YXIgUmVmbGVjdGl2ZVByb3RvSW5qZWN0b3JJbmxpbmVTdHJhdGVneSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFJlZmxlY3RpdmVQcm90b0luamVjdG9ySW5saW5lU3RyYXRlZ3kocHJvdG9FSSwgcHJvdmlkZXJzKSB7XG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVyMCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVyMSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVyMiA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVyMyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVyNCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVyNSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVyNiA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVyNyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVyOCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVyOSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmtleUlkMCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmtleUlkMSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmtleUlkMiA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmtleUlkMyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmtleUlkNCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmtleUlkNSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmtleUlkNiA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmtleUlkNyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmtleUlkOCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmtleUlkOSA9IG51bGw7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gcHJvdmlkZXJzLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChsZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlcjAgPSBwcm92aWRlcnNbMF07XG4gICAgICAgICAgICAgICAgdGhpcy5rZXlJZDAgPSBwcm92aWRlcnNbMF0ua2V5LmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3ZpZGVyMSA9IHByb3ZpZGVyc1sxXTtcbiAgICAgICAgICAgICAgICB0aGlzLmtleUlkMSA9IHByb3ZpZGVyc1sxXS5rZXkuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvdmlkZXIyID0gcHJvdmlkZXJzWzJdO1xuICAgICAgICAgICAgICAgIHRoaXMua2V5SWQyID0gcHJvdmlkZXJzWzJdLmtleS5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZW5ndGggPiAzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlcjMgPSBwcm92aWRlcnNbM107XG4gICAgICAgICAgICAgICAgdGhpcy5rZXlJZDMgPSBwcm92aWRlcnNbM10ua2V5LmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlbmd0aCA+IDQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3ZpZGVyNCA9IHByb3ZpZGVyc1s0XTtcbiAgICAgICAgICAgICAgICB0aGlzLmtleUlkNCA9IHByb3ZpZGVyc1s0XS5rZXkuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGVuZ3RoID4gNSkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvdmlkZXI1ID0gcHJvdmlkZXJzWzVdO1xuICAgICAgICAgICAgICAgIHRoaXMua2V5SWQ1ID0gcHJvdmlkZXJzWzVdLmtleS5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZW5ndGggPiA2KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlcjYgPSBwcm92aWRlcnNbNl07XG4gICAgICAgICAgICAgICAgdGhpcy5rZXlJZDYgPSBwcm92aWRlcnNbNl0ua2V5LmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlbmd0aCA+IDcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3ZpZGVyNyA9IHByb3ZpZGVyc1s3XTtcbiAgICAgICAgICAgICAgICB0aGlzLmtleUlkNyA9IHByb3ZpZGVyc1s3XS5rZXkuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGVuZ3RoID4gOCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvdmlkZXI4ID0gcHJvdmlkZXJzWzhdO1xuICAgICAgICAgICAgICAgIHRoaXMua2V5SWQ4ID0gcHJvdmlkZXJzWzhdLmtleS5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZW5ndGggPiA5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlcjkgPSBwcm92aWRlcnNbOV07XG4gICAgICAgICAgICAgICAgdGhpcy5rZXlJZDkgPSBwcm92aWRlcnNbOV0ua2V5LmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFJlZmxlY3RpdmVQcm90b0luamVjdG9ySW5saW5lU3RyYXRlZ3kucHJvdG90eXBlLmdldFByb3ZpZGVyQXRJbmRleCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIwO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIxO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IDIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIyO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IDMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIzO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IDQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXI0O1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IDUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXI1O1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IDYpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXI2O1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IDcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXI3O1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IDgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXI4O1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IDkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXI5O1xuICAgICAgICAgICAgdGhyb3cgbmV3IE91dE9mQm91bmRzRXJyb3IoaW5kZXgpO1xuICAgICAgICB9O1xuICAgICAgICBSZWZsZWN0aXZlUHJvdG9JbmplY3RvcklubGluZVN0cmF0ZWd5LnByb3RvdHlwZS5jcmVhdGVJbmplY3RvclN0cmF0ZWd5ID0gZnVuY3Rpb24gKGluamVjdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZmxlY3RpdmVJbmplY3RvcklubGluZVN0cmF0ZWd5KGluamVjdG9yLCB0aGlzKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFJlZmxlY3RpdmVQcm90b0luamVjdG9ySW5saW5lU3RyYXRlZ3k7XG4gICAgfSgpKTtcbiAgICB2YXIgUmVmbGVjdGl2ZVByb3RvSW5qZWN0b3JEeW5hbWljU3RyYXRlZ3kgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBSZWZsZWN0aXZlUHJvdG9JbmplY3RvckR5bmFtaWNTdHJhdGVneShwcm90b0luaiwgcHJvdmlkZXJzKSB7XG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVycyA9IHByb3ZpZGVycztcbiAgICAgICAgICAgIHZhciBsZW4gPSBwcm92aWRlcnMubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5rZXlJZHMgPSBuZXcgQXJyYXkobGVuKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmtleUlkc1tpXSA9IHByb3ZpZGVyc1tpXS5rZXkuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgUmVmbGVjdGl2ZVByb3RvSW5qZWN0b3JEeW5hbWljU3RyYXRlZ3kucHJvdG90eXBlLmdldFByb3ZpZGVyQXRJbmRleCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLnByb3ZpZGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgT3V0T2ZCb3VuZHNFcnJvcihpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlcnNbaW5kZXhdO1xuICAgICAgICB9O1xuICAgICAgICBSZWZsZWN0aXZlUHJvdG9JbmplY3RvckR5bmFtaWNTdHJhdGVneS5wcm90b3R5cGUuY3JlYXRlSW5qZWN0b3JTdHJhdGVneSA9IGZ1bmN0aW9uIChlaSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWZsZWN0aXZlSW5qZWN0b3JEeW5hbWljU3RyYXRlZ3kodGhpcywgZWkpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUmVmbGVjdGl2ZVByb3RvSW5qZWN0b3JEeW5hbWljU3RyYXRlZ3k7XG4gICAgfSgpKTtcbiAgICB2YXIgUmVmbGVjdGl2ZVByb3RvSW5qZWN0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBSZWZsZWN0aXZlUHJvdG9JbmplY3Rvcihwcm92aWRlcnMpIHtcbiAgICAgICAgICAgIHRoaXMubnVtYmVyT2ZQcm92aWRlcnMgPSBwcm92aWRlcnMubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5fc3RyYXRlZ3kgPSBwcm92aWRlcnMubGVuZ3RoID4gX01BWF9DT05TVFJVQ1RJT05fQ09VTlRFUiA/XG4gICAgICAgICAgICAgICAgbmV3IFJlZmxlY3RpdmVQcm90b0luamVjdG9yRHluYW1pY1N0cmF0ZWd5KHRoaXMsIHByb3ZpZGVycykgOlxuICAgICAgICAgICAgICAgIG5ldyBSZWZsZWN0aXZlUHJvdG9JbmplY3RvcklubGluZVN0cmF0ZWd5KHRoaXMsIHByb3ZpZGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgUmVmbGVjdGl2ZVByb3RvSW5qZWN0b3IuZnJvbVJlc29sdmVkUHJvdmlkZXJzID0gZnVuY3Rpb24gKHByb3ZpZGVycykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWZsZWN0aXZlUHJvdG9JbmplY3Rvcihwcm92aWRlcnMpO1xuICAgICAgICB9O1xuICAgICAgICBSZWZsZWN0aXZlUHJvdG9JbmplY3Rvci5wcm90b3R5cGUuZ2V0UHJvdmlkZXJBdEluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RyYXRlZ3kuZ2V0UHJvdmlkZXJBdEluZGV4KGluZGV4KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFJlZmxlY3RpdmVQcm90b0luamVjdG9yO1xuICAgIH0oKSk7XG4gICAgdmFyIFJlZmxlY3RpdmVJbmplY3RvcklubGluZVN0cmF0ZWd5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUmVmbGVjdGl2ZUluamVjdG9ySW5saW5lU3RyYXRlZ3koaW5qZWN0b3IsIHByb3RvU3RyYXRlZ3kpIHtcbiAgICAgICAgICAgIHRoaXMuaW5qZWN0b3IgPSBpbmplY3RvcjtcbiAgICAgICAgICAgIHRoaXMucHJvdG9TdHJhdGVneSA9IHByb3RvU3RyYXRlZ3k7XG4gICAgICAgICAgICB0aGlzLm9iajAgPSBVTkRFRklORUQ7XG4gICAgICAgICAgICB0aGlzLm9iajEgPSBVTkRFRklORUQ7XG4gICAgICAgICAgICB0aGlzLm9iajIgPSBVTkRFRklORUQ7XG4gICAgICAgICAgICB0aGlzLm9iajMgPSBVTkRFRklORUQ7XG4gICAgICAgICAgICB0aGlzLm9iajQgPSBVTkRFRklORUQ7XG4gICAgICAgICAgICB0aGlzLm9iajUgPSBVTkRFRklORUQ7XG4gICAgICAgICAgICB0aGlzLm9iajYgPSBVTkRFRklORUQ7XG4gICAgICAgICAgICB0aGlzLm9iajcgPSBVTkRFRklORUQ7XG4gICAgICAgICAgICB0aGlzLm9iajggPSBVTkRFRklORUQ7XG4gICAgICAgICAgICB0aGlzLm9iajkgPSBVTkRFRklORUQ7XG4gICAgICAgIH1cbiAgICAgICAgUmVmbGVjdGl2ZUluamVjdG9ySW5saW5lU3RyYXRlZ3kucHJvdG90eXBlLnJlc2V0Q29uc3RydWN0aW9uQ291bnRlciA9IGZ1bmN0aW9uICgpIHsgdGhpcy5pbmplY3Rvci5fY29uc3RydWN0aW9uQ291bnRlciA9IDA7IH07XG4gICAgICAgIFJlZmxlY3RpdmVJbmplY3RvcklubGluZVN0cmF0ZWd5LnByb3RvdHlwZS5pbnN0YW50aWF0ZVByb3ZpZGVyID0gZnVuY3Rpb24gKHByb3ZpZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbmplY3Rvci5fbmV3KHByb3ZpZGVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgUmVmbGVjdGl2ZUluamVjdG9ySW5saW5lU3RyYXRlZ3kucHJvdG90eXBlLmdldE9iakJ5S2V5SWQgPSBmdW5jdGlvbiAoa2V5SWQpIHtcbiAgICAgICAgICAgIHZhciBwID0gdGhpcy5wcm90b1N0cmF0ZWd5O1xuICAgICAgICAgICAgdmFyIGluaiA9IHRoaXMuaW5qZWN0b3I7XG4gICAgICAgICAgICBpZiAocC5rZXlJZDAgPT09IGtleUlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub2JqMCA9PT0gVU5ERUZJTkVEKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2JqMCA9IGluai5fbmV3KHAucHJvdmlkZXIwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwLmtleUlkMSA9PT0ga2V5SWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vYmoxID09PSBVTkRFRklORUQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vYmoxID0gaW5qLl9uZXcocC5wcm92aWRlcjEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vYmoxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHAua2V5SWQyID09PSBrZXlJZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9iajIgPT09IFVOREVGSU5FRCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9iajIgPSBpbmouX25ldyhwLnByb3ZpZGVyMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9iajI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocC5rZXlJZDMgPT09IGtleUlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub2JqMyA9PT0gVU5ERUZJTkVEKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2JqMyA9IGluai5fbmV3KHAucHJvdmlkZXIzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwLmtleUlkNCA9PT0ga2V5SWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vYmo0ID09PSBVTkRFRklORUQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vYmo0ID0gaW5qLl9uZXcocC5wcm92aWRlcjQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vYmo0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHAua2V5SWQ1ID09PSBrZXlJZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9iajUgPT09IFVOREVGSU5FRCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9iajUgPSBpbmouX25ldyhwLnByb3ZpZGVyNSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9iajU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocC5rZXlJZDYgPT09IGtleUlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub2JqNiA9PT0gVU5ERUZJTkVEKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2JqNiA9IGluai5fbmV3KHAucHJvdmlkZXI2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqNjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwLmtleUlkNyA9PT0ga2V5SWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vYmo3ID09PSBVTkRFRklORUQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vYmo3ID0gaW5qLl9uZXcocC5wcm92aWRlcjcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vYmo3O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHAua2V5SWQ4ID09PSBrZXlJZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9iajggPT09IFVOREVGSU5FRCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9iajggPSBpbmouX25ldyhwLnByb3ZpZGVyOCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9iajg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocC5rZXlJZDkgPT09IGtleUlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub2JqOSA9PT0gVU5ERUZJTkVEKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2JqOSA9IGluai5fbmV3KHAucHJvdmlkZXI5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqOTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBVTkRFRklORUQ7XG4gICAgICAgIH07XG4gICAgICAgIFJlZmxlY3RpdmVJbmplY3RvcklubGluZVN0cmF0ZWd5LnByb3RvdHlwZS5nZXRPYmpBdEluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vYmowO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqMTtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PSAyKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9iajI7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT0gMylcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vYmozO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IDQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqNDtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PSA1KVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9iajU7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT0gNilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vYmo2O1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IDcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqNztcbiAgICAgICAgICAgIGlmIChpbmRleCA9PSA4KVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9iajg7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT0gOSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vYmo5O1xuICAgICAgICAgICAgdGhyb3cgbmV3IE91dE9mQm91bmRzRXJyb3IoaW5kZXgpO1xuICAgICAgICB9O1xuICAgICAgICBSZWZsZWN0aXZlSW5qZWN0b3JJbmxpbmVTdHJhdGVneS5wcm90b3R5cGUuZ2V0TWF4TnVtYmVyT2ZPYmplY3RzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX01BWF9DT05TVFJVQ1RJT05fQ09VTlRFUjsgfTtcbiAgICAgICAgcmV0dXJuIFJlZmxlY3RpdmVJbmplY3RvcklubGluZVN0cmF0ZWd5O1xuICAgIH0oKSk7XG4gICAgdmFyIFJlZmxlY3RpdmVJbmplY3RvckR5bmFtaWNTdHJhdGVneSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFJlZmxlY3RpdmVJbmplY3RvckR5bmFtaWNTdHJhdGVneShwcm90b1N0cmF0ZWd5LCBpbmplY3Rvcikge1xuICAgICAgICAgICAgdGhpcy5wcm90b1N0cmF0ZWd5ID0gcHJvdG9TdHJhdGVneTtcbiAgICAgICAgICAgIHRoaXMuaW5qZWN0b3IgPSBpbmplY3RvcjtcbiAgICAgICAgICAgIHRoaXMub2JqcyA9IG5ldyBBcnJheShwcm90b1N0cmF0ZWd5LnByb3ZpZGVycy5sZW5ndGgpO1xuICAgICAgICAgICAgTGlzdFdyYXBwZXIuZmlsbCh0aGlzLm9ianMsIFVOREVGSU5FRCk7XG4gICAgICAgIH1cbiAgICAgICAgUmVmbGVjdGl2ZUluamVjdG9yRHluYW1pY1N0cmF0ZWd5LnByb3RvdHlwZS5yZXNldENvbnN0cnVjdGlvbkNvdW50ZXIgPSBmdW5jdGlvbiAoKSB7IHRoaXMuaW5qZWN0b3IuX2NvbnN0cnVjdGlvbkNvdW50ZXIgPSAwOyB9O1xuICAgICAgICBSZWZsZWN0aXZlSW5qZWN0b3JEeW5hbWljU3RyYXRlZ3kucHJvdG90eXBlLmluc3RhbnRpYXRlUHJvdmlkZXIgPSBmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluamVjdG9yLl9uZXcocHJvdmlkZXIpO1xuICAgICAgICB9O1xuICAgICAgICBSZWZsZWN0aXZlSW5qZWN0b3JEeW5hbWljU3RyYXRlZ3kucHJvdG90eXBlLmdldE9iakJ5S2V5SWQgPSBmdW5jdGlvbiAoa2V5SWQpIHtcbiAgICAgICAgICAgIHZhciBwID0gdGhpcy5wcm90b1N0cmF0ZWd5O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwLmtleUlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChwLmtleUlkc1tpXSA9PT0ga2V5SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub2Jqc1tpXSA9PT0gVU5ERUZJTkVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9ianNbaV0gPSB0aGlzLmluamVjdG9yLl9uZXcocC5wcm92aWRlcnNbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9ianNbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFVOREVGSU5FRDtcbiAgICAgICAgfTtcbiAgICAgICAgUmVmbGVjdGl2ZUluamVjdG9yRHluYW1pY1N0cmF0ZWd5LnByb3RvdHlwZS5nZXRPYmpBdEluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMub2Jqcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgT3V0T2ZCb3VuZHNFcnJvcihpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vYmpzW2luZGV4XTtcbiAgICAgICAgfTtcbiAgICAgICAgUmVmbGVjdGl2ZUluamVjdG9yRHluYW1pY1N0cmF0ZWd5LnByb3RvdHlwZS5nZXRNYXhOdW1iZXJPZk9iamVjdHMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLm9ianMubGVuZ3RoOyB9O1xuICAgICAgICByZXR1cm4gUmVmbGVjdGl2ZUluamVjdG9yRHluYW1pY1N0cmF0ZWd5O1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogQSBSZWZsZWN0aXZlRGVwZW5kZW5jeSBpbmplY3Rpb24gY29udGFpbmVyIHVzZWQgZm9yIGluc3RhbnRpYXRpbmcgb2JqZWN0cyBhbmQgcmVzb2x2aW5nXG4gICAgICogZGVwZW5kZW5jaWVzLlxuICAgICAqXG4gICAgICogQW4gYEluamVjdG9yYCBpcyBhIHJlcGxhY2VtZW50IGZvciBhIGBuZXdgIG9wZXJhdG9yLCB3aGljaCBjYW4gYXV0b21hdGljYWxseSByZXNvbHZlIHRoZVxuICAgICAqIGNvbnN0cnVjdG9yIGRlcGVuZGVuY2llcy5cbiAgICAgKlxuICAgICAqIEluIHR5cGljYWwgdXNlLCBhcHBsaWNhdGlvbiBjb2RlIGFza3MgZm9yIHRoZSBkZXBlbmRlbmNpZXMgaW4gdGhlIGNvbnN0cnVjdG9yIGFuZCB0aGV5IGFyZVxuICAgICAqIHJlc29sdmVkIGJ5IHRoZSBgSW5qZWN0b3JgLlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L2p6amVjMD9wPXByZXZpZXcpKVxuICAgICAqXG4gICAgICogVGhlIGZvbGxvd2luZyBleGFtcGxlIGNyZWF0ZXMgYW4gYEluamVjdG9yYCBjb25maWd1cmVkIHRvIGNyZWF0ZSBgRW5naW5lYCBhbmQgYENhcmAuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogQEluamVjdGFibGUoKVxuICAgICAqIGNsYXNzIEVuZ2luZSB7XG4gICAgICogfVxuICAgICAqXG4gICAgICogQEluamVjdGFibGUoKVxuICAgICAqIGNsYXNzIENhciB7XG4gICAgICogICBjb25zdHJ1Y3RvcihwdWJsaWMgZW5naW5lOkVuZ2luZSkge31cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgaW5qZWN0b3IgPSBSZWZsZWN0aXZlSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbQ2FyLCBFbmdpbmVdKTtcbiAgICAgKiB2YXIgY2FyID0gaW5qZWN0b3IuZ2V0KENhcik7XG4gICAgICogZXhwZWN0KGNhciBpbnN0YW5jZW9mIENhcikudG9CZSh0cnVlKTtcbiAgICAgKiBleHBlY3QoY2FyLmVuZ2luZSBpbnN0YW5jZW9mIEVuZ2luZSkudG9CZSh0cnVlKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIE5vdGljZSwgd2UgZG9uJ3QgdXNlIHRoZSBgbmV3YCBvcGVyYXRvciBiZWNhdXNlIHdlIGV4cGxpY2l0bHkgd2FudCB0byBoYXZlIHRoZSBgSW5qZWN0b3JgXG4gICAgICogcmVzb2x2ZSBhbGwgb2YgdGhlIG9iamVjdCdzIGRlcGVuZGVuY2llcyBhdXRvbWF0aWNhbGx5LlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBSZWZsZWN0aXZlSW5qZWN0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBSZWZsZWN0aXZlSW5qZWN0b3IoKSB7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFR1cm5zIGFuIGFycmF5IG9mIHByb3ZpZGVyIGRlZmluaXRpb25zIGludG8gYW4gYXJyYXkgb2YgcmVzb2x2ZWQgcHJvdmlkZXJzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBBIHJlc29sdXRpb24gaXMgYSBwcm9jZXNzIG9mIGZsYXR0ZW5pbmcgbXVsdGlwbGUgbmVzdGVkIGFycmF5cyBhbmQgY29udmVydGluZyBpbmRpdmlkdWFsXG4gICAgICAgICAqIHByb3ZpZGVycyBpbnRvIGFuIGFycmF5IG9mIHtAbGluayBSZXNvbHZlZFJlZmxlY3RpdmVQcm92aWRlcn1zLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvQWlYVEhpP3A9cHJldmlldykpXG4gICAgICAgICAqXG4gICAgICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgICAgICogQEluamVjdGFibGUoKVxuICAgICAgICAgKiBjbGFzcyBFbmdpbmUge1xuICAgICAgICAgKiB9XG4gICAgICAgICAqXG4gICAgICAgICAqIEBJbmplY3RhYmxlKClcbiAgICAgICAgICogY2xhc3MgQ2FyIHtcbiAgICAgICAgICogICBjb25zdHJ1Y3RvcihwdWJsaWMgZW5naW5lOkVuZ2luZSkge31cbiAgICAgICAgICogfVxuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgcHJvdmlkZXJzID0gUmVmbGVjdGl2ZUluamVjdG9yLnJlc29sdmUoW0NhciwgW1tFbmdpbmVdXV0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBleHBlY3QocHJvdmlkZXJzLmxlbmd0aCkudG9FcXVhbCgyKTtcbiAgICAgICAgICpcbiAgICAgICAgICogZXhwZWN0KHByb3ZpZGVyc1swXSBpbnN0YW5jZW9mIFJlc29sdmVkUmVmbGVjdGl2ZVByb3ZpZGVyKS50b0JlKHRydWUpO1xuICAgICAgICAgKiBleHBlY3QocHJvdmlkZXJzWzBdLmtleS5kaXNwbGF5TmFtZSkudG9CZShcIkNhclwiKTtcbiAgICAgICAgICogZXhwZWN0KHByb3ZpZGVyc1swXS5kZXBlbmRlbmNpZXMubGVuZ3RoKS50b0VxdWFsKDEpO1xuICAgICAgICAgKiBleHBlY3QocHJvdmlkZXJzWzBdLmZhY3RvcnkpLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgICAqXG4gICAgICAgICAqIGV4cGVjdChwcm92aWRlcnNbMV0ua2V5LmRpc3BsYXlOYW1lKS50b0JlKFwiRW5naW5lXCIpO1xuICAgICAgICAgKiB9KTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSB7QGxpbmsgUmVmbGVjdGl2ZUluamVjdG9yI2Zyb21SZXNvbHZlZFByb3ZpZGVyc30gZm9yIG1vcmUgaW5mby5cbiAgICAgICAgICovXG4gICAgICAgIFJlZmxlY3RpdmVJbmplY3Rvci5yZXNvbHZlID0gZnVuY3Rpb24gKHByb3ZpZGVycykge1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVSZWZsZWN0aXZlUHJvdmlkZXJzKHByb3ZpZGVycyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXNvbHZlcyBhbiBhcnJheSBvZiBwcm92aWRlcnMgYW5kIGNyZWF0ZXMgYW4gaW5qZWN0b3IgZnJvbSB0aG9zZSBwcm92aWRlcnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBwYXNzZWQtaW4gcHJvdmlkZXJzIGNhbiBiZSBhbiBhcnJheSBvZiBgVHlwZWAsIHtAbGluayBQcm92aWRlcn0sXG4gICAgICAgICAqIG9yIGEgcmVjdXJzaXZlIGFycmF5IG9mIG1vcmUgcHJvdmlkZXJzLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvZVBPY2NBP3A9cHJldmlldykpXG4gICAgICAgICAqXG4gICAgICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgICAgICogQEluamVjdGFibGUoKVxuICAgICAgICAgKiBjbGFzcyBFbmdpbmUge1xuICAgICAgICAgKiB9XG4gICAgICAgICAqXG4gICAgICAgICAqIEBJbmplY3RhYmxlKClcbiAgICAgICAgICogY2xhc3MgQ2FyIHtcbiAgICAgICAgICogICBjb25zdHJ1Y3RvcihwdWJsaWMgZW5naW5lOkVuZ2luZSkge31cbiAgICAgICAgICogfVxuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgaW5qZWN0b3IgPSBSZWZsZWN0aXZlSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbQ2FyLCBFbmdpbmVdKTtcbiAgICAgICAgICogZXhwZWN0KGluamVjdG9yLmdldChDYXIpIGluc3RhbmNlb2YgQ2FyKS50b0JlKHRydWUpO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBmdW5jdGlvbiBpcyBzbG93ZXIgdGhhbiB0aGUgY29ycmVzcG9uZGluZyBgZnJvbVJlc29sdmVkUHJvdmlkZXJzYFxuICAgICAgICAgKiBiZWNhdXNlIGl0IG5lZWRzIHRvIHJlc29sdmUgdGhlIHBhc3NlZC1pbiBwcm92aWRlcnMgZmlyc3QuXG4gICAgICAgICAqIFNlZSB7QGxpbmsgSW5qZWN0b3IjcmVzb2x2ZX0gYW5kIHtAbGluayBJbmplY3RvciNmcm9tUmVzb2x2ZWRQcm92aWRlcnN9LlxuICAgICAgICAgKi9cbiAgICAgICAgUmVmbGVjdGl2ZUluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUgPSBmdW5jdGlvbiAocHJvdmlkZXJzLCBwYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnQgPT09IHZvaWQgMCkgeyBwYXJlbnQgPSBudWxsOyB9XG4gICAgICAgICAgICB2YXIgUmVzb2x2ZWRSZWZsZWN0aXZlUHJvdmlkZXJzID0gUmVmbGVjdGl2ZUluamVjdG9yLnJlc29sdmUocHJvdmlkZXJzKTtcbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0aXZlSW5qZWN0b3IuZnJvbVJlc29sdmVkUHJvdmlkZXJzKFJlc29sdmVkUmVmbGVjdGl2ZVByb3ZpZGVycywgcGFyZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYW4gaW5qZWN0b3IgZnJvbSBwcmV2aW91c2x5IHJlc29sdmVkIHByb3ZpZGVycy5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBBUEkgaXMgdGhlIHJlY29tbWVuZGVkIHdheSB0byBjb25zdHJ1Y3QgaW5qZWN0b3JzIGluIHBlcmZvcm1hbmNlLXNlbnNpdGl2ZSBwYXJ0cy5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L0tyU01jaT9wPXByZXZpZXcpKVxuICAgICAgICAgKlxuICAgICAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICAgICAqIEBJbmplY3RhYmxlKClcbiAgICAgICAgICogY2xhc3MgRW5naW5lIHtcbiAgICAgICAgICogfVxuICAgICAgICAgKlxuICAgICAgICAgKiBASW5qZWN0YWJsZSgpXG4gICAgICAgICAqIGNsYXNzIENhciB7XG4gICAgICAgICAqICAgY29uc3RydWN0b3IocHVibGljIGVuZ2luZTpFbmdpbmUpIHt9XG4gICAgICAgICAqIH1cbiAgICAgICAgICpcbiAgICAgICAgICogdmFyIHByb3ZpZGVycyA9IFJlZmxlY3RpdmVJbmplY3Rvci5yZXNvbHZlKFtDYXIsIEVuZ2luZV0pO1xuICAgICAgICAgKiB2YXIgaW5qZWN0b3IgPSBSZWZsZWN0aXZlSW5qZWN0b3IuZnJvbVJlc29sdmVkUHJvdmlkZXJzKHByb3ZpZGVycyk7XG4gICAgICAgICAqIGV4cGVjdChpbmplY3Rvci5nZXQoQ2FyKSBpbnN0YW5jZW9mIENhcikudG9CZSh0cnVlKTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgICAgICovXG4gICAgICAgIFJlZmxlY3RpdmVJbmplY3Rvci5mcm9tUmVzb2x2ZWRQcm92aWRlcnMgPSBmdW5jdGlvbiAocHJvdmlkZXJzLCBwYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnQgPT09IHZvaWQgMCkgeyBwYXJlbnQgPSBudWxsOyB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZmxlY3RpdmVJbmplY3Rvcl8oUmVmbGVjdGl2ZVByb3RvSW5qZWN0b3IuZnJvbVJlc29sdmVkUHJvdmlkZXJzKHByb3ZpZGVycyksIHBhcmVudCk7XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWZsZWN0aXZlSW5qZWN0b3IucHJvdG90eXBlLCBcInBhcmVudFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFBhcmVudCBvZiB0aGlzIGluamVjdG9yLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIDwhLS0gVE9ETzogQWRkIGEgbGluayB0byB0aGUgc2VjdGlvbiBvZiB0aGUgdXNlciBndWlkZSB0YWxraW5nIGFib3V0IGhpZXJhcmNoaWNhbCBpbmplY3Rpb24uXG4gICAgICAgICAgICAgKiAtLT5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvZW9zTUdvP3A9cHJldmlldykpXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAgICAgICAgICogdmFyIHBhcmVudCA9IFJlZmxlY3RpdmVJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtdKTtcbiAgICAgICAgICAgICAqIHZhciBjaGlsZCA9IHBhcmVudC5yZXNvbHZlQW5kQ3JlYXRlQ2hpbGQoW10pO1xuICAgICAgICAgICAgICogZXhwZWN0KGNoaWxkLnBhcmVudCkudG9CZShwYXJlbnQpO1xuICAgICAgICAgICAgICogYGBgXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc29sdmVzIGFuIGFycmF5IG9mIHByb3ZpZGVycyBhbmQgY3JlYXRlcyBhIGNoaWxkIGluamVjdG9yIGZyb20gdGhvc2UgcHJvdmlkZXJzLlxuICAgICAgICAgKlxuICAgICAgICAgKiA8IS0tIFRPRE86IEFkZCBhIGxpbmsgdG8gdGhlIHNlY3Rpb24gb2YgdGhlIHVzZXIgZ3VpZGUgdGFsa2luZyBhYm91dCBoaWVyYXJjaGljYWwgaW5qZWN0aW9uLlxuICAgICAgICAgKiAtLT5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIHBhc3NlZC1pbiBwcm92aWRlcnMgY2FuIGJlIGFuIGFycmF5IG9mIGBUeXBlYCwge0BsaW5rIFByb3ZpZGVyfSxcbiAgICAgICAgICogb3IgYSByZWN1cnNpdmUgYXJyYXkgb2YgbW9yZSBwcm92aWRlcnMuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9vcEIzVDQ/cD1wcmV2aWV3KSlcbiAgICAgICAgICpcbiAgICAgICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAgICAgKiBjbGFzcyBQYXJlbnRQcm92aWRlciB7fVxuICAgICAgICAgKiBjbGFzcyBDaGlsZFByb3ZpZGVyIHt9XG4gICAgICAgICAqXG4gICAgICAgICAqIHZhciBwYXJlbnQgPSBSZWZsZWN0aXZlSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbUGFyZW50UHJvdmlkZXJdKTtcbiAgICAgICAgICogdmFyIGNoaWxkID0gcGFyZW50LnJlc29sdmVBbmRDcmVhdGVDaGlsZChbQ2hpbGRQcm92aWRlcl0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBleHBlY3QoY2hpbGQuZ2V0KFBhcmVudFByb3ZpZGVyKSBpbnN0YW5jZW9mIFBhcmVudFByb3ZpZGVyKS50b0JlKHRydWUpO1xuICAgICAgICAgKiBleHBlY3QoY2hpbGQuZ2V0KENoaWxkUHJvdmlkZXIpIGluc3RhbmNlb2YgQ2hpbGRQcm92aWRlcikudG9CZSh0cnVlKTtcbiAgICAgICAgICogZXhwZWN0KGNoaWxkLmdldChQYXJlbnRQcm92aWRlcikpLnRvQmUocGFyZW50LmdldChQYXJlbnRQcm92aWRlcikpO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBmdW5jdGlvbiBpcyBzbG93ZXIgdGhhbiB0aGUgY29ycmVzcG9uZGluZyBgY3JlYXRlQ2hpbGRGcm9tUmVzb2x2ZWRgXG4gICAgICAgICAqIGJlY2F1c2UgaXQgbmVlZHMgdG8gcmVzb2x2ZSB0aGUgcGFzc2VkLWluIHByb3ZpZGVycyBmaXJzdC5cbiAgICAgICAgICogU2VlIHtAbGluayBJbmplY3RvciNyZXNvbHZlfSBhbmQge0BsaW5rIEluamVjdG9yI2NyZWF0ZUNoaWxkRnJvbVJlc29sdmVkfS5cbiAgICAgICAgICovXG4gICAgICAgIFJlZmxlY3RpdmVJbmplY3Rvci5wcm90b3R5cGUucmVzb2x2ZUFuZENyZWF0ZUNoaWxkID0gZnVuY3Rpb24gKHByb3ZpZGVycykgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCgpOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIGNoaWxkIGluamVjdG9yIGZyb20gcHJldmlvdXNseSByZXNvbHZlZCBwcm92aWRlcnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIDwhLS0gVE9ETzogQWRkIGEgbGluayB0byB0aGUgc2VjdGlvbiBvZiB0aGUgdXNlciBndWlkZSB0YWxraW5nIGFib3V0IGhpZXJhcmNoaWNhbCBpbmplY3Rpb24uXG4gICAgICAgICAqIC0tPlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIEFQSSBpcyB0aGUgcmVjb21tZW5kZWQgd2F5IHRvIGNvbnN0cnVjdCBpbmplY3RvcnMgaW4gcGVyZm9ybWFuY2Utc2Vuc2l0aXZlIHBhcnRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvVmh5ZmpOP3A9cHJldmlldykpXG4gICAgICAgICAqXG4gICAgICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgICAgICogY2xhc3MgUGFyZW50UHJvdmlkZXIge31cbiAgICAgICAgICogY2xhc3MgQ2hpbGRQcm92aWRlciB7fVxuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgcGFyZW50UHJvdmlkZXJzID0gUmVmbGVjdGl2ZUluamVjdG9yLnJlc29sdmUoW1BhcmVudFByb3ZpZGVyXSk7XG4gICAgICAgICAqIHZhciBjaGlsZFByb3ZpZGVycyA9IFJlZmxlY3RpdmVJbmplY3Rvci5yZXNvbHZlKFtDaGlsZFByb3ZpZGVyXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIHZhciBwYXJlbnQgPSBSZWZsZWN0aXZlSW5qZWN0b3IuZnJvbVJlc29sdmVkUHJvdmlkZXJzKHBhcmVudFByb3ZpZGVycyk7XG4gICAgICAgICAqIHZhciBjaGlsZCA9IHBhcmVudC5jcmVhdGVDaGlsZEZyb21SZXNvbHZlZChjaGlsZFByb3ZpZGVycyk7XG4gICAgICAgICAqXG4gICAgICAgICAqIGV4cGVjdChjaGlsZC5nZXQoUGFyZW50UHJvdmlkZXIpIGluc3RhbmNlb2YgUGFyZW50UHJvdmlkZXIpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAqIGV4cGVjdChjaGlsZC5nZXQoQ2hpbGRQcm92aWRlcikgaW5zdGFuY2VvZiBDaGlsZFByb3ZpZGVyKS50b0JlKHRydWUpO1xuICAgICAgICAgKiBleHBlY3QoY2hpbGQuZ2V0KFBhcmVudFByb3ZpZGVyKSkudG9CZShwYXJlbnQuZ2V0KFBhcmVudFByb3ZpZGVyKSk7XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgUmVmbGVjdGl2ZUluamVjdG9yLnByb3RvdHlwZS5jcmVhdGVDaGlsZEZyb21SZXNvbHZlZCA9IGZ1bmN0aW9uIChwcm92aWRlcnMpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmltcGxlbWVudGVkKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXNvbHZlcyBhIHByb3ZpZGVyIGFuZCBpbnN0YW50aWF0ZXMgYW4gb2JqZWN0IGluIHRoZSBjb250ZXh0IG9mIHRoZSBpbmplY3Rvci5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGNyZWF0ZWQgb2JqZWN0IGRvZXMgbm90IGdldCBjYWNoZWQgYnkgdGhlIGluamVjdG9yLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQveXZWWG9CP3A9cHJldmlldykpXG4gICAgICAgICAqXG4gICAgICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgICAgICogQEluamVjdGFibGUoKVxuICAgICAgICAgKiBjbGFzcyBFbmdpbmUge1xuICAgICAgICAgKiB9XG4gICAgICAgICAqXG4gICAgICAgICAqIEBJbmplY3RhYmxlKClcbiAgICAgICAgICogY2xhc3MgQ2FyIHtcbiAgICAgICAgICogICBjb25zdHJ1Y3RvcihwdWJsaWMgZW5naW5lOkVuZ2luZSkge31cbiAgICAgICAgICogfVxuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgaW5qZWN0b3IgPSBSZWZsZWN0aXZlSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbRW5naW5lXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIHZhciBjYXIgPSBpbmplY3Rvci5yZXNvbHZlQW5kSW5zdGFudGlhdGUoQ2FyKTtcbiAgICAgICAgICogZXhwZWN0KGNhci5lbmdpbmUpLnRvQmUoaW5qZWN0b3IuZ2V0KEVuZ2luZSkpO1xuICAgICAgICAgKiBleHBlY3QoY2FyKS5ub3QudG9CZShpbmplY3Rvci5yZXNvbHZlQW5kSW5zdGFudGlhdGUoQ2FyKSk7XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgUmVmbGVjdGl2ZUluamVjdG9yLnByb3RvdHlwZS5yZXNvbHZlQW5kSW5zdGFudGlhdGUgPSBmdW5jdGlvbiAocHJvdmlkZXIpIHsgcmV0dXJuIHVuaW1wbGVtZW50ZWQoKTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluc3RhbnRpYXRlcyBhbiBvYmplY3QgdXNpbmcgYSByZXNvbHZlZCBwcm92aWRlciBpbiB0aGUgY29udGV4dCBvZiB0aGUgaW5qZWN0b3IuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBjcmVhdGVkIG9iamVjdCBkb2VzIG5vdCBnZXQgY2FjaGVkIGJ5IHRoZSBpbmplY3Rvci5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L3B0Q0ltUT9wPXByZXZpZXcpKVxuICAgICAgICAgKlxuICAgICAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICAgICAqIEBJbmplY3RhYmxlKClcbiAgICAgICAgICogY2xhc3MgRW5naW5lIHtcbiAgICAgICAgICogfVxuICAgICAgICAgKlxuICAgICAgICAgKiBASW5qZWN0YWJsZSgpXG4gICAgICAgICAqIGNsYXNzIENhciB7XG4gICAgICAgICAqICAgY29uc3RydWN0b3IocHVibGljIGVuZ2luZTpFbmdpbmUpIHt9XG4gICAgICAgICAqIH1cbiAgICAgICAgICpcbiAgICAgICAgICogdmFyIGluamVjdG9yID0gUmVmbGVjdGl2ZUluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW0VuZ2luZV0pO1xuICAgICAgICAgKiB2YXIgY2FyUHJvdmlkZXIgPSBSZWZsZWN0aXZlSW5qZWN0b3IucmVzb2x2ZShbQ2FyXSlbMF07XG4gICAgICAgICAqIHZhciBjYXIgPSBpbmplY3Rvci5pbnN0YW50aWF0ZVJlc29sdmVkKGNhclByb3ZpZGVyKTtcbiAgICAgICAgICogZXhwZWN0KGNhci5lbmdpbmUpLnRvQmUoaW5qZWN0b3IuZ2V0KEVuZ2luZSkpO1xuICAgICAgICAgKiBleHBlY3QoY2FyKS5ub3QudG9CZShpbmplY3Rvci5pbnN0YW50aWF0ZVJlc29sdmVkKGNhclByb3ZpZGVyKSk7XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgUmVmbGVjdGl2ZUluamVjdG9yLnByb3RvdHlwZS5pbnN0YW50aWF0ZVJlc29sdmVkID0gZnVuY3Rpb24gKHByb3ZpZGVyKSB7IHJldHVybiB1bmltcGxlbWVudGVkKCk7IH07XG4gICAgICAgIHJldHVybiBSZWZsZWN0aXZlSW5qZWN0b3I7XG4gICAgfSgpKTtcbiAgICB2YXIgUmVmbGVjdGl2ZUluamVjdG9yXyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBSZWZsZWN0aXZlSW5qZWN0b3JfKF9wcm90byAvKiBQcm90b0luamVjdG9yICovLCBfcGFyZW50KSB7XG4gICAgICAgICAgICBpZiAoX3BhcmVudCA9PT0gdm9pZCAwKSB7IF9wYXJlbnQgPSBudWxsOyB9XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9jb25zdHJ1Y3Rpb25Db3VudGVyID0gMDtcbiAgICAgICAgICAgIHRoaXMuX3Byb3RvID0gX3Byb3RvO1xuICAgICAgICAgICAgdGhpcy5fcGFyZW50ID0gX3BhcmVudDtcbiAgICAgICAgICAgIHRoaXMuX3N0cmF0ZWd5ID0gX3Byb3RvLl9zdHJhdGVneS5jcmVhdGVJbmplY3RvclN0cmF0ZWd5KHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIFJlZmxlY3RpdmVJbmplY3Rvcl8ucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh0b2tlbiwgbm90Rm91bmRWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKG5vdEZvdW5kVmFsdWUgPT09IHZvaWQgMCkgeyBub3RGb3VuZFZhbHVlID0gVEhST1dfSUZfTk9UX0ZPVU5EOyB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0QnlLZXkoUmVmbGVjdGl2ZUtleS5nZXQodG9rZW4pLCBudWxsLCBudWxsLCBub3RGb3VuZFZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgUmVmbGVjdGl2ZUluamVjdG9yXy5wcm90b3R5cGUuZ2V0QXQgPSBmdW5jdGlvbiAoaW5kZXgpIHsgcmV0dXJuIHRoaXMuX3N0cmF0ZWd5LmdldE9iakF0SW5kZXgoaW5kZXgpOyB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVmbGVjdGl2ZUluamVjdG9yXy5wcm90b3R5cGUsIFwicGFyZW50XCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcGFyZW50OyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlZmxlY3RpdmVJbmplY3Rvcl8ucHJvdG90eXBlLCBcImludGVybmFsU3RyYXRlZ3lcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICAgICAqIEludGVybmFsLiBEbyBub3QgdXNlLlxuICAgICAgICAgICAgICogV2UgcmV0dXJuIGBhbnlgIG5vdCB0byBleHBvcnQgdGhlIEluamVjdG9yU3RyYXRlZ3kgdHlwZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zdHJhdGVneTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIFJlZmxlY3RpdmVJbmplY3Rvcl8ucHJvdG90eXBlLnJlc29sdmVBbmRDcmVhdGVDaGlsZCA9IGZ1bmN0aW9uIChwcm92aWRlcnMpIHtcbiAgICAgICAgICAgIHZhciBSZXNvbHZlZFJlZmxlY3RpdmVQcm92aWRlcnMgPSBSZWZsZWN0aXZlSW5qZWN0b3IucmVzb2x2ZShwcm92aWRlcnMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQ2hpbGRGcm9tUmVzb2x2ZWQoUmVzb2x2ZWRSZWZsZWN0aXZlUHJvdmlkZXJzKTtcbiAgICAgICAgfTtcbiAgICAgICAgUmVmbGVjdGl2ZUluamVjdG9yXy5wcm90b3R5cGUuY3JlYXRlQ2hpbGRGcm9tUmVzb2x2ZWQgPSBmdW5jdGlvbiAocHJvdmlkZXJzKSB7XG4gICAgICAgICAgICB2YXIgcHJvdG8gPSBuZXcgUmVmbGVjdGl2ZVByb3RvSW5qZWN0b3IocHJvdmlkZXJzKTtcbiAgICAgICAgICAgIHZhciBpbmogPSBuZXcgUmVmbGVjdGl2ZUluamVjdG9yXyhwcm90byk7XG4gICAgICAgICAgICBpbmouX3BhcmVudCA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gaW5qO1xuICAgICAgICB9O1xuICAgICAgICBSZWZsZWN0aXZlSW5qZWN0b3JfLnByb3RvdHlwZS5yZXNvbHZlQW5kSW5zdGFudGlhdGUgPSBmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluc3RhbnRpYXRlUmVzb2x2ZWQoUmVmbGVjdGl2ZUluamVjdG9yLnJlc29sdmUoW3Byb3ZpZGVyXSlbMF0pO1xuICAgICAgICB9O1xuICAgICAgICBSZWZsZWN0aXZlSW5qZWN0b3JfLnByb3RvdHlwZS5pbnN0YW50aWF0ZVJlc29sdmVkID0gZnVuY3Rpb24gKHByb3ZpZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW5zdGFudGlhdGVQcm92aWRlcihwcm92aWRlcik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgUmVmbGVjdGl2ZUluamVjdG9yXy5wcm90b3R5cGUuX25ldyA9IGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2NvbnN0cnVjdGlvbkNvdW50ZXIrKyA+IHRoaXMuX3N0cmF0ZWd5LmdldE1heE51bWJlck9mT2JqZWN0cygpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEN5Y2xpY0RlcGVuZGVuY3lFcnJvcih0aGlzLCBwcm92aWRlci5rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2luc3RhbnRpYXRlUHJvdmlkZXIocHJvdmlkZXIpO1xuICAgICAgICB9O1xuICAgICAgICBSZWZsZWN0aXZlSW5qZWN0b3JfLnByb3RvdHlwZS5faW5zdGFudGlhdGVQcm92aWRlciA9IGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgICAgICAgICAgaWYgKHByb3ZpZGVyLm11bHRpUHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gbmV3IEFycmF5KHByb3ZpZGVyLnJlc29sdmVkRmFjdG9yaWVzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm92aWRlci5yZXNvbHZlZEZhY3Rvcmllcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICByZXNbaV0gPSB0aGlzLl9pbnN0YW50aWF0ZShwcm92aWRlciwgcHJvdmlkZXIucmVzb2x2ZWRGYWN0b3JpZXNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2luc3RhbnRpYXRlKHByb3ZpZGVyLCBwcm92aWRlci5yZXNvbHZlZEZhY3Rvcmllc1swXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFJlZmxlY3RpdmVJbmplY3Rvcl8ucHJvdG90eXBlLl9pbnN0YW50aWF0ZSA9IGZ1bmN0aW9uIChwcm92aWRlciwgUmVzb2x2ZWRSZWZsZWN0aXZlRmFjdG9yeSkge1xuICAgICAgICAgICAgdmFyIGZhY3RvcnkgPSBSZXNvbHZlZFJlZmxlY3RpdmVGYWN0b3J5LmZhY3Rvcnk7XG4gICAgICAgICAgICB2YXIgZGVwcyA9IFJlc29sdmVkUmVmbGVjdGl2ZUZhY3RvcnkuZGVwZW5kZW5jaWVzO1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGRlcHMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGQwO1xuICAgICAgICAgICAgdmFyIGQxO1xuICAgICAgICAgICAgdmFyIGQyO1xuICAgICAgICAgICAgdmFyIGQzO1xuICAgICAgICAgICAgdmFyIGQ0O1xuICAgICAgICAgICAgdmFyIGQ1O1xuICAgICAgICAgICAgdmFyIGQ2O1xuICAgICAgICAgICAgdmFyIGQ3O1xuICAgICAgICAgICAgdmFyIGQ4O1xuICAgICAgICAgICAgdmFyIGQ5O1xuICAgICAgICAgICAgdmFyIGQxMDtcbiAgICAgICAgICAgIHZhciBkMTE7XG4gICAgICAgICAgICB2YXIgZDEyO1xuICAgICAgICAgICAgdmFyIGQxMztcbiAgICAgICAgICAgIHZhciBkMTQ7XG4gICAgICAgICAgICB2YXIgZDE1O1xuICAgICAgICAgICAgdmFyIGQxNjtcbiAgICAgICAgICAgIHZhciBkMTc7XG4gICAgICAgICAgICB2YXIgZDE4O1xuICAgICAgICAgICAgdmFyIGQxOTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZDAgPSBsZW5ndGggPiAwID8gdGhpcy5fZ2V0QnlSZWZsZWN0aXZlRGVwZW5kZW5jeShwcm92aWRlciwgZGVwc1swXSkgOiBudWxsO1xuICAgICAgICAgICAgICAgIGQxID0gbGVuZ3RoID4gMSA/IHRoaXMuX2dldEJ5UmVmbGVjdGl2ZURlcGVuZGVuY3kocHJvdmlkZXIsIGRlcHNbMV0pIDogbnVsbDtcbiAgICAgICAgICAgICAgICBkMiA9IGxlbmd0aCA+IDIgPyB0aGlzLl9nZXRCeVJlZmxlY3RpdmVEZXBlbmRlbmN5KHByb3ZpZGVyLCBkZXBzWzJdKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgZDMgPSBsZW5ndGggPiAzID8gdGhpcy5fZ2V0QnlSZWZsZWN0aXZlRGVwZW5kZW5jeShwcm92aWRlciwgZGVwc1szXSkgOiBudWxsO1xuICAgICAgICAgICAgICAgIGQ0ID0gbGVuZ3RoID4gNCA/IHRoaXMuX2dldEJ5UmVmbGVjdGl2ZURlcGVuZGVuY3kocHJvdmlkZXIsIGRlcHNbNF0pIDogbnVsbDtcbiAgICAgICAgICAgICAgICBkNSA9IGxlbmd0aCA+IDUgPyB0aGlzLl9nZXRCeVJlZmxlY3RpdmVEZXBlbmRlbmN5KHByb3ZpZGVyLCBkZXBzWzVdKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgZDYgPSBsZW5ndGggPiA2ID8gdGhpcy5fZ2V0QnlSZWZsZWN0aXZlRGVwZW5kZW5jeShwcm92aWRlciwgZGVwc1s2XSkgOiBudWxsO1xuICAgICAgICAgICAgICAgIGQ3ID0gbGVuZ3RoID4gNyA/IHRoaXMuX2dldEJ5UmVmbGVjdGl2ZURlcGVuZGVuY3kocHJvdmlkZXIsIGRlcHNbN10pIDogbnVsbDtcbiAgICAgICAgICAgICAgICBkOCA9IGxlbmd0aCA+IDggPyB0aGlzLl9nZXRCeVJlZmxlY3RpdmVEZXBlbmRlbmN5KHByb3ZpZGVyLCBkZXBzWzhdKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgZDkgPSBsZW5ndGggPiA5ID8gdGhpcy5fZ2V0QnlSZWZsZWN0aXZlRGVwZW5kZW5jeShwcm92aWRlciwgZGVwc1s5XSkgOiBudWxsO1xuICAgICAgICAgICAgICAgIGQxMCA9IGxlbmd0aCA+IDEwID8gdGhpcy5fZ2V0QnlSZWZsZWN0aXZlRGVwZW5kZW5jeShwcm92aWRlciwgZGVwc1sxMF0pIDogbnVsbDtcbiAgICAgICAgICAgICAgICBkMTEgPSBsZW5ndGggPiAxMSA/IHRoaXMuX2dldEJ5UmVmbGVjdGl2ZURlcGVuZGVuY3kocHJvdmlkZXIsIGRlcHNbMTFdKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgZDEyID0gbGVuZ3RoID4gMTIgPyB0aGlzLl9nZXRCeVJlZmxlY3RpdmVEZXBlbmRlbmN5KHByb3ZpZGVyLCBkZXBzWzEyXSkgOiBudWxsO1xuICAgICAgICAgICAgICAgIGQxMyA9IGxlbmd0aCA+IDEzID8gdGhpcy5fZ2V0QnlSZWZsZWN0aXZlRGVwZW5kZW5jeShwcm92aWRlciwgZGVwc1sxM10pIDogbnVsbDtcbiAgICAgICAgICAgICAgICBkMTQgPSBsZW5ndGggPiAxNCA/IHRoaXMuX2dldEJ5UmVmbGVjdGl2ZURlcGVuZGVuY3kocHJvdmlkZXIsIGRlcHNbMTRdKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgZDE1ID0gbGVuZ3RoID4gMTUgPyB0aGlzLl9nZXRCeVJlZmxlY3RpdmVEZXBlbmRlbmN5KHByb3ZpZGVyLCBkZXBzWzE1XSkgOiBudWxsO1xuICAgICAgICAgICAgICAgIGQxNiA9IGxlbmd0aCA+IDE2ID8gdGhpcy5fZ2V0QnlSZWZsZWN0aXZlRGVwZW5kZW5jeShwcm92aWRlciwgZGVwc1sxNl0pIDogbnVsbDtcbiAgICAgICAgICAgICAgICBkMTcgPSBsZW5ndGggPiAxNyA/IHRoaXMuX2dldEJ5UmVmbGVjdGl2ZURlcGVuZGVuY3kocHJvdmlkZXIsIGRlcHNbMTddKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgZDE4ID0gbGVuZ3RoID4gMTggPyB0aGlzLl9nZXRCeVJlZmxlY3RpdmVEZXBlbmRlbmN5KHByb3ZpZGVyLCBkZXBzWzE4XSkgOiBudWxsO1xuICAgICAgICAgICAgICAgIGQxOSA9IGxlbmd0aCA+IDE5ID8gdGhpcy5fZ2V0QnlSZWZsZWN0aXZlRGVwZW5kZW5jeShwcm92aWRlciwgZGVwc1sxOV0pIDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBBYnN0cmFjdFByb3ZpZGVyRXJyb3IgfHwgZSBpbnN0YW5jZW9mIEluc3RhbnRpYXRpb25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBlLmFkZEtleSh0aGlzLCBwcm92aWRlci5rZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG9iajtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gZmFjdG9yeSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IGZhY3RvcnkoZDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IGZhY3RvcnkoZDAsIGQxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBmYWN0b3J5KGQwLCBkMSwgZDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IGZhY3RvcnkoZDAsIGQxLCBkMiwgZDMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IGZhY3RvcnkoZDAsIGQxLCBkMiwgZDMsIGQ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBmYWN0b3J5KGQwLCBkMSwgZDIsIGQzLCBkNCwgZDUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IGZhY3RvcnkoZDAsIGQxLCBkMiwgZDMsIGQ0LCBkNSwgZDYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IGZhY3RvcnkoZDAsIGQxLCBkMiwgZDMsIGQ0LCBkNSwgZDYsIGQ3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBmYWN0b3J5KGQwLCBkMSwgZDIsIGQzLCBkNCwgZDUsIGQ2LCBkNywgZDgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBmYWN0b3J5KGQwLCBkMSwgZDIsIGQzLCBkNCwgZDUsIGQ2LCBkNywgZDgsIGQ5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gZmFjdG9yeShkMCwgZDEsIGQyLCBkMywgZDQsIGQ1LCBkNiwgZDcsIGQ4LCBkOSwgZDEwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gZmFjdG9yeShkMCwgZDEsIGQyLCBkMywgZDQsIGQ1LCBkNiwgZDcsIGQ4LCBkOSwgZDEwLCBkMTEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBmYWN0b3J5KGQwLCBkMSwgZDIsIGQzLCBkNCwgZDUsIGQ2LCBkNywgZDgsIGQ5LCBkMTAsIGQxMSwgZDEyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gZmFjdG9yeShkMCwgZDEsIGQyLCBkMywgZDQsIGQ1LCBkNiwgZDcsIGQ4LCBkOSwgZDEwLCBkMTEsIGQxMiwgZDEzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gZmFjdG9yeShkMCwgZDEsIGQyLCBkMywgZDQsIGQ1LCBkNiwgZDcsIGQ4LCBkOSwgZDEwLCBkMTEsIGQxMiwgZDEzLCBkMTQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBmYWN0b3J5KGQwLCBkMSwgZDIsIGQzLCBkNCwgZDUsIGQ2LCBkNywgZDgsIGQ5LCBkMTAsIGQxMSwgZDEyLCBkMTMsIGQxNCwgZDE1KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gZmFjdG9yeShkMCwgZDEsIGQyLCBkMywgZDQsIGQ1LCBkNiwgZDcsIGQ4LCBkOSwgZDEwLCBkMTEsIGQxMiwgZDEzLCBkMTQsIGQxNSwgZDE2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gZmFjdG9yeShkMCwgZDEsIGQyLCBkMywgZDQsIGQ1LCBkNiwgZDcsIGQ4LCBkOSwgZDEwLCBkMTEsIGQxMiwgZDEzLCBkMTQsIGQxNSwgZDE2LCBkMTcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBmYWN0b3J5KGQwLCBkMSwgZDIsIGQzLCBkNCwgZDUsIGQ2LCBkNywgZDgsIGQ5LCBkMTAsIGQxMSwgZDEyLCBkMTMsIGQxNCwgZDE1LCBkMTYsIGQxNywgZDE4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDIwOlxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gZmFjdG9yeShkMCwgZDEsIGQyLCBkMywgZDQsIGQ1LCBkNiwgZDcsIGQ4LCBkOSwgZDEwLCBkMTEsIGQxMiwgZDEzLCBkMTQsIGQxNSwgZDE2LCBkMTcsIGQxOCwgZDE5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGluc3RhbnRpYXRlICdcIiArIHByb3ZpZGVyLmtleS5kaXNwbGF5TmFtZSArIFwiJyBiZWNhdXNlIGl0IGhhcyBtb3JlIHRoYW4gMjAgZGVwZW5kZW5jaWVzXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEluc3RhbnRpYXRpb25FcnJvcih0aGlzLCBlLCBlLnN0YWNrLCBwcm92aWRlci5rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfTtcbiAgICAgICAgUmVmbGVjdGl2ZUluamVjdG9yXy5wcm90b3R5cGUuX2dldEJ5UmVmbGVjdGl2ZURlcGVuZGVuY3kgPSBmdW5jdGlvbiAocHJvdmlkZXIsIGRlcCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldEJ5S2V5KGRlcC5rZXksIGRlcC5sb3dlckJvdW5kVmlzaWJpbGl0eSwgZGVwLnVwcGVyQm91bmRWaXNpYmlsaXR5LCBkZXAub3B0aW9uYWwgPyBudWxsIDogVEhST1dfSUZfTk9UX0ZPVU5EKTtcbiAgICAgICAgfTtcbiAgICAgICAgUmVmbGVjdGl2ZUluamVjdG9yXy5wcm90b3R5cGUuX2dldEJ5S2V5ID0gZnVuY3Rpb24gKGtleSwgbG93ZXJCb3VuZFZpc2liaWxpdHksIHVwcGVyQm91bmRWaXNpYmlsaXR5LCBub3RGb3VuZFZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSBJTkpFQ1RPUl9LRVkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1cHBlckJvdW5kVmlzaWJpbGl0eSBpbnN0YW5jZW9mIFNlbGYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0QnlLZXlTZWxmKGtleSwgbm90Rm91bmRWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0QnlLZXlEZWZhdWx0KGtleSwgbm90Rm91bmRWYWx1ZSwgbG93ZXJCb3VuZFZpc2liaWxpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIFJlZmxlY3RpdmVJbmplY3Rvcl8ucHJvdG90eXBlLl90aHJvd09yTnVsbCA9IGZ1bmN0aW9uIChrZXksIG5vdEZvdW5kVmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChub3RGb3VuZFZhbHVlICE9PSBUSFJPV19JRl9OT1RfRk9VTkQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm90Rm91bmRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb1Byb3ZpZGVyRXJyb3IodGhpcywga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBSZWZsZWN0aXZlSW5qZWN0b3JfLnByb3RvdHlwZS5fZ2V0QnlLZXlTZWxmID0gZnVuY3Rpb24gKGtleSwgbm90Rm91bmRWYWx1ZSkge1xuICAgICAgICAgICAgdmFyIG9iaiA9IHRoaXMuX3N0cmF0ZWd5LmdldE9iakJ5S2V5SWQoa2V5LmlkKTtcbiAgICAgICAgICAgIHJldHVybiAob2JqICE9PSBVTkRFRklORUQpID8gb2JqIDogdGhpcy5fdGhyb3dPck51bGwoa2V5LCBub3RGb3VuZFZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBSZWZsZWN0aXZlSW5qZWN0b3JfLnByb3RvdHlwZS5fZ2V0QnlLZXlEZWZhdWx0ID0gZnVuY3Rpb24gKGtleSwgbm90Rm91bmRWYWx1ZSwgbG93ZXJCb3VuZFZpc2liaWxpdHkpIHtcbiAgICAgICAgICAgIHZhciBpbmo7XG4gICAgICAgICAgICBpZiAobG93ZXJCb3VuZFZpc2liaWxpdHkgaW5zdGFuY2VvZiBTa2lwU2VsZikge1xuICAgICAgICAgICAgICAgIGluaiA9IHRoaXMuX3BhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGluaiA9IHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoaW5qIGluc3RhbmNlb2YgUmVmbGVjdGl2ZUluamVjdG9yXykge1xuICAgICAgICAgICAgICAgIHZhciBpbmpfID0gaW5qO1xuICAgICAgICAgICAgICAgIHZhciBvYmogPSBpbmpfLl9zdHJhdGVneS5nZXRPYmpCeUtleUlkKGtleS5pZCk7XG4gICAgICAgICAgICAgICAgaWYgKG9iaiAhPT0gVU5ERUZJTkVEKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgICAgIGluaiA9IGlual8uX3BhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbmogIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5qLmdldChrZXkudG9rZW4sIG5vdEZvdW5kVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Rocm93T3JOdWxsKGtleSwgbm90Rm91bmRWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWZsZWN0aXZlSW5qZWN0b3JfLnByb3RvdHlwZSwgXCJkaXNwbGF5TmFtZVwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvdmlkZXJzID0gX21hcFByb3ZpZGVycyh0aGlzLCBmdW5jdGlvbiAoYikgeyByZXR1cm4gJyBcIicgKyBiLmtleS5kaXNwbGF5TmFtZSArICdcIiAnOyB9KVxuICAgICAgICAgICAgICAgICAgICAuam9pbignLCAnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJSZWZsZWN0aXZlSW5qZWN0b3IocHJvdmlkZXJzOiBbXCIgKyBwcm92aWRlcnMgKyBcIl0pXCI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgUmVmbGVjdGl2ZUluamVjdG9yXy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmRpc3BsYXlOYW1lOyB9O1xuICAgICAgICByZXR1cm4gUmVmbGVjdGl2ZUluamVjdG9yXztcbiAgICB9KCkpO1xuICAgIHZhciBJTkpFQ1RPUl9LRVkgPSBSZWZsZWN0aXZlS2V5LmdldChJbmplY3Rvcik7XG4gICAgZnVuY3Rpb24gX21hcFByb3ZpZGVycyhpbmplY3RvciwgZm4pIHtcbiAgICAgICAgdmFyIHJlcyA9IG5ldyBBcnJheShpbmplY3Rvci5fcHJvdG8ubnVtYmVyT2ZQcm92aWRlcnMpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluamVjdG9yLl9wcm90by5udW1iZXJPZlByb3ZpZGVyczsgKytpKSB7XG4gICAgICAgICAgICByZXNbaV0gPSBmbihpbmplY3Rvci5fcHJvdG8uZ2V0UHJvdmlkZXJBdEluZGV4KGkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAd2hhdEl0RG9lcyBQcm92aWRlcyBhIGhvb2sgZm9yIGNlbnRyYWxpemVkIGV4Y2VwdGlvbiBoYW5kbGluZy5cbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgYEVycm9ySGFuZGxlcmAgcHJpbnRzIGVycm9yIG1lc3NhZ2VzIHRvIHRoZSBgY29uc29sZWAuIFRvXG4gICAgICogaW50ZXJjZXB0IGVycm9yIGhhbmRsaW5nLCB3cml0ZSBhIGN1c3RvbSBleGNlcHRpb24gaGFuZGxlciB0aGF0IHJlcGxhY2VzIHRoaXMgZGVmYXVsdCBhc1xuICAgICAqIGFwcHJvcHJpYXRlIGZvciB5b3VyIGFwcC5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBjbGFzcyBNeUVycm9ySGFuZGxlciBpbXBsZW1lbnRzIEVycm9ySGFuZGxlciB7XG4gICAgICogICBoYW5kbGVFcnJvcihlcnJvcikge1xuICAgICAqICAgICAvLyBkbyBzb21ldGhpbmcgd2l0aCB0aGUgZXhjZXB0aW9uXG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICogQE5nTW9kdWxlKHtcbiAgICAgKiAgIHByb3ZpZGVyczogW3twcm92aWRlOiBFcnJvckhhbmRsZXIsIHVzZUNsYXNzOiBNeUVycm9ySGFuZGxlcn1dXG4gICAgICogfSlcbiAgICAgKiBjbGFzcyBNeU1vZHVsZSB7fVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBFcnJvckhhbmRsZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBFcnJvckhhbmRsZXIocmV0aHJvd0Vycm9yKSB7XG4gICAgICAgICAgICBpZiAocmV0aHJvd0Vycm9yID09PSB2b2lkIDApIHsgcmV0aHJvd0Vycm9yID0gdHJ1ZTsgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5fY29uc29sZSA9IGNvbnNvbGU7XG4gICAgICAgICAgICB0aGlzLnJldGhyb3dFcnJvciA9IHJldGhyb3dFcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBFcnJvckhhbmRsZXIucHJvdG90eXBlLmhhbmRsZUVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICB2YXIgb3JpZ2luYWxFcnJvciA9IHRoaXMuX2ZpbmRPcmlnaW5hbEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIHZhciBvcmlnaW5hbFN0YWNrID0gdGhpcy5fZmluZE9yaWdpbmFsU3RhY2soZXJyb3IpO1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLl9maW5kQ29udGV4dChlcnJvcik7XG4gICAgICAgICAgICB0aGlzLl9jb25zb2xlLmVycm9yKFwiRVhDRVBUSU9OOiBcIiArIHRoaXMuX2V4dHJhY3RNZXNzYWdlKGVycm9yKSk7XG4gICAgICAgICAgICBpZiAob3JpZ2luYWxFcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnNvbGUuZXJyb3IoXCJPUklHSU5BTCBFWENFUFRJT046IFwiICsgdGhpcy5fZXh0cmFjdE1lc3NhZ2Uob3JpZ2luYWxFcnJvcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9yaWdpbmFsU3RhY2spIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb25zb2xlLmVycm9yKCdPUklHSU5BTCBTVEFDS1RSQUNFOicpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnNvbGUuZXJyb3Iob3JpZ2luYWxTdGFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29udGV4dCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnNvbGUuZXJyb3IoJ0VSUk9SIENPTlRFWFQ6Jyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29uc29sZS5lcnJvcihjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlIHJldGhyb3cgZXhjZXB0aW9ucywgc28gb3BlcmF0aW9ucyBsaWtlICdib290c3RyYXAnIHdpbGwgcmVzdWx0IGluIGFuIGVycm9yXG4gICAgICAgICAgICAvLyB3aGVuIGFuIGVycm9yIGhhcHBlbnMuIElmIHdlIGRvIG5vdCByZXRocm93LCBib290c3RyYXAgd2lsbCBhbHdheXMgc3VjY2VlZC5cbiAgICAgICAgICAgIGlmICh0aGlzLnJldGhyb3dFcnJvcilcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBFcnJvckhhbmRsZXIucHJvdG90eXBlLl9leHRyYWN0TWVzc2FnZSA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogZXJyb3IudG9TdHJpbmcoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBFcnJvckhhbmRsZXIucHJvdG90eXBlLl9maW5kQ29udGV4dCA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yLmNvbnRleHQgPyBlcnJvci5jb250ZXh0IDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmluZENvbnRleHQoZXJyb3Iub3JpZ2luYWxFcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBFcnJvckhhbmRsZXIucHJvdG90eXBlLl9maW5kT3JpZ2luYWxFcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgdmFyIGUgPSBlcnJvci5vcmlnaW5hbEVycm9yO1xuICAgICAgICAgICAgd2hpbGUgKGUgJiYgZS5vcmlnaW5hbEVycm9yKSB7XG4gICAgICAgICAgICAgICAgZSA9IGUub3JpZ2luYWxFcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIEVycm9ySGFuZGxlci5wcm90b3R5cGUuX2ZpbmRPcmlnaW5hbFN0YWNrID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoIShlcnJvciBpbnN0YW5jZW9mIEVycm9yKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHZhciBlID0gZXJyb3I7XG4gICAgICAgICAgICB2YXIgc3RhY2sgPSBlLnN0YWNrO1xuICAgICAgICAgICAgd2hpbGUgKGUgaW5zdGFuY2VvZiBFcnJvciAmJiBlLm9yaWdpbmFsRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlID0gZS5vcmlnaW5hbEVycm9yO1xuICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IgJiYgZS5zdGFjaykge1xuICAgICAgICAgICAgICAgICAgICBzdGFjayA9IGUuc3RhY2s7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0YWNrO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRXJyb3JIYW5kbGVyO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNQcm9taXNlKG9iaikge1xuICAgICAgICAvLyBhbGxvdyBhbnkgUHJvbWlzZS9BKyBjb21wbGlhbnQgdGhlbmFibGUuXG4gICAgICAgIC8vIEl0J3MgdXAgdG8gdGhlIGNhbGxlciB0byBlbnN1cmUgdGhhdCBvYmoudGhlbiBjb25mb3JtcyB0byB0aGUgc3BlY1xuICAgICAgICByZXR1cm4gISFvYmogJiYgdHlwZW9mIG9iai50aGVuID09PSAnZnVuY3Rpb24nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gYW4gYXBwbGljYXRpb24gaXMgaW5pdGlhbGl6ZWQuXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBBUFBfSU5JVElBTElaRVIgPSBuZXcgT3BhcXVlVG9rZW4oJ0FwcGxpY2F0aW9uIEluaXRpYWxpemVyJyk7XG4gICAgLyoqXG4gICAgICogQSBjbGFzcyB0aGF0IHJlZmxlY3RzIHRoZSBzdGF0ZSBvZiBydW5uaW5nIHtAbGluayBBUFBfSU5JVElBTElaRVJ9cy5cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgQXBwbGljYXRpb25Jbml0U3RhdHVzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQXBwbGljYXRpb25Jbml0U3RhdHVzKGFwcEluaXRzKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5fZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGFzeW5jSW5pdFByb21pc2VzID0gW107XG4gICAgICAgICAgICBpZiAoYXBwSW5pdHMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFwcEluaXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbml0UmVzdWx0ID0gYXBwSW5pdHNbaV0oKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUHJvbWlzZShpbml0UmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXN5bmNJbml0UHJvbWlzZXMucHVzaChpbml0UmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2RvbmVQcm9taXNlID0gUHJvbWlzZS5hbGwoYXN5bmNJbml0UHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24gKCkgeyBfdGhpcy5fZG9uZSA9IHRydWU7IH0pO1xuICAgICAgICAgICAgaWYgKGFzeW5jSW5pdFByb21pc2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcHBsaWNhdGlvbkluaXRTdGF0dXMucHJvdG90eXBlLCBcImRvbmVcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kb25lOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFwcGxpY2F0aW9uSW5pdFN0YXR1cy5wcm90b3R5cGUsIFwiZG9uZVByb21pc2VcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kb25lUHJvbWlzZTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIEFwcGxpY2F0aW9uSW5pdFN0YXR1cy5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBJbmplY3RhYmxlIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBBcHBsaWNhdGlvbkluaXRTdGF0dXMuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IEFycmF5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtBUFBfSU5JVElBTElaRVIsXSB9LCB7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gQXBwbGljYXRpb25Jbml0U3RhdHVzO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBBIERJIFRva2VuIHJlcHJlc2VudGluZyBhIHVuaXF1ZSBzdHJpbmcgaWQgYXNzaWduZWQgdG8gdGhlIGFwcGxpY2F0aW9uIGJ5IEFuZ3VsYXIgYW5kIHVzZWRcbiAgICAgKiBwcmltYXJpbHkgZm9yIHByZWZpeGluZyBhcHBsaWNhdGlvbiBhdHRyaWJ1dGVzIGFuZCBDU1Mgc3R5bGVzIHdoZW5cbiAgICAgKiB7QGxpbmsgVmlld0VuY2Fwc3VsYXRpb24jRW11bGF0ZWR9IGlzIGJlaW5nIHVzZWQuXG4gICAgICpcbiAgICAgKiBJZiB5b3UgbmVlZCB0byBhdm9pZCByYW5kb21seSBnZW5lcmF0ZWQgdmFsdWUgdG8gYmUgdXNlZCBhcyBhbiBhcHBsaWNhdGlvbiBpZCwgeW91IGNhbiBwcm92aWRlXG4gICAgICogYSBjdXN0b20gdmFsdWUgdmlhIGEgREkgcHJvdmlkZXIgPCEtLSBUT0RPOiBwcm92aWRlciAtLT4gY29uZmlndXJpbmcgdGhlIHJvb3Qge0BsaW5rIEluamVjdG9yfVxuICAgICAqIHVzaW5nIHRoaXMgdG9rZW4uXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBBUFBfSUQgPSBuZXcgT3BhcXVlVG9rZW4oJ0FwcElkJyk7XG4gICAgZnVuY3Rpb24gX2FwcElkUmFuZG9tUHJvdmlkZXJGYWN0b3J5KCkge1xuICAgICAgICByZXR1cm4gXCJcIiArIF9yYW5kb21DaGFyKCkgKyBfcmFuZG9tQ2hhcigpICsgX3JhbmRvbUNoYXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvdmlkZXJzIHRoYXQgd2lsbCBnZW5lcmF0ZSBhIHJhbmRvbSBBUFBfSURfVE9LRU4uXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBBUFBfSURfUkFORE9NX1BST1ZJREVSID0ge1xuICAgICAgICBwcm92aWRlOiBBUFBfSUQsXG4gICAgICAgIHVzZUZhY3Rvcnk6IF9hcHBJZFJhbmRvbVByb3ZpZGVyRmFjdG9yeSxcbiAgICAgICAgZGVwczogW10sXG4gICAgfTtcbiAgICBmdW5jdGlvbiBfcmFuZG9tQ2hhcigpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoOTcgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyNSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIGEgcGxhdGZvcm0gaXMgaW5pdGlhbGl6ZWQuXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBQTEFURk9STV9JTklUSUFMSVpFUiA9IG5ldyBPcGFxdWVUb2tlbignUGxhdGZvcm0gSW5pdGlhbGl6ZXInKTtcbiAgICAvKipcbiAgICAgKiBBbGwgY2FsbGJhY2tzIHByb3ZpZGVkIHZpYSB0aGlzIHRva2VuIHdpbGwgYmUgY2FsbGVkIGZvciBldmVyeSBjb21wb25lbnQgdGhhdCBpcyBib290c3RyYXBwZWQuXG4gICAgICogU2lnbmF0dXJlIG9mIHRoZSBjYWxsYmFjazpcbiAgICAgKlxuICAgICAqIGAoY29tcG9uZW50UmVmOiBDb21wb25lbnRSZWYpID0+IHZvaWRgLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBBUFBfQk9PVFNUUkFQX0xJU1RFTkVSID0gbmV3IE9wYXF1ZVRva2VuKCdhcHBCb290c3RyYXBMaXN0ZW5lcicpO1xuICAgIC8qKlxuICAgICAqIEEgdG9rZW4gd2hpY2ggaW5kaWNhdGVzIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGUgYXBwbGljYXRpb25cbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgdmFyIFBBQ0tBR0VfUk9PVF9VUkwgPSBuZXcgT3BhcXVlVG9rZW4oJ0FwcGxpY2F0aW9uIFBhY2thZ2VzIFJvb3QgVVJMJyk7XG5cbiAgICB2YXIgQ29uc29sZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIENvbnNvbGUoKSB7XG4gICAgICAgIH1cbiAgICAgICAgQ29uc29sZS5wcm90b3R5cGUubG9nID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHsgcHJpbnQobWVzc2FnZSk7IH07XG4gICAgICAgIC8vIE5vdGU6IGZvciByZXBvcnRpbmcgZXJyb3JzIHVzZSBgRE9NLmxvZ0Vycm9yKClgIGFzIGl0IGlzIHBsYXRmb3JtIHNwZWNpZmljXG4gICAgICAgIENvbnNvbGUucHJvdG90eXBlLndhcm4gPSBmdW5jdGlvbiAobWVzc2FnZSkgeyB3YXJuKG1lc3NhZ2UpOyB9O1xuICAgICAgICBDb25zb2xlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IEluamVjdGFibGUgfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIENvbnNvbGUuY3RvclBhcmFtZXRlcnMgPSBbXTtcbiAgICAgICAgcmV0dXJuIENvbnNvbGU7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDQgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgdGhhdCBhIGNvbXBvbmVudCBpcyBzdGlsbCBiZWluZyBsb2FkZWQgaW4gYSBzeW5jaHJvbm91cyBjb21waWxlLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBDb21wb25lbnRTdGlsbExvYWRpbmdFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQ0KENvbXBvbmVudFN0aWxsTG9hZGluZ0Vycm9yLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBDb21wb25lbnRTdGlsbExvYWRpbmdFcnJvcihjb21wVHlwZSkge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgXCJDYW4ndCBjb21waWxlIHN5bmNocm9ub3VzbHkgYXMgXCIgKyBzdHJpbmdpZnkoY29tcFR5cGUpICsgXCIgaXMgc3RpbGwgYmVpbmcgbG9hZGVkIVwiKTtcbiAgICAgICAgICAgIHRoaXMuY29tcFR5cGUgPSBjb21wVHlwZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ29tcG9uZW50U3RpbGxMb2FkaW5nRXJyb3I7XG4gICAgfShCYXNlRXJyb3IpKTtcbiAgICAvKipcbiAgICAgKiBDb21iaW5hdGlvbiBvZiBOZ01vZHVsZUZhY3RvcnkgYW5kIENvbXBvbmVudEZhY3RvcnlzLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBNb2R1bGVXaXRoQ29tcG9uZW50RmFjdG9yaWVzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTW9kdWxlV2l0aENvbXBvbmVudEZhY3RvcmllcyhuZ01vZHVsZUZhY3RvcnksIGNvbXBvbmVudEZhY3Rvcmllcykge1xuICAgICAgICAgICAgdGhpcy5uZ01vZHVsZUZhY3RvcnkgPSBuZ01vZHVsZUZhY3Rvcnk7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudEZhY3RvcmllcyA9IGNvbXBvbmVudEZhY3RvcmllcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTW9kdWxlV2l0aENvbXBvbmVudEZhY3RvcmllcztcbiAgICB9KCkpO1xuICAgIGZ1bmN0aW9uIF90aHJvd0Vycm9yKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSdW50aW1lIGNvbXBpbGVyIGlzIG5vdCBsb2FkZWRcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvdy1sZXZlbCBzZXJ2aWNlIGZvciBydW5uaW5nIHRoZSBhbmd1bGFyIGNvbXBpbGVyIGR1cmluZyBydW50aW1lXG4gICAgICogdG8gY3JlYXRlIHtAbGluayBDb21wb25lbnRGYWN0b3J5fXMsIHdoaWNoXG4gICAgICogY2FuIGxhdGVyIGJlIHVzZWQgdG8gY3JlYXRlIGFuZCByZW5kZXIgYSBDb21wb25lbnQgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBFYWNoIGBATmdNb2R1bGVgIHByb3ZpZGVzIGFuIG93biBgQ29tcGlsZXJgIHRvIGl0cyBpbmplY3RvcixcbiAgICAgKiB0aGF0IHdpbGwgdXNlIHRoZSBkaXJlY3RpdmVzL3BpcGVzIG9mIHRoZSBuZyBtb2R1bGUgZm9yIGNvbXBpbGF0aW9uXG4gICAgICogb2YgY29tcG9uZW50cy5cbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIENvbXBpbGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQ29tcGlsZXIoKSB7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbXBpbGVzIHRoZSBnaXZlbiBOZ01vZHVsZSBhbmQgYWxsIG9mIGl0cyBjb21wb25lbnRzLiBBbGwgdGVtcGxhdGVzIG9mIHRoZSBjb21wb25lbnRzIGxpc3RlZFxuICAgICAgICAgKiBpbiBgZW50cnlDb21wb25lbnRzYFxuICAgICAgICAgKiBoYXZlIHRvIGJlIGlubGluZWQuIE90aGVyd2lzZSB0aHJvd3MgYSB7QGxpbmsgQ29tcG9uZW50U3RpbGxMb2FkaW5nRXJyb3J9LlxuICAgICAgICAgKi9cbiAgICAgICAgQ29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGVNb2R1bGVTeW5jID0gZnVuY3Rpb24gKG1vZHVsZVR5cGUpIHsgdGhyb3cgX3Rocm93RXJyb3IoKTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbXBpbGVzIHRoZSBnaXZlbiBOZ01vZHVsZSBhbmQgYWxsIG9mIGl0cyBjb21wb25lbnRzXG4gICAgICAgICAqL1xuICAgICAgICBDb21waWxlci5wcm90b3R5cGUuY29tcGlsZU1vZHVsZUFzeW5jID0gZnVuY3Rpb24gKG1vZHVsZVR5cGUpIHsgdGhyb3cgX3Rocm93RXJyb3IoKTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNhbWUgYXMge0BsaW5rIGNvbXBpbGVNb2R1bGVTeW5jfSBidXQgYWxzbyBjcmVhdGVzIENvbXBvbmVudEZhY3RvcmllcyBmb3IgYWxsIGNvbXBvbmVudHMuXG4gICAgICAgICAqL1xuICAgICAgICBDb21waWxlci5wcm90b3R5cGUuY29tcGlsZU1vZHVsZUFuZEFsbENvbXBvbmVudHNTeW5jID0gZnVuY3Rpb24gKG1vZHVsZVR5cGUpIHtcbiAgICAgICAgICAgIHRocm93IF90aHJvd0Vycm9yKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTYW1lIGFzIHtAbGluayBjb21waWxlTW9kdWxlQXN5bmN9IGJ1dCBhbHNvIGNyZWF0ZXMgQ29tcG9uZW50RmFjdG9yaWVzIGZvciBhbGwgY29tcG9uZW50cy5cbiAgICAgICAgICovXG4gICAgICAgIENvbXBpbGVyLnByb3RvdHlwZS5jb21waWxlTW9kdWxlQW5kQWxsQ29tcG9uZW50c0FzeW5jID0gZnVuY3Rpb24gKG1vZHVsZVR5cGUpIHtcbiAgICAgICAgICAgIHRocm93IF90aHJvd0Vycm9yKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbGVhcnMgYWxsIGNhY2hlcy5cbiAgICAgICAgICovXG4gICAgICAgIENvbXBpbGVyLnByb3RvdHlwZS5jbGVhckNhY2hlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2xlYXJzIHRoZSBjYWNoZSBmb3IgdGhlIGdpdmVuIGNvbXBvbmVudC9uZ01vZHVsZS5cbiAgICAgICAgICovXG4gICAgICAgIENvbXBpbGVyLnByb3RvdHlwZS5jbGVhckNhY2hlRm9yID0gZnVuY3Rpb24gKHR5cGUpIHsgfTtcbiAgICAgICAgcmV0dXJuIENvbXBpbGVyO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogVG9rZW4gdG8gcHJvdmlkZSBDb21waWxlck9wdGlvbnMgaW4gdGhlIHBsYXRmb3JtIGluamVjdG9yLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBDT01QSUxFUl9PUFRJT05TID0gbmV3IE9wYXF1ZVRva2VuKCdjb21waWxlck9wdGlvbnMnKTtcbiAgICAvKipcbiAgICAgKiBBIGZhY3RvcnkgZm9yIGNyZWF0aW5nIGEgQ29tcGlsZXJcbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgQ29tcGlsZXJGYWN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQ29tcGlsZXJGYWN0b3J5KCkge1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBDb21waWxlckZhY3Rvcnk7XG4gICAgfSgpKTtcblxuICAgIHZhciBEZWZhdWx0SXRlcmFibGVEaWZmZXJGYWN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gRGVmYXVsdEl0ZXJhYmxlRGlmZmVyRmFjdG9yeSgpIHtcbiAgICAgICAgfVxuICAgICAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXJGYWN0b3J5LnByb3RvdHlwZS5zdXBwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIGlzTGlzdExpa2VJdGVyYWJsZShvYmopOyB9O1xuICAgICAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXJGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAoY2RSZWYsIHRyYWNrQnlGbikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZWZhdWx0SXRlcmFibGVEaWZmZXIodHJhY2tCeUZuKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIERlZmF1bHRJdGVyYWJsZURpZmZlckZhY3Rvcnk7XG4gICAgfSgpKTtcbiAgICB2YXIgdHJhY2tCeUlkZW50aXR5ID0gZnVuY3Rpb24gKGluZGV4LCBpdGVtKSB7IHJldHVybiBpdGVtOyB9O1xuICAgIC8qKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gRGVmYXVsdEl0ZXJhYmxlRGlmZmVyKF90cmFja0J5Rm4pIHtcbiAgICAgICAgICAgIHRoaXMuX3RyYWNrQnlGbiA9IF90cmFja0J5Rm47XG4gICAgICAgICAgICB0aGlzLl9sZW5ndGggPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fY29sbGVjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAvLyBLZWVwcyB0cmFjayBvZiB0aGUgdXNlZCByZWNvcmRzIGF0IGFueSBwb2ludCBpbiB0aW1lIChkdXJpbmcgJiBhY3Jvc3MgYF9jaGVjaygpYCBjYWxscylcbiAgICAgICAgICAgIHRoaXMuX2xpbmtlZFJlY29yZHMgPSBudWxsO1xuICAgICAgICAgICAgLy8gS2VlcHMgdHJhY2sgb2YgdGhlIHJlbW92ZWQgcmVjb3JkcyBhdCBhbnkgcG9pbnQgaW4gdGltZSBkdXJpbmcgYF9jaGVjaygpYCBjYWxscy5cbiAgICAgICAgICAgIHRoaXMuX3VubGlua2VkUmVjb3JkcyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9wcmV2aW91c0l0SGVhZCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9pdEhlYWQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5faXRUYWlsID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2FkZGl0aW9uc0hlYWQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fYWRkaXRpb25zVGFpbCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9tb3Zlc0hlYWQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fbW92ZXNUYWlsID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3JlbW92YWxzSGVhZCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdmFsc1RhaWwgPSBudWxsO1xuICAgICAgICAgICAgLy8gS2VlcHMgdHJhY2sgb2YgcmVjb3JkcyB3aGVyZSBjdXN0b20gdHJhY2sgYnkgaXMgdGhlIHNhbWUsIGJ1dCBpdGVtIGlkZW50aXR5IGhhcyBjaGFuZ2VkXG4gICAgICAgICAgICB0aGlzLl9pZGVudGl0eUNoYW5nZXNIZWFkID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2lkZW50aXR5Q2hhbmdlc1RhaWwgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fdHJhY2tCeUZuID0gdGhpcy5fdHJhY2tCeUZuIHx8IHRyYWNrQnlJZGVudGl0eTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZSwgXCJjb2xsZWN0aW9uXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY29sbGVjdGlvbjsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLCBcImxlbmd0aFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2xlbmd0aDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuZm9yRWFjaEl0ZW0gPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIHZhciByZWNvcmQ7XG4gICAgICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX2l0SGVhZDsgcmVjb3JkICE9PSBudWxsOyByZWNvcmQgPSByZWNvcmQuX25leHQpIHtcbiAgICAgICAgICAgICAgICBmbihyZWNvcmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLmZvckVhY2hPcGVyYXRpb24gPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIHZhciBuZXh0SXQgPSB0aGlzLl9pdEhlYWQ7XG4gICAgICAgICAgICB2YXIgbmV4dFJlbW92ZSA9IHRoaXMuX3JlbW92YWxzSGVhZDtcbiAgICAgICAgICAgIHZhciBhZGRSZW1vdmVPZmZzZXQgPSAwO1xuICAgICAgICAgICAgdmFyIG1vdmVPZmZzZXRzID0gbnVsbDtcbiAgICAgICAgICAgIHdoaWxlIChuZXh0SXQgfHwgbmV4dFJlbW92ZSkge1xuICAgICAgICAgICAgICAgIC8vIEZpZ3VyZSBvdXQgd2hpY2ggaXMgdGhlIG5leHQgcmVjb3JkIHRvIHByb2Nlc3NcbiAgICAgICAgICAgICAgICAvLyBPcmRlcjogcmVtb3ZlLCBhZGQsIG1vdmVcbiAgICAgICAgICAgICAgICB2YXIgcmVjb3JkID0gIW5leHRSZW1vdmUgfHxcbiAgICAgICAgICAgICAgICAgICAgbmV4dEl0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0SXQuY3VycmVudEluZGV4IDwgZ2V0UHJldmlvdXNJbmRleChuZXh0UmVtb3ZlLCBhZGRSZW1vdmVPZmZzZXQsIG1vdmVPZmZzZXRzKSA/XG4gICAgICAgICAgICAgICAgICAgIG5leHRJdCA6XG4gICAgICAgICAgICAgICAgICAgIG5leHRSZW1vdmU7XG4gICAgICAgICAgICAgICAgdmFyIGFkalByZXZpb3VzSW5kZXggPSBnZXRQcmV2aW91c0luZGV4KHJlY29yZCwgYWRkUmVtb3ZlT2Zmc2V0LCBtb3ZlT2Zmc2V0cyk7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRJbmRleCA9IHJlY29yZC5jdXJyZW50SW5kZXg7XG4gICAgICAgICAgICAgICAgLy8gY29uc3VtZSB0aGUgaXRlbSwgYW5kIGFkanVzdCB0aGUgYWRkUmVtb3ZlT2Zmc2V0IGFuZCB1cGRhdGUgbW92ZURpc3RhbmNlIGlmIG5lY2Vzc2FyeVxuICAgICAgICAgICAgICAgIGlmIChyZWNvcmQgPT09IG5leHRSZW1vdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkUmVtb3ZlT2Zmc2V0LS07XG4gICAgICAgICAgICAgICAgICAgIG5leHRSZW1vdmUgPSBuZXh0UmVtb3ZlLl9uZXh0UmVtb3ZlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRJdCA9IG5leHRJdC5fbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY29yZC5wcmV2aW91c0luZGV4ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZFJlbW92ZU9mZnNldCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSU5WQVJJQU5UOiAgY3VycmVudEluZGV4IDwgcHJldmlvdXNJbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtb3ZlT2Zmc2V0cylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3ZlT2Zmc2V0cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxvY2FsTW92ZVByZXZpb3VzSW5kZXggPSBhZGpQcmV2aW91c0luZGV4IC0gYWRkUmVtb3ZlT2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxvY2FsQ3VycmVudEluZGV4ID0gY3VycmVudEluZGV4IC0gYWRkUmVtb3ZlT2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsTW92ZVByZXZpb3VzSW5kZXggIT0gbG9jYWxDdXJyZW50SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvY2FsTW92ZVByZXZpb3VzSW5kZXg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gaSA8IG1vdmVPZmZzZXRzLmxlbmd0aCA/IG1vdmVPZmZzZXRzW2ldIDogKG1vdmVPZmZzZXRzW2ldID0gMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IG9mZnNldCArIGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2NhbEN1cnJlbnRJbmRleCA8PSBpbmRleCAmJiBpbmRleCA8IGxvY2FsTW92ZVByZXZpb3VzSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVPZmZzZXRzW2ldID0gb2Zmc2V0ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNJbmRleCA9IHJlY29yZC5wcmV2aW91c0luZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVPZmZzZXRzW3ByZXZpb3VzSW5kZXhdID0gbG9jYWxDdXJyZW50SW5kZXggLSBsb2NhbE1vdmVQcmV2aW91c0luZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhZGpQcmV2aW91c0luZGV4ICE9PSBjdXJyZW50SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgZm4ocmVjb3JkLCBhZGpQcmV2aW91c0luZGV4LCBjdXJyZW50SW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZS5mb3JFYWNoUHJldmlvdXNJdGVtID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICB2YXIgcmVjb3JkO1xuICAgICAgICAgICAgZm9yIChyZWNvcmQgPSB0aGlzLl9wcmV2aW91c0l0SGVhZDsgcmVjb3JkICE9PSBudWxsOyByZWNvcmQgPSByZWNvcmQuX25leHRQcmV2aW91cykge1xuICAgICAgICAgICAgICAgIGZuKHJlY29yZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuZm9yRWFjaEFkZGVkSXRlbSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgdmFyIHJlY29yZDtcbiAgICAgICAgICAgIGZvciAocmVjb3JkID0gdGhpcy5fYWRkaXRpb25zSGVhZDsgcmVjb3JkICE9PSBudWxsOyByZWNvcmQgPSByZWNvcmQuX25leHRBZGRlZCkge1xuICAgICAgICAgICAgICAgIGZuKHJlY29yZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuZm9yRWFjaE1vdmVkSXRlbSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgdmFyIHJlY29yZDtcbiAgICAgICAgICAgIGZvciAocmVjb3JkID0gdGhpcy5fbW92ZXNIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dE1vdmVkKSB7XG4gICAgICAgICAgICAgICAgZm4ocmVjb3JkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZS5mb3JFYWNoUmVtb3ZlZEl0ZW0gPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIHZhciByZWNvcmQ7XG4gICAgICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX3JlbW92YWxzSGVhZDsgcmVjb3JkICE9PSBudWxsOyByZWNvcmQgPSByZWNvcmQuX25leHRSZW1vdmVkKSB7XG4gICAgICAgICAgICAgICAgZm4ocmVjb3JkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZS5mb3JFYWNoSWRlbnRpdHlDaGFuZ2UgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIHZhciByZWNvcmQ7XG4gICAgICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX2lkZW50aXR5Q2hhbmdlc0hlYWQ7IHJlY29yZCAhPT0gbnVsbDsgcmVjb3JkID0gcmVjb3JkLl9uZXh0SWRlbnRpdHlDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICBmbihyZWNvcmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLmRpZmYgPSBmdW5jdGlvbiAoY29sbGVjdGlvbikge1xuICAgICAgICAgICAgaWYgKGlzQmxhbmsoY29sbGVjdGlvbikpXG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbiA9IFtdO1xuICAgICAgICAgICAgaWYgKCFpc0xpc3RMaWtlSXRlcmFibGUoY29sbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciB0cnlpbmcgdG8gZGlmZiAnXCIgKyBjb2xsZWN0aW9uICsgXCInXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY2hlY2soY29sbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLm9uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgLy8gdG9kbyh2aWNiKTogb3B0aW0gZm9yIFVubW9kaWZpYWJsZUxpc3RWaWV3IChmcm96ZW4gYXJyYXlzKVxuICAgICAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLmNoZWNrID0gZnVuY3Rpb24gKGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLl9yZXNldCgpO1xuICAgICAgICAgICAgdmFyIHJlY29yZCA9IHRoaXMuX2l0SGVhZDtcbiAgICAgICAgICAgIHZhciBtYXlCZURpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgaW5kZXg7XG4gICAgICAgICAgICB2YXIgaXRlbTtcbiAgICAgICAgICAgIHZhciBpdGVtVHJhY2tCeTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpc3QgPSBjb2xsZWN0aW9uO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGluZGV4XzEgPSAwOyBpbmRleF8xIDwgdGhpcy5fbGVuZ3RoOyBpbmRleF8xKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbSA9IGxpc3RbaW5kZXhfMV07XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1UcmFja0J5ID0gdGhpcy5fdHJhY2tCeUZuKGluZGV4XzEsIGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVjb3JkID09PSBudWxsIHx8ICFsb29zZUlkZW50aWNhbChyZWNvcmQudHJhY2tCeUlkLCBpdGVtVHJhY2tCeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY29yZCA9IHRoaXMuX21pc21hdGNoKHJlY29yZCwgaXRlbSwgaXRlbVRyYWNrQnksIGluZGV4XzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF5QmVEaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF5QmVEaXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8obWlza28pOiBjYW4gd2UgbGltaXQgdGhpcyB0byBkdXBsaWNhdGVzIG9ubHk/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3JkID0gdGhpcy5fdmVyaWZ5UmVpbnNlcnRpb24ocmVjb3JkLCBpdGVtLCBpdGVtVHJhY2tCeSwgaW5kZXhfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWxvb3NlSWRlbnRpY2FsKHJlY29yZC5pdGVtLCBpdGVtKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRJZGVudGl0eUNoYW5nZShyZWNvcmQsIGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlY29yZCA9IHJlY29yZC5fbmV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgaXRlcmF0ZUxpc3RMaWtlKGNvbGxlY3Rpb24sIGZ1bmN0aW9uIChpdGVtIC8qKiBUT0RPICM5MTAwICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1UcmFja0J5ID0gX3RoaXMuX3RyYWNrQnlGbihpbmRleCwgaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWNvcmQgPT09IG51bGwgfHwgIWxvb3NlSWRlbnRpY2FsKHJlY29yZC50cmFja0J5SWQsIGl0ZW1UcmFja0J5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3JkID0gX3RoaXMuX21pc21hdGNoKHJlY29yZCwgaXRlbSwgaXRlbVRyYWNrQnksIGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heUJlRGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1heUJlRGlydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPKG1pc2tvKTogY2FuIHdlIGxpbWl0IHRoaXMgdG8gZHVwbGljYXRlcyBvbmx5P1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY29yZCA9IF90aGlzLl92ZXJpZnlSZWluc2VydGlvbihyZWNvcmQsIGl0ZW0sIGl0ZW1UcmFja0J5LCBpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWxvb3NlSWRlbnRpY2FsKHJlY29yZC5pdGVtLCBpdGVtKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYWRkSWRlbnRpdHlDaGFuZ2UocmVjb3JkLCBpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZWNvcmQgPSByZWNvcmQuX25leHQ7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGVuZ3RoID0gaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl90cnVuY2F0ZShyZWNvcmQpO1xuICAgICAgICAgICAgdGhpcy5fY29sbGVjdGlvbiA9IGNvbGxlY3Rpb247XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc0RpcnR5O1xuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZSwgXCJpc0RpcnR5XCIsIHtcbiAgICAgICAgICAgIC8qIENvbGxlY3Rpb25DaGFuZ2VzIGlzIGNvbnNpZGVyZWQgZGlydHkgaWYgaXQgaGFzIGFueSBhZGRpdGlvbnMsIG1vdmVzLCByZW1vdmFscywgb3IgaWRlbnRpdHlcbiAgICAgICAgICAgICAqIGNoYW5nZXMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9hZGRpdGlvbnNIZWFkICE9PSBudWxsIHx8IHRoaXMuX21vdmVzSGVhZCAhPT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmFsc0hlYWQgIT09IG51bGwgfHwgdGhpcy5faWRlbnRpdHlDaGFuZ2VzSGVhZCAhPT0gbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVzZXQgdGhlIHN0YXRlIG9mIHRoZSBjaGFuZ2Ugb2JqZWN0cyB0byBzaG93IG5vIGNoYW5nZXMuIFRoaXMgbWVhbnMgc2V0IHByZXZpb3VzS2V5IHRvXG4gICAgICAgICAqIGN1cnJlbnRLZXksIGFuZCBjbGVhciBhbGwgb2YgdGhlIHF1ZXVlcyAoYWRkaXRpb25zLCBtb3ZlcywgcmVtb3ZhbHMpLlxuICAgICAgICAgKiBTZXQgdGhlIHByZXZpb3VzSW5kZXhlcyBvZiBtb3ZlZCBhbmQgYWRkZWQgaXRlbXMgdG8gdGhlaXIgY3VycmVudEluZGV4ZXNcbiAgICAgICAgICogUmVzZXQgdGhlIGxpc3Qgb2YgYWRkaXRpb25zLCBtb3ZlcyBhbmQgcmVtb3ZhbHNcbiAgICAgICAgICpcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLl9yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRGlydHkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVjb3JkO1xuICAgICAgICAgICAgICAgIHZhciBuZXh0UmVjb3JkO1xuICAgICAgICAgICAgICAgIGZvciAocmVjb3JkID0gdGhpcy5fcHJldmlvdXNJdEhlYWQgPSB0aGlzLl9pdEhlYWQ7IHJlY29yZCAhPT0gbnVsbDsgcmVjb3JkID0gcmVjb3JkLl9uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY29yZC5fbmV4dFByZXZpb3VzID0gcmVjb3JkLl9uZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX2FkZGl0aW9uc0hlYWQ7IHJlY29yZCAhPT0gbnVsbDsgcmVjb3JkID0gcmVjb3JkLl9uZXh0QWRkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkLnByZXZpb3VzSW5kZXggPSByZWNvcmQuY3VycmVudEluZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRpdGlvbnNIZWFkID0gdGhpcy5fYWRkaXRpb25zVGFpbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgZm9yIChyZWNvcmQgPSB0aGlzLl9tb3Zlc0hlYWQ7IHJlY29yZCAhPT0gbnVsbDsgcmVjb3JkID0gbmV4dFJlY29yZCkge1xuICAgICAgICAgICAgICAgICAgICByZWNvcmQucHJldmlvdXNJbmRleCA9IHJlY29yZC5jdXJyZW50SW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIG5leHRSZWNvcmQgPSByZWNvcmQuX25leHRNb3ZlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fbW92ZXNIZWFkID0gdGhpcy5fbW92ZXNUYWlsID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmFsc0hlYWQgPSB0aGlzLl9yZW1vdmFsc1RhaWwgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuX2lkZW50aXR5Q2hhbmdlc0hlYWQgPSB0aGlzLl9pZGVudGl0eUNoYW5nZXNUYWlsID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgaXMgdGhlIGNvcmUgZnVuY3Rpb24gd2hpY2ggaGFuZGxlcyBkaWZmZXJlbmNlcyBiZXR3ZWVuIGNvbGxlY3Rpb25zLlxuICAgICAgICAgKlxuICAgICAgICAgKiAtIGByZWNvcmRgIGlzIHRoZSByZWNvcmQgd2hpY2ggd2Ugc2F3IGF0IHRoaXMgcG9zaXRpb24gbGFzdCB0aW1lLiBJZiBudWxsIHRoZW4gaXQgaXMgYSBuZXdcbiAgICAgICAgICogICBpdGVtLlxuICAgICAgICAgKiAtIGBpdGVtYCBpcyB0aGUgY3VycmVudCBpdGVtIGluIHRoZSBjb2xsZWN0aW9uXG4gICAgICAgICAqIC0gYGluZGV4YCBpcyB0aGUgcG9zaXRpb24gb2YgdGhlIGl0ZW0gaW4gdGhlIGNvbGxlY3Rpb25cbiAgICAgICAgICpcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLl9taXNtYXRjaCA9IGZ1bmN0aW9uIChyZWNvcmQsIGl0ZW0sIGl0ZW1UcmFja0J5LCBpbmRleCkge1xuICAgICAgICAgICAgLy8gVGhlIHByZXZpb3VzIHJlY29yZCBhZnRlciB3aGljaCB3ZSB3aWxsIGFwcGVuZCB0aGUgY3VycmVudCBvbmUuXG4gICAgICAgICAgICB2YXIgcHJldmlvdXNSZWNvcmQ7XG4gICAgICAgICAgICBpZiAocmVjb3JkID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNSZWNvcmQgPSB0aGlzLl9pdFRhaWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcmV2aW91c1JlY29yZCA9IHJlY29yZC5fcHJldjtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIHJlY29yZCBmcm9tIHRoZSBjb2xsZWN0aW9uIHNpbmNlIHdlIGtub3cgaXQgZG9lcyBub3QgbWF0Y2ggdGhlIGl0ZW0uXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlKHJlY29yZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBdHRlbXB0IHRvIHNlZSBpZiB3ZSBoYXZlIHNlZW4gdGhlIGl0ZW0gYmVmb3JlLlxuICAgICAgICAgICAgcmVjb3JkID0gdGhpcy5fbGlua2VkUmVjb3JkcyA9PT0gbnVsbCA/IG51bGwgOiB0aGlzLl9saW5rZWRSZWNvcmRzLmdldChpdGVtVHJhY2tCeSwgaW5kZXgpO1xuICAgICAgICAgICAgaWYgKHJlY29yZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgc2VlbiB0aGlzIGJlZm9yZSwgd2UgbmVlZCB0byBtb3ZlIGl0IGZvcndhcmQgaW4gdGhlIGNvbGxlY3Rpb24uXG4gICAgICAgICAgICAgICAgLy8gQnV0IGZpcnN0IHdlIG5lZWQgdG8gY2hlY2sgaWYgaWRlbnRpdHkgY2hhbmdlZCwgc28gd2UgY2FuIHVwZGF0ZSBpbiB2aWV3IGlmIG5lY2Vzc2FyeVxuICAgICAgICAgICAgICAgIGlmICghbG9vc2VJZGVudGljYWwocmVjb3JkLml0ZW0sIGl0ZW0pKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRJZGVudGl0eUNoYW5nZShyZWNvcmQsIGl0ZW0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX21vdmVBZnRlcihyZWNvcmQsIHByZXZpb3VzUmVjb3JkLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBOZXZlciBzZWVuIGl0LCBjaGVjayBldmljdGVkIGxpc3QuXG4gICAgICAgICAgICAgICAgcmVjb3JkID0gdGhpcy5fdW5saW5rZWRSZWNvcmRzID09PSBudWxsID8gbnVsbCA6IHRoaXMuX3VubGlua2VkUmVjb3Jkcy5nZXQoaXRlbVRyYWNrQnkpO1xuICAgICAgICAgICAgICAgIGlmIChyZWNvcmQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSXQgaXMgYW4gaXRlbSB3aGljaCB3ZSBoYXZlIGV2aWN0ZWQgZWFybGllcjogcmVpbnNlcnQgaXQgYmFjayBpbnRvIHRoZSBsaXN0LlxuICAgICAgICAgICAgICAgICAgICAvLyBCdXQgZmlyc3Qgd2UgbmVlZCB0byBjaGVjayBpZiBpZGVudGl0eSBjaGFuZ2VkLCBzbyB3ZSBjYW4gdXBkYXRlIGluIHZpZXcgaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgICAgICAgICAgIGlmICghbG9vc2VJZGVudGljYWwocmVjb3JkLml0ZW0sIGl0ZW0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkSWRlbnRpdHlDaGFuZ2UocmVjb3JkLCBpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVpbnNlcnRBZnRlcihyZWNvcmQsIHByZXZpb3VzUmVjb3JkLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBJdCBpcyBhIG5ldyBpdGVtOiBhZGQgaXQuXG4gICAgICAgICAgICAgICAgICAgIHJlY29yZCA9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRBZnRlcihuZXcgQ29sbGVjdGlvbkNoYW5nZVJlY29yZChpdGVtLCBpdGVtVHJhY2tCeSksIHByZXZpb3VzUmVjb3JkLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlY29yZDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgY2hlY2sgaXMgb25seSBuZWVkZWQgaWYgYW4gYXJyYXkgY29udGFpbnMgZHVwbGljYXRlcy4gKFNob3J0IGNpcmN1aXQgb2Ygbm90aGluZyBkaXJ0eSlcbiAgICAgICAgICpcbiAgICAgICAgICogVXNlIGNhc2U6IGBbYSwgYV1gID0+IGBbYiwgYSwgYV1gXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIHdlIGRpZCBub3QgaGF2ZSB0aGlzIGNoZWNrIHRoZW4gdGhlIGluc2VydGlvbiBvZiBgYmAgd291bGQ6XG4gICAgICAgICAqICAgMSkgZXZpY3QgZmlyc3QgYGFgXG4gICAgICAgICAqICAgMikgaW5zZXJ0IGBiYCBhdCBgMGAgaW5kZXguXG4gICAgICAgICAqICAgMykgbGVhdmUgYGFgIGF0IGluZGV4IGAxYCBhcyBpcy4gPC0tIHRoaXMgaXMgd3JvbmchXG4gICAgICAgICAqICAgMykgcmVpbnNlcnQgYGFgIGF0IGluZGV4IDIuIDwtLSB0aGlzIGlzIHdyb25nIVxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgY29ycmVjdCBiZWhhdmlvciBpczpcbiAgICAgICAgICogICAxKSBldmljdCBmaXJzdCBgYWBcbiAgICAgICAgICogICAyKSBpbnNlcnQgYGJgIGF0IGAwYCBpbmRleC5cbiAgICAgICAgICogICAzKSByZWluc2VydCBgYWAgYXQgaW5kZXggMS5cbiAgICAgICAgICogICAzKSBtb3ZlIGBhYCBhdCBmcm9tIGAxYCB0byBgMmAuXG4gICAgICAgICAqXG4gICAgICAgICAqXG4gICAgICAgICAqIERvdWJsZSBjaGVjayB0aGF0IHdlIGhhdmUgbm90IGV2aWN0ZWQgYSBkdXBsaWNhdGUgaXRlbS4gV2UgbmVlZCB0byBjaGVjayBpZiB0aGUgaXRlbSB0eXBlIG1heVxuICAgICAgICAgKiBoYXZlIGFscmVhZHkgYmVlbiByZW1vdmVkOlxuICAgICAgICAgKiBUaGUgaW5zZXJ0aW9uIG9mIGIgd2lsbCBldmljdCB0aGUgZmlyc3QgJ2EnLiBJZiB3ZSBkb24ndCByZWluc2VydCBpdCBub3cgaXQgd2lsbCBiZSByZWluc2VydGVkXG4gICAgICAgICAqIGF0IHRoZSBlbmQuIFdoaWNoIHdpbGwgc2hvdyB1cCBhcyB0aGUgdHdvICdhJ3Mgc3dpdGNoaW5nIHBvc2l0aW9uLiBUaGlzIGlzIGluY29ycmVjdCwgc2luY2UgYVxuICAgICAgICAgKiBiZXR0ZXIgd2F5IHRvIHRoaW5rIG9mIGl0IGlzIGFzIGluc2VydCBvZiAnYicgcmF0aGVyIHRoZW4gc3dpdGNoICdhJyB3aXRoICdiJyBhbmQgdGhlbiBhZGQgJ2EnXG4gICAgICAgICAqIGF0IHRoZSBlbmQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZS5fdmVyaWZ5UmVpbnNlcnRpb24gPSBmdW5jdGlvbiAocmVjb3JkLCBpdGVtLCBpdGVtVHJhY2tCeSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciByZWluc2VydFJlY29yZCA9IHRoaXMuX3VubGlua2VkUmVjb3JkcyA9PT0gbnVsbCA/IG51bGwgOiB0aGlzLl91bmxpbmtlZFJlY29yZHMuZ2V0KGl0ZW1UcmFja0J5KTtcbiAgICAgICAgICAgIGlmIChyZWluc2VydFJlY29yZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlY29yZCA9IHRoaXMuX3JlaW5zZXJ0QWZ0ZXIocmVpbnNlcnRSZWNvcmQsIHJlY29yZC5fcHJldiwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVjb3JkLmN1cnJlbnRJbmRleCAhPSBpbmRleCkge1xuICAgICAgICAgICAgICAgIHJlY29yZC5jdXJyZW50SW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRUb01vdmVzKHJlY29yZCwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlY29yZDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCByaWQgb2YgYW55IGV4Y2VzcyB7QGxpbmsgQ29sbGVjdGlvbkNoYW5nZVJlY29yZH1zIGZyb20gdGhlIHByZXZpb3VzIGNvbGxlY3Rpb25cbiAgICAgICAgICpcbiAgICAgICAgICogLSBgcmVjb3JkYCBUaGUgZmlyc3QgZXhjZXNzIHtAbGluayBDb2xsZWN0aW9uQ2hhbmdlUmVjb3JkfS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLl90cnVuY2F0ZSA9IGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgICAgIC8vIEFueXRoaW5nIGFmdGVyIHRoYXQgbmVlZHMgdG8gYmUgcmVtb3ZlZDtcbiAgICAgICAgICAgIHdoaWxlIChyZWNvcmQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dFJlY29yZCA9IHJlY29yZC5fbmV4dDtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRUb1JlbW92YWxzKHRoaXMuX3VubGluayhyZWNvcmQpKTtcbiAgICAgICAgICAgICAgICByZWNvcmQgPSBuZXh0UmVjb3JkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3VubGlua2VkUmVjb3JkcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VubGlua2VkUmVjb3Jkcy5jbGVhcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX2FkZGl0aW9uc1RhaWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRpdGlvbnNUYWlsLl9uZXh0QWRkZWQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX21vdmVzVGFpbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21vdmVzVGFpbC5fbmV4dE1vdmVkID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9pdFRhaWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pdFRhaWwuX25leHQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3JlbW92YWxzVGFpbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92YWxzVGFpbC5fbmV4dFJlbW92ZWQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX2lkZW50aXR5Q2hhbmdlc1RhaWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pZGVudGl0eUNoYW5nZXNUYWlsLl9uZXh0SWRlbnRpdHlDaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuX3JlaW5zZXJ0QWZ0ZXIgPSBmdW5jdGlvbiAocmVjb3JkLCBwcmV2UmVjb3JkLCBpbmRleCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3VubGlua2VkUmVjb3JkcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VubGlua2VkUmVjb3Jkcy5yZW1vdmUocmVjb3JkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwcmV2ID0gcmVjb3JkLl9wcmV2UmVtb3ZlZDtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gcmVjb3JkLl9uZXh0UmVtb3ZlZDtcbiAgICAgICAgICAgIGlmIChwcmV2ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZhbHNIZWFkID0gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHByZXYuX25leHRSZW1vdmVkID0gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZhbHNUYWlsID0gcHJldjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5leHQuX3ByZXZSZW1vdmVkID0gcHJldjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2luc2VydEFmdGVyKHJlY29yZCwgcHJldlJlY29yZCwgaW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5fYWRkVG9Nb3ZlcyhyZWNvcmQsIGluZGV4KTtcbiAgICAgICAgICAgIHJldHVybiByZWNvcmQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZS5fbW92ZUFmdGVyID0gZnVuY3Rpb24gKHJlY29yZCwgcHJldlJlY29yZCwgaW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMuX3VubGluayhyZWNvcmQpO1xuICAgICAgICAgICAgdGhpcy5faW5zZXJ0QWZ0ZXIocmVjb3JkLCBwcmV2UmVjb3JkLCBpbmRleCk7XG4gICAgICAgICAgICB0aGlzLl9hZGRUb01vdmVzKHJlY29yZCwgaW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlY29yZDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLl9hZGRBZnRlciA9IGZ1bmN0aW9uIChyZWNvcmQsIHByZXZSZWNvcmQsIGluZGV4KSB7XG4gICAgICAgICAgICB0aGlzLl9pbnNlcnRBZnRlcihyZWNvcmQsIHByZXZSZWNvcmQsIGluZGV4KTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9hZGRpdGlvbnNUYWlsID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gdG9kbyh2aWNiKVxuICAgICAgICAgICAgICAgIC8vIGFzc2VydCh0aGlzLl9hZGRpdGlvbnNIZWFkID09PSBudWxsKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRpdGlvbnNUYWlsID0gdGhpcy5fYWRkaXRpb25zSGVhZCA9IHJlY29yZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHRvZG8odmljYilcbiAgICAgICAgICAgICAgICAvLyBhc3NlcnQoX2FkZGl0aW9uc1RhaWwuX25leHRBZGRlZCA9PT0gbnVsbCk7XG4gICAgICAgICAgICAgICAgLy8gYXNzZXJ0KHJlY29yZC5fbmV4dEFkZGVkID09PSBudWxsKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRpdGlvbnNUYWlsID0gdGhpcy5fYWRkaXRpb25zVGFpbC5fbmV4dEFkZGVkID0gcmVjb3JkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlY29yZDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLl9pbnNlcnRBZnRlciA9IGZ1bmN0aW9uIChyZWNvcmQsIHByZXZSZWNvcmQsIGluZGV4KSB7XG4gICAgICAgICAgICAvLyB0b2RvKHZpY2IpXG4gICAgICAgICAgICAvLyBhc3NlcnQocmVjb3JkICE9IHByZXZSZWNvcmQpO1xuICAgICAgICAgICAgLy8gYXNzZXJ0KHJlY29yZC5fbmV4dCA9PT0gbnVsbCk7XG4gICAgICAgICAgICAvLyBhc3NlcnQocmVjb3JkLl9wcmV2ID09PSBudWxsKTtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gcHJldlJlY29yZCA9PT0gbnVsbCA/IHRoaXMuX2l0SGVhZCA6IHByZXZSZWNvcmQuX25leHQ7XG4gICAgICAgICAgICAvLyB0b2RvKHZpY2IpXG4gICAgICAgICAgICAvLyBhc3NlcnQobmV4dCAhPSByZWNvcmQpO1xuICAgICAgICAgICAgLy8gYXNzZXJ0KHByZXZSZWNvcmQgIT0gcmVjb3JkKTtcbiAgICAgICAgICAgIHJlY29yZC5fbmV4dCA9IG5leHQ7XG4gICAgICAgICAgICByZWNvcmQuX3ByZXYgPSBwcmV2UmVjb3JkO1xuICAgICAgICAgICAgaWYgKG5leHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pdFRhaWwgPSByZWNvcmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXh0Ll9wcmV2ID0gcmVjb3JkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByZXZSZWNvcmQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pdEhlYWQgPSByZWNvcmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcmV2UmVjb3JkLl9uZXh0ID0gcmVjb3JkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX2xpbmtlZFJlY29yZHMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9saW5rZWRSZWNvcmRzID0gbmV3IF9EdXBsaWNhdGVNYXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2xpbmtlZFJlY29yZHMucHV0KHJlY29yZCk7XG4gICAgICAgICAgICByZWNvcmQuY3VycmVudEluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICByZXR1cm4gcmVjb3JkO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuX3JlbW92ZSA9IGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hZGRUb1JlbW92YWxzKHRoaXMuX3VubGluayhyZWNvcmQpKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLl91bmxpbmsgPSBmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbGlua2VkUmVjb3JkcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xpbmtlZFJlY29yZHMucmVtb3ZlKHJlY29yZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcHJldiA9IHJlY29yZC5fcHJldjtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gcmVjb3JkLl9uZXh0O1xuICAgICAgICAgICAgLy8gdG9kbyh2aWNiKVxuICAgICAgICAgICAgLy8gYXNzZXJ0KChyZWNvcmQuX3ByZXYgPSBudWxsKSA9PT0gbnVsbCk7XG4gICAgICAgICAgICAvLyBhc3NlcnQoKHJlY29yZC5fbmV4dCA9IG51bGwpID09PSBudWxsKTtcbiAgICAgICAgICAgIGlmIChwcmV2ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faXRIZWFkID0gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHByZXYuX25leHQgPSBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5leHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pdFRhaWwgPSBwcmV2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV4dC5fcHJldiA9IHByZXY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVjb3JkO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuX2FkZFRvTW92ZXMgPSBmdW5jdGlvbiAocmVjb3JkLCB0b0luZGV4KSB7XG4gICAgICAgICAgICAvLyB0b2RvKHZpY2IpXG4gICAgICAgICAgICAvLyBhc3NlcnQocmVjb3JkLl9uZXh0TW92ZWQgPT09IG51bGwpO1xuICAgICAgICAgICAgaWYgKHJlY29yZC5wcmV2aW91c0luZGV4ID09PSB0b0luZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY29yZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9tb3Zlc1RhaWwgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyB0b2RvKHZpY2IpXG4gICAgICAgICAgICAgICAgLy8gYXNzZXJ0KF9tb3Zlc0hlYWQgPT09IG51bGwpO1xuICAgICAgICAgICAgICAgIHRoaXMuX21vdmVzVGFpbCA9IHRoaXMuX21vdmVzSGVhZCA9IHJlY29yZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHRvZG8odmljYilcbiAgICAgICAgICAgICAgICAvLyBhc3NlcnQoX21vdmVzVGFpbC5fbmV4dE1vdmVkID09PSBudWxsKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb3Zlc1RhaWwgPSB0aGlzLl9tb3Zlc1RhaWwuX25leHRNb3ZlZCA9IHJlY29yZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZWNvcmQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZS5fYWRkVG9SZW1vdmFscyA9IGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl91bmxpbmtlZFJlY29yZHMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91bmxpbmtlZFJlY29yZHMgPSBuZXcgX0R1cGxpY2F0ZU1hcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fdW5saW5rZWRSZWNvcmRzLnB1dChyZWNvcmQpO1xuICAgICAgICAgICAgcmVjb3JkLmN1cnJlbnRJbmRleCA9IG51bGw7XG4gICAgICAgICAgICByZWNvcmQuX25leHRSZW1vdmVkID0gbnVsbDtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yZW1vdmFsc1RhaWwgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyB0b2RvKHZpY2IpXG4gICAgICAgICAgICAgICAgLy8gYXNzZXJ0KF9yZW1vdmFsc0hlYWQgPT09IG51bGwpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92YWxzVGFpbCA9IHRoaXMuX3JlbW92YWxzSGVhZCA9IHJlY29yZDtcbiAgICAgICAgICAgICAgICByZWNvcmQuX3ByZXZSZW1vdmVkID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHRvZG8odmljYilcbiAgICAgICAgICAgICAgICAvLyBhc3NlcnQoX3JlbW92YWxzVGFpbC5fbmV4dFJlbW92ZWQgPT09IG51bGwpO1xuICAgICAgICAgICAgICAgIC8vIGFzc2VydChyZWNvcmQuX25leHRSZW1vdmVkID09PSBudWxsKTtcbiAgICAgICAgICAgICAgICByZWNvcmQuX3ByZXZSZW1vdmVkID0gdGhpcy5fcmVtb3ZhbHNUYWlsO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92YWxzVGFpbCA9IHRoaXMuX3JlbW92YWxzVGFpbC5fbmV4dFJlbW92ZWQgPSByZWNvcmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVjb3JkO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuX2FkZElkZW50aXR5Q2hhbmdlID0gZnVuY3Rpb24gKHJlY29yZCwgaXRlbSkge1xuICAgICAgICAgICAgcmVjb3JkLml0ZW0gPSBpdGVtO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lkZW50aXR5Q2hhbmdlc1RhaWwgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pZGVudGl0eUNoYW5nZXNUYWlsID0gdGhpcy5faWRlbnRpdHlDaGFuZ2VzSGVhZCA9IHJlY29yZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2lkZW50aXR5Q2hhbmdlc1RhaWwgPSB0aGlzLl9pZGVudGl0eUNoYW5nZXNUYWlsLl9uZXh0SWRlbnRpdHlDaGFuZ2UgPSByZWNvcmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVjb3JkO1xuICAgICAgICB9O1xuICAgICAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGxpc3QgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuZm9yRWFjaEl0ZW0oZnVuY3Rpb24gKHJlY29yZCAvKiogVE9ETyAjOTEwMCAqLykgeyByZXR1cm4gbGlzdC5wdXNoKHJlY29yZCk7IH0pO1xuICAgICAgICAgICAgdmFyIHByZXZpb3VzID0gW107XG4gICAgICAgICAgICB0aGlzLmZvckVhY2hQcmV2aW91c0l0ZW0oZnVuY3Rpb24gKHJlY29yZCAvKiogVE9ETyAjOTEwMCAqLykgeyByZXR1cm4gcHJldmlvdXMucHVzaChyZWNvcmQpOyB9KTtcbiAgICAgICAgICAgIHZhciBhZGRpdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuZm9yRWFjaEFkZGVkSXRlbShmdW5jdGlvbiAocmVjb3JkIC8qKiBUT0RPICM5MTAwICovKSB7IHJldHVybiBhZGRpdGlvbnMucHVzaChyZWNvcmQpOyB9KTtcbiAgICAgICAgICAgIHZhciBtb3ZlcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5mb3JFYWNoTW92ZWRJdGVtKGZ1bmN0aW9uIChyZWNvcmQgLyoqIFRPRE8gIzkxMDAgKi8pIHsgcmV0dXJuIG1vdmVzLnB1c2gocmVjb3JkKTsgfSk7XG4gICAgICAgICAgICB2YXIgcmVtb3ZhbHMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuZm9yRWFjaFJlbW92ZWRJdGVtKGZ1bmN0aW9uIChyZWNvcmQgLyoqIFRPRE8gIzkxMDAgKi8pIHsgcmV0dXJuIHJlbW92YWxzLnB1c2gocmVjb3JkKTsgfSk7XG4gICAgICAgICAgICB2YXIgaWRlbnRpdHlDaGFuZ2VzID0gW107XG4gICAgICAgICAgICB0aGlzLmZvckVhY2hJZGVudGl0eUNoYW5nZShmdW5jdGlvbiAocmVjb3JkIC8qKiBUT0RPICM5MTAwICovKSB7IHJldHVybiBpZGVudGl0eUNoYW5nZXMucHVzaChyZWNvcmQpOyB9KTtcbiAgICAgICAgICAgIHJldHVybiAnY29sbGVjdGlvbjogJyArIGxpc3Quam9pbignLCAnKSArICdcXG4nICtcbiAgICAgICAgICAgICAgICAncHJldmlvdXM6ICcgKyBwcmV2aW91cy5qb2luKCcsICcpICsgJ1xcbicgK1xuICAgICAgICAgICAgICAgICdhZGRpdGlvbnM6ICcgKyBhZGRpdGlvbnMuam9pbignLCAnKSArICdcXG4nICtcbiAgICAgICAgICAgICAgICAnbW92ZXM6ICcgKyBtb3Zlcy5qb2luKCcsICcpICsgJ1xcbicgK1xuICAgICAgICAgICAgICAgICdyZW1vdmFsczogJyArIHJlbW92YWxzLmpvaW4oJywgJykgKyAnXFxuJyArXG4gICAgICAgICAgICAgICAgJ2lkZW50aXR5Q2hhbmdlczogJyArIGlkZW50aXR5Q2hhbmdlcy5qb2luKCcsICcpICsgJ1xcbic7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBEZWZhdWx0SXRlcmFibGVEaWZmZXI7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIENvbGxlY3Rpb25DaGFuZ2VSZWNvcmQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBDb2xsZWN0aW9uQ2hhbmdlUmVjb3JkKGl0ZW0sIHRyYWNrQnlJZCkge1xuICAgICAgICAgICAgdGhpcy5pdGVtID0gaXRlbTtcbiAgICAgICAgICAgIHRoaXMudHJhY2tCeUlkID0gdHJhY2tCeUlkO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50SW5kZXggPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5wcmV2aW91c0luZGV4ID0gbnVsbDtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX25leHRQcmV2aW91cyA9IG51bGw7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9wcmV2ID0gbnVsbDtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX25leHQgPSBudWxsO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fcHJldkR1cCA9IG51bGw7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9uZXh0RHVwID0gbnVsbDtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX3ByZXZSZW1vdmVkID0gbnVsbDtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX25leHRSZW1vdmVkID0gbnVsbDtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX25leHRBZGRlZCA9IG51bGw7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9uZXh0TW92ZWQgPSBudWxsO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fbmV4dElkZW50aXR5Q2hhbmdlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBDb2xsZWN0aW9uQ2hhbmdlUmVjb3JkLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByZXZpb3VzSW5kZXggPT09IHRoaXMuY3VycmVudEluZGV4ID8gc3RyaW5naWZ5KHRoaXMuaXRlbSkgOlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSh0aGlzLml0ZW0pICsgJ1snICtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5naWZ5KHRoaXMucHJldmlvdXNJbmRleCkgKyAnLT4nICsgc3RyaW5naWZ5KHRoaXMuY3VycmVudEluZGV4KSArICddJztcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIENvbGxlY3Rpb25DaGFuZ2VSZWNvcmQ7XG4gICAgfSgpKTtcbiAgICAvLyBBIGxpbmtlZCBsaXN0IG9mIENvbGxlY3Rpb25DaGFuZ2VSZWNvcmRzIHdpdGggdGhlIHNhbWUgQ29sbGVjdGlvbkNoYW5nZVJlY29yZC5pdGVtXG4gICAgdmFyIF9EdXBsaWNhdGVJdGVtUmVjb3JkTGlzdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIF9EdXBsaWNhdGVJdGVtUmVjb3JkTGlzdCgpIHtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX2hlYWQgPSBudWxsO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fdGFpbCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFwcGVuZCB0aGUgcmVjb3JkIHRvIHRoZSBsaXN0IG9mIGR1cGxpY2F0ZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIE5vdGU6IGJ5IGRlc2lnbiBhbGwgcmVjb3JkcyBpbiB0aGUgbGlzdCBvZiBkdXBsaWNhdGVzIGhvbGQgdGhlIHNhbWUgdmFsdWUgaW4gcmVjb3JkLml0ZW0uXG4gICAgICAgICAqL1xuICAgICAgICBfRHVwbGljYXRlSXRlbVJlY29yZExpc3QucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9oZWFkID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faGVhZCA9IHRoaXMuX3RhaWwgPSByZWNvcmQ7XG4gICAgICAgICAgICAgICAgcmVjb3JkLl9uZXh0RHVwID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZWNvcmQuX3ByZXZEdXAgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdG9kbyh2aWNiKVxuICAgICAgICAgICAgICAgIC8vIGFzc2VydChyZWNvcmQuaXRlbSA9PSAgX2hlYWQuaXRlbSB8fFxuICAgICAgICAgICAgICAgIC8vICAgICAgIHJlY29yZC5pdGVtIGlzIG51bSAmJiByZWNvcmQuaXRlbS5pc05hTiAmJiBfaGVhZC5pdGVtIGlzIG51bSAmJiBfaGVhZC5pdGVtLmlzTmFOKTtcbiAgICAgICAgICAgICAgICB0aGlzLl90YWlsLl9uZXh0RHVwID0gcmVjb3JkO1xuICAgICAgICAgICAgICAgIHJlY29yZC5fcHJldkR1cCA9IHRoaXMuX3RhaWw7XG4gICAgICAgICAgICAgICAgcmVjb3JkLl9uZXh0RHVwID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLl90YWlsID0gcmVjb3JkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBSZXR1cm5zIGEgQ29sbGVjdGlvbkNoYW5nZVJlY29yZCBoYXZpbmcgQ29sbGVjdGlvbkNoYW5nZVJlY29yZC50cmFja0J5SWQgPT0gdHJhY2tCeUlkIGFuZFxuICAgICAgICAvLyBDb2xsZWN0aW9uQ2hhbmdlUmVjb3JkLmN1cnJlbnRJbmRleCA+PSBhZnRlckluZGV4XG4gICAgICAgIF9EdXBsaWNhdGVJdGVtUmVjb3JkTGlzdC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHRyYWNrQnlJZCwgYWZ0ZXJJbmRleCkge1xuICAgICAgICAgICAgdmFyIHJlY29yZDtcbiAgICAgICAgICAgIGZvciAocmVjb3JkID0gdGhpcy5faGVhZDsgcmVjb3JkICE9PSBudWxsOyByZWNvcmQgPSByZWNvcmQuX25leHREdXApIHtcbiAgICAgICAgICAgICAgICBpZiAoKGFmdGVySW5kZXggPT09IG51bGwgfHwgYWZ0ZXJJbmRleCA8IHJlY29yZC5jdXJyZW50SW5kZXgpICYmXG4gICAgICAgICAgICAgICAgICAgIGxvb3NlSWRlbnRpY2FsKHJlY29yZC50cmFja0J5SWQsIHRyYWNrQnlJZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlY29yZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZSBvbmUge0BsaW5rIENvbGxlY3Rpb25DaGFuZ2VSZWNvcmR9IGZyb20gdGhlIGxpc3Qgb2YgZHVwbGljYXRlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBsaXN0IG9mIGR1cGxpY2F0ZXMgaXMgZW1wdHkuXG4gICAgICAgICAqL1xuICAgICAgICBfRHVwbGljYXRlSXRlbVJlY29yZExpc3QucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgICAgIC8vIHRvZG8odmljYilcbiAgICAgICAgICAgIC8vIGFzc2VydCgoKSB7XG4gICAgICAgICAgICAvLyAgLy8gdmVyaWZ5IHRoYXQgdGhlIHJlY29yZCBiZWluZyByZW1vdmVkIGlzIGluIHRoZSBsaXN0LlxuICAgICAgICAgICAgLy8gIGZvciAoQ29sbGVjdGlvbkNoYW5nZVJlY29yZCBjdXJzb3IgPSBfaGVhZDsgY3Vyc29yICE9IG51bGw7IGN1cnNvciA9IGN1cnNvci5fbmV4dER1cCkge1xuICAgICAgICAgICAgLy8gICAgaWYgKGlkZW50aWNhbChjdXJzb3IsIHJlY29yZCkpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgLy8gIH1cbiAgICAgICAgICAgIC8vICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAvL30pO1xuICAgICAgICAgICAgdmFyIHByZXYgPSByZWNvcmQuX3ByZXZEdXA7XG4gICAgICAgICAgICB2YXIgbmV4dCA9IHJlY29yZC5fbmV4dER1cDtcbiAgICAgICAgICAgIGlmIChwcmV2ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faGVhZCA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcmV2Ll9uZXh0RHVwID0gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGFpbCA9IHByZXY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXh0Ll9wcmV2RHVwID0gcHJldjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9oZWFkID09PSBudWxsO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX0R1cGxpY2F0ZUl0ZW1SZWNvcmRMaXN0O1xuICAgIH0oKSk7XG4gICAgdmFyIF9EdXBsaWNhdGVNYXAgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBfRHVwbGljYXRlTWFwKCkge1xuICAgICAgICAgICAgdGhpcy5tYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIH1cbiAgICAgICAgX0R1cGxpY2F0ZU1hcC5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgICAgICAgdmFyIGtleSA9IHJlY29yZC50cmFja0J5SWQ7XG4gICAgICAgICAgICB2YXIgZHVwbGljYXRlcyA9IHRoaXMubWFwLmdldChrZXkpO1xuICAgICAgICAgICAgaWYgKCFkdXBsaWNhdGVzKSB7XG4gICAgICAgICAgICAgICAgZHVwbGljYXRlcyA9IG5ldyBfRHVwbGljYXRlSXRlbVJlY29yZExpc3QoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1hcC5zZXQoa2V5LCBkdXBsaWNhdGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGR1cGxpY2F0ZXMuYWRkKHJlY29yZCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXRyaWV2ZSB0aGUgYHZhbHVlYCB1c2luZyBrZXkuIEJlY2F1c2UgdGhlIENvbGxlY3Rpb25DaGFuZ2VSZWNvcmQgdmFsdWUgbWF5IGJlIG9uZSB3aGljaCB3ZVxuICAgICAgICAgKiBoYXZlIGFscmVhZHkgaXRlcmF0ZWQgb3Zlciwgd2UgdXNlIHRoZSBhZnRlckluZGV4IHRvIHByZXRlbmQgaXQgaXMgbm90IHRoZXJlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBVc2UgY2FzZTogYFthLCBiLCBjLCBhLCBhXWAgaWYgd2UgYXJlIGF0IGluZGV4IGAzYCB3aGljaCBpcyB0aGUgc2Vjb25kIGBhYCB0aGVuIGFza2luZyBpZiB3ZVxuICAgICAgICAgKiBoYXZlIGFueSBtb3JlIGBhYHMgbmVlZHMgdG8gcmV0dXJuIHRoZSBsYXN0IGBhYCBub3QgdGhlIGZpcnN0IG9yIHNlY29uZC5cbiAgICAgICAgICovXG4gICAgICAgIF9EdXBsaWNhdGVNYXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh0cmFja0J5SWQsIGFmdGVySW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChhZnRlckluZGV4ID09PSB2b2lkIDApIHsgYWZ0ZXJJbmRleCA9IG51bGw7IH1cbiAgICAgICAgICAgIHZhciBrZXkgPSB0cmFja0J5SWQ7XG4gICAgICAgICAgICB2YXIgcmVjb3JkTGlzdCA9IHRoaXMubWFwLmdldChrZXkpO1xuICAgICAgICAgICAgcmV0dXJuIHJlY29yZExpc3QgPyByZWNvcmRMaXN0LmdldCh0cmFja0J5SWQsIGFmdGVySW5kZXgpIDogbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZXMgYSB7QGxpbmsgQ29sbGVjdGlvbkNoYW5nZVJlY29yZH0gZnJvbSB0aGUgbGlzdCBvZiBkdXBsaWNhdGVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgbGlzdCBvZiBkdXBsaWNhdGVzIGFsc28gaXMgcmVtb3ZlZCBmcm9tIHRoZSBtYXAgaWYgaXQgZ2V0cyBlbXB0eS5cbiAgICAgICAgICovXG4gICAgICAgIF9EdXBsaWNhdGVNYXAucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSByZWNvcmQudHJhY2tCeUlkO1xuICAgICAgICAgICAgdmFyIHJlY29yZExpc3QgPSB0aGlzLm1hcC5nZXQoa2V5KTtcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgbGlzdCBvZiBkdXBsaWNhdGVzIHdoZW4gaXQgZ2V0cyBlbXB0eVxuICAgICAgICAgICAgaWYgKHJlY29yZExpc3QucmVtb3ZlKHJlY29yZCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hcC5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZWNvcmQ7XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfRHVwbGljYXRlTWFwLnByb3RvdHlwZSwgXCJpc0VtcHR5XCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5tYXAuc2l6ZSA9PT0gMDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIF9EdXBsaWNhdGVNYXAucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkgeyB0aGlzLm1hcC5jbGVhcigpOyB9O1xuICAgICAgICBfRHVwbGljYXRlTWFwLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdfRHVwbGljYXRlTWFwKCcgKyBzdHJpbmdpZnkodGhpcy5tYXApICsgJyknOyB9O1xuICAgICAgICByZXR1cm4gX0R1cGxpY2F0ZU1hcDtcbiAgICB9KCkpO1xuICAgIGZ1bmN0aW9uIGdldFByZXZpb3VzSW5kZXgoaXRlbSwgYWRkUmVtb3ZlT2Zmc2V0LCBtb3ZlT2Zmc2V0cykge1xuICAgICAgICB2YXIgcHJldmlvdXNJbmRleCA9IGl0ZW0ucHJldmlvdXNJbmRleDtcbiAgICAgICAgaWYgKHByZXZpb3VzSW5kZXggPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gcHJldmlvdXNJbmRleDtcbiAgICAgICAgdmFyIG1vdmVPZmZzZXQgPSAwO1xuICAgICAgICBpZiAobW92ZU9mZnNldHMgJiYgcHJldmlvdXNJbmRleCA8IG1vdmVPZmZzZXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgbW92ZU9mZnNldCA9IG1vdmVPZmZzZXRzW3ByZXZpb3VzSW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcmV2aW91c0luZGV4ICsgYWRkUmVtb3ZlT2Zmc2V0ICsgbW92ZU9mZnNldDtcbiAgICB9XG5cbiAgICB2YXIgRGVmYXVsdEtleVZhbHVlRGlmZmVyRmFjdG9yeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIERlZmF1bHRLZXlWYWx1ZURpZmZlckZhY3RvcnkoKSB7XG4gICAgICAgIH1cbiAgICAgICAgRGVmYXVsdEtleVZhbHVlRGlmZmVyRmFjdG9yeS5wcm90b3R5cGUuc3VwcG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogaW5zdGFuY2VvZiBNYXAgfHwgaXNKc09iamVjdChvYmopOyB9O1xuICAgICAgICBEZWZhdWx0S2V5VmFsdWVEaWZmZXJGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAoY2RSZWYpIHsgcmV0dXJuIG5ldyBEZWZhdWx0S2V5VmFsdWVEaWZmZXIoKTsgfTtcbiAgICAgICAgcmV0dXJuIERlZmF1bHRLZXlWYWx1ZURpZmZlckZhY3Rvcnk7XG4gICAgfSgpKTtcbiAgICB2YXIgRGVmYXVsdEtleVZhbHVlRGlmZmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gRGVmYXVsdEtleVZhbHVlRGlmZmVyKCkge1xuICAgICAgICAgICAgdGhpcy5fcmVjb3JkcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHRoaXMuX21hcEhlYWQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fcHJldmlvdXNNYXBIZWFkID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZXNIZWFkID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZXNUYWlsID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2FkZGl0aW9uc0hlYWQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fYWRkaXRpb25zVGFpbCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdmFsc0hlYWQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fcmVtb3ZhbHNUYWlsID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVmYXVsdEtleVZhbHVlRGlmZmVyLnByb3RvdHlwZSwgXCJpc0RpcnR5XCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9hZGRpdGlvbnNIZWFkICE9PSBudWxsIHx8IHRoaXMuX2NoYW5nZXNIZWFkICE9PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92YWxzSGVhZCAhPT0gbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBEZWZhdWx0S2V5VmFsdWVEaWZmZXIucHJvdG90eXBlLmZvckVhY2hJdGVtID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICB2YXIgcmVjb3JkO1xuICAgICAgICAgICAgZm9yIChyZWNvcmQgPSB0aGlzLl9tYXBIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dCkge1xuICAgICAgICAgICAgICAgIGZuKHJlY29yZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIERlZmF1bHRLZXlWYWx1ZURpZmZlci5wcm90b3R5cGUuZm9yRWFjaFByZXZpb3VzSXRlbSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgdmFyIHJlY29yZDtcbiAgICAgICAgICAgIGZvciAocmVjb3JkID0gdGhpcy5fcHJldmlvdXNNYXBIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dFByZXZpb3VzKSB7XG4gICAgICAgICAgICAgICAgZm4ocmVjb3JkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRGVmYXVsdEtleVZhbHVlRGlmZmVyLnByb3RvdHlwZS5mb3JFYWNoQ2hhbmdlZEl0ZW0gPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIHZhciByZWNvcmQ7XG4gICAgICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX2NoYW5nZXNIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dENoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICBmbihyZWNvcmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBEZWZhdWx0S2V5VmFsdWVEaWZmZXIucHJvdG90eXBlLmZvckVhY2hBZGRlZEl0ZW0gPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIHZhciByZWNvcmQ7XG4gICAgICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX2FkZGl0aW9uc0hlYWQ7IHJlY29yZCAhPT0gbnVsbDsgcmVjb3JkID0gcmVjb3JkLl9uZXh0QWRkZWQpIHtcbiAgICAgICAgICAgICAgICBmbihyZWNvcmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBEZWZhdWx0S2V5VmFsdWVEaWZmZXIucHJvdG90eXBlLmZvckVhY2hSZW1vdmVkSXRlbSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgdmFyIHJlY29yZDtcbiAgICAgICAgICAgIGZvciAocmVjb3JkID0gdGhpcy5fcmVtb3ZhbHNIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dFJlbW92ZWQpIHtcbiAgICAgICAgICAgICAgICBmbihyZWNvcmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBEZWZhdWx0S2V5VmFsdWVEaWZmZXIucHJvdG90eXBlLmRpZmYgPSBmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgICAgICBpZiAoIW1hcCkge1xuICAgICAgICAgICAgICAgIG1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCEobWFwIGluc3RhbmNlb2YgTWFwIHx8IGlzSnNPYmplY3QobWFwKSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciB0cnlpbmcgdG8gZGlmZiAnXCIgKyBtYXAgKyBcIidcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGVjayhtYXApID8gdGhpcyA6IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIERlZmF1bHRLZXlWYWx1ZURpZmZlci5wcm90b3R5cGUub25EZXN0cm95ID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICBEZWZhdWx0S2V5VmFsdWVEaWZmZXIucHJvdG90eXBlLmNoZWNrID0gZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuX3Jlc2V0KCk7XG4gICAgICAgICAgICB2YXIgcmVjb3JkcyA9IHRoaXMuX3JlY29yZHM7XG4gICAgICAgICAgICB2YXIgb2xkU2VxUmVjb3JkID0gdGhpcy5fbWFwSGVhZDtcbiAgICAgICAgICAgIHZhciBsYXN0T2xkU2VxUmVjb3JkID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBsYXN0TmV3U2VxUmVjb3JkID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBzZXFDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9mb3JFYWNoKG1hcCwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3U2VxUmVjb3JkO1xuICAgICAgICAgICAgICAgIGlmIChvbGRTZXFSZWNvcmQgJiYga2V5ID09PSBvbGRTZXFSZWNvcmQua2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1NlcVJlY29yZCA9IG9sZFNlcVJlY29yZDtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX21heWJlQWRkVG9DaGFuZ2VzKG5ld1NlcVJlY29yZCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VxQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvbGRTZXFSZWNvcmQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZW1vdmVGcm9tU2VxKGxhc3RPbGRTZXFSZWNvcmQsIG9sZFNlcVJlY29yZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYWRkVG9SZW1vdmFscyhvbGRTZXFSZWNvcmQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWNvcmRzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdTZXFSZWNvcmQgPSByZWNvcmRzLmdldChrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX21heWJlQWRkVG9DaGFuZ2VzKG5ld1NlcVJlY29yZCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3U2VxUmVjb3JkID0gbmV3IEtleVZhbHVlQ2hhbmdlUmVjb3JkKGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWNvcmRzLnNldChrZXksIG5ld1NlcVJlY29yZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdTZXFSZWNvcmQuY3VycmVudFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYWRkVG9BZGRpdGlvbnMobmV3U2VxUmVjb3JkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VxQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX2lzSW5SZW1vdmFscyhuZXdTZXFSZWNvcmQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVtb3ZlRnJvbVJlbW92YWxzKG5ld1NlcVJlY29yZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3ROZXdTZXFSZWNvcmQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX21hcEhlYWQgPSBuZXdTZXFSZWNvcmQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0TmV3U2VxUmVjb3JkLl9uZXh0ID0gbmV3U2VxUmVjb3JkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhc3RPbGRTZXFSZWNvcmQgPSBvbGRTZXFSZWNvcmQ7XG4gICAgICAgICAgICAgICAgbGFzdE5ld1NlcVJlY29yZCA9IG5ld1NlcVJlY29yZDtcbiAgICAgICAgICAgICAgICBvbGRTZXFSZWNvcmQgPSBvbGRTZXFSZWNvcmQgJiYgb2xkU2VxUmVjb3JkLl9uZXh0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl90cnVuY2F0ZShsYXN0T2xkU2VxUmVjb3JkLCBvbGRTZXFSZWNvcmQpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNEaXJ0eTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBEZWZhdWx0S2V5VmFsdWVEaWZmZXIucHJvdG90eXBlLl9yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRGlydHkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVjb3JkID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIC8vIFJlY29yZCB0aGUgc3RhdGUgb2YgdGhlIG1hcHBpbmdcbiAgICAgICAgICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX3ByZXZpb3VzTWFwSGVhZCA9IHRoaXMuX21hcEhlYWQ7IHJlY29yZCAhPT0gbnVsbDsgcmVjb3JkID0gcmVjb3JkLl9uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY29yZC5fbmV4dFByZXZpb3VzID0gcmVjb3JkLl9uZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX2NoYW5nZXNIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dENoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkLnByZXZpb3VzVmFsdWUgPSByZWNvcmQuY3VycmVudFZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX2FkZGl0aW9uc0hlYWQ7IHJlY29yZCAhPSBudWxsOyByZWNvcmQgPSByZWNvcmQuX25leHRBZGRlZCkge1xuICAgICAgICAgICAgICAgICAgICByZWNvcmQucHJldmlvdXNWYWx1ZSA9IHJlY29yZC5jdXJyZW50VmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZXNIZWFkID0gdGhpcy5fY2hhbmdlc1RhaWwgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZGl0aW9uc0hlYWQgPSB0aGlzLl9hZGRpdGlvbnNUYWlsID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmFsc0hlYWQgPSB0aGlzLl9yZW1vdmFsc1RhaWwgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIERlZmF1bHRLZXlWYWx1ZURpZmZlci5wcm90b3R5cGUuX3RydW5jYXRlID0gZnVuY3Rpb24gKGxhc3RSZWNvcmQsIHJlY29yZCkge1xuICAgICAgICAgICAgd2hpbGUgKHJlY29yZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChsYXN0UmVjb3JkID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21hcEhlYWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFJlY29yZC5fbmV4dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBuZXh0UmVjb3JkID0gcmVjb3JkLl9uZXh0O1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZFRvUmVtb3ZhbHMocmVjb3JkKTtcbiAgICAgICAgICAgICAgICBsYXN0UmVjb3JkID0gcmVjb3JkO1xuICAgICAgICAgICAgICAgIHJlY29yZCA9IG5leHRSZWNvcmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciByZWMgPSB0aGlzLl9yZW1vdmFsc0hlYWQ7IHJlYyAhPT0gbnVsbDsgcmVjID0gcmVjLl9uZXh0UmVtb3ZlZCkge1xuICAgICAgICAgICAgICAgIHJlYy5wcmV2aW91c1ZhbHVlID0gcmVjLmN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgICAgICByZWMuY3VycmVudFZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWNvcmRzLmRlbGV0ZShyZWMua2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRGVmYXVsdEtleVZhbHVlRGlmZmVyLnByb3RvdHlwZS5fbWF5YmVBZGRUb0NoYW5nZXMgPSBmdW5jdGlvbiAocmVjb3JkLCBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKCFsb29zZUlkZW50aWNhbChuZXdWYWx1ZSwgcmVjb3JkLmN1cnJlbnRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZWNvcmQucHJldmlvdXNWYWx1ZSA9IHJlY29yZC5jdXJyZW50VmFsdWU7XG4gICAgICAgICAgICAgICAgcmVjb3JkLmN1cnJlbnRWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZFRvQ2hhbmdlcyhyZWNvcmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIERlZmF1bHRLZXlWYWx1ZURpZmZlci5wcm90b3R5cGUuX2lzSW5SZW1vdmFscyA9IGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgICAgIHJldHVybiByZWNvcmQgPT09IHRoaXMuX3JlbW92YWxzSGVhZCB8fCByZWNvcmQuX25leHRSZW1vdmVkICE9PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgcmVjb3JkLl9wcmV2UmVtb3ZlZCAhPT0gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBEZWZhdWx0S2V5VmFsdWVEaWZmZXIucHJvdG90eXBlLl9hZGRUb1JlbW92YWxzID0gZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3JlbW92YWxzSGVhZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92YWxzSGVhZCA9IHRoaXMuX3JlbW92YWxzVGFpbCA9IHJlY29yZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92YWxzVGFpbC5fbmV4dFJlbW92ZWQgPSByZWNvcmQ7XG4gICAgICAgICAgICAgICAgcmVjb3JkLl9wcmV2UmVtb3ZlZCA9IHRoaXMuX3JlbW92YWxzVGFpbDtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmFsc1RhaWwgPSByZWNvcmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRGVmYXVsdEtleVZhbHVlRGlmZmVyLnByb3RvdHlwZS5fcmVtb3ZlRnJvbVNlcSA9IGZ1bmN0aW9uIChwcmV2LCByZWNvcmQpIHtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gcmVjb3JkLl9uZXh0O1xuICAgICAgICAgICAgaWYgKHByZXYgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXBIZWFkID0gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHByZXYuX25leHQgPSBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVjb3JkLl9uZXh0ID0gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBEZWZhdWx0S2V5VmFsdWVEaWZmZXIucHJvdG90eXBlLl9yZW1vdmVGcm9tUmVtb3ZhbHMgPSBmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgICB2YXIgcHJldiA9IHJlY29yZC5fcHJldlJlbW92ZWQ7XG4gICAgICAgICAgICB2YXIgbmV4dCA9IHJlY29yZC5fbmV4dFJlbW92ZWQ7XG4gICAgICAgICAgICBpZiAocHJldiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92YWxzSGVhZCA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcmV2Ll9uZXh0UmVtb3ZlZCA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV4dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92YWxzVGFpbCA9IHByZXY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXh0Ll9wcmV2UmVtb3ZlZCA9IHByZXY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWNvcmQuX3ByZXZSZW1vdmVkID0gcmVjb3JkLl9uZXh0UmVtb3ZlZCA9IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRGVmYXVsdEtleVZhbHVlRGlmZmVyLnByb3RvdHlwZS5fYWRkVG9BZGRpdGlvbnMgPSBmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fYWRkaXRpb25zSGVhZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZGl0aW9uc0hlYWQgPSB0aGlzLl9hZGRpdGlvbnNUYWlsID0gcmVjb3JkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkaXRpb25zVGFpbC5fbmV4dEFkZGVkID0gcmVjb3JkO1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZGl0aW9uc1RhaWwgPSByZWNvcmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRGVmYXVsdEtleVZhbHVlRGlmZmVyLnByb3RvdHlwZS5fYWRkVG9DaGFuZ2VzID0gZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2NoYW5nZXNIZWFkID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlc0hlYWQgPSB0aGlzLl9jaGFuZ2VzVGFpbCA9IHJlY29yZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZXNUYWlsLl9uZXh0Q2hhbmdlZCA9IHJlY29yZDtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VzVGFpbCA9IHJlY29yZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRGVmYXVsdEtleVZhbHVlRGlmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpdGVtcyA9IFtdO1xuICAgICAgICAgICAgdmFyIHByZXZpb3VzID0gW107XG4gICAgICAgICAgICB2YXIgY2hhbmdlcyA9IFtdO1xuICAgICAgICAgICAgdmFyIGFkZGl0aW9ucyA9IFtdO1xuICAgICAgICAgICAgdmFyIHJlbW92YWxzID0gW107XG4gICAgICAgICAgICB2YXIgcmVjb3JkO1xuICAgICAgICAgICAgZm9yIChyZWNvcmQgPSB0aGlzLl9tYXBIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dCkge1xuICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goc3RyaW5naWZ5KHJlY29yZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChyZWNvcmQgPSB0aGlzLl9wcmV2aW91c01hcEhlYWQ7IHJlY29yZCAhPT0gbnVsbDsgcmVjb3JkID0gcmVjb3JkLl9uZXh0UHJldmlvdXMpIHtcbiAgICAgICAgICAgICAgICBwcmV2aW91cy5wdXNoKHN0cmluZ2lmeShyZWNvcmQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAocmVjb3JkID0gdGhpcy5fY2hhbmdlc0hlYWQ7IHJlY29yZCAhPT0gbnVsbDsgcmVjb3JkID0gcmVjb3JkLl9uZXh0Q2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaChzdHJpbmdpZnkocmVjb3JkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX2FkZGl0aW9uc0hlYWQ7IHJlY29yZCAhPT0gbnVsbDsgcmVjb3JkID0gcmVjb3JkLl9uZXh0QWRkZWQpIHtcbiAgICAgICAgICAgICAgICBhZGRpdGlvbnMucHVzaChzdHJpbmdpZnkocmVjb3JkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX3JlbW92YWxzSGVhZDsgcmVjb3JkICE9PSBudWxsOyByZWNvcmQgPSByZWNvcmQuX25leHRSZW1vdmVkKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZhbHMucHVzaChzdHJpbmdpZnkocmVjb3JkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJ21hcDogJyArIGl0ZW1zLmpvaW4oJywgJykgKyAnXFxuJyArXG4gICAgICAgICAgICAgICAgJ3ByZXZpb3VzOiAnICsgcHJldmlvdXMuam9pbignLCAnKSArICdcXG4nICtcbiAgICAgICAgICAgICAgICAnYWRkaXRpb25zOiAnICsgYWRkaXRpb25zLmpvaW4oJywgJykgKyAnXFxuJyArXG4gICAgICAgICAgICAgICAgJ2NoYW5nZXM6ICcgKyBjaGFuZ2VzLmpvaW4oJywgJykgKyAnXFxuJyArXG4gICAgICAgICAgICAgICAgJ3JlbW92YWxzOiAnICsgcmVtb3ZhbHMuam9pbignLCAnKSArICdcXG4nO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIERlZmF1bHRLZXlWYWx1ZURpZmZlci5wcm90b3R5cGUuX2ZvckVhY2ggPSBmdW5jdGlvbiAob2JqLCBmbikge1xuICAgICAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICAgICAgICAgIG9iai5mb3JFYWNoKGZuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChmdW5jdGlvbiAoaykgeyByZXR1cm4gZm4ob2JqW2tdLCBrKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBEZWZhdWx0S2V5VmFsdWVEaWZmZXI7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEtleVZhbHVlQ2hhbmdlUmVjb3JkID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gS2V5VmFsdWVDaGFuZ2VSZWNvcmQoa2V5KSB7XG4gICAgICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXNWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9uZXh0UHJldmlvdXMgPSBudWxsO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fbmV4dCA9IG51bGw7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9uZXh0QWRkZWQgPSBudWxsO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fbmV4dFJlbW92ZWQgPSBudWxsO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fcHJldlJlbW92ZWQgPSBudWxsO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fbmV4dENoYW5nZWQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIEtleVZhbHVlQ2hhbmdlUmVjb3JkLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBsb29zZUlkZW50aWNhbCh0aGlzLnByZXZpb3VzVmFsdWUsIHRoaXMuY3VycmVudFZhbHVlKSA/XG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KHRoaXMua2V5KSA6XG4gICAgICAgICAgICAgICAgKHN0cmluZ2lmeSh0aGlzLmtleSkgKyAnWycgKyBzdHJpbmdpZnkodGhpcy5wcmV2aW91c1ZhbHVlKSArICctPicgK1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmdpZnkodGhpcy5jdXJyZW50VmFsdWUpICsgJ10nKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEtleVZhbHVlQ2hhbmdlUmVjb3JkO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBBIHJlcG9zaXRvcnkgb2YgZGlmZmVyZW50IGl0ZXJhYmxlIGRpZmZpbmcgc3RyYXRlZ2llcyB1c2VkIGJ5IE5nRm9yLCBOZ0NsYXNzLCBhbmQgb3RoZXJzLlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgSXRlcmFibGVEaWZmZXJzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gSXRlcmFibGVEaWZmZXJzKGZhY3Rvcmllcykge1xuICAgICAgICAgICAgdGhpcy5mYWN0b3JpZXMgPSBmYWN0b3JpZXM7XG4gICAgICAgIH1cbiAgICAgICAgSXRlcmFibGVEaWZmZXJzLmNyZWF0ZSA9IGZ1bmN0aW9uIChmYWN0b3JpZXMsIHBhcmVudCkge1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChwYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvcGllZCA9IExpc3RXcmFwcGVyLmNsb25lKHBhcmVudC5mYWN0b3JpZXMpO1xuICAgICAgICAgICAgICAgIGZhY3RvcmllcyA9IGZhY3Rvcmllcy5jb25jYXQoY29waWVkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEl0ZXJhYmxlRGlmZmVycyhmYWN0b3JpZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJdGVyYWJsZURpZmZlcnMoZmFjdG9yaWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRha2VzIGFuIGFycmF5IG9mIHtAbGluayBJdGVyYWJsZURpZmZlckZhY3Rvcnl9IGFuZCByZXR1cm5zIGEgcHJvdmlkZXIgdXNlZCB0byBleHRlbmQgdGhlXG4gICAgICAgICAqIGluaGVyaXRlZCB7QGxpbmsgSXRlcmFibGVEaWZmZXJzfSBpbnN0YW5jZSB3aXRoIHRoZSBwcm92aWRlZCBmYWN0b3JpZXMgYW5kIHJldHVybiBhIG5ld1xuICAgICAgICAgKiB7QGxpbmsgSXRlcmFibGVEaWZmZXJzfSBpbnN0YW5jZS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGZvbGxvd2luZyBleGFtcGxlIHNob3dzIGhvdyB0byBleHRlbmQgYW4gZXhpc3RpbmcgbGlzdCBvZiBmYWN0b3JpZXMsXG4gICAgICAgICAgICAgICAqIHdoaWNoIHdpbGwgb25seSBiZSBhcHBsaWVkIHRvIHRoZSBpbmplY3RvciBmb3IgdGhpcyBjb21wb25lbnQgYW5kIGl0cyBjaGlsZHJlbi5cbiAgICAgICAgICAgICAgICogVGhpcyBzdGVwIGlzIGFsbCB0aGF0J3MgcmVxdWlyZWQgdG8gbWFrZSBhIG5ldyB7QGxpbmsgSXRlcmFibGVEaWZmZXJ9IGF2YWlsYWJsZS5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIEV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqIEBDb21wb25lbnQoe1xuICAgICAgICAgKiAgIHZpZXdQcm92aWRlcnM6IFtcbiAgICAgICAgICogICAgIEl0ZXJhYmxlRGlmZmVycy5leHRlbmQoW25ldyBJbW11dGFibGVMaXN0RGlmZmVyKCldKVxuICAgICAgICAgKiAgIF1cbiAgICAgICAgICogfSlcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICBJdGVyYWJsZURpZmZlcnMuZXh0ZW5kID0gZnVuY3Rpb24gKGZhY3Rvcmllcykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlOiBJdGVyYWJsZURpZmZlcnMsXG4gICAgICAgICAgICAgICAgdXNlRmFjdG9yeTogZnVuY3Rpb24gKHBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHlwaWNhbGx5IHdvdWxkIG9jY3VyIHdoZW4gY2FsbGluZyBJdGVyYWJsZURpZmZlcnMuZXh0ZW5kIGluc2lkZSBvZiBkZXBlbmRlbmNpZXMgcGFzc2VkXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0b1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYm9vdHN0cmFwKCksIHdoaWNoIHdvdWxkIG92ZXJyaWRlIGRlZmF1bHQgcGlwZXMgaW5zdGVhZCBvZiBleHRlbmRpbmcgdGhlbS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGV4dGVuZCBJdGVyYWJsZURpZmZlcnMgd2l0aG91dCBhIHBhcmVudCBpbmplY3RvcicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBJdGVyYWJsZURpZmZlcnMuY3JlYXRlKGZhY3RvcmllcywgcGFyZW50KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIERlcGVuZGVuY3kgdGVjaG5pY2FsbHkgaXNuJ3Qgb3B0aW9uYWwsIGJ1dCB3ZSBjYW4gcHJvdmlkZSBhIGJldHRlciBlcnJvciBtZXNzYWdlIHRoaXMgd2F5LlxuICAgICAgICAgICAgICAgIGRlcHM6IFtbSXRlcmFibGVEaWZmZXJzLCBuZXcgU2tpcFNlbGYoKSwgbmV3IE9wdGlvbmFsKCldXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgSXRlcmFibGVEaWZmZXJzLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gKGl0ZXJhYmxlKSB7XG4gICAgICAgICAgICB2YXIgZmFjdG9yeSA9IHRoaXMuZmFjdG9yaWVzLmZpbmQoZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGYuc3VwcG9ydHMoaXRlcmFibGUpOyB9KTtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoZmFjdG9yeSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFjdG9yeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIGEgZGlmZmVyIHN1cHBvcnRpbmcgb2JqZWN0ICdcIiArIGl0ZXJhYmxlICsgXCInIG9mIHR5cGUgJ1wiICsgZ2V0VHlwZU5hbWVGb3JEZWJ1Z2dpbmcoaXRlcmFibGUpICsgXCInXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gSXRlcmFibGVEaWZmZXJzO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBBIHJlcG9zaXRvcnkgb2YgZGlmZmVyZW50IE1hcCBkaWZmaW5nIHN0cmF0ZWdpZXMgdXNlZCBieSBOZ0NsYXNzLCBOZ1N0eWxlLCBhbmQgb3RoZXJzLlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgS2V5VmFsdWVEaWZmZXJzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gS2V5VmFsdWVEaWZmZXJzKGZhY3Rvcmllcykge1xuICAgICAgICAgICAgdGhpcy5mYWN0b3JpZXMgPSBmYWN0b3JpZXM7XG4gICAgICAgIH1cbiAgICAgICAgS2V5VmFsdWVEaWZmZXJzLmNyZWF0ZSA9IGZ1bmN0aW9uIChmYWN0b3JpZXMsIHBhcmVudCkge1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChwYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvcGllZCA9IExpc3RXcmFwcGVyLmNsb25lKHBhcmVudC5mYWN0b3JpZXMpO1xuICAgICAgICAgICAgICAgIGZhY3RvcmllcyA9IGZhY3Rvcmllcy5jb25jYXQoY29waWVkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEtleVZhbHVlRGlmZmVycyhmYWN0b3JpZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBLZXlWYWx1ZURpZmZlcnMoZmFjdG9yaWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRha2VzIGFuIGFycmF5IG9mIHtAbGluayBLZXlWYWx1ZURpZmZlckZhY3Rvcnl9IGFuZCByZXR1cm5zIGEgcHJvdmlkZXIgdXNlZCB0byBleHRlbmQgdGhlXG4gICAgICAgICAqIGluaGVyaXRlZCB7QGxpbmsgS2V5VmFsdWVEaWZmZXJzfSBpbnN0YW5jZSB3aXRoIHRoZSBwcm92aWRlZCBmYWN0b3JpZXMgYW5kIHJldHVybiBhIG5ld1xuICAgICAgICAgKiB7QGxpbmsgS2V5VmFsdWVEaWZmZXJzfSBpbnN0YW5jZS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGZvbGxvd2luZyBleGFtcGxlIHNob3dzIGhvdyB0byBleHRlbmQgYW4gZXhpc3RpbmcgbGlzdCBvZiBmYWN0b3JpZXMsXG4gICAgICAgICAgICAgICAqIHdoaWNoIHdpbGwgb25seSBiZSBhcHBsaWVkIHRvIHRoZSBpbmplY3RvciBmb3IgdGhpcyBjb21wb25lbnQgYW5kIGl0cyBjaGlsZHJlbi5cbiAgICAgICAgICAgICAgICogVGhpcyBzdGVwIGlzIGFsbCB0aGF0J3MgcmVxdWlyZWQgdG8gbWFrZSBhIG5ldyB7QGxpbmsgS2V5VmFsdWVEaWZmZXJ9IGF2YWlsYWJsZS5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIEV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqIEBDb21wb25lbnQoe1xuICAgICAgICAgKiAgIHZpZXdQcm92aWRlcnM6IFtcbiAgICAgICAgICogICAgIEtleVZhbHVlRGlmZmVycy5leHRlbmQoW25ldyBJbW11dGFibGVNYXBEaWZmZXIoKV0pXG4gICAgICAgICAqICAgXVxuICAgICAgICAgKiB9KVxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIEtleVZhbHVlRGlmZmVycy5leHRlbmQgPSBmdW5jdGlvbiAoZmFjdG9yaWVzKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IEtleVZhbHVlRGlmZmVycyxcbiAgICAgICAgICAgICAgICB1c2VGYWN0b3J5OiBmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUeXBpY2FsbHkgd291bGQgb2NjdXIgd2hlbiBjYWxsaW5nIEtleVZhbHVlRGlmZmVycy5leHRlbmQgaW5zaWRlIG9mIGRlcGVuZGVuY2llcyBwYXNzZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBib290c3RyYXAoKSwgd2hpY2ggd291bGQgb3ZlcnJpZGUgZGVmYXVsdCBwaXBlcyBpbnN0ZWFkIG9mIGV4dGVuZGluZyB0aGVtLlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZXh0ZW5kIEtleVZhbHVlRGlmZmVycyB3aXRob3V0IGEgcGFyZW50IGluamVjdG9yJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEtleVZhbHVlRGlmZmVycy5jcmVhdGUoZmFjdG9yaWVzLCBwYXJlbnQpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLy8gRGVwZW5kZW5jeSB0ZWNobmljYWxseSBpc24ndCBvcHRpb25hbCwgYnV0IHdlIGNhbiBwcm92aWRlIGEgYmV0dGVyIGVycm9yIG1lc3NhZ2UgdGhpcyB3YXkuXG4gICAgICAgICAgICAgICAgZGVwczogW1tLZXlWYWx1ZURpZmZlcnMsIG5ldyBTa2lwU2VsZigpLCBuZXcgT3B0aW9uYWwoKV1dXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICBLZXlWYWx1ZURpZmZlcnMucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiAoa3YpIHtcbiAgICAgICAgICAgIHZhciBmYWN0b3J5ID0gdGhpcy5mYWN0b3JpZXMuZmluZChmdW5jdGlvbiAoZikgeyByZXR1cm4gZi5zdXBwb3J0cyhrdik7IH0pO1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChmYWN0b3J5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWN0b3J5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgYSBkaWZmZXIgc3VwcG9ydGluZyBvYmplY3QgJ1wiICsga3YgKyBcIidcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBLZXlWYWx1ZURpZmZlcnM7XG4gICAgfSgpKTtcblxuICAgIHZhciBVTklOSVRJQUxJWkVEID0ge1xuICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkgeyByZXR1cm4gJ0NEX0lOSVRfVkFMVUUnOyB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBkZXZNb2RlRXF1YWwoYSwgYikge1xuICAgICAgICBpZiAoaXNMaXN0TGlrZUl0ZXJhYmxlKGEpICYmIGlzTGlzdExpa2VJdGVyYWJsZShiKSkge1xuICAgICAgICAgICAgcmV0dXJuIGFyZUl0ZXJhYmxlc0VxdWFsKGEsIGIsIGRldk1vZGVFcXVhbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWlzTGlzdExpa2VJdGVyYWJsZShhKSAmJiAhaXNQcmltaXRpdmUoYSkgJiYgIWlzTGlzdExpa2VJdGVyYWJsZShiKSAmJiAhaXNQcmltaXRpdmUoYikpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGxvb3NlSWRlbnRpY2FsKGEsIGIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGF0IHRoZSByZXN1bHQgb2YgYSB7QGxpbmsgUGlwZX0gdHJhbnNmb3JtYXRpb24gaGFzIGNoYW5nZWQgZXZlbiB0aG91Z2ggdGhlXG4gICAgICogcmVmZXJlbmNlXG4gICAgICogaGFzIG5vdCBjaGFuZ2VkLlxuICAgICAqXG4gICAgICogVGhlIHdyYXBwZWQgdmFsdWUgd2lsbCBiZSB1bndyYXBwZWQgYnkgY2hhbmdlIGRldGVjdGlvbiwgYW5kIHRoZSB1bndyYXBwZWQgdmFsdWUgd2lsbCBiZSBzdG9yZWQuXG4gICAgICpcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogaWYgKHRoaXMuX2xhdGVzdFZhbHVlID09PSB0aGlzLl9sYXRlc3RSZXR1cm5lZFZhbHVlKSB7XG4gICAgICogICAgcmV0dXJuIHRoaXMuX2xhdGVzdFJldHVybmVkVmFsdWU7XG4gICAgICogIH0gZWxzZSB7XG4gICAgICogICAgdGhpcy5fbGF0ZXN0UmV0dXJuZWRWYWx1ZSA9IHRoaXMuX2xhdGVzdFZhbHVlO1xuICAgICAqICAgIHJldHVybiBXcmFwcGVkVmFsdWUud3JhcCh0aGlzLl9sYXRlc3RWYWx1ZSk7IC8vIHRoaXMgd2lsbCBmb3JjZSB1cGRhdGVcbiAgICAgKiAgfVxuICAgICAqIGBgYFxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgV3JhcHBlZFZhbHVlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gV3JhcHBlZFZhbHVlKHdyYXBwZWQpIHtcbiAgICAgICAgICAgIHRoaXMud3JhcHBlZCA9IHdyYXBwZWQ7XG4gICAgICAgIH1cbiAgICAgICAgV3JhcHBlZFZhbHVlLndyYXAgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIG5ldyBXcmFwcGVkVmFsdWUodmFsdWUpOyB9O1xuICAgICAgICByZXR1cm4gV3JhcHBlZFZhbHVlO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogSGVscGVyIGNsYXNzIGZvciB1bndyYXBwaW5nIFdyYXBwZWRWYWx1ZSBzXG4gICAgICovXG4gICAgdmFyIFZhbHVlVW53cmFwcGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gVmFsdWVVbndyYXBwZXIoKSB7XG4gICAgICAgICAgICB0aGlzLmhhc1dyYXBwZWRWYWx1ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIFZhbHVlVW53cmFwcGVyLnByb3RvdHlwZS51bndyYXAgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFdyYXBwZWRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFzV3JhcHBlZFZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUud3JhcHBlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgVmFsdWVVbndyYXBwZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkgeyB0aGlzLmhhc1dyYXBwZWRWYWx1ZSA9IGZhbHNlOyB9O1xuICAgICAgICByZXR1cm4gVmFsdWVVbndyYXBwZXI7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGEgYmFzaWMgY2hhbmdlIGZyb20gYSBwcmV2aW91cyB0byBhIG5ldyB2YWx1ZS5cbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIFNpbXBsZUNoYW5nZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFNpbXBsZUNoYW5nZShwcmV2aW91c1ZhbHVlLCBjdXJyZW50VmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXNWYWx1ZSA9IHByZXZpb3VzVmFsdWU7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRWYWx1ZSA9IGN1cnJlbnRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2sgd2hldGhlciB0aGUgbmV3IHZhbHVlIGlzIHRoZSBmaXJzdCB2YWx1ZSBhc3NpZ25lZC5cbiAgICAgICAgICovXG4gICAgICAgIFNpbXBsZUNoYW5nZS5wcm90b3R5cGUuaXNGaXJzdENoYW5nZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucHJldmlvdXNWYWx1ZSA9PT0gVU5JTklUSUFMSVpFRDsgfTtcbiAgICAgICAgcmV0dXJuIFNpbXBsZUNoYW5nZTtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgQ2hhbmdlRGV0ZWN0b3JSZWYgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBDaGFuZ2VEZXRlY3RvclJlZigpIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ2hhbmdlRGV0ZWN0b3JSZWY7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIFN0cnVjdHVyYWwgZGlmZmluZyBmb3IgYE9iamVjdGBzIGFuZCBgTWFwYHMuXG4gICAgICovXG4gICAgdmFyIGtleVZhbERpZmYgPSBbbmV3IERlZmF1bHRLZXlWYWx1ZURpZmZlckZhY3RvcnkoKV07XG4gICAgLyoqXG4gICAgICogU3RydWN0dXJhbCBkaWZmaW5nIGZvciBgSXRlcmFibGVgIHR5cGVzIHN1Y2ggYXMgYEFycmF5YHMuXG4gICAgICovXG4gICAgdmFyIGl0ZXJhYmxlRGlmZiA9IFtuZXcgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyRmFjdG9yeSgpXTtcbiAgICB2YXIgZGVmYXVsdEl0ZXJhYmxlRGlmZmVycyA9IG5ldyBJdGVyYWJsZURpZmZlcnMoaXRlcmFibGVEaWZmKTtcbiAgICB2YXIgZGVmYXVsdEtleVZhbHVlRGlmZmVycyA9IG5ldyBLZXlWYWx1ZURpZmZlcnMoa2V5VmFsRGlmZik7XG5cbiAgICAvKipcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgLy8gVE9ETyAobWF0c2tvKTogYWRkIHR5cGluZyBmb3IgdGhlIGFuaW1hdGlvbiBmdW5jdGlvblxuICAgIHZhciBSZW5kZXJDb21wb25lbnRUeXBlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUmVuZGVyQ29tcG9uZW50VHlwZShpZCwgdGVtcGxhdGVVcmwsIHNsb3RDb3VudCwgZW5jYXBzdWxhdGlvbiwgc3R5bGVzLCBhbmltYXRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgICAgICB0aGlzLnRlbXBsYXRlVXJsID0gdGVtcGxhdGVVcmw7XG4gICAgICAgICAgICB0aGlzLnNsb3RDb3VudCA9IHNsb3RDb3VudDtcbiAgICAgICAgICAgIHRoaXMuZW5jYXBzdWxhdGlvbiA9IGVuY2Fwc3VsYXRpb247XG4gICAgICAgICAgICB0aGlzLnN0eWxlcyA9IHN0eWxlcztcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9ucyA9IGFuaW1hdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFJlbmRlckNvbXBvbmVudFR5cGU7XG4gICAgfSgpKTtcbiAgICB2YXIgUmVuZGVyRGVidWdJbmZvID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUmVuZGVyRGVidWdJbmZvKCkge1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZW5kZXJEZWJ1Z0luZm8ucHJvdG90eXBlLCBcImluamVjdG9yXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlbmRlckRlYnVnSW5mby5wcm90b3R5cGUsIFwiY29tcG9uZW50XCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlbmRlckRlYnVnSW5mby5wcm90b3R5cGUsIFwicHJvdmlkZXJUb2tlbnNcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmltcGxlbWVudGVkKCk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVuZGVyRGVidWdJbmZvLnByb3RvdHlwZSwgXCJyZWZlcmVuY2VzXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlbmRlckRlYnVnSW5mby5wcm90b3R5cGUsIFwiY29udGV4dFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaW1wbGVtZW50ZWQoKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZW5kZXJEZWJ1Z0luZm8ucHJvdG90eXBlLCBcInNvdXJjZVwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaW1wbGVtZW50ZWQoKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBSZW5kZXJEZWJ1Z0luZm87XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgdmFyIFJlbmRlcmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUmVuZGVyZXIoKSB7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFJlbmRlcmVyO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogSW5qZWN0YWJsZSBzZXJ2aWNlIHRoYXQgcHJvdmlkZXMgYSBsb3ctbGV2ZWwgaW50ZXJmYWNlIGZvciBtb2RpZnlpbmcgdGhlIFVJLlxuICAgICAqXG4gICAgICogVXNlIHRoaXMgc2VydmljZSB0byBieXBhc3MgQW5ndWxhcidzIHRlbXBsYXRpbmcgYW5kIG1ha2UgY3VzdG9tIFVJIGNoYW5nZXMgdGhhdCBjYW4ndCBiZVxuICAgICAqIGV4cHJlc3NlZCBkZWNsYXJhdGl2ZWx5LiBGb3IgZXhhbXBsZSBpZiB5b3UgbmVlZCB0byBzZXQgYSBwcm9wZXJ0eSBvciBhbiBhdHRyaWJ1dGUgd2hvc2UgbmFtZSBpc1xuICAgICAqIG5vdCBzdGF0aWNhbGx5IGtub3duLCB1c2Uge0BsaW5rICNzZXRFbGVtZW50UHJvcGVydHl9IG9yIHtAbGluayAjc2V0RWxlbWVudEF0dHJpYnV0ZX1cbiAgICAgKiByZXNwZWN0aXZlbHkuXG4gICAgICpcbiAgICAgKiBJZiB5b3UgYXJlIGltcGxlbWVudGluZyBhIGN1c3RvbSByZW5kZXJlciwgeW91IG11c3QgaW1wbGVtZW50IHRoaXMgaW50ZXJmYWNlLlxuICAgICAqXG4gICAgICogVGhlIGRlZmF1bHQgUmVuZGVyZXIgaW1wbGVtZW50YXRpb24gaXMgYERvbVJlbmRlcmVyYC4gQWxzbyBhdmFpbGFibGUgaXMgYFdlYldvcmtlclJlbmRlcmVyYC5cbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgdmFyIFJvb3RSZW5kZXJlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFJvb3RSZW5kZXJlcigpIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUm9vdFJlbmRlcmVyO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQSBTZWN1cml0eUNvbnRleHQgbWFya3MgYSBsb2NhdGlvbiB0aGF0IGhhcyBkYW5nZXJvdXMgc2VjdXJpdHkgaW1wbGljYXRpb25zLCBlLmcuIGEgRE9NIHByb3BlcnR5XG4gICAgICogbGlrZSBgaW5uZXJIVE1MYCB0aGF0IGNvdWxkIGNhdXNlIENyb3NzIFNpdGUgU2NyaXB0aW5nIChYU1MpIHNlY3VyaXR5IGJ1Z3Mgd2hlbiBpbXByb3Blcmx5XG4gICAgICogaGFuZGxlZC5cbiAgICAgKlxuICAgICAqIFNlZSBEb21TYW5pdGl6ZXIgZm9yIG1vcmUgZGV0YWlscyBvbiBzZWN1cml0eSBpbiBBbmd1bGFyIGFwcGxpY2F0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICBleHBvcnRzLlNlY3VyaXR5Q29udGV4dDtcbiAgICAoZnVuY3Rpb24gKFNlY3VyaXR5Q29udGV4dCkge1xuICAgICAgICBTZWN1cml0eUNvbnRleHRbU2VjdXJpdHlDb250ZXh0W1wiTk9ORVwiXSA9IDBdID0gXCJOT05FXCI7XG4gICAgICAgIFNlY3VyaXR5Q29udGV4dFtTZWN1cml0eUNvbnRleHRbXCJIVE1MXCJdID0gMV0gPSBcIkhUTUxcIjtcbiAgICAgICAgU2VjdXJpdHlDb250ZXh0W1NlY3VyaXR5Q29udGV4dFtcIlNUWUxFXCJdID0gMl0gPSBcIlNUWUxFXCI7XG4gICAgICAgIFNlY3VyaXR5Q29udGV4dFtTZWN1cml0eUNvbnRleHRbXCJTQ1JJUFRcIl0gPSAzXSA9IFwiU0NSSVBUXCI7XG4gICAgICAgIFNlY3VyaXR5Q29udGV4dFtTZWN1cml0eUNvbnRleHRbXCJVUkxcIl0gPSA0XSA9IFwiVVJMXCI7XG4gICAgICAgIFNlY3VyaXR5Q29udGV4dFtTZWN1cml0eUNvbnRleHRbXCJSRVNPVVJDRV9VUkxcIl0gPSA1XSA9IFwiUkVTT1VSQ0VfVVJMXCI7XG4gICAgfSkoZXhwb3J0cy5TZWN1cml0eUNvbnRleHQgfHwgKGV4cG9ydHMuU2VjdXJpdHlDb250ZXh0ID0ge30pKTtcbiAgICAvKipcbiAgICAgKiBTYW5pdGl6ZXIgaXMgdXNlZCBieSB0aGUgdmlld3MgdG8gc2FuaXRpemUgcG90ZW50aWFsbHkgZGFuZ2Vyb3VzIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgU2FuaXRpemVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gU2FuaXRpemVyKCkge1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTYW5pdGl6ZXI7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBBIHdyYXBwZXIgYXJvdW5kIGEgbmF0aXZlIGVsZW1lbnQgaW5zaWRlIG9mIGEgVmlldy5cbiAgICAgKlxuICAgICAqIEFuIGBFbGVtZW50UmVmYCBpcyBiYWNrZWQgYnkgYSByZW5kZXItc3BlY2lmaWMgZWxlbWVudC4gSW4gdGhlIGJyb3dzZXIsIHRoaXMgaXMgdXN1YWxseSBhIERPTVxuICAgICAqIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAc2VjdXJpdHkgUGVybWl0dGluZyBkaXJlY3QgYWNjZXNzIHRvIHRoZSBET00gY2FuIG1ha2UgeW91ciBhcHBsaWNhdGlvbiBtb3JlIHZ1bG5lcmFibGUgdG9cbiAgICAgKiBYU1MgYXR0YWNrcy4gQ2FyZWZ1bGx5IHJldmlldyBhbnkgdXNlIG9mIGBFbGVtZW50UmVmYCBpbiB5b3VyIGNvZGUuIEZvciBtb3JlIGRldGFpbCwgc2VlIHRoZVxuICAgICAqIFtTZWN1cml0eSBHdWlkZV0oaHR0cDovL2cuY28vbmcvc2VjdXJpdHkpLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIC8vIE5vdGU6IFdlIGRvbid0IGV4cG9zZSB0aGluZ3MgbGlrZSBgSW5qZWN0b3JgLCBgVmlld0NvbnRhaW5lcmAsIC4uLiBoZXJlLFxuICAgIC8vIGkuZS4gdXNlcnMgaGF2ZSB0byBhc2sgZm9yIHdoYXQgdGhleSBuZWVkLiBXaXRoIHRoYXQsIHdlIGNhbiBidWlsZCBiZXR0ZXIgYW5hbHlzaXMgdG9vbHNcbiAgICAvLyBhbmQgY291bGQgZG8gYmV0dGVyIGNvZGVnZW4gaW4gdGhlIGZ1dHVyZS5cbiAgICB2YXIgRWxlbWVudFJlZiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEVsZW1lbnRSZWYobmF0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5uYXRpdmVFbGVtZW50ID0gbmF0aXZlRWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRWxlbWVudFJlZjtcbiAgICB9KCkpO1xuXG4gICAgdmFyIHRyYWNlO1xuICAgIHZhciBldmVudHM7XG4gICAgZnVuY3Rpb24gZGV0ZWN0V1RGKCkge1xuICAgICAgICB2YXIgd3RmID0gZ2xvYmFsJDFbJ3d0ZiddO1xuICAgICAgICBpZiAod3RmKSB7XG4gICAgICAgICAgICB0cmFjZSA9IHd0ZlsndHJhY2UnXTtcbiAgICAgICAgICAgIGlmICh0cmFjZSkge1xuICAgICAgICAgICAgICAgIGV2ZW50cyA9IHRyYWNlWydldmVudHMnXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVNjb3BlKHNpZ25hdHVyZSwgZmxhZ3MpIHtcbiAgICAgICAgaWYgKGZsYWdzID09PSB2b2lkIDApIHsgZmxhZ3MgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiBldmVudHMuY3JlYXRlU2NvcGUoc2lnbmF0dXJlLCBmbGFncyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxlYXZlKHNjb3BlLCByZXR1cm5WYWx1ZSkge1xuICAgICAgICB0cmFjZS5sZWF2ZVNjb3BlKHNjb3BlLCByZXR1cm5WYWx1ZSk7XG4gICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RhcnRUaW1lUmFuZ2UocmFuZ2VUeXBlLCBhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHRyYWNlLmJlZ2luVGltZVJhbmdlKHJhbmdlVHlwZSwgYWN0aW9uKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW5kVGltZVJhbmdlKHJhbmdlKSB7XG4gICAgICAgIHRyYWNlLmVuZFRpbWVSYW5nZShyYW5nZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiBXVEYgaXMgZW5hYmxlZC5cbiAgICAgKi9cbiAgICB2YXIgd3RmRW5hYmxlZCA9IGRldGVjdFdURigpO1xuICAgIGZ1bmN0aW9uIG5vb3BTY29wZShhcmcwLCBhcmcxKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdHJhY2Ugc2NvcGUuXG4gICAgICpcbiAgICAgKiBTY29wZXMgbXVzdCBiZSBzdHJpY3RseSBuZXN0ZWQgYW5kIGFyZSBhbmFsb2dvdXMgdG8gc3RhY2sgZnJhbWVzLCBidXRcbiAgICAgKiBkbyBub3QgaGF2ZSB0byBmb2xsb3cgdGhlIHN0YWNrIGZyYW1lcy4gSW5zdGVhZCBpdCBpcyByZWNvbW1lbmRlZCB0aGF0IHRoZXkgZm9sbG93IGxvZ2ljYWxcbiAgICAgKiBuZXN0aW5nLiBZb3UgbWF5IHdhbnQgdG8gdXNlXG4gICAgICogW0V2ZW50XG4gICAgICogU2lnbmF0dXJlc10oaHR0cDovL2dvb2dsZS5naXRodWIuaW8vdHJhY2luZy1mcmFtZXdvcmsvaW5zdHJ1bWVudGluZy1jb2RlLmh0bWwjY3VzdG9tLWV2ZW50cylcbiAgICAgKiBhcyB0aGV5IGFyZSBkZWZpbmVkIGluIFdURi5cbiAgICAgKlxuICAgICAqIFVzZWQgdG8gbWFyayBzY29wZSBlbnRyeS4gVGhlIHJldHVybiB2YWx1ZSBpcyB1c2VkIHRvIGxlYXZlIHRoZSBzY29wZS5cbiAgICAgKlxuICAgICAqICAgICB2YXIgbXlTY29wZSA9IHd0ZkNyZWF0ZVNjb3BlKCdNeUNsYXNzI215TWV0aG9kKGFzY2lpIHNvbWVWYWwpJyk7XG4gICAgICpcbiAgICAgKiAgICAgc29tZU1ldGhvZCgpIHtcbiAgICAgKiAgICAgICAgdmFyIHMgPSBteVNjb3BlKCdGb28nKTsgLy8gJ0ZvbycgZ2V0cyBzdG9yZWQgaW4gdHJhY2luZyBVSVxuICAgICAqICAgICAgICAvLyBETyBTT01FIFdPUksgSEVSRVxuICAgICAqICAgICAgICByZXR1cm4gd3RmTGVhdmUocywgMTIzKTsgLy8gUmV0dXJuIHZhbHVlIDEyM1xuICAgICAqICAgICB9XG4gICAgICpcbiAgICAgKiBOb3RlLCBhZGRpbmcgdHJ5LWZpbmFsbHkgYmxvY2sgYXJvdW5kIHRoZSB3b3JrIHRvIGVuc3VyZSB0aGF0IGB3dGZMZWF2ZWAgZ2V0cyBjYWxsZWQgY2FuXG4gICAgICogbmVnYXRpdmVseSBpbXBhY3QgdGhlIHBlcmZvcm1hbmNlIG9mIHlvdXIgYXBwbGljYXRpb24uIEZvciB0aGlzIHJlYXNvbiB3ZSByZWNvbW1lbmQgdGhhdFxuICAgICAqIHlvdSBkb24ndCBhZGQgdGhlbSB0byBlbnN1cmUgdGhhdCBgd3RmTGVhdmVgIGdldHMgY2FsbGVkLiBJbiBwcm9kdWN0aW9uIGB3dGZMZWF2ZWAgaXMgYSBub29wIGFuZFxuICAgICAqIHNvIHRyeS1maW5hbGx5IGJsb2NrIGhhcyBubyB2YWx1ZS4gV2hlbiBkZWJ1Z2dpbmcgcGVyZiBpc3N1ZXMsIHNraXBwaW5nIGB3dGZMZWF2ZWAsIGRvIHRvXG4gICAgICogZXhjZXB0aW9uLCB3aWxsIHByb2R1Y2UgaW5jb3JyZWN0IHRyYWNlLCBidXQgcHJlc2VuY2Ugb2YgZXhjZXB0aW9uIHNpZ25pZmllcyBsb2dpYyBlcnJvciB3aGljaFxuICAgICAqIG5lZWRzIHRvIGJlIGZpeGVkIGJlZm9yZSB0aGUgYXBwIHNob3VsZCBiZSBwcm9maWxlZC4gQWRkIHRyeS1maW5hbGx5IG9ubHkgd2hlbiB5b3UgZXhwZWN0IHRoYXRcbiAgICAgKiBhbiBleGNlcHRpb24gaXMgZXhwZWN0ZWQgZHVyaW5nIG5vcm1hbCBleGVjdXRpb24gd2hpbGUgcHJvZmlsaW5nLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciB3dGZDcmVhdGVTY29wZSA9IHd0ZkVuYWJsZWQgPyBjcmVhdGVTY29wZSA6IGZ1bmN0aW9uIChzaWduYXR1cmUsIGZsYWdzKSB7IHJldHVybiBub29wU2NvcGU7IH07XG4gICAgLyoqXG4gICAgICogVXNlZCB0byBtYXJrIGVuZCBvZiBTY29wZS5cbiAgICAgKlxuICAgICAqIC0gYHNjb3BlYCB0byBlbmQuXG4gICAgICogLSBgcmV0dXJuVmFsdWVgIChvcHRpb25hbCkgdG8gYmUgcGFzc2VkIHRvIHRoZSBXVEYuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIHRoZSBgcmV0dXJuVmFsdWUgZm9yIGVhc3kgY2hhaW5pbmcuXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciB3dGZMZWF2ZSA9IHd0ZkVuYWJsZWQgPyBsZWF2ZSA6IGZ1bmN0aW9uIChzLCByKSB7IHJldHVybiByOyB9O1xuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gbWFyayBBc3luYyBzdGFydC4gQXN5bmMgYXJlIHNpbWlsYXIgdG8gc2NvcGUgYnV0IHRoZXkgZG9uJ3QgaGF2ZSB0byBiZSBzdHJpY3RseSBuZXN0ZWQuXG4gICAgICogVGhlIHJldHVybiB2YWx1ZSBpcyB1c2VkIGluIHRoZSBjYWxsIHRvIFtlbmRBc3luY10uIEFzeW5jIHJhbmdlcyBvbmx5IHdvcmsgaWYgV1RGIGhhcyBiZWVuXG4gICAgICogZW5hYmxlZC5cbiAgICAgKlxuICAgICAqICAgICBzb21lTWV0aG9kKCkge1xuICAgICAqICAgICAgICB2YXIgcyA9IHd0ZlN0YXJ0VGltZVJhbmdlKCdIVFRQOkdFVCcsICdzb21lLnVybCcpO1xuICAgICAqICAgICAgICB2YXIgZnV0dXJlID0gbmV3IEZ1dHVyZS5kZWxheSg1KS50aGVuKChfKSB7XG4gICAgICogICAgICAgICAgd3RmRW5kVGltZVJhbmdlKHMpO1xuICAgICAqICAgICAgICB9KTtcbiAgICAgKiAgICAgfVxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgd3RmU3RhcnRUaW1lUmFuZ2UgPSB3dGZFbmFibGVkID8gc3RhcnRUaW1lUmFuZ2UgOiBmdW5jdGlvbiAocmFuZ2VUeXBlLCBhY3Rpb24pIHsgcmV0dXJuIG51bGw7IH07XG4gICAgLyoqXG4gICAgICogRW5kcyBhIGFzeW5jIHRpbWUgcmFuZ2Ugb3BlcmF0aW9uLlxuICAgICAqIFtyYW5nZV0gaXMgdGhlIHJldHVybiB2YWx1ZSBmcm9tIFt3dGZTdGFydFRpbWVSYW5nZV0gQXN5bmMgcmFuZ2VzIG9ubHkgd29yayBpZiBXVEYgaGFzIGJlZW5cbiAgICAgKiBlbmFibGVkLlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgd3RmRW5kVGltZVJhbmdlID0gd3RmRW5hYmxlZCA/IGVuZFRpbWVSYW5nZSA6IGZ1bmN0aW9uIChyKSB7IHJldHVybiBudWxsOyB9O1xuXG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhIGNvbnRhaW5lciB3aGVyZSBvbmUgb3IgbW9yZSBWaWV3cyBjYW4gYmUgYXR0YWNoZWQuXG4gICAgICpcbiAgICAgKiBUaGUgY29udGFpbmVyIGNhbiBjb250YWluIHR3byBraW5kcyBvZiBWaWV3cy4gSG9zdCBWaWV3cywgY3JlYXRlZCBieSBpbnN0YW50aWF0aW5nIGFcbiAgICAgKiB7QGxpbmsgQ29tcG9uZW50fSB2aWEge0BsaW5rICNjcmVhdGVDb21wb25lbnR9LCBhbmQgRW1iZWRkZWQgVmlld3MsIGNyZWF0ZWQgYnkgaW5zdGFudGlhdGluZyBhblxuICAgICAqIHtAbGluayBUZW1wbGF0ZVJlZiBFbWJlZGRlZCBUZW1wbGF0ZX0gdmlhIHtAbGluayAjY3JlYXRlRW1iZWRkZWRWaWV3fS5cbiAgICAgKlxuICAgICAqIFRoZSBsb2NhdGlvbiBvZiB0aGUgVmlldyBDb250YWluZXIgd2l0aGluIHRoZSBjb250YWluaW5nIFZpZXcgaXMgc3BlY2lmaWVkIGJ5IHRoZSBBbmNob3JcbiAgICAgKiBgZWxlbWVudGAuIEVhY2ggVmlldyBDb250YWluZXIgY2FuIGhhdmUgb25seSBvbmUgQW5jaG9yIEVsZW1lbnQgYW5kIGVhY2ggQW5jaG9yIEVsZW1lbnQgY2FuIG9ubHlcbiAgICAgKiBoYXZlIGEgc2luZ2xlIFZpZXcgQ29udGFpbmVyLlxuICAgICAqXG4gICAgICogUm9vdCBlbGVtZW50cyBvZiBWaWV3cyBhdHRhY2hlZCB0byB0aGlzIGNvbnRhaW5lciBiZWNvbWUgc2libGluZ3Mgb2YgdGhlIEFuY2hvciBFbGVtZW50IGluXG4gICAgICogdGhlIFJlbmRlcmVkIFZpZXcuXG4gICAgICpcbiAgICAgKiBUbyBhY2Nlc3MgYSBgVmlld0NvbnRhaW5lclJlZmAgb2YgYW4gRWxlbWVudCwgeW91IGNhbiBlaXRoZXIgcGxhY2UgYSB7QGxpbmsgRGlyZWN0aXZlfSBpbmplY3RlZFxuICAgICAqIHdpdGggYFZpZXdDb250YWluZXJSZWZgIG9uIHRoZSBFbGVtZW50LCBvciB5b3Ugb2J0YWluIGl0IHZpYSBhIHtAbGluayBWaWV3Q2hpbGR9IHF1ZXJ5LlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgVmlld0NvbnRhaW5lclJlZiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFZpZXdDb250YWluZXJSZWYoKSB7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdDb250YWluZXJSZWYucHJvdG90eXBlLCBcImVsZW1lbnRcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBbmNob3IgZWxlbWVudCB0aGF0IHNwZWNpZmllcyB0aGUgbG9jYXRpb24gb2YgdGhpcyBjb250YWluZXIgaW4gdGhlIGNvbnRhaW5pbmcgVmlldy5cbiAgICAgICAgICAgICAqIDwhLS0gVE9ETzogcmVuYW1lIHRvIGFuY2hvckVsZW1lbnQgLS0+XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdDb250YWluZXJSZWYucHJvdG90eXBlLCBcImluamVjdG9yXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdDb250YWluZXJSZWYucHJvdG90eXBlLCBcInBhcmVudEluamVjdG9yXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdDb250YWluZXJSZWYucHJvdG90eXBlLCBcImxlbmd0aFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBWaWV3cyBjdXJyZW50bHkgYXR0YWNoZWQgdG8gdGhpcyBjb250YWluZXIuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgO1xuICAgICAgICByZXR1cm4gVmlld0NvbnRhaW5lclJlZjtcbiAgICB9KCkpO1xuICAgIHZhciBWaWV3Q29udGFpbmVyUmVmXyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFZpZXdDb250YWluZXJSZWZfKF9lbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50ID0gX2VsZW1lbnQ7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVDb21wb25lbnRJbkNvbnRhaW5lclNjb3BlID0gd3RmQ3JlYXRlU2NvcGUoJ1ZpZXdDb250YWluZXJSZWYjY3JlYXRlQ29tcG9uZW50KCknKTtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX2luc2VydFNjb3BlID0gd3RmQ3JlYXRlU2NvcGUoJ1ZpZXdDb250YWluZXJSZWYjaW5zZXJ0KCknKTtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZVNjb3BlID0gd3RmQ3JlYXRlU2NvcGUoJ1ZpZXdDb250YWluZXJSZWYjcmVtb3ZlKCknKTtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX2RldGFjaFNjb3BlID0gd3RmQ3JlYXRlU2NvcGUoJ1ZpZXdDb250YWluZXJSZWYjZGV0YWNoKCknKTtcbiAgICAgICAgfVxuICAgICAgICBWaWV3Q29udGFpbmVyUmVmXy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGluZGV4KSB7IHJldHVybiB0aGlzLl9lbGVtZW50Lm5lc3RlZFZpZXdzW2luZGV4XS5yZWY7IH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaWV3Q29udGFpbmVyUmVmXy5wcm90b3R5cGUsIFwibGVuZ3RoXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciB2aWV3cyA9IHRoaXMuX2VsZW1lbnQubmVzdGVkVmlld3M7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh2aWV3cykgPyB2aWV3cy5sZW5ndGggOiAwO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaWV3Q29udGFpbmVyUmVmXy5wcm90b3R5cGUsIFwiZWxlbWVudFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2VsZW1lbnQuZWxlbWVudFJlZjsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaWV3Q29udGFpbmVyUmVmXy5wcm90b3R5cGUsIFwiaW5qZWN0b3JcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9lbGVtZW50LmluamVjdG9yOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdDb250YWluZXJSZWZfLnByb3RvdHlwZSwgXCJwYXJlbnRJbmplY3RvclwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2VsZW1lbnQucGFyZW50SW5qZWN0b3I7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUT0RPKHJhZG8pOiBwcm9maWxlIGFuZCBkZWNpZGUgd2hldGhlciBib3VuZHMgY2hlY2tzIHNob3VsZCBiZSBhZGRlZFxuICAgICAgICAvLyB0byB0aGUgbWV0aG9kcyBiZWxvdy5cbiAgICAgICAgVmlld0NvbnRhaW5lclJlZl8ucHJvdG90eXBlLmNyZWF0ZUVtYmVkZGVkVmlldyA9IGZ1bmN0aW9uICh0ZW1wbGF0ZVJlZiwgY29udGV4dCwgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gdm9pZCAwKSB7IGluZGV4ID0gLTE7IH1cbiAgICAgICAgICAgIHZhciB2aWV3UmVmID0gdGVtcGxhdGVSZWYuY3JlYXRlRW1iZWRkZWRWaWV3KGNvbnRleHQpO1xuICAgICAgICAgICAgdGhpcy5pbnNlcnQodmlld1JlZiwgaW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuIHZpZXdSZWY7XG4gICAgICAgIH07XG4gICAgICAgIFZpZXdDb250YWluZXJSZWZfLnByb3RvdHlwZS5jcmVhdGVDb21wb25lbnQgPSBmdW5jdGlvbiAoY29tcG9uZW50RmFjdG9yeSwgaW5kZXgsIGluamVjdG9yLCBwcm9qZWN0YWJsZU5vZGVzKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IHZvaWQgMCkgeyBpbmRleCA9IC0xOyB9XG4gICAgICAgICAgICBpZiAoaW5qZWN0b3IgPT09IHZvaWQgMCkgeyBpbmplY3RvciA9IG51bGw7IH1cbiAgICAgICAgICAgIGlmIChwcm9qZWN0YWJsZU5vZGVzID09PSB2b2lkIDApIHsgcHJvamVjdGFibGVOb2RlcyA9IG51bGw7IH1cbiAgICAgICAgICAgIHZhciBzID0gdGhpcy5fY3JlYXRlQ29tcG9uZW50SW5Db250YWluZXJTY29wZSgpO1xuICAgICAgICAgICAgdmFyIGNvbnRleHRJbmplY3RvciA9IGluamVjdG9yIHx8IHRoaXMuX2VsZW1lbnQucGFyZW50SW5qZWN0b3I7XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50UmVmID0gY29tcG9uZW50RmFjdG9yeS5jcmVhdGUoY29udGV4dEluamVjdG9yLCBwcm9qZWN0YWJsZU5vZGVzKTtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0KGNvbXBvbmVudFJlZi5ob3N0VmlldywgaW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuIHd0ZkxlYXZlKHMsIGNvbXBvbmVudFJlZik7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFRPRE8oaSk6IHJlZmFjdG9yIGluc2VydCtyZW1vdmUgaW50byBtb3ZlXG4gICAgICAgIFZpZXdDb250YWluZXJSZWZfLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiAodmlld1JlZiwgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gdm9pZCAwKSB7IGluZGV4ID0gLTE7IH1cbiAgICAgICAgICAgIHZhciBzID0gdGhpcy5faW5zZXJ0U2NvcGUoKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PSAtMSlcbiAgICAgICAgICAgICAgICBpbmRleCA9IHRoaXMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIHZpZXdSZWZfID0gdmlld1JlZjtcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnQuYXR0YWNoVmlldyh2aWV3UmVmXy5pbnRlcm5hbFZpZXcsIGluZGV4KTtcbiAgICAgICAgICAgIHJldHVybiB3dGZMZWF2ZShzLCB2aWV3UmVmXyk7XG4gICAgICAgIH07XG4gICAgICAgIFZpZXdDb250YWluZXJSZWZfLnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24gKHZpZXdSZWYsIGN1cnJlbnRJbmRleCkge1xuICAgICAgICAgICAgdmFyIHMgPSB0aGlzLl9pbnNlcnRTY29wZSgpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA9PSAtMSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgdmlld1JlZl8gPSB2aWV3UmVmO1xuICAgICAgICAgICAgdGhpcy5fZWxlbWVudC5tb3ZlVmlldyh2aWV3UmVmXy5pbnRlcm5hbFZpZXcsIGN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICByZXR1cm4gd3RmTGVhdmUocywgdmlld1JlZl8pO1xuICAgICAgICB9O1xuICAgICAgICBWaWV3Q29udGFpbmVyUmVmXy5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uICh2aWV3UmVmKSB7XG4gICAgICAgICAgICByZXR1cm4gTGlzdFdyYXBwZXIuaW5kZXhPZih0aGlzLl9lbGVtZW50Lm5lc3RlZFZpZXdzLCB2aWV3UmVmLmludGVybmFsVmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFRPRE8oaSk6IHJlbmFtZSB0byBkZXN0cm95XG4gICAgICAgIFZpZXdDb250YWluZXJSZWZfLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gdm9pZCAwKSB7IGluZGV4ID0gLTE7IH1cbiAgICAgICAgICAgIHZhciBzID0gdGhpcy5fcmVtb3ZlU2NvcGUoKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PSAtMSlcbiAgICAgICAgICAgICAgICBpbmRleCA9IHRoaXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHZhciB2aWV3ID0gdGhpcy5fZWxlbWVudC5kZXRhY2hWaWV3KGluZGV4KTtcbiAgICAgICAgICAgIHZpZXcuZGVzdHJveSgpO1xuICAgICAgICAgICAgLy8gdmlldyBpcyBpbnRlbnRpb25hbGx5IG5vdCByZXR1cm5lZCB0byB0aGUgY2xpZW50LlxuICAgICAgICAgICAgd3RmTGVhdmUocyk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFRPRE8oaSk6IHJlZmFjdG9yIGluc2VydCtyZW1vdmUgaW50byBtb3ZlXG4gICAgICAgIFZpZXdDb250YWluZXJSZWZfLnByb3RvdHlwZS5kZXRhY2ggPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gdm9pZCAwKSB7IGluZGV4ID0gLTE7IH1cbiAgICAgICAgICAgIHZhciBzID0gdGhpcy5fZGV0YWNoU2NvcGUoKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PSAtMSlcbiAgICAgICAgICAgICAgICBpbmRleCA9IHRoaXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHZhciB2aWV3ID0gdGhpcy5fZWxlbWVudC5kZXRhY2hWaWV3KGluZGV4KTtcbiAgICAgICAgICAgIHJldHVybiB3dGZMZWF2ZShzLCB2aWV3LnJlZik7XG4gICAgICAgIH07XG4gICAgICAgIFZpZXdDb250YWluZXJSZWZfLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmUoaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBWaWV3Q29udGFpbmVyUmVmXztcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBWaWV3VHlwZTtcbiAgICAoZnVuY3Rpb24gKFZpZXdUeXBlKSB7XG4gICAgICAgIC8vIEEgdmlldyB0aGF0IGNvbnRhaW5zIHRoZSBob3N0IGVsZW1lbnQgd2l0aCBib3VuZCBjb21wb25lbnQgZGlyZWN0aXZlLlxuICAgICAgICAvLyBDb250YWlucyBhIENPTVBPTkVOVCB2aWV3XG4gICAgICAgIFZpZXdUeXBlW1ZpZXdUeXBlW1wiSE9TVFwiXSA9IDBdID0gXCJIT1NUXCI7XG4gICAgICAgIC8vIFRoZSB2aWV3IG9mIHRoZSBjb21wb25lbnRcbiAgICAgICAgLy8gQ2FuIGNvbnRhaW4gMCB0byBuIEVNQkVEREVEIHZpZXdzXG4gICAgICAgIFZpZXdUeXBlW1ZpZXdUeXBlW1wiQ09NUE9ORU5UXCJdID0gMV0gPSBcIkNPTVBPTkVOVFwiO1xuICAgICAgICAvLyBBIHZpZXcgdGhhdCBpcyBlbWJlZGRlZCBpbnRvIGFub3RoZXIgVmlldyB2aWEgYSA8dGVtcGxhdGU+IGVsZW1lbnRcbiAgICAgICAgLy8gaW5zaWRlIG9mIGEgQ09NUE9ORU5UIHZpZXdcbiAgICAgICAgVmlld1R5cGVbVmlld1R5cGVbXCJFTUJFRERFRFwiXSA9IDJdID0gXCJFTUJFRERFRFwiO1xuICAgIH0pKFZpZXdUeXBlIHx8IChWaWV3VHlwZSA9IHt9KSk7XG5cbiAgICAvKipcbiAgICAgKiBBbiBBcHBFbGVtZW50IGlzIGNyZWF0ZWQgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIFZpZXdDb250YWluZXJSZWYsXG4gICAgICogYSBuZXN0ZWQgY29tcG9uZW50IG9yIGEgPHRlbXBsYXRlPiBlbGVtZW50IHRvIGtlZXAgZGF0YSBhcm91bmRcbiAgICAgKiB0aGF0IGlzIG5lZWRlZCBmb3IgbGF0ZXIgaW5zdGFudGlhdGlvbnMuXG4gICAgICovXG4gICAgdmFyIEFwcEVsZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBBcHBFbGVtZW50KGluZGV4LCBwYXJlbnRJbmRleCwgcGFyZW50VmlldywgbmF0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgdGhpcy5wYXJlbnRJbmRleCA9IHBhcmVudEluZGV4O1xuICAgICAgICAgICAgdGhpcy5wYXJlbnRWaWV3ID0gcGFyZW50VmlldztcbiAgICAgICAgICAgIHRoaXMubmF0aXZlRWxlbWVudCA9IG5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLm5lc3RlZFZpZXdzID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50VmlldyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFwcEVsZW1lbnQucHJvdG90eXBlLCBcImVsZW1lbnRSZWZcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgRWxlbWVudFJlZih0aGlzLm5hdGl2ZUVsZW1lbnQpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFwcEVsZW1lbnQucHJvdG90eXBlLCBcInZjUmVmXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IFZpZXdDb250YWluZXJSZWZfKHRoaXMpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgQXBwRWxlbWVudC5wcm90b3R5cGUuaW5pdENvbXBvbmVudCA9IGZ1bmN0aW9uIChjb21wb25lbnQsIGNvbXBvbmVudENvbnN0cnVjdG9yVmlld1F1ZXJpZXMsIHZpZXcpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRDb25zdHJ1Y3RvclZpZXdRdWVyaWVzID0gY29tcG9uZW50Q29uc3RydWN0b3JWaWV3UXVlcmllcztcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50VmlldyA9IHZpZXc7XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcHBFbGVtZW50LnByb3RvdHlwZSwgXCJwYXJlbnRJbmplY3RvclwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucGFyZW50Vmlldy5pbmplY3Rvcih0aGlzLnBhcmVudEluZGV4KTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcHBFbGVtZW50LnByb3RvdHlwZSwgXCJpbmplY3RvclwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucGFyZW50Vmlldy5pbmplY3Rvcih0aGlzLmluZGV4KTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIEFwcEVsZW1lbnQucHJvdG90eXBlLm1hcE5lc3RlZFZpZXdzID0gZnVuY3Rpb24gKG5lc3RlZFZpZXdDbGFzcywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5uZXN0ZWRWaWV3cykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5lc3RlZFZpZXdzLmZvckVhY2goZnVuY3Rpb24gKG5lc3RlZFZpZXcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5lc3RlZFZpZXcuY2xhenogPT09IG5lc3RlZFZpZXdDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY2FsbGJhY2sobmVzdGVkVmlldykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgICBBcHBFbGVtZW50LnByb3RvdHlwZS5tb3ZlVmlldyA9IGZ1bmN0aW9uICh2aWV3LCBjdXJyZW50SW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBwcmV2aW91c0luZGV4ID0gdGhpcy5uZXN0ZWRWaWV3cy5pbmRleE9mKHZpZXcpO1xuICAgICAgICAgICAgaWYgKHZpZXcudHlwZSA9PT0gVmlld1R5cGUuQ09NUE9ORU5UKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29tcG9uZW50IHZpZXdzIGNhbid0IGJlIG1vdmVkIVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBuZXN0ZWRWaWV3cyA9IHRoaXMubmVzdGVkVmlld3M7XG4gICAgICAgICAgICBpZiAobmVzdGVkVmlld3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG5lc3RlZFZpZXdzID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5uZXN0ZWRWaWV3cyA9IG5lc3RlZFZpZXdzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgTGlzdFdyYXBwZXIucmVtb3ZlQXQobmVzdGVkVmlld3MsIHByZXZpb3VzSW5kZXgpO1xuICAgICAgICAgICAgTGlzdFdyYXBwZXIuaW5zZXJ0KG5lc3RlZFZpZXdzLCBjdXJyZW50SW5kZXgsIHZpZXcpO1xuICAgICAgICAgICAgdmFyIHJlZlJlbmRlck5vZGU7XG4gICAgICAgICAgICBpZiAoY3VycmVudEluZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBwcmV2VmlldyA9IG5lc3RlZFZpZXdzW2N1cnJlbnRJbmRleCAtIDFdO1xuICAgICAgICAgICAgICAgIHJlZlJlbmRlck5vZGUgPSBwcmV2Vmlldy5sYXN0Um9vdE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWZSZW5kZXJOb2RlID0gdGhpcy5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChyZWZSZW5kZXJOb2RlKSkge1xuICAgICAgICAgICAgICAgIHZpZXcucmVuZGVyZXIuYXR0YWNoVmlld0FmdGVyKHJlZlJlbmRlck5vZGUsIHZpZXcuZmxhdFJvb3ROb2Rlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2aWV3Lm1hcmtDb250ZW50Q2hpbGRBc01vdmVkKHRoaXMpO1xuICAgICAgICB9O1xuICAgICAgICBBcHBFbGVtZW50LnByb3RvdHlwZS5hdHRhY2hWaWV3ID0gZnVuY3Rpb24gKHZpZXcsIHZpZXdJbmRleCkge1xuICAgICAgICAgICAgaWYgKHZpZXcudHlwZSA9PT0gVmlld1R5cGUuQ09NUE9ORU5UKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29tcG9uZW50IHZpZXdzIGNhbid0IGJlIG1vdmVkIVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBuZXN0ZWRWaWV3cyA9IHRoaXMubmVzdGVkVmlld3M7XG4gICAgICAgICAgICBpZiAobmVzdGVkVmlld3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG5lc3RlZFZpZXdzID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5uZXN0ZWRWaWV3cyA9IG5lc3RlZFZpZXdzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgTGlzdFdyYXBwZXIuaW5zZXJ0KG5lc3RlZFZpZXdzLCB2aWV3SW5kZXgsIHZpZXcpO1xuICAgICAgICAgICAgdmFyIHJlZlJlbmRlck5vZGU7XG4gICAgICAgICAgICBpZiAodmlld0luZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBwcmV2VmlldyA9IG5lc3RlZFZpZXdzW3ZpZXdJbmRleCAtIDFdO1xuICAgICAgICAgICAgICAgIHJlZlJlbmRlck5vZGUgPSBwcmV2Vmlldy5sYXN0Um9vdE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWZSZW5kZXJOb2RlID0gdGhpcy5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChyZWZSZW5kZXJOb2RlKSkge1xuICAgICAgICAgICAgICAgIHZpZXcucmVuZGVyZXIuYXR0YWNoVmlld0FmdGVyKHJlZlJlbmRlck5vZGUsIHZpZXcuZmxhdFJvb3ROb2Rlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2aWV3LmFkZFRvQ29udGVudENoaWxkcmVuKHRoaXMpO1xuICAgICAgICB9O1xuICAgICAgICBBcHBFbGVtZW50LnByb3RvdHlwZS5kZXRhY2hWaWV3ID0gZnVuY3Rpb24gKHZpZXdJbmRleCkge1xuICAgICAgICAgICAgdmFyIHZpZXcgPSBMaXN0V3JhcHBlci5yZW1vdmVBdCh0aGlzLm5lc3RlZFZpZXdzLCB2aWV3SW5kZXgpO1xuICAgICAgICAgICAgaWYgKHZpZXcudHlwZSA9PT0gVmlld1R5cGUuQ09NUE9ORU5UKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29tcG9uZW50IHZpZXdzIGNhbid0IGJlIG1vdmVkIVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZpZXcuZGV0YWNoKCk7XG4gICAgICAgICAgICB2aWV3LnJlbW92ZUZyb21Db250ZW50Q2hpbGRyZW4odGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gdmlldztcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEFwcEVsZW1lbnQ7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDYgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBbiBlcnJvciB0aHJvd24gaWYgYXBwbGljYXRpb24gY2hhbmdlcyBtb2RlbCBicmVha2luZyB0aGUgdG9wLWRvd24gZGF0YSBmbG93LlxuICAgICAqXG4gICAgICogVGhpcyBleGNlcHRpb24gaXMgb25seSB0aHJvd24gaW4gZGV2IG1vZGUuXG4gICAgICpcbiAgICAgKiA8IS0tIFRPRE86IEFkZCBhIGxpbmsgb25jZSB0aGUgZGV2IG1vZGUgb3B0aW9uIGlzIGNvbmZpZ3VyYWJsZSAtLT5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogQENvbXBvbmVudCh7XG4gICAgICogICBzZWxlY3RvcjogJ3BhcmVudCcsXG4gICAgICogICB0ZW1wbGF0ZTogJzxjaGlsZCBbcHJvcF09XCJwYXJlbnRQcm9wXCI+PC9jaGlsZD4nLFxuICAgICAqIH0pXG4gICAgICogY2xhc3MgUGFyZW50IHtcbiAgICAgKiAgIHBhcmVudFByb3AgPSAnaW5pdCc7XG4gICAgICogfVxuICAgICAqXG4gICAgICogQERpcmVjdGl2ZSh7c2VsZWN0b3I6ICdjaGlsZCcsIGlucHV0czogWydwcm9wJ119KVxuICAgICAqIGNsYXNzIENoaWxkIHtcbiAgICAgKiAgIGNvbnN0cnVjdG9yKHB1YmxpYyBwYXJlbnQ6IFBhcmVudCkge31cbiAgICAgKlxuICAgICAqICAgc2V0IHByb3Aodikge1xuICAgICAqICAgICAvLyB0aGlzIHVwZGF0ZXMgdGhlIHBhcmVudCBwcm9wZXJ0eSwgd2hpY2ggaXMgZGlzYWxsb3dlZCBkdXJpbmcgY2hhbmdlIGRldGVjdGlvblxuICAgICAqICAgICAvLyB0aGlzIHdpbGwgcmVzdWx0IGluIEV4cHJlc3Npb25DaGFuZ2VkQWZ0ZXJJdEhhc0JlZW5DaGVja2VkRXJyb3JcbiAgICAgKiAgICAgdGhpcy5wYXJlbnQucGFyZW50UHJvcCA9ICd1cGRhdGVkJztcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBFeHByZXNzaW9uQ2hhbmdlZEFmdGVySXRIYXNCZWVuQ2hlY2tlZEVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDYoRXhwcmVzc2lvbkNoYW5nZWRBZnRlckl0SGFzQmVlbkNoZWNrZWRFcnJvciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gRXhwcmVzc2lvbkNoYW5nZWRBZnRlckl0SGFzQmVlbkNoZWNrZWRFcnJvcihvbGRWYWx1ZSwgY3VyclZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgbXNnID0gXCJFeHByZXNzaW9uIGhhcyBjaGFuZ2VkIGFmdGVyIGl0IHdhcyBjaGVja2VkLiBQcmV2aW91cyB2YWx1ZTogJ1wiICsgb2xkVmFsdWUgKyBcIicuIEN1cnJlbnQgdmFsdWU6ICdcIiArIGN1cnJWYWx1ZSArIFwiJy5cIjtcbiAgICAgICAgICAgIGlmIChvbGRWYWx1ZSA9PT0gVU5JTklUSUFMSVpFRCkge1xuICAgICAgICAgICAgICAgIG1zZyArPVxuICAgICAgICAgICAgICAgICAgICBcIiBJdCBzZWVtcyBsaWtlIHRoZSB2aWV3IGhhcyBiZWVuIGNyZWF0ZWQgYWZ0ZXIgaXRzIHBhcmVudCBhbmQgaXRzIGNoaWxkcmVuIGhhdmUgYmVlbiBkaXJ0eSBjaGVja2VkLlwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiIEhhcyBpdCBiZWVuIGNyZWF0ZWQgaW4gYSBjaGFuZ2UgZGV0ZWN0aW9uIGhvb2sgP1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgbXNnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRXhwcmVzc2lvbkNoYW5nZWRBZnRlckl0SGFzQmVlbkNoZWNrZWRFcnJvcjtcbiAgICB9KEJhc2VFcnJvcikpO1xuICAgIC8qKlxuICAgICAqIFRocm93biB3aGVuIGFuIGV4Y2VwdGlvbiB3YXMgcmFpc2VkIGR1cmluZyB2aWV3IGNyZWF0aW9uLCBjaGFuZ2UgZGV0ZWN0aW9uIG9yIGRlc3RydWN0aW9uLlxuICAgICAqXG4gICAgICogVGhpcyBlcnJvciB3cmFwcyB0aGUgb3JpZ2luYWwgZXhjZXB0aW9uIHRvIGF0dGFjaCBhZGRpdGlvbmFsIGNvbnRleHR1YWwgaW5mb3JtYXRpb24gdGhhdCBjYW5cbiAgICAgKiBiZSB1c2VmdWwgZm9yIGRlYnVnZ2luZy5cbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIFZpZXdXcmFwcGVkRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkNihWaWV3V3JhcHBlZEVycm9yLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBWaWV3V3JhcHBlZEVycm9yKG9yaWdpbmFsRXJyb3IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIFwiRXJyb3IgaW4gXCIgKyBjb250ZXh0LnNvdXJjZSwgb3JpZ2luYWxFcnJvcik7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBWaWV3V3JhcHBlZEVycm9yO1xuICAgIH0oV3JhcHBlZEVycm9yKSk7XG4gICAgLyoqXG4gICAgICogVGhyb3duIHdoZW4gYSBkZXN0cm95ZWQgdmlldyBpcyB1c2VkLlxuICAgICAqXG4gICAgICogVGhpcyBlcnJvciBpbmRpY2F0ZXMgYSBidWcgaW4gdGhlIGZyYW1ld29yay5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgYW4gaW50ZXJuYWwgQW5ndWxhciBlcnJvci5cbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIFZpZXdEZXN0cm95ZWRFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQ2KFZpZXdEZXN0cm95ZWRFcnJvciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gVmlld0Rlc3Ryb3llZEVycm9yKGRldGFpbHMpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIFwiQXR0ZW1wdCB0byB1c2UgYSBkZXN0cm95ZWQgdmlldzogXCIgKyBkZXRhaWxzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVmlld0Rlc3Ryb3llZEVycm9yO1xuICAgIH0oQmFzZUVycm9yKSk7XG5cbiAgICB2YXIgVmlld1V0aWxzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gVmlld1V0aWxzKF9yZW5kZXJlciwgX2FwcElkLCBzYW5pdGl6ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICAgICAgdGhpcy5fYXBwSWQgPSBfYXBwSWQ7XG4gICAgICAgICAgICB0aGlzLl9uZXh0Q29tcFR5cGVJZCA9IDA7XG4gICAgICAgICAgICB0aGlzLnNhbml0aXplciA9IHNhbml0aXplcjtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVXNlZCBieSB0aGUgZ2VuZXJhdGVkIGNvZGVcbiAgICAgICAgICovXG4gICAgICAgIC8vIFRPRE8gKG1hdHNrbyk6IGFkZCB0eXBpbmcgZm9yIHRoZSBhbmltYXRpb24gZnVuY3Rpb25cbiAgICAgICAgVmlld1V0aWxzLnByb3RvdHlwZS5jcmVhdGVSZW5kZXJDb21wb25lbnRUeXBlID0gZnVuY3Rpb24gKHRlbXBsYXRlVXJsLCBzbG90Q291bnQsIGVuY2Fwc3VsYXRpb24sIHN0eWxlcywgYW5pbWF0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZW5kZXJDb21wb25lbnRUeXBlKHRoaXMuX2FwcElkICsgXCItXCIgKyB0aGlzLl9uZXh0Q29tcFR5cGVJZCsrLCB0ZW1wbGF0ZVVybCwgc2xvdENvdW50LCBlbmNhcHN1bGF0aW9uLCBzdHlsZXMsIGFuaW1hdGlvbnMpO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIFZpZXdVdGlscy5wcm90b3R5cGUucmVuZGVyQ29tcG9uZW50ID0gZnVuY3Rpb24gKHJlbmRlckNvbXBvbmVudFR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJlci5yZW5kZXJDb21wb25lbnQocmVuZGVyQ29tcG9uZW50VHlwZSk7XG4gICAgICAgIH07XG4gICAgICAgIFZpZXdVdGlscy5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBJbmplY3RhYmxlIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBWaWV3VXRpbHMuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IFJvb3RSZW5kZXJlciwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtBUFBfSUQsXSB9LF0gfSxcbiAgICAgICAgICAgIHsgdHlwZTogU2FuaXRpemVyLCB9LFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gVmlld1V0aWxzO1xuICAgIH0oKSk7XG4gICAgZnVuY3Rpb24gZmxhdHRlbk5lc3RlZFZpZXdSZW5kZXJOb2Rlcyhub2Rlcykge1xuICAgICAgICByZXR1cm4gX2ZsYXR0ZW5OZXN0ZWRWaWV3UmVuZGVyTm9kZXMobm9kZXMsIFtdKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX2ZsYXR0ZW5OZXN0ZWRWaWV3UmVuZGVyTm9kZXMobm9kZXMsIHJlbmRlck5vZGVzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFwcEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXBwRWwgPSBub2RlO1xuICAgICAgICAgICAgICAgIHJlbmRlck5vZGVzLnB1c2goYXBwRWwubmF0aXZlRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudChhcHBFbC5uZXN0ZWRWaWV3cykpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBhcHBFbC5uZXN0ZWRWaWV3cy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2ZsYXR0ZW5OZXN0ZWRWaWV3UmVuZGVyTm9kZXMoYXBwRWwubmVzdGVkVmlld3Nba10ucm9vdE5vZGVzT3JBcHBFbGVtZW50cywgcmVuZGVyTm9kZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyTm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVuZGVyTm9kZXM7XG4gICAgfVxuICAgIHZhciBFTVBUWV9BUlIgPSBbXTtcbiAgICBmdW5jdGlvbiBlbnN1cmVTbG90Q291bnQocHJvamVjdGFibGVOb2RlcywgZXhwZWN0ZWRTbG90Q291bnQpIHtcbiAgICAgICAgdmFyIHJlcztcbiAgICAgICAgaWYgKCFwcm9qZWN0YWJsZU5vZGVzKSB7XG4gICAgICAgICAgICByZXMgPSBFTVBUWV9BUlI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvamVjdGFibGVOb2Rlcy5sZW5ndGggPCBleHBlY3RlZFNsb3RDb3VudCkge1xuICAgICAgICAgICAgdmFyIGdpdmVuU2xvdENvdW50ID0gcHJvamVjdGFibGVOb2Rlcy5sZW5ndGg7XG4gICAgICAgICAgICByZXMgPSBuZXcgQXJyYXkoZXhwZWN0ZWRTbG90Q291bnQpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBlY3RlZFNsb3RDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVzW2ldID0gKGkgPCBnaXZlblNsb3RDb3VudCkgPyBwcm9qZWN0YWJsZU5vZGVzW2ldIDogRU1QVFlfQVJSO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzID0gcHJvamVjdGFibGVOb2RlcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICB2YXIgTUFYX0lOVEVSUE9MQVRJT05fVkFMVUVTID0gOTtcbiAgICBmdW5jdGlvbiBpbnRlcnBvbGF0ZSh2YWx1ZUNvdW50LCBjMCwgYTEsIGMxLCBhMiwgYzIsIGEzLCBjMywgYTQsIGM0LCBhNSwgYzUsIGE2LCBjNiwgYTcsIGM3LCBhOCwgYzgsIGE5LCBjOSkge1xuICAgICAgICBzd2l0Y2ggKHZhbHVlQ291bnQpIHtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXR1cm4gYzAgKyBfdG9TdHJpbmdXaXRoTnVsbChhMSkgKyBjMTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICByZXR1cm4gYzAgKyBfdG9TdHJpbmdXaXRoTnVsbChhMSkgKyBjMSArIF90b1N0cmluZ1dpdGhOdWxsKGEyKSArIGMyO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIHJldHVybiBjMCArIF90b1N0cmluZ1dpdGhOdWxsKGExKSArIGMxICsgX3RvU3RyaW5nV2l0aE51bGwoYTIpICsgYzIgKyBfdG9TdHJpbmdXaXRoTnVsbChhMykgK1xuICAgICAgICAgICAgICAgICAgICBjMztcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICByZXR1cm4gYzAgKyBfdG9TdHJpbmdXaXRoTnVsbChhMSkgKyBjMSArIF90b1N0cmluZ1dpdGhOdWxsKGEyKSArIGMyICsgX3RvU3RyaW5nV2l0aE51bGwoYTMpICtcbiAgICAgICAgICAgICAgICAgICAgYzMgKyBfdG9TdHJpbmdXaXRoTnVsbChhNCkgKyBjNDtcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICByZXR1cm4gYzAgKyBfdG9TdHJpbmdXaXRoTnVsbChhMSkgKyBjMSArIF90b1N0cmluZ1dpdGhOdWxsKGEyKSArIGMyICsgX3RvU3RyaW5nV2l0aE51bGwoYTMpICtcbiAgICAgICAgICAgICAgICAgICAgYzMgKyBfdG9TdHJpbmdXaXRoTnVsbChhNCkgKyBjNCArIF90b1N0cmluZ1dpdGhOdWxsKGE1KSArIGM1O1xuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgIHJldHVybiBjMCArIF90b1N0cmluZ1dpdGhOdWxsKGExKSArIGMxICsgX3RvU3RyaW5nV2l0aE51bGwoYTIpICsgYzIgKyBfdG9TdHJpbmdXaXRoTnVsbChhMykgK1xuICAgICAgICAgICAgICAgICAgICBjMyArIF90b1N0cmluZ1dpdGhOdWxsKGE0KSArIGM0ICsgX3RvU3RyaW5nV2l0aE51bGwoYTUpICsgYzUgKyBfdG9TdHJpbmdXaXRoTnVsbChhNikgKyBjNjtcbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYzAgKyBfdG9TdHJpbmdXaXRoTnVsbChhMSkgKyBjMSArIF90b1N0cmluZ1dpdGhOdWxsKGEyKSArIGMyICsgX3RvU3RyaW5nV2l0aE51bGwoYTMpICtcbiAgICAgICAgICAgICAgICAgICAgYzMgKyBfdG9TdHJpbmdXaXRoTnVsbChhNCkgKyBjNCArIF90b1N0cmluZ1dpdGhOdWxsKGE1KSArIGM1ICsgX3RvU3RyaW5nV2l0aE51bGwoYTYpICtcbiAgICAgICAgICAgICAgICAgICAgYzYgKyBfdG9TdHJpbmdXaXRoTnVsbChhNykgKyBjNztcbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICByZXR1cm4gYzAgKyBfdG9TdHJpbmdXaXRoTnVsbChhMSkgKyBjMSArIF90b1N0cmluZ1dpdGhOdWxsKGEyKSArIGMyICsgX3RvU3RyaW5nV2l0aE51bGwoYTMpICtcbiAgICAgICAgICAgICAgICAgICAgYzMgKyBfdG9TdHJpbmdXaXRoTnVsbChhNCkgKyBjNCArIF90b1N0cmluZ1dpdGhOdWxsKGE1KSArIGM1ICsgX3RvU3RyaW5nV2l0aE51bGwoYTYpICtcbiAgICAgICAgICAgICAgICAgICAgYzYgKyBfdG9TdHJpbmdXaXRoTnVsbChhNykgKyBjNyArIF90b1N0cmluZ1dpdGhOdWxsKGE4KSArIGM4O1xuICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgIHJldHVybiBjMCArIF90b1N0cmluZ1dpdGhOdWxsKGExKSArIGMxICsgX3RvU3RyaW5nV2l0aE51bGwoYTIpICsgYzIgKyBfdG9TdHJpbmdXaXRoTnVsbChhMykgK1xuICAgICAgICAgICAgICAgICAgICBjMyArIF90b1N0cmluZ1dpdGhOdWxsKGE0KSArIGM0ICsgX3RvU3RyaW5nV2l0aE51bGwoYTUpICsgYzUgKyBfdG9TdHJpbmdXaXRoTnVsbChhNikgK1xuICAgICAgICAgICAgICAgICAgICBjNiArIF90b1N0cmluZ1dpdGhOdWxsKGE3KSArIGM3ICsgX3RvU3RyaW5nV2l0aE51bGwoYTgpICsgYzggKyBfdG9TdHJpbmdXaXRoTnVsbChhOSkgKyBjOTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRG9lcyBub3Qgc3VwcG9ydCBtb3JlIHRoYW4gOSBleHByZXNzaW9uc1wiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBfdG9TdHJpbmdXaXRoTnVsbCh2KSB7XG4gICAgICAgIHJldHVybiB2ICE9IG51bGwgPyB2LnRvU3RyaW5nKCkgOiAnJztcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tCaW5kaW5nKHRocm93T25DaGFuZ2UsIG9sZFZhbHVlLCBuZXdWYWx1ZSkge1xuICAgICAgICBpZiAodGhyb3dPbkNoYW5nZSkge1xuICAgICAgICAgICAgaWYgKCFkZXZNb2RlRXF1YWwob2xkVmFsdWUsIG5ld1ZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFeHByZXNzaW9uQ2hhbmdlZEFmdGVySXRIYXNCZWVuQ2hlY2tlZEVycm9yKG9sZFZhbHVlLCBuZXdWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gIWxvb3NlSWRlbnRpY2FsKG9sZFZhbHVlLCBuZXdWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY2FzdEJ5VmFsdWUoaW5wdXQsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG4gICAgdmFyIEVNUFRZX0FSUkFZID0gW107XG4gICAgdmFyIEVNUFRZX01BUCA9IHt9O1xuICAgIGZ1bmN0aW9uIHB1cmVQcm94eTEoZm4pIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdmFyIHYwID0gVU5JTklUSUFMSVpFRDtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwMCkge1xuICAgICAgICAgICAgaWYgKCFsb29zZUlkZW50aWNhbCh2MCwgcDApKSB7XG4gICAgICAgICAgICAgICAgdjAgPSBwMDtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmbihwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXJlUHJveHkyKGZuKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHZhciB2MCA9IFVOSU5JVElBTElaRUQ7XG4gICAgICAgIHZhciB2MSA9IFVOSU5JVElBTElaRUQ7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocDAsIHAxKSB7XG4gICAgICAgICAgICBpZiAoIWxvb3NlSWRlbnRpY2FsKHYwLCBwMCkgfHwgIWxvb3NlSWRlbnRpY2FsKHYxLCBwMSkpIHtcbiAgICAgICAgICAgICAgICB2MCA9IHAwO1xuICAgICAgICAgICAgICAgIHYxID0gcDE7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZm4ocDAsIHAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1cmVQcm94eTMoZm4pIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdmFyIHYwID0gVU5JTklUSUFMSVpFRDtcbiAgICAgICAgdmFyIHYxID0gVU5JTklUSUFMSVpFRDtcbiAgICAgICAgdmFyIHYyID0gVU5JTklUSUFMSVpFRDtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwMCwgcDEsIHAyKSB7XG4gICAgICAgICAgICBpZiAoIWxvb3NlSWRlbnRpY2FsKHYwLCBwMCkgfHwgIWxvb3NlSWRlbnRpY2FsKHYxLCBwMSkgfHwgIWxvb3NlSWRlbnRpY2FsKHYyLCBwMikpIHtcbiAgICAgICAgICAgICAgICB2MCA9IHAwO1xuICAgICAgICAgICAgICAgIHYxID0gcDE7XG4gICAgICAgICAgICAgICAgdjIgPSBwMjtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmbihwMCwgcDEsIHAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1cmVQcm94eTQoZm4pIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdmFyIHYwLCB2MSwgdjIsIHYzO1xuICAgICAgICB2MCA9IHYxID0gdjIgPSB2MyA9IFVOSU5JVElBTElaRUQ7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocDAsIHAxLCBwMiwgcDMpIHtcbiAgICAgICAgICAgIGlmICghbG9vc2VJZGVudGljYWwodjAsIHAwKSB8fCAhbG9vc2VJZGVudGljYWwodjEsIHAxKSB8fCAhbG9vc2VJZGVudGljYWwodjIsIHAyKSB8fFxuICAgICAgICAgICAgICAgICFsb29zZUlkZW50aWNhbCh2MywgcDMpKSB7XG4gICAgICAgICAgICAgICAgdjAgPSBwMDtcbiAgICAgICAgICAgICAgICB2MSA9IHAxO1xuICAgICAgICAgICAgICAgIHYyID0gcDI7XG4gICAgICAgICAgICAgICAgdjMgPSBwMztcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmbihwMCwgcDEsIHAyLCBwMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXJlUHJveHk1KGZuKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHZhciB2MCwgdjEsIHYyLCB2MywgdjQ7XG4gICAgICAgIHYwID0gdjEgPSB2MiA9IHYzID0gdjQgPSBVTklOSVRJQUxJWkVEO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHAwLCBwMSwgcDIsIHAzLCBwNCkge1xuICAgICAgICAgICAgaWYgKCFsb29zZUlkZW50aWNhbCh2MCwgcDApIHx8ICFsb29zZUlkZW50aWNhbCh2MSwgcDEpIHx8ICFsb29zZUlkZW50aWNhbCh2MiwgcDIpIHx8XG4gICAgICAgICAgICAgICAgIWxvb3NlSWRlbnRpY2FsKHYzLCBwMykgfHwgIWxvb3NlSWRlbnRpY2FsKHY0LCBwNCkpIHtcbiAgICAgICAgICAgICAgICB2MCA9IHAwO1xuICAgICAgICAgICAgICAgIHYxID0gcDE7XG4gICAgICAgICAgICAgICAgdjIgPSBwMjtcbiAgICAgICAgICAgICAgICB2MyA9IHAzO1xuICAgICAgICAgICAgICAgIHY0ID0gcDQ7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZm4ocDAsIHAxLCBwMiwgcDMsIHA0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1cmVQcm94eTYoZm4pIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdmFyIHYwLCB2MSwgdjIsIHYzLCB2NCwgdjU7XG4gICAgICAgIHYwID0gdjEgPSB2MiA9IHYzID0gdjQgPSB2NSA9IFVOSU5JVElBTElaRUQ7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocDAsIHAxLCBwMiwgcDMsIHA0LCBwNSkge1xuICAgICAgICAgICAgaWYgKCFsb29zZUlkZW50aWNhbCh2MCwgcDApIHx8ICFsb29zZUlkZW50aWNhbCh2MSwgcDEpIHx8ICFsb29zZUlkZW50aWNhbCh2MiwgcDIpIHx8XG4gICAgICAgICAgICAgICAgIWxvb3NlSWRlbnRpY2FsKHYzLCBwMykgfHwgIWxvb3NlSWRlbnRpY2FsKHY0LCBwNCkgfHwgIWxvb3NlSWRlbnRpY2FsKHY1LCBwNSkpIHtcbiAgICAgICAgICAgICAgICB2MCA9IHAwO1xuICAgICAgICAgICAgICAgIHYxID0gcDE7XG4gICAgICAgICAgICAgICAgdjIgPSBwMjtcbiAgICAgICAgICAgICAgICB2MyA9IHAzO1xuICAgICAgICAgICAgICAgIHY0ID0gcDQ7XG4gICAgICAgICAgICAgICAgdjUgPSBwNTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmbihwMCwgcDEsIHAyLCBwMywgcDQsIHA1KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1cmVQcm94eTcoZm4pIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdmFyIHYwLCB2MSwgdjIsIHYzLCB2NCwgdjUsIHY2O1xuICAgICAgICB2MCA9IHYxID0gdjIgPSB2MyA9IHY0ID0gdjUgPSB2NiA9IFVOSU5JVElBTElaRUQ7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocDAsIHAxLCBwMiwgcDMsIHA0LCBwNSwgcDYpIHtcbiAgICAgICAgICAgIGlmICghbG9vc2VJZGVudGljYWwodjAsIHAwKSB8fCAhbG9vc2VJZGVudGljYWwodjEsIHAxKSB8fCAhbG9vc2VJZGVudGljYWwodjIsIHAyKSB8fFxuICAgICAgICAgICAgICAgICFsb29zZUlkZW50aWNhbCh2MywgcDMpIHx8ICFsb29zZUlkZW50aWNhbCh2NCwgcDQpIHx8ICFsb29zZUlkZW50aWNhbCh2NSwgcDUpIHx8XG4gICAgICAgICAgICAgICAgIWxvb3NlSWRlbnRpY2FsKHY2LCBwNikpIHtcbiAgICAgICAgICAgICAgICB2MCA9IHAwO1xuICAgICAgICAgICAgICAgIHYxID0gcDE7XG4gICAgICAgICAgICAgICAgdjIgPSBwMjtcbiAgICAgICAgICAgICAgICB2MyA9IHAzO1xuICAgICAgICAgICAgICAgIHY0ID0gcDQ7XG4gICAgICAgICAgICAgICAgdjUgPSBwNTtcbiAgICAgICAgICAgICAgICB2NiA9IHA2O1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZuKHAwLCBwMSwgcDIsIHAzLCBwNCwgcDUsIHA2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1cmVQcm94eTgoZm4pIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdmFyIHYwLCB2MSwgdjIsIHYzLCB2NCwgdjUsIHY2LCB2NztcbiAgICAgICAgdjAgPSB2MSA9IHYyID0gdjMgPSB2NCA9IHY1ID0gdjYgPSB2NyA9IFVOSU5JVElBTElaRUQ7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocDAsIHAxLCBwMiwgcDMsIHA0LCBwNSwgcDYsIHA3KSB7XG4gICAgICAgICAgICBpZiAoIWxvb3NlSWRlbnRpY2FsKHYwLCBwMCkgfHwgIWxvb3NlSWRlbnRpY2FsKHYxLCBwMSkgfHwgIWxvb3NlSWRlbnRpY2FsKHYyLCBwMikgfHxcbiAgICAgICAgICAgICAgICAhbG9vc2VJZGVudGljYWwodjMsIHAzKSB8fCAhbG9vc2VJZGVudGljYWwodjQsIHA0KSB8fCAhbG9vc2VJZGVudGljYWwodjUsIHA1KSB8fFxuICAgICAgICAgICAgICAgICFsb29zZUlkZW50aWNhbCh2NiwgcDYpIHx8ICFsb29zZUlkZW50aWNhbCh2NywgcDcpKSB7XG4gICAgICAgICAgICAgICAgdjAgPSBwMDtcbiAgICAgICAgICAgICAgICB2MSA9IHAxO1xuICAgICAgICAgICAgICAgIHYyID0gcDI7XG4gICAgICAgICAgICAgICAgdjMgPSBwMztcbiAgICAgICAgICAgICAgICB2NCA9IHA0O1xuICAgICAgICAgICAgICAgIHY1ID0gcDU7XG4gICAgICAgICAgICAgICAgdjYgPSBwNjtcbiAgICAgICAgICAgICAgICB2NyA9IHA3O1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZuKHAwLCBwMSwgcDIsIHAzLCBwNCwgcDUsIHA2LCBwNyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXJlUHJveHk5KGZuKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHZhciB2MCwgdjEsIHYyLCB2MywgdjQsIHY1LCB2NiwgdjcsIHY4O1xuICAgICAgICB2MCA9IHYxID0gdjIgPSB2MyA9IHY0ID0gdjUgPSB2NiA9IHY3ID0gdjggPSBVTklOSVRJQUxJWkVEO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHAwLCBwMSwgcDIsIHAzLCBwNCwgcDUsIHA2LCBwNywgcDgpIHtcbiAgICAgICAgICAgIGlmICghbG9vc2VJZGVudGljYWwodjAsIHAwKSB8fCAhbG9vc2VJZGVudGljYWwodjEsIHAxKSB8fCAhbG9vc2VJZGVudGljYWwodjIsIHAyKSB8fFxuICAgICAgICAgICAgICAgICFsb29zZUlkZW50aWNhbCh2MywgcDMpIHx8ICFsb29zZUlkZW50aWNhbCh2NCwgcDQpIHx8ICFsb29zZUlkZW50aWNhbCh2NSwgcDUpIHx8XG4gICAgICAgICAgICAgICAgIWxvb3NlSWRlbnRpY2FsKHY2LCBwNikgfHwgIWxvb3NlSWRlbnRpY2FsKHY3LCBwNykgfHwgIWxvb3NlSWRlbnRpY2FsKHY4LCBwOCkpIHtcbiAgICAgICAgICAgICAgICB2MCA9IHAwO1xuICAgICAgICAgICAgICAgIHYxID0gcDE7XG4gICAgICAgICAgICAgICAgdjIgPSBwMjtcbiAgICAgICAgICAgICAgICB2MyA9IHAzO1xuICAgICAgICAgICAgICAgIHY0ID0gcDQ7XG4gICAgICAgICAgICAgICAgdjUgPSBwNTtcbiAgICAgICAgICAgICAgICB2NiA9IHA2O1xuICAgICAgICAgICAgICAgIHY3ID0gcDc7XG4gICAgICAgICAgICAgICAgdjggPSBwODtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmbihwMCwgcDEsIHAyLCBwMywgcDQsIHA1LCBwNiwgcDcsIHA4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1cmVQcm94eTEwKGZuKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHZhciB2MCwgdjEsIHYyLCB2MywgdjQsIHY1LCB2NiwgdjcsIHY4LCB2OTtcbiAgICAgICAgdjAgPSB2MSA9IHYyID0gdjMgPSB2NCA9IHY1ID0gdjYgPSB2NyA9IHY4ID0gdjkgPSBVTklOSVRJQUxJWkVEO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHAwLCBwMSwgcDIsIHAzLCBwNCwgcDUsIHA2LCBwNywgcDgsIHA5KSB7XG4gICAgICAgICAgICBpZiAoIWxvb3NlSWRlbnRpY2FsKHYwLCBwMCkgfHwgIWxvb3NlSWRlbnRpY2FsKHYxLCBwMSkgfHwgIWxvb3NlSWRlbnRpY2FsKHYyLCBwMikgfHxcbiAgICAgICAgICAgICAgICAhbG9vc2VJZGVudGljYWwodjMsIHAzKSB8fCAhbG9vc2VJZGVudGljYWwodjQsIHA0KSB8fCAhbG9vc2VJZGVudGljYWwodjUsIHA1KSB8fFxuICAgICAgICAgICAgICAgICFsb29zZUlkZW50aWNhbCh2NiwgcDYpIHx8ICFsb29zZUlkZW50aWNhbCh2NywgcDcpIHx8ICFsb29zZUlkZW50aWNhbCh2OCwgcDgpIHx8XG4gICAgICAgICAgICAgICAgIWxvb3NlSWRlbnRpY2FsKHY5LCBwOSkpIHtcbiAgICAgICAgICAgICAgICB2MCA9IHAwO1xuICAgICAgICAgICAgICAgIHYxID0gcDE7XG4gICAgICAgICAgICAgICAgdjIgPSBwMjtcbiAgICAgICAgICAgICAgICB2MyA9IHAzO1xuICAgICAgICAgICAgICAgIHY0ID0gcDQ7XG4gICAgICAgICAgICAgICAgdjUgPSBwNTtcbiAgICAgICAgICAgICAgICB2NiA9IHA2O1xuICAgICAgICAgICAgICAgIHY3ID0gcDc7XG4gICAgICAgICAgICAgICAgdjggPSBwODtcbiAgICAgICAgICAgICAgICB2OSA9IHA5O1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZuKHAwLCBwMSwgcDIsIHAzLCBwNCwgcDUsIHA2LCBwNywgcDgsIHA5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldEJpbmRpbmdEZWJ1Z0luZm9Gb3JDaGFuZ2VzKHJlbmRlcmVyLCBlbCwgY2hhbmdlcykge1xuICAgICAgICBPYmplY3Qua2V5cyhjaGFuZ2VzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICAgICAgICAgICAgc2V0QmluZGluZ0RlYnVnSW5mbyhyZW5kZXJlciwgZWwsIHByb3BOYW1lLCBjaGFuZ2VzW3Byb3BOYW1lXS5jdXJyZW50VmFsdWUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0QmluZGluZ0RlYnVnSW5mbyhyZW5kZXJlciwgZWwsIHByb3BOYW1lLCB2YWx1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVuZGVyZXIuc2V0QmluZGluZ0RlYnVnSW5mbyhlbCwgXCJuZy1yZWZsZWN0LVwiICsgY2FtZWxDYXNlVG9EYXNoQ2FzZShwcm9wTmFtZSksIHZhbHVlID8gdmFsdWUudG9TdHJpbmcoKSA6IG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZW5kZXJlci5zZXRCaW5kaW5nRGVidWdJbmZvKGVsLCBcIm5nLXJlZmxlY3QtXCIgKyBjYW1lbENhc2VUb0Rhc2hDYXNlKHByb3BOYW1lKSwgJ1tFUlJPUl0gRXhjZXB0aW9uIHdoaWxlIHRyeWluZyB0byBzZXJpYWxpemUgdGhlIHZhbHVlJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIENBTUVMX0NBU0VfUkVHRVhQID0gLyhbQS1aXSkvZztcbiAgICBmdW5jdGlvbiBjYW1lbENhc2VUb0Rhc2hDYXNlKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKENBTUVMX0NBU0VfUkVHRVhQLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbSA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBtW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICctJyArIG1bMV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG5cbiAgICB2YXIgdmlld191dGlscyA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBWaWV3VXRpbHM6IFZpZXdVdGlscyxcbiAgICAgICAgZmxhdHRlbk5lc3RlZFZpZXdSZW5kZXJOb2RlczogZmxhdHRlbk5lc3RlZFZpZXdSZW5kZXJOb2RlcyxcbiAgICAgICAgZW5zdXJlU2xvdENvdW50OiBlbnN1cmVTbG90Q291bnQsXG4gICAgICAgIE1BWF9JTlRFUlBPTEFUSU9OX1ZBTFVFUzogTUFYX0lOVEVSUE9MQVRJT05fVkFMVUVTLFxuICAgICAgICBpbnRlcnBvbGF0ZTogaW50ZXJwb2xhdGUsXG4gICAgICAgIGNoZWNrQmluZGluZzogY2hlY2tCaW5kaW5nLFxuICAgICAgICBjYXN0QnlWYWx1ZTogY2FzdEJ5VmFsdWUsXG4gICAgICAgIEVNUFRZX0FSUkFZOiBFTVBUWV9BUlJBWSxcbiAgICAgICAgRU1QVFlfTUFQOiBFTVBUWV9NQVAsXG4gICAgICAgIHB1cmVQcm94eTE6IHB1cmVQcm94eTEsXG4gICAgICAgIHB1cmVQcm94eTI6IHB1cmVQcm94eTIsXG4gICAgICAgIHB1cmVQcm94eTM6IHB1cmVQcm94eTMsXG4gICAgICAgIHB1cmVQcm94eTQ6IHB1cmVQcm94eTQsXG4gICAgICAgIHB1cmVQcm94eTU6IHB1cmVQcm94eTUsXG4gICAgICAgIHB1cmVQcm94eTY6IHB1cmVQcm94eTYsXG4gICAgICAgIHB1cmVQcm94eTc6IHB1cmVQcm94eTcsXG4gICAgICAgIHB1cmVQcm94eTg6IHB1cmVQcm94eTgsXG4gICAgICAgIHB1cmVQcm94eTk6IHB1cmVQcm94eTksXG4gICAgICAgIHB1cmVQcm94eTEwOiBwdXJlUHJveHkxMCxcbiAgICAgICAgc2V0QmluZGluZ0RlYnVnSW5mb0ZvckNoYW5nZXM6IHNldEJpbmRpbmdEZWJ1Z0luZm9Gb3JDaGFuZ2VzLFxuICAgICAgICBzZXRCaW5kaW5nRGVidWdJbmZvOiBzZXRCaW5kaW5nRGVidWdJbmZvXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQ1ID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhbiBpbnN0YW5jZSBvZiBhIENvbXBvbmVudCBjcmVhdGVkIHZpYSBhIHtAbGluayBDb21wb25lbnRGYWN0b3J5fS5cbiAgICAgKlxuICAgICAqIGBDb21wb25lbnRSZWZgIHByb3ZpZGVzIGFjY2VzcyB0byB0aGUgQ29tcG9uZW50IEluc3RhbmNlIGFzIHdlbGwgb3RoZXIgb2JqZWN0cyByZWxhdGVkIHRvIHRoaXNcbiAgICAgKiBDb21wb25lbnQgSW5zdGFuY2UgYW5kIGFsbG93cyB5b3UgdG8gZGVzdHJveSB0aGUgQ29tcG9uZW50IEluc3RhbmNlIHZpYSB0aGUge0BsaW5rICNkZXN0cm95fVxuICAgICAqIG1ldGhvZC5cbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIENvbXBvbmVudFJlZiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIENvbXBvbmVudFJlZigpIHtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50UmVmLnByb3RvdHlwZSwgXCJsb2NhdGlvblwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIExvY2F0aW9uIG9mIHRoZSBIb3N0IEVsZW1lbnQgb2YgdGhpcyBDb21wb25lbnQgSW5zdGFuY2UuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudFJlZi5wcm90b3R5cGUsIFwiaW5qZWN0b3JcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgaW5qZWN0b3Igb24gd2hpY2ggdGhlIGNvbXBvbmVudCBpbnN0YW5jZSBleGlzdHMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudFJlZi5wcm90b3R5cGUsIFwiaW5zdGFuY2VcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgaW5zdGFuY2Ugb2YgdGhlIENvbXBvbmVudC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmltcGxlbWVudGVkKCk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICA7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnRSZWYucHJvdG90eXBlLCBcImhvc3RWaWV3XCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIHtAbGluayBWaWV3UmVmfSBvZiB0aGUgSG9zdCBWaWV3IG9mIHRoaXMgQ29tcG9uZW50IGluc3RhbmNlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaW1wbGVtZW50ZWQoKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIDtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudFJlZi5wcm90b3R5cGUsIFwiY2hhbmdlRGV0ZWN0b3JSZWZcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUge0BsaW5rIENoYW5nZURldGVjdG9yUmVmfSBvZiB0aGUgQ29tcG9uZW50IGluc3RhbmNlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaW1wbGVtZW50ZWQoKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnRSZWYucHJvdG90eXBlLCBcImNvbXBvbmVudFR5cGVcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgY29tcG9uZW50IHR5cGUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIENvbXBvbmVudFJlZjtcbiAgICB9KCkpO1xuICAgIHZhciBDb21wb25lbnRSZWZfID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDUoQ29tcG9uZW50UmVmXywgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gQ29tcG9uZW50UmVmXyhfaG9zdEVsZW1lbnQsIF9jb21wb25lbnRUeXBlKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX2hvc3RFbGVtZW50ID0gX2hvc3RFbGVtZW50O1xuICAgICAgICAgICAgdGhpcy5fY29tcG9uZW50VHlwZSA9IF9jb21wb25lbnRUeXBlO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnRSZWZfLnByb3RvdHlwZSwgXCJsb2NhdGlvblwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2hvc3RFbGVtZW50LmVsZW1lbnRSZWY7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50UmVmXy5wcm90b3R5cGUsIFwiaW5qZWN0b3JcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9ob3N0RWxlbWVudC5pbmplY3RvcjsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnRSZWZfLnByb3RvdHlwZSwgXCJpbnN0YW5jZVwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2hvc3RFbGVtZW50LmNvbXBvbmVudDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIDtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudFJlZl8ucHJvdG90eXBlLCBcImhvc3RWaWV3XCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5faG9zdEVsZW1lbnQucGFyZW50Vmlldy5yZWY7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICA7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnRSZWZfLnByb3RvdHlwZSwgXCJjaGFuZ2VEZXRlY3RvclJlZlwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2hvc3RFbGVtZW50LnBhcmVudFZpZXcucmVmOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50UmVmXy5wcm90b3R5cGUsIFwiY29tcG9uZW50VHlwZVwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NvbXBvbmVudFR5cGU7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBDb21wb25lbnRSZWZfLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9ob3N0RWxlbWVudC5wYXJlbnRWaWV3LmRlc3Ryb3koKTsgfTtcbiAgICAgICAgQ29tcG9uZW50UmVmXy5wcm90b3R5cGUub25EZXN0cm95ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7IHRoaXMuaG9zdFZpZXcub25EZXN0cm95KGNhbGxiYWNrKTsgfTtcbiAgICAgICAgcmV0dXJuIENvbXBvbmVudFJlZl87XG4gICAgfShDb21wb25lbnRSZWYpKTtcbiAgICAvKipcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgdmFyIEVNUFRZX0NPTlRFWFQgPSBuZXcgT2JqZWN0KCk7XG4gICAgLyoqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBDb21wb25lbnRGYWN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQ29tcG9uZW50RmFjdG9yeShzZWxlY3RvciwgX3ZpZXdGYWN0b3J5LCBfY29tcG9uZW50VHlwZSkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgICAgICAgICAgdGhpcy5fdmlld0ZhY3RvcnkgPSBfdmlld0ZhY3Rvcnk7XG4gICAgICAgICAgICB0aGlzLl9jb21wb25lbnRUeXBlID0gX2NvbXBvbmVudFR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudEZhY3RvcnkucHJvdG90eXBlLCBcImNvbXBvbmVudFR5cGVcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jb21wb25lbnRUeXBlOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgY29tcG9uZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgQ29tcG9uZW50RmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKGluamVjdG9yLCBwcm9qZWN0YWJsZU5vZGVzLCByb290U2VsZWN0b3JPck5vZGUpIHtcbiAgICAgICAgICAgIGlmIChwcm9qZWN0YWJsZU5vZGVzID09PSB2b2lkIDApIHsgcHJvamVjdGFibGVOb2RlcyA9IG51bGw7IH1cbiAgICAgICAgICAgIGlmIChyb290U2VsZWN0b3JPck5vZGUgPT09IHZvaWQgMCkgeyByb290U2VsZWN0b3JPck5vZGUgPSBudWxsOyB9XG4gICAgICAgICAgICB2YXIgdnUgPSBpbmplY3Rvci5nZXQoVmlld1V0aWxzKTtcbiAgICAgICAgICAgIGlmICghcHJvamVjdGFibGVOb2Rlcykge1xuICAgICAgICAgICAgICAgIHByb2plY3RhYmxlTm9kZXMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vdGU6IEhvc3Qgdmlld3MgZG9uJ3QgbmVlZCBhIGRlY2xhcmF0aW9uQXBwRWxlbWVudCFcbiAgICAgICAgICAgIHZhciBob3N0VmlldyA9IHRoaXMuX3ZpZXdGYWN0b3J5KHZ1LCBpbmplY3RvciwgbnVsbCk7XG4gICAgICAgICAgICB2YXIgaG9zdEVsZW1lbnQgPSBob3N0Vmlldy5jcmVhdGUoRU1QVFlfQ09OVEVYVCwgcHJvamVjdGFibGVOb2Rlcywgcm9vdFNlbGVjdG9yT3JOb2RlKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcG9uZW50UmVmXyhob3N0RWxlbWVudCwgdGhpcy5fY29tcG9uZW50VHlwZSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBDb21wb25lbnRGYWN0b3J5O1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQ3ID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBOb0NvbXBvbmVudEZhY3RvcnlFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQ3KE5vQ29tcG9uZW50RmFjdG9yeUVycm9yLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBOb0NvbXBvbmVudEZhY3RvcnlFcnJvcihjb21wb25lbnQpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIFwiTm8gY29tcG9uZW50IGZhY3RvcnkgZm91bmQgZm9yIFwiICsgc3RyaW5naWZ5KGNvbXBvbmVudCkpO1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE5vQ29tcG9uZW50RmFjdG9yeUVycm9yO1xuICAgIH0oQmFzZUVycm9yKSk7XG4gICAgdmFyIF9OdWxsQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gX051bGxDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIoKSB7XG4gICAgICAgIH1cbiAgICAgICAgX051bGxDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIucHJvdG90eXBlLnJlc29sdmVDb21wb25lbnRGYWN0b3J5ID0gZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE5vQ29tcG9uZW50RmFjdG9yeUVycm9yKGNvbXBvbmVudCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfTnVsbENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcjtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyKCkge1xuICAgICAgICB9XG4gICAgICAgIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlci5OVUxMID0gbmV3IF9OdWxsQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyKCk7XG4gICAgICAgIHJldHVybiBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXI7XG4gICAgfSgpKTtcbiAgICB2YXIgQ29kZWdlbkNvbXBvbmVudEZhY3RvcnlSZXNvbHZlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIENvZGVnZW5Db21wb25lbnRGYWN0b3J5UmVzb2x2ZXIoZmFjdG9yaWVzLCBfcGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJlbnQgPSBfcGFyZW50O1xuICAgICAgICAgICAgdGhpcy5fZmFjdG9yaWVzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmYWN0b3JpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZmFjdG9yeSA9IGZhY3Rvcmllc1tpXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9mYWN0b3JpZXMuc2V0KGZhY3RvcnkuY29tcG9uZW50VHlwZSwgZmFjdG9yeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgQ29kZWdlbkNvbXBvbmVudEZhY3RvcnlSZXNvbHZlci5wcm90b3R5cGUucmVzb2x2ZUNvbXBvbmVudEZhY3RvcnkgPSBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fZmFjdG9yaWVzLmdldChjb21wb25lbnQpO1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9wYXJlbnQucmVzb2x2ZUNvbXBvbmVudEZhY3RvcnkoY29tcG9uZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBDb2RlZ2VuQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQ4ID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVXNlIGJ5IGRpcmVjdGl2ZXMgYW5kIGNvbXBvbmVudHMgdG8gZW1pdCBjdXN0b20gRXZlbnRzLlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGVzXG4gICAgICpcbiAgICAgKiBJbiB0aGUgZm9sbG93aW5nIGV4YW1wbGUsIGBaaXBweWAgYWx0ZXJuYXRpdmVseSBlbWl0cyBgb3BlbmAgYW5kIGBjbG9zZWAgZXZlbnRzIHdoZW4gaXRzXG4gICAgICogdGl0bGUgZ2V0cyBjbGlja2VkOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogQENvbXBvbmVudCh7XG4gICAgICogICBzZWxlY3RvcjogJ3ppcHB5JyxcbiAgICAgKiAgIHRlbXBsYXRlOiBgXG4gICAgICogICA8ZGl2IGNsYXNzPVwiemlwcHlcIj5cbiAgICAgKiAgICAgPGRpdiAoY2xpY2spPVwidG9nZ2xlKClcIj5Ub2dnbGU8L2Rpdj5cbiAgICAgKiAgICAgPGRpdiBbaGlkZGVuXT1cIiF2aXNpYmxlXCI+XG4gICAgICogICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgICAqICAgICA8L2Rpdj5cbiAgICAgKiAgPC9kaXY+YH0pXG4gICAgICogZXhwb3J0IGNsYXNzIFppcHB5IHtcbiAgICAgKiAgIHZpc2libGU6IGJvb2xlYW4gPSB0cnVlO1xuICAgICAqICAgQE91dHB1dCgpIG9wZW46IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAqICAgQE91dHB1dCgpIGNsb3NlOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgKlxuICAgICAqICAgdG9nZ2xlKCkge1xuICAgICAqICAgICB0aGlzLnZpc2libGUgPSAhdGhpcy52aXNpYmxlO1xuICAgICAqICAgICBpZiAodGhpcy52aXNpYmxlKSB7XG4gICAgICogICAgICAgdGhpcy5vcGVuLmVtaXQobnVsbCk7XG4gICAgICogICAgIH0gZWxzZSB7XG4gICAgICogICAgICAgdGhpcy5jbG9zZS5lbWl0KG51bGwpO1xuICAgICAqICAgICB9XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogVGhlIGV2ZW50cyBwYXlsb2FkIGNhbiBiZSBhY2Nlc3NlZCBieSB0aGUgcGFyYW1ldGVyIGAkZXZlbnRgIG9uIHRoZSBjb21wb25lbnRzIG91dHB1dCBldmVudFxuICAgICAqIGhhbmRsZXI6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiA8emlwcHkgKG9wZW4pPVwib25PcGVuKCRldmVudClcIiAoY2xvc2UpPVwib25DbG9zZSgkZXZlbnQpXCI+PC96aXBweT5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFVzZXMgUnguT2JzZXJ2YWJsZSBidXQgcHJvdmlkZXMgYW4gYWRhcHRlciB0byBtYWtlIGl0IHdvcmsgYXMgc3BlY2lmaWVkIGhlcmU6XG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL2podXNhaW4vb2JzZXJ2YWJsZS1zcGVjXG4gICAgICpcbiAgICAgKiBPbmNlIGEgcmVmZXJlbmNlIGltcGxlbWVudGF0aW9uIG9mIHRoZSBzcGVjIGlzIGF2YWlsYWJsZSwgc3dpdGNoIHRvIGl0LlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgRXZlbnRFbWl0dGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDgoRXZlbnRFbWl0dGVyLCBfc3VwZXIpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBbRXZlbnRFbWl0dGVyXSwgd2hpY2ggZGVwZW5kaW5nIG9uIFtpc0FzeW5jXSxcbiAgICAgICAgICogZGVsaXZlcnMgZXZlbnRzIHN5bmNocm9ub3VzbHkgb3IgYXN5bmNocm9ub3VzbHkuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBFdmVudEVtaXR0ZXIoaXNBc3luYykge1xuICAgICAgICAgICAgaWYgKGlzQXN5bmMgPT09IHZvaWQgMCkgeyBpc0FzeW5jID0gZmFsc2U7IH1cbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fX2lzQXN5bmMgPSBpc0FzeW5jO1xuICAgICAgICB9XG4gICAgICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uICh2YWx1ZSkgeyBfc3VwZXIucHJvdG90eXBlLm5leHQuY2FsbCh0aGlzLCB2YWx1ZSk7IH07XG4gICAgICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKGdlbmVyYXRvck9yTmV4dCwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgICAgICAgICB2YXIgc2NoZWR1bGVyRm47XG4gICAgICAgICAgICB2YXIgZXJyb3JGbiA9IGZ1bmN0aW9uIChlcnIpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgICAgICAgICB2YXIgY29tcGxldGVGbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgICAgICAgICBpZiAoZ2VuZXJhdG9yT3JOZXh0ICYmIHR5cGVvZiBnZW5lcmF0b3JPck5leHQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgc2NoZWR1bGVyRm4gPSB0aGlzLl9faXNBc3luYyA/IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdlbmVyYXRvck9yTmV4dC5uZXh0KHZhbHVlKTsgfSk7XG4gICAgICAgICAgICAgICAgfSA6IGZ1bmN0aW9uICh2YWx1ZSkgeyBnZW5lcmF0b3JPck5leHQubmV4dCh2YWx1ZSk7IH07XG4gICAgICAgICAgICAgICAgaWYgKGdlbmVyYXRvck9yTmV4dC5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBlcnJvckZuID0gdGhpcy5fX2lzQXN5bmMgPyBmdW5jdGlvbiAoZXJyKSB7IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2VuZXJhdG9yT3JOZXh0LmVycm9yKGVycik7IH0pOyB9IDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlcnIpIHsgZ2VuZXJhdG9yT3JOZXh0LmVycm9yKGVycik7IH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChnZW5lcmF0b3JPck5leHQuY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGVGbiA9IHRoaXMuX19pc0FzeW5jID8gZnVuY3Rpb24gKCkgeyBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdlbmVyYXRvck9yTmV4dC5jb21wbGV0ZSgpOyB9KTsgfSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7IGdlbmVyYXRvck9yTmV4dC5jb21wbGV0ZSgpOyB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNjaGVkdWxlckZuID0gdGhpcy5fX2lzQXN5bmMgPyBmdW5jdGlvbiAodmFsdWUpIHsgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBnZW5lcmF0b3JPck5leHQodmFsdWUpOyB9KTsgfSA6XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICh2YWx1ZSkgeyBnZW5lcmF0b3JPck5leHQodmFsdWUpOyB9O1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBlcnJvckZuID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX19pc0FzeW5jID8gZnVuY3Rpb24gKGVycikgeyBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVycm9yKGVycik7IH0pOyB9IDogZnVuY3Rpb24gKGVycikgeyBlcnJvcihlcnIpOyB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGVGbiA9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9faXNBc3luYyA/IGZ1bmN0aW9uICgpIHsgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBjb21wbGV0ZSgpOyB9KTsgfSA6IGZ1bmN0aW9uICgpIHsgY29tcGxldGUoKTsgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5zdWJzY3JpYmUuY2FsbCh0aGlzLCBzY2hlZHVsZXJGbiwgZXJyb3JGbiwgY29tcGxldGVGbik7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBFdmVudEVtaXR0ZXI7XG4gICAgfShyeGpzX1N1YmplY3QuU3ViamVjdCkpO1xuXG4gICAgLyoqXG4gICAgICogQW4gaW5qZWN0YWJsZSBzZXJ2aWNlIGZvciBleGVjdXRpbmcgd29yayBpbnNpZGUgb3Igb3V0c2lkZSBvZiB0aGUgQW5ndWxhciB6b25lLlxuICAgICAqXG4gICAgICogVGhlIG1vc3QgY29tbW9uIHVzZSBvZiB0aGlzIHNlcnZpY2UgaXMgdG8gb3B0aW1pemUgcGVyZm9ybWFuY2Ugd2hlbiBzdGFydGluZyBhIHdvcmsgY29uc2lzdGluZyBvZlxuICAgICAqIG9uZSBvciBtb3JlIGFzeW5jaHJvbm91cyB0YXNrcyB0aGF0IGRvbid0IHJlcXVpcmUgVUkgdXBkYXRlcyBvciBlcnJvciBoYW5kbGluZyB0byBiZSBoYW5kbGVkIGJ5XG4gICAgICogQW5ndWxhci4gU3VjaCB0YXNrcyBjYW4gYmUga2lja2VkIG9mZiB2aWEge0BsaW5rIHJ1bk91dHNpZGVBbmd1bGFyfSBhbmQgaWYgbmVlZGVkLCB0aGVzZSB0YXNrc1xuICAgICAqIGNhbiByZWVudGVyIHRoZSBBbmd1bGFyIHpvbmUgdmlhIHtAbGluayBydW59LlxuICAgICAqXG4gICAgICogPCEtLSBUT0RPOiBhZGQvZml4IGxpbmtzIHRvOlxuICAgICAqICAgLSBkb2NzIGV4cGxhaW5pbmcgem9uZXMgYW5kIHRoZSB1c2Ugb2Ygem9uZXMgaW4gQW5ndWxhciBhbmQgY2hhbmdlLWRldGVjdGlvblxuICAgICAqICAgLSBsaW5rIHRvIHJ1bk91dHNpZGVBbmd1bGFyL3J1biAodGhyb3VnaG91dCB0aGlzIGZpbGUhKVxuICAgICAqICAgLS0+XG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqIGBgYFxuICAgICAqIGltcG9ydCB7Q29tcG9uZW50LCBOZ1pvbmV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICAgICAqIGltcG9ydCB7TmdJZn0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbiAgICAgKlxuICAgICAqIEBDb21wb25lbnQoe1xuICAgICAqICAgc2VsZWN0b3I6ICduZy16b25lLWRlbW8nLlxuICAgICAqICAgdGVtcGxhdGU6IGBcbiAgICAgKiAgICAgPGgyPkRlbW86IE5nWm9uZTwvaDI+XG4gICAgICpcbiAgICAgKiAgICAgPHA+UHJvZ3Jlc3M6IHt7cHJvZ3Jlc3N9fSU8L3A+XG4gICAgICogICAgIDxwICpuZ0lmPVwicHJvZ3Jlc3MgPj0gMTAwXCI+RG9uZSBwcm9jZXNzaW5nIHt7bGFiZWx9fSBvZiBBbmd1bGFyIHpvbmUhPC9wPlxuICAgICAqXG4gICAgICogICAgIDxidXR0b24gKGNsaWNrKT1cInByb2Nlc3NXaXRoaW5Bbmd1bGFyWm9uZSgpXCI+UHJvY2VzcyB3aXRoaW4gQW5ndWxhciB6b25lPC9idXR0b24+XG4gICAgICogICAgIDxidXR0b24gKGNsaWNrKT1cInByb2Nlc3NPdXRzaWRlT2ZBbmd1bGFyWm9uZSgpXCI+UHJvY2VzcyBvdXRzaWRlIG9mIEFuZ3VsYXIgem9uZTwvYnV0dG9uPlxuICAgICAqICAgYCxcbiAgICAgKiB9KVxuICAgICAqIGV4cG9ydCBjbGFzcyBOZ1pvbmVEZW1vIHtcbiAgICAgKiAgIHByb2dyZXNzOiBudW1iZXIgPSAwO1xuICAgICAqICAgbGFiZWw6IHN0cmluZztcbiAgICAgKlxuICAgICAqICAgY29uc3RydWN0b3IocHJpdmF0ZSBfbmdab25lOiBOZ1pvbmUpIHt9XG4gICAgICpcbiAgICAgKiAgIC8vIExvb3AgaW5zaWRlIHRoZSBBbmd1bGFyIHpvbmVcbiAgICAgKiAgIC8vIHNvIHRoZSBVSSBET0VTIHJlZnJlc2ggYWZ0ZXIgZWFjaCBzZXRUaW1lb3V0IGN5Y2xlXG4gICAgICogICBwcm9jZXNzV2l0aGluQW5ndWxhclpvbmUoKSB7XG4gICAgICogICAgIHRoaXMubGFiZWwgPSAnaW5zaWRlJztcbiAgICAgKiAgICAgdGhpcy5wcm9ncmVzcyA9IDA7XG4gICAgICogICAgIHRoaXMuX2luY3JlYXNlUHJvZ3Jlc3MoKCkgPT4gY29uc29sZS5sb2coJ0luc2lkZSBEb25lIScpKTtcbiAgICAgKiAgIH1cbiAgICAgKlxuICAgICAqICAgLy8gTG9vcCBvdXRzaWRlIG9mIHRoZSBBbmd1bGFyIHpvbmVcbiAgICAgKiAgIC8vIHNvIHRoZSBVSSBET0VTIE5PVCByZWZyZXNoIGFmdGVyIGVhY2ggc2V0VGltZW91dCBjeWNsZVxuICAgICAqICAgcHJvY2Vzc091dHNpZGVPZkFuZ3VsYXJab25lKCkge1xuICAgICAqICAgICB0aGlzLmxhYmVsID0gJ291dHNpZGUnO1xuICAgICAqICAgICB0aGlzLnByb2dyZXNzID0gMDtcbiAgICAgKiAgICAgdGhpcy5fbmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgKiAgICAgICB0aGlzLl9pbmNyZWFzZVByb2dyZXNzKCgpID0+IHtcbiAgICAgKiAgICAgICAvLyByZWVudGVyIHRoZSBBbmd1bGFyIHpvbmUgYW5kIGRpc3BsYXkgZG9uZVxuICAgICAqICAgICAgIHRoaXMuX25nWm9uZS5ydW4oKCkgPT4ge2NvbnNvbGUubG9nKCdPdXRzaWRlIERvbmUhJykgfSk7XG4gICAgICogICAgIH19KSk7XG4gICAgICogICB9XG4gICAgICpcbiAgICAgKiAgIF9pbmNyZWFzZVByb2dyZXNzKGRvbmVDYWxsYmFjazogKCkgPT4gdm9pZCkge1xuICAgICAqICAgICB0aGlzLnByb2dyZXNzICs9IDE7XG4gICAgICogICAgIGNvbnNvbGUubG9nKGBDdXJyZW50IHByb2dyZXNzOiAke3RoaXMucHJvZ3Jlc3N9JWApO1xuICAgICAqXG4gICAgICogICAgIGlmICh0aGlzLnByb2dyZXNzIDwgMTAwKSB7XG4gICAgICogICAgICAgd2luZG93LnNldFRpbWVvdXQoKCkgPT4gdGhpcy5faW5jcmVhc2VQcm9ncmVzcyhkb25lQ2FsbGJhY2spKSwgMTApXG4gICAgICogICAgIH0gZWxzZSB7XG4gICAgICogICAgICAgZG9uZUNhbGxiYWNrKCk7XG4gICAgICogICAgIH1cbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBOZ1pvbmUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBOZ1pvbmUoX2EpIHtcbiAgICAgICAgICAgIHZhciBfYiA9IF9hLmVuYWJsZUxvbmdTdGFja1RyYWNlLCBlbmFibGVMb25nU3RhY2tUcmFjZSA9IF9iID09PSB2b2lkIDAgPyBmYWxzZSA6IF9iO1xuICAgICAgICAgICAgdGhpcy5faGFzUGVuZGluZ01pY3JvdGFza3MgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2hhc1BlbmRpbmdNYWNyb3Rhc2tzID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pc1N0YWJsZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9uZXN0aW5nID0gMDtcbiAgICAgICAgICAgIHRoaXMuX29uVW5zdGFibGUgPSBuZXcgRXZlbnRFbWl0dGVyKGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuX29uTWljcm90YXNrRW1wdHkgPSBuZXcgRXZlbnRFbWl0dGVyKGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuX29uU3RhYmxlID0gbmV3IEV2ZW50RW1pdHRlcihmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLl9vbkVycm9yRXZlbnRzID0gbmV3IEV2ZW50RW1pdHRlcihmYWxzZSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIFpvbmUgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FuZ3VsYXIgcmVxdWlyZXMgWm9uZS5qcyBwcm9seWZpbGwuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBab25lLmFzc2VydFpvbmVQYXRjaGVkKCk7XG4gICAgICAgICAgICB0aGlzLm91dGVyID0gdGhpcy5pbm5lciA9IFpvbmUuY3VycmVudDtcbiAgICAgICAgICAgIGlmIChab25lWyd3dGZab25lU3BlYyddKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbm5lciA9IHRoaXMuaW5uZXIuZm9yayhab25lWyd3dGZab25lU3BlYyddKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbmFibGVMb25nU3RhY2tUcmFjZSAmJiBab25lWydsb25nU3RhY2tUcmFjZVpvbmVTcGVjJ10pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlubmVyID0gdGhpcy5pbm5lci5mb3JrKFpvbmVbJ2xvbmdTdGFja1RyYWNlWm9uZVNwZWMnXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmZvcmtJbm5lclpvbmVXaXRoQW5ndWxhckJlaGF2aW9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgTmdab25lLmlzSW5Bbmd1bGFyWm9uZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFpvbmUuY3VycmVudC5nZXQoJ2lzQW5ndWxhclpvbmUnKSA9PT0gdHJ1ZTsgfTtcbiAgICAgICAgTmdab25lLmFzc2VydEluQW5ndWxhclpvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIU5nWm9uZS5pc0luQW5ndWxhclpvbmUoKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdG8gYmUgaW4gQW5ndWxhciBab25lLCBidXQgaXQgaXMgbm90IScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBOZ1pvbmUuYXNzZXJ0Tm90SW5Bbmd1bGFyWm9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChOZ1pvbmUuaXNJbkFuZ3VsYXJab25lKCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvIG5vdCBiZSBpbiBBbmd1bGFyIFpvbmUsIGJ1dCBpdCBpcyEnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV4ZWN1dGVzIHRoZSBgZm5gIGZ1bmN0aW9uIHN5bmNocm9ub3VzbHkgd2l0aGluIHRoZSBBbmd1bGFyIHpvbmUgYW5kIHJldHVybnMgdmFsdWUgcmV0dXJuZWQgYnlcbiAgICAgICAgICogdGhlIGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBSdW5uaW5nIGZ1bmN0aW9ucyB2aWEgYHJ1bmAgYWxsb3dzIHlvdSB0byByZWVudGVyIEFuZ3VsYXIgem9uZSBmcm9tIGEgdGFzayB0aGF0IHdhcyBleGVjdXRlZFxuICAgICAgICAgKiBvdXRzaWRlIG9mIHRoZSBBbmd1bGFyIHpvbmUgKHR5cGljYWxseSBzdGFydGVkIHZpYSB7QGxpbmsgcnVuT3V0c2lkZUFuZ3VsYXJ9KS5cbiAgICAgICAgICpcbiAgICAgICAgICogQW55IGZ1dHVyZSB0YXNrcyBvciBtaWNyb3Rhc2tzIHNjaGVkdWxlZCBmcm9tIHdpdGhpbiB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udGludWUgZXhlY3V0aW5nIGZyb21cbiAgICAgICAgICogd2l0aGluIHRoZSBBbmd1bGFyIHpvbmUuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIGEgc3luY2hyb25vdXMgZXJyb3IgaGFwcGVucyBpdCB3aWxsIGJlIHJldGhyb3duIGFuZCBub3QgcmVwb3J0ZWQgdmlhIGBvbkVycm9yYC5cbiAgICAgICAgICovXG4gICAgICAgIE5nWm9uZS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKGZuKSB7IHJldHVybiB0aGlzLmlubmVyLnJ1bihmbik7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTYW1lIGFzIGBydW5gLCBleGNlcHQgdGhhdCBzeW5jaHJvbm91cyBlcnJvcnMgYXJlIGNhdWdodCBhbmQgZm9yd2FyZGVkIHZpYSBgb25FcnJvcmAgYW5kIG5vdFxuICAgICAgICAgKiByZXRocm93bi5cbiAgICAgICAgICovXG4gICAgICAgIE5nWm9uZS5wcm90b3R5cGUucnVuR3VhcmRlZCA9IGZ1bmN0aW9uIChmbikgeyByZXR1cm4gdGhpcy5pbm5lci5ydW5HdWFyZGVkKGZuKTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV4ZWN1dGVzIHRoZSBgZm5gIGZ1bmN0aW9uIHN5bmNocm9ub3VzbHkgaW4gQW5ndWxhcidzIHBhcmVudCB6b25lIGFuZCByZXR1cm5zIHZhbHVlIHJldHVybmVkIGJ5XG4gICAgICAgICAqIHRoZSBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogUnVubmluZyBmdW5jdGlvbnMgdmlhIGBydW5PdXRzaWRlQW5ndWxhcmAgYWxsb3dzIHlvdSB0byBlc2NhcGUgQW5ndWxhcidzIHpvbmUgYW5kIGRvIHdvcmsgdGhhdFxuICAgICAgICAgKiBkb2Vzbid0IHRyaWdnZXIgQW5ndWxhciBjaGFuZ2UtZGV0ZWN0aW9uIG9yIGlzIHN1YmplY3QgdG8gQW5ndWxhcidzIGVycm9yIGhhbmRsaW5nLlxuICAgICAgICAgKlxuICAgICAgICAgKiBBbnkgZnV0dXJlIHRhc2tzIG9yIG1pY3JvdGFza3Mgc2NoZWR1bGVkIGZyb20gd2l0aGluIHRoaXMgZnVuY3Rpb24gd2lsbCBjb250aW51ZSBleGVjdXRpbmcgZnJvbVxuICAgICAgICAgKiBvdXRzaWRlIG9mIHRoZSBBbmd1bGFyIHpvbmUuXG4gICAgICAgICAqXG4gICAgICAgICAqIFVzZSB7QGxpbmsgcnVufSB0byByZWVudGVyIHRoZSBBbmd1bGFyIHpvbmUgYW5kIGRvIHdvcmsgdGhhdCB1cGRhdGVzIHRoZSBhcHBsaWNhdGlvbiBtb2RlbC5cbiAgICAgICAgICovXG4gICAgICAgIE5nWm9uZS5wcm90b3R5cGUucnVuT3V0c2lkZUFuZ3VsYXIgPSBmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIHRoaXMub3V0ZXIucnVuKGZuKTsgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nWm9uZS5wcm90b3R5cGUsIFwib25VbnN0YWJsZVwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE5vdGlmaWVzIHdoZW4gY29kZSBlbnRlcnMgQW5ndWxhciBab25lLiBUaGlzIGdldHMgZmlyZWQgZmlyc3Qgb24gVk0gVHVybi5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9vblVuc3RhYmxlOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nWm9uZS5wcm90b3R5cGUsIFwib25NaWNyb3Rhc2tFbXB0eVwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE5vdGlmaWVzIHdoZW4gdGhlcmUgaXMgbm8gbW9yZSBtaWNyb3Rhc2tzIGVucXVldWUgaW4gdGhlIGN1cnJlbnQgVk0gVHVybi5cbiAgICAgICAgICAgICAqIFRoaXMgaXMgYSBoaW50IGZvciBBbmd1bGFyIHRvIGRvIGNoYW5nZSBkZXRlY3Rpb24sIHdoaWNoIG1heSBlbnF1ZXVlIG1vcmUgbWljcm90YXNrcy5cbiAgICAgICAgICAgICAqIEZvciB0aGlzIHJlYXNvbiB0aGlzIGV2ZW50IGNhbiBmaXJlIG11bHRpcGxlIHRpbWVzIHBlciBWTSBUdXJuLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX29uTWljcm90YXNrRW1wdHk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdab25lLnByb3RvdHlwZSwgXCJvblN0YWJsZVwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE5vdGlmaWVzIHdoZW4gdGhlIGxhc3QgYG9uTWljcm90YXNrRW1wdHlgIGhhcyBydW4gYW5kIHRoZXJlIGFyZSBubyBtb3JlIG1pY3JvdGFza3MsIHdoaWNoXG4gICAgICAgICAgICAgKiBpbXBsaWVzIHdlIGFyZSBhYm91dCB0byByZWxpbnF1aXNoIFZNIHR1cm4uXG4gICAgICAgICAgICAgKiBUaGlzIGV2ZW50IGdldHMgY2FsbGVkIGp1c3Qgb25jZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9vblN0YWJsZTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ1pvbmUucHJvdG90eXBlLCBcIm9uRXJyb3JcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBOb3RpZnkgdGhhdCBhbiBlcnJvciBoYXMgYmVlbiBkZWxpdmVyZWQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fb25FcnJvckV2ZW50czsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ1pvbmUucHJvdG90eXBlLCBcImlzU3RhYmxlXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2hldGhlciB0aGVyZSBhcmUgbm8gb3V0c3RhbmRpbmcgbWljcm90YXNrcyBvciBtYWNyb3Rhc2tzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2lzU3RhYmxlOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nWm9uZS5wcm90b3R5cGUsIFwiaGFzUGVuZGluZ01pY3JvdGFza3NcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9oYXNQZW5kaW5nTWljcm90YXNrczsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ1pvbmUucHJvdG90eXBlLCBcImhhc1BlbmRpbmdNYWNyb3Rhc2tzXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5faGFzUGVuZGluZ01hY3JvdGFza3M7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBOZ1pvbmUucHJvdG90eXBlLmNoZWNrU3RhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGlmICh0aGlzLl9uZXN0aW5nID09IDAgJiYgIXRoaXMuX2hhc1BlbmRpbmdNaWNyb3Rhc2tzICYmICF0aGlzLl9pc1N0YWJsZSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX25lc3RpbmcrKztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25NaWNyb3Rhc2tFbXB0eS5lbWl0KG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbmVzdGluZy0tO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2hhc1BlbmRpbmdNaWNyb3Rhc2tzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucnVuT3V0c2lkZUFuZ3VsYXIoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX29uU3RhYmxlLmVtaXQobnVsbCk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faXNTdGFibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBOZ1pvbmUucHJvdG90eXBlLmZvcmtJbm5lclpvbmVXaXRoQW5ndWxhckJlaGF2aW9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuaW5uZXIgPSB0aGlzLmlubmVyLmZvcmsoe1xuICAgICAgICAgICAgICAgIG5hbWU6ICdhbmd1bGFyJyxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiB7ICdpc0FuZ3VsYXJab25lJzogdHJ1ZSB9LFxuICAgICAgICAgICAgICAgIG9uSW52b2tlVGFzazogZnVuY3Rpb24gKGRlbGVnYXRlLCBjdXJyZW50LCB0YXJnZXQsIHRhc2ssIGFwcGx5VGhpcywgYXBwbHlBcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5vbkVudGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVsZWdhdGUuaW52b2tlVGFzayh0YXJnZXQsIHRhc2ssIGFwcGx5VGhpcywgYXBwbHlBcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm9uTGVhdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25JbnZva2U6IGZ1bmN0aW9uIChkZWxlZ2F0ZSwgY3VycmVudCwgdGFyZ2V0LCBjYWxsYmFjaywgYXBwbHlUaGlzLCBhcHBseUFyZ3MsIHNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMub25FbnRlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlLmludm9rZSh0YXJnZXQsIGNhbGxiYWNrLCBhcHBseVRoaXMsIGFwcGx5QXJncywgc291cmNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm9uTGVhdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25IYXNUYXNrOiBmdW5jdGlvbiAoZGVsZWdhdGUsIGN1cnJlbnQsIHRhcmdldCwgaGFzVGFza1N0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGVnYXRlLmhhc1Rhc2sodGFyZ2V0LCBoYXNUYXNrU3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudCA9PT0gdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBhcmUgb25seSBpbnRlcmVzdGVkIGluIGhhc1Rhc2sgZXZlbnRzIHdoaWNoIG9yaWdpbmF0ZSBmcm9tIG91ciB6b25lXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAoQSBjaGlsZCBoYXNUYXNrIGV2ZW50IGlzIG5vdCBpbnRlcmVzdGluZyB0byB1cylcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNUYXNrU3RhdGUuY2hhbmdlID09ICdtaWNyb1Rhc2snKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0SGFzTWljcm90YXNrKGhhc1Rhc2tTdGF0ZS5taWNyb1Rhc2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaGFzVGFza1N0YXRlLmNoYW5nZSA9PSAnbWFjcm9UYXNrJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnNldEhhc01hY3JvdGFzayhoYXNUYXNrU3RhdGUubWFjcm9UYXNrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25IYW5kbGVFcnJvcjogZnVuY3Rpb24gKGRlbGVnYXRlLCBjdXJyZW50LCB0YXJnZXQsIGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGVnYXRlLmhhbmRsZUVycm9yKHRhcmdldCwgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy50cmlnZ2VyRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIE5nWm9uZS5wcm90b3R5cGUub25FbnRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX25lc3RpbmcrKztcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc1N0YWJsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzU3RhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25VbnN0YWJsZS5lbWl0KG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBOZ1pvbmUucHJvdG90eXBlLm9uTGVhdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9uZXN0aW5nLS07XG4gICAgICAgICAgICB0aGlzLmNoZWNrU3RhYmxlKCk7XG4gICAgICAgIH07XG4gICAgICAgIE5nWm9uZS5wcm90b3R5cGUuc2V0SGFzTWljcm90YXNrID0gZnVuY3Rpb24gKGhhc01pY3JvdGFza3MpIHtcbiAgICAgICAgICAgIHRoaXMuX2hhc1BlbmRpbmdNaWNyb3Rhc2tzID0gaGFzTWljcm90YXNrcztcbiAgICAgICAgICAgIHRoaXMuY2hlY2tTdGFibGUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgTmdab25lLnByb3RvdHlwZS5zZXRIYXNNYWNyb3Rhc2sgPSBmdW5jdGlvbiAoaGFzTWFjcm90YXNrcykgeyB0aGlzLl9oYXNQZW5kaW5nTWFjcm90YXNrcyA9IGhhc01hY3JvdGFza3M7IH07XG4gICAgICAgIE5nWm9uZS5wcm90b3R5cGUudHJpZ2dlckVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7IHRoaXMuX29uRXJyb3JFdmVudHMuZW1pdChlcnJvcik7IH07XG4gICAgICAgIHJldHVybiBOZ1pvbmU7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBUZXN0YWJpbGl0eSBzZXJ2aWNlIHByb3ZpZGVzIHRlc3RpbmcgaG9va3MgdGhhdCBjYW4gYmUgYWNjZXNzZWQgZnJvbVxuICAgICAqIHRoZSBicm93c2VyIGFuZCBieSBzZXJ2aWNlcyBzdWNoIGFzIFByb3RyYWN0b3IuIEVhY2ggYm9vdHN0cmFwcGVkIEFuZ3VsYXJcbiAgICAgKiBhcHBsaWNhdGlvbiBvbiB0aGUgcGFnZSB3aWxsIGhhdmUgYW4gaW5zdGFuY2Ugb2YgVGVzdGFiaWxpdHkuXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBUZXN0YWJpbGl0eSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFRlc3RhYmlsaXR5KF9uZ1pvbmUpIHtcbiAgICAgICAgICAgIHRoaXMuX25nWm9uZSA9IF9uZ1pvbmU7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nQ291bnQgPSAwO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5faXNab25lU3RhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2hldGhlciBhbnkgd29yayB3YXMgZG9uZSBzaW5jZSB0aGUgbGFzdCAnd2hlblN0YWJsZScgY2FsbGJhY2suIFRoaXMgaXNcbiAgICAgICAgICAgICAqIHVzZWZ1bCB0byBkZXRlY3QgaWYgdGhpcyBjb3VsZCBoYXZlIHBvdGVudGlhbGx5IGRlc3RhYmlsaXplZCBhbm90aGVyXG4gICAgICAgICAgICAgKiBjb21wb25lbnQgd2hpbGUgaXQgaXMgc3RhYmlsaXppbmcuXG4gICAgICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5fZGlkV29yayA9IGZhbHNlO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzID0gW107XG4gICAgICAgICAgICB0aGlzLl93YXRjaEFuZ3VsYXJFdmVudHMoKTtcbiAgICAgICAgfVxuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIFRlc3RhYmlsaXR5LnByb3RvdHlwZS5fd2F0Y2hBbmd1bGFyRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuX25nWm9uZS5vblVuc3RhYmxlLnN1YnNjcmliZSh7XG4gICAgICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fZGlkV29yayA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9pc1pvbmVTdGFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX25nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX25nWm9uZS5vblN0YWJsZS5zdWJzY3JpYmUoe1xuICAgICAgICAgICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBOZ1pvbmUuYXNzZXJ0Tm90SW5Bbmd1bGFyWm9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NoZWR1bGVNaWNyb1Rhc2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9pc1pvbmVTdGFibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9ydW5DYWxsYmFja3NJZlJlYWR5KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIFRlc3RhYmlsaXR5LnByb3RvdHlwZS5pbmNyZWFzZVBlbmRpbmdSZXF1ZXN0Q291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nQ291bnQgKz0gMTtcbiAgICAgICAgICAgIHRoaXMuX2RpZFdvcmsgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BlbmRpbmdDb3VudDtcbiAgICAgICAgfTtcbiAgICAgICAgVGVzdGFiaWxpdHkucHJvdG90eXBlLmRlY3JlYXNlUGVuZGluZ1JlcXVlc3RDb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdDb3VudCAtPSAxO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BlbmRpbmdDb3VudCA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BlbmRpbmcgYXN5bmMgcmVxdWVzdHMgYmVsb3cgemVybycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcnVuQ2FsbGJhY2tzSWZSZWFkeSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BlbmRpbmdDb3VudDtcbiAgICAgICAgfTtcbiAgICAgICAgVGVzdGFiaWxpdHkucHJvdG90eXBlLmlzU3RhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzWm9uZVN0YWJsZSAmJiB0aGlzLl9wZW5kaW5nQ291bnQgPT0gMCAmJiAhdGhpcy5fbmdab25lLmhhc1BlbmRpbmdNYWNyb3Rhc2tzO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIFRlc3RhYmlsaXR5LnByb3RvdHlwZS5fcnVuQ2FsbGJhY2tzSWZSZWFkeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1N0YWJsZSgpKSB7XG4gICAgICAgICAgICAgICAgLy8gU2NoZWR1bGVzIHRoZSBjYWxsIGJhY2tzIGluIGEgbmV3IGZyYW1lIHNvIHRoYXQgaXQgaXMgYWx3YXlzIGFzeW5jLlxuICAgICAgICAgICAgICAgIHNjaGVkdWxlTWljcm9UYXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKF90aGlzLl9jYWxsYmFja3MubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAoX3RoaXMuX2NhbGxiYWNrcy5wb3AoKSkoX3RoaXMuX2RpZFdvcmspO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9kaWRXb3JrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBOb3QgUmVhZHlcbiAgICAgICAgICAgICAgICB0aGlzLl9kaWRXb3JrID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgVGVzdGFiaWxpdHkucHJvdG90eXBlLndoZW5TdGFibGUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIHRoaXMuX3J1bkNhbGxiYWNrc0lmUmVhZHkoKTtcbiAgICAgICAgfTtcbiAgICAgICAgVGVzdGFiaWxpdHkucHJvdG90eXBlLmdldFBlbmRpbmdSZXF1ZXN0Q291bnQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wZW5kaW5nQ291bnQ7IH07XG4gICAgICAgIC8qKiBAZGVwcmVjYXRlZCB1c2UgZmluZFByb3ZpZGVycyAqL1xuICAgICAgICBUZXN0YWJpbGl0eS5wcm90b3R5cGUuZmluZEJpbmRpbmdzID0gZnVuY3Rpb24gKHVzaW5nLCBwcm92aWRlciwgZXhhY3RNYXRjaCkge1xuICAgICAgICAgICAgLy8gVE9ETyhqdWxpZW1yKTogaW1wbGVtZW50LlxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9O1xuICAgICAgICBUZXN0YWJpbGl0eS5wcm90b3R5cGUuZmluZFByb3ZpZGVycyA9IGZ1bmN0aW9uICh1c2luZywgcHJvdmlkZXIsIGV4YWN0TWF0Y2gpIHtcbiAgICAgICAgICAgIC8vIFRPRE8oanVsaWVtcik6IGltcGxlbWVudC5cbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfTtcbiAgICAgICAgVGVzdGFiaWxpdHkuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgVGVzdGFiaWxpdHkuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IE5nWm9uZSwgfSxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIFRlc3RhYmlsaXR5O1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogQSBnbG9iYWwgcmVnaXN0cnkgb2Yge0BsaW5rIFRlc3RhYmlsaXR5fSBpbnN0YW5jZXMgZm9yIHNwZWNpZmljIGVsZW1lbnRzLlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgVGVzdGFiaWxpdHlSZWdpc3RyeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFRlc3RhYmlsaXR5UmVnaXN0cnkoKSB7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9hcHBsaWNhdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBfdGVzdGFiaWxpdHlHZXR0ZXIuYWRkVG9XaW5kb3codGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgVGVzdGFiaWxpdHlSZWdpc3RyeS5wcm90b3R5cGUucmVnaXN0ZXJBcHBsaWNhdGlvbiA9IGZ1bmN0aW9uICh0b2tlbiwgdGVzdGFiaWxpdHkpIHtcbiAgICAgICAgICAgIHRoaXMuX2FwcGxpY2F0aW9ucy5zZXQodG9rZW4sIHRlc3RhYmlsaXR5KTtcbiAgICAgICAgfTtcbiAgICAgICAgVGVzdGFiaWxpdHlSZWdpc3RyeS5wcm90b3R5cGUuZ2V0VGVzdGFiaWxpdHkgPSBmdW5jdGlvbiAoZWxlbSkgeyByZXR1cm4gdGhpcy5fYXBwbGljYXRpb25zLmdldChlbGVtKTsgfTtcbiAgICAgICAgVGVzdGFiaWxpdHlSZWdpc3RyeS5wcm90b3R5cGUuZ2V0QWxsVGVzdGFiaWxpdGllcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1hcFdyYXBwZXIudmFsdWVzKHRoaXMuX2FwcGxpY2F0aW9ucyk7IH07XG4gICAgICAgIFRlc3RhYmlsaXR5UmVnaXN0cnkucHJvdG90eXBlLmdldEFsbFJvb3RFbGVtZW50cyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1hcFdyYXBwZXIua2V5cyh0aGlzLl9hcHBsaWNhdGlvbnMpOyB9O1xuICAgICAgICBUZXN0YWJpbGl0eVJlZ2lzdHJ5LnByb3RvdHlwZS5maW5kVGVzdGFiaWxpdHlJblRyZWUgPSBmdW5jdGlvbiAoZWxlbSwgZmluZEluQW5jZXN0b3JzKSB7XG4gICAgICAgICAgICBpZiAoZmluZEluQW5jZXN0b3JzID09PSB2b2lkIDApIHsgZmluZEluQW5jZXN0b3JzID0gdHJ1ZTsgfVxuICAgICAgICAgICAgcmV0dXJuIF90ZXN0YWJpbGl0eUdldHRlci5maW5kVGVzdGFiaWxpdHlJblRyZWUodGhpcywgZWxlbSwgZmluZEluQW5jZXN0b3JzKTtcbiAgICAgICAgfTtcbiAgICAgICAgVGVzdGFiaWxpdHlSZWdpc3RyeS5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBJbmplY3RhYmxlIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBUZXN0YWJpbGl0eVJlZ2lzdHJ5LmN0b3JQYXJhbWV0ZXJzID0gW107XG4gICAgICAgIHJldHVybiBUZXN0YWJpbGl0eVJlZ2lzdHJ5O1xuICAgIH0oKSk7XG4gICAgdmFyIF9Ob29wR2V0VGVzdGFiaWxpdHkgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBfTm9vcEdldFRlc3RhYmlsaXR5KCkge1xuICAgICAgICB9XG4gICAgICAgIF9Ob29wR2V0VGVzdGFiaWxpdHkucHJvdG90eXBlLmFkZFRvV2luZG93ID0gZnVuY3Rpb24gKHJlZ2lzdHJ5KSB7IH07XG4gICAgICAgIF9Ob29wR2V0VGVzdGFiaWxpdHkucHJvdG90eXBlLmZpbmRUZXN0YWJpbGl0eUluVHJlZSA9IGZ1bmN0aW9uIChyZWdpc3RyeSwgZWxlbSwgZmluZEluQW5jZXN0b3JzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF9Ob29wR2V0VGVzdGFiaWxpdHk7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHtAbGluayBHZXRUZXN0YWJpbGl0eX0gaW1wbGVtZW50YXRpb24gdXNlZCBieSB0aGUgQW5ndWxhciB0ZXN0aW5nIGZyYW1ld29yay5cbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0VGVzdGFiaWxpdHlHZXR0ZXIoZ2V0dGVyKSB7XG4gICAgICAgIF90ZXN0YWJpbGl0eUdldHRlciA9IGdldHRlcjtcbiAgICB9XG4gICAgdmFyIF90ZXN0YWJpbGl0eUdldHRlciA9IG5ldyBfTm9vcEdldFRlc3RhYmlsaXR5KCk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgdmFyIF9kZXZNb2RlID0gdHJ1ZTtcbiAgICB2YXIgX3J1bk1vZGVMb2NrZWQgPSBmYWxzZTtcbiAgICB2YXIgX3BsYXRmb3JtO1xuICAgIC8qKlxuICAgICAqIERpc2FibGUgQW5ndWxhcidzIGRldmVsb3BtZW50IG1vZGUsIHdoaWNoIHR1cm5zIG9mZiBhc3NlcnRpb25zIGFuZCBvdGhlclxuICAgICAqIGNoZWNrcyB3aXRoaW4gdGhlIGZyYW1ld29yay5cbiAgICAgKlxuICAgICAqIE9uZSBpbXBvcnRhbnQgYXNzZXJ0aW9uIHRoaXMgZGlzYWJsZXMgdmVyaWZpZXMgdGhhdCBhIGNoYW5nZSBkZXRlY3Rpb24gcGFzc1xuICAgICAqIGRvZXMgbm90IHJlc3VsdCBpbiBhZGRpdGlvbmFsIGNoYW5nZXMgdG8gYW55IGJpbmRpbmdzIChhbHNvIGtub3duIGFzXG4gICAgICogdW5pZGlyZWN0aW9uYWwgZGF0YSBmbG93KS5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlbmFibGVQcm9kTW9kZSgpIHtcbiAgICAgICAgaWYgKF9ydW5Nb2RlTG9ja2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBlbmFibGUgcHJvZCBtb2RlIGFmdGVyIHBsYXRmb3JtIHNldHVwLicpO1xuICAgICAgICB9XG4gICAgICAgIF9kZXZNb2RlID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBBbmd1bGFyIGlzIGluIGRldmVsb3BtZW50IG1vZGUuIEFmdGVyIGNhbGxlZCBvbmNlLFxuICAgICAqIHRoZSB2YWx1ZSBpcyBsb2NrZWQgYW5kIHdvbid0IGNoYW5nZSBhbnkgbW9yZS5cbiAgICAgKlxuICAgICAqIEJ5IGRlZmF1bHQsIHRoaXMgaXMgdHJ1ZSwgdW5sZXNzIGEgdXNlciBjYWxscyBgZW5hYmxlUHJvZE1vZGVgIGJlZm9yZSBjYWxsaW5nIHRoaXMuXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsIEFQSXMgcmVsYXRlZCB0byBhcHBsaWNhdGlvbiBib290c3RyYXAgYXJlIGN1cnJlbnRseSB1bmRlciByZXZpZXcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNEZXZNb2RlKCkge1xuICAgICAgICBfcnVuTW9kZUxvY2tlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBfZGV2TW9kZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHBsYXRmb3JtLlxuICAgICAqIFBsYXRmb3JtcyBoYXZlIHRvIGJlIGVhZ2VybHkgY3JlYXRlZCB2aWEgdGhpcyBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWwgQVBJcyByZWxhdGVkIHRvIGFwcGxpY2F0aW9uIGJvb3RzdHJhcCBhcmUgY3VycmVudGx5IHVuZGVyIHJldmlldy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVQbGF0Zm9ybShpbmplY3Rvcikge1xuICAgICAgICBpZiAoX3BsYXRmb3JtICYmICFfcGxhdGZvcm0uZGVzdHJveWVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZXJlIGNhbiBiZSBvbmx5IG9uZSBwbGF0Zm9ybS4gRGVzdHJveSB0aGUgcHJldmlvdXMgb25lIHRvIGNyZWF0ZSBhIG5ldyBvbmUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgX3BsYXRmb3JtID0gaW5qZWN0b3IuZ2V0KFBsYXRmb3JtUmVmKTtcbiAgICAgICAgdmFyIGluaXRzID0gaW5qZWN0b3IuZ2V0KFBMQVRGT1JNX0lOSVRJQUxJWkVSLCBudWxsKTtcbiAgICAgICAgaWYgKGluaXRzKVxuICAgICAgICAgICAgaW5pdHMuZm9yRWFjaChmdW5jdGlvbiAoaW5pdCkgeyByZXR1cm4gaW5pdCgpOyB9KTtcbiAgICAgICAgcmV0dXJuIF9wbGF0Zm9ybTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZhY3RvcnkgZm9yIGEgcGxhdGZvcm1cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWwgQVBJcyByZWxhdGVkIHRvIGFwcGxpY2F0aW9uIGJvb3RzdHJhcCBhcmUgY3VycmVudGx5IHVuZGVyIHJldmlldy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVQbGF0Zm9ybUZhY3RvcnkocGFyZW50UGxhZm9ybUZhY3RvcnksIG5hbWUsIHByb3ZpZGVycykge1xuICAgICAgICBpZiAocHJvdmlkZXJzID09PSB2b2lkIDApIHsgcHJvdmlkZXJzID0gW107IH1cbiAgICAgICAgdmFyIG1hcmtlciA9IG5ldyBPcGFxdWVUb2tlbihcIlBsYXRmb3JtOiBcIiArIG5hbWUpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGV4dHJhUHJvdmlkZXJzKSB7XG4gICAgICAgICAgICBpZiAoZXh0cmFQcm92aWRlcnMgPT09IHZvaWQgMCkgeyBleHRyYVByb3ZpZGVycyA9IFtdOyB9XG4gICAgICAgICAgICBpZiAoIWdldFBsYXRmb3JtKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50UGxhZm9ybUZhY3RvcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50UGxhZm9ybUZhY3RvcnkocHJvdmlkZXJzLmNvbmNhdChleHRyYVByb3ZpZGVycykuY29uY2F0KHsgcHJvdmlkZTogbWFya2VyLCB1c2VWYWx1ZTogdHJ1ZSB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjcmVhdGVQbGF0Zm9ybShSZWZsZWN0aXZlSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShwcm92aWRlcnMuY29uY2F0KGV4dHJhUHJvdmlkZXJzKS5jb25jYXQoeyBwcm92aWRlOiBtYXJrZXIsIHVzZVZhbHVlOiB0cnVlIH0pKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFzc2VydFBsYXRmb3JtKG1hcmtlcik7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyB0aGF0IHRoZXJlIGN1cnJlbnRseSBpcyBhIHBsYXRmb3JtXG4gICAgICogd2hpY2ggY29udGFpbnMgdGhlIGdpdmVuIHRva2VuIGFzIGEgcHJvdmlkZXIuXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsIEFQSXMgcmVsYXRlZCB0byBhcHBsaWNhdGlvbiBib290c3RyYXAgYXJlIGN1cnJlbnRseSB1bmRlciByZXZpZXcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXNzZXJ0UGxhdGZvcm0ocmVxdWlyZWRUb2tlbikge1xuICAgICAgICB2YXIgcGxhdGZvcm0gPSBnZXRQbGF0Zm9ybSgpO1xuICAgICAgICBpZiAoIXBsYXRmb3JtKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHBsYXRmb3JtIGV4aXN0cyEnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBsYXRmb3JtLmluamVjdG9yLmdldChyZXF1aXJlZFRva2VuLCBudWxsKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIHBsYXRmb3JtIHdpdGggYSBkaWZmZXJlbnQgY29uZmlndXJhdGlvbiBoYXMgYmVlbiBjcmVhdGVkLiBQbGVhc2UgZGVzdHJveSBpdCBmaXJzdC4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGxhdGZvcm07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc3Ryb3kgdGhlIGV4aXN0aW5nIHBsYXRmb3JtLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbCBBUElzIHJlbGF0ZWQgdG8gYXBwbGljYXRpb24gYm9vdHN0cmFwIGFyZSBjdXJyZW50bHkgdW5kZXIgcmV2aWV3LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlc3Ryb3lQbGF0Zm9ybSgpIHtcbiAgICAgICAgaWYgKF9wbGF0Zm9ybSAmJiAhX3BsYXRmb3JtLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgX3BsYXRmb3JtLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHBsYXRmb3JtLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbCBBUElzIHJlbGF0ZWQgdG8gYXBwbGljYXRpb24gYm9vdHN0cmFwIGFyZSBjdXJyZW50bHkgdW5kZXIgcmV2aWV3LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFBsYXRmb3JtKCkge1xuICAgICAgICByZXR1cm4gX3BsYXRmb3JtICYmICFfcGxhdGZvcm0uZGVzdHJveWVkID8gX3BsYXRmb3JtIDogbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIEFuZ3VsYXIgcGxhdGZvcm0gaXMgdGhlIGVudHJ5IHBvaW50IGZvciBBbmd1bGFyIG9uIGEgd2ViIHBhZ2UuIEVhY2ggcGFnZVxuICAgICAqIGhhcyBleGFjdGx5IG9uZSBwbGF0Zm9ybSwgYW5kIHNlcnZpY2VzIChzdWNoIGFzIHJlZmxlY3Rpb24pIHdoaWNoIGFyZSBjb21tb25cbiAgICAgKiB0byBldmVyeSBBbmd1bGFyIGFwcGxpY2F0aW9uIHJ1bm5pbmcgb24gdGhlIHBhZ2UgYXJlIGJvdW5kIGluIGl0cyBzY29wZS5cbiAgICAgKlxuICAgICAqIEEgcGFnZSdzIHBsYXRmb3JtIGlzIGluaXRpYWxpemVkIGltcGxpY2l0bHkgd2hlbiB7QGxpbmsgYm9vdHN0cmFwfSgpIGlzIGNhbGxlZCwgb3JcbiAgICAgKiBleHBsaWNpdGx5IGJ5IGNhbGxpbmcge0BsaW5rIGNyZWF0ZVBsYXRmb3JtfSgpLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBQbGF0Zm9ybVJlZiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFBsYXRmb3JtUmVmKCkge1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGFuIGBATmdNb2R1bGVgIGZvciB0aGUgZ2l2ZW4gcGxhdGZvcm1cbiAgICAgICAgICogZm9yIG9mZmxpbmUgY29tcGlsYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIFNpbXBsZSBFeGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgICAgICogbXlfbW9kdWxlLnRzOlxuICAgICAgICAgKlxuICAgICAgICAgKiBATmdNb2R1bGUoe1xuICAgICAgICAgKiAgIGltcG9ydHM6IFtCcm93c2VyTW9kdWxlXVxuICAgICAgICAgKiB9KVxuICAgICAgICAgKiBjbGFzcyBNeU1vZHVsZSB7fVxuICAgICAgICAgKlxuICAgICAgICAgKiBtYWluLnRzOlxuICAgICAgICAgKiBpbXBvcnQge015TW9kdWxlTmdGYWN0b3J5fSBmcm9tICcuL215X21vZHVsZS5uZ2ZhY3RvcnknO1xuICAgICAgICAgKiBpbXBvcnQge3BsYXRmb3JtQnJvd3Nlcn0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlcic7XG4gICAgICAgICAqXG4gICAgICAgICAqIGxldCBtb2R1bGVSZWYgPSBwbGF0Zm9ybUJyb3dzZXIoKS5ib290c3RyYXBNb2R1bGVGYWN0b3J5KE15TW9kdWxlTmdGYWN0b3J5KTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleHBlcmltZW50YWwgQVBJcyByZWxhdGVkIHRvIGFwcGxpY2F0aW9uIGJvb3RzdHJhcCBhcmUgY3VycmVudGx5IHVuZGVyIHJldmlldy5cbiAgICAgICAgICovXG4gICAgICAgIFBsYXRmb3JtUmVmLnByb3RvdHlwZS5ib290c3RyYXBNb2R1bGVGYWN0b3J5ID0gZnVuY3Rpb24gKG1vZHVsZUZhY3RvcnkpIHtcbiAgICAgICAgICAgIHRocm93IHVuaW1wbGVtZW50ZWQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgYW4gYEBOZ01vZHVsZWAgZm9yIGEgZ2l2ZW4gcGxhdGZvcm0gdXNpbmcgdGhlIGdpdmVuIHJ1bnRpbWUgY29tcGlsZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIFNpbXBsZSBFeGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgICAgICogQE5nTW9kdWxlKHtcbiAgICAgICAgICogICBpbXBvcnRzOiBbQnJvd3Nlck1vZHVsZV1cbiAgICAgICAgICogfSlcbiAgICAgICAgICogY2xhc3MgTXlNb2R1bGUge31cbiAgICAgICAgICpcbiAgICAgICAgICogbGV0IG1vZHVsZVJlZiA9IHBsYXRmb3JtQnJvd3NlcigpLmJvb3RzdHJhcE1vZHVsZShNeU1vZHVsZSk7XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKiBAc3RhYmxlXG4gICAgICAgICAqL1xuICAgICAgICBQbGF0Zm9ybVJlZi5wcm90b3R5cGUuYm9vdHN0cmFwTW9kdWxlID0gZnVuY3Rpb24gKG1vZHVsZVR5cGUsIGNvbXBpbGVyT3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKGNvbXBpbGVyT3B0aW9ucyA9PT0gdm9pZCAwKSB7IGNvbXBpbGVyT3B0aW9ucyA9IFtdOyB9XG4gICAgICAgICAgICB0aHJvdyB1bmltcGxlbWVudGVkKCk7XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQbGF0Zm9ybVJlZi5wcm90b3R5cGUsIFwiaW5qZWN0b3JcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXRyaWV2ZSB0aGUgcGxhdGZvcm0ge0BsaW5rIEluamVjdG9yfSwgd2hpY2ggaXMgdGhlIHBhcmVudCBpbmplY3RvciBmb3JcbiAgICAgICAgICAgICAqIGV2ZXJ5IEFuZ3VsYXIgYXBwbGljYXRpb24gb24gdGhlIHBhZ2UgYW5kIHByb3ZpZGVzIHNpbmdsZXRvbiBwcm92aWRlcnMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyB0aHJvdyB1bmltcGxlbWVudGVkKCk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICA7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQbGF0Zm9ybVJlZi5wcm90b3R5cGUsIFwiZGVzdHJveWVkXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyB0aHJvdyB1bmltcGxlbWVudGVkKCk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUGxhdGZvcm1SZWY7XG4gICAgfSgpKTtcbiAgICBmdW5jdGlvbiBfY2FsbEFuZFJlcG9ydFRvRXJyb3JIYW5kbGVyKGVycm9ySGFuZGxlciwgY2FsbGJhY2spIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBjYWxsYmFjaygpO1xuICAgICAgICAgICAgaWYgKGlzUHJvbWlzZShyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5jYXRjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvckhhbmRsZXIuaGFuZGxlRXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJldGhyb3cgYXMgdGhlIGV4Y2VwdGlvbiBoYW5kbGVyIG1pZ2h0IG5vdCBkbyBpdFxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZXJyb3JIYW5kbGVyLmhhbmRsZUVycm9yKGUpO1xuICAgICAgICAgICAgLy8gcmV0aHJvdyBhcyB0aGUgZXhjZXB0aW9uIGhhbmRsZXIgbWlnaHQgbm90IGRvIGl0XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBQbGF0Zm9ybVJlZl8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMyhQbGF0Zm9ybVJlZl8sIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIFBsYXRmb3JtUmVmXyhfaW5qZWN0b3IpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5faW5qZWN0b3IgPSBfaW5qZWN0b3I7XG4gICAgICAgICAgICB0aGlzLl9tb2R1bGVzID0gW107XG4gICAgICAgICAgICB0aGlzLl9kZXN0cm95TGlzdGVuZXJzID0gW107XG4gICAgICAgICAgICB0aGlzLl9kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBQbGF0Zm9ybVJlZl8ucHJvdG90eXBlLm9uRGVzdHJveSA9IGZ1bmN0aW9uIChjYWxsYmFjaykgeyB0aGlzLl9kZXN0cm95TGlzdGVuZXJzLnB1c2goY2FsbGJhY2spOyB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUGxhdGZvcm1SZWZfLnByb3RvdHlwZSwgXCJpbmplY3RvclwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2luamVjdG9yOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBsYXRmb3JtUmVmXy5wcm90b3R5cGUsIFwiZGVzdHJveWVkXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGVzdHJveWVkOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgUGxhdGZvcm1SZWZfLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2Rlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHBsYXRmb3JtIGhhcyBhbHJlYWR5IGJlZW4gZGVzdHJveWVkIScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbW9kdWxlcy5zbGljZSgpLmZvckVhY2goZnVuY3Rpb24gKG1vZHVsZSkgeyByZXR1cm4gbW9kdWxlLmRlc3Ryb3koKTsgfSk7XG4gICAgICAgICAgICB0aGlzLl9kZXN0cm95TGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7IHJldHVybiBsaXN0ZW5lcigpOyB9KTtcbiAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIFBsYXRmb3JtUmVmXy5wcm90b3R5cGUuYm9vdHN0cmFwTW9kdWxlRmFjdG9yeSA9IGZ1bmN0aW9uIChtb2R1bGVGYWN0b3J5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYm9vdHN0cmFwTW9kdWxlRmFjdG9yeVdpdGhab25lKG1vZHVsZUZhY3RvcnksIG51bGwpO1xuICAgICAgICB9O1xuICAgICAgICBQbGF0Zm9ybVJlZl8ucHJvdG90eXBlLl9ib290c3RyYXBNb2R1bGVGYWN0b3J5V2l0aFpvbmUgPSBmdW5jdGlvbiAobW9kdWxlRmFjdG9yeSwgbmdab25lKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgLy8gTm90ZTogV2UgbmVlZCB0byBjcmVhdGUgdGhlIE5nWm9uZSBfYmVmb3JlXyB3ZSBpbnN0YW50aWF0ZSB0aGUgbW9kdWxlLFxuICAgICAgICAgICAgLy8gYXMgaW5zdGFudGlhdGluZyB0aGUgbW9kdWxlIGNyZWF0ZXMgc29tZSBwcm92aWRlcnMgZWFnZXJseS5cbiAgICAgICAgICAgIC8vIFNvIHdlIGNyZWF0ZSBhIG1pbmkgcGFyZW50IGluamVjdG9yIHRoYXQganVzdCBjb250YWlucyB0aGUgbmV3IE5nWm9uZSBhbmRcbiAgICAgICAgICAgIC8vIHBhc3MgdGhhdCBhcyBwYXJlbnQgdG8gdGhlIE5nTW9kdWxlRmFjdG9yeS5cbiAgICAgICAgICAgIGlmICghbmdab25lKVxuICAgICAgICAgICAgICAgIG5nWm9uZSA9IG5ldyBOZ1pvbmUoeyBlbmFibGVMb25nU3RhY2tUcmFjZTogaXNEZXZNb2RlKCkgfSk7XG4gICAgICAgICAgICAvLyBBdHRlbnRpb246IERvbid0IHVzZSBBcHBsaWNhdGlvblJlZi5ydW4gaGVyZSxcbiAgICAgICAgICAgIC8vIGFzIHdlIHdhbnQgdG8gYmUgc3VyZSB0aGF0IGFsbCBwb3NzaWJsZSBjb25zdHJ1Y3RvciBjYWxscyBhcmUgaW5zaWRlIGBuZ1pvbmUucnVuYCFcbiAgICAgICAgICAgIHJldHVybiBuZ1pvbmUucnVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmdab25lSW5qZWN0b3IgPSBSZWZsZWN0aXZlSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbeyBwcm92aWRlOiBOZ1pvbmUsIHVzZVZhbHVlOiBuZ1pvbmUgfV0sIF90aGlzLmluamVjdG9yKTtcbiAgICAgICAgICAgICAgICB2YXIgbW9kdWxlUmVmID0gbW9kdWxlRmFjdG9yeS5jcmVhdGUobmdab25lSW5qZWN0b3IpO1xuICAgICAgICAgICAgICAgIHZhciBleGNlcHRpb25IYW5kbGVyID0gbW9kdWxlUmVmLmluamVjdG9yLmdldChFcnJvckhhbmRsZXIsIG51bGwpO1xuICAgICAgICAgICAgICAgIGlmICghZXhjZXB0aW9uSGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIEVycm9ySGFuZGxlci4gSXMgcGxhdGZvcm0gbW9kdWxlIChCcm93c2VyTW9kdWxlKSBpbmNsdWRlZD8nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbW9kdWxlUmVmLm9uRGVzdHJveShmdW5jdGlvbiAoKSB7IHJldHVybiBMaXN0V3JhcHBlci5yZW1vdmUoX3RoaXMuX21vZHVsZXMsIG1vZHVsZVJlZik7IH0pO1xuICAgICAgICAgICAgICAgIG5nWm9uZS5vbkVycm9yLnN1YnNjcmliZSh7IG5leHQ6IGZ1bmN0aW9uIChlcnJvcikgeyBleGNlcHRpb25IYW5kbGVyLmhhbmRsZUVycm9yKGVycm9yKTsgfSB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NhbGxBbmRSZXBvcnRUb0Vycm9ySGFuZGxlcihleGNlcHRpb25IYW5kbGVyLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbml0U3RhdHVzID0gbW9kdWxlUmVmLmluamVjdG9yLmdldChBcHBsaWNhdGlvbkluaXRTdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5pdFN0YXR1cy5kb25lUHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9tb2R1bGVEb0Jvb3RzdHJhcChtb2R1bGVSZWYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vZHVsZVJlZjtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgUGxhdGZvcm1SZWZfLnByb3RvdHlwZS5ib290c3RyYXBNb2R1bGUgPSBmdW5jdGlvbiAobW9kdWxlVHlwZSwgY29tcGlsZXJPcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoY29tcGlsZXJPcHRpb25zID09PSB2b2lkIDApIHsgY29tcGlsZXJPcHRpb25zID0gW107IH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ib290c3RyYXBNb2R1bGVXaXRoWm9uZShtb2R1bGVUeXBlLCBjb21waWxlck9wdGlvbnMsIG51bGwpO1xuICAgICAgICB9O1xuICAgICAgICBQbGF0Zm9ybVJlZl8ucHJvdG90eXBlLl9ib290c3RyYXBNb2R1bGVXaXRoWm9uZSA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlLCBjb21waWxlck9wdGlvbnMsIG5nWm9uZSwgY29tcG9uZW50RmFjdG9yeUNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKGNvbXBpbGVyT3B0aW9ucyA9PT0gdm9pZCAwKSB7IGNvbXBpbGVyT3B0aW9ucyA9IFtdOyB9XG4gICAgICAgICAgICB2YXIgY29tcGlsZXJGYWN0b3J5ID0gdGhpcy5pbmplY3Rvci5nZXQoQ29tcGlsZXJGYWN0b3J5KTtcbiAgICAgICAgICAgIHZhciBjb21waWxlciA9IGNvbXBpbGVyRmFjdG9yeS5jcmVhdGVDb21waWxlcihBcnJheS5pc0FycmF5KGNvbXBpbGVyT3B0aW9ucykgPyBjb21waWxlck9wdGlvbnMgOiBbY29tcGlsZXJPcHRpb25zXSk7XG4gICAgICAgICAgICAvLyB1Z2x5IGludGVybmFsIGFwaSBoYWNrOiBnZW5lcmF0ZSBob3N0IGNvbXBvbmVudCBmYWN0b3JpZXMgZm9yIGFsbCBkZWNsYXJlZCBjb21wb25lbnRzIGFuZFxuICAgICAgICAgICAgLy8gcGFzcyB0aGUgZmFjdG9yaWVzIGludG8gdGhlIGNhbGxiYWNrIC0gdGhpcyBpcyB1c2VkIGJ5IFVwZGF0ZUFkYXB0ZXIgdG8gZ2V0IGhvbGQgb2YgYWxsXG4gICAgICAgICAgICAvLyBmYWN0b3JpZXMuXG4gICAgICAgICAgICBpZiAoY29tcG9uZW50RmFjdG9yeUNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBpbGVyLmNvbXBpbGVNb2R1bGVBbmRBbGxDb21wb25lbnRzQXN5bmMobW9kdWxlVHlwZSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZ01vZHVsZUZhY3RvcnkgPSBfYS5uZ01vZHVsZUZhY3RvcnksIGNvbXBvbmVudEZhY3RvcmllcyA9IF9hLmNvbXBvbmVudEZhY3RvcmllcztcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RmFjdG9yeUNhbGxiYWNrKGNvbXBvbmVudEZhY3Rvcmllcyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fYm9vdHN0cmFwTW9kdWxlRmFjdG9yeVdpdGhab25lKG5nTW9kdWxlRmFjdG9yeSwgbmdab25lKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb21waWxlci5jb21waWxlTW9kdWxlQXN5bmMobW9kdWxlVHlwZSlcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAobW9kdWxlRmFjdG9yeSkgeyByZXR1cm4gX3RoaXMuX2Jvb3RzdHJhcE1vZHVsZUZhY3RvcnlXaXRoWm9uZShtb2R1bGVGYWN0b3J5LCBuZ1pvbmUpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgUGxhdGZvcm1SZWZfLnByb3RvdHlwZS5fbW9kdWxlRG9Cb290c3RyYXAgPSBmdW5jdGlvbiAobW9kdWxlUmVmKSB7XG4gICAgICAgICAgICB2YXIgYXBwUmVmID0gbW9kdWxlUmVmLmluamVjdG9yLmdldChBcHBsaWNhdGlvblJlZik7XG4gICAgICAgICAgICBpZiAobW9kdWxlUmVmLmJvb3RzdHJhcEZhY3Rvcmllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbW9kdWxlUmVmLmJvb3RzdHJhcEZhY3Rvcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChjb21wRmFjdG9yeSkgeyByZXR1cm4gYXBwUmVmLmJvb3RzdHJhcChjb21wRmFjdG9yeSk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobW9kdWxlUmVmLmluc3RhbmNlLm5nRG9Cb290c3RyYXApIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVSZWYuaW5zdGFuY2UubmdEb0Jvb3RzdHJhcChhcHBSZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKChcIlRoZSBtb2R1bGUgXCIgKyBzdHJpbmdpZnkobW9kdWxlUmVmLmluc3RhbmNlLmNvbnN0cnVjdG9yKSArIFwiIHdhcyBib290c3RyYXBwZWQsIGJ1dCBpdCBkb2VzIG5vdCBkZWNsYXJlIFxcXCJATmdNb2R1bGUuYm9vdHN0cmFwXFxcIiBjb21wb25lbnRzIG5vciBhIFxcXCJuZ0RvQm9vdHN0cmFwXFxcIiBtZXRob2QuIFwiKSArXG4gICAgICAgICAgICAgICAgICAgIFwiUGxlYXNlIGRlZmluZSBvbmUgb2YgdGhlc2UuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBQbGF0Zm9ybVJlZl8uZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgUGxhdGZvcm1SZWZfLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBJbmplY3RvciwgfSxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIFBsYXRmb3JtUmVmXztcbiAgICB9KFBsYXRmb3JtUmVmKSk7XG4gICAgLyoqXG4gICAgICogQSByZWZlcmVuY2UgdG8gYW4gQW5ndWxhciBhcHBsaWNhdGlvbiBydW5uaW5nIG9uIGEgcGFnZS5cbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGFib3V0IEFuZ3VsYXIgYXBwbGljYXRpb25zLCBzZWUgdGhlIGRvY3VtZW50YXRpb24gZm9yIHtAbGluayBib290c3RyYXB9LlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBBcHBsaWNhdGlvblJlZiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEFwcGxpY2F0aW9uUmVmKCkge1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcHBsaWNhdGlvblJlZi5wcm90b3R5cGUsIFwiY29tcG9uZW50VHlwZXNcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXQgYSBsaXN0IG9mIGNvbXBvbmVudCB0eXBlcyByZWdpc3RlcmVkIHRvIHRoaXMgYXBwbGljYXRpb24uXG4gICAgICAgICAgICAgKiBUaGlzIGxpc3QgaXMgcG9wdWxhdGVkIGV2ZW4gYmVmb3JlIHRoZSBjb21wb25lbnQgaXMgY3JlYXRlZC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmltcGxlbWVudGVkKCk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICA7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcHBsaWNhdGlvblJlZi5wcm90b3R5cGUsIFwiY29tcG9uZW50c1wiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldCBhIGxpc3Qgb2YgY29tcG9uZW50cyByZWdpc3RlcmVkIHRvIHRoaXMgYXBwbGljYXRpb24uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgO1xuICAgICAgICByZXR1cm4gQXBwbGljYXRpb25SZWY7XG4gICAgfSgpKTtcbiAgICB2YXIgQXBwbGljYXRpb25SZWZfID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDMoQXBwbGljYXRpb25SZWZfLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBBcHBsaWNhdGlvblJlZl8oX3pvbmUsIF9jb25zb2xlLCBfaW5qZWN0b3IsIF9leGNlcHRpb25IYW5kbGVyLCBfY29tcG9uZW50RmFjdG9yeVJlc29sdmVyLCBfaW5pdFN0YXR1cywgX3Rlc3RhYmlsaXR5UmVnaXN0cnksIF90ZXN0YWJpbGl0eSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fem9uZSA9IF96b25lO1xuICAgICAgICAgICAgdGhpcy5fY29uc29sZSA9IF9jb25zb2xlO1xuICAgICAgICAgICAgdGhpcy5faW5qZWN0b3IgPSBfaW5qZWN0b3I7XG4gICAgICAgICAgICB0aGlzLl9leGNlcHRpb25IYW5kbGVyID0gX2V4Y2VwdGlvbkhhbmRsZXI7XG4gICAgICAgICAgICB0aGlzLl9jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIgPSBfY29tcG9uZW50RmFjdG9yeVJlc29sdmVyO1xuICAgICAgICAgICAgdGhpcy5faW5pdFN0YXR1cyA9IF9pbml0U3RhdHVzO1xuICAgICAgICAgICAgdGhpcy5fdGVzdGFiaWxpdHlSZWdpc3RyeSA9IF90ZXN0YWJpbGl0eVJlZ2lzdHJ5O1xuICAgICAgICAgICAgdGhpcy5fdGVzdGFiaWxpdHkgPSBfdGVzdGFiaWxpdHk7XG4gICAgICAgICAgICB0aGlzLl9ib290c3RyYXBMaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RDb21wb25lbnRzID0gW107XG4gICAgICAgICAgICB0aGlzLl9yb290Q29tcG9uZW50VHlwZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fcnVubmluZ1RpY2sgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2VuZm9yY2VOb05ld0NoYW5nZXMgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2VuZm9yY2VOb05ld0NoYW5nZXMgPSBpc0Rldk1vZGUoKTtcbiAgICAgICAgICAgIHRoaXMuX3pvbmUub25NaWNyb3Rhc2tFbXB0eS5zdWJzY3JpYmUoeyBuZXh0OiBmdW5jdGlvbiAoKSB7IF90aGlzLl96b25lLnJ1bihmdW5jdGlvbiAoKSB7IF90aGlzLnRpY2soKTsgfSk7IH0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgQXBwbGljYXRpb25SZWZfLnByb3RvdHlwZS5yZWdpc3RlckNoYW5nZURldGVjdG9yID0gZnVuY3Rpb24gKGNoYW5nZURldGVjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZnMucHVzaChjaGFuZ2VEZXRlY3Rvcik7XG4gICAgICAgIH07XG4gICAgICAgIEFwcGxpY2F0aW9uUmVmXy5wcm90b3R5cGUudW5yZWdpc3RlckNoYW5nZURldGVjdG9yID0gZnVuY3Rpb24gKGNoYW5nZURldGVjdG9yKSB7XG4gICAgICAgICAgICBMaXN0V3JhcHBlci5yZW1vdmUodGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWZzLCBjaGFuZ2VEZXRlY3Rvcik7XG4gICAgICAgIH07XG4gICAgICAgIEFwcGxpY2F0aW9uUmVmXy5wcm90b3R5cGUuYm9vdHN0cmFwID0gZnVuY3Rpb24gKGNvbXBvbmVudE9yRmFjdG9yeSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGlmICghdGhpcy5faW5pdFN0YXR1cy5kb25lKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYm9vdHN0cmFwIGFzIHRoZXJlIGFyZSBzdGlsbCBhc3luY2hyb25vdXMgaW5pdGlhbGl6ZXJzIHJ1bm5pbmcuIEJvb3RzdHJhcCBjb21wb25lbnRzIGluIHRoZSBgbmdEb0Jvb3RzdHJhcGAgbWV0aG9kIG9mIHRoZSByb290IG1vZHVsZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjb21wb25lbnRGYWN0b3J5O1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudE9yRmFjdG9yeSBpbnN0YW5jZW9mIENvbXBvbmVudEZhY3RvcnkpIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRGYWN0b3J5ID0gY29tcG9uZW50T3JGYWN0b3J5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50RmFjdG9yeSA9IHRoaXMuX2NvbXBvbmVudEZhY3RvcnlSZXNvbHZlci5yZXNvbHZlQ29tcG9uZW50RmFjdG9yeShjb21wb25lbnRPckZhY3RvcnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcm9vdENvbXBvbmVudFR5cGVzLnB1c2goY29tcG9uZW50RmFjdG9yeS5jb21wb25lbnRUeXBlKTtcbiAgICAgICAgICAgIHZhciBjb21wUmVmID0gY29tcG9uZW50RmFjdG9yeS5jcmVhdGUodGhpcy5faW5qZWN0b3IsIFtdLCBjb21wb25lbnRGYWN0b3J5LnNlbGVjdG9yKTtcbiAgICAgICAgICAgIGNvbXBSZWYub25EZXN0cm95KGZ1bmN0aW9uICgpIHsgX3RoaXMuX3VubG9hZENvbXBvbmVudChjb21wUmVmKTsgfSk7XG4gICAgICAgICAgICB2YXIgdGVzdGFiaWxpdHkgPSBjb21wUmVmLmluamVjdG9yLmdldChUZXN0YWJpbGl0eSwgbnVsbCk7XG4gICAgICAgICAgICBpZiAodGVzdGFiaWxpdHkpIHtcbiAgICAgICAgICAgICAgICBjb21wUmVmLmluamVjdG9yLmdldChUZXN0YWJpbGl0eVJlZ2lzdHJ5KVxuICAgICAgICAgICAgICAgICAgICAucmVnaXN0ZXJBcHBsaWNhdGlvbihjb21wUmVmLmxvY2F0aW9uLm5hdGl2ZUVsZW1lbnQsIHRlc3RhYmlsaXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2xvYWRDb21wb25lbnQoY29tcFJlZik7XG4gICAgICAgICAgICBpZiAoaXNEZXZNb2RlKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb25zb2xlLmxvZyhcIkFuZ3VsYXIgMiBpcyBydW5uaW5nIGluIHRoZSBkZXZlbG9wbWVudCBtb2RlLiBDYWxsIGVuYWJsZVByb2RNb2RlKCkgdG8gZW5hYmxlIHRoZSBwcm9kdWN0aW9uIG1vZGUuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbXBSZWY7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgQXBwbGljYXRpb25SZWZfLnByb3RvdHlwZS5fbG9hZENvbXBvbmVudCA9IGZ1bmN0aW9uIChjb21wb25lbnRSZWYpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmcy5wdXNoKGNvbXBvbmVudFJlZi5jaGFuZ2VEZXRlY3RvclJlZik7XG4gICAgICAgICAgICB0aGlzLnRpY2soKTtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RDb21wb25lbnRzLnB1c2goY29tcG9uZW50UmVmKTtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgbGlzdGVuZXJzIGxhemlseSB0byBwcmV2ZW50IERJIGN5Y2xlcy5cbiAgICAgICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9pbmplY3Rvci5nZXQoQVBQX0JPT1RTVFJBUF9MSVNURU5FUiwgW10pXG4gICAgICAgICAgICAgICAgLmNvbmNhdCh0aGlzLl9ib290c3RyYXBMaXN0ZW5lcnMpO1xuICAgICAgICAgICAgbGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7IHJldHVybiBsaXN0ZW5lcihjb21wb25lbnRSZWYpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBBcHBsaWNhdGlvblJlZl8ucHJvdG90eXBlLl91bmxvYWRDb21wb25lbnQgPSBmdW5jdGlvbiAoY29tcG9uZW50UmVmKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcm9vdENvbXBvbmVudHMuaW5kZXhPZihjb21wb25lbnRSZWYpID09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51bnJlZ2lzdGVyQ2hhbmdlRGV0ZWN0b3IoY29tcG9uZW50UmVmLmNoYW5nZURldGVjdG9yUmVmKTtcbiAgICAgICAgICAgIExpc3RXcmFwcGVyLnJlbW92ZSh0aGlzLl9yb290Q29tcG9uZW50cywgY29tcG9uZW50UmVmKTtcbiAgICAgICAgfTtcbiAgICAgICAgQXBwbGljYXRpb25SZWZfLnByb3RvdHlwZS50aWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3J1bm5pbmdUaWNrKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBcHBsaWNhdGlvblJlZi50aWNrIGlzIGNhbGxlZCByZWN1cnNpdmVseScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNjb3BlID0gQXBwbGljYXRpb25SZWZfLl90aWNrU2NvcGUoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcnVubmluZ1RpY2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmcy5mb3JFYWNoKGZ1bmN0aW9uIChkZXRlY3RvcikgeyByZXR1cm4gZGV0ZWN0b3IuZGV0ZWN0Q2hhbmdlcygpOyB9KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZW5mb3JjZU5vTmV3Q2hhbmdlcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZnMuZm9yRWFjaChmdW5jdGlvbiAoZGV0ZWN0b3IpIHsgcmV0dXJuIGRldGVjdG9yLmNoZWNrTm9DaGFuZ2VzKCk7IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3J1bm5pbmdUaWNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgd3RmTGVhdmUoc2NvcGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBBcHBsaWNhdGlvblJlZl8ucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gVE9ETyhhbHhodWIpOiBEaXNwb3NlIG9mIHRoZSBOZ1pvbmUuXG4gICAgICAgICAgICB0aGlzLl9yb290Q29tcG9uZW50cy5zbGljZSgpLmZvckVhY2goZnVuY3Rpb24gKGNvbXBvbmVudCkgeyByZXR1cm4gY29tcG9uZW50LmRlc3Ryb3koKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcHBsaWNhdGlvblJlZl8ucHJvdG90eXBlLCBcImNvbXBvbmVudFR5cGVzXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcm9vdENvbXBvbmVudFR5cGVzOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFwcGxpY2F0aW9uUmVmXy5wcm90b3R5cGUsIFwiY29tcG9uZW50c1wiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3Jvb3RDb21wb25lbnRzOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBBcHBsaWNhdGlvblJlZl8uX3RpY2tTY29wZSA9IHd0ZkNyZWF0ZVNjb3BlKCdBcHBsaWNhdGlvblJlZiN0aWNrKCknKTtcbiAgICAgICAgQXBwbGljYXRpb25SZWZfLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IEluamVjdGFibGUgfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIEFwcGxpY2F0aW9uUmVmXy5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogTmdab25lLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBDb25zb2xlLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBJbmplY3RvciwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogRXJyb3JIYW5kbGVyLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsIH0sXG4gICAgICAgICAgICB7IHR5cGU6IEFwcGxpY2F0aW9uSW5pdFN0YXR1cywgfSxcbiAgICAgICAgICAgIHsgdHlwZTogVGVzdGFiaWxpdHlSZWdpc3RyeSwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgICAgICAgICB7IHR5cGU6IFRlc3RhYmlsaXR5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIEFwcGxpY2F0aW9uUmVmXztcbiAgICB9KEFwcGxpY2F0aW9uUmVmKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQ5ID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhbiBpbnN0YW5jZSBvZiBhbiBOZ01vZHVsZSBjcmVhdGVkIHZpYSBhIHtAbGluayBOZ01vZHVsZUZhY3Rvcnl9LlxuICAgICAqXG4gICAgICogYE5nTW9kdWxlUmVmYCBwcm92aWRlcyBhY2Nlc3MgdG8gdGhlIE5nTW9kdWxlIEluc3RhbmNlIGFzIHdlbGwgb3RoZXIgb2JqZWN0cyByZWxhdGVkIHRvIHRoaXNcbiAgICAgKiBOZ01vZHVsZSBJbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgTmdNb2R1bGVSZWYgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBOZ01vZHVsZVJlZigpIHtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdNb2R1bGVSZWYucHJvdG90eXBlLCBcImluamVjdG9yXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIGluamVjdG9yIHRoYXQgY29udGFpbnMgYWxsIG9mIHRoZSBwcm92aWRlcnMgb2YgdGhlIE5nTW9kdWxlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaW1wbGVtZW50ZWQoKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ01vZHVsZVJlZi5wcm90b3R5cGUsIFwiY29tcG9uZW50RmFjdG9yeVJlc29sdmVyXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlciB0byBnZXQgaG9sZCBvZiB0aGUgQ29tcG9uZW50RmFjdG9yaWVzXG4gICAgICAgICAgICAgKiBkZWNsYXJlZCBpbiB0aGUgYGVudHJ5Q29tcG9uZW50c2AgcHJvcGVydHkgb2YgdGhlIG1vZHVsZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmltcGxlbWVudGVkKCk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdNb2R1bGVSZWYucHJvdG90eXBlLCBcImluc3RhbmNlXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIE5nTW9kdWxlIGluc3RhbmNlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaW1wbGVtZW50ZWQoKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBOZ01vZHVsZVJlZjtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgTmdNb2R1bGVGYWN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTmdNb2R1bGVGYWN0b3J5KF9pbmplY3RvckNsYXNzLCBfbW9kdWxlVHlwZSkge1xuICAgICAgICAgICAgdGhpcy5faW5qZWN0b3JDbGFzcyA9IF9pbmplY3RvckNsYXNzO1xuICAgICAgICAgICAgdGhpcy5fbW9kdWxlVHlwZSA9IF9tb2R1bGVUeXBlO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ01vZHVsZUZhY3RvcnkucHJvdG90eXBlLCBcIm1vZHVsZVR5cGVcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9tb2R1bGVUeXBlOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgTmdNb2R1bGVGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAocGFyZW50SW5qZWN0b3IpIHtcbiAgICAgICAgICAgIGlmICghcGFyZW50SW5qZWN0b3IpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRJbmplY3RvciA9IEluamVjdG9yLk5VTEw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBuZXcgdGhpcy5faW5qZWN0b3JDbGFzcyhwYXJlbnRJbmplY3Rvcik7XG4gICAgICAgICAgICBpbnN0YW5jZS5jcmVhdGUoKTtcbiAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE5nTW9kdWxlRmFjdG9yeTtcbiAgICB9KCkpO1xuICAgIHZhciBfVU5ERUZJTkVEID0gbmV3IE9iamVjdCgpO1xuICAgIHZhciBOZ01vZHVsZUluamVjdG9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDkoTmdNb2R1bGVJbmplY3RvciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gTmdNb2R1bGVJbmplY3RvcihwYXJlbnQsIGZhY3RvcmllcywgYm9vdHN0cmFwRmFjdG9yaWVzKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBmYWN0b3JpZXMsIHBhcmVudC5nZXQoQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLCBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIuTlVMTCkpO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgICAgICB0aGlzLmJvb3RzdHJhcEZhY3RvcmllcyA9IGJvb3RzdHJhcEZhY3RvcmllcztcbiAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3lMaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIE5nTW9kdWxlSW5qZWN0b3IucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHsgdGhpcy5pbnN0YW5jZSA9IHRoaXMuY3JlYXRlSW50ZXJuYWwoKTsgfTtcbiAgICAgICAgTmdNb2R1bGVJbmplY3Rvci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHRva2VuLCBub3RGb3VuZFZhbHVlKSB7XG4gICAgICAgICAgICBpZiAobm90Rm91bmRWYWx1ZSA9PT0gdm9pZCAwKSB7IG5vdEZvdW5kVmFsdWUgPSBUSFJPV19JRl9OT1RfRk9VTkQ7IH1cbiAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gSW5qZWN0b3IgfHwgdG9rZW4gPT09IENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuZ2V0SW50ZXJuYWwodG9rZW4sIF9VTkRFRklORUQpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gX1VOREVGSU5FRCA/IHRoaXMucGFyZW50LmdldCh0b2tlbiwgbm90Rm91bmRWYWx1ZSkgOiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ01vZHVsZUluamVjdG9yLnByb3RvdHlwZSwgXCJpbmplY3RvclwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdNb2R1bGVJbmplY3Rvci5wcm90b3R5cGUsIFwiY29tcG9uZW50RmFjdG9yeVJlc29sdmVyXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE5nTW9kdWxlSW5qZWN0b3IucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIG5nIG1vZHVsZSBcIiArIHN0cmluZ2lmeSh0aGlzLmluc3RhbmNlLmNvbnN0cnVjdG9yKSArIFwiIGhhcyBhbHJlYWR5IGJlZW4gZGVzdHJveWVkLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3lJbnRlcm5hbCgpO1xuICAgICAgICAgICAgdGhpcy5fZGVzdHJveUxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikgeyByZXR1cm4gbGlzdGVuZXIoKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIE5nTW9kdWxlSW5qZWN0b3IucHJvdG90eXBlLm9uRGVzdHJveSA9IGZ1bmN0aW9uIChjYWxsYmFjaykgeyB0aGlzLl9kZXN0cm95TGlzdGVuZXJzLnB1c2goY2FsbGJhY2spOyB9O1xuICAgICAgICByZXR1cm4gTmdNb2R1bGVJbmplY3RvcjtcbiAgICB9KENvZGVnZW5Db21wb25lbnRGYWN0b3J5UmVzb2x2ZXIpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGxvYWQgbmcgbW9kdWxlIGZhY3Rvcmllcy5cbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIE5nTW9kdWxlRmFjdG9yeUxvYWRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE5nTW9kdWxlRmFjdG9yeUxvYWRlcigpIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTmdNb2R1bGVGYWN0b3J5TG9hZGVyO1xuICAgIH0oKSk7XG4gICAgdmFyIG1vZHVsZUZhY3RvcmllcyA9IG5ldyBNYXAoKTtcbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBsb2FkZWQgbW9kdWxlLiBTaG91bGQgb25seSBiZSBjYWxsZWQgZnJvbSBnZW5lcmF0ZWQgTmdNb2R1bGVGYWN0b3J5IGNvZGUuXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlZ2lzdGVyTW9kdWxlRmFjdG9yeShpZCwgZmFjdG9yeSkge1xuICAgICAgICB2YXIgZXhpc3RpbmcgPSBtb2R1bGVGYWN0b3JpZXMuZ2V0KGlkKTtcbiAgICAgICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgbW9kdWxlIHJlZ2lzdGVyZWQgZm9yIFwiICsgaWQgKyBcIiAtIFwiICsgZXhpc3RpbmcubW9kdWxlVHlwZS5uYW1lICsgXCIgdnMgXCIgKyBmYWN0b3J5Lm1vZHVsZVR5cGUubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgbW9kdWxlRmFjdG9yaWVzLnNldChpZCwgZmFjdG9yeSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIE5nTW9kdWxlRmFjdG9yeSB3aXRoIHRoZSBnaXZlbiBpZCwgaWYgaXQgZXhpc3RzIGFuZCBoYXMgYmVlbiBsb2FkZWQuXG4gICAgICogRmFjdG9yaWVzIGZvciBtb2R1bGVzIHRoYXQgZG8gbm90IHNwZWNpZnkgYW4gYGlkYCBjYW5ub3QgYmUgcmV0cmlldmVkLiBUaHJvd3MgaWYgdGhlIG1vZHVsZVxuICAgICAqIGNhbm5vdCBiZSBmb3VuZC5cbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0TW9kdWxlRmFjdG9yeShpZCkge1xuICAgICAgICB2YXIgZmFjdG9yeSA9IG1vZHVsZUZhY3Rvcmllcy5nZXQoaWQpO1xuICAgICAgICBpZiAoIWZhY3RvcnkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBtb2R1bGUgd2l0aCBJRCBcIiArIGlkICsgXCIgbG9hZGVkXCIpO1xuICAgICAgICByZXR1cm4gZmFjdG9yeTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbiB1bm1vZGlmaWFibGUgbGlzdCBvZiBpdGVtcyB0aGF0IEFuZ3VsYXIga2VlcHMgdXAgdG8gZGF0ZSB3aGVuIHRoZSBzdGF0ZVxuICAgICAqIG9mIHRoZSBhcHBsaWNhdGlvbiBjaGFuZ2VzLlxuICAgICAqXG4gICAgICogVGhlIHR5cGUgb2Ygb2JqZWN0IHRoYXQge0BsaW5rIFF1ZXJ5fSBhbmQge0BsaW5rIFZpZXdRdWVyeU1ldGFkYXRhfSBwcm92aWRlLlxuICAgICAqXG4gICAgICogSW1wbGVtZW50cyBhbiBpdGVyYWJsZSBpbnRlcmZhY2UsIHRoZXJlZm9yZSBpdCBjYW4gYmUgdXNlZCBpbiBib3RoIEVTNlxuICAgICAqIGphdmFzY3JpcHQgYGZvciAodmFyIGkgb2YgaXRlbXMpYCBsb29wcyBhcyB3ZWxsIGFzIGluIEFuZ3VsYXIgdGVtcGxhdGVzIHdpdGhcbiAgICAgKiBgKm5nRm9yPVwibGV0IGkgb2YgbXlMaXN0XCJgLlxuICAgICAqXG4gICAgICogQ2hhbmdlcyBjYW4gYmUgb2JzZXJ2ZWQgYnkgc3Vic2NyaWJpbmcgdG8gdGhlIGNoYW5nZXMgYE9ic2VydmFibGVgLlxuICAgICAqXG4gICAgICogTk9URTogSW4gdGhlIGZ1dHVyZSB0aGlzIGNsYXNzIHdpbGwgaW1wbGVtZW50IGFuIGBPYnNlcnZhYmxlYCBpbnRlcmZhY2UuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvUlg4c0puUVlsOUZXdVNDV21lNXo/cD1wcmV2aWV3KSlcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogQENvbXBvbmVudCh7Li4ufSlcbiAgICAgKiBjbGFzcyBDb250YWluZXIge1xuICAgICAqICAgQFZpZXdDaGlsZHJlbihJdGVtKSBpdGVtczpRdWVyeUxpc3Q8SXRlbT47XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgUXVlcnlMaXN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUXVlcnlMaXN0KCkge1xuICAgICAgICAgICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fZW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUXVlcnlMaXN0LnByb3RvdHlwZSwgXCJjaGFuZ2VzXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZW1pdHRlcjsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShRdWVyeUxpc3QucHJvdG90eXBlLCBcImxlbmd0aFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3Jlc3VsdHMubGVuZ3RoOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFF1ZXJ5TGlzdC5wcm90b3R5cGUsIFwiZmlyc3RcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9yZXN1bHRzWzBdOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFF1ZXJ5TGlzdC5wcm90b3R5cGUsIFwibGFzdFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3Jlc3VsdHNbdGhpcy5sZW5ndGggLSAxXTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZWVcbiAgICAgICAgICogW0FycmF5Lm1hcF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvbWFwKVxuICAgICAgICAgKi9cbiAgICAgICAgUXVlcnlMaXN0LnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIHRoaXMuX3Jlc3VsdHMubWFwKGZuKTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlZVxuICAgICAgICAgKiBbQXJyYXkuZmlsdGVyXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9maWx0ZXIpXG4gICAgICAgICAqL1xuICAgICAgICBRdWVyeUxpc3QucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc3VsdHMuZmlsdGVyKGZuKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlZVxuICAgICAgICAgKiBbQXJyYXkucmVkdWNlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9yZWR1Y2UpXG4gICAgICAgICAqL1xuICAgICAgICBRdWVyeUxpc3QucHJvdG90eXBlLnJlZHVjZSA9IGZ1bmN0aW9uIChmbiwgaW5pdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc3VsdHMucmVkdWNlKGZuLCBpbml0KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlZVxuICAgICAgICAgKiBbQXJyYXkuZm9yRWFjaF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvZm9yRWFjaClcbiAgICAgICAgICovXG4gICAgICAgIFF1ZXJ5TGlzdC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLl9yZXN1bHRzLmZvckVhY2goZm4pOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2VlXG4gICAgICAgICAqIFtBcnJheS5zb21lXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9zb21lKVxuICAgICAgICAgKi9cbiAgICAgICAgUXVlcnlMaXN0LnByb3RvdHlwZS5zb21lID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVzdWx0cy5zb21lKGZuKTtcbiAgICAgICAgfTtcbiAgICAgICAgUXVlcnlMaXN0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcmVzdWx0cy5zbGljZSgpOyB9O1xuICAgICAgICBRdWVyeUxpc3QucHJvdG90eXBlW2dldFN5bWJvbEl0ZXJhdG9yKCldID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcmVzdWx0c1tnZXRTeW1ib2xJdGVyYXRvcigpXSgpOyB9O1xuICAgICAgICBRdWVyeUxpc3QucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcmVzdWx0cy50b1N0cmluZygpOyB9O1xuICAgICAgICBRdWVyeUxpc3QucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAgICAgdGhpcy5fcmVzdWx0cyA9IExpc3RXcmFwcGVyLmZsYXR0ZW4ocmVzKTtcbiAgICAgICAgICAgIHRoaXMuX2RpcnR5ID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIFF1ZXJ5TGlzdC5wcm90b3R5cGUubm90aWZ5T25DaGFuZ2VzID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9lbWl0dGVyLmVtaXQodGhpcyk7IH07XG4gICAgICAgIC8qKiBpbnRlcm5hbCAqL1xuICAgICAgICBRdWVyeUxpc3QucHJvdG90eXBlLnNldERpcnR5ID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9kaXJ0eSA9IHRydWU7IH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShRdWVyeUxpc3QucHJvdG90eXBlLCBcImRpcnR5XCIsIHtcbiAgICAgICAgICAgIC8qKiBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kaXJ0eTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBRdWVyeUxpc3Q7XG4gICAgfSgpKTtcblxuICAgIHZhciBfU0VQQVJBVE9SID0gJyMnO1xuICAgIHZhciBGQUNUT1JZX0NMQVNTX1NVRkZJWCA9ICdOZ0ZhY3RvcnknO1xuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyYXRpb24gZm9yIFN5c3RlbUpzTmdNb2R1bGVMb2FkZXIuXG4gICAgICogdG9rZW4uXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgdmFyIFN5c3RlbUpzTmdNb2R1bGVMb2FkZXJDb25maWcgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBTeXN0ZW1Kc05nTW9kdWxlTG9hZGVyQ29uZmlnKCkge1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTeXN0ZW1Kc05nTW9kdWxlTG9hZGVyQ29uZmlnO1xuICAgIH0oKSk7XG4gICAgdmFyIERFRkFVTFRfQ09ORklHID0ge1xuICAgICAgICBmYWN0b3J5UGF0aFByZWZpeDogJycsXG4gICAgICAgIGZhY3RvcnlQYXRoU3VmZml4OiAnLm5nZmFjdG9yeScsXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBOZ01vZHVsZUZhY3RvcnlMb2FkZXIgdGhhdCB1c2VzIFN5c3RlbUpTIHRvIGxvYWQgTmdNb2R1bGVGYWN0b3J5XG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBTeXN0ZW1Kc05nTW9kdWxlTG9hZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gU3lzdGVtSnNOZ01vZHVsZUxvYWRlcihfY29tcGlsZXIsIGNvbmZpZykge1xuICAgICAgICAgICAgdGhpcy5fY29tcGlsZXIgPSBfY29tcGlsZXI7XG4gICAgICAgICAgICB0aGlzLl9jb25maWcgPSBjb25maWcgfHwgREVGQVVMVF9DT05GSUc7XG4gICAgICAgIH1cbiAgICAgICAgU3lzdGVtSnNOZ01vZHVsZUxvYWRlci5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgICAgICB2YXIgb2ZmbGluZU1vZGUgPSB0aGlzLl9jb21waWxlciBpbnN0YW5jZW9mIENvbXBpbGVyO1xuICAgICAgICAgICAgcmV0dXJuIG9mZmxpbmVNb2RlID8gdGhpcy5sb2FkRmFjdG9yeShwYXRoKSA6IHRoaXMubG9hZEFuZENvbXBpbGUocGF0aCk7XG4gICAgICAgIH07XG4gICAgICAgIFN5c3RlbUpzTmdNb2R1bGVMb2FkZXIucHJvdG90eXBlLmxvYWRBbmRDb21waWxlID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgX2EgPSBwYXRoLnNwbGl0KF9TRVBBUkFUT1IpLCBtb2R1bGUgPSBfYVswXSwgZXhwb3J0TmFtZSA9IF9hWzFdO1xuICAgICAgICAgICAgaWYgKGV4cG9ydE5hbWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBleHBvcnROYW1lID0gJ2RlZmF1bHQnO1xuICAgICAgICAgICAgcmV0dXJuIFN5c3RlbS5pbXBvcnQobW9kdWxlKVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChtb2R1bGUpIHsgcmV0dXJuIG1vZHVsZVtleHBvcnROYW1lXTsgfSlcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gY2hlY2tOb3RFbXB0eSh0eXBlLCBtb2R1bGUsIGV4cG9ydE5hbWUpOyB9KVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiBfdGhpcy5fY29tcGlsZXIuY29tcGlsZU1vZHVsZUFzeW5jKHR5cGUpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgU3lzdGVtSnNOZ01vZHVsZUxvYWRlci5wcm90b3R5cGUubG9hZEZhY3RvcnkgPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICAgICAgdmFyIF9hID0gcGF0aC5zcGxpdChfU0VQQVJBVE9SKSwgbW9kdWxlID0gX2FbMF0sIGV4cG9ydE5hbWUgPSBfYVsxXTtcbiAgICAgICAgICAgIHZhciBmYWN0b3J5Q2xhc3NTdWZmaXggPSBGQUNUT1JZX0NMQVNTX1NVRkZJWDtcbiAgICAgICAgICAgIGlmIChleHBvcnROYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBleHBvcnROYW1lID0gJ2RlZmF1bHQnO1xuICAgICAgICAgICAgICAgIGZhY3RvcnlDbGFzc1N1ZmZpeCA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFN5c3RlbS5pbXBvcnQodGhpcy5fY29uZmlnLmZhY3RvcnlQYXRoUHJlZml4ICsgbW9kdWxlICsgdGhpcy5fY29uZmlnLmZhY3RvcnlQYXRoU3VmZml4KVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChtb2R1bGUpIHsgcmV0dXJuIG1vZHVsZVtleHBvcnROYW1lICsgZmFjdG9yeUNsYXNzU3VmZml4XTsgfSlcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoZmFjdG9yeSkgeyByZXR1cm4gY2hlY2tOb3RFbXB0eShmYWN0b3J5LCBtb2R1bGUsIGV4cG9ydE5hbWUpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgU3lzdGVtSnNOZ01vZHVsZUxvYWRlci5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBJbmplY3RhYmxlIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBTeXN0ZW1Kc05nTW9kdWxlTG9hZGVyLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBDb21waWxlciwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogU3lzdGVtSnNOZ01vZHVsZUxvYWRlckNvbmZpZywgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBTeXN0ZW1Kc05nTW9kdWxlTG9hZGVyO1xuICAgIH0oKSk7XG4gICAgZnVuY3Rpb24gY2hlY2tOb3RFbXB0eSh2YWx1ZSwgbW9kdWxlUGF0aCwgZXhwb3J0TmFtZSkge1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCAnXCIgKyBleHBvcnROYW1lICsgXCInIGluICdcIiArIG1vZHVsZVBhdGggKyBcIidcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDEwID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhbiBFbWJlZGRlZCBUZW1wbGF0ZSB0aGF0IGNhbiBiZSB1c2VkIHRvIGluc3RhbnRpYXRlIEVtYmVkZGVkIFZpZXdzLlxuICAgICAqXG4gICAgICogWW91IGNhbiBhY2Nlc3MgYSBgVGVtcGxhdGVSZWZgLCBpbiB0d28gd2F5cy4gVmlhIGEgZGlyZWN0aXZlIHBsYWNlZCBvbiBhIGA8dGVtcGxhdGU+YCBlbGVtZW50IChvclxuICAgICAqIGRpcmVjdGl2ZSBwcmVmaXhlZCB3aXRoIGAqYCkgYW5kIGhhdmUgdGhlIGBUZW1wbGF0ZVJlZmAgZm9yIHRoaXMgRW1iZWRkZWQgVmlldyBpbmplY3RlZCBpbnRvIHRoZVxuICAgICAqIGNvbnN0cnVjdG9yIG9mIHRoZSBkaXJlY3RpdmUgdXNpbmcgdGhlIGBUZW1wbGF0ZVJlZmAgVG9rZW4uIEFsdGVybmF0aXZlbHkgeW91IGNhbiBxdWVyeSBmb3IgdGhlXG4gICAgICogYFRlbXBsYXRlUmVmYCBmcm9tIGEgQ29tcG9uZW50IG9yIGEgRGlyZWN0aXZlIHZpYSB7QGxpbmsgUXVlcnl9LlxuICAgICAqXG4gICAgICogVG8gaW5zdGFudGlhdGUgRW1iZWRkZWQgVmlld3MgYmFzZWQgb24gYSBUZW1wbGF0ZSwgdXNlXG4gICAgICoge0BsaW5rIFZpZXdDb250YWluZXJSZWYjY3JlYXRlRW1iZWRkZWRWaWV3fSwgd2hpY2ggd2lsbCBjcmVhdGUgdGhlIFZpZXcgYW5kIGF0dGFjaCBpdCB0byB0aGVcbiAgICAgKiBWaWV3IENvbnRhaW5lci5cbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIFRlbXBsYXRlUmVmID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gVGVtcGxhdGVSZWYoKSB7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRlbXBsYXRlUmVmLnByb3RvdHlwZSwgXCJlbGVtZW50UmVmXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIGxvY2F0aW9uIGluIHRoZSBWaWV3IHdoZXJlIHRoZSBFbWJlZGRlZCBWaWV3IGxvZ2ljYWxseSBiZWxvbmdzIHRvLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIFRoZSBkYXRhLWJpbmRpbmcgYW5kIGluamVjdGlvbiBjb250ZXh0cyBvZiBFbWJlZGRlZCBWaWV3cyBjcmVhdGVkIGZyb20gdGhpcyBgVGVtcGxhdGVSZWZgXG4gICAgICAgICAgICAgKiBpbmhlcml0IGZyb20gdGhlIGNvbnRleHRzIG9mIHRoaXMgbG9jYXRpb24uXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogVHlwaWNhbGx5IG5ldyBFbWJlZGRlZCBWaWV3cyBhcmUgYXR0YWNoZWQgdG8gdGhlIFZpZXcgQ29udGFpbmVyIG9mIHRoaXMgbG9jYXRpb24sIGJ1dCBpblxuICAgICAgICAgICAgICogYWR2YW5jZWQgdXNlLWNhc2VzLCB0aGUgVmlldyBjYW4gYmUgYXR0YWNoZWQgdG8gYSBkaWZmZXJlbnQgY29udGFpbmVyIHdoaWxlIGtlZXBpbmcgdGhlXG4gICAgICAgICAgICAgKiBkYXRhLWJpbmRpbmcgYW5kIGluamVjdGlvbiBjb250ZXh0IGZyb20gdGhlIG9yaWdpbmFsIGxvY2F0aW9uLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLy8gVE9ETyhpKTogcmVuYW1lIHRvIGFuY2hvciBvciBsb2NhdGlvblxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFRlbXBsYXRlUmVmO1xuICAgIH0oKSk7XG4gICAgdmFyIFRlbXBsYXRlUmVmXyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQxMChUZW1wbGF0ZVJlZl8sIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIFRlbXBsYXRlUmVmXyhfYXBwRWxlbWVudCwgX3ZpZXdGYWN0b3J5KSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX2FwcEVsZW1lbnQgPSBfYXBwRWxlbWVudDtcbiAgICAgICAgICAgIHRoaXMuX3ZpZXdGYWN0b3J5ID0gX3ZpZXdGYWN0b3J5O1xuICAgICAgICB9XG4gICAgICAgIFRlbXBsYXRlUmVmXy5wcm90b3R5cGUuY3JlYXRlRW1iZWRkZWRWaWV3ID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciB2aWV3ID0gdGhpcy5fdmlld0ZhY3RvcnkodGhpcy5fYXBwRWxlbWVudC5wYXJlbnRWaWV3LnZpZXdVdGlscywgdGhpcy5fYXBwRWxlbWVudC5wYXJlbnRJbmplY3RvciwgdGhpcy5fYXBwRWxlbWVudCk7XG4gICAgICAgICAgICB2aWV3LmNyZWF0ZShjb250ZXh0IHx8IHt9LCBudWxsLCBudWxsKTtcbiAgICAgICAgICAgIHJldHVybiB2aWV3LnJlZjtcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRlbXBsYXRlUmVmXy5wcm90b3R5cGUsIFwiZWxlbWVudFJlZlwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2FwcEVsZW1lbnQuZWxlbWVudFJlZjsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBUZW1wbGF0ZVJlZl87XG4gICAgfShUZW1wbGF0ZVJlZikpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfcXVldWVkQW5pbWF0aW9ucyA9IFtdO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBmdW5jdGlvbiBxdWV1ZUFuaW1hdGlvbkdsb2JhbGx5KHBsYXllcikge1xuICAgICAgICBfcXVldWVkQW5pbWF0aW9ucy5wdXNoKHBsYXllcik7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBmdW5jdGlvbiB0cmlnZ2VyUXVldWVkQW5pbWF0aW9ucygpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfcXVldWVkQW5pbWF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHBsYXllciA9IF9xdWV1ZWRBbmltYXRpb25zW2ldO1xuICAgICAgICAgICAgcGxheWVyLnBsYXkoKTtcbiAgICAgICAgfVxuICAgICAgICBfcXVldWVkQW5pbWF0aW9ucyA9IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDExID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBWaWV3UmVmID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gVmlld1JlZigpIHtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVmlld1JlZi5wcm90b3R5cGUsIFwiZGVzdHJveWVkXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFZpZXdSZWY7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGFuIEFuZ3VsYXIgVmlldy5cbiAgICAgKlxuICAgICAqIDwhLS0gVE9ETzogbW92ZSB0aGUgbmV4dCB0d28gcGFyYWdyYXBocyB0byB0aGUgZGV2IGd1aWRlIC0tPlxuICAgICAqIEEgVmlldyBpcyBhIGZ1bmRhbWVudGFsIGJ1aWxkaW5nIGJsb2NrIG9mIHRoZSBhcHBsaWNhdGlvbiBVSS4gSXQgaXMgdGhlIHNtYWxsZXN0IGdyb3VwaW5nIG9mXG4gICAgICogRWxlbWVudHMgd2hpY2ggYXJlIGNyZWF0ZWQgYW5kIGRlc3Ryb3llZCB0b2dldGhlci5cbiAgICAgKlxuICAgICAqIFByb3BlcnRpZXMgb2YgZWxlbWVudHMgaW4gYSBWaWV3IGNhbiBjaGFuZ2UsIGJ1dCB0aGUgc3RydWN0dXJlIChudW1iZXIgYW5kIG9yZGVyKSBvZiBlbGVtZW50cyBpblxuICAgICAqIGEgVmlldyBjYW5ub3QuIENoYW5naW5nIHRoZSBzdHJ1Y3R1cmUgb2YgRWxlbWVudHMgY2FuIG9ubHkgYmUgZG9uZSBieSBpbnNlcnRpbmcsIG1vdmluZyBvclxuICAgICAqIHJlbW92aW5nIG5lc3RlZCBWaWV3cyB2aWEgYSB7QGxpbmsgVmlld0NvbnRhaW5lclJlZn0uIEVhY2ggVmlldyBjYW4gY29udGFpbiBtYW55IFZpZXcgQ29udGFpbmVycy5cbiAgICAgKiA8IS0tIC9UT0RPIC0tPlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGVcbiAgICAgKlxuICAgICAqIEdpdmVuIHRoaXMgdGVtcGxhdGUuLi5cbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIENvdW50OiB7e2l0ZW1zLmxlbmd0aH19XG4gICAgICogPHVsPlxuICAgICAqICAgPGxpICpuZ0Zvcj1cImxldCAgaXRlbSBvZiBpdGVtc1wiPnt7aXRlbX19PC9saT5cbiAgICAgKiA8L3VsPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogV2UgaGF2ZSB0d28ge0BsaW5rIFRlbXBsYXRlUmVmfXM6XG4gICAgICpcbiAgICAgKiBPdXRlciB7QGxpbmsgVGVtcGxhdGVSZWZ9OlxuICAgICAqIGBgYFxuICAgICAqIENvdW50OiB7e2l0ZW1zLmxlbmd0aH19XG4gICAgICogPHVsPlxuICAgICAqICAgPHRlbXBsYXRlIG5nRm9yIGxldC1pdGVtIFtuZ0Zvck9mXT1cIml0ZW1zXCI+PC90ZW1wbGF0ZT5cbiAgICAgKiA8L3VsPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogSW5uZXIge0BsaW5rIFRlbXBsYXRlUmVmfTpcbiAgICAgKiBgYGBcbiAgICAgKiAgIDxsaT57e2l0ZW19fTwvbGk+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBOb3RpY2UgdGhhdCB0aGUgb3JpZ2luYWwgdGVtcGxhdGUgaXMgYnJva2VuIGRvd24gaW50byB0d28gc2VwYXJhdGUge0BsaW5rIFRlbXBsYXRlUmVmfXMuXG4gICAgICpcbiAgICAgKiBUaGUgb3V0ZXIvaW5uZXIge0BsaW5rIFRlbXBsYXRlUmVmfXMgYXJlIHRoZW4gYXNzZW1ibGVkIGludG8gdmlld3MgbGlrZSBzbzpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIDwhLS0gVmlld1JlZjogb3V0ZXItMCAtLT5cbiAgICAgKiBDb3VudDogMlxuICAgICAqIDx1bD5cbiAgICAgKiAgIDx0ZW1wbGF0ZSB2aWV3LWNvbnRhaW5lci1yZWY+PC90ZW1wbGF0ZT5cbiAgICAgKiAgIDwhLS0gVmlld1JlZjogaW5uZXItMSAtLT48bGk+Zmlyc3Q8L2xpPjwhLS0gL1ZpZXdSZWY6IGlubmVyLTEgLS0+XG4gICAgICogICA8IS0tIFZpZXdSZWY6IGlubmVyLTIgLS0+PGxpPnNlY29uZDwvbGk+PCEtLSAvVmlld1JlZjogaW5uZXItMiAtLT5cbiAgICAgKiA8L3VsPlxuICAgICAqIDwhLS0gL1ZpZXdSZWY6IG91dGVyLTAgLS0+XG4gICAgICogYGBgXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBFbWJlZGRlZFZpZXdSZWYgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMTEoRW1iZWRkZWRWaWV3UmVmLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBFbWJlZGRlZFZpZXdSZWYoKSB7XG4gICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRW1iZWRkZWRWaWV3UmVmLnByb3RvdHlwZSwgXCJjb250ZXh0XCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEVtYmVkZGVkVmlld1JlZi5wcm90b3R5cGUsIFwicm9vdE5vZGVzXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgO1xuICAgICAgICByZXR1cm4gRW1iZWRkZWRWaWV3UmVmO1xuICAgIH0oVmlld1JlZikpO1xuICAgIHZhciBWaWV3UmVmXyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFZpZXdSZWZfKF92aWV3KSB7XG4gICAgICAgICAgICB0aGlzLl92aWV3ID0gX3ZpZXc7XG4gICAgICAgICAgICB0aGlzLl92aWV3ID0gX3ZpZXc7XG4gICAgICAgICAgICB0aGlzLl9vcmlnaW5hbE1vZGUgPSB0aGlzLl92aWV3LmNkTW9kZTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVmlld1JlZl8ucHJvdG90eXBlLCBcImludGVybmFsVmlld1wiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3ZpZXc7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVmlld1JlZl8ucHJvdG90eXBlLCBcInJvb3ROb2Rlc1wiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3ZpZXcuZmxhdFJvb3ROb2RlczsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaWV3UmVmXy5wcm90b3R5cGUsIFwiY29udGV4dFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3ZpZXcuY29udGV4dDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaWV3UmVmXy5wcm90b3R5cGUsIFwiZGVzdHJveWVkXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fdmlldy5kZXN0cm95ZWQ7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBWaWV3UmVmXy5wcm90b3R5cGUubWFya0ZvckNoZWNrID0gZnVuY3Rpb24gKCkgeyB0aGlzLl92aWV3Lm1hcmtQYXRoVG9Sb290QXNDaGVja09uY2UoKTsgfTtcbiAgICAgICAgVmlld1JlZl8ucHJvdG90eXBlLmRldGFjaCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fdmlldy5jZE1vZGUgPSBDaGFuZ2VEZXRlY3RvclN0YXR1cy5EZXRhY2hlZDsgfTtcbiAgICAgICAgVmlld1JlZl8ucHJvdG90eXBlLmRldGVjdENoYW5nZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl92aWV3LmRldGVjdENoYW5nZXMoZmFsc2UpO1xuICAgICAgICAgICAgdHJpZ2dlclF1ZXVlZEFuaW1hdGlvbnMoKTtcbiAgICAgICAgfTtcbiAgICAgICAgVmlld1JlZl8ucHJvdG90eXBlLmNoZWNrTm9DaGFuZ2VzID0gZnVuY3Rpb24gKCkgeyB0aGlzLl92aWV3LmRldGVjdENoYW5nZXModHJ1ZSk7IH07XG4gICAgICAgIFZpZXdSZWZfLnByb3RvdHlwZS5yZWF0dGFjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZpZXcuY2RNb2RlID0gdGhpcy5fb3JpZ2luYWxNb2RlO1xuICAgICAgICAgICAgdGhpcy5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgfTtcbiAgICAgICAgVmlld1JlZl8ucHJvdG90eXBlLm9uRGVzdHJveSA9IGZ1bmN0aW9uIChjYWxsYmFjaykgeyB0aGlzLl92aWV3LmRpc3Bvc2FibGVzLnB1c2goY2FsbGJhY2spOyB9O1xuICAgICAgICBWaWV3UmVmXy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fdmlldy5kZXN0cm95KCk7IH07XG4gICAgICAgIHJldHVybiBWaWV3UmVmXztcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkMTIgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICB2YXIgRXZlbnRMaXN0ZW5lciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEV2ZW50TGlzdGVuZXIobmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgICByZXR1cm4gRXZlbnRMaXN0ZW5lcjtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIEBleHBlcmltZW50YWwgQWxsIGRlYnVnZ2luZyBhcGlzIGFyZSBjdXJyZW50bHkgZXhwZXJpbWVudGFsLlxuICAgICAqL1xuICAgIHZhciBEZWJ1Z05vZGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBEZWJ1Z05vZGUobmF0aXZlTm9kZSwgcGFyZW50LCBfZGVidWdJbmZvKSB7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1Z0luZm8gPSBfZGVidWdJbmZvO1xuICAgICAgICAgICAgdGhpcy5uYXRpdmVOb2RlID0gbmF0aXZlTm9kZTtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQocGFyZW50KSAmJiBwYXJlbnQgaW5zdGFuY2VvZiBEZWJ1Z0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQuYWRkQ2hpbGQodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxpc3RlbmVycyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWJ1Z05vZGUucHJvdG90eXBlLCBcImluamVjdG9yXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaXNQcmVzZW50KHRoaXMuX2RlYnVnSW5mbykgPyB0aGlzLl9kZWJ1Z0luZm8uaW5qZWN0b3IgOiBudWxsOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERlYnVnTm9kZS5wcm90b3R5cGUsIFwiY29tcG9uZW50SW5zdGFuY2VcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLl9kZWJ1Z0luZm8pID8gdGhpcy5fZGVidWdJbmZvLmNvbXBvbmVudCA6IG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERlYnVnTm9kZS5wcm90b3R5cGUsIFwiY29udGV4dFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlzUHJlc2VudCh0aGlzLl9kZWJ1Z0luZm8pID8gdGhpcy5fZGVidWdJbmZvLmNvbnRleHQgOiBudWxsOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERlYnVnTm9kZS5wcm90b3R5cGUsIFwicmVmZXJlbmNlc1wiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMuX2RlYnVnSW5mbykgPyB0aGlzLl9kZWJ1Z0luZm8ucmVmZXJlbmNlcyA6IG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERlYnVnTm9kZS5wcm90b3R5cGUsIFwicHJvdmlkZXJUb2tlbnNcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLl9kZWJ1Z0luZm8pID8gdGhpcy5fZGVidWdJbmZvLnByb3ZpZGVyVG9rZW5zIDogbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVidWdOb2RlLnByb3RvdHlwZSwgXCJzb3VyY2VcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpc1ByZXNlbnQodGhpcy5fZGVidWdJbmZvKSA/IHRoaXMuX2RlYnVnSW5mby5zb3VyY2UgOiBudWxsOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIERlYnVnTm9kZTtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIEBleHBlcmltZW50YWwgQWxsIGRlYnVnZ2luZyBhcGlzIGFyZSBjdXJyZW50bHkgZXhwZXJpbWVudGFsLlxuICAgICAqL1xuICAgIHZhciBEZWJ1Z0VsZW1lbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMTIoRGVidWdFbGVtZW50LCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBEZWJ1Z0VsZW1lbnQobmF0aXZlTm9kZSwgcGFyZW50LCBfZGVidWdJbmZvKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBuYXRpdmVOb2RlLCBwYXJlbnQsIF9kZWJ1Z0luZm8pO1xuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0ge307XG4gICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NlcyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5zdHlsZXMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuY2hpbGROb2RlcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5uYXRpdmVFbGVtZW50ID0gbmF0aXZlTm9kZTtcbiAgICAgICAgfVxuICAgICAgICBEZWJ1Z0VsZW1lbnQucHJvdG90eXBlLmFkZENoaWxkID0gZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KGNoaWxkKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGROb2Rlcy5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICBjaGlsZC5wYXJlbnQgPSB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBEZWJ1Z0VsZW1lbnQucHJvdG90eXBlLnJlbW92ZUNoaWxkID0gZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRJbmRleCA9IHRoaXMuY2hpbGROb2Rlcy5pbmRleE9mKGNoaWxkKTtcbiAgICAgICAgICAgIGlmIChjaGlsZEluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGNoaWxkLnBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZE5vZGVzLnNwbGljZShjaGlsZEluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRGVidWdFbGVtZW50LnByb3RvdHlwZS5pbnNlcnRDaGlsZHJlbkFmdGVyID0gZnVuY3Rpb24gKGNoaWxkLCBuZXdDaGlsZHJlbikge1xuICAgICAgICAgICAgdmFyIHNpYmxpbmdJbmRleCA9IHRoaXMuY2hpbGROb2Rlcy5pbmRleE9mKGNoaWxkKTtcbiAgICAgICAgICAgIGlmIChzaWJsaW5nSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzQ2hpbGRyZW4gPSB0aGlzLmNoaWxkTm9kZXMuc2xpY2UoMCwgc2libGluZ0luZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgdmFyIG5leHRDaGlsZHJlbiA9IHRoaXMuY2hpbGROb2Rlcy5zbGljZShzaWJsaW5nSW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkTm9kZXMgPVxuICAgICAgICAgICAgICAgICAgICBMaXN0V3JhcHBlci5jb25jYXQoTGlzdFdyYXBwZXIuY29uY2F0KHByZXZpb3VzQ2hpbGRyZW4sIG5ld0NoaWxkcmVuKSwgbmV4dENoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdDaGlsZCA9IG5ld0NoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KG5ld0NoaWxkLnBhcmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkLnBhcmVudC5yZW1vdmVDaGlsZChuZXdDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbmV3Q2hpbGQucGFyZW50ID0gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIERlYnVnRWxlbWVudC5wcm90b3R5cGUucXVlcnkgPSBmdW5jdGlvbiAocHJlZGljYXRlKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHRoaXMucXVlcnlBbGwocHJlZGljYXRlKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzLmxlbmd0aCA+IDAgPyByZXN1bHRzWzBdIDogbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgRGVidWdFbGVtZW50LnByb3RvdHlwZS5xdWVyeUFsbCA9IGZ1bmN0aW9uIChwcmVkaWNhdGUpIHtcbiAgICAgICAgICAgIHZhciBtYXRjaGVzID0gW107XG4gICAgICAgICAgICBfcXVlcnlFbGVtZW50Q2hpbGRyZW4odGhpcywgcHJlZGljYXRlLCBtYXRjaGVzKTtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaGVzO1xuICAgICAgICB9O1xuICAgICAgICBEZWJ1Z0VsZW1lbnQucHJvdG90eXBlLnF1ZXJ5QWxsTm9kZXMgPSBmdW5jdGlvbiAocHJlZGljYXRlKSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IFtdO1xuICAgICAgICAgICAgX3F1ZXJ5Tm9kZUNoaWxkcmVuKHRoaXMsIHByZWRpY2F0ZSwgbWF0Y2hlcyk7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlcztcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERlYnVnRWxlbWVudC5wcm90b3R5cGUsIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBEZWJ1Z0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgRGVidWdFbGVtZW50LnByb3RvdHlwZS50cmlnZ2VyRXZlbnRIYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgZXZlbnRPYmopIHtcbiAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyLm5hbWUgPT0gZXZlbnROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmNhbGxiYWNrKGV2ZW50T2JqKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIERlYnVnRWxlbWVudDtcbiAgICB9KERlYnVnTm9kZSkpO1xuICAgIC8qKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc05hdGl2ZUVsZW1lbnRzKGRlYnVnRWxzKSB7XG4gICAgICAgIHJldHVybiBkZWJ1Z0Vscy5tYXAoZnVuY3Rpb24gKGVsKSB7IHJldHVybiBlbC5uYXRpdmVFbGVtZW50OyB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX3F1ZXJ5RWxlbWVudENoaWxkcmVuKGVsZW1lbnQsIHByZWRpY2F0ZSwgbWF0Y2hlcykge1xuICAgICAgICBlbGVtZW50LmNoaWxkTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBEZWJ1Z0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJlZGljYXRlKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZXMucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3F1ZXJ5RWxlbWVudENoaWxkcmVuKG5vZGUsIHByZWRpY2F0ZSwgbWF0Y2hlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfcXVlcnlOb2RlQ2hpbGRyZW4ocGFyZW50Tm9kZSwgcHJlZGljYXRlLCBtYXRjaGVzKSB7XG4gICAgICAgIGlmIChwYXJlbnROb2RlIGluc3RhbmNlb2YgRGVidWdFbGVtZW50KSB7XG4gICAgICAgICAgICBwYXJlbnROb2RlLmNoaWxkTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChwcmVkaWNhdGUobm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIERlYnVnRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBfcXVlcnlOb2RlQ2hpbGRyZW4obm9kZSwgcHJlZGljYXRlLCBtYXRjaGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBOZWVkIHRvIGtlZXAgdGhlIG5vZGVzIGluIGEgZ2xvYmFsIE1hcCBzbyB0aGF0IG11bHRpcGxlIGFuZ3VsYXIgYXBwcyBhcmUgc3VwcG9ydGVkLlxuICAgIHZhciBfbmF0aXZlTm9kZVRvRGVidWdOb2RlID0gbmV3IE1hcCgpO1xuICAgIC8qKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXREZWJ1Z05vZGUobmF0aXZlTm9kZSkge1xuICAgICAgICByZXR1cm4gX25hdGl2ZU5vZGVUb0RlYnVnTm9kZS5nZXQobmF0aXZlTm9kZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGluZGV4RGVidWdOb2RlKG5vZGUpIHtcbiAgICAgICAgX25hdGl2ZU5vZGVUb0RlYnVnTm9kZS5zZXQobm9kZS5uYXRpdmVOb2RlLCBub2RlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVtb3ZlRGVidWdOb2RlRnJvbUluZGV4KG5vZGUpIHtcbiAgICAgICAgX25hdGl2ZU5vZGVUb0RlYnVnTm9kZS5kZWxldGUobm9kZS5uYXRpdmVOb2RlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfcmVmbGVjdG9yKCkge1xuICAgICAgICByZXR1cm4gcmVmbGVjdG9yO1xuICAgIH1cbiAgICB2YXIgX0NPUkVfUExBVEZPUk1fUFJPVklERVJTID0gW1xuICAgICAgICBQbGF0Zm9ybVJlZl8sXG4gICAgICAgIHsgcHJvdmlkZTogUGxhdGZvcm1SZWYsIHVzZUV4aXN0aW5nOiBQbGF0Zm9ybVJlZl8gfSxcbiAgICAgICAgeyBwcm92aWRlOiBSZWZsZWN0b3IsIHVzZUZhY3Rvcnk6IF9yZWZsZWN0b3IsIGRlcHM6IFtdIH0sXG4gICAgICAgIHsgcHJvdmlkZTogUmVmbGVjdG9yUmVhZGVyLCB1c2VFeGlzdGluZzogUmVmbGVjdG9yIH0sXG4gICAgICAgIFRlc3RhYmlsaXR5UmVnaXN0cnksXG4gICAgICAgIENvbnNvbGUsXG4gICAgXTtcbiAgICAvKipcbiAgICAgKiBUaGlzIHBsYXRmb3JtIGhhcyB0byBiZSBpbmNsdWRlZCBpbiBhbnkgb3RoZXIgcGxhdGZvcm1cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgcGxhdGZvcm1Db3JlID0gY3JlYXRlUGxhdGZvcm1GYWN0b3J5KG51bGwsICdjb3JlJywgX0NPUkVfUExBVEZPUk1fUFJPVklERVJTKTtcblxuICAgIC8qKlxuICAgICAqIEBleHBlcmltZW50YWwgaTE4biBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cbiAgICAgKi9cbiAgICB2YXIgTE9DQUxFX0lEID0gbmV3IE9wYXF1ZVRva2VuKCdMb2NhbGVJZCcpO1xuICAgIC8qKlxuICAgICAqIEBleHBlcmltZW50YWwgaTE4biBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cbiAgICAgKi9cbiAgICB2YXIgVFJBTlNMQVRJT05TID0gbmV3IE9wYXF1ZVRva2VuKCdUcmFuc2xhdGlvbnMnKTtcbiAgICAvKipcbiAgICAgKiBAZXhwZXJpbWVudGFsIGkxOG4gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gICAgICovXG4gICAgdmFyIFRSQU5TTEFUSU9OU19GT1JNQVQgPSBuZXcgT3BhcXVlVG9rZW4oJ1RyYW5zbGF0aW9uc0Zvcm1hdCcpO1xuXG4gICAgZnVuY3Rpb24gX2l0ZXJhYmxlRGlmZmVyc0ZhY3RvcnkoKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0SXRlcmFibGVEaWZmZXJzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfa2V5VmFsdWVEaWZmZXJzRmFjdG9yeSgpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRLZXlWYWx1ZURpZmZlcnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbW9kdWxlIGluY2x1ZGVzIHRoZSBwcm92aWRlcnMgb2YgQGFuZ3VsYXIvY29yZSB0aGF0IGFyZSBuZWVkZWRcbiAgICAgKiB0byBib290c3RyYXAgY29tcG9uZW50cyB2aWEgYEFwcGxpY2F0aW9uUmVmYC5cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgQXBwbGljYXRpb25Nb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBBcHBsaWNhdGlvbk1vZHVsZSgpIHtcbiAgICAgICAgfVxuICAgICAgICBBcHBsaWNhdGlvbk1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBOZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFwcGxpY2F0aW9uUmVmXyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IEFwcGxpY2F0aW9uUmVmLCB1c2VFeGlzdGluZzogQXBwbGljYXRpb25SZWZfIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQXBwbGljYXRpb25Jbml0U3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIENvbXBpbGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFQUF9JRF9SQU5ET01fUFJPVklERVIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgVmlld1V0aWxzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogSXRlcmFibGVEaWZmZXJzLCB1c2VGYWN0b3J5OiBfaXRlcmFibGVEaWZmZXJzRmFjdG9yeSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogS2V5VmFsdWVEaWZmZXJzLCB1c2VGYWN0b3J5OiBfa2V5VmFsdWVEaWZmZXJzRmFjdG9yeSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogTE9DQUxFX0lELCB1c2VWYWx1ZTogJ2VuLVVTJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIEFwcGxpY2F0aW9uTW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gW107XG4gICAgICAgIHJldHVybiBBcHBsaWNhdGlvbk1vZHVsZTtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBGSUxMX1NUWUxFX0ZMQUcgPSAndHJ1ZSc7IC8vIFRPRE8gKG1hdHNrbyk6IGNoYW5nZSB0byBib29sZWFuXG4gICAgdmFyIEFOWV9TVEFURSA9ICcqJztcbiAgICB2YXIgREVGQVVMVF9TVEFURSA9ICcqJztcbiAgICB2YXIgRU1QVFlfU1RBVEUgPSAndm9pZCc7XG5cbiAgICB2YXIgQW5pbWF0aW9uR3JvdXBQbGF5ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBBbmltYXRpb25Hcm91cFBsYXllcihfcGxheWVycykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuX3BsYXllcnMgPSBfcGxheWVycztcbiAgICAgICAgICAgIHRoaXMuX29uRG9uZUZucyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fb25TdGFydEZucyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMucGFyZW50UGxheWVyID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgICAgICB2YXIgdG90YWwgPSB0aGlzLl9wbGF5ZXJzLmxlbmd0aDtcbiAgICAgICAgICAgIGlmICh0b3RhbCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgc2NoZWR1bGVNaWNyb1Rhc2soZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX29uRmluaXNoKCk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcGxheWVyLnBhcmVudFBsYXllciA9IF90aGlzO1xuICAgICAgICAgICAgICAgICAgICBwbGF5ZXIub25Eb25lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgrK2NvdW50ID49IHRvdGFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX29uRmluaXNoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIEFuaW1hdGlvbkdyb3VwUGxheWVyLnByb3RvdHlwZS5fb25GaW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2ZpbmlzaGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICghaXNQcmVzZW50KHRoaXMucGFyZW50UGxheWVyKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fb25Eb25lRm5zLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7IHJldHVybiBmbigpOyB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vbkRvbmVGbnMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgQW5pbWF0aW9uR3JvdXBQbGF5ZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX3BsYXllcnMuZm9yRWFjaChmdW5jdGlvbiAocGxheWVyKSB7IHJldHVybiBwbGF5ZXIuaW5pdCgpOyB9KTsgfTtcbiAgICAgICAgQW5pbWF0aW9uR3JvdXBQbGF5ZXIucHJvdG90eXBlLm9uU3RhcnQgPSBmdW5jdGlvbiAoZm4pIHsgdGhpcy5fb25TdGFydEZucy5wdXNoKGZuKTsgfTtcbiAgICAgICAgQW5pbWF0aW9uR3JvdXBQbGF5ZXIucHJvdG90eXBlLm9uRG9uZSA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLl9vbkRvbmVGbnMucHVzaChmbik7IH07XG4gICAgICAgIEFuaW1hdGlvbkdyb3VwUGxheWVyLnByb3RvdHlwZS5oYXNTdGFydGVkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc3RhcnRlZDsgfTtcbiAgICAgICAgQW5pbWF0aW9uR3JvdXBQbGF5ZXIucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIWlzUHJlc2VudCh0aGlzLnBhcmVudFBsYXllcikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5oYXNTdGFydGVkKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vblN0YXJ0Rm5zLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7IHJldHVybiBmbigpOyB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vblN0YXJ0Rm5zID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9wbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBsYXllcikgeyByZXR1cm4gcGxheWVyLnBsYXkoKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIEFuaW1hdGlvbkdyb3VwUGxheWVyLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fcGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHsgcmV0dXJuIHBsYXllci5wYXVzZSgpOyB9KTsgfTtcbiAgICAgICAgQW5pbWF0aW9uR3JvdXBQbGF5ZXIucHJvdG90eXBlLnJlc3RhcnQgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX3BsYXllcnMuZm9yRWFjaChmdW5jdGlvbiAocGxheWVyKSB7IHJldHVybiBwbGF5ZXIucmVzdGFydCgpOyB9KTsgfTtcbiAgICAgICAgQW5pbWF0aW9uR3JvdXBQbGF5ZXIucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX29uRmluaXNoKCk7XG4gICAgICAgICAgICB0aGlzLl9wbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBsYXllcikgeyByZXR1cm4gcGxheWVyLmZpbmlzaCgpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgQW5pbWF0aW9uR3JvdXBQbGF5ZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9vbkZpbmlzaCgpO1xuICAgICAgICAgICAgdGhpcy5fcGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHsgcmV0dXJuIHBsYXllci5kZXN0cm95KCk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICBBbmltYXRpb25Hcm91cFBsYXllci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX3BsYXllcnMuZm9yRWFjaChmdW5jdGlvbiAocGxheWVyKSB7IHJldHVybiBwbGF5ZXIucmVzZXQoKTsgfSk7IH07XG4gICAgICAgIEFuaW1hdGlvbkdyb3VwUGxheWVyLnByb3RvdHlwZS5zZXRQb3NpdGlvbiA9IGZ1bmN0aW9uIChwIC8qKiBUT0RPICM5MTAwICovKSB7XG4gICAgICAgICAgICB0aGlzLl9wbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBsYXllcikgeyBwbGF5ZXIuc2V0UG9zaXRpb24ocCk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICBBbmltYXRpb25Hcm91cFBsYXllci5wcm90b3R5cGUuZ2V0UG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbWluID0gMDtcbiAgICAgICAgICAgIHRoaXMuX3BsYXllcnMuZm9yRWFjaChmdW5jdGlvbiAocGxheWVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHAgPSBwbGF5ZXIuZ2V0UG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgICBtaW4gPSBNYXRoLm1pbihwLCBtaW4pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbWluO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gQW5pbWF0aW9uR3JvdXBQbGF5ZXI7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgQW5pbWF0aW9uS2V5ZnJhbWUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBBbmltYXRpb25LZXlmcmFtZShvZmZzZXQsIHN0eWxlcykge1xuICAgICAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICB0aGlzLnN0eWxlcyA9IHN0eWxlcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQW5pbWF0aW9uS2V5ZnJhbWU7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEBleHBlcmltZW50YWwgQW5pbWF0aW9uIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsLlxuICAgICAqL1xuICAgIHZhciBBbmltYXRpb25QbGF5ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBBbmltYXRpb25QbGF5ZXIoKSB7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFuaW1hdGlvblBsYXllci5wcm90b3R5cGUsIFwicGFyZW50UGxheWVyXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyB0aHJvdyBuZXcgRXJyb3IoJ05PVCBJTVBMRU1FTlRFRDogQmFzZSBDbGFzcycpOyB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAocGxheWVyKSB7IHRocm93IG5ldyBFcnJvcignTk9UIElNUExFTUVOVEVEOiBCYXNlIENsYXNzJyk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gQW5pbWF0aW9uUGxheWVyO1xuICAgIH0oKSk7XG4gICAgdmFyIE5vT3BBbmltYXRpb25QbGF5ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBOb09wQW5pbWF0aW9uUGxheWVyKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuX29uRG9uZUZucyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fb25TdGFydEZucyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnRQbGF5ZXIgPSBudWxsO1xuICAgICAgICAgICAgc2NoZWR1bGVNaWNyb1Rhc2soZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX29uRmluaXNoKCk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgTm9PcEFuaW1hdGlvblBsYXllci5wcm90b3R5cGUuX29uRmluaXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fb25Eb25lRm5zLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7IHJldHVybiBmbigpOyB9KTtcbiAgICAgICAgICAgIHRoaXMuX29uRG9uZUZucyA9IFtdO1xuICAgICAgICB9O1xuICAgICAgICBOb09wQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5vblN0YXJ0ID0gZnVuY3Rpb24gKGZuKSB7IHRoaXMuX29uU3RhcnRGbnMucHVzaChmbik7IH07XG4gICAgICAgIE5vT3BBbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLm9uRG9uZSA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLl9vbkRvbmVGbnMucHVzaChmbik7IH07XG4gICAgICAgIE5vT3BBbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLmhhc1N0YXJ0ZWQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zdGFydGVkOyB9O1xuICAgICAgICBOb09wQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICBOb09wQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmhhc1N0YXJ0ZWQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX29uU3RhcnRGbnMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuKCk7IH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX29uU3RhcnRGbnMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICBOb09wQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgTm9PcEFuaW1hdGlvblBsYXllci5wcm90b3R5cGUucmVzdGFydCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgTm9PcEFuaW1hdGlvblBsYXllci5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9vbkZpbmlzaCgpOyB9O1xuICAgICAgICBOb09wQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICBOb09wQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgTm9PcEFuaW1hdGlvblBsYXllci5wcm90b3R5cGUuc2V0UG9zaXRpb24gPSBmdW5jdGlvbiAocCAvKiogVE9ETyAjOTEwMCAqLykgeyB9O1xuICAgICAgICBOb09wQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5nZXRQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDA7IH07XG4gICAgICAgIHJldHVybiBOb09wQW5pbWF0aW9uUGxheWVyO1xuICAgIH0oKSk7XG5cbiAgICB2YXIgQW5pbWF0aW9uU2VxdWVuY2VQbGF5ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBBbmltYXRpb25TZXF1ZW5jZVBsYXllcihfcGxheWVycykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuX3BsYXllcnMgPSBfcGxheWVycztcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRJbmRleCA9IDA7XG4gICAgICAgICAgICB0aGlzLl9vbkRvbmVGbnMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX29uU3RhcnRGbnMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2ZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnBhcmVudFBsYXllciA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9wbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBsYXllcikgeyBwbGF5ZXIucGFyZW50UGxheWVyID0gX3RoaXM7IH0pO1xuICAgICAgICAgICAgdGhpcy5fb25OZXh0KGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBBbmltYXRpb25TZXF1ZW5jZVBsYXllci5wcm90b3R5cGUuX29uTmV4dCA9IGZ1bmN0aW9uIChzdGFydCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGlmICh0aGlzLl9maW5pc2hlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAodGhpcy5fcGxheWVycy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZVBsYXllciA9IG5ldyBOb09wQW5pbWF0aW9uUGxheWVyKCk7XG4gICAgICAgICAgICAgICAgc2NoZWR1bGVNaWNyb1Rhc2soZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX29uRmluaXNoKCk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fY3VycmVudEluZGV4ID49IHRoaXMuX3BsYXllcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZlUGxheWVyID0gbmV3IE5vT3BBbmltYXRpb25QbGF5ZXIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vbkZpbmlzaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHBsYXllciA9IHRoaXMuX3BsYXllcnNbdGhpcy5fY3VycmVudEluZGV4KytdO1xuICAgICAgICAgICAgICAgIHBsYXllci5vbkRvbmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX29uTmV4dCh0cnVlKTsgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZlUGxheWVyID0gcGxheWVyO1xuICAgICAgICAgICAgICAgIGlmIChzdGFydCkge1xuICAgICAgICAgICAgICAgICAgICBwbGF5ZXIucGxheSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgQW5pbWF0aW9uU2VxdWVuY2VQbGF5ZXIucHJvdG90eXBlLl9vbkZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fZmluaXNoZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9maW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1ByZXNlbnQodGhpcy5wYXJlbnRQbGF5ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9vbkRvbmVGbnMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuKCk7IH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX29uRG9uZUZucyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBBbmltYXRpb25TZXF1ZW5jZVBsYXllci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fcGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHsgcmV0dXJuIHBsYXllci5pbml0KCk7IH0pOyB9O1xuICAgICAgICBBbmltYXRpb25TZXF1ZW5jZVBsYXllci5wcm90b3R5cGUub25TdGFydCA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLl9vblN0YXJ0Rm5zLnB1c2goZm4pOyB9O1xuICAgICAgICBBbmltYXRpb25TZXF1ZW5jZVBsYXllci5wcm90b3R5cGUub25Eb25lID0gZnVuY3Rpb24gKGZuKSB7IHRoaXMuX29uRG9uZUZucy5wdXNoKGZuKTsgfTtcbiAgICAgICAgQW5pbWF0aW9uU2VxdWVuY2VQbGF5ZXIucHJvdG90eXBlLmhhc1N0YXJ0ZWQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zdGFydGVkOyB9O1xuICAgICAgICBBbmltYXRpb25TZXF1ZW5jZVBsYXllci5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghaXNQcmVzZW50KHRoaXMucGFyZW50UGxheWVyKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLmhhc1N0YXJ0ZWQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX29uU3RhcnRGbnMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuKCk7IH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX29uU3RhcnRGbnMgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2FjdGl2ZVBsYXllci5wbGF5KCk7XG4gICAgICAgIH07XG4gICAgICAgIEFuaW1hdGlvblNlcXVlbmNlUGxheWVyLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fYWN0aXZlUGxheWVyLnBhdXNlKCk7IH07XG4gICAgICAgIEFuaW1hdGlvblNlcXVlbmNlUGxheWVyLnByb3RvdHlwZS5yZXN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BsYXllcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wbGF5ZXJzWzBdLnJlc3RhcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgQW5pbWF0aW9uU2VxdWVuY2VQbGF5ZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9wbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBsYXllcikgeyByZXR1cm4gcGxheWVyLnJlc2V0KCk7IH0pOyB9O1xuICAgICAgICBBbmltYXRpb25TZXF1ZW5jZVBsYXllci5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fb25GaW5pc2goKTtcbiAgICAgICAgICAgIHRoaXMuX3BsYXllcnMuZm9yRWFjaChmdW5jdGlvbiAocGxheWVyKSB7IHJldHVybiBwbGF5ZXIuZmluaXNoKCk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICBBbmltYXRpb25TZXF1ZW5jZVBsYXllci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX29uRmluaXNoKCk7XG4gICAgICAgICAgICB0aGlzLl9wbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBsYXllcikgeyByZXR1cm4gcGxheWVyLmRlc3Ryb3koKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIEFuaW1hdGlvblNlcXVlbmNlUGxheWVyLnByb3RvdHlwZS5zZXRQb3NpdGlvbiA9IGZ1bmN0aW9uIChwIC8qKiBUT0RPICM5MTAwICovKSB7IHRoaXMuX3BsYXllcnNbMF0uc2V0UG9zaXRpb24ocCk7IH07XG4gICAgICAgIEFuaW1hdGlvblNlcXVlbmNlUGxheWVyLnByb3RvdHlwZS5nZXRQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3BsYXllcnNbMF0uZ2V0UG9zaXRpb24oKTsgfTtcbiAgICAgICAgcmV0dXJuIEFuaW1hdGlvblNlcXVlbmNlUGxheWVyO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQxMyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBleHBlcmltZW50YWwgQW5pbWF0aW9uIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsLlxuICAgICAqL1xuICAgIHZhciBBVVRPX1NUWUxFID0gJyonO1xuICAgIC8qKlxuICAgICAqIE1ldGFkYXRhIHJlcHJlc2VudGluZyB0aGUgZW50cnkgb2YgYW5pbWF0aW9ucy5cbiAgICAgKiBJbnN0YW5jZXMgb2YgdGhpcyBjbGFzcyBhcmUgcHJvdmlkZWQgdmlhIHRoZSBhbmltYXRpb24gRFNMIHdoZW4gdGhlIHtAbGluayB0cmlnZ2VyIHRyaWdnZXJcbiAgICAgKiBhbmltYXRpb24gZnVuY3Rpb259IGlzIGNhbGxlZC5cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWwgQW5pbWF0aW9uIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsLlxuICAgICAqL1xuICAgIHZhciBBbmltYXRpb25FbnRyeU1ldGFkYXRhID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQW5pbWF0aW9uRW50cnlNZXRhZGF0YShuYW1lLCBkZWZpbml0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICAgIHRoaXMuZGVmaW5pdGlvbnMgPSBkZWZpbml0aW9ucztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQW5pbWF0aW9uRW50cnlNZXRhZGF0YTtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIEBleHBlcmltZW50YWwgQW5pbWF0aW9uIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsLlxuICAgICAqL1xuICAgIHZhciBBbmltYXRpb25TdGF0ZU1ldGFkYXRhID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQW5pbWF0aW9uU3RhdGVNZXRhZGF0YSgpIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQW5pbWF0aW9uU3RhdGVNZXRhZGF0YTtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIE1ldGFkYXRhIHJlcHJlc2VudGluZyB0aGUgZW50cnkgb2YgYW5pbWF0aW9ucy5cbiAgICAgKiBJbnN0YW5jZXMgb2YgdGhpcyBjbGFzcyBhcmUgcHJvdmlkZWQgdmlhIHRoZSBhbmltYXRpb24gRFNMIHdoZW4gdGhlIHtAbGluayBzdGF0ZSBzdGF0ZSBhbmltYXRpb25cbiAgICAgKiBmdW5jdGlvbn0gaXMgY2FsbGVkLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gICAgICovXG4gICAgdmFyIEFuaW1hdGlvblN0YXRlRGVjbGFyYXRpb25NZXRhZGF0YSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQxMyhBbmltYXRpb25TdGF0ZURlY2xhcmF0aW9uTWV0YWRhdGEsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvblN0YXRlRGVjbGFyYXRpb25NZXRhZGF0YShzdGF0ZU5hbWVFeHByLCBzdHlsZXMpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZU5hbWVFeHByID0gc3RhdGVOYW1lRXhwcjtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVzID0gc3R5bGVzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBbmltYXRpb25TdGF0ZURlY2xhcmF0aW9uTWV0YWRhdGE7XG4gICAgfShBbmltYXRpb25TdGF0ZU1ldGFkYXRhKSk7XG4gICAgLyoqXG4gICAgICogTWV0YWRhdGEgcmVwcmVzZW50aW5nIHRoZSBlbnRyeSBvZiBhbmltYXRpb25zLlxuICAgICAqIEluc3RhbmNlcyBvZiB0aGlzIGNsYXNzIGFyZSBwcm92aWRlZCB2aWEgdGhlIGFuaW1hdGlvbiBEU0wgd2hlbiB0aGVcbiAgICAgKiB7QGxpbmsgdHJhbnNpdGlvbiB0cmFuc2l0aW9uIGFuaW1hdGlvbiBmdW5jdGlvbn0gaXMgY2FsbGVkLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gICAgICovXG4gICAgdmFyIEFuaW1hdGlvblN0YXRlVHJhbnNpdGlvbk1ldGFkYXRhID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDEzKEFuaW1hdGlvblN0YXRlVHJhbnNpdGlvbk1ldGFkYXRhLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBBbmltYXRpb25TdGF0ZVRyYW5zaXRpb25NZXRhZGF0YShzdGF0ZUNoYW5nZUV4cHIsIHN0ZXBzKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVDaGFuZ2VFeHByID0gc3RhdGVDaGFuZ2VFeHByO1xuICAgICAgICAgICAgdGhpcy5zdGVwcyA9IHN0ZXBzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBbmltYXRpb25TdGF0ZVRyYW5zaXRpb25NZXRhZGF0YTtcbiAgICB9KEFuaW1hdGlvblN0YXRlTWV0YWRhdGEpKTtcbiAgICAvKipcbiAgICAgKiBAZXhwZXJpbWVudGFsIEFuaW1hdGlvbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cbiAgICAgKi9cbiAgICB2YXIgQW5pbWF0aW9uTWV0YWRhdGEgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBBbmltYXRpb25NZXRhZGF0YSgpIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQW5pbWF0aW9uTWV0YWRhdGE7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBNZXRhZGF0YSByZXByZXNlbnRpbmcgdGhlIGVudHJ5IG9mIGFuaW1hdGlvbnMuXG4gICAgICogSW5zdGFuY2VzIG9mIHRoaXMgY2xhc3MgYXJlIHByb3ZpZGVkIHZpYSB0aGUgYW5pbWF0aW9uIERTTCB3aGVuIHRoZSB7QGxpbmsga2V5ZnJhbWVzIGtleWZyYW1lc1xuICAgICAqIGFuaW1hdGlvbiBmdW5jdGlvbn0gaXMgY2FsbGVkLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gICAgICovXG4gICAgdmFyIEFuaW1hdGlvbktleWZyYW1lc1NlcXVlbmNlTWV0YWRhdGEgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMTMoQW5pbWF0aW9uS2V5ZnJhbWVzU2VxdWVuY2VNZXRhZGF0YSwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gQW5pbWF0aW9uS2V5ZnJhbWVzU2VxdWVuY2VNZXRhZGF0YShzdGVwcykge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLnN0ZXBzID0gc3RlcHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFuaW1hdGlvbktleWZyYW1lc1NlcXVlbmNlTWV0YWRhdGE7XG4gICAgfShBbmltYXRpb25NZXRhZGF0YSkpO1xuICAgIC8qKlxuICAgICAqIE1ldGFkYXRhIHJlcHJlc2VudGluZyB0aGUgZW50cnkgb2YgYW5pbWF0aW9ucy5cbiAgICAgKiBJbnN0YW5jZXMgb2YgdGhpcyBjbGFzcyBhcmUgcHJvdmlkZWQgdmlhIHRoZSBhbmltYXRpb24gRFNMIHdoZW4gdGhlIHtAbGluayBzdHlsZSBzdHlsZSBhbmltYXRpb25cbiAgICAgKiBmdW5jdGlvbn0gaXMgY2FsbGVkLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gICAgICovXG4gICAgdmFyIEFuaW1hdGlvblN0eWxlTWV0YWRhdGEgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMTMoQW5pbWF0aW9uU3R5bGVNZXRhZGF0YSwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gQW5pbWF0aW9uU3R5bGVNZXRhZGF0YShzdHlsZXMsIG9mZnNldCkge1xuICAgICAgICAgICAgaWYgKG9mZnNldCA9PT0gdm9pZCAwKSB7IG9mZnNldCA9IG51bGw7IH1cbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5zdHlsZXMgPSBzdHlsZXM7XG4gICAgICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQW5pbWF0aW9uU3R5bGVNZXRhZGF0YTtcbiAgICB9KEFuaW1hdGlvbk1ldGFkYXRhKSk7XG4gICAgLyoqXG4gICAgICogTWV0YWRhdGEgcmVwcmVzZW50aW5nIHRoZSBlbnRyeSBvZiBhbmltYXRpb25zLlxuICAgICAqIEluc3RhbmNlcyBvZiB0aGlzIGNsYXNzIGFyZSBwcm92aWRlZCB2aWEgdGhlIGFuaW1hdGlvbiBEU0wgd2hlbiB0aGUge0BsaW5rIGFuaW1hdGUgYW5pbWF0ZVxuICAgICAqIGFuaW1hdGlvbiBmdW5jdGlvbn0gaXMgY2FsbGVkLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gICAgICovXG4gICAgdmFyIEFuaW1hdGlvbkFuaW1hdGVNZXRhZGF0YSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQxMyhBbmltYXRpb25BbmltYXRlTWV0YWRhdGEsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvbkFuaW1hdGVNZXRhZGF0YSh0aW1pbmdzLCBzdHlsZXMpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy50aW1pbmdzID0gdGltaW5ncztcbiAgICAgICAgICAgIHRoaXMuc3R5bGVzID0gc3R5bGVzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBbmltYXRpb25BbmltYXRlTWV0YWRhdGE7XG4gICAgfShBbmltYXRpb25NZXRhZGF0YSkpO1xuICAgIC8qKlxuICAgICAqIEBleHBlcmltZW50YWwgQW5pbWF0aW9uIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsLlxuICAgICAqL1xuICAgIHZhciBBbmltYXRpb25XaXRoU3RlcHNNZXRhZGF0YSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQxMyhBbmltYXRpb25XaXRoU3RlcHNNZXRhZGF0YSwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gQW5pbWF0aW9uV2l0aFN0ZXBzTWV0YWRhdGEoKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQW5pbWF0aW9uV2l0aFN0ZXBzTWV0YWRhdGEucHJvdG90eXBlLCBcInN0ZXBzXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyB0aHJvdyBuZXcgRXJyb3IoJ05PVCBJTVBMRU1FTlRFRDogQmFzZSBDbGFzcycpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIEFuaW1hdGlvbldpdGhTdGVwc01ldGFkYXRhO1xuICAgIH0oQW5pbWF0aW9uTWV0YWRhdGEpKTtcbiAgICAvKipcbiAgICAgKiBNZXRhZGF0YSByZXByZXNlbnRpbmcgdGhlIGVudHJ5IG9mIGFuaW1hdGlvbnMuXG4gICAgICogSW5zdGFuY2VzIG9mIHRoaXMgY2xhc3MgYXJlIHByb3ZpZGVkIHZpYSB0aGUgYW5pbWF0aW9uIERTTCB3aGVuIHRoZSB7QGxpbmsgc2VxdWVuY2Ugc2VxdWVuY2VcbiAgICAgKiBhbmltYXRpb24gZnVuY3Rpb259IGlzIGNhbGxlZC5cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWwgQW5pbWF0aW9uIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsLlxuICAgICAqL1xuICAgIHZhciBBbmltYXRpb25TZXF1ZW5jZU1ldGFkYXRhID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDEzKEFuaW1hdGlvblNlcXVlbmNlTWV0YWRhdGEsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvblNlcXVlbmNlTWV0YWRhdGEoX3N0ZXBzKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX3N0ZXBzID0gX3N0ZXBzO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBbmltYXRpb25TZXF1ZW5jZU1ldGFkYXRhLnByb3RvdHlwZSwgXCJzdGVwc1wiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3N0ZXBzOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIEFuaW1hdGlvblNlcXVlbmNlTWV0YWRhdGE7XG4gICAgfShBbmltYXRpb25XaXRoU3RlcHNNZXRhZGF0YSkpO1xuICAgIC8qKlxuICAgICAqIE1ldGFkYXRhIHJlcHJlc2VudGluZyB0aGUgZW50cnkgb2YgYW5pbWF0aW9ucy5cbiAgICAgKiBJbnN0YW5jZXMgb2YgdGhpcyBjbGFzcyBhcmUgcHJvdmlkZWQgdmlhIHRoZSBhbmltYXRpb24gRFNMIHdoZW4gdGhlIHtAbGluayBncm91cCBncm91cCBhbmltYXRpb25cbiAgICAgKiBmdW5jdGlvbn0gaXMgY2FsbGVkLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gICAgICovXG4gICAgdmFyIEFuaW1hdGlvbkdyb3VwTWV0YWRhdGEgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMTMoQW5pbWF0aW9uR3JvdXBNZXRhZGF0YSwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gQW5pbWF0aW9uR3JvdXBNZXRhZGF0YShfc3RlcHMpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fc3RlcHMgPSBfc3RlcHM7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFuaW1hdGlvbkdyb3VwTWV0YWRhdGEucHJvdG90eXBlLCBcInN0ZXBzXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc3RlcHM7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gQW5pbWF0aW9uR3JvdXBNZXRhZGF0YTtcbiAgICB9KEFuaW1hdGlvbldpdGhTdGVwc01ldGFkYXRhKSk7XG4gICAgLyoqXG4gICAgICogYGFuaW1hdGVgIGlzIGFuIGFuaW1hdGlvbi1zcGVjaWZpYyBmdW5jdGlvbiB0aGF0IGlzIGRlc2lnbmVkIHRvIGJlIHVzZWQgaW5zaWRlIG9mIEFuZ3VsYXIyJ3NcbiAgICAgKiBhbmltYXRpb25cbiAgICAgKiBEU0wgbGFuZ3VhZ2UuIElmIHRoaXMgaW5mb3JtYXRpb24gaXMgbmV3LCBwbGVhc2UgbmF2aWdhdGUgdG8gdGhlXG4gICAgICoge0BsaW5rIENvbXBvbmVudCNhbmltYXRpb25zLWFuY2hvciBjb21wb25lbnQgYW5pbWF0aW9ucyBtZXRhZGF0YVxuICAgICAqIHBhZ2V9IHRvIGdhaW4gYSBiZXR0ZXIgdW5kZXJzdGFuZGluZyBvZiBob3cgYW5pbWF0aW9ucyBpbiBBbmd1bGFyMiBhcmUgdXNlZC5cbiAgICAgKlxuICAgICAqIGBhbmltYXRlYCBzcGVjaWZpZXMgYW4gYW5pbWF0aW9uIHN0ZXAgdGhhdCB3aWxsIGFwcGx5IHRoZSBwcm92aWRlZCBgc3R5bGVzYCBkYXRhIGZvciBhIGdpdmVuXG4gICAgICogYW1vdW50IG9mXG4gICAgICogdGltZSBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgYHRpbWluZ2AgZXhwcmVzc2lvbiB2YWx1ZS4gQ2FsbHMgdG8gYGFuaW1hdGVgIGFyZSBleHBlY3RlZCB0byBiZVxuICAgICAqIHVzZWQgd2l0aGluIHtAbGluayBzZXF1ZW5jZSBhbiBhbmltYXRpb24gc2VxdWVuY2V9LCB7QGxpbmsgZ3JvdXAgZ3JvdXB9LCBvciB7QGxpbmsgdHJhbnNpdGlvblxuICAgICAqIHRyYW5zaXRpb259LlxuICAgICAqXG4gICAgICogIyMjIFVzYWdlXG4gICAgICpcbiAgICAgKiBUaGUgYGFuaW1hdGVgIGZ1bmN0aW9uIGFjY2VwdHMgdHdvIGlucHV0IHBhcmFtZXRlcnM6IGB0aW1pbmdgIGFuZCBgc3R5bGVzYDpcbiAgICAgKlxuICAgICAqIC0gYHRpbWluZ2AgaXMgYSBzdHJpbmcgYmFzZWQgdmFsdWUgdGhhdCBjYW4gYmUgYSBjb21iaW5hdGlvbiBvZiBhIGR1cmF0aW9uIHdpdGggb3B0aW9uYWxcbiAgICAgKiBkZWxheSBhbmQgZWFzaW5nIHZhbHVlcy4gVGhlIGZvcm1hdCBmb3IgdGhlIGV4cHJlc3Npb24gYnJlYWtzIGRvd24gdG8gYGR1cmF0aW9uIGRlbGF5IGVhc2luZ2BcbiAgICAgKiAodGhlcmVmb3JlIGEgdmFsdWUgc3VjaCBhcyBgMXMgMTAwbXMgZWFzZS1vdXRgIHdpbGwgYmUgcGFyc2UgaXRzZWxmIGludG8gYGR1cmF0aW9uPTEwMDAsXG4gICAgICogZGVsYXk9MTAwLCBlYXNpbmc9ZWFzZS1vdXRgLlxuICAgICAqIElmIGEgbnVtZXJpYyB2YWx1ZSBpcyBwcm92aWRlZCB0aGVuIHRoYXQgd2lsbCBiZSB1c2VkIGFzIHRoZSBgZHVyYXRpb25gIHZhbHVlIGluIG1pbGxpc2Vjb25kXG4gICAgICogZm9ybS5cbiAgICAgKiAtIGBzdHlsZXNgIGlzIHRoZSBzdHlsZSBpbnB1dCBkYXRhIHdoaWNoIGNhbiBlaXRoZXIgYmUgYSBjYWxsIHRvIHtAbGluayBzdHlsZSBzdHlsZX0gb3Ige0BsaW5rXG4gICAgICoga2V5ZnJhbWVzIGtleWZyYW1lc30uXG4gICAgICogSWYgbGVmdCBlbXB0eSB0aGVuIHRoZSBzdHlsZXMgZnJvbSB0aGUgZGVzdGluYXRpb24gc3RhdGUgd2lsbCBiZSBjb2xsZWN0ZWQgYW5kIHVzZWQgKHRoaXMgaXNcbiAgICAgKiB1c2VmdWwgd2hlblxuICAgICAqIGRlc2NyaWJpbmcgYW4gYW5pbWF0aW9uIHN0ZXAgdGhhdCB3aWxsIGNvbXBsZXRlIGFuIGFuaW1hdGlvbiBieSB7QGxpbmtcbiAgICAgKiB0cmFuc2l0aW9uI3RoZS1maW5hbC1hbmltYXRlLWNhbGwgYW5pbWF0aW5nIHRvIHRoZSBmaW5hbCBzdGF0ZX0pLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIC8vIHZhcmlvdXMgZnVuY3Rpb25zIGZvciBzcGVjaWZ5aW5nIHRpbWluZyBkYXRhXG4gICAgICogYW5pbWF0ZSg1MDAsIHN0eWxlKC4uLikpXG4gICAgICogYW5pbWF0ZShcIjFzXCIsIHN0eWxlKC4uLikpXG4gICAgICogYW5pbWF0ZShcIjEwMG1zIDAuNXNcIiwgc3R5bGUoLi4uKSlcbiAgICAgKiBhbmltYXRlKFwiNXMgZWFzZVwiLCBzdHlsZSguLi4pKVxuICAgICAqIGFuaW1hdGUoXCI1cyAxMG1zIGN1YmljLWJlemllciguMTcsLjY3LC44OCwuMSlcIiwgc3R5bGUoLi4uKSlcbiAgICAgKlxuICAgICAqIC8vIGVpdGhlciBzdHlsZSgpIG9mIGtleWZyYW1lcygpIGNhbiBiZSB1c2VkXG4gICAgICogYW5pbWF0ZSg1MDAsIHN0eWxlKHsgYmFja2dyb3VuZDogXCJyZWRcIiB9KSlcbiAgICAgKiBhbmltYXRlKDUwMCwga2V5ZnJhbWVzKFtcbiAgICAgKiAgIHN0eWxlKHsgYmFja2dyb3VuZDogXCJibHVlXCIgfSkpLFxuICAgICAqICAgc3R5bGUoeyBiYWNrZ3JvdW5kOiBcInJlZFwiIH0pKVxuICAgICAqIF0pXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvS2V6OFhHV0J4V3VlN3FQN25OdkY/cD1wcmV2aWV3KSlcbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBjb3JlL2FuaW1hdGlvbi90cy9kc2wvYW5pbWF0aW9uX2V4YW1wbGUudHMgcmVnaW9uPSdDb21wb25lbnQnfVxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYW5pbWF0ZSh0aW1pbmcsIHN0eWxlcykge1xuICAgICAgICBpZiAoc3R5bGVzID09PSB2b2lkIDApIHsgc3R5bGVzID0gbnVsbDsgfVxuICAgICAgICB2YXIgc3R5bGVzRW50cnkgPSBzdHlsZXM7XG4gICAgICAgIGlmICghaXNQcmVzZW50KHN0eWxlc0VudHJ5KSkge1xuICAgICAgICAgICAgdmFyIEVNUFRZX1NUWUxFID0ge307XG4gICAgICAgICAgICBzdHlsZXNFbnRyeSA9IG5ldyBBbmltYXRpb25TdHlsZU1ldGFkYXRhKFtFTVBUWV9TVFlMRV0sIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQW5pbWF0aW9uQW5pbWF0ZU1ldGFkYXRhKHRpbWluZywgc3R5bGVzRW50cnkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ3JvdXBgIGlzIGFuIGFuaW1hdGlvbi1zcGVjaWZpYyBmdW5jdGlvbiB0aGF0IGlzIGRlc2lnbmVkIHRvIGJlIHVzZWQgaW5zaWRlIG9mIEFuZ3VsYXIyJ3NcbiAgICAgKiBhbmltYXRpb25cbiAgICAgKiBEU0wgbGFuZ3VhZ2UuIElmIHRoaXMgaW5mb3JtYXRpb24gaXMgbmV3LCBwbGVhc2UgbmF2aWdhdGUgdG8gdGhlXG4gICAgICoge0BsaW5rIENvbXBvbmVudCNhbmltYXRpb25zLWFuY2hvciBjb21wb25lbnQgYW5pbWF0aW9ucyBtZXRhZGF0YVxuICAgICAqIHBhZ2V9IHRvIGdhaW4gYSBiZXR0ZXIgdW5kZXJzdGFuZGluZyBvZiBob3cgYW5pbWF0aW9ucyBpbiBBbmd1bGFyMiBhcmUgdXNlZC5cbiAgICAgKlxuICAgICAqIGBncm91cGAgc3BlY2lmaWVzIGEgbGlzdCBvZiBhbmltYXRpb24gc3RlcHMgdGhhdCBhcmUgYWxsIHJ1biBpbiBwYXJhbGxlbC4gR3JvdXBlZCBhbmltYXRpb25zXG4gICAgICogYXJlIHVzZWZ1bCB3aGVuIGEgc2VyaWVzIG9mIHN0eWxlcyBtdXN0IGJlIGFuaW1hdGVkL2Nsb3NlZCBvZmZcbiAgICAgKiBhdCBkaWZmZXJlbnQgc3RhdHJ0aW5nL2VuZGluZyB0aW1lcy5cbiAgICAgKlxuICAgICAqIFRoZSBgZ3JvdXBgIGZ1bmN0aW9uIGNhbiBlaXRoZXIgYmUgdXNlZCB3aXRoaW4gYSB7QGxpbmsgc2VxdWVuY2Ugc2VxdWVuY2V9IG9yIGEge0BsaW5rIHRyYW5zaXRpb25cbiAgICAgKiB0cmFuc2l0aW9ufVxuICAgICAqIGFuZCBpdCB3aWxsIG9ubHkgY29udGludWUgdG8gdGhlIG5leHQgaW5zdHJ1Y3Rpb24gb25jZSBhbGwgb2YgdGhlIGlubmVyIGFuaW1hdGlvbiBzdGVwc1xuICAgICAqIGhhdmUgY29tcGxldGVkLlxuICAgICAqXG4gICAgICogIyMjIFVzYWdlXG4gICAgICpcbiAgICAgKiBUaGUgYHN0ZXBzYCBkYXRhIHRoYXQgaXMgcGFzc2VkIGludG8gdGhlIGBncm91cGAgYW5pbWF0aW9uIGZ1bmN0aW9uIGNhbiBlaXRoZXIgY29uc2lzdFxuICAgICAqIG9mIHtAbGluayBzdHlsZSBzdHlsZX0gb3Ige0BsaW5rIGFuaW1hdGUgYW5pbWF0ZX0gZnVuY3Rpb24gY2FsbHMuIEVhY2ggY2FsbCB0byBgc3R5bGUoKWAgb3JcbiAgICAgKiBgYW5pbWF0ZSgpYFxuICAgICAqIHdpdGhpbiBhIGdyb3VwIHdpbGwgYmUgZXhlY3V0ZWQgaW5zdGFudGx5ICh1c2Uge0BsaW5rIGtleWZyYW1lcyBrZXlmcmFtZXN9IG9yIGFcbiAgICAgKiB7QGxpbmsgYW5pbWF0ZSN1c2FnZSBhbmltYXRlKCkgd2l0aCBhIGRlbGF5IHZhbHVlfSB0byBvZmZzZXQgc3R5bGVzIHRvIGJlIGFwcGxpZWQgYXQgYSBsYXRlclxuICAgICAqIHRpbWUpLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGdyb3VwKFtcbiAgICAgKiAgIGFuaW1hdGUoXCIxc1wiLCB7IGJhY2tncm91bmQ6IFwiYmxhY2tcIiB9KSlcbiAgICAgKiAgIGFuaW1hdGUoXCIyc1wiLCB7IGNvbG9yOiBcIndoaXRlXCIgfSkpXG4gICAgICogXSlcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9LZXo4WEdXQnhXdWU3cVA3bk52Rj9wPXByZXZpZXcpKVxuICAgICAqXG4gICAgICoge0BleGFtcGxlIGNvcmUvYW5pbWF0aW9uL3RzL2RzbC9hbmltYXRpb25fZXhhbXBsZS50cyByZWdpb249J0NvbXBvbmVudCd9XG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsIEFuaW1hdGlvbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBncm91cChzdGVwcykge1xuICAgICAgICByZXR1cm4gbmV3IEFuaW1hdGlvbkdyb3VwTWV0YWRhdGEoc3RlcHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgc2VxdWVuY2VgIGlzIGFuIGFuaW1hdGlvbi1zcGVjaWZpYyBmdW5jdGlvbiB0aGF0IGlzIGRlc2lnbmVkIHRvIGJlIHVzZWQgaW5zaWRlIG9mIEFuZ3VsYXIyJ3NcbiAgICAgKiBhbmltYXRpb25cbiAgICAgKiBEU0wgbGFuZ3VhZ2UuIElmIHRoaXMgaW5mb3JtYXRpb24gaXMgbmV3LCBwbGVhc2UgbmF2aWdhdGUgdG8gdGhlXG4gICAgICoge0BsaW5rIENvbXBvbmVudCNhbmltYXRpb25zLWFuY2hvciBjb21wb25lbnQgYW5pbWF0aW9ucyBtZXRhZGF0YVxuICAgICAqIHBhZ2V9IHRvIGdhaW4gYSBiZXR0ZXIgdW5kZXJzdGFuZGluZyBvZiBob3cgYW5pbWF0aW9ucyBpbiBBbmd1bGFyMiBhcmUgdXNlZC5cbiAgICAgKlxuICAgICAqIGBzZXF1ZW5jZWAgU3BlY2lmaWVzIGEgbGlzdCBvZiBhbmltYXRpb24gc3RlcHMgdGhhdCBhcmUgcnVuIG9uZSBieSBvbmUuIChgc2VxdWVuY2VgIGlzIHVzZWRcbiAgICAgKiBieSBkZWZhdWx0IHdoZW4gYW4gYXJyYXkgaXMgcGFzc2VkIGFzIGFuaW1hdGlvbiBkYXRhIGludG8ge0BsaW5rIHRyYW5zaXRpb24gdHJhbnNpdGlvbn0uKVxuICAgICAqXG4gICAgICogVGhlIGBzZXF1ZW5jZWAgZnVuY3Rpb24gY2FuIGVpdGhlciBiZSB1c2VkIHdpdGhpbiBhIHtAbGluayBncm91cCBncm91cH0gb3IgYSB7QGxpbmsgdHJhbnNpdGlvblxuICAgICAqIHRyYW5zaXRpb259XG4gICAgICogYW5kIGl0IHdpbGwgb25seSBjb250aW51ZSB0byB0aGUgbmV4dCBpbnN0cnVjdGlvbiBvbmNlIGVhY2ggb2YgdGhlIGlubmVyIGFuaW1hdGlvbiBzdGVwc1xuICAgICAqIGhhdmUgY29tcGxldGVkLlxuICAgICAqXG4gICAgICogVG8gcGVyZm9ybSBhbmltYXRpb24gc3R5bGluZyBpbiBwYXJhbGxlbCB3aXRoIG90aGVyIGFuaW1hdGlvbiBzdGVwcyB0aGVuXG4gICAgICogaGF2ZSBhIGxvb2sgYXQgdGhlIHtAbGluayBncm91cCBncm91cH0gYW5pbWF0aW9uIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogIyMjIFVzYWdlXG4gICAgICpcbiAgICAgKiBUaGUgYHN0ZXBzYCBkYXRhIHRoYXQgaXMgcGFzc2VkIGludG8gdGhlIGBzZXF1ZW5jZWAgYW5pbWF0aW9uIGZ1bmN0aW9uIGNhbiBlaXRoZXIgY29uc2lzdFxuICAgICAqIG9mIHtAbGluayBzdHlsZSBzdHlsZX0gb3Ige0BsaW5rIGFuaW1hdGUgYW5pbWF0ZX0gZnVuY3Rpb24gY2FsbHMuIEEgY2FsbCB0byBgc3R5bGUoKWAgd2lsbCBhcHBseVxuICAgICAqIHRoZVxuICAgICAqIHByb3ZpZGVkIHN0eWxpbmcgZGF0YSBpbW1lZGlhdGVseSB3aGlsZSBhIGNhbGwgdG8gYGFuaW1hdGUoKWAgd2lsbCBhcHBseSBpdHMgc3R5bGluZ1xuICAgICAqIGRhdGEgb3ZlciBhIGdpdmVuIHRpbWUgZGVwZW5kaW5nIG9uIGl0cyB0aW1pbmcgZGF0YS5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBzZXF1ZW5jZShbXG4gICAgICogICBzdHlsZSh7IG9wYWNpdHk6IDAgfSkpLFxuICAgICAqICAgYW5pbWF0ZShcIjFzXCIsIHsgb3BhY2l0eTogMSB9KSlcbiAgICAgKiBdKVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L0tlejhYR1dCeFd1ZTdxUDduTnZGP3A9cHJldmlldykpXG4gICAgICpcbiAgICAgKiB7QGV4YW1wbGUgY29yZS9hbmltYXRpb24vdHMvZHNsL2FuaW1hdGlvbl9leGFtcGxlLnRzIHJlZ2lvbj0nQ29tcG9uZW50J31cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWwgQW5pbWF0aW9uIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNlcXVlbmNlKHN0ZXBzKSB7XG4gICAgICAgIHJldHVybiBuZXcgQW5pbWF0aW9uU2VxdWVuY2VNZXRhZGF0YShzdGVwcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBzdHlsZWAgaXMgYW4gYW5pbWF0aW9uLXNwZWNpZmljIGZ1bmN0aW9uIHRoYXQgaXMgZGVzaWduZWQgdG8gYmUgdXNlZCBpbnNpZGUgb2YgQW5ndWxhcjInc1xuICAgICAqIGFuaW1hdGlvblxuICAgICAqIERTTCBsYW5ndWFnZS4gSWYgdGhpcyBpbmZvcm1hdGlvbiBpcyBuZXcsIHBsZWFzZSBuYXZpZ2F0ZSB0byB0aGVcbiAgICAgKiB7QGxpbmsgQ29tcG9uZW50I2FuaW1hdGlvbnMtYW5jaG9yIGNvbXBvbmVudCBhbmltYXRpb25zIG1ldGFkYXRhXG4gICAgICogcGFnZX0gdG8gZ2FpbiBhIGJldHRlciB1bmRlcnN0YW5kaW5nIG9mIGhvdyBhbmltYXRpb25zIGluIEFuZ3VsYXIyIGFyZSB1c2VkLlxuICAgICAqXG4gICAgICogYHN0eWxlYCBkZWNsYXJlcyBhIGtleS92YWx1ZSBvYmplY3QgY29udGFpbmluZyBDU1MgcHJvcGVydGllcy9zdHlsZXMgdGhhdCBjYW4gdGhlblxuICAgICAqIGJlIHVzZWQgZm9yIHtAbGluayBzdGF0ZSBhbmltYXRpb24gc3RhdGVzfSwgd2l0aGluIGFuIHtAbGluayBzZXF1ZW5jZSBhbmltYXRpb24gc2VxdWVuY2V9LCBvciBhc1xuICAgICAqIHN0eWxpbmcgZGF0YSBmb3IgYm90aCB7QGxpbmsgYW5pbWF0ZSBhbmltYXRlfSBhbmQge0BsaW5rIGtleWZyYW1lcyBrZXlmcmFtZXN9LlxuICAgICAqXG4gICAgICogIyMjIFVzYWdlXG4gICAgICpcbiAgICAgKiBgc3R5bGVgIHRha2VzIGluIGEga2V5L3ZhbHVlIHN0cmluZyBtYXAgYXMgZGF0YSBhbmQgZXhwZWN0cyBvbmUgb3IgbW9yZSBDU1MgcHJvcGVydHkvdmFsdWVcbiAgICAgKiBwYWlycyB0byBiZSBkZWZpbmVkLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIC8vIHN0cmluZyB2YWx1ZXMgYXJlIHVzZWQgZm9yIGNzcyBwcm9wZXJ0aWVzXG4gICAgICogc3R5bGUoeyBiYWNrZ3JvdW5kOiBcInJlZFwiLCBjb2xvcjogXCJibHVlXCIgfSlcbiAgICAgKlxuICAgICAqIC8vIG51bWVyaWNhbCAocGl4ZWwpIHZhbHVlcyBhcmUgYWxzbyBzdXBwb3J0ZWRcbiAgICAgKiBzdHlsZSh7IHdpZHRoOiAxMDAsIGhlaWdodDogMCB9KVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogIyMjIyBBdXRvLXN0eWxlcyAodXNpbmcgYCpgKVxuICAgICAqXG4gICAgICogV2hlbiBhbiBhc3Rlcml4IChgKmApIGNoYXJhY3RlciBpcyB1c2VkIGFzIGEgdmFsdWUgdGhlbiBpdCB3aWxsIGJlIGRldGVjdGVkIGZyb20gdGhlIGVsZW1lbnRcbiAgICAgKiBiZWluZyBhbmltYXRlZFxuICAgICAqIGFuZCBhcHBsaWVkIGFzIGFuaW1hdGlvbiBkYXRhIHdoZW4gdGhlIGFuaW1hdGlvbiBzdGFydHMuXG4gICAgICpcbiAgICAgKiBUaGlzIGZlYXR1cmUgcHJvdmVzIHVzZWZ1bCBmb3IgYSBzdGF0ZSBkZXBlbmRpbmcgb24gbGF5b3V0IGFuZC9vciBlbnZpcm9ubWVudCBmYWN0b3JzOyBpbiBzdWNoXG4gICAgICogY2FzZXNcbiAgICAgKiB0aGUgc3R5bGVzIGFyZSBjYWxjdWxhdGVkIGp1c3QgYmVmb3JlIHRoZSBhbmltYXRpb24gc3RhcnRzLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIC8vIHRoZSBzdGVwcyBiZWxvdyB3aWxsIGFuaW1hdGUgZnJvbSAwIHRvIHRoZVxuICAgICAqIC8vIGFjdHVhbCBoZWlnaHQgb2YgdGhlIGVsZW1lbnRcbiAgICAgKiBzdHlsZSh7IGhlaWdodDogMCB9KSxcbiAgICAgKiBhbmltYXRlKFwiMXNcIiwgc3R5bGUoeyBoZWlnaHQ6IFwiKlwiIH0pKVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L0tlejhYR1dCeFd1ZTdxUDduTnZGP3A9cHJldmlldykpXG4gICAgICpcbiAgICAgKiB7QGV4YW1wbGUgY29yZS9hbmltYXRpb24vdHMvZHNsL2FuaW1hdGlvbl9leGFtcGxlLnRzIHJlZ2lvbj0nQ29tcG9uZW50J31cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWwgQW5pbWF0aW9uIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0eWxlKHRva2Vucykge1xuICAgICAgICB2YXIgaW5wdXQ7XG4gICAgICAgIHZhciBvZmZzZXQgPSBudWxsO1xuICAgICAgICBpZiAodHlwZW9mIHRva2VucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlucHV0ID0gW3Rva2Vuc107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0b2tlbnMpKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSB0b2tlbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IFt0b2tlbnNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5wdXQuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZW50cnlPZmZzZXQgPSBlbnRyeVsnb2Zmc2V0J107XG4gICAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudChlbnRyeU9mZnNldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ID09IG51bGwgPyBwYXJzZUZsb2F0KGVudHJ5T2Zmc2V0KSA6IG9mZnNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEFuaW1hdGlvblN0eWxlTWV0YWRhdGEoaW5wdXQsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBzdGF0ZWAgaXMgYW4gYW5pbWF0aW9uLXNwZWNpZmljIGZ1bmN0aW9uIHRoYXQgaXMgZGVzaWduZWQgdG8gYmUgdXNlZCBpbnNpZGUgb2YgQW5ndWxhcjInc1xuICAgICAqIGFuaW1hdGlvblxuICAgICAqIERTTCBsYW5ndWFnZS4gSWYgdGhpcyBpbmZvcm1hdGlvbiBpcyBuZXcsIHBsZWFzZSBuYXZpZ2F0ZSB0byB0aGVcbiAgICAgKiB7QGxpbmsgQ29tcG9uZW50I2FuaW1hdGlvbnMtYW5jaG9yIGNvbXBvbmVudCBhbmltYXRpb25zIG1ldGFkYXRhXG4gICAgICogcGFnZX0gdG8gZ2FpbiBhIGJldHRlciB1bmRlcnN0YW5kaW5nIG9mIGhvdyBhbmltYXRpb25zIGluIEFuZ3VsYXIyIGFyZSB1c2VkLlxuICAgICAqXG4gICAgICogYHN0YXRlYCBkZWNsYXJlcyBhbiBhbmltYXRpb24gc3RhdGUgd2l0aGluIHRoZSBnaXZlbiB0cmlnZ2VyLiBXaGVuIGEgc3RhdGUgaXNcbiAgICAgKiBhY3RpdmUgd2l0aGluIGEgY29tcG9uZW50IHRoZW4gaXRzIGFzc29jaWF0ZWQgc3R5bGVzIHdpbGwgcGVyc2lzdCBvblxuICAgICAqIHRoZSBlbGVtZW50IHRoYXQgdGhlIHRyaWdnZXIgaXMgYXR0YWNoZWQgdG8gKGV2ZW4gd2hlbiB0aGUgYW5pbWF0aW9uIGVuZHMpLlxuICAgICAqXG4gICAgICogVG8gYW5pbWF0ZSBiZXR3ZWVuIHN0YXRlcywgaGF2ZSBhIGxvb2sgYXQgdGhlIGFuaW1hdGlvbiB7QGxpbmsgdHJhbnNpdGlvbiB0cmFuc2l0aW9ufVxuICAgICAqIERTTCBmdW5jdGlvbi4gVG8gcmVnaXN0ZXIgc3RhdGVzIHRvIGFuIGFuaW1hdGlvbiB0cmlnZ2VyIHBsZWFzZSBoYXZlIGEgbG9va1xuICAgICAqIGF0IHRoZSB7QGxpbmsgdHJpZ2dlciB0cmlnZ2VyfSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqICMjIyMgVGhlIGB2b2lkYCBzdGF0ZVxuICAgICAqXG4gICAgICogVGhlIGB2b2lkYCBzdGF0ZSB2YWx1ZSBpcyBhIHJlc2VydmVkIHdvcmQgdGhhdCBhbmd1bGFyIHVzZXMgdG8gZGV0ZXJtaW5lIHdoZW4gdGhlIGVsZW1lbnQgaXMgbm90XG4gICAgICogYXBhcnRcbiAgICAgKiBvZiB0aGUgYXBwbGljYXRpb24gYW55bW9yZSAoZS5nLiB3aGVuIGFuIGBuZ0lmYCBldmFsdWF0ZXMgdG8gZmFsc2UgdGhlbiB0aGUgc3RhdGUgb2YgdGhlXG4gICAgICogYXNzb2NpYXRlZCBlbGVtZW50XG4gICAgICogaXMgdm9pZCkuXG4gICAgICpcbiAgICAgKiAjIyMjIFRoZSBgKmAgKGRlZmF1bHQpIHN0YXRlXG4gICAgICpcbiAgICAgKiBUaGUgYCpgIHN0YXRlICh3aGVuIHN0eWxlZCkgaXMgYSBmYWxsYmFjayBzdGF0ZSB0aGF0IHdpbGwgYmUgdXNlZCBpZlxuICAgICAqIHRoZSBzdGF0ZSB0aGF0IGlzIGJlaW5nIGFuaW1hdGVkIGlzIG5vdCBkZWNsYXJlZCB3aXRoaW4gdGhlIHRyaWdnZXIuXG4gICAgICpcbiAgICAgKiAjIyMgVXNhZ2VcbiAgICAgKlxuICAgICAqIGBzdGF0ZWAgd2lsbCBkZWNsYXJlIGFuIGFuaW1hdGlvbiBzdGF0ZSB3aXRoIGl0cyBhc3NvY2lhdGVkIHN0eWxlc1xuICAgICAqIHdpdGhpbiB0aGUgZ2l2ZW4gdHJpZ2dlci5cbiAgICAgKlxuICAgICAqIC0gYHN0YXRlTmFtZUV4cHJgIGNhbiBiZSBvbmUgb3IgbW9yZSBzdGF0ZSBuYW1lcyBzZXBhcmF0ZWQgYnkgY29tbWFzLlxuICAgICAqIC0gYHN0eWxlc2AgcmVmZXJzIHRvIHRoZSB7QGxpbmsgc3R5bGUgc3R5bGluZyBkYXRhfSB0aGF0IHdpbGwgYmUgcGVyc2lzdGVkIG9uIHRoZSBlbGVtZW50IG9uY2VcbiAgICAgKiB0aGUgc3RhdGVcbiAgICAgKiBoYXMgYmVlbiByZWFjaGVkLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIC8vIFwidm9pZFwiIGlzIGEgcmVzZXJ2ZWQgbmFtZSBmb3IgYSBzdGF0ZSBhbmQgaXMgdXNlZCB0byByZXByZXNlbnRcbiAgICAgKiAvLyB0aGUgc3RhdGUgaW4gd2hpY2ggYW4gZWxlbWVudCBpcyBkZXRhY2hlZCBmcm9tIGZyb20gdGhlIGFwcGxpY2F0aW9uLlxuICAgICAqIHN0YXRlKFwidm9pZFwiLCBzdHlsZSh7IGhlaWdodDogMCB9KSlcbiAgICAgKlxuICAgICAqIC8vIHVzZXItZGVmaW5lZCBzdGF0ZXNcbiAgICAgKiBzdGF0ZShcImNsb3NlZFwiLCBzdHlsZSh7IGhlaWdodDogMCB9KSlcbiAgICAgKiBzdGF0ZShcIm9wZW4sIHZpc2libGVcIiwgc3R5bGUoeyBoZWlnaHQ6IFwiKlwiIH0pKVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L0tlejhYR1dCeFd1ZTdxUDduTnZGP3A9cHJldmlldykpXG4gICAgICpcbiAgICAgKiB7QGV4YW1wbGUgY29yZS9hbmltYXRpb24vdHMvZHNsL2FuaW1hdGlvbl9leGFtcGxlLnRzIHJlZ2lvbj0nQ29tcG9uZW50J31cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWwgQW5pbWF0aW9uIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YXRlKHN0YXRlTmFtZUV4cHIsIHN0eWxlcykge1xuICAgICAgICByZXR1cm4gbmV3IEFuaW1hdGlvblN0YXRlRGVjbGFyYXRpb25NZXRhZGF0YShzdGF0ZU5hbWVFeHByLCBzdHlsZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBga2V5ZnJhbWVzYCBpcyBhbiBhbmltYXRpb24tc3BlY2lmaWMgZnVuY3Rpb24gdGhhdCBpcyBkZXNpZ25lZCB0byBiZSB1c2VkIGluc2lkZSBvZiBBbmd1bGFyMidzXG4gICAgICogYW5pbWF0aW9uXG4gICAgICogRFNMIGxhbmd1YWdlLiBJZiB0aGlzIGluZm9ybWF0aW9uIGlzIG5ldywgcGxlYXNlIG5hdmlnYXRlIHRvIHRoZVxuICAgICAqIHtAbGluayBDb21wb25lbnQjYW5pbWF0aW9ucy1hbmNob3IgY29tcG9uZW50IGFuaW1hdGlvbnMgbWV0YWRhdGFcbiAgICAgKiBwYWdlfSB0byBnYWluIGEgYmV0dGVyIHVuZGVyc3RhbmRpbmcgb2YgaG93IGFuaW1hdGlvbnMgaW4gQW5ndWxhcjIgYXJlIHVzZWQuXG4gICAgICpcbiAgICAgKiBga2V5ZnJhbWVzYCBzcGVjaWZpZXMgYSBjb2xsZWN0aW9uIG9mIHtAbGluayBzdHlsZSBzdHlsZX0gZW50cmllcyBlYWNoIG9wdGlvbmFsbHkgY2hhcmFjdGVyaXplZFxuICAgICAqIGJ5IGFuIGBvZmZzZXRgIHZhbHVlLlxuICAgICAqXG4gICAgICogIyMjIFVzYWdlXG4gICAgICpcbiAgICAgKiBUaGUgYGtleWZyYW1lc2AgYW5pbWF0aW9uIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIHVzZWQgYWxvbmdzaWRlIHRoZSB7QGxpbmsgYW5pbWF0ZSBhbmltYXRlfVxuICAgICAqIGFuaW1hdGlvbiBmdW5jdGlvbi4gSW5zdGVhZCBvZiBhcHBseWluZyBhbmltYXRpb25zIGZyb20gd2hlcmUgdGhleSBhcmVcbiAgICAgKiBjdXJyZW50bHkgdG8gdGhlaXIgZGVzdGluYXRpb24sIGtleWZyYW1lcyBjYW4gZGVzY3JpYmUgaG93IGVhY2ggc3R5bGUgZW50cnkgaXMgYXBwbGllZFxuICAgICAqIGFuZCBhdCB3aGF0IHBvaW50IHdpdGhpbiB0aGUgYW5pbWF0aW9uIGFyYyAobXVjaCBsaWtlIENTUyBLZXlmcmFtZSBBbmltYXRpb25zIGRvKS5cbiAgICAgKlxuICAgICAqIEZvciBlYWNoIGBzdHlsZSgpYCBlbnRyeSBhbiBgb2Zmc2V0YCB2YWx1ZSBjYW4gYmUgc2V0LiBEb2luZyBzbyBhbGxvd3MgdG8gc3BlY2lmaXkgYXRcbiAgICAgKiB3aGF0IHBlcmNlbnRhZ2Ugb2YgdGhlIGFuaW1hdGUgdGltZSB0aGUgc3R5bGVzIHdpbGwgYmUgYXBwbGllZC5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiAvLyB0aGUgcHJvdmlkZWQgb2Zmc2V0IHZhbHVlcyBkZXNjcmliZSB3aGVuIGVhY2ggYmFja2dyb3VuZENvbG9yIHZhbHVlIGlzIGFwcGxpZWQuXG4gICAgICogYW5pbWF0ZShcIjVzXCIsIGtleWZyYW1lcyhbXG4gICAgICogICBzdHlsZSh7IGJhY2tncm91bmRDb2xvcjogXCJyZWRcIiwgb2Zmc2V0OiAwIH0pLFxuICAgICAqICAgc3R5bGUoeyBiYWNrZ3JvdW5kQ29sb3I6IFwiYmx1ZVwiLCBvZmZzZXQ6IDAuMiB9KSxcbiAgICAgKiAgIHN0eWxlKHsgYmFja2dyb3VuZENvbG9yOiBcIm9yYW5nZVwiLCBvZmZzZXQ6IDAuMyB9KSxcbiAgICAgKiAgIHN0eWxlKHsgYmFja2dyb3VuZENvbG9yOiBcImJsYWNrXCIsIG9mZnNldDogMSB9KVxuICAgICAqIF0pKVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQWx0ZXJuYXRpdmVseSwgaWYgdGhlcmUgYXJlIG5vIGBvZmZzZXRgIHZhbHVlcyB1c2VkIHdpdGhpbiB0aGUgc3R5bGUgZW50cmllcyB0aGVuIHRoZSBvZmZzZXRzXG4gICAgICogd2lsbFxuICAgICAqIGJlIGNhbGN1bGF0ZWQgYXV0b21hdGljYWxseS5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBhbmltYXRlKFwiNXNcIiwga2V5ZnJhbWVzKFtcbiAgICAgKiAgIHN0eWxlKHsgYmFja2dyb3VuZENvbG9yOiBcInJlZFwiIH0pIC8vIG9mZnNldCA9IDBcbiAgICAgKiAgIHN0eWxlKHsgYmFja2dyb3VuZENvbG9yOiBcImJsdWVcIiB9KSAvLyBvZmZzZXQgPSAwLjMzXG4gICAgICogICBzdHlsZSh7IGJhY2tncm91bmRDb2xvcjogXCJvcmFuZ2VcIiB9KSAvLyBvZmZzZXQgPSAwLjY2XG4gICAgICogICBzdHlsZSh7IGJhY2tncm91bmRDb2xvcjogXCJibGFja1wiIH0pIC8vIG9mZnNldCA9IDFcbiAgICAgKiBdKSlcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9LZXo4WEdXQnhXdWU3cVA3bk52Rj9wPXByZXZpZXcpKVxuICAgICAqXG4gICAgICoge0BleGFtcGxlIGNvcmUvYW5pbWF0aW9uL3RzL2RzbC9hbmltYXRpb25fZXhhbXBsZS50cyByZWdpb249J0NvbXBvbmVudCd9XG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsIEFuaW1hdGlvbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBrZXlmcmFtZXMoc3RlcHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBbmltYXRpb25LZXlmcmFtZXNTZXF1ZW5jZU1ldGFkYXRhKHN0ZXBzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYHRyYW5zaXRpb25gIGlzIGFuIGFuaW1hdGlvbi1zcGVjaWZpYyBmdW5jdGlvbiB0aGF0IGlzIGRlc2lnbmVkIHRvIGJlIHVzZWQgaW5zaWRlIG9mIEFuZ3VsYXIyJ3NcbiAgICAgKiBhbmltYXRpb25cbiAgICAgKiBEU0wgbGFuZ3VhZ2UuIElmIHRoaXMgaW5mb3JtYXRpb24gaXMgbmV3LCBwbGVhc2UgbmF2aWdhdGUgdG8gdGhlXG4gICAgICoge0BsaW5rIENvbXBvbmVudCNhbmltYXRpb25zLWFuY2hvciBjb21wb25lbnQgYW5pbWF0aW9ucyBtZXRhZGF0YVxuICAgICAqIHBhZ2V9IHRvIGdhaW4gYSBiZXR0ZXIgdW5kZXJzdGFuZGluZyBvZiBob3cgYW5pbWF0aW9ucyBpbiBBbmd1bGFyMiBhcmUgdXNlZC5cbiAgICAgKlxuICAgICAqIGB0cmFuc2l0aW9uYCBkZWNsYXJlcyB0aGUge0BsaW5rIHNlcXVlbmNlIHNlcXVlbmNlIG9mIGFuaW1hdGlvbiBzdGVwc30gdGhhdCB3aWxsIGJlIHJ1biB3aGVuIHRoZVxuICAgICAqIHByb3ZpZGVkXG4gICAgICogYHN0YXRlQ2hhbmdlRXhwcmAgdmFsdWUgaXMgc2F0aXNmaWVkLiBUaGUgYHN0YXRlQ2hhbmdlRXhwcmAgY29uc2lzdHMgb2YgYSBgc3RhdGUxID0+IHN0YXRlMmBcbiAgICAgKiB3aGljaCBjb25zaXN0c1xuICAgICAqIG9mIHR3byBrbm93biBzdGF0ZXMgKHVzZSBhbiBhc3Rlcml4IChgKmApIHRvIHJlZmVyIHRvIGEgZHluYW1pYyBzdGFydGluZyBhbmQvb3IgZW5kaW5nIHN0YXRlKS5cbiAgICAgKlxuICAgICAqIEFuaW1hdGlvbiB0cmFuc2l0aW9ucyBhcmUgcGxhY2VkIHdpdGhpbiBhbiB7QGxpbmsgdHJpZ2dlciBhbmltYXRpb24gdHJpZ2dlcn0uIEZvciBhbiB0cmFuc2l0aW9uXG4gICAgICogdG8gYW5pbWF0ZSB0b1xuICAgICAqIGEgc3RhdGUgdmFsdWUgYW5kIHBlcnNpc3QgaXRzIHN0eWxlcyB0aGVuIG9uZSBvciBtb3JlIHtAbGluayBzdGF0ZSBhbmltYXRpb24gc3RhdGVzfSBpcyBleHBlY3RlZFxuICAgICAqIHRvIGJlIGRlZmluZWQuXG4gICAgICpcbiAgICAgKiAjIyMgVXNhZ2VcbiAgICAgKlxuICAgICAqIEFuIGFuaW1hdGlvbiB0cmFuc2l0aW9uIGlzIGtpY2tlZCBvZmYgdGhlIGBzdGF0ZUNoYW5nZUV4cHJgIHByZWRpY2F0ZSBldmFsdWF0ZXMgdG8gdHJ1ZSBiYXNlZCBvblxuICAgICAqIHdoYXQgdGhlXG4gICAgICogcHJldmlvdXMgc3RhdGUgaXMgYW5kIHdoYXQgdGhlIGN1cnJlbnQgc3RhdGUgaGFzIGJlY29tZS4gSW4gb3RoZXIgd29yZHMsIGlmIGEgdHJhbnNpdGlvbiBpc1xuICAgICAqIGRlZmluZWQgdGhhdFxuICAgICAqIG1hdGNoZXMgdGhlIG9sZC9jdXJyZW50IHN0YXRlIGNyaXRlcmlhIHRoZW4gdGhlIGFzc29jaWF0ZWQgYW5pbWF0aW9uIHdpbGwgYmUgdHJpZ2dlcmVkLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIC8vIGFsbCB0cmFuc2l0aW9uL3N0YXRlIGNoYW5nZXMgYXJlIGRlZmluZWQgd2l0aGluIGFuIGFuaW1hdGlvbiB0cmlnZ2VyXG4gICAgICogdHJpZ2dlcihcIm15QW5pbWF0aW9uVHJpZ2dlclwiLCBbXG4gICAgICogICAvLyBpZiBhIHN0YXRlIGlzIGRlZmluZWQgdGhlbiBpdHMgc3R5bGVzIHdpbGwgYmUgcGVyc2lzdGVkIHdoZW4gdGhlXG4gICAgICogICAvLyBhbmltYXRpb24gaGFzIGZ1bGx5IGNvbXBsZXRlZCBpdHNlbGZcbiAgICAgKiAgIHN0YXRlKFwib25cIiwgc3R5bGUoeyBiYWNrZ3JvdW5kOiBcImdyZWVuXCIgfSkpLFxuICAgICAqICAgc3RhdGUoXCJvZmZcIiwgc3R5bGUoeyBiYWNrZ3JvdW5kOiBcImdyZXlcIiB9KSksXG4gICAgICpcbiAgICAgKiAgIC8vIGEgdHJhbnNpdGlvbiBhbmltYXRpb24gdGhhdCB3aWxsIGJlIGtpY2tlZCBvZmYgd2hlbiB0aGUgc3RhdGUgdmFsdWVcbiAgICAgKiAgIC8vIGJvdW5kIHRvIFwibXlBbmltYXRpb25UcmlnZ2VyXCIgY2hhbmdlcyBmcm9tIFwib25cIiB0byBcIm9mZlwiXG4gICAgICogICB0cmFuc2l0aW9uKFwib24gPT4gb2ZmXCIsIGFuaW1hdGUoNTAwKSksXG4gICAgICpcbiAgICAgKiAgIC8vIGl0IGlzIGFsc28gcG9zc2libGUgdG8gZG8gcnVuIHRoZSBzYW1lIGFuaW1hdGlvbiBmb3IgYm90aCBkaXJlY3Rpb25zXG4gICAgICogICB0cmFuc2l0aW9uKFwib24gPD0+IG9mZlwiLCBhbmltYXRlKDUwMCkpLFxuICAgICAqXG4gICAgICogICAvLyBvciB0byBkZWZpbmUgbXVsdGlwbGUgc3RhdGVzIHBhaXJzIHNlcGFyYXRlZCBieSBjb21tYXNcbiAgICAgKiAgIHRyYW5zaXRpb24oXCJvbiA9PiBvZmYsIG9mZiA9PiB2b2lkXCIsIGFuaW1hdGUoNTAwKSksXG4gICAgICpcbiAgICAgKiAgIC8vIHRoaXMgaXMgYSBjYXRjaC1hbGwgc3RhdGUgY2hhbmdlIGZvciB3aGVuIGFuIGVsZW1lbnQgaXMgaW5zZXJ0ZWQgaW50b1xuICAgICAqICAgLy8gdGhlIHBhZ2UgYW5kIHRoZSBkZXN0aW5hdGlvbiBzdGF0ZSBpcyB1bmtub3duXG4gICAgICogICB0cmFuc2l0aW9uKFwidm9pZCA9PiAqXCIsIFtcbiAgICAgKiAgICAgc3R5bGUoeyBvcGFjaXR5OiAwIH0pLFxuICAgICAqICAgICBhbmltYXRlKDUwMClcbiAgICAgKiAgIF0pLFxuICAgICAqXG4gICAgICogICAvLyB0aGlzIHdpbGwgY2FwdHVyZSBhIHN0YXRlIGNoYW5nZSBiZXR3ZWVuIGFueSBzdGF0ZXNcbiAgICAgKiAgIHRyYW5zaXRpb24oXCIqID0+ICpcIiwgYW5pbWF0ZShcIjFzIDBzXCIpKSxcbiAgICAgKiBdKVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogVGhlIHRlbXBsYXRlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGNvbXBvbmVudCB3aWxsIG1ha2UgdXNlIG9mIHRoZSBgbXlBbmltYXRpb25UcmlnZ2VyYFxuICAgICAqIGFuaW1hdGlvbiB0cmlnZ2VyIGJ5IGJpbmRpbmcgdG8gYW4gZWxlbWVudCB3aXRoaW4gaXRzIHRlbXBsYXRlIGNvZGUuXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPCEtLSBzb21ld2hlcmUgaW5zaWRlIG9mIG15LWNvbXBvbmVudC10cGwuaHRtbCAtLT5cbiAgICAgKiA8ZGl2IFtAbXlBbmltYXRpb25UcmlnZ2VyXT1cIm15U3RhdHVzRXhwXCI+Li4uPC9kaXY+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiAjIyMjIFRoZSBmaW5hbCBgYW5pbWF0ZWAgY2FsbFxuICAgICAqXG4gICAgICogSWYgdGhlIGZpbmFsIHN0ZXAgd2l0aGluIHRoZSB0cmFuc2l0aW9uIHN0ZXBzIGlzIGEgY2FsbCB0byBgYW5pbWF0ZSgpYCB0aGF0ICoqb25seSoqXG4gICAgICogdXNlcyBhIHRpbWluZyB2YWx1ZSB3aXRoICoqbm8gc3R5bGUgZGF0YSoqIHRoZW4gaXQgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IHVzZWQgYXMgdGhlIGZpbmFsXG4gICAgICogYW5pbWF0aW9uXG4gICAgICogYXJjIGZvciB0aGUgZWxlbWVudCB0byBhbmltYXRlIGl0c2VsZiB0byB0aGUgZmluYWwgc3RhdGUuIFRoaXMgaW52b2x2ZXMgYW4gYXV0b21hdGljIG1peCBvZlxuICAgICAqIGFkZGluZy9yZW1vdmluZyBDU1Mgc3R5bGVzIHNvIHRoYXQgdGhlIGVsZW1lbnQgd2lsbCBiZSBpbiB0aGUgZXhhY3Qgc3RhdGUgaXQgc2hvdWxkIGJlIGZvciB0aGVcbiAgICAgKiBhcHBsaWVkIHN0YXRlIHRvIGJlIHByZXNlbnRlZCBjb3JyZWN0bHkuXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiAvLyBzdGFydCBvZmYgYnkgaGlkaW5nIHRoZSBlbGVtZW50LCBidXQgbWFrZSBzdXJlIHRoYXQgaXQgYW5pbWF0ZXMgcHJvcGVybHkgdG8gd2hhdGV2ZXIgc3RhdGVcbiAgICAgKiAvLyBpcyBjdXJyZW50bHkgYWN0aXZlIGZvciBcIm15QW5pbWF0aW9uVHJpZ2dlclwiXG4gICAgICogdHJhbnNpdGlvbihcInZvaWQgPT4gKlwiLCBbXG4gICAgICogICBzdHlsZSh7IG9wYWNpdHk6IDAgfSksXG4gICAgICogICBhbmltYXRlKDUwMClcbiAgICAgKiBdKVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogIyMjIFRyYW5zaXRpb24gQWxpYXNlcyAoYDplbnRlcmAgYW5kIGA6bGVhdmVgKVxuICAgICAqXG4gICAgICogR2l2ZW4gdGhhdCBlbnRlciAoaW5zZXJ0aW9uKSBhbmQgbGVhdmUgKHJlbW92YWwpIGFuaW1hdGlvbnMgYXJlIHNvIGNvbW1vbixcbiAgICAgKiB0aGUgYHRyYW5zaXRpb25gIGZ1bmN0aW9uIGFjY2VwdHMgYm90aCBgOmVudGVyYCBhbmQgYDpsZWF2ZWAgdmFsdWVzIHdoaWNoXG4gICAgICogYXJlIGFsaWFzZXMgZm9yIHRoZSBgdm9pZCA9PiAqYCBhbmQgYCogPT4gdm9pZGAgc3RhdGUgY2hhbmdlcy5cbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIHRyYW5zaXRpb24oXCI6ZW50ZXJcIiwgW1xuICAgICAqICAgc3R5bGUoeyBvcGFjaXR5OiAwIH0pLFxuICAgICAqICAgYW5pbWF0ZSg1MDAsIHN0eWxlKHsgb3BhY2l0eTogMSB9KSlcbiAgICAgKiBdKVxuICAgICAqIHRyYW5zaXRpb24oXCI6bGVhdmVcIiwgW1xuICAgICAqICAgYW5pbWF0ZSg1MDAsIHN0eWxlKHsgb3BhY2l0eTogMCB9KSlcbiAgICAgKiBdKVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L0tlejhYR1dCeFd1ZTdxUDduTnZGP3A9cHJldmlldykpXG4gICAgICpcbiAgICAgKiB7QGV4YW1wbGUgY29yZS9hbmltYXRpb24vdHMvZHNsL2FuaW1hdGlvbl9leGFtcGxlLnRzIHJlZ2lvbj0nQ29tcG9uZW50J31cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWwgQW5pbWF0aW9uIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyYW5zaXRpb24oc3RhdGVDaGFuZ2VFeHByLCBzdGVwcykge1xuICAgICAgICB2YXIgYW5pbWF0aW9uRGF0YSA9IEFycmF5LmlzQXJyYXkoc3RlcHMpID8gbmV3IEFuaW1hdGlvblNlcXVlbmNlTWV0YWRhdGEoc3RlcHMpIDogc3RlcHM7XG4gICAgICAgIHJldHVybiBuZXcgQW5pbWF0aW9uU3RhdGVUcmFuc2l0aW9uTWV0YWRhdGEoc3RhdGVDaGFuZ2VFeHByLCBhbmltYXRpb25EYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYHRyaWdnZXJgIGlzIGFuIGFuaW1hdGlvbi1zcGVjaWZpYyBmdW5jdGlvbiB0aGF0IGlzIGRlc2lnbmVkIHRvIGJlIHVzZWQgaW5zaWRlIG9mIEFuZ3VsYXIyJ3NcbiAgICAgKiBhbmltYXRpb25cbiAgICAgKiBEU0wgbGFuZ3VhZ2UuIElmIHRoaXMgaW5mb3JtYXRpb24gaXMgbmV3LCBwbGVhc2UgbmF2aWdhdGUgdG8gdGhlXG4gICAgICoge0BsaW5rIENvbXBvbmVudCNhbmltYXRpb25zLWFuY2hvciBjb21wb25lbnQgYW5pbWF0aW9ucyBtZXRhZGF0YVxuICAgICAqIHBhZ2V9IHRvIGdhaW4gYSBiZXR0ZXIgdW5kZXJzdGFuZGluZyBvZiBob3cgYW5pbWF0aW9ucyBpbiBBbmd1bGFyMiBhcmUgdXNlZC5cbiAgICAgKlxuICAgICAqIGB0cmlnZ2VyYCBDcmVhdGVzIGFuIGFuaW1hdGlvbiB0cmlnZ2VyIHdoaWNoIHdpbGwgYSBsaXN0IG9mIHtAbGluayBzdGF0ZSBzdGF0ZX0gYW5kIHtAbGlua1xuICAgICAqIHRyYW5zaXRpb24gdHJhbnNpdGlvbn1cbiAgICAgKiBlbnRyaWVzIHRoYXQgd2lsbCBiZSBldmFsdWF0ZWQgd2hlbiB0aGUgZXhwcmVzc2lvbiBib3VuZCB0byB0aGUgdHJpZ2dlciBjaGFuZ2VzLlxuICAgICAqXG4gICAgICogVHJpZ2dlcnMgYXJlIHJlZ2lzdGVyZWQgd2l0aGluIHRoZSBjb21wb25lbnQgYW5ub3RhdGlvbiBkYXRhIHVuZGVyIHRoZVxuICAgICAqIHtAbGluayBDb21wb25lbnQjYW5pbWF0aW9ucy1hbmNob3IgYW5pbWF0aW9ucyBzZWN0aW9ufS4gQW4gYW5pbWF0aW9uIHRyaWdnZXIgY2FuXG4gICAgICogYmUgcGxhY2VkIG9uIGFuIGVsZW1lbnQgd2l0aGluIGEgdGVtcGxhdGUgYnkgcmVmZXJlbmNpbmcgdGhlIG5hbWUgb2YgdGhlXG4gICAgICogdHJpZ2dlciBmb2xsb3dlZCBieSB0aGUgZXhwcmVzc2lvbiB2YWx1ZSB0aGF0IHRoZSB0cmlnZ2VyIGlzIGJvdW5kIHRvXG4gICAgICogKGluIHRoZSBmb3JtIG9mIGBbQHRyaWdnZXJOYW1lXT1cImV4cHJlc3Npb25cImAuXG4gICAgICpcbiAgICAgKiAjIyMgVXNhZ2VcbiAgICAgKlxuICAgICAqIGB0cmlnZ2VyYCB3aWxsIGNyZWF0ZSBhbiBhbmltYXRpb24gdHJpZ2dlciByZWZlcmVuY2UgYmFzZWQgb24gdGhlIHByb3ZpZGVkIGBuYW1lYCB2YWx1ZS5cbiAgICAgKiBUaGUgcHJvdmlkZWQgYGFuaW1hdGlvbmAgdmFsdWUgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gYXJyYXkgY29uc2lzdGluZyBvZiB7QGxpbmsgc3RhdGUgc3RhdGV9IGFuZFxuICAgICAqIHtAbGluayB0cmFuc2l0aW9uIHRyYW5zaXRpb259XG4gICAgICogZGVjbGFyYXRpb25zLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIEBDb21wb25lbnQoe1xuICAgICAqICAgc2VsZWN0b3I6ICdteS1jb21wb25lbnQnLFxuICAgICAqICAgdGVtcGxhdGVVcmw6ICdteS1jb21wb25lbnQtdHBsLmh0bWwnLFxuICAgICAqICAgYW5pbWF0aW9uczogW1xuICAgICAqICAgICB0cmlnZ2VyKFwibXlBbmltYXRpb25UcmlnZ2VyXCIsIFtcbiAgICAgKiAgICAgICBzdGF0ZSguLi4pLFxuICAgICAqICAgICAgIHN0YXRlKC4uLiksXG4gICAgICogICAgICAgdHJhbnNpdGlvbiguLi4pLFxuICAgICAqICAgICAgIHRyYW5zaXRpb24oLi4uKVxuICAgICAqICAgICBdKVxuICAgICAqICAgXVxuICAgICAqIH0pXG4gICAgICogY2xhc3MgTXlDb21wb25lbnQge1xuICAgICAqICAgbXlTdGF0dXNFeHAgPSBcInNvbWV0aGluZ1wiO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFRoZSB0ZW1wbGF0ZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBjb21wb25lbnQgd2lsbCBtYWtlIHVzZSBvZiB0aGUgYG15QW5pbWF0aW9uVHJpZ2dlcmBcbiAgICAgKiBhbmltYXRpb24gdHJpZ2dlciBieSBiaW5kaW5nIHRvIGFuIGVsZW1lbnQgd2l0aGluIGl0cyB0ZW1wbGF0ZSBjb2RlLlxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDwhLS0gc29tZXdoZXJlIGluc2lkZSBvZiBteS1jb21wb25lbnQtdHBsLmh0bWwgLS0+XG4gICAgICogPGRpdiBbQG15QW5pbWF0aW9uVHJpZ2dlcl09XCJteVN0YXR1c0V4cFwiPi4uLjwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L0tlejhYR1dCeFd1ZTdxUDduTnZGP3A9cHJldmlldykpXG4gICAgICpcbiAgICAgKiB7QGV4YW1wbGUgY29yZS9hbmltYXRpb24vdHMvZHNsL2FuaW1hdGlvbl9leGFtcGxlLnRzIHJlZ2lvbj0nQ29tcG9uZW50J31cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWwgQW5pbWF0aW9uIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyaWdnZXIobmFtZSwgYW5pbWF0aW9uKSB7XG4gICAgICAgIHJldHVybiBuZXcgQW5pbWF0aW9uRW50cnlNZXRhZGF0YShuYW1lLCBhbmltYXRpb24pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZXBhcmVGaW5hbEFuaW1hdGlvblN0eWxlcyhwcmV2aW91c1N0eWxlcywgbmV3U3R5bGVzLCBudWxsVmFsdWUpIHtcbiAgICAgICAgaWYgKG51bGxWYWx1ZSA9PT0gdm9pZCAwKSB7IG51bGxWYWx1ZSA9IG51bGw7IH1cbiAgICAgICAgdmFyIGZpbmFsU3R5bGVzID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKG5ld1N0eWxlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gbmV3U3R5bGVzW3Byb3BdO1xuICAgICAgICAgICAgZmluYWxTdHlsZXNbcHJvcF0gPSB2YWx1ZSA9PSBBVVRPX1NUWUxFID8gbnVsbFZhbHVlIDogdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5rZXlzKHByZXZpb3VzU3R5bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICBpZiAoIWlzUHJlc2VudChmaW5hbFN0eWxlc1twcm9wXSkpIHtcbiAgICAgICAgICAgICAgICBmaW5hbFN0eWxlc1twcm9wXSA9IG51bGxWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmaW5hbFN0eWxlcztcbiAgICB9XG4gICAgZnVuY3Rpb24gYmFsYW5jZUFuaW1hdGlvbktleWZyYW1lcyhjb2xsZWN0ZWRTdHlsZXMsIGZpbmFsU3RhdGVTdHlsZXMsIGtleWZyYW1lcykge1xuICAgICAgICB2YXIgbGltaXQgPSBrZXlmcmFtZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgdmFyIGZpcnN0S2V5ZnJhbWUgPSBrZXlmcmFtZXNbMF07XG4gICAgICAgIC8vIHBoYXNlIDE6IGNvcHkgYWxsIHRoZSBzdHlsZXMgZnJvbSB0aGUgZmlyc3Qga2V5ZnJhbWUgaW50byB0aGUgbG9va3VwIG1hcFxuICAgICAgICB2YXIgZmxhdGVuZWRGaXJzdEtleWZyYW1lU3R5bGVzID0gZmxhdHRlblN0eWxlcyhmaXJzdEtleWZyYW1lLnN0eWxlcy5zdHlsZXMpO1xuICAgICAgICB2YXIgZXh0cmFGaXJzdEtleWZyYW1lU3R5bGVzID0ge307XG4gICAgICAgIHZhciBoYXNFeHRyYUZpcnN0U3R5bGVzID0gZmFsc2U7XG4gICAgICAgIE9iamVjdC5rZXlzKGNvbGxlY3RlZFN0eWxlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gY29sbGVjdGVkU3R5bGVzW3Byb3BdO1xuICAgICAgICAgICAgLy8gaWYgdGhlIHN0eWxlIGlzIGFscmVhZHkgZGVmaW5lZCBpbiB0aGUgZmlyc3Qga2V5ZnJhbWUgdGhlblxuICAgICAgICAgICAgLy8gd2UgZG8gbm90IHJlcGxhY2UgaXQuXG4gICAgICAgICAgICBpZiAoIWZsYXRlbmVkRmlyc3RLZXlmcmFtZVN0eWxlc1twcm9wXSkge1xuICAgICAgICAgICAgICAgIGZsYXRlbmVkRmlyc3RLZXlmcmFtZVN0eWxlc1twcm9wXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGV4dHJhRmlyc3RLZXlmcmFtZVN0eWxlc1twcm9wXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGhhc0V4dHJhRmlyc3RTdHlsZXMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGtleWZyYW1lQ29sbGVjdGVkU3R5bGVzID0gU3RyaW5nTWFwV3JhcHBlci5tZXJnZSh7fSwgZmxhdGVuZWRGaXJzdEtleWZyYW1lU3R5bGVzKTtcbiAgICAgICAgLy8gcGhhc2UgMjogbm9ybWFsaXplIHRoZSBmaW5hbCBrZXlmcmFtZVxuICAgICAgICB2YXIgZmluYWxLZXlmcmFtZSA9IGtleWZyYW1lc1tsaW1pdF07XG4gICAgICAgIExpc3RXcmFwcGVyLmluc2VydChmaW5hbEtleWZyYW1lLnN0eWxlcy5zdHlsZXMsIDAsIGZpbmFsU3RhdGVTdHlsZXMpO1xuICAgICAgICB2YXIgZmxhdGVuZWRGaW5hbEtleWZyYW1lU3R5bGVzID0gZmxhdHRlblN0eWxlcyhmaW5hbEtleWZyYW1lLnN0eWxlcy5zdHlsZXMpO1xuICAgICAgICB2YXIgZXh0cmFGaW5hbEtleWZyYW1lU3R5bGVzID0ge307XG4gICAgICAgIHZhciBoYXNFeHRyYUZpbmFsU3R5bGVzID0gZmFsc2U7XG4gICAgICAgIE9iamVjdC5rZXlzKGtleWZyYW1lQ29sbGVjdGVkU3R5bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICBpZiAoIWlzUHJlc2VudChmbGF0ZW5lZEZpbmFsS2V5ZnJhbWVTdHlsZXNbcHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgZXh0cmFGaW5hbEtleWZyYW1lU3R5bGVzW3Byb3BdID0gQVVUT19TVFlMRTtcbiAgICAgICAgICAgICAgICBoYXNFeHRyYUZpbmFsU3R5bGVzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChoYXNFeHRyYUZpbmFsU3R5bGVzKSB7XG4gICAgICAgICAgICBmaW5hbEtleWZyYW1lLnN0eWxlcy5zdHlsZXMucHVzaChleHRyYUZpbmFsS2V5ZnJhbWVTdHlsZXMpO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5rZXlzKGZsYXRlbmVkRmluYWxLZXlmcmFtZVN0eWxlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgaWYgKCFpc1ByZXNlbnQoZmxhdGVuZWRGaXJzdEtleWZyYW1lU3R5bGVzW3Byb3BdKSkge1xuICAgICAgICAgICAgICAgIGV4dHJhRmlyc3RLZXlmcmFtZVN0eWxlc1twcm9wXSA9IEFVVE9fU1RZTEU7XG4gICAgICAgICAgICAgICAgaGFzRXh0cmFGaXJzdFN0eWxlcyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaGFzRXh0cmFGaXJzdFN0eWxlcykge1xuICAgICAgICAgICAgZmlyc3RLZXlmcmFtZS5zdHlsZXMuc3R5bGVzLnB1c2goZXh0cmFGaXJzdEtleWZyYW1lU3R5bGVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga2V5ZnJhbWVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbGVhclN0eWxlcyhzdHlsZXMpIHtcbiAgICAgICAgdmFyIGZpbmFsU3R5bGVzID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKHN0eWxlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IGZpbmFsU3R5bGVzW2tleV0gPSBudWxsOyB9KTtcbiAgICAgICAgcmV0dXJuIGZpbmFsU3R5bGVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb2xsZWN0QW5kUmVzb2x2ZVN0eWxlcyhjb2xsZWN0aW9uLCBzdHlsZXMpIHtcbiAgICAgICAgcmV0dXJuIHN0eWxlcy5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICB2YXIgc3R5bGVzT2JqID0ge307XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhlbnRyeSkuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGVudHJ5W3Byb3BdO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBGSUxMX1NUWUxFX0ZMQUcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBjb2xsZWN0aW9uW3Byb3BdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUHJlc2VudCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gQVVUT19TVFlMRTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uW3Byb3BdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgc3R5bGVzT2JqW3Byb3BdID0gdmFsdWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBzdHlsZXNPYmo7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZW5kZXJTdHlsZXMoZWxlbWVudCwgcmVuZGVyZXIsIHN0eWxlcykge1xuICAgICAgICBPYmplY3Qua2V5cyhzdHlsZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHsgcmVuZGVyZXIuc2V0RWxlbWVudFN0eWxlKGVsZW1lbnQsIHByb3AsIHN0eWxlc1twcm9wXSk7IH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmbGF0dGVuU3R5bGVzKHN0eWxlcykge1xuICAgICAgICB2YXIgZmluYWxTdHlsZXMgPSB7fTtcbiAgICAgICAgc3R5bGVzLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhlbnRyeSkuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkgeyBmaW5hbFN0eWxlc1twcm9wXSA9IGVudHJ5W3Byb3BdOyB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmaW5hbFN0eWxlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIEFuaW1hdGlvblN0eWxlcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvblN0eWxlcyhzdHlsZXMpIHtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVzID0gc3R5bGVzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBbmltYXRpb25TdHlsZXM7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBBbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzIGlzIHJldHVybmVkIGFzIGFuIGV2ZW50IHBhcmFtZXRlciB3aGVuIGFuIGFuaW1hdGlvblxuICAgICAqIGNhbGxiYWNrIGlzIGNhcHR1cmVkIGZvciBhbiBhbmltYXRpb24gZWl0aGVyIGR1cmluZyB0aGUgc3RhcnQgb3IgZG9uZSBwaGFzZS5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBAQ29tcG9uZW50KHtcbiAgICAgKiAgIGhvc3Q6IHtcbiAgICAgKiAgICAgJ1tAbXlBbmltYXRpb25UcmlnZ2VyXSc6ICdzb21lRXhwcmVzc2lvbicsXG4gICAgICogICAgICcoQG15QW5pbWF0aW9uVHJpZ2dlci5zdGFydCknOiAnY2FwdHVyZVN0YXJ0RXZlbnQoJGV2ZW50KScsXG4gICAgICogICAgICcoQG15QW5pbWF0aW9uVHJpZ2dlci5kb25lKSc6ICdjYXB0dXJlRG9uZUV2ZW50KCRldmVudCknLFxuICAgICAqICAgfSxcbiAgICAgKiAgIGFuaW1hdGlvbnM6IFtcbiAgICAgKiAgICAgdHJpZ2dlcihcIm15QW5pbWF0aW9uVHJpZ2dlclwiLCBbXG4gICAgICogICAgICAgIC8vIC4uLlxuICAgICAqICAgICBdKVxuICAgICAqICAgXVxuICAgICAqIH0pXG4gICAgICogY2xhc3MgTXlDb21wb25lbnQge1xuICAgICAqICAgc29tZUV4cHJlc3Npb246IGFueSA9IGZhbHNlO1xuICAgICAqICAgY2FwdHVyZVN0YXJ0RXZlbnQoZXZlbnQ6IEFuaW1hdGlvblRyYW5zaXRpb25FdmVudCkge1xuICAgICAqICAgICAvLyB0aGUgdG9TdGF0ZSwgZnJvbVN0YXRlIGFuZCB0b3RhbFRpbWUgZGF0YSBpcyBhY2Nlc3NpYmxlIGZyb20gdGhlIGV2ZW50IHZhcmlhYmxlXG4gICAgICogICB9XG4gICAgICpcbiAgICAgKiAgIGNhcHR1cmVEb25lRXZlbnQoZXZlbnQ6IEFuaW1hdGlvblRyYW5zaXRpb25FdmVudCkge1xuICAgICAqICAgICAvLyB0aGUgdG9TdGF0ZSwgZnJvbVN0YXRlIGFuZCB0b3RhbFRpbWUgZGF0YSBpcyBhY2Nlc3NpYmxlIGZyb20gdGhlIGV2ZW50IHZhcmlhYmxlXG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gICAgICovXG4gICAgdmFyIEFuaW1hdGlvblRyYW5zaXRpb25FdmVudCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvblRyYW5zaXRpb25FdmVudChfYSkge1xuICAgICAgICAgICAgdmFyIGZyb21TdGF0ZSA9IF9hLmZyb21TdGF0ZSwgdG9TdGF0ZSA9IF9hLnRvU3RhdGUsIHRvdGFsVGltZSA9IF9hLnRvdGFsVGltZSwgcGhhc2VOYW1lID0gX2EucGhhc2VOYW1lO1xuICAgICAgICAgICAgdGhpcy5mcm9tU3RhdGUgPSBmcm9tU3RhdGU7XG4gICAgICAgICAgICB0aGlzLnRvU3RhdGUgPSB0b1N0YXRlO1xuICAgICAgICAgICAgdGhpcy50b3RhbFRpbWUgPSB0b3RhbFRpbWU7XG4gICAgICAgICAgICB0aGlzLnBoYXNlTmFtZSA9IHBoYXNlTmFtZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQW5pbWF0aW9uVHJhbnNpdGlvbkV2ZW50O1xuICAgIH0oKSk7XG5cbiAgICB2YXIgQW5pbWF0aW9uVHJhbnNpdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvblRyYW5zaXRpb24oX3BsYXllciwgX2Zyb21TdGF0ZSwgX3RvU3RhdGUsIF90b3RhbFRpbWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3BsYXllciA9IF9wbGF5ZXI7XG4gICAgICAgICAgICB0aGlzLl9mcm9tU3RhdGUgPSBfZnJvbVN0YXRlO1xuICAgICAgICAgICAgdGhpcy5fdG9TdGF0ZSA9IF90b1N0YXRlO1xuICAgICAgICAgICAgdGhpcy5fdG90YWxUaW1lID0gX3RvdGFsVGltZTtcbiAgICAgICAgfVxuICAgICAgICBBbmltYXRpb25UcmFuc2l0aW9uLnByb3RvdHlwZS5fY3JlYXRlRXZlbnQgPSBmdW5jdGlvbiAocGhhc2VOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFuaW1hdGlvblRyYW5zaXRpb25FdmVudCh7XG4gICAgICAgICAgICAgICAgZnJvbVN0YXRlOiB0aGlzLl9mcm9tU3RhdGUsXG4gICAgICAgICAgICAgICAgdG9TdGF0ZTogdGhpcy5fdG9TdGF0ZSxcbiAgICAgICAgICAgICAgICB0b3RhbFRpbWU6IHRoaXMuX3RvdGFsVGltZSxcbiAgICAgICAgICAgICAgICBwaGFzZU5hbWU6IHBoYXNlTmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIEFuaW1hdGlvblRyYW5zaXRpb24ucHJvdG90eXBlLm9uU3RhcnQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBldmVudCA9IHRoaXMuX2NyZWF0ZUV2ZW50KCdzdGFydCcpO1xuICAgICAgICAgICAgdGhpcy5fcGxheWVyLm9uU3RhcnQoZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FsbGJhY2soZXZlbnQpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgQW5pbWF0aW9uVHJhbnNpdGlvbi5wcm90b3R5cGUub25Eb25lID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgZXZlbnQgPSB0aGlzLl9jcmVhdGVFdmVudCgnZG9uZScpO1xuICAgICAgICAgICAgdGhpcy5fcGxheWVyLm9uRG9uZShmdW5jdGlvbiAoKSB7IHJldHVybiBjYWxsYmFjayhldmVudCk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gQW5pbWF0aW9uVHJhbnNpdGlvbjtcbiAgICB9KCkpO1xuXG4gICAgdmFyIERlYnVnRG9tUm9vdFJlbmRlcmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gRGVidWdEb21Sb290UmVuZGVyZXIoX2RlbGVnYXRlKSB7XG4gICAgICAgICAgICB0aGlzLl9kZWxlZ2F0ZSA9IF9kZWxlZ2F0ZTtcbiAgICAgICAgfVxuICAgICAgICBEZWJ1Z0RvbVJvb3RSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyQ29tcG9uZW50ID0gZnVuY3Rpb24gKGNvbXBvbmVudFByb3RvKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERlYnVnRG9tUmVuZGVyZXIodGhpcy5fZGVsZWdhdGUucmVuZGVyQ29tcG9uZW50KGNvbXBvbmVudFByb3RvKSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBEZWJ1Z0RvbVJvb3RSZW5kZXJlcjtcbiAgICB9KCkpO1xuICAgIHZhciBEZWJ1Z0RvbVJlbmRlcmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gRGVidWdEb21SZW5kZXJlcihfZGVsZWdhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2RlbGVnYXRlID0gX2RlbGVnYXRlO1xuICAgICAgICB9XG4gICAgICAgIERlYnVnRG9tUmVuZGVyZXIucHJvdG90eXBlLnNlbGVjdFJvb3RFbGVtZW50ID0gZnVuY3Rpb24gKHNlbGVjdG9yT3JOb2RlLCBkZWJ1Z0luZm8pIHtcbiAgICAgICAgICAgIHZhciBuYXRpdmVFbCA9IHRoaXMuX2RlbGVnYXRlLnNlbGVjdFJvb3RFbGVtZW50KHNlbGVjdG9yT3JOb2RlLCBkZWJ1Z0luZm8pO1xuICAgICAgICAgICAgdmFyIGRlYnVnRWwgPSBuZXcgRGVidWdFbGVtZW50KG5hdGl2ZUVsLCBudWxsLCBkZWJ1Z0luZm8pO1xuICAgICAgICAgICAgaW5kZXhEZWJ1Z05vZGUoZGVidWdFbCk7XG4gICAgICAgICAgICByZXR1cm4gbmF0aXZlRWw7XG4gICAgICAgIH07XG4gICAgICAgIERlYnVnRG9tUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAocGFyZW50RWxlbWVudCwgbmFtZSwgZGVidWdJbmZvKSB7XG4gICAgICAgICAgICB2YXIgbmF0aXZlRWwgPSB0aGlzLl9kZWxlZ2F0ZS5jcmVhdGVFbGVtZW50KHBhcmVudEVsZW1lbnQsIG5hbWUsIGRlYnVnSW5mbyk7XG4gICAgICAgICAgICB2YXIgZGVidWdFbCA9IG5ldyBEZWJ1Z0VsZW1lbnQobmF0aXZlRWwsIGdldERlYnVnTm9kZShwYXJlbnRFbGVtZW50KSwgZGVidWdJbmZvKTtcbiAgICAgICAgICAgIGRlYnVnRWwubmFtZSA9IG5hbWU7XG4gICAgICAgICAgICBpbmRleERlYnVnTm9kZShkZWJ1Z0VsKTtcbiAgICAgICAgICAgIHJldHVybiBuYXRpdmVFbDtcbiAgICAgICAgfTtcbiAgICAgICAgRGVidWdEb21SZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlVmlld1Jvb3QgPSBmdW5jdGlvbiAoaG9zdEVsZW1lbnQpIHsgcmV0dXJuIHRoaXMuX2RlbGVnYXRlLmNyZWF0ZVZpZXdSb290KGhvc3RFbGVtZW50KTsgfTtcbiAgICAgICAgRGVidWdEb21SZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlVGVtcGxhdGVBbmNob3IgPSBmdW5jdGlvbiAocGFyZW50RWxlbWVudCwgZGVidWdJbmZvKSB7XG4gICAgICAgICAgICB2YXIgY29tbWVudCA9IHRoaXMuX2RlbGVnYXRlLmNyZWF0ZVRlbXBsYXRlQW5jaG9yKHBhcmVudEVsZW1lbnQsIGRlYnVnSW5mbyk7XG4gICAgICAgICAgICB2YXIgZGVidWdFbCA9IG5ldyBEZWJ1Z05vZGUoY29tbWVudCwgZ2V0RGVidWdOb2RlKHBhcmVudEVsZW1lbnQpLCBkZWJ1Z0luZm8pO1xuICAgICAgICAgICAgaW5kZXhEZWJ1Z05vZGUoZGVidWdFbCk7XG4gICAgICAgICAgICByZXR1cm4gY29tbWVudDtcbiAgICAgICAgfTtcbiAgICAgICAgRGVidWdEb21SZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlVGV4dCA9IGZ1bmN0aW9uIChwYXJlbnRFbGVtZW50LCB2YWx1ZSwgZGVidWdJbmZvKSB7XG4gICAgICAgICAgICB2YXIgdGV4dCA9IHRoaXMuX2RlbGVnYXRlLmNyZWF0ZVRleHQocGFyZW50RWxlbWVudCwgdmFsdWUsIGRlYnVnSW5mbyk7XG4gICAgICAgICAgICB2YXIgZGVidWdFbCA9IG5ldyBEZWJ1Z05vZGUodGV4dCwgZ2V0RGVidWdOb2RlKHBhcmVudEVsZW1lbnQpLCBkZWJ1Z0luZm8pO1xuICAgICAgICAgICAgaW5kZXhEZWJ1Z05vZGUoZGVidWdFbCk7XG4gICAgICAgICAgICByZXR1cm4gdGV4dDtcbiAgICAgICAgfTtcbiAgICAgICAgRGVidWdEb21SZW5kZXJlci5wcm90b3R5cGUucHJvamVjdE5vZGVzID0gZnVuY3Rpb24gKHBhcmVudEVsZW1lbnQsIG5vZGVzKSB7XG4gICAgICAgICAgICB2YXIgZGVidWdQYXJlbnQgPSBnZXREZWJ1Z05vZGUocGFyZW50RWxlbWVudCk7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KGRlYnVnUGFyZW50KSAmJiBkZWJ1Z1BhcmVudCBpbnN0YW5jZW9mIERlYnVnRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBkZWJ1Z0VsZW1lbnRfMSA9IGRlYnVnUGFyZW50O1xuICAgICAgICAgICAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHsgZGVidWdFbGVtZW50XzEuYWRkQ2hpbGQoZ2V0RGVidWdOb2RlKG5vZGUpKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9kZWxlZ2F0ZS5wcm9qZWN0Tm9kZXMocGFyZW50RWxlbWVudCwgbm9kZXMpO1xuICAgICAgICB9O1xuICAgICAgICBEZWJ1Z0RvbVJlbmRlcmVyLnByb3RvdHlwZS5hdHRhY2hWaWV3QWZ0ZXIgPSBmdW5jdGlvbiAobm9kZSwgdmlld1Jvb3ROb2Rlcykge1xuICAgICAgICAgICAgdmFyIGRlYnVnTm9kZSA9IGdldERlYnVnTm9kZShub2RlKTtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoZGVidWdOb2RlKSkge1xuICAgICAgICAgICAgICAgIHZhciBkZWJ1Z1BhcmVudCA9IGRlYnVnTm9kZS5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgaWYgKHZpZXdSb290Tm9kZXMubGVuZ3RoID4gMCAmJiBpc1ByZXNlbnQoZGVidWdQYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWJ1Z1ZpZXdSb290Tm9kZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdmlld1Jvb3ROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChyb290Tm9kZSkgeyByZXR1cm4gZGVidWdWaWV3Um9vdE5vZGVzLnB1c2goZ2V0RGVidWdOb2RlKHJvb3ROb2RlKSk7IH0pO1xuICAgICAgICAgICAgICAgICAgICBkZWJ1Z1BhcmVudC5pbnNlcnRDaGlsZHJlbkFmdGVyKGRlYnVnTm9kZSwgZGVidWdWaWV3Um9vdE5vZGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9kZWxlZ2F0ZS5hdHRhY2hWaWV3QWZ0ZXIobm9kZSwgdmlld1Jvb3ROb2Rlcyk7XG4gICAgICAgIH07XG4gICAgICAgIERlYnVnRG9tUmVuZGVyZXIucHJvdG90eXBlLmRldGFjaFZpZXcgPSBmdW5jdGlvbiAodmlld1Jvb3ROb2Rlcykge1xuICAgICAgICAgICAgdmlld1Jvb3ROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlYnVnTm9kZSA9IGdldERlYnVnTm9kZShub2RlKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KGRlYnVnTm9kZSkgJiYgaXNQcmVzZW50KGRlYnVnTm9kZS5wYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnTm9kZS5wYXJlbnQucmVtb3ZlQ2hpbGQoZGVidWdOb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX2RlbGVnYXRlLmRldGFjaFZpZXcodmlld1Jvb3ROb2Rlcyk7XG4gICAgICAgIH07XG4gICAgICAgIERlYnVnRG9tUmVuZGVyZXIucHJvdG90eXBlLmRlc3Ryb3lWaWV3ID0gZnVuY3Rpb24gKGhvc3RFbGVtZW50LCB2aWV3QWxsTm9kZXMpIHtcbiAgICAgICAgICAgIHZpZXdBbGxOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7IHJlbW92ZURlYnVnTm9kZUZyb21JbmRleChnZXREZWJ1Z05vZGUobm9kZSkpOyB9KTtcbiAgICAgICAgICAgIHRoaXMuX2RlbGVnYXRlLmRlc3Ryb3lWaWV3KGhvc3RFbGVtZW50LCB2aWV3QWxsTm9kZXMpO1xuICAgICAgICB9O1xuICAgICAgICBEZWJ1Z0RvbVJlbmRlcmVyLnByb3RvdHlwZS5saXN0ZW4gPSBmdW5jdGlvbiAocmVuZGVyRWxlbWVudCwgbmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBkZWJ1Z0VsID0gZ2V0RGVidWdOb2RlKHJlbmRlckVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChkZWJ1Z0VsKSkge1xuICAgICAgICAgICAgICAgIGRlYnVnRWwubGlzdGVuZXJzLnB1c2gobmV3IEV2ZW50TGlzdGVuZXIobmFtZSwgY2FsbGJhY2spKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWxlZ2F0ZS5saXN0ZW4ocmVuZGVyRWxlbWVudCwgbmFtZSwgY2FsbGJhY2spO1xuICAgICAgICB9O1xuICAgICAgICBEZWJ1Z0RvbVJlbmRlcmVyLnByb3RvdHlwZS5saXN0ZW5HbG9iYWwgPSBmdW5jdGlvbiAodGFyZ2V0LCBuYW1lLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlbGVnYXRlLmxpc3Rlbkdsb2JhbCh0YXJnZXQsIG5hbWUsIGNhbGxiYWNrKTtcbiAgICAgICAgfTtcbiAgICAgICAgRGVidWdEb21SZW5kZXJlci5wcm90b3R5cGUuc2V0RWxlbWVudFByb3BlcnR5ID0gZnVuY3Rpb24gKHJlbmRlckVsZW1lbnQsIHByb3BlcnR5TmFtZSwgcHJvcGVydHlWYWx1ZSkge1xuICAgICAgICAgICAgdmFyIGRlYnVnRWwgPSBnZXREZWJ1Z05vZGUocmVuZGVyRWxlbWVudCk7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KGRlYnVnRWwpICYmIGRlYnVnRWwgaW5zdGFuY2VvZiBEZWJ1Z0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBkZWJ1Z0VsLnByb3BlcnRpZXNbcHJvcGVydHlOYW1lXSA9IHByb3BlcnR5VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9kZWxlZ2F0ZS5zZXRFbGVtZW50UHJvcGVydHkocmVuZGVyRWxlbWVudCwgcHJvcGVydHlOYW1lLCBwcm9wZXJ0eVZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgRGVidWdEb21SZW5kZXJlci5wcm90b3R5cGUuc2V0RWxlbWVudEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChyZW5kZXJFbGVtZW50LCBhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVWYWx1ZSkge1xuICAgICAgICAgICAgdmFyIGRlYnVnRWwgPSBnZXREZWJ1Z05vZGUocmVuZGVyRWxlbWVudCk7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KGRlYnVnRWwpICYmIGRlYnVnRWwgaW5zdGFuY2VvZiBEZWJ1Z0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBkZWJ1Z0VsLmF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV0gPSBhdHRyaWJ1dGVWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2RlbGVnYXRlLnNldEVsZW1lbnRBdHRyaWJ1dGUocmVuZGVyRWxlbWVudCwgYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICBEZWJ1Z0RvbVJlbmRlcmVyLnByb3RvdHlwZS5zZXRCaW5kaW5nRGVidWdJbmZvID0gZnVuY3Rpb24gKHJlbmRlckVsZW1lbnQsIHByb3BlcnR5TmFtZSwgcHJvcGVydHlWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fZGVsZWdhdGUuc2V0QmluZGluZ0RlYnVnSW5mbyhyZW5kZXJFbGVtZW50LCBwcm9wZXJ0eU5hbWUsIHByb3BlcnR5VmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICBEZWJ1Z0RvbVJlbmRlcmVyLnByb3RvdHlwZS5zZXRFbGVtZW50Q2xhc3MgPSBmdW5jdGlvbiAocmVuZGVyRWxlbWVudCwgY2xhc3NOYW1lLCBpc0FkZCkge1xuICAgICAgICAgICAgdmFyIGRlYnVnRWwgPSBnZXREZWJ1Z05vZGUocmVuZGVyRWxlbWVudCk7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KGRlYnVnRWwpICYmIGRlYnVnRWwgaW5zdGFuY2VvZiBEZWJ1Z0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBkZWJ1Z0VsLmNsYXNzZXNbY2xhc3NOYW1lXSA9IGlzQWRkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fZGVsZWdhdGUuc2V0RWxlbWVudENsYXNzKHJlbmRlckVsZW1lbnQsIGNsYXNzTmFtZSwgaXNBZGQpO1xuICAgICAgICB9O1xuICAgICAgICBEZWJ1Z0RvbVJlbmRlcmVyLnByb3RvdHlwZS5zZXRFbGVtZW50U3R5bGUgPSBmdW5jdGlvbiAocmVuZGVyRWxlbWVudCwgc3R5bGVOYW1lLCBzdHlsZVZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgZGVidWdFbCA9IGdldERlYnVnTm9kZShyZW5kZXJFbGVtZW50KTtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoZGVidWdFbCkgJiYgZGVidWdFbCBpbnN0YW5jZW9mIERlYnVnRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGRlYnVnRWwuc3R5bGVzW3N0eWxlTmFtZV0gPSBzdHlsZVZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fZGVsZWdhdGUuc2V0RWxlbWVudFN0eWxlKHJlbmRlckVsZW1lbnQsIHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIERlYnVnRG9tUmVuZGVyZXIucHJvdG90eXBlLmludm9rZUVsZW1lbnRNZXRob2QgPSBmdW5jdGlvbiAocmVuZGVyRWxlbWVudCwgbWV0aG9kTmFtZSwgYXJncykge1xuICAgICAgICAgICAgdGhpcy5fZGVsZWdhdGUuaW52b2tlRWxlbWVudE1ldGhvZChyZW5kZXJFbGVtZW50LCBtZXRob2ROYW1lLCBhcmdzKTtcbiAgICAgICAgfTtcbiAgICAgICAgRGVidWdEb21SZW5kZXJlci5wcm90b3R5cGUuc2V0VGV4dCA9IGZ1bmN0aW9uIChyZW5kZXJOb2RlLCB0ZXh0KSB7IHRoaXMuX2RlbGVnYXRlLnNldFRleHQocmVuZGVyTm9kZSwgdGV4dCk7IH07XG4gICAgICAgIERlYnVnRG9tUmVuZGVyZXIucHJvdG90eXBlLmFuaW1hdGUgPSBmdW5jdGlvbiAoZWxlbWVudCwgc3RhcnRpbmdTdHlsZXMsIGtleWZyYW1lcywgZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWxlZ2F0ZS5hbmltYXRlKGVsZW1lbnQsIHN0YXJ0aW5nU3R5bGVzLCBrZXlmcmFtZXMsIGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIERlYnVnRG9tUmVuZGVyZXI7XG4gICAgfSgpKTtcblxuICAgIHZhciBTdGF0aWNOb2RlRGVidWdJbmZvID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gU3RhdGljTm9kZURlYnVnSW5mbyhwcm92aWRlclRva2VucywgY29tcG9uZW50VG9rZW4sIHJlZlRva2Vucykge1xuICAgICAgICAgICAgdGhpcy5wcm92aWRlclRva2VucyA9IHByb3ZpZGVyVG9rZW5zO1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRUb2tlbiA9IGNvbXBvbmVudFRva2VuO1xuICAgICAgICAgICAgdGhpcy5yZWZUb2tlbnMgPSByZWZUb2tlbnM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFN0YXRpY05vZGVEZWJ1Z0luZm87XG4gICAgfSgpKTtcbiAgICB2YXIgRGVidWdDb250ZXh0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gRGVidWdDb250ZXh0KF92aWV3LCBfbm9kZUluZGV4LCBfdHBsUm93LCBfdHBsQ29sKSB7XG4gICAgICAgICAgICB0aGlzLl92aWV3ID0gX3ZpZXc7XG4gICAgICAgICAgICB0aGlzLl9ub2RlSW5kZXggPSBfbm9kZUluZGV4O1xuICAgICAgICAgICAgdGhpcy5fdHBsUm93ID0gX3RwbFJvdztcbiAgICAgICAgICAgIHRoaXMuX3RwbENvbCA9IF90cGxDb2w7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERlYnVnQ29udGV4dC5wcm90b3R5cGUsIFwiX3N0YXRpY05vZGVJbmZvXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5fbm9kZUluZGV4KSA/IHRoaXMuX3ZpZXcuc3RhdGljTm9kZURlYnVnSW5mb3NbdGhpcy5fbm9kZUluZGV4XSA6IG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERlYnVnQ29udGV4dC5wcm90b3R5cGUsIFwiY29udGV4dFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3ZpZXcuY29udGV4dDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWJ1Z0NvbnRleHQucHJvdG90eXBlLCBcImNvbXBvbmVudFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhdGljTm9kZUluZm8gPSB0aGlzLl9zdGF0aWNOb2RlSW5mbztcbiAgICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KHN0YXRpY05vZGVJbmZvKSAmJiBpc1ByZXNlbnQoc3RhdGljTm9kZUluZm8uY29tcG9uZW50VG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmluamVjdG9yLmdldChzdGF0aWNOb2RlSW5mby5jb21wb25lbnRUb2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWJ1Z0NvbnRleHQucHJvdG90eXBlLCBcImNvbXBvbmVudFJlbmRlckVsZW1lbnRcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbXBvbmVudFZpZXcgPSB0aGlzLl92aWV3O1xuICAgICAgICAgICAgICAgIHdoaWxlIChpc1ByZXNlbnQoY29tcG9uZW50Vmlldy5kZWNsYXJhdGlvbkFwcEVsZW1lbnQpICYmXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudFZpZXcudHlwZSAhPT0gVmlld1R5cGUuQ09NUE9ORU5UKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudFZpZXcgPSBjb21wb25lbnRWaWV3LmRlY2xhcmF0aW9uQXBwRWxlbWVudC5wYXJlbnRWaWV3O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaXNQcmVzZW50KGNvbXBvbmVudFZpZXcuZGVjbGFyYXRpb25BcHBFbGVtZW50KSA/XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudFZpZXcuZGVjbGFyYXRpb25BcHBFbGVtZW50Lm5hdGl2ZUVsZW1lbnQgOlxuICAgICAgICAgICAgICAgICAgICBudWxsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWJ1Z0NvbnRleHQucHJvdG90eXBlLCBcImluamVjdG9yXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fdmlldy5pbmplY3Rvcih0aGlzLl9ub2RlSW5kZXgpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERlYnVnQ29udGV4dC5wcm90b3R5cGUsIFwicmVuZGVyTm9kZVwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuX25vZGVJbmRleCkgJiYgdGhpcy5fdmlldy5hbGxOb2Rlcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdmlldy5hbGxOb2Rlc1t0aGlzLl9ub2RlSW5kZXhdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWJ1Z0NvbnRleHQucHJvdG90eXBlLCBcInByb3ZpZGVyVG9rZW5zXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBzdGF0aWNOb2RlSW5mbyA9IHRoaXMuX3N0YXRpY05vZGVJbmZvO1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1ByZXNlbnQoc3RhdGljTm9kZUluZm8pID8gc3RhdGljTm9kZUluZm8ucHJvdmlkZXJUb2tlbnMgOiBudWxsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWJ1Z0NvbnRleHQucHJvdG90eXBlLCBcInNvdXJjZVwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdmlldy5jb21wb25lbnRUeXBlLnRlbXBsYXRlVXJsICsgXCI6XCIgKyB0aGlzLl90cGxSb3cgKyBcIjpcIiArIHRoaXMuX3RwbENvbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVidWdDb250ZXh0LnByb3RvdHlwZSwgXCJyZWZlcmVuY2VzXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdmFyIHZhclZhbHVlcyA9IHt9O1xuICAgICAgICAgICAgICAgIHZhciBzdGF0aWNOb2RlSW5mbyA9IHRoaXMuX3N0YXRpY05vZGVJbmZvO1xuICAgICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoc3RhdGljTm9kZUluZm8pKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWZzID0gc3RhdGljTm9kZUluZm8ucmVmVG9rZW5zO1xuICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhyZWZzKS5mb3JFYWNoKGZ1bmN0aW9uIChyZWZOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVmVG9rZW4gPSByZWZzW3JlZk5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhclZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQmxhbmsocmVmVG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyVmFsdWUgPSBfdGhpcy5fdmlldy5hbGxOb2RlcyA/IF90aGlzLl92aWV3LmFsbE5vZGVzW190aGlzLl9ub2RlSW5kZXhdIDogbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhclZhbHVlID0gX3RoaXMuX3ZpZXcuaW5qZWN0b3JHZXQocmVmVG9rZW4sIF90aGlzLl9ub2RlSW5kZXgsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyVmFsdWVzW3JlZk5hbWVdID0gdmFyVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFyVmFsdWVzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBEZWJ1Z0NvbnRleHQ7XG4gICAgfSgpKTtcblxuICAgIHZhciBWaWV3QW5pbWF0aW9uTWFwID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gVmlld0FuaW1hdGlvbk1hcCgpIHtcbiAgICAgICAgICAgIHRoaXMuX21hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHRoaXMuX2FsbFBsYXllcnMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBWaWV3QW5pbWF0aW9uTWFwLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gKGVsZW1lbnQsIGFuaW1hdGlvbk5hbWUpIHtcbiAgICAgICAgICAgIHZhciBwbGF5ZXJzQnlBbmltYXRpb24gPSB0aGlzLl9tYXAuZ2V0KGVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChwbGF5ZXJzQnlBbmltYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBsYXllcnNCeUFuaW1hdGlvblthbmltYXRpb25OYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgVmlld0FuaW1hdGlvbk1hcC5wcm90b3R5cGUuZmluZEFsbFBsYXllcnNCeUVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIGVsID0gdGhpcy5fbWFwLmdldChlbGVtZW50KTtcbiAgICAgICAgICAgIHJldHVybiBlbCA/IE9iamVjdC5rZXlzKGVsKS5tYXAoZnVuY3Rpb24gKGspIHsgcmV0dXJuIGVsW2tdOyB9KSA6IFtdO1xuICAgICAgICB9O1xuICAgICAgICBWaWV3QW5pbWF0aW9uTWFwLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoZWxlbWVudCwgYW5pbWF0aW9uTmFtZSwgcGxheWVyKSB7XG4gICAgICAgICAgICB2YXIgcGxheWVyc0J5QW5pbWF0aW9uID0gdGhpcy5fbWFwLmdldChlbGVtZW50KTtcbiAgICAgICAgICAgIGlmICghaXNQcmVzZW50KHBsYXllcnNCeUFuaW1hdGlvbikpIHtcbiAgICAgICAgICAgICAgICBwbGF5ZXJzQnlBbmltYXRpb24gPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBleGlzdGluZ0VudHJ5ID0gcGxheWVyc0J5QW5pbWF0aW9uW2FuaW1hdGlvbk5hbWVdO1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChleGlzdGluZ0VudHJ5KSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlKGVsZW1lbnQsIGFuaW1hdGlvbk5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGxheWVyc0J5QW5pbWF0aW9uW2FuaW1hdGlvbk5hbWVdID0gcGxheWVyO1xuICAgICAgICAgICAgdGhpcy5fYWxsUGxheWVycy5wdXNoKHBsYXllcik7XG4gICAgICAgICAgICB0aGlzLl9tYXAuc2V0KGVsZW1lbnQsIHBsYXllcnNCeUFuaW1hdGlvbik7XG4gICAgICAgIH07XG4gICAgICAgIFZpZXdBbmltYXRpb25NYXAucHJvdG90eXBlLmdldEFsbFBsYXllcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9hbGxQbGF5ZXJzOyB9O1xuICAgICAgICBWaWV3QW5pbWF0aW9uTWFwLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoZWxlbWVudCwgYW5pbWF0aW9uTmFtZSkge1xuICAgICAgICAgICAgdmFyIHBsYXllcnNCeUFuaW1hdGlvbiA9IHRoaXMuX21hcC5nZXQoZWxlbWVudCk7XG4gICAgICAgICAgICBpZiAocGxheWVyc0J5QW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBsYXllciA9IHBsYXllcnNCeUFuaW1hdGlvblthbmltYXRpb25OYW1lXTtcbiAgICAgICAgICAgICAgICBkZWxldGUgcGxheWVyc0J5QW5pbWF0aW9uW2FuaW1hdGlvbk5hbWVdO1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuX2FsbFBsYXllcnMuaW5kZXhPZihwbGF5ZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2FsbFBsYXllcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMocGxheWVyc0J5QW5pbWF0aW9uKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWFwLmRlbGV0ZShlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBWaWV3QW5pbWF0aW9uTWFwO1xuICAgIH0oKSk7XG5cbiAgICB2YXIgQW5pbWF0aW9uVmlld0NvbnRleHQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBBbmltYXRpb25WaWV3Q29udGV4dCgpIHtcbiAgICAgICAgICAgIHRoaXMuX3BsYXllcnMgPSBuZXcgVmlld0FuaW1hdGlvbk1hcCgpO1xuICAgICAgICB9XG4gICAgICAgIEFuaW1hdGlvblZpZXdDb250ZXh0LnByb3RvdHlwZS5vbkFsbEFjdGl2ZUFuaW1hdGlvbnNEb25lID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgYWN0aXZlQW5pbWF0aW9uUGxheWVycyA9IHRoaXMuX3BsYXllcnMuZ2V0QWxsUGxheWVycygpO1xuICAgICAgICAgICAgLy8gd2UgY2hlY2sgZm9yIHRoZSBsZW5ndGggdG8gYXZvaWQgaGF2aW5nIEdyb3VwQW5pbWF0aW9uUGxheWVyXG4gICAgICAgICAgICAvLyBpc3N1ZSBhbiB1bm5lY2Vzc2FyeSBtaWNyb3Rhc2sgd2hlbiB6ZXJvIHBsYXllcnMgYXJlIHBhc3NlZCBpblxuICAgICAgICAgICAgaWYgKGFjdGl2ZUFuaW1hdGlvblBsYXllcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbmV3IEFuaW1hdGlvbkdyb3VwUGxheWVyKGFjdGl2ZUFuaW1hdGlvblBsYXllcnMpLm9uRG9uZShmdW5jdGlvbiAoKSB7IHJldHVybiBjYWxsYmFjaygpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEFuaW1hdGlvblZpZXdDb250ZXh0LnByb3RvdHlwZS5xdWV1ZUFuaW1hdGlvbiA9IGZ1bmN0aW9uIChlbGVtZW50LCBhbmltYXRpb25OYW1lLCBwbGF5ZXIpIHtcbiAgICAgICAgICAgIHF1ZXVlQW5pbWF0aW9uR2xvYmFsbHkocGxheWVyKTtcbiAgICAgICAgICAgIHRoaXMuX3BsYXllcnMuc2V0KGVsZW1lbnQsIGFuaW1hdGlvbk5hbWUsIHBsYXllcik7XG4gICAgICAgIH07XG4gICAgICAgIEFuaW1hdGlvblZpZXdDb250ZXh0LnByb3RvdHlwZS5jYW5jZWxBY3RpdmVBbmltYXRpb24gPSBmdW5jdGlvbiAoZWxlbWVudCwgYW5pbWF0aW9uTmFtZSwgcmVtb3ZlQWxsQW5pbWF0aW9ucykge1xuICAgICAgICAgICAgaWYgKHJlbW92ZUFsbEFuaW1hdGlvbnMgPT09IHZvaWQgMCkgeyByZW1vdmVBbGxBbmltYXRpb25zID0gZmFsc2U7IH1cbiAgICAgICAgICAgIGlmIChyZW1vdmVBbGxBbmltYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGxheWVycy5maW5kQWxsUGxheWVyc0J5RWxlbWVudChlbGVtZW50KS5mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHsgcmV0dXJuIHBsYXllci5kZXN0cm95KCk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHBsYXllciA9IHRoaXMuX3BsYXllcnMuZmluZChlbGVtZW50LCBhbmltYXRpb25OYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAocGxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHBsYXllci5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gQW5pbWF0aW9uVmlld0NvbnRleHQ7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDE1ID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgdmFyIF9VTkRFRklORUQkMSA9IG5ldyBPYmplY3QoKTtcbiAgICB2YXIgRWxlbWVudEluamVjdG9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDE1KEVsZW1lbnRJbmplY3RvciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gRWxlbWVudEluamVjdG9yKF92aWV3LCBfbm9kZUluZGV4KSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX3ZpZXcgPSBfdmlldztcbiAgICAgICAgICAgIHRoaXMuX25vZGVJbmRleCA9IF9ub2RlSW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgRWxlbWVudEluamVjdG9yLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodG9rZW4sIG5vdEZvdW5kVmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChub3RGb3VuZFZhbHVlID09PSB2b2lkIDApIHsgbm90Rm91bmRWYWx1ZSA9IFRIUk9XX0lGX05PVF9GT1VORDsgfVxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IF9VTkRFRklORUQkMTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IF9VTkRFRklORUQkMSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuX3ZpZXcuaW5qZWN0b3JHZXQodG9rZW4sIHRoaXMuX25vZGVJbmRleCwgX1VOREVGSU5FRCQxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IF9VTkRFRklORUQkMSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuX3ZpZXcucGFyZW50SW5qZWN0b3IuZ2V0KHRva2VuLCBub3RGb3VuZFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBFbGVtZW50SW5qZWN0b3I7XG4gICAgfShJbmplY3RvcikpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkMTQgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICB2YXIgX3Njb3BlX2NoZWNrID0gd3RmQ3JlYXRlU2NvcGUoXCJBcHBWaWV3I2NoZWNrKGFzY2lpIGlkKVwiKTtcbiAgICAvKipcbiAgICAgKiBDb3N0IG9mIG1ha2luZyBvYmplY3RzOiBodHRwOi8vanNwZXJmLmNvbS9pbnN0YW50aWF0ZS1zaXplLW9mLW9iamVjdFxuICAgICAqXG4gICAgICovXG4gICAgdmFyIEFwcFZpZXcgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBBcHBWaWV3KGNsYXp6LCBjb21wb25lbnRUeXBlLCB0eXBlLCB2aWV3VXRpbHMsIHBhcmVudEluamVjdG9yLCBkZWNsYXJhdGlvbkFwcEVsZW1lbnQsIGNkTW9kZSkge1xuICAgICAgICAgICAgdGhpcy5jbGF6eiA9IGNsYXp6O1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRUeXBlID0gY29tcG9uZW50VHlwZTtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgICAgICB0aGlzLnZpZXdVdGlscyA9IHZpZXdVdGlscztcbiAgICAgICAgICAgIHRoaXMucGFyZW50SW5qZWN0b3IgPSBwYXJlbnRJbmplY3RvcjtcbiAgICAgICAgICAgIHRoaXMuZGVjbGFyYXRpb25BcHBFbGVtZW50ID0gZGVjbGFyYXRpb25BcHBFbGVtZW50O1xuICAgICAgICAgICAgdGhpcy5jZE1vZGUgPSBjZE1vZGU7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRDaGlsZHJlbiA9IFtdO1xuICAgICAgICAgICAgdGhpcy52aWV3Q2hpbGRyZW4gPSBbXTtcbiAgICAgICAgICAgIHRoaXMudmlld0NvbnRhaW5lckVsZW1lbnQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5udW1iZXJPZkNoZWNrcyA9IDA7XG4gICAgICAgICAgICB0aGlzLnJlZiA9IG5ldyBWaWV3UmVmXyh0aGlzKTtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBWaWV3VHlwZS5DT01QT05FTlQgfHwgdHlwZSA9PT0gVmlld1R5cGUuSE9TVCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIgPSB2aWV3VXRpbHMucmVuZGVyQ29tcG9uZW50KGNvbXBvbmVudFR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlciA9IGRlY2xhcmF0aW9uQXBwRWxlbWVudC5wYXJlbnRWaWV3LnJlbmRlcmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcHBWaWV3LnByb3RvdHlwZSwgXCJhbmltYXRpb25Db250ZXh0XCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fYW5pbWF0aW9uQ29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hbmltYXRpb25Db250ZXh0ID0gbmV3IEFuaW1hdGlvblZpZXdDb250ZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9hbmltYXRpb25Db250ZXh0O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcHBWaWV3LnByb3RvdHlwZSwgXCJkZXN0cm95ZWRcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmNkTW9kZSA9PT0gQ2hhbmdlRGV0ZWN0b3JTdGF0dXMuRGVzdHJveWVkOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgQXBwVmlldy5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKGNvbnRleHQsIGdpdmVuUHJvamVjdGFibGVOb2Rlcywgcm9vdFNlbGVjdG9yT3JOb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAgICAgdmFyIHByb2plY3RhYmxlTm9kZXM7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgVmlld1R5cGUuQ09NUE9ORU5UOlxuICAgICAgICAgICAgICAgICAgICBwcm9qZWN0YWJsZU5vZGVzID0gZW5zdXJlU2xvdENvdW50KGdpdmVuUHJvamVjdGFibGVOb2RlcywgdGhpcy5jb21wb25lbnRUeXBlLnNsb3RDb3VudCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgVmlld1R5cGUuRU1CRURERUQ6XG4gICAgICAgICAgICAgICAgICAgIHByb2plY3RhYmxlTm9kZXMgPSB0aGlzLmRlY2xhcmF0aW9uQXBwRWxlbWVudC5wYXJlbnRWaWV3LnByb2plY3RhYmxlTm9kZXM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgVmlld1R5cGUuSE9TVDpcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90ZTogRG9uJ3QgZW5zdXJlIHRoZSBzbG90IGNvdW50IGZvciB0aGUgcHJvamVjdGFibGVOb2RlcyBhcyB3ZSBzdG9yZVxuICAgICAgICAgICAgICAgICAgICAvLyB0aGVtIG9ubHkgZm9yIHRoZSBjb250YWluZWQgY29tcG9uZW50IHZpZXcgKHdoaWNoIHdpbGwgbGF0ZXIgY2hlY2sgdGhlIHNsb3QgY291bnQuLi4pXG4gICAgICAgICAgICAgICAgICAgIHByb2plY3RhYmxlTm9kZXMgPSBnaXZlblByb2plY3RhYmxlTm9kZXM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5faGFzRXh0ZXJuYWxIb3N0RWxlbWVudCA9IGlzUHJlc2VudChyb290U2VsZWN0b3JPck5vZGUpO1xuICAgICAgICAgICAgdGhpcy5wcm9qZWN0YWJsZU5vZGVzID0gcHJvamVjdGFibGVOb2RlcztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUludGVybmFsKHJvb3RTZWxlY3Rvck9yTm9kZSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPdmVyd3JpdHRlbiBieSBpbXBsZW1lbnRhdGlvbnMuXG4gICAgICAgICAqIFJldHVybnMgdGhlIEFwcEVsZW1lbnQgZm9yIHRoZSBob3N0IGVsZW1lbnQgZm9yIFZpZXdUeXBlLkhPU1QuXG4gICAgICAgICAqL1xuICAgICAgICBBcHBWaWV3LnByb3RvdHlwZS5jcmVhdGVJbnRlcm5hbCA9IGZ1bmN0aW9uIChyb290U2VsZWN0b3JPck5vZGUpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgICAgIEFwcFZpZXcucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAocm9vdE5vZGVzT3JBcHBFbGVtZW50cywgYWxsTm9kZXMsIGRpc3Bvc2FibGVzLCBzdWJzY3JpcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLnJvb3ROb2Rlc09yQXBwRWxlbWVudHMgPSByb290Tm9kZXNPckFwcEVsZW1lbnRzO1xuICAgICAgICAgICAgdGhpcy5hbGxOb2RlcyA9IGFsbE5vZGVzO1xuICAgICAgICAgICAgdGhpcy5kaXNwb3NhYmxlcyA9IGRpc3Bvc2FibGVzO1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gc3Vic2NyaXB0aW9ucztcbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09IFZpZXdUeXBlLkNPTVBPTkVOVCkge1xuICAgICAgICAgICAgICAgIC8vIE5vdGU6IHRoZSByZW5kZXIgbm9kZXMgaGF2ZSBiZWVuIGF0dGFjaGVkIHRvIHRoZWlyIGhvc3QgZWxlbWVudFxuICAgICAgICAgICAgICAgIC8vIGluIHRoZSBWaWV3RmFjdG9yeSBhbHJlYWR5LlxuICAgICAgICAgICAgICAgIHRoaXMuZGVjbGFyYXRpb25BcHBFbGVtZW50LnBhcmVudFZpZXcudmlld0NoaWxkcmVuLnB1c2godGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXJ0eVBhcmVudFF1ZXJpZXNJbnRlcm5hbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBBcHBWaWV3LnByb3RvdHlwZS5zZWxlY3RPckNyZWF0ZUhvc3RFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnROYW1lLCByb290U2VsZWN0b3JPck5vZGUsIGRlYnVnSW5mbykge1xuICAgICAgICAgICAgdmFyIGhvc3RFbGVtZW50O1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChyb290U2VsZWN0b3JPck5vZGUpKSB7XG4gICAgICAgICAgICAgICAgaG9zdEVsZW1lbnQgPSB0aGlzLnJlbmRlcmVyLnNlbGVjdFJvb3RFbGVtZW50KHJvb3RTZWxlY3Rvck9yTm9kZSwgZGVidWdJbmZvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGhvc3RFbGVtZW50ID0gdGhpcy5yZW5kZXJlci5jcmVhdGVFbGVtZW50KG51bGwsIGVsZW1lbnROYW1lLCBkZWJ1Z0luZm8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhvc3RFbGVtZW50O1xuICAgICAgICB9O1xuICAgICAgICBBcHBWaWV3LnByb3RvdHlwZS5pbmplY3RvckdldCA9IGZ1bmN0aW9uICh0b2tlbiwgbm9kZUluZGV4LCBub3RGb3VuZFJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5qZWN0b3JHZXRJbnRlcm5hbCh0b2tlbiwgbm9kZUluZGV4LCBub3RGb3VuZFJlc3VsdCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPdmVyd3JpdHRlbiBieSBpbXBsZW1lbnRhdGlvbnNcbiAgICAgICAgICovXG4gICAgICAgIEFwcFZpZXcucHJvdG90eXBlLmluamVjdG9yR2V0SW50ZXJuYWwgPSBmdW5jdGlvbiAodG9rZW4sIG5vZGVJbmRleCwgbm90Rm91bmRSZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiBub3RGb3VuZFJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgQXBwVmlldy5wcm90b3R5cGUuaW5qZWN0b3IgPSBmdW5jdGlvbiAobm9kZUluZGV4KSB7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KG5vZGVJbmRleCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEVsZW1lbnRJbmplY3Rvcih0aGlzLCBub2RlSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50SW5qZWN0b3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEFwcFZpZXcucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faGFzRXh0ZXJuYWxIb3N0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuZGV0YWNoVmlldyh0aGlzLmZsYXRSb290Tm9kZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNQcmVzZW50KHRoaXMudmlld0NvbnRhaW5lckVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3Q29udGFpbmVyRWxlbWVudC5kZXRhY2hWaWV3KHRoaXMudmlld0NvbnRhaW5lckVsZW1lbnQubmVzdGVkVmlld3MuaW5kZXhPZih0aGlzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9kZXN0cm95UmVjdXJzZSgpO1xuICAgICAgICB9O1xuICAgICAgICBBcHBWaWV3LnByb3RvdHlwZS5fZGVzdHJveVJlY3Vyc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jZE1vZGUgPT09IENoYW5nZURldGVjdG9yU3RhdHVzLkRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY29udGVudENoaWxkcmVuO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuW2ldLl9kZXN0cm95UmVjdXJzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hpbGRyZW4gPSB0aGlzLnZpZXdDaGlsZHJlbjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbltpXS5fZGVzdHJveVJlY3Vyc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGVzdHJveUxvY2FsKCk7XG4gICAgICAgICAgICB0aGlzLmNkTW9kZSA9IENoYW5nZURldGVjdG9yU3RhdHVzLkRlc3Ryb3llZDtcbiAgICAgICAgfTtcbiAgICAgICAgQXBwVmlldy5wcm90b3R5cGUuZGVzdHJveUxvY2FsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBob3N0RWxlbWVudCA9IHRoaXMudHlwZSA9PT0gVmlld1R5cGUuQ09NUE9ORU5UID8gdGhpcy5kZWNsYXJhdGlvbkFwcEVsZW1lbnQubmF0aXZlRWxlbWVudCA6IG51bGw7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGlzcG9zYWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3Bvc2FibGVzW2ldKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc3Vic2NyaXB0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uc1tpXS51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kZXN0cm95SW50ZXJuYWwoKTtcbiAgICAgICAgICAgIHRoaXMuZGlydHlQYXJlbnRRdWVyaWVzSW50ZXJuYWwoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9hbmltYXRpb25Db250ZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYW5pbWF0aW9uQ29udGV4dC5vbkFsbEFjdGl2ZUFuaW1hdGlvbnNEb25lKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnJlbmRlcmVyLmRlc3Ryb3lWaWV3KGhvc3RFbGVtZW50LCBfdGhpcy5hbGxOb2Rlcyk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5kZXN0cm95Vmlldyhob3N0RWxlbWVudCwgdGhpcy5hbGxOb2Rlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPdmVyd3JpdHRlbiBieSBpbXBsZW1lbnRhdGlvbnNcbiAgICAgICAgICovXG4gICAgICAgIEFwcFZpZXcucHJvdG90eXBlLmRlc3Ryb3lJbnRlcm5hbCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE92ZXJ3cml0dGVuIGJ5IGltcGxlbWVudGF0aW9uc1xuICAgICAgICAgKi9cbiAgICAgICAgQXBwVmlldy5wcm90b3R5cGUuZGV0YWNoSW50ZXJuYWwgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIEFwcFZpZXcucHJvdG90eXBlLmRldGFjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmRldGFjaEludGVybmFsKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fYW5pbWF0aW9uQ29udGV4dCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FuaW1hdGlvbkNvbnRleHQub25BbGxBY3RpdmVBbmltYXRpb25zRG9uZShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5yZW5kZXJlci5kZXRhY2hWaWV3KF90aGlzLmZsYXRSb290Tm9kZXMpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuZGV0YWNoVmlldyh0aGlzLmZsYXRSb290Tm9kZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXBwVmlldy5wcm90b3R5cGUsIFwiY2hhbmdlRGV0ZWN0b3JSZWZcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnJlZjsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcHBWaWV3LnByb3RvdHlwZSwgXCJwYXJlbnRcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLmRlY2xhcmF0aW9uQXBwRWxlbWVudCkgPyB0aGlzLmRlY2xhcmF0aW9uQXBwRWxlbWVudC5wYXJlbnRWaWV3IDogbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXBwVmlldy5wcm90b3R5cGUsIFwiZmxhdFJvb3ROb2Rlc1wiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZsYXR0ZW5OZXN0ZWRWaWV3UmVuZGVyTm9kZXModGhpcy5yb290Tm9kZXNPckFwcEVsZW1lbnRzKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcHBWaWV3LnByb3RvdHlwZSwgXCJsYXN0Um9vdE5vZGVcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxhc3ROb2RlID0gdGhpcy5yb290Tm9kZXNPckFwcEVsZW1lbnRzLmxlbmd0aCA+IDAgP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJvb3ROb2Rlc09yQXBwRWxlbWVudHNbdGhpcy5yb290Tm9kZXNPckFwcEVsZW1lbnRzLmxlbmd0aCAtIDFdIDpcbiAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZpbmRMYXN0UmVuZGVyTm9kZShsYXN0Tm9kZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE92ZXJ3cml0dGVuIGJ5IGltcGxlbWVudGF0aW9uc1xuICAgICAgICAgKi9cbiAgICAgICAgQXBwVmlldy5wcm90b3R5cGUuZGlydHlQYXJlbnRRdWVyaWVzSW50ZXJuYWwgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIEFwcFZpZXcucHJvdG90eXBlLmRldGVjdENoYW5nZXMgPSBmdW5jdGlvbiAodGhyb3dPbkNoYW5nZSkge1xuICAgICAgICAgICAgdmFyIHMgPSBfc2NvcGVfY2hlY2sodGhpcy5jbGF6eik7XG4gICAgICAgICAgICBpZiAodGhpcy5jZE1vZGUgPT09IENoYW5nZURldGVjdG9yU3RhdHVzLkNoZWNrZWQgfHxcbiAgICAgICAgICAgICAgICB0aGlzLmNkTW9kZSA9PT0gQ2hhbmdlRGV0ZWN0b3JTdGF0dXMuRXJyb3JlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAodGhpcy5jZE1vZGUgPT09IENoYW5nZURldGVjdG9yU3RhdHVzLkRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgIHRoaXMudGhyb3dEZXN0cm95ZWRFcnJvcignZGV0ZWN0Q2hhbmdlcycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kZXRlY3RDaGFuZ2VzSW50ZXJuYWwodGhyb3dPbkNoYW5nZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5jZE1vZGUgPT09IENoYW5nZURldGVjdG9yU3RhdHVzLkNoZWNrT25jZSlcbiAgICAgICAgICAgICAgICB0aGlzLmNkTW9kZSA9IENoYW5nZURldGVjdG9yU3RhdHVzLkNoZWNrZWQ7XG4gICAgICAgICAgICB0aGlzLm51bWJlck9mQ2hlY2tzKys7XG4gICAgICAgICAgICB3dGZMZWF2ZShzKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE92ZXJ3cml0dGVuIGJ5IGltcGxlbWVudGF0aW9uc1xuICAgICAgICAgKi9cbiAgICAgICAgQXBwVmlldy5wcm90b3R5cGUuZGV0ZWN0Q2hhbmdlc0ludGVybmFsID0gZnVuY3Rpb24gKHRocm93T25DaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuZGV0ZWN0Q29udGVudENoaWxkcmVuQ2hhbmdlcyh0aHJvd09uQ2hhbmdlKTtcbiAgICAgICAgICAgIHRoaXMuZGV0ZWN0Vmlld0NoaWxkcmVuQ2hhbmdlcyh0aHJvd09uQ2hhbmdlKTtcbiAgICAgICAgfTtcbiAgICAgICAgQXBwVmlldy5wcm90b3R5cGUuZGV0ZWN0Q29udGVudENoaWxkcmVuQ2hhbmdlcyA9IGZ1bmN0aW9uICh0aHJvd09uQ2hhbmdlKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29udGVudENoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jb250ZW50Q2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmNkTW9kZSA9PT0gQ2hhbmdlRGV0ZWN0b3JTdGF0dXMuRGV0YWNoZWQpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNoaWxkLmRldGVjdENoYW5nZXModGhyb3dPbkNoYW5nZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEFwcFZpZXcucHJvdG90eXBlLmRldGVjdFZpZXdDaGlsZHJlbkNoYW5nZXMgPSBmdW5jdGlvbiAodGhyb3dPbkNoYW5nZSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnZpZXdDaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IHRoaXMudmlld0NoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5jZE1vZGUgPT09IENoYW5nZURldGVjdG9yU3RhdHVzLkRldGFjaGVkKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjaGlsZC5kZXRlY3RDaGFuZ2VzKHRocm93T25DaGFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBBcHBWaWV3LnByb3RvdHlwZS5tYXJrQ29udGVudENoaWxkQXNNb3ZlZCA9IGZ1bmN0aW9uIChyZW5kZXJBcHBFbGVtZW50KSB7IHRoaXMuZGlydHlQYXJlbnRRdWVyaWVzSW50ZXJuYWwoKTsgfTtcbiAgICAgICAgQXBwVmlldy5wcm90b3R5cGUuYWRkVG9Db250ZW50Q2hpbGRyZW4gPSBmdW5jdGlvbiAocmVuZGVyQXBwRWxlbWVudCkge1xuICAgICAgICAgICAgcmVuZGVyQXBwRWxlbWVudC5wYXJlbnRWaWV3LmNvbnRlbnRDaGlsZHJlbi5wdXNoKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy52aWV3Q29udGFpbmVyRWxlbWVudCA9IHJlbmRlckFwcEVsZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmRpcnR5UGFyZW50UXVlcmllc0ludGVybmFsKCk7XG4gICAgICAgIH07XG4gICAgICAgIEFwcFZpZXcucHJvdG90eXBlLnJlbW92ZUZyb21Db250ZW50Q2hpbGRyZW4gPSBmdW5jdGlvbiAocmVuZGVyQXBwRWxlbWVudCkge1xuICAgICAgICAgICAgTGlzdFdyYXBwZXIucmVtb3ZlKHJlbmRlckFwcEVsZW1lbnQucGFyZW50Vmlldy5jb250ZW50Q2hpbGRyZW4sIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eVBhcmVudFF1ZXJpZXNJbnRlcm5hbCgpO1xuICAgICAgICAgICAgdGhpcy52aWV3Q29udGFpbmVyRWxlbWVudCA9IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIEFwcFZpZXcucHJvdG90eXBlLm1hcmtBc0NoZWNrT25jZSA9IGZ1bmN0aW9uICgpIHsgdGhpcy5jZE1vZGUgPSBDaGFuZ2VEZXRlY3RvclN0YXR1cy5DaGVja09uY2U7IH07XG4gICAgICAgIEFwcFZpZXcucHJvdG90eXBlLm1hcmtQYXRoVG9Sb290QXNDaGVja09uY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYyA9IHRoaXM7XG4gICAgICAgICAgICB3aGlsZSAoaXNQcmVzZW50KGMpICYmIGMuY2RNb2RlICE9PSBDaGFuZ2VEZXRlY3RvclN0YXR1cy5EZXRhY2hlZCkge1xuICAgICAgICAgICAgICAgIGlmIChjLmNkTW9kZSA9PT0gQ2hhbmdlRGV0ZWN0b3JTdGF0dXMuQ2hlY2tlZCkge1xuICAgICAgICAgICAgICAgICAgICBjLmNkTW9kZSA9IENoYW5nZURldGVjdG9yU3RhdHVzLkNoZWNrT25jZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudEVsID0gYy50eXBlID09PSBWaWV3VHlwZS5DT01QT05FTlQgPyBjLmRlY2xhcmF0aW9uQXBwRWxlbWVudCA6IGMudmlld0NvbnRhaW5lckVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgYyA9IGlzUHJlc2VudChwYXJlbnRFbCkgPyBwYXJlbnRFbC5wYXJlbnRWaWV3IDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgQXBwVmlldy5wcm90b3R5cGUuZXZlbnRIYW5kbGVyID0gZnVuY3Rpb24gKGNiKSB7IHJldHVybiBjYjsgfTtcbiAgICAgICAgQXBwVmlldy5wcm90b3R5cGUudGhyb3dEZXN0cm95ZWRFcnJvciA9IGZ1bmN0aW9uIChkZXRhaWxzKSB7IHRocm93IG5ldyBWaWV3RGVzdHJveWVkRXJyb3IoZGV0YWlscyk7IH07XG4gICAgICAgIHJldHVybiBBcHBWaWV3O1xuICAgIH0oKSk7XG4gICAgdmFyIERlYnVnQXBwVmlldyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQxNChEZWJ1Z0FwcFZpZXcsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIERlYnVnQXBwVmlldyhjbGF6eiwgY29tcG9uZW50VHlwZSwgdHlwZSwgdmlld1V0aWxzLCBwYXJlbnRJbmplY3RvciwgZGVjbGFyYXRpb25BcHBFbGVtZW50LCBjZE1vZGUsIHN0YXRpY05vZGVEZWJ1Z0luZm9zKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBjbGF6eiwgY29tcG9uZW50VHlwZSwgdHlwZSwgdmlld1V0aWxzLCBwYXJlbnRJbmplY3RvciwgZGVjbGFyYXRpb25BcHBFbGVtZW50LCBjZE1vZGUpO1xuICAgICAgICAgICAgdGhpcy5zdGF0aWNOb2RlRGVidWdJbmZvcyA9IHN0YXRpY05vZGVEZWJ1Z0luZm9zO1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudERlYnVnQ29udGV4dCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgRGVidWdBcHBWaWV3LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAoY29udGV4dCwgZ2l2ZW5Qcm9qZWN0YWJsZU5vZGVzLCByb290U2VsZWN0b3JPck5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2V0RGVidWcoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuY3JlYXRlLmNhbGwodGhpcywgY29udGV4dCwgZ2l2ZW5Qcm9qZWN0YWJsZU5vZGVzLCByb290U2VsZWN0b3JPck5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXRocm93V2l0aENvbnRleHQoZSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRGVidWdBcHBWaWV3LnByb3RvdHlwZS5pbmplY3RvckdldCA9IGZ1bmN0aW9uICh0b2tlbiwgbm9kZUluZGV4LCBub3RGb3VuZFJlc3VsdCkge1xuICAgICAgICAgICAgdGhpcy5fcmVzZXREZWJ1ZygpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5pbmplY3RvckdldC5jYWxsKHRoaXMsIHRva2VuLCBub2RlSW5kZXgsIG5vdEZvdW5kUmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmV0aHJvd1dpdGhDb250ZXh0KGUpO1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIERlYnVnQXBwVmlldy5wcm90b3R5cGUuZGV0YWNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fcmVzZXREZWJ1ZygpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRldGFjaC5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXRocm93V2l0aENvbnRleHQoZSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRGVidWdBcHBWaWV3LnByb3RvdHlwZS5kZXN0cm95TG9jYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNldERlYnVnKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGVzdHJveUxvY2FsLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JldGhyb3dXaXRoQ29udGV4dChlKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBEZWJ1Z0FwcFZpZXcucHJvdG90eXBlLmRldGVjdENoYW5nZXMgPSBmdW5jdGlvbiAodGhyb3dPbkNoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVzZXREZWJ1ZygpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRldGVjdENoYW5nZXMuY2FsbCh0aGlzLCB0aHJvd09uQ2hhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmV0aHJvd1dpdGhDb250ZXh0KGUpO1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIERlYnVnQXBwVmlldy5wcm90b3R5cGUuX3Jlc2V0RGVidWcgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX2N1cnJlbnREZWJ1Z0NvbnRleHQgPSBudWxsOyB9O1xuICAgICAgICBEZWJ1Z0FwcFZpZXcucHJvdG90eXBlLmRlYnVnID0gZnVuY3Rpb24gKG5vZGVJbmRleCwgcm93TnVtLCBjb2xOdW0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50RGVidWdDb250ZXh0ID0gbmV3IERlYnVnQ29udGV4dCh0aGlzLCBub2RlSW5kZXgsIHJvd051bSwgY29sTnVtKTtcbiAgICAgICAgfTtcbiAgICAgICAgRGVidWdBcHBWaWV3LnByb3RvdHlwZS5fcmV0aHJvd1dpdGhDb250ZXh0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGlmICghKGUgaW5zdGFuY2VvZiBWaWV3V3JhcHBlZEVycm9yKSkge1xuICAgICAgICAgICAgICAgIGlmICghKGUgaW5zdGFuY2VvZiBFeHByZXNzaW9uQ2hhbmdlZEFmdGVySXRIYXNCZWVuQ2hlY2tlZEVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNkTW9kZSA9IENoYW5nZURldGVjdG9yU3RhdHVzLkVycm9yZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5fY3VycmVudERlYnVnQ29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFZpZXdXcmFwcGVkRXJyb3IoZSwgdGhpcy5fY3VycmVudERlYnVnQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBEZWJ1Z0FwcFZpZXcucHJvdG90eXBlLmV2ZW50SGFuZGxlciA9IGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBzdXBlckhhbmRsZXIgPSBfc3VwZXIucHJvdG90eXBlLmV2ZW50SGFuZGxlci5jYWxsKHRoaXMsIGNiKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fcmVzZXREZWJ1ZygpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdXBlckhhbmRsZXIoZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmV0aHJvd1dpdGhDb250ZXh0KGUpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBEZWJ1Z0FwcFZpZXc7XG4gICAgfShBcHBWaWV3KSk7XG4gICAgZnVuY3Rpb24gX2ZpbmRMYXN0UmVuZGVyTm9kZShub2RlKSB7XG4gICAgICAgIHZhciBsYXN0Tm9kZTtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBcHBFbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgYXBwRWwgPSBub2RlO1xuICAgICAgICAgICAgbGFzdE5vZGUgPSBhcHBFbC5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChhcHBFbC5uZXN0ZWRWaWV3cykpIHtcbiAgICAgICAgICAgICAgICAvLyBOb3RlOiBWaWV3cyBtaWdodCBoYXZlIG5vIHJvb3Qgbm9kZXMgYXQgYWxsIVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBhcHBFbC5uZXN0ZWRWaWV3cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmVzdGVkVmlldyA9IGFwcEVsLm5lc3RlZFZpZXdzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmVzdGVkVmlldy5yb290Tm9kZXNPckFwcEVsZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3ROb2RlID0gX2ZpbmRMYXN0UmVuZGVyTm9kZShuZXN0ZWRWaWV3LnJvb3ROb2Rlc09yQXBwRWxlbWVudHNbbmVzdGVkVmlldy5yb290Tm9kZXNPckFwcEVsZW1lbnRzLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxhc3ROb2RlID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGFzdE5vZGU7XG4gICAgfVxuXG4gICAgdmFyIF9fY29yZV9wcml2YXRlX18gPSB7XG4gICAgICAgIGlzRGVmYXVsdENoYW5nZURldGVjdGlvblN0cmF0ZWd5OiBpc0RlZmF1bHRDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgICAgICAgQ2hhbmdlRGV0ZWN0b3JTdGF0dXM6IENoYW5nZURldGVjdG9yU3RhdHVzLFxuICAgICAgICBjb25zdHJ1Y3REZXBlbmRlbmNpZXM6IGNvbnN0cnVjdERlcGVuZGVuY2llcyxcbiAgICAgICAgTGlmZWN5Y2xlSG9va3M6IExpZmVjeWNsZUhvb2tzLFxuICAgICAgICBMSUZFQ1lDTEVfSE9PS1NfVkFMVUVTOiBMSUZFQ1lDTEVfSE9PS1NfVkFMVUVTLFxuICAgICAgICBSZWZsZWN0b3JSZWFkZXI6IFJlZmxlY3RvclJlYWRlcixcbiAgICAgICAgQ29kZWdlbkNvbXBvbmVudEZhY3RvcnlSZXNvbHZlcjogQ29kZWdlbkNvbXBvbmVudEZhY3RvcnlSZXNvbHZlcixcbiAgICAgICAgQXBwRWxlbWVudDogQXBwRWxlbWVudCxcbiAgICAgICAgQXBwVmlldzogQXBwVmlldyxcbiAgICAgICAgRGVidWdBcHBWaWV3OiBEZWJ1Z0FwcFZpZXcsXG4gICAgICAgIE5nTW9kdWxlSW5qZWN0b3I6IE5nTW9kdWxlSW5qZWN0b3IsXG4gICAgICAgIHJlZ2lzdGVyTW9kdWxlRmFjdG9yeTogcmVnaXN0ZXJNb2R1bGVGYWN0b3J5LFxuICAgICAgICBWaWV3VHlwZTogVmlld1R5cGUsXG4gICAgICAgIHZpZXdfdXRpbHM6IHZpZXdfdXRpbHMsXG4gICAgICAgIFZpZXdNZXRhZGF0YTogVmlld01ldGFkYXRhLFxuICAgICAgICBEZWJ1Z0NvbnRleHQ6IERlYnVnQ29udGV4dCxcbiAgICAgICAgU3RhdGljTm9kZURlYnVnSW5mbzogU3RhdGljTm9kZURlYnVnSW5mbyxcbiAgICAgICAgZGV2TW9kZUVxdWFsOiBkZXZNb2RlRXF1YWwsXG4gICAgICAgIFVOSU5JVElBTElaRUQ6IFVOSU5JVElBTElaRUQsXG4gICAgICAgIFZhbHVlVW53cmFwcGVyOiBWYWx1ZVVud3JhcHBlcixcbiAgICAgICAgUmVuZGVyRGVidWdJbmZvOiBSZW5kZXJEZWJ1Z0luZm8sXG4gICAgICAgIFRlbXBsYXRlUmVmXzogVGVtcGxhdGVSZWZfLFxuICAgICAgICBSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzOiBSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLFxuICAgICAgICBtYWtlRGVjb3JhdG9yOiBtYWtlRGVjb3JhdG9yLFxuICAgICAgICBEZWJ1Z0RvbVJvb3RSZW5kZXJlcjogRGVidWdEb21Sb290UmVuZGVyZXIsXG4gICAgICAgIENvbnNvbGU6IENvbnNvbGUsXG4gICAgICAgIHJlZmxlY3RvcjogcmVmbGVjdG9yLFxuICAgICAgICBSZWZsZWN0b3I6IFJlZmxlY3RvcixcbiAgICAgICAgTm9PcEFuaW1hdGlvblBsYXllcjogTm9PcEFuaW1hdGlvblBsYXllcixcbiAgICAgICAgQW5pbWF0aW9uUGxheWVyOiBBbmltYXRpb25QbGF5ZXIsXG4gICAgICAgIEFuaW1hdGlvblNlcXVlbmNlUGxheWVyOiBBbmltYXRpb25TZXF1ZW5jZVBsYXllcixcbiAgICAgICAgQW5pbWF0aW9uR3JvdXBQbGF5ZXI6IEFuaW1hdGlvbkdyb3VwUGxheWVyLFxuICAgICAgICBBbmltYXRpb25LZXlmcmFtZTogQW5pbWF0aW9uS2V5ZnJhbWUsXG4gICAgICAgIHByZXBhcmVGaW5hbEFuaW1hdGlvblN0eWxlczogcHJlcGFyZUZpbmFsQW5pbWF0aW9uU3R5bGVzLFxuICAgICAgICBiYWxhbmNlQW5pbWF0aW9uS2V5ZnJhbWVzOiBiYWxhbmNlQW5pbWF0aW9uS2V5ZnJhbWVzLFxuICAgICAgICBmbGF0dGVuU3R5bGVzOiBmbGF0dGVuU3R5bGVzLFxuICAgICAgICBjbGVhclN0eWxlczogY2xlYXJTdHlsZXMsXG4gICAgICAgIHJlbmRlclN0eWxlczogcmVuZGVyU3R5bGVzLFxuICAgICAgICBjb2xsZWN0QW5kUmVzb2x2ZVN0eWxlczogY29sbGVjdEFuZFJlc29sdmVTdHlsZXMsXG4gICAgICAgIEFuaW1hdGlvblN0eWxlczogQW5pbWF0aW9uU3R5bGVzLFxuICAgICAgICBBTllfU1RBVEU6IEFOWV9TVEFURSxcbiAgICAgICAgREVGQVVMVF9TVEFURTogREVGQVVMVF9TVEFURSxcbiAgICAgICAgRU1QVFlfU1RBVEU6IEVNUFRZX1NUQVRFLFxuICAgICAgICBGSUxMX1NUWUxFX0ZMQUc6IEZJTExfU1RZTEVfRkxBRyxcbiAgICAgICAgQ29tcG9uZW50U3RpbGxMb2FkaW5nRXJyb3I6IENvbXBvbmVudFN0aWxsTG9hZGluZ0Vycm9yLFxuICAgICAgICBpc1Byb21pc2U6IGlzUHJvbWlzZSxcbiAgICAgICAgQW5pbWF0aW9uVHJhbnNpdGlvbjogQW5pbWF0aW9uVHJhbnNpdGlvblxuICAgIH07XG5cbiAgICBleHBvcnRzLmNyZWF0ZVBsYXRmb3JtID0gY3JlYXRlUGxhdGZvcm07XG4gICAgZXhwb3J0cy5hc3NlcnRQbGF0Zm9ybSA9IGFzc2VydFBsYXRmb3JtO1xuICAgIGV4cG9ydHMuZGVzdHJveVBsYXRmb3JtID0gZGVzdHJveVBsYXRmb3JtO1xuICAgIGV4cG9ydHMuZ2V0UGxhdGZvcm0gPSBnZXRQbGF0Zm9ybTtcbiAgICBleHBvcnRzLlBsYXRmb3JtUmVmID0gUGxhdGZvcm1SZWY7XG4gICAgZXhwb3J0cy5BcHBsaWNhdGlvblJlZiA9IEFwcGxpY2F0aW9uUmVmO1xuICAgIGV4cG9ydHMuZW5hYmxlUHJvZE1vZGUgPSBlbmFibGVQcm9kTW9kZTtcbiAgICBleHBvcnRzLmlzRGV2TW9kZSA9IGlzRGV2TW9kZTtcbiAgICBleHBvcnRzLmNyZWF0ZVBsYXRmb3JtRmFjdG9yeSA9IGNyZWF0ZVBsYXRmb3JtRmFjdG9yeTtcbiAgICBleHBvcnRzLkFQUF9JRCA9IEFQUF9JRDtcbiAgICBleHBvcnRzLlBBQ0tBR0VfUk9PVF9VUkwgPSBQQUNLQUdFX1JPT1RfVVJMO1xuICAgIGV4cG9ydHMuUExBVEZPUk1fSU5JVElBTElaRVIgPSBQTEFURk9STV9JTklUSUFMSVpFUjtcbiAgICBleHBvcnRzLkFQUF9CT09UU1RSQVBfTElTVEVORVIgPSBBUFBfQk9PVFNUUkFQX0xJU1RFTkVSO1xuICAgIGV4cG9ydHMuQVBQX0lOSVRJQUxJWkVSID0gQVBQX0lOSVRJQUxJWkVSO1xuICAgIGV4cG9ydHMuQXBwbGljYXRpb25Jbml0U3RhdHVzID0gQXBwbGljYXRpb25Jbml0U3RhdHVzO1xuICAgIGV4cG9ydHMuRGVidWdFbGVtZW50ID0gRGVidWdFbGVtZW50O1xuICAgIGV4cG9ydHMuRGVidWdOb2RlID0gRGVidWdOb2RlO1xuICAgIGV4cG9ydHMuYXNOYXRpdmVFbGVtZW50cyA9IGFzTmF0aXZlRWxlbWVudHM7XG4gICAgZXhwb3J0cy5nZXREZWJ1Z05vZGUgPSBnZXREZWJ1Z05vZGU7XG4gICAgZXhwb3J0cy5UZXN0YWJpbGl0eSA9IFRlc3RhYmlsaXR5O1xuICAgIGV4cG9ydHMuVGVzdGFiaWxpdHlSZWdpc3RyeSA9IFRlc3RhYmlsaXR5UmVnaXN0cnk7XG4gICAgZXhwb3J0cy5zZXRUZXN0YWJpbGl0eUdldHRlciA9IHNldFRlc3RhYmlsaXR5R2V0dGVyO1xuICAgIGV4cG9ydHMuVFJBTlNMQVRJT05TID0gVFJBTlNMQVRJT05TO1xuICAgIGV4cG9ydHMuVFJBTlNMQVRJT05TX0ZPUk1BVCA9IFRSQU5TTEFUSU9OU19GT1JNQVQ7XG4gICAgZXhwb3J0cy5MT0NBTEVfSUQgPSBMT0NBTEVfSUQ7XG4gICAgZXhwb3J0cy5BcHBsaWNhdGlvbk1vZHVsZSA9IEFwcGxpY2F0aW9uTW9kdWxlO1xuICAgIGV4cG9ydHMud3RmQ3JlYXRlU2NvcGUgPSB3dGZDcmVhdGVTY29wZTtcbiAgICBleHBvcnRzLnd0ZkxlYXZlID0gd3RmTGVhdmU7XG4gICAgZXhwb3J0cy53dGZTdGFydFRpbWVSYW5nZSA9IHd0ZlN0YXJ0VGltZVJhbmdlO1xuICAgIGV4cG9ydHMud3RmRW5kVGltZVJhbmdlID0gd3RmRW5kVGltZVJhbmdlO1xuICAgIGV4cG9ydHMuVHlwZSA9IFR5cGU7XG4gICAgZXhwb3J0cy5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG4gICAgZXhwb3J0cy5FcnJvckhhbmRsZXIgPSBFcnJvckhhbmRsZXI7XG4gICAgZXhwb3J0cy5BbmltYXRpb25UcmFuc2l0aW9uRXZlbnQgPSBBbmltYXRpb25UcmFuc2l0aW9uRXZlbnQ7XG4gICAgZXhwb3J0cy5BbmltYXRpb25QbGF5ZXIgPSBBbmltYXRpb25QbGF5ZXI7XG4gICAgZXhwb3J0cy5TYW5pdGl6ZXIgPSBTYW5pdGl6ZXI7XG4gICAgZXhwb3J0cy5BTkFMWVpFX0ZPUl9FTlRSWV9DT01QT05FTlRTID0gQU5BTFlaRV9GT1JfRU5UUllfQ09NUE9ORU5UUztcbiAgICBleHBvcnRzLkF0dHJpYnV0ZSA9IEF0dHJpYnV0ZTtcbiAgICBleHBvcnRzLkNvbnRlbnRDaGlsZCA9IENvbnRlbnRDaGlsZDtcbiAgICBleHBvcnRzLkNvbnRlbnRDaGlsZHJlbiA9IENvbnRlbnRDaGlsZHJlbjtcbiAgICBleHBvcnRzLlF1ZXJ5ID0gUXVlcnk7XG4gICAgZXhwb3J0cy5WaWV3Q2hpbGQgPSBWaWV3Q2hpbGQ7XG4gICAgZXhwb3J0cy5WaWV3Q2hpbGRyZW4gPSBWaWV3Q2hpbGRyZW47XG4gICAgZXhwb3J0cy5Db21wb25lbnQgPSBDb21wb25lbnQ7XG4gICAgZXhwb3J0cy5EaXJlY3RpdmUgPSBEaXJlY3RpdmU7XG4gICAgZXhwb3J0cy5Ib3N0QmluZGluZyA9IEhvc3RCaW5kaW5nO1xuICAgIGV4cG9ydHMuSG9zdExpc3RlbmVyID0gSG9zdExpc3RlbmVyO1xuICAgIGV4cG9ydHMuSW5wdXQgPSBJbnB1dDtcbiAgICBleHBvcnRzLk91dHB1dCA9IE91dHB1dDtcbiAgICBleHBvcnRzLlBpcGUgPSBQaXBlO1xuICAgIGV4cG9ydHMuQWZ0ZXJDb250ZW50Q2hlY2tlZCA9IEFmdGVyQ29udGVudENoZWNrZWQ7XG4gICAgZXhwb3J0cy5BZnRlckNvbnRlbnRJbml0ID0gQWZ0ZXJDb250ZW50SW5pdDtcbiAgICBleHBvcnRzLkFmdGVyVmlld0NoZWNrZWQgPSBBZnRlclZpZXdDaGVja2VkO1xuICAgIGV4cG9ydHMuQWZ0ZXJWaWV3SW5pdCA9IEFmdGVyVmlld0luaXQ7XG4gICAgZXhwb3J0cy5Eb0NoZWNrID0gRG9DaGVjaztcbiAgICBleHBvcnRzLk9uQ2hhbmdlcyA9IE9uQ2hhbmdlcztcbiAgICBleHBvcnRzLk9uRGVzdHJveSA9IE9uRGVzdHJveTtcbiAgICBleHBvcnRzLk9uSW5pdCA9IE9uSW5pdDtcbiAgICBleHBvcnRzLkNVU1RPTV9FTEVNRU5UU19TQ0hFTUEgPSBDVVNUT01fRUxFTUVOVFNfU0NIRU1BO1xuICAgIGV4cG9ydHMuTk9fRVJST1JTX1NDSEVNQSA9IE5PX0VSUk9SU19TQ0hFTUE7XG4gICAgZXhwb3J0cy5OZ01vZHVsZSA9IE5nTW9kdWxlO1xuICAgIGV4cG9ydHMuQ2xhc3MgPSBDbGFzcztcbiAgICBleHBvcnRzLmZvcndhcmRSZWYgPSBmb3J3YXJkUmVmO1xuICAgIGV4cG9ydHMucmVzb2x2ZUZvcndhcmRSZWYgPSByZXNvbHZlRm9yd2FyZFJlZjtcbiAgICBleHBvcnRzLkluamVjdG9yID0gSW5qZWN0b3I7XG4gICAgZXhwb3J0cy5SZWZsZWN0aXZlSW5qZWN0b3IgPSBSZWZsZWN0aXZlSW5qZWN0b3I7XG4gICAgZXhwb3J0cy5SZXNvbHZlZFJlZmxlY3RpdmVGYWN0b3J5ID0gUmVzb2x2ZWRSZWZsZWN0aXZlRmFjdG9yeTtcbiAgICBleHBvcnRzLlJlZmxlY3RpdmVLZXkgPSBSZWZsZWN0aXZlS2V5O1xuICAgIGV4cG9ydHMuT3BhcXVlVG9rZW4gPSBPcGFxdWVUb2tlbjtcbiAgICBleHBvcnRzLkluamVjdCA9IEluamVjdDtcbiAgICBleHBvcnRzLk9wdGlvbmFsID0gT3B0aW9uYWw7XG4gICAgZXhwb3J0cy5JbmplY3RhYmxlID0gSW5qZWN0YWJsZTtcbiAgICBleHBvcnRzLlNlbGYgPSBTZWxmO1xuICAgIGV4cG9ydHMuU2tpcFNlbGYgPSBTa2lwU2VsZjtcbiAgICBleHBvcnRzLkhvc3QgPSBIb3N0O1xuICAgIGV4cG9ydHMuTmdab25lID0gTmdab25lO1xuICAgIGV4cG9ydHMuUmVuZGVyQ29tcG9uZW50VHlwZSA9IFJlbmRlckNvbXBvbmVudFR5cGU7XG4gICAgZXhwb3J0cy5SZW5kZXJlciA9IFJlbmRlcmVyO1xuICAgIGV4cG9ydHMuUm9vdFJlbmRlcmVyID0gUm9vdFJlbmRlcmVyO1xuICAgIGV4cG9ydHMuQ09NUElMRVJfT1BUSU9OUyA9IENPTVBJTEVSX09QVElPTlM7XG4gICAgZXhwb3J0cy5Db21waWxlciA9IENvbXBpbGVyO1xuICAgIGV4cG9ydHMuQ29tcGlsZXJGYWN0b3J5ID0gQ29tcGlsZXJGYWN0b3J5O1xuICAgIGV4cG9ydHMuTW9kdWxlV2l0aENvbXBvbmVudEZhY3RvcmllcyA9IE1vZHVsZVdpdGhDb21wb25lbnRGYWN0b3JpZXM7XG4gICAgZXhwb3J0cy5Db21wb25lbnRGYWN0b3J5ID0gQ29tcG9uZW50RmFjdG9yeTtcbiAgICBleHBvcnRzLkNvbXBvbmVudFJlZiA9IENvbXBvbmVudFJlZjtcbiAgICBleHBvcnRzLkNvbXBvbmVudEZhY3RvcnlSZXNvbHZlciA9IENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcjtcbiAgICBleHBvcnRzLkVsZW1lbnRSZWYgPSBFbGVtZW50UmVmO1xuICAgIGV4cG9ydHMuTmdNb2R1bGVGYWN0b3J5ID0gTmdNb2R1bGVGYWN0b3J5O1xuICAgIGV4cG9ydHMuTmdNb2R1bGVSZWYgPSBOZ01vZHVsZVJlZjtcbiAgICBleHBvcnRzLk5nTW9kdWxlRmFjdG9yeUxvYWRlciA9IE5nTW9kdWxlRmFjdG9yeUxvYWRlcjtcbiAgICBleHBvcnRzLmdldE1vZHVsZUZhY3RvcnkgPSBnZXRNb2R1bGVGYWN0b3J5O1xuICAgIGV4cG9ydHMuUXVlcnlMaXN0ID0gUXVlcnlMaXN0O1xuICAgIGV4cG9ydHMuU3lzdGVtSnNOZ01vZHVsZUxvYWRlciA9IFN5c3RlbUpzTmdNb2R1bGVMb2FkZXI7XG4gICAgZXhwb3J0cy5TeXN0ZW1Kc05nTW9kdWxlTG9hZGVyQ29uZmlnID0gU3lzdGVtSnNOZ01vZHVsZUxvYWRlckNvbmZpZztcbiAgICBleHBvcnRzLlRlbXBsYXRlUmVmID0gVGVtcGxhdGVSZWY7XG4gICAgZXhwb3J0cy5WaWV3Q29udGFpbmVyUmVmID0gVmlld0NvbnRhaW5lclJlZjtcbiAgICBleHBvcnRzLkVtYmVkZGVkVmlld1JlZiA9IEVtYmVkZGVkVmlld1JlZjtcbiAgICBleHBvcnRzLlZpZXdSZWYgPSBWaWV3UmVmO1xuICAgIGV4cG9ydHMuQ2hhbmdlRGV0ZWN0b3JSZWYgPSBDaGFuZ2VEZXRlY3RvclJlZjtcbiAgICBleHBvcnRzLkNvbGxlY3Rpb25DaGFuZ2VSZWNvcmQgPSBDb2xsZWN0aW9uQ2hhbmdlUmVjb3JkO1xuICAgIGV4cG9ydHMuRGVmYXVsdEl0ZXJhYmxlRGlmZmVyID0gRGVmYXVsdEl0ZXJhYmxlRGlmZmVyO1xuICAgIGV4cG9ydHMuSXRlcmFibGVEaWZmZXJzID0gSXRlcmFibGVEaWZmZXJzO1xuICAgIGV4cG9ydHMuS2V5VmFsdWVDaGFuZ2VSZWNvcmQgPSBLZXlWYWx1ZUNoYW5nZVJlY29yZDtcbiAgICBleHBvcnRzLktleVZhbHVlRGlmZmVycyA9IEtleVZhbHVlRGlmZmVycztcbiAgICBleHBvcnRzLlNpbXBsZUNoYW5nZSA9IFNpbXBsZUNoYW5nZTtcbiAgICBleHBvcnRzLldyYXBwZWRWYWx1ZSA9IFdyYXBwZWRWYWx1ZTtcbiAgICBleHBvcnRzLnBsYXRmb3JtQ29yZSA9IHBsYXRmb3JtQ29yZTtcbiAgICBleHBvcnRzLl9fY29yZV9wcml2YXRlX18gPSBfX2NvcmVfcHJpdmF0ZV9fO1xuICAgIGV4cG9ydHMuQVVUT19TVFlMRSA9IEFVVE9fU1RZTEU7XG4gICAgZXhwb3J0cy5BbmltYXRpb25FbnRyeU1ldGFkYXRhID0gQW5pbWF0aW9uRW50cnlNZXRhZGF0YTtcbiAgICBleHBvcnRzLkFuaW1hdGlvblN0YXRlTWV0YWRhdGEgPSBBbmltYXRpb25TdGF0ZU1ldGFkYXRhO1xuICAgIGV4cG9ydHMuQW5pbWF0aW9uU3RhdGVEZWNsYXJhdGlvbk1ldGFkYXRhID0gQW5pbWF0aW9uU3RhdGVEZWNsYXJhdGlvbk1ldGFkYXRhO1xuICAgIGV4cG9ydHMuQW5pbWF0aW9uU3RhdGVUcmFuc2l0aW9uTWV0YWRhdGEgPSBBbmltYXRpb25TdGF0ZVRyYW5zaXRpb25NZXRhZGF0YTtcbiAgICBleHBvcnRzLkFuaW1hdGlvbk1ldGFkYXRhID0gQW5pbWF0aW9uTWV0YWRhdGE7XG4gICAgZXhwb3J0cy5BbmltYXRpb25LZXlmcmFtZXNTZXF1ZW5jZU1ldGFkYXRhID0gQW5pbWF0aW9uS2V5ZnJhbWVzU2VxdWVuY2VNZXRhZGF0YTtcbiAgICBleHBvcnRzLkFuaW1hdGlvblN0eWxlTWV0YWRhdGEgPSBBbmltYXRpb25TdHlsZU1ldGFkYXRhO1xuICAgIGV4cG9ydHMuQW5pbWF0aW9uQW5pbWF0ZU1ldGFkYXRhID0gQW5pbWF0aW9uQW5pbWF0ZU1ldGFkYXRhO1xuICAgIGV4cG9ydHMuQW5pbWF0aW9uV2l0aFN0ZXBzTWV0YWRhdGEgPSBBbmltYXRpb25XaXRoU3RlcHNNZXRhZGF0YTtcbiAgICBleHBvcnRzLkFuaW1hdGlvblNlcXVlbmNlTWV0YWRhdGEgPSBBbmltYXRpb25TZXF1ZW5jZU1ldGFkYXRhO1xuICAgIGV4cG9ydHMuQW5pbWF0aW9uR3JvdXBNZXRhZGF0YSA9IEFuaW1hdGlvbkdyb3VwTWV0YWRhdGE7XG4gICAgZXhwb3J0cy5hbmltYXRlID0gYW5pbWF0ZTtcbiAgICBleHBvcnRzLmdyb3VwID0gZ3JvdXA7XG4gICAgZXhwb3J0cy5zZXF1ZW5jZSA9IHNlcXVlbmNlO1xuICAgIGV4cG9ydHMuc3R5bGUgPSBzdHlsZTtcbiAgICBleHBvcnRzLnN0YXRlID0gc3RhdGU7XG4gICAgZXhwb3J0cy5rZXlmcmFtZXMgPSBrZXlmcmFtZXM7XG4gICAgZXhwb3J0cy50cmFuc2l0aW9uID0gdHJhbnNpdGlvbjtcbiAgICBleHBvcnRzLnRyaWdnZXIgPSB0cmlnZ2VyO1xuXG59KSk7XG4iLCIvKipcbiAqIEBsaWNlbnNlIEFuZ3VsYXIgdjIuMS4xXG4gKiAoYykgMjAxMC0yMDE2IEdvb2dsZSwgSW5jLiBodHRwczovL2FuZ3VsYXIuaW8vXG4gKiBMaWNlbnNlOiBNSVRcbiAqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMsIHJlcXVpcmUoJ0Bhbmd1bGFyL2NvbXBpbGVyJyksIHJlcXVpcmUoJ0Bhbmd1bGFyL2NvcmUnKSwgcmVxdWlyZSgnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3NlcicpKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cycsICdAYW5ndWxhci9jb21waWxlcicsICdAYW5ndWxhci9jb3JlJywgJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXInXSwgZmFjdG9yeSkgOlxuICAgIChmYWN0b3J5KChnbG9iYWwubmcgPSBnbG9iYWwubmcgfHwge30sIGdsb2JhbC5uZy5wbGF0Zm9ybUJyb3dzZXJEeW5hbWljID0gZ2xvYmFsLm5nLnBsYXRmb3JtQnJvd3NlckR5bmFtaWMgfHwge30pLGdsb2JhbC5uZy5jb21waWxlcixnbG9iYWwubmcuY29yZSxnbG9iYWwubmcucGxhdGZvcm1Ccm93c2VyKSk7XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzLF9hbmd1bGFyX2NvbXBpbGVyLF9hbmd1bGFyX2NvcmUsX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyKSB7ICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBJTlRFUk5BTF9CUk9XU0VSX1BMQVRGT1JNX1BST1ZJREVSUyA9IF9hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci5fX3BsYXRmb3JtX2Jyb3dzZXJfcHJpdmF0ZV9fLklOVEVSTkFMX0JST1dTRVJfUExBVEZPUk1fUFJPVklERVJTO1xuXG4gICAgdmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIHZhciBSZXNvdXJjZUxvYWRlckltcGwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoUmVzb3VyY2VMb2FkZXJJbXBsLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBSZXNvdXJjZUxvYWRlckltcGwoKSB7XG4gICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBSZXNvdXJjZUxvYWRlckltcGwucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgICAgIHZhciByZXNvbHZlO1xuICAgICAgICAgICAgdmFyIHJlamVjdDtcbiAgICAgICAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlcywgcmVqKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSA9IHJlcztcbiAgICAgICAgICAgICAgICByZWplY3QgPSByZWo7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgIHhoci5vcGVuKCdHRVQnLCB1cmwsIHRydWUpO1xuICAgICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICd0ZXh0JztcbiAgICAgICAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVzcG9uc2VUZXh0IGlzIHRoZSBvbGQtc2Nob29sIHdheSBvZiByZXRyaWV2aW5nIHJlc3BvbnNlIChzdXBwb3J0ZWQgYnkgSUU4ICYgOSlcbiAgICAgICAgICAgICAgICAvLyByZXNwb25zZS9yZXNwb25zZVR5cGUgcHJvcGVydGllcyB3ZXJlIGludHJvZHVjZWQgaW4gUmVzb3VyY2VMb2FkZXIgTGV2ZWwyIHNwZWMgKHN1cHBvcnRlZFxuICAgICAgICAgICAgICAgIC8vIGJ5IElFMTApXG4gICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlID0geGhyLnJlc3BvbnNlIHx8IHhoci5yZXNwb25zZVRleHQ7XG4gICAgICAgICAgICAgICAgLy8gbm9ybWFsaXplIElFOSBidWcgKGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzE0NTApXG4gICAgICAgICAgICAgICAgdmFyIHN0YXR1cyA9IHhoci5zdGF0dXMgPT09IDEyMjMgPyAyMDQgOiB4aHIuc3RhdHVzO1xuICAgICAgICAgICAgICAgIC8vIGZpeCBzdGF0dXMgY29kZSB3aGVuIGl0IGlzIDAgKDAgc3RhdHVzIGlzIHVuZG9jdW1lbnRlZCkuXG4gICAgICAgICAgICAgICAgLy8gT2NjdXJzIHdoZW4gYWNjZXNzaW5nIGZpbGUgcmVzb3VyY2VzIG9yIG9uIEFuZHJvaWQgNC4xIHN0b2NrIGJyb3dzZXJcbiAgICAgICAgICAgICAgICAvLyB3aGlsZSByZXRyaWV2aW5nIGZpbGVzIGZyb20gYXBwbGljYXRpb24gY2FjaGUuXG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMgPSByZXNwb25zZSA/IDIwMCA6IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgyMDAgPD0gc3RhdHVzICYmIHN0YXR1cyA8PSAzMDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoXCJGYWlsZWQgdG8gbG9hZCBcIiArIHVybCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24gKCkgeyByZWplY3QoXCJGYWlsZWQgdG8gbG9hZCBcIiArIHVybCk7IH07XG4gICAgICAgICAgICB4aHIuc2VuZCgpO1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgIH07XG4gICAgICAgIFJlc291cmNlTG9hZGVySW1wbC5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIFJlc291cmNlTG9hZGVySW1wbC5jdG9yUGFyYW1ldGVycyA9IFtdO1xuICAgICAgICByZXR1cm4gUmVzb3VyY2VMb2FkZXJJbXBsO1xuICAgIH0oX2FuZ3VsYXJfY29tcGlsZXIuUmVzb3VyY2VMb2FkZXIpKTtcblxuICAgIHZhciBJTlRFUk5BTF9CUk9XU0VSX0RZTkFNSUNfUExBVEZPUk1fUFJPVklERVJTID0gW1xuICAgICAgICBJTlRFUk5BTF9CUk9XU0VSX1BMQVRGT1JNX1BST1ZJREVSUyxcbiAgICAgICAge1xuICAgICAgICAgICAgcHJvdmlkZTogX2FuZ3VsYXJfY29yZS5DT01QSUxFUl9PUFRJT05TLFxuICAgICAgICAgICAgdXNlVmFsdWU6IHsgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBfYW5ndWxhcl9jb21waWxlci5SZXNvdXJjZUxvYWRlciwgdXNlQ2xhc3M6IFJlc291cmNlTG9hZGVySW1wbCB9XSB9LFxuICAgICAgICAgICAgbXVsdGk6IHRydWVcbiAgICAgICAgfSxcbiAgICBdO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBnbG9iYWxTY29wZTtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZiBpbnN0YW5jZW9mIFdvcmtlckdsb2JhbFNjb3BlKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBSZXBsYWNlIGFueSB3aXRoIFdvcmtlckdsb2JhbFNjb3BlIGZyb20gbGliLndlYndvcmtlci5kLnRzICMzNDkyXG4gICAgICAgICAgICBnbG9iYWxTY29wZSA9IHNlbGY7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBnbG9iYWxTY29wZSA9IGdsb2JhbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ2xvYmFsU2NvcGUgPSB3aW5kb3c7XG4gICAgfVxuICAgIC8vIE5lZWQgdG8gZGVjbGFyZSBhIG5ldyB2YXJpYWJsZSBmb3IgZ2xvYmFsIGhlcmUgc2luY2UgVHlwZVNjcmlwdFxuICAgIC8vIGV4cG9ydHMgdGhlIG9yaWdpbmFsIHZhbHVlIG9mIHRoZSBzeW1ib2wuXG4gICAgdmFyIF9nbG9iYWwgPSBnbG9iYWxTY29wZTtcbiAgICAvLyBUT0RPOiByZW1vdmUgY2FsbHMgdG8gYXNzZXJ0IGluIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRcbiAgICAvLyBOb3RlOiBDYW4ndCBqdXN0IGV4cG9ydCB0aGlzIGFuZCBpbXBvcnQgaW4gaW4gb3RoZXIgZmlsZXNcbiAgICAvLyBhcyBgYXNzZXJ0YCBpcyBhIHJlc2VydmVkIGtleXdvcmQgaW4gRGFydFxuICAgIF9nbG9iYWwuYXNzZXJ0ID0gZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbikge1xuICAgICAgICAvLyBUT0RPOiB0byBiZSBmaXhlZCBwcm9wZXJseSB2aWEgIzI4MzAsIG5vb3AgZm9yIG5vd1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQxID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQW4gaW1wbGVtZW50YXRpb24gb2YgUmVzb3VyY2VMb2FkZXIgdGhhdCB1c2VzIGEgdGVtcGxhdGUgY2FjaGUgdG8gYXZvaWQgZG9pbmcgYW4gYWN0dWFsXG4gICAgICogUmVzb3VyY2VMb2FkZXIuXG4gICAgICpcbiAgICAgKiBUaGUgdGVtcGxhdGUgY2FjaGUgbmVlZHMgdG8gYmUgYnVpbHQgYW5kIGxvYWRlZCBpbnRvIHdpbmRvdy4kdGVtcGxhdGVDYWNoZVxuICAgICAqIHZpYSBhIHNlcGFyYXRlIG1lY2hhbmlzbS5cbiAgICAgKi9cbiAgICB2YXIgQ2FjaGVkUmVzb3VyY2VMb2FkZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMShDYWNoZWRSZXNvdXJjZUxvYWRlciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gQ2FjaGVkUmVzb3VyY2VMb2FkZXIoKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlID0gX2dsb2JhbC4kdGVtcGxhdGVDYWNoZTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jYWNoZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYWNoZWRSZXNvdXJjZUxvYWRlcjogVGVtcGxhdGUgY2FjaGUgd2FzIG5vdCBmb3VuZCBpbiAkdGVtcGxhdGVDYWNoZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBDYWNoZWRSZXNvdXJjZUxvYWRlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHVybCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2NhY2hlLmhhc093blByb3BlcnR5KHVybCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2NhY2hlW3VybF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdDYWNoZWRSZXNvdXJjZUxvYWRlcjogRGlkIG5vdCBmaW5kIGNhY2hlZCB0ZW1wbGF0ZSBmb3IgJyArIHVybCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBDYWNoZWRSZXNvdXJjZUxvYWRlcjtcbiAgICB9KF9hbmd1bGFyX2NvbXBpbGVyLlJlc291cmNlTG9hZGVyKSk7XG5cbiAgICB2YXIgX19wbGF0Zm9ybV9icm93c2VyX2R5bmFtaWNfcHJpdmF0ZV9fID0ge1xuICAgICAgICBJTlRFUk5BTF9CUk9XU0VSX0RZTkFNSUNfUExBVEZPUk1fUFJPVklERVJTOiBJTlRFUk5BTF9CUk9XU0VSX0RZTkFNSUNfUExBVEZPUk1fUFJPVklERVJTLFxuICAgICAgICBSZXNvdXJjZUxvYWRlckltcGw6IFJlc291cmNlTG9hZGVySW1wbFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgdmFyIFJFU09VUkNFX0NBQ0hFX1BST1ZJREVSID0gW3sgcHJvdmlkZTogX2FuZ3VsYXJfY29tcGlsZXIuUmVzb3VyY2VMb2FkZXIsIHVzZUNsYXNzOiBDYWNoZWRSZXNvdXJjZUxvYWRlciB9XTtcbiAgICAvKipcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIHBsYXRmb3JtQnJvd3NlckR5bmFtaWMgPSBfYW5ndWxhcl9jb3JlLmNyZWF0ZVBsYXRmb3JtRmFjdG9yeShfYW5ndWxhcl9jb21waWxlci5wbGF0Zm9ybUNvcmVEeW5hbWljLCAnYnJvd3NlckR5bmFtaWMnLCBJTlRFUk5BTF9CUk9XU0VSX0RZTkFNSUNfUExBVEZPUk1fUFJPVklERVJTKTtcblxuICAgIGV4cG9ydHMuUkVTT1VSQ0VfQ0FDSEVfUFJPVklERVIgPSBSRVNPVVJDRV9DQUNIRV9QUk9WSURFUjtcbiAgICBleHBvcnRzLnBsYXRmb3JtQnJvd3NlckR5bmFtaWMgPSBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljO1xuICAgIGV4cG9ydHMuX19wbGF0Zm9ybV9icm93c2VyX2R5bmFtaWNfcHJpdmF0ZV9fID0gX19wbGF0Zm9ybV9icm93c2VyX2R5bmFtaWNfcHJpdmF0ZV9fO1xuXG59KSk7XG4iLCIvKipcbiAqIEBsaWNlbnNlIEFuZ3VsYXIgdjIuMS4xXG4gKiAoYykgMjAxMC0yMDE2IEdvb2dsZSwgSW5jLiBodHRwczovL2FuZ3VsYXIuaW8vXG4gKiBMaWNlbnNlOiBNSVRcbiAqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMsIHJlcXVpcmUoJ0Bhbmd1bGFyL2NvbW1vbicpLCByZXF1aXJlKCdAYW5ndWxhci9jb3JlJykpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ0Bhbmd1bGFyL2NvbW1vbicsICdAYW5ndWxhci9jb3JlJ10sIGZhY3RvcnkpIDpcbiAgICAoZmFjdG9yeSgoZ2xvYmFsLm5nID0gZ2xvYmFsLm5nIHx8IHt9LCBnbG9iYWwubmcucGxhdGZvcm1Ccm93c2VyID0gZ2xvYmFsLm5nLnBsYXRmb3JtQnJvd3NlciB8fCB7fSksZ2xvYmFsLm5nLmNvbW1vbixnbG9iYWwubmcuY29yZSkpO1xufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cyxfYW5ndWxhcl9jb21tb24sX2FuZ3VsYXJfY29yZSkgeyAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgRGVidWdEb21Sb290UmVuZGVyZXIgPSBfYW5ndWxhcl9jb3JlLl9fY29yZV9wcml2YXRlX18uRGVidWdEb21Sb290UmVuZGVyZXI7XG4gICAgdmFyIE5vT3BBbmltYXRpb25QbGF5ZXIgPSBfYW5ndWxhcl9jb3JlLl9fY29yZV9wcml2YXRlX18uTm9PcEFuaW1hdGlvblBsYXllcjtcblxuICAgIHZhciBfTm9PcEFuaW1hdGlvbkRyaXZlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIF9Ob09wQW5pbWF0aW9uRHJpdmVyKCkge1xuICAgICAgICB9XG4gICAgICAgIF9Ob09wQW5pbWF0aW9uRHJpdmVyLnByb3RvdHlwZS5hbmltYXRlID0gZnVuY3Rpb24gKGVsZW1lbnQsIHN0YXJ0aW5nU3R5bGVzLCBrZXlmcmFtZXMsIGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE5vT3BBbmltYXRpb25QbGF5ZXIoKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF9Ob09wQW5pbWF0aW9uRHJpdmVyO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBBbmltYXRpb25Ecml2ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBBbmltYXRpb25Ecml2ZXIoKSB7XG4gICAgICAgIH1cbiAgICAgICAgQW5pbWF0aW9uRHJpdmVyLk5PT1AgPSBuZXcgX05vT3BBbmltYXRpb25Ecml2ZXIoKTtcbiAgICAgICAgcmV0dXJuIEFuaW1hdGlvbkRyaXZlcjtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBnbG9iYWxTY29wZTtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZiBpbnN0YW5jZW9mIFdvcmtlckdsb2JhbFNjb3BlKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBSZXBsYWNlIGFueSB3aXRoIFdvcmtlckdsb2JhbFNjb3BlIGZyb20gbGliLndlYndvcmtlci5kLnRzICMzNDkyXG4gICAgICAgICAgICBnbG9iYWxTY29wZSA9IHNlbGY7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBnbG9iYWxTY29wZSA9IGdsb2JhbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ2xvYmFsU2NvcGUgPSB3aW5kb3c7XG4gICAgfVxuICAgIC8vIE5lZWQgdG8gZGVjbGFyZSBhIG5ldyB2YXJpYWJsZSBmb3IgZ2xvYmFsIGhlcmUgc2luY2UgVHlwZVNjcmlwdFxuICAgIC8vIGV4cG9ydHMgdGhlIG9yaWdpbmFsIHZhbHVlIG9mIHRoZSBzeW1ib2wuXG4gICAgdmFyIGdsb2JhbCQxID0gZ2xvYmFsU2NvcGU7XG4gICAgLy8gVE9ETzogcmVtb3ZlIGNhbGxzIHRvIGFzc2VydCBpbiBwcm9kdWN0aW9uIGVudmlyb25tZW50XG4gICAgLy8gTm90ZTogQ2FuJ3QganVzdCBleHBvcnQgdGhpcyBhbmQgaW1wb3J0IGluIGluIG90aGVyIGZpbGVzXG4gICAgLy8gYXMgYGFzc2VydGAgaXMgYSByZXNlcnZlZCBrZXl3b3JkIGluIERhcnRcbiAgICBnbG9iYWwkMS5hc3NlcnQgPSBmdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uKSB7XG4gICAgICAgIC8vIFRPRE86IHRvIGJlIGZpeGVkIHByb3Blcmx5IHZpYSAjMjgzMCwgbm9vcCBmb3Igbm93XG4gICAgfTtcbiAgICBmdW5jdGlvbiBpc1ByZXNlbnQob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogIT09IHVuZGVmaW5lZCAmJiBvYmogIT09IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzQmxhbmsob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogPT09IHVuZGVmaW5lZCB8fCBvYmogPT09IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0cmluZ2lmeSh0b2tlbikge1xuICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbiA9PT0gdW5kZWZpbmVkIHx8IHRva2VuID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gJycgKyB0b2tlbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW4ub3ZlcnJpZGRlbk5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbi5vdmVycmlkZGVuTmFtZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW4ubmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuLm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlcyA9IHRva2VuLnRvU3RyaW5nKCk7XG4gICAgICAgIHZhciBuZXdMaW5lSW5kZXggPSByZXMuaW5kZXhPZignXFxuJyk7XG4gICAgICAgIHJldHVybiBuZXdMaW5lSW5kZXggPT09IC0xID8gcmVzIDogcmVzLnN1YnN0cmluZygwLCBuZXdMaW5lSW5kZXgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRWYWx1ZU9uUGF0aChnbG9iYWwsIHBhdGgsIHZhbHVlKSB7XG4gICAgICAgIHZhciBwYXJ0cyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgICAgICAgdmFyIG9iaiA9IGdsb2JhbDtcbiAgICAgICAgd2hpbGUgKHBhcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gcGFydHMuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkobmFtZSkgJiYgaXNQcmVzZW50KG9ialtuYW1lXSkpIHtcbiAgICAgICAgICAgICAgICBvYmogPSBvYmpbbmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvYmogPSBvYmpbbmFtZV0gPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqID09PSB1bmRlZmluZWQgfHwgb2JqID09PSBudWxsKSB7XG4gICAgICAgICAgICBvYmogPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBvYmpbcGFydHMuc2hpZnQoKV0gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIENBTUVMX0NBU0VfUkVHRVhQID0gLyhbQS1aXSkvZztcbiAgICB2YXIgREFTSF9DQVNFX1JFR0VYUCA9IC8tKFthLXpdKS9nO1xuICAgIGZ1bmN0aW9uIGNhbWVsQ2FzZVRvRGFzaENhc2UoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoQ0FNRUxfQ0FTRV9SRUdFWFAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIG1bX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJy0nICsgbVsxXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGFzaENhc2VUb0NhbWVsQ2FzZShpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQucmVwbGFjZShEQVNIX0NBU0VfUkVHRVhQLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbSA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBtW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1bMV0udG9VcHBlckNhc2UoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfRE9NID0gbnVsbDtcbiAgICBmdW5jdGlvbiBnZXRET00oKSB7XG4gICAgICAgIHJldHVybiBfRE9NO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRSb290RG9tQWRhcHRlcihhZGFwdGVyKSB7XG4gICAgICAgIGlmICghX0RPTSkge1xuICAgICAgICAgICAgX0RPTSA9IGFkYXB0ZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyogdHNsaW50OmRpc2FibGU6cmVxdWlyZVBhcmFtZXRlclR5cGUgKi9cbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyBET00gb3BlcmF0aW9ucyBpbiBhbiBlbnZpcm9ubWVudC1hZ25vc3RpYyB3YXkuXG4gICAgICpcbiAgICAgKiBAc2VjdXJpdHkgVHJlYWQgY2FyZWZ1bGx5ISBJbnRlcmFjdGluZyB3aXRoIHRoZSBET00gZGlyZWN0bHkgaXMgZGFuZ2Vyb3VzIGFuZFxuICAgICAqIGNhbiBpbnRyb2R1Y2UgWFNTIHJpc2tzLlxuICAgICAqL1xuICAgIHZhciBEb21BZGFwdGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gRG9tQWRhcHRlcigpIHtcbiAgICAgICAgICAgIHRoaXMucmVzb3VyY2VMb2FkZXJUeXBlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRG9tQWRhcHRlci5wcm90b3R5cGUsIFwiYXR0clRvUHJvcE1hcFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE1hcHMgYXR0cmlidXRlIG5hbWVzIHRvIHRoZWlyIGNvcnJlc3BvbmRpbmcgcHJvcGVydHkgbmFtZXMgZm9yIGNhc2VzXG4gICAgICAgICAgICAgKiB3aGVyZSBhdHRyaWJ1dGUgbmFtZSBkb2Vzbid0IG1hdGNoIHByb3BlcnR5IG5hbWUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fYXR0clRvUHJvcE1hcDsgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuX2F0dHJUb1Byb3BNYXAgPSB2YWx1ZTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIDtcbiAgICAgICAgO1xuICAgICAgICByZXR1cm4gRG9tQWRhcHRlcjtcbiAgICB9KCkpO1xuXG4gICAgdmFyIFdlYkFuaW1hdGlvbnNQbGF5ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBXZWJBbmltYXRpb25zUGxheWVyKGVsZW1lbnQsIGtleWZyYW1lcywgb3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgICAgIHRoaXMua2V5ZnJhbWVzID0ga2V5ZnJhbWVzO1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgICAgIHRoaXMuX29uRG9uZUZucyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fb25TdGFydEZucyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnBhcmVudFBsYXllciA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9kdXJhdGlvbiA9IG9wdGlvbnNbJ2R1cmF0aW9uJ107XG4gICAgICAgIH1cbiAgICAgICAgV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUuX29uRmluaXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9maW5pc2hlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzUHJlc2VudCh0aGlzLnBhcmVudFBsYXllcikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX29uRG9uZUZucy5mb3JFYWNoKGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oKTsgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25Eb25lRm5zID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFdlYkFuaW1hdGlvbnNQbGF5ZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2luaXRpYWxpemVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBrZXlmcmFtZXMgPSB0aGlzLmtleWZyYW1lcy5tYXAoZnVuY3Rpb24gKHN0eWxlcykge1xuICAgICAgICAgICAgICAgIHZhciBmb3JtYXR0ZWRLZXlmcmFtZSA9IHt9O1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHN0eWxlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBzdHlsZXNbcHJvcF07XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlZEtleWZyYW1lW3Byb3BdID0gdmFsdWUgPT0gX2FuZ3VsYXJfY29yZS5BVVRPX1NUWUxFID8gX2NvbXB1dGVTdHlsZShfdGhpcy5lbGVtZW50LCBwcm9wKSA6IHZhbHVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXR0ZWRLZXlmcmFtZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fcGxheWVyID0gdGhpcy5fdHJpZ2dlcldlYkFuaW1hdGlvbih0aGlzLmVsZW1lbnQsIGtleWZyYW1lcywgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgcmVxdWlyZWQgc28gdGhhdCB0aGUgcGxheWVyIGRvZXNuJ3Qgc3RhcnQgdG8gYW5pbWF0ZSByaWdodCBhd2F5XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICB0aGlzLl9wbGF5ZXIub25maW5pc2ggPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fb25GaW5pc2goKTsgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBXZWJBbmltYXRpb25zUGxheWVyLnByb3RvdHlwZS5fdHJpZ2dlcldlYkFuaW1hdGlvbiA9IGZ1bmN0aW9uIChlbGVtZW50LCBrZXlmcmFtZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50LmFuaW1hdGUoa2V5ZnJhbWVzLCBvcHRpb25zKTtcbiAgICAgICAgfTtcbiAgICAgICAgV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUub25TdGFydCA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLl9vblN0YXJ0Rm5zLnB1c2goZm4pOyB9O1xuICAgICAgICBXZWJBbmltYXRpb25zUGxheWVyLnByb3RvdHlwZS5vbkRvbmUgPSBmdW5jdGlvbiAoZm4pIHsgdGhpcy5fb25Eb25lRm5zLnB1c2goZm4pOyB9O1xuICAgICAgICBXZWJBbmltYXRpb25zUGxheWVyLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaGFzU3RhcnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25TdGFydEZucy5mb3JFYWNoKGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oKTsgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25TdGFydEZucyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcGxheWVyLnBsYXkoKTtcbiAgICAgICAgfTtcbiAgICAgICAgV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgICAgIHRoaXMuX3BsYXllci5wYXVzZSgpO1xuICAgICAgICB9O1xuICAgICAgICBXZWJBbmltYXRpb25zUGxheWVyLnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgICAgIHRoaXMuX29uRmluaXNoKCk7XG4gICAgICAgICAgICB0aGlzLl9wbGF5ZXIuZmluaXNoKCk7XG4gICAgICAgIH07XG4gICAgICAgIFdlYkFuaW1hdGlvbnNQbGF5ZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9wbGF5ZXIuY2FuY2VsKCk7IH07XG4gICAgICAgIFdlYkFuaW1hdGlvbnNQbGF5ZXIucHJvdG90eXBlLnJlc3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICB0aGlzLnBsYXkoKTtcbiAgICAgICAgfTtcbiAgICAgICAgV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUuaGFzU3RhcnRlZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3N0YXJ0ZWQ7IH07XG4gICAgICAgIFdlYkFuaW1hdGlvbnNQbGF5ZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICB0aGlzLl9vbkZpbmlzaCgpO1xuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUsIFwidG90YWxUaW1lXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZHVyYXRpb247IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBXZWJBbmltYXRpb25zUGxheWVyLnByb3RvdHlwZS5zZXRQb3NpdGlvbiA9IGZ1bmN0aW9uIChwKSB7IHRoaXMuX3BsYXllci5jdXJyZW50VGltZSA9IHAgKiB0aGlzLnRvdGFsVGltZTsgfTtcbiAgICAgICAgV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUuZ2V0UG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wbGF5ZXIuY3VycmVudFRpbWUgLyB0aGlzLnRvdGFsVGltZTsgfTtcbiAgICAgICAgcmV0dXJuIFdlYkFuaW1hdGlvbnNQbGF5ZXI7XG4gICAgfSgpKTtcbiAgICBmdW5jdGlvbiBfY29tcHV0ZVN0eWxlKGVsZW1lbnQsIHByb3ApIHtcbiAgICAgICAgcmV0dXJuIGdldERPTSgpLmdldENvbXB1dGVkU3R5bGUoZWxlbWVudClbcHJvcF07XG4gICAgfVxuXG4gICAgdmFyIFdlYkFuaW1hdGlvbnNEcml2ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBXZWJBbmltYXRpb25zRHJpdmVyKCkge1xuICAgICAgICB9XG4gICAgICAgIFdlYkFuaW1hdGlvbnNEcml2ZXIucHJvdG90eXBlLmFuaW1hdGUgPSBmdW5jdGlvbiAoZWxlbWVudCwgc3RhcnRpbmdTdHlsZXMsIGtleWZyYW1lcywgZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcpIHtcbiAgICAgICAgICAgIHZhciBmb3JtYXR0ZWRTdGVwcyA9IFtdO1xuICAgICAgICAgICAgdmFyIHN0YXJ0aW5nU3R5bGVMb29rdXAgPSB7fTtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoc3RhcnRpbmdTdHlsZXMpICYmIHN0YXJ0aW5nU3R5bGVzLnN0eWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRpbmdTdHlsZUxvb2t1cCA9IF9wb3B1bGF0ZVN0eWxlcyhlbGVtZW50LCBzdGFydGluZ1N0eWxlcywge30pO1xuICAgICAgICAgICAgICAgIHN0YXJ0aW5nU3R5bGVMb29rdXBbJ29mZnNldCddID0gMDtcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWRTdGVwcy5wdXNoKHN0YXJ0aW5nU3R5bGVMb29rdXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAga2V5ZnJhbWVzLmZvckVhY2goZnVuY3Rpb24gKGtleWZyYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBfcG9wdWxhdGVTdHlsZXMoZWxlbWVudCwga2V5ZnJhbWUuc3R5bGVzLCBzdGFydGluZ1N0eWxlTG9va3VwKTtcbiAgICAgICAgICAgICAgICBkYXRhWydvZmZzZXQnXSA9IGtleWZyYW1lLm9mZnNldDtcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWRTdGVwcy5wdXNoKGRhdGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIGEgc3BlY2lhbCBjYXNlIHdoZW4gb25seSBzdHlsZXMgYXJlIGFwcGxpZWQgYXMgYW5cbiAgICAgICAgICAgIC8vIGFuaW1hdGlvbi4gV2hlbiB0aGlzIG9jY3VycyB3ZSB3YW50IHRvIGFuaW1hdGUgZnJvbSBzdGFydCB0b1xuICAgICAgICAgICAgLy8gZW5kIHdpdGggdGhlIHNhbWUgdmFsdWVzLiBSZW1vdmluZyB0aGUgb2Zmc2V0IGFuZCBoYXZpbmcgb25seVxuICAgICAgICAgICAgLy8gc3RhcnQvZW5kIHZhbHVlcyBpcyBzdWl0YWJsZSBlbm91Z2ggZm9yIHRoZSB3ZWItYW5pbWF0aW9ucyBBUElcbiAgICAgICAgICAgIGlmIChmb3JtYXR0ZWRTdGVwcy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IGZvcm1hdHRlZFN0ZXBzWzBdO1xuICAgICAgICAgICAgICAgIHN0YXJ0WydvZmZzZXQnXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkU3RlcHMgPSBbc3RhcnQsIHN0YXJ0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwbGF5ZXJPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICdkdXJhdGlvbic6IGR1cmF0aW9uLFxuICAgICAgICAgICAgICAgICdkZWxheSc6IGRlbGF5LFxuICAgICAgICAgICAgICAgICdmaWxsJzogJ2JvdGgnIC8vIHdlIHVzZSBgYm90aGAgYmVjYXVzZSBpdCBhbGxvd3MgZm9yIHN0eWxpbmcgYXQgMCUgdG8gd29yayB3aXRoIGBkZWxheWBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyB3ZSBjaGVjayBmb3IgdGhpcyB0byBhdm9pZCBoYXZpbmcgYSBudWxsfHVuZGVmaW5lZCB2YWx1ZSBiZSBwcmVzZW50XG4gICAgICAgICAgICAvLyBmb3IgdGhlIGVhc2luZyAod2hpY2ggcmVzdWx0cyBpbiBhbiBlcnJvciBmb3IgY2VydGFpbiBicm93c2VycyAjOTc1MilcbiAgICAgICAgICAgIGlmIChlYXNpbmcpIHtcbiAgICAgICAgICAgICAgICBwbGF5ZXJPcHRpb25zWydlYXNpbmcnXSA9IGVhc2luZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgV2ViQW5pbWF0aW9uc1BsYXllcihlbGVtZW50LCBmb3JtYXR0ZWRTdGVwcywgcGxheWVyT3B0aW9ucyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBXZWJBbmltYXRpb25zRHJpdmVyO1xuICAgIH0oKSk7XG4gICAgZnVuY3Rpb24gX3BvcHVsYXRlU3R5bGVzKGVsZW1lbnQsIHN0eWxlcywgZGVmYXVsdFN0eWxlcykge1xuICAgICAgICB2YXIgZGF0YSA9IHt9O1xuICAgICAgICBzdHlsZXMuc3R5bGVzLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhlbnRyeSkuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgICAgIHZhciB2YWwgPSBlbnRyeVtwcm9wXTtcbiAgICAgICAgICAgICAgICB2YXIgZm9ybWF0dGVkUHJvcCA9IGRhc2hDYXNlVG9DYW1lbENhc2UocHJvcCk7XG4gICAgICAgICAgICAgICAgZGF0YVtmb3JtYXR0ZWRQcm9wXSA9XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9PSBfYW5ndWxhcl9jb3JlLkFVVE9fU1RZTEUgPyB2YWwgOiB2YWwudG9TdHJpbmcoKSArIF9yZXNvbHZlU3R5bGVVbml0KHZhbCwgcHJvcCwgZm9ybWF0dGVkUHJvcCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5rZXlzKGRlZmF1bHRTdHlsZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgIGlmICghaXNQcmVzZW50KGRhdGFbcHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgZGF0YVtwcm9wXSA9IGRlZmF1bHRTdHlsZXNbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX3Jlc29sdmVTdHlsZVVuaXQodmFsLCB1c2VyUHJvdmlkZWRQcm9wLCBmb3JtYXR0ZWRQcm9wKSB7XG4gICAgICAgIHZhciB1bml0ID0gJyc7XG4gICAgICAgIGlmIChfaXNQaXhlbERpbWVuc2lvblN0eWxlKGZvcm1hdHRlZFByb3ApICYmIHZhbCAhPSAwICYmIHZhbCAhPSAnMCcpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHVuaXQgPSAncHgnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoX2ZpbmREaW1lbnNpb25hbFN1ZmZpeCh2YWwudG9TdHJpbmcoKSkubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBwcm92aWRlIGEgQ1NTIHVuaXQgdmFsdWUgZm9yICcgKyB1c2VyUHJvdmlkZWRQcm9wICsgJzonICsgdmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5pdDtcbiAgICB9XG4gICAgdmFyIF8kMCA9IDQ4O1xuICAgIHZhciBfJDkgPSA1NztcbiAgICB2YXIgXyRQRVJJT0QgPSA0NjtcbiAgICBmdW5jdGlvbiBfZmluZERpbWVuc2lvbmFsU3VmZml4KHZhbHVlKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjID0gdmFsdWUuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIGlmICgoYyA+PSBfJDAgJiYgYyA8PSBfJDkpIHx8IGMgPT0gXyRQRVJJT0QpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUuc3Vic3RyaW5nKGksIHZhbHVlLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfaXNQaXhlbERpbWVuc2lvblN0eWxlKHByb3ApIHtcbiAgICAgICAgc3dpdGNoIChwcm9wKSB7XG4gICAgICAgICAgICBjYXNlICd3aWR0aCc6XG4gICAgICAgICAgICBjYXNlICdoZWlnaHQnOlxuICAgICAgICAgICAgY2FzZSAnbWluV2lkdGgnOlxuICAgICAgICAgICAgY2FzZSAnbWluSGVpZ2h0JzpcbiAgICAgICAgICAgIGNhc2UgJ21heFdpZHRoJzpcbiAgICAgICAgICAgIGNhc2UgJ21heEhlaWdodCc6XG4gICAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgY2FzZSAnZm9udFNpemUnOlxuICAgICAgICAgICAgY2FzZSAnb3V0bGluZVdpZHRoJzpcbiAgICAgICAgICAgIGNhc2UgJ291dGxpbmVPZmZzZXQnOlxuICAgICAgICAgICAgY2FzZSAncGFkZGluZ1RvcCc6XG4gICAgICAgICAgICBjYXNlICdwYWRkaW5nTGVmdCc6XG4gICAgICAgICAgICBjYXNlICdwYWRkaW5nQm90dG9tJzpcbiAgICAgICAgICAgIGNhc2UgJ3BhZGRpbmdSaWdodCc6XG4gICAgICAgICAgICBjYXNlICdtYXJnaW5Ub3AnOlxuICAgICAgICAgICAgY2FzZSAnbWFyZ2luTGVmdCc6XG4gICAgICAgICAgICBjYXNlICdtYXJnaW5Cb3R0b20nOlxuICAgICAgICAgICAgY2FzZSAnbWFyZ2luUmlnaHQnOlxuICAgICAgICAgICAgY2FzZSAnYm9yZGVyUmFkaXVzJzpcbiAgICAgICAgICAgIGNhc2UgJ2JvcmRlcldpZHRoJzpcbiAgICAgICAgICAgIGNhc2UgJ2JvcmRlclRvcFdpZHRoJzpcbiAgICAgICAgICAgIGNhc2UgJ2JvcmRlckxlZnRXaWR0aCc6XG4gICAgICAgICAgICBjYXNlICdib3JkZXJSaWdodFdpZHRoJzpcbiAgICAgICAgICAgIGNhc2UgJ2JvcmRlckJvdHRvbVdpZHRoJzpcbiAgICAgICAgICAgIGNhc2UgJ3RleHRJbmRlbnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQxID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgRE9NIG9wZXJhdGlvbnMgaW4gYW55IGJyb3dzZXIgZW52aXJvbm1lbnQuXG4gICAgICpcbiAgICAgKiBAc2VjdXJpdHkgVHJlYWQgY2FyZWZ1bGx5ISBJbnRlcmFjdGluZyB3aXRoIHRoZSBET00gZGlyZWN0bHkgaXMgZGFuZ2Vyb3VzIGFuZFxuICAgICAqIGNhbiBpbnRyb2R1Y2UgWFNTIHJpc2tzLlxuICAgICAqL1xuICAgIHZhciBHZW5lcmljQnJvd3NlckRvbUFkYXB0ZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMShHZW5lcmljQnJvd3NlckRvbUFkYXB0ZXIsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEdlbmVyaWNCcm93c2VyRG9tQWRhcHRlcigpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX2FuaW1hdGlvblByZWZpeCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uRW5kID0gbnVsbDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnRfMSA9IHRoaXMuY3JlYXRlRWxlbWVudCgnZGl2JywgdGhpcy5kZWZhdWx0RG9jKCkpO1xuICAgICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5nZXRTdHlsZShlbGVtZW50XzEsICdhbmltYXRpb25OYW1lJykpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FuaW1hdGlvblByZWZpeCA9ICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRvbVByZWZpeGVzID0gWydXZWJraXQnLCAnTW96JywgJ08nLCAnbXMnXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkb21QcmVmaXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmdldFN0eWxlKGVsZW1lbnRfMSwgZG9tUHJlZml4ZXNbaV0gKyAnQW5pbWF0aW9uTmFtZScpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FuaW1hdGlvblByZWZpeCA9ICctJyArIGRvbVByZWZpeGVzW2ldLnRvTG93ZXJDYXNlKCkgKyAnLSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zRW5kRXZlbnROYW1lc18xID0ge1xuICAgICAgICAgICAgICAgICAgICBXZWJraXRUcmFuc2l0aW9uOiAnd2Via2l0VHJhbnNpdGlvbkVuZCcsXG4gICAgICAgICAgICAgICAgICAgIE1velRyYW5zaXRpb246ICd0cmFuc2l0aW9uZW5kJyxcbiAgICAgICAgICAgICAgICAgICAgT1RyYW5zaXRpb246ICdvVHJhbnNpdGlvbkVuZCBvdHJhbnNpdGlvbmVuZCcsXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb246ICd0cmFuc2l0aW9uZW5kJ1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXModHJhbnNFbmRFdmVudE5hbWVzXzEpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KF90aGlzLmdldFN0eWxlKGVsZW1lbnRfMSwga2V5KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl90cmFuc2l0aW9uRW5kID0gdHJhbnNFbmRFdmVudE5hbWVzXzFba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hbmltYXRpb25QcmVmaXggPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb25FbmQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIEdlbmVyaWNCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0RGlzdHJpYnV0ZWROb2RlcyA9IGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gZWwuZ2V0RGlzdHJpYnV0ZWROb2RlcygpOyB9O1xuICAgICAgICBHZW5lcmljQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnJlc29sdmVBbmRTZXRIcmVmID0gZnVuY3Rpb24gKGVsLCBiYXNlVXJsLCBocmVmKSB7XG4gICAgICAgICAgICBlbC5ocmVmID0gaHJlZiA9PSBudWxsID8gYmFzZVVybCA6IGJhc2VVcmwgKyAnLy4uLycgKyBocmVmO1xuICAgICAgICB9O1xuICAgICAgICBHZW5lcmljQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnN1cHBvcnRzRE9NRXZlbnRzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfTtcbiAgICAgICAgR2VuZXJpY0Jyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5zdXBwb3J0c05hdGl2ZVNoYWRvd0RPTSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdGhpcy5kZWZhdWx0RG9jKCkuYm9keS5jcmVhdGVTaGFkb3dSb290ID09PSAnZnVuY3Rpb24nO1xuICAgICAgICB9O1xuICAgICAgICBHZW5lcmljQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldEFuaW1hdGlvblByZWZpeCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2FuaW1hdGlvblByZWZpeCA/IHRoaXMuX2FuaW1hdGlvblByZWZpeCA6ICcnOyB9O1xuICAgICAgICBHZW5lcmljQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldFRyYW5zaXRpb25FbmQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl90cmFuc2l0aW9uRW5kID8gdGhpcy5fdHJhbnNpdGlvbkVuZCA6ICcnOyB9O1xuICAgICAgICBHZW5lcmljQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnN1cHBvcnRzQW5pbWF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLl9hbmltYXRpb25QcmVmaXgpICYmIGlzUHJlc2VudCh0aGlzLl90cmFuc2l0aW9uRW5kKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEdlbmVyaWNCcm93c2VyRG9tQWRhcHRlcjtcbiAgICB9KERvbUFkYXB0ZXIpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgdmFyIF9hdHRyVG9Qcm9wTWFwID0ge1xuICAgICAgICAnY2xhc3MnOiAnY2xhc3NOYW1lJyxcbiAgICAgICAgJ2lubmVySHRtbCc6ICdpbm5lckhUTUwnLFxuICAgICAgICAncmVhZG9ubHknOiAncmVhZE9ubHknLFxuICAgICAgICAndGFiaW5kZXgnOiAndGFiSW5kZXgnLFxuICAgIH07XG4gICAgdmFyIERPTV9LRVlfTE9DQVRJT05fTlVNUEFEID0gMztcbiAgICAvLyBNYXAgdG8gY29udmVydCBzb21lIGtleSBvciBrZXlJZGVudGlmaWVyIHZhbHVlcyB0byB3aGF0IHdpbGwgYmUgcmV0dXJuZWQgYnkgZ2V0RXZlbnRLZXlcbiAgICB2YXIgX2tleU1hcCA9IHtcbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyB2YWx1ZXMgYXJlIGhlcmUgZm9yIGNyb3NzLWJyb3dzZXIgY29tcGF0aWJpbGl0eSBhbmQgdG8gbWF0Y2ggdGhlIFczQyBzdGFuZGFyZFxuICAgICAgICAvLyBjZiBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMta2V5L1xuICAgICAgICAnXFxiJzogJ0JhY2tzcGFjZScsXG4gICAgICAgICdcXHQnOiAnVGFiJyxcbiAgICAgICAgJ1xceDdGJzogJ0RlbGV0ZScsXG4gICAgICAgICdcXHgxQic6ICdFc2NhcGUnLFxuICAgICAgICAnRGVsJzogJ0RlbGV0ZScsXG4gICAgICAgICdFc2MnOiAnRXNjYXBlJyxcbiAgICAgICAgJ0xlZnQnOiAnQXJyb3dMZWZ0JyxcbiAgICAgICAgJ1JpZ2h0JzogJ0Fycm93UmlnaHQnLFxuICAgICAgICAnVXAnOiAnQXJyb3dVcCcsXG4gICAgICAgICdEb3duJzogJ0Fycm93RG93bicsXG4gICAgICAgICdNZW51JzogJ0NvbnRleHRNZW51JyxcbiAgICAgICAgJ1Njcm9sbCc6ICdTY3JvbGxMb2NrJyxcbiAgICAgICAgJ1dpbic6ICdPUydcbiAgICB9O1xuICAgIC8vIFRoZXJlIGlzIGEgYnVnIGluIENocm9tZSBmb3IgbnVtZXJpYyBrZXlwYWQga2V5czpcbiAgICAvLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MTU1NjU0XG4gICAgLy8gMSwgMiwgMyAuLi4gYXJlIHJlcG9ydGVkIGFzIEEsIEIsIEMgLi4uXG4gICAgdmFyIF9jaHJvbWVOdW1LZXlQYWRNYXAgPSB7XG4gICAgICAgICdBJzogJzEnLFxuICAgICAgICAnQic6ICcyJyxcbiAgICAgICAgJ0MnOiAnMycsXG4gICAgICAgICdEJzogJzQnLFxuICAgICAgICAnRSc6ICc1JyxcbiAgICAgICAgJ0YnOiAnNicsXG4gICAgICAgICdHJzogJzcnLFxuICAgICAgICAnSCc6ICc4JyxcbiAgICAgICAgJ0knOiAnOScsXG4gICAgICAgICdKJzogJyonLFxuICAgICAgICAnSyc6ICcrJyxcbiAgICAgICAgJ00nOiAnLScsXG4gICAgICAgICdOJzogJy4nLFxuICAgICAgICAnTyc6ICcvJyxcbiAgICAgICAgJ1xceDYwJzogJzAnLFxuICAgICAgICAnXFx4OTAnOiAnTnVtTG9jaydcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgYERvbUFkYXB0ZXJgIHBvd2VyZWQgYnkgZnVsbCBicm93c2VyIERPTSBBUElzLlxuICAgICAqXG4gICAgICogQHNlY3VyaXR5IFRyZWFkIGNhcmVmdWxseSEgSW50ZXJhY3Rpbmcgd2l0aCB0aGUgRE9NIGRpcmVjdGx5IGlzIGRhbmdlcm91cyBhbmRcbiAgICAgKiBjYW4gaW50cm9kdWNlIFhTUyByaXNrcy5cbiAgICAgKi9cbiAgICAvKiB0c2xpbnQ6ZGlzYWJsZTpyZXF1aXJlUGFyYW1ldGVyVHlwZSAqL1xuICAgIHZhciBCcm93c2VyRG9tQWRhcHRlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhCcm93c2VyRG9tQWRhcHRlciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gQnJvd3NlckRvbUFkYXB0ZXIoKSB7XG4gICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAodGVtcGxhdGVIdG1sKSB7IHRocm93IG5ldyBFcnJvcigncGFyc2Ugbm90IGltcGxlbWVudGVkJyk7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLm1ha2VDdXJyZW50ID0gZnVuY3Rpb24gKCkgeyBzZXRSb290RG9tQWRhcHRlcihuZXcgQnJvd3NlckRvbUFkYXB0ZXIoKSk7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5oYXNQcm9wZXJ0eSA9IGZ1bmN0aW9uIChlbGVtZW50LCBuYW1lKSB7IHJldHVybiBuYW1lIGluIGVsZW1lbnQ7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5zZXRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChlbCwgbmFtZSwgdmFsdWUpIHsgZWxbbmFtZV0gPSB2YWx1ZTsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldFByb3BlcnR5ID0gZnVuY3Rpb24gKGVsLCBuYW1lKSB7IHJldHVybiBlbFtuYW1lXTsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmludm9rZSA9IGZ1bmN0aW9uIChlbCwgbWV0aG9kTmFtZSwgYXJncykgeyAoX2EgPSBlbClbbWV0aG9kTmFtZV0uYXBwbHkoX2EsIGFyZ3MpOyB2YXIgX2E7IH07XG4gICAgICAgIC8vIFRPRE8odGJvc2NoKTogbW92ZSB0aGlzIGludG8gYSBzZXBhcmF0ZSBlbnZpcm9ubWVudCBjbGFzcyBvbmNlIHdlIGhhdmUgaXRcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmxvZ0Vycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7ICh3aW5kb3cuY29uc29sZS5lcnJvciB8fCB3aW5kb3cuY29uc29sZS5sb2cpKGVycm9yKTsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uIChlcnJvcikgeyB3aW5kb3cuY29uc29sZS5sb2coZXJyb3IpOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUubG9nR3JvdXAgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHdpbmRvdy5jb25zb2xlLmdyb3VwICYmIHdpbmRvdy5jb25zb2xlLmdyb3VwKGVycm9yKTtcbiAgICAgICAgICAgIHRoaXMubG9nRXJyb3IoZXJyb3IpO1xuICAgICAgICB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUubG9nR3JvdXBFbmQgPSBmdW5jdGlvbiAoKSB7IHdpbmRvdy5jb25zb2xlLmdyb3VwRW5kICYmIHdpbmRvdy5jb25zb2xlLmdyb3VwRW5kKCk7IH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUsIFwiYXR0clRvUHJvcE1hcFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9hdHRyVG9Qcm9wTWFwOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnF1ZXJ5ID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7IHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3IgPSBmdW5jdGlvbiAoZWwsIHNlbGVjdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZWwucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgICAgIH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5xdWVyeVNlbGVjdG9yQWxsID0gZnVuY3Rpb24gKGVsLCBzZWxlY3RvcikgeyByZXR1cm4gZWwucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChlbCwgZXZ0LCBsaXN0ZW5lcikgeyBlbC5hZGRFdmVudExpc3RlbmVyKGV2dCwgbGlzdGVuZXIsIGZhbHNlKTsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLm9uQW5kQ2FuY2VsID0gZnVuY3Rpb24gKGVsLCBldnQsIGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKGV2dCwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgICAgICAgICAgIC8vIE5lZWRlZCB0byBmb2xsb3cgRGFydCdzIHN1YnNjcmlwdGlvbiBzZW1hbnRpYywgdW50aWwgZml4IG9mXG4gICAgICAgICAgICAvLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2RhcnQvaXNzdWVzL2RldGFpbD9pZD0xNzQwNlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnQsIGxpc3RlbmVyLCBmYWxzZSk7IH07XG4gICAgICAgIH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24gKGVsLCBldnQpIHsgZWwuZGlzcGF0Y2hFdmVudChldnQpOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuY3JlYXRlTW91c2VFdmVudCA9IGZ1bmN0aW9uIChldmVudFR5cGUpIHtcbiAgICAgICAgICAgIHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnTW91c2VFdmVudCcpO1xuICAgICAgICAgICAgZXZ0LmluaXRFdmVudChldmVudFR5cGUsIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIGV2dDtcbiAgICAgICAgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmNyZWF0ZUV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50VHlwZSkge1xuICAgICAgICAgICAgdmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgICAgICAgICAgZXZ0LmluaXRFdmVudChldmVudFR5cGUsIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIGV2dDtcbiAgICAgICAgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBldnQucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmlzUHJldmVudGVkID0gZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAgICAgcmV0dXJuIGV2dC5kZWZhdWx0UHJldmVudGVkIHx8IGlzUHJlc2VudChldnQucmV0dXJuVmFsdWUpICYmICFldnQucmV0dXJuVmFsdWU7XG4gICAgICAgIH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5nZXRJbm5lckhUTUwgPSBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIGVsLmlubmVySFRNTDsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldFRlbXBsYXRlQ29udGVudCA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgcmV0dXJuICdjb250ZW50JyBpbiBlbCAmJiBlbCBpbnN0YW5jZW9mIEhUTUxUZW1wbGF0ZUVsZW1lbnQgPyBlbC5jb250ZW50IDogbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldE91dGVySFRNTCA9IGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gZWwub3V0ZXJIVE1MOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUubm9kZU5hbWUgPSBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS5ub2RlTmFtZTsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLm5vZGVWYWx1ZSA9IGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLm5vZGVWYWx1ZTsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnR5cGUgPSBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS50eXBlOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuY29udGVudCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5oYXNQcm9wZXJ0eShub2RlLCAnY29udGVudCcpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuY29udGVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZmlyc3RDaGlsZCA9IGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gZWwuZmlyc3RDaGlsZDsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLm5leHRTaWJsaW5nID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiBlbC5uZXh0U2libGluZzsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnBhcmVudEVsZW1lbnQgPSBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIGVsLnBhcmVudE5vZGU7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5jaGlsZE5vZGVzID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiBlbC5jaGlsZE5vZGVzOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuY2hpbGROb2Rlc0FzTGlzdCA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgdmFyIGNoaWxkTm9kZXMgPSBlbC5jaGlsZE5vZGVzO1xuICAgICAgICAgICAgdmFyIHJlcyA9IG5ldyBBcnJheShjaGlsZE5vZGVzLmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXNbaV0gPSBjaGlsZE5vZGVzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmNsZWFyTm9kZXMgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHdoaWxlIChlbC5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgZWwucmVtb3ZlQ2hpbGQoZWwuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5hcHBlbmRDaGlsZCA9IGZ1bmN0aW9uIChlbCwgbm9kZSkgeyBlbC5hcHBlbmRDaGlsZChub2RlKTsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnJlbW92ZUNoaWxkID0gZnVuY3Rpb24gKGVsLCBub2RlKSB7IGVsLnJlbW92ZUNoaWxkKG5vZGUpOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUucmVwbGFjZUNoaWxkID0gZnVuY3Rpb24gKGVsLCBuZXdDaGlsZCwgb2xkQ2hpbGQpIHsgZWwucmVwbGFjZUNoaWxkKG5ld0NoaWxkLCBvbGRDaGlsZCk7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuaW5zZXJ0QmVmb3JlID0gZnVuY3Rpb24gKGVsLCBub2RlKSB7IGVsLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5vZGUsIGVsKTsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmluc2VydEFsbEJlZm9yZSA9IGZ1bmN0aW9uIChlbCwgbm9kZXMpIHtcbiAgICAgICAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG4pIHsgcmV0dXJuIGVsLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG4sIGVsKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5pbnNlcnRBZnRlciA9IGZ1bmN0aW9uIChlbCwgbm9kZSkgeyBlbC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShub2RlLCBlbC5uZXh0U2libGluZyk7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5zZXRJbm5lckhUTUwgPSBmdW5jdGlvbiAoZWwsIHZhbHVlKSB7IGVsLmlubmVySFRNTCA9IHZhbHVlOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0VGV4dCA9IGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gZWwudGV4dENvbnRlbnQ7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5zZXRUZXh0ID0gZnVuY3Rpb24gKGVsLCB2YWx1ZSkgeyBlbC50ZXh0Q29udGVudCA9IHZhbHVlOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIGVsLnZhbHVlOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbiAoZWwsIHZhbHVlKSB7IGVsLnZhbHVlID0gdmFsdWU7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5nZXRDaGVja2VkID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiBlbC5jaGVja2VkOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuc2V0Q2hlY2tlZCA9IGZ1bmN0aW9uIChlbCwgdmFsdWUpIHsgZWwuY2hlY2tlZCA9IHZhbHVlOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuY3JlYXRlQ29tbWVudCA9IGZ1bmN0aW9uICh0ZXh0KSB7IHJldHVybiBkb2N1bWVudC5jcmVhdGVDb21tZW50KHRleHQpOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuY3JlYXRlVGVtcGxhdGUgPSBmdW5jdGlvbiAoaHRtbCkge1xuICAgICAgICAgICAgdmFyIHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgICAgICAgICAgdC5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgIH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKHRhZ05hbWUsIGRvYykge1xuICAgICAgICAgICAgaWYgKGRvYyA9PT0gdm9pZCAwKSB7IGRvYyA9IGRvY3VtZW50OyB9XG4gICAgICAgICAgICByZXR1cm4gZG9jLmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gICAgICAgIH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5jcmVhdGVFbGVtZW50TlMgPSBmdW5jdGlvbiAobnMsIHRhZ05hbWUsIGRvYykge1xuICAgICAgICAgICAgaWYgKGRvYyA9PT0gdm9pZCAwKSB7IGRvYyA9IGRvY3VtZW50OyB9XG4gICAgICAgICAgICByZXR1cm4gZG9jLmNyZWF0ZUVsZW1lbnROUyhucywgdGFnTmFtZSk7XG4gICAgICAgIH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5jcmVhdGVUZXh0Tm9kZSA9IGZ1bmN0aW9uICh0ZXh0LCBkb2MpIHtcbiAgICAgICAgICAgIGlmIChkb2MgPT09IHZvaWQgMCkgeyBkb2MgPSBkb2N1bWVudDsgfVxuICAgICAgICAgICAgcmV0dXJuIGRvYy5jcmVhdGVUZXh0Tm9kZSh0ZXh0KTtcbiAgICAgICAgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmNyZWF0ZVNjcmlwdFRhZyA9IGZ1bmN0aW9uIChhdHRyTmFtZSwgYXR0clZhbHVlLCBkb2MpIHtcbiAgICAgICAgICAgIGlmIChkb2MgPT09IHZvaWQgMCkgeyBkb2MgPSBkb2N1bWVudDsgfVxuICAgICAgICAgICAgdmFyIGVsID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ1NDUklQVCcpO1xuICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKGF0dHJOYW1lLCBhdHRyVmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgICB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuY3JlYXRlU3R5bGVFbGVtZW50ID0gZnVuY3Rpb24gKGNzcywgZG9jKSB7XG4gICAgICAgICAgICBpZiAoZG9jID09PSB2b2lkIDApIHsgZG9jID0gZG9jdW1lbnQ7IH1cbiAgICAgICAgICAgIHZhciBzdHlsZSA9IGRvYy5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChzdHlsZSwgdGhpcy5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgICAgICAgICAgIHJldHVybiBzdHlsZTtcbiAgICAgICAgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmNyZWF0ZVNoYWRvd1Jvb3QgPSBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIGVsLmNyZWF0ZVNoYWRvd1Jvb3QoKTsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldFNoYWRvd1Jvb3QgPSBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIGVsLnNoYWRvd1Jvb3Q7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5nZXRIb3N0ID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiBlbC5ob3N0OyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS5jbG9uZU5vZGUodHJ1ZSk7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lID0gZnVuY3Rpb24gKGVsZW1lbnQsIG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUobmFtZSk7XG4gICAgICAgIH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5nZXRFbGVtZW50c0J5VGFnTmFtZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShuYW1lKTtcbiAgICAgICAgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmNsYXNzTGlzdCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7IHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChlbGVtZW50LmNsYXNzTGlzdCwgMCk7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5hZGRDbGFzcyA9IGZ1bmN0aW9uIChlbGVtZW50LCBjbGFzc05hbWUpIHsgZWxlbWVudC5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5yZW1vdmVDbGFzcyA9IGZ1bmN0aW9uIChlbGVtZW50LCBjbGFzc05hbWUpIHsgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5oYXNDbGFzcyA9IGZ1bmN0aW9uIChlbGVtZW50LCBjbGFzc05hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpO1xuICAgICAgICB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuc2V0U3R5bGUgPSBmdW5jdGlvbiAoZWxlbWVudCwgc3R5bGVOYW1lLCBzdHlsZVZhbHVlKSB7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlW3N0eWxlTmFtZV0gPSBzdHlsZVZhbHVlO1xuICAgICAgICB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUucmVtb3ZlU3R5bGUgPSBmdW5jdGlvbiAoZWxlbWVudCwgc3R5bGVuYW1lKSB7XG4gICAgICAgICAgICAvLyBJRSByZXF1aXJlcyAnJyBpbnN0ZWFkIG9mIG51bGxcbiAgICAgICAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy83OTE2XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlW3N0eWxlbmFtZV0gPSAnJztcbiAgICAgICAgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldFN0eWxlID0gZnVuY3Rpb24gKGVsZW1lbnQsIHN0eWxlbmFtZSkgeyByZXR1cm4gZWxlbWVudC5zdHlsZVtzdHlsZW5hbWVdOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuaGFzU3R5bGUgPSBmdW5jdGlvbiAoZWxlbWVudCwgc3R5bGVOYW1lLCBzdHlsZVZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoc3R5bGVWYWx1ZSA9PT0gdm9pZCAwKSB7IHN0eWxlVmFsdWUgPSBudWxsOyB9XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmdldFN0eWxlKGVsZW1lbnQsIHN0eWxlTmFtZSkgfHwgJyc7XG4gICAgICAgICAgICByZXR1cm4gc3R5bGVWYWx1ZSA/IHZhbHVlID09IHN0eWxlVmFsdWUgOiB2YWx1ZS5sZW5ndGggPiAwO1xuICAgICAgICB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUudGFnTmFtZSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7IHJldHVybiBlbGVtZW50LnRhZ05hbWU7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5hdHRyaWJ1dGVNYXAgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIHJlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHZhciBlbEF0dHJzID0gZWxlbWVudC5hdHRyaWJ1dGVzO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbEF0dHJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF0dHJpYiA9IGVsQXR0cnNbaV07XG4gICAgICAgICAgICAgICAgcmVzLnNldChhdHRyaWIubmFtZSwgYXR0cmliLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5oYXNBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoZWxlbWVudCwgYXR0cmlidXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudC5oYXNBdHRyaWJ1dGUoYXR0cmlidXRlKTtcbiAgICAgICAgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmhhc0F0dHJpYnV0ZU5TID0gZnVuY3Rpb24gKGVsZW1lbnQsIG5zLCBhdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50Lmhhc0F0dHJpYnV0ZU5TKG5zLCBhdHRyaWJ1dGUpO1xuICAgICAgICB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0QXR0cmlidXRlID0gZnVuY3Rpb24gKGVsZW1lbnQsIGF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZSk7XG4gICAgICAgIH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5nZXRBdHRyaWJ1dGVOUyA9IGZ1bmN0aW9uIChlbGVtZW50LCBucywgbmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQuZ2V0QXR0cmlidXRlTlMobnMsIG5hbWUpO1xuICAgICAgICB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuc2V0QXR0cmlidXRlID0gZnVuY3Rpb24gKGVsZW1lbnQsIG5hbWUsIHZhbHVlKSB7IGVsZW1lbnQuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnNldEF0dHJpYnV0ZU5TID0gZnVuY3Rpb24gKGVsZW1lbnQsIG5zLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhucywgbmFtZSwgdmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUucmVtb3ZlQXR0cmlidXRlID0gZnVuY3Rpb24gKGVsZW1lbnQsIGF0dHJpYnV0ZSkgeyBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUucmVtb3ZlQXR0cmlidXRlTlMgPSBmdW5jdGlvbiAoZWxlbWVudCwgbnMsIG5hbWUpIHtcbiAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlTlMobnMsIG5hbWUpO1xuICAgICAgICB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUudGVtcGxhdGVBd2FyZVJvb3QgPSBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIHRoaXMuaXNUZW1wbGF0ZUVsZW1lbnQoZWwpID8gdGhpcy5jb250ZW50KGVsKSA6IGVsOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuY3JlYXRlSHRtbERvY3VtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCgnZmFrZVRpdGxlJyk7XG4gICAgICAgIH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5kZWZhdWx0RG9jID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZG9jdW1lbnQ7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB0b3A6IDAsIGJvdHRvbTogMCwgbGVmdDogMCwgcmlnaHQ6IDAsIHdpZHRoOiAwLCBoZWlnaHQ6IDAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldFRpdGxlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZG9jdW1lbnQudGl0bGU7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5zZXRUaXRsZSA9IGZ1bmN0aW9uIChuZXdUaXRsZSkgeyBkb2N1bWVudC50aXRsZSA9IG5ld1RpdGxlIHx8ICcnOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZWxlbWVudE1hdGNoZXMgPSBmdW5jdGlvbiAobiwgc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIGlmIChuIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbi5tYXRjaGVzICYmIG4ubWF0Y2hlcyhzZWxlY3RvcikgfHxcbiAgICAgICAgICAgICAgICAgICAgbi5tc01hdGNoZXNTZWxlY3RvciAmJiBuLm1zTWF0Y2hlc1NlbGVjdG9yKHNlbGVjdG9yKSB8fFxuICAgICAgICAgICAgICAgICAgICBuLndlYmtpdE1hdGNoZXNTZWxlY3RvciAmJiBuLndlYmtpdE1hdGNoZXNTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5pc1RlbXBsYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgcmV0dXJuIGVsIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgZWwubm9kZU5hbWUgPT0gJ1RFTVBMQVRFJztcbiAgICAgICAgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmlzVGV4dE5vZGUgPSBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREU7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5pc0NvbW1lbnROb2RlID0gZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09IE5vZGUuQ09NTUVOVF9OT0RFOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuaXNFbGVtZW50Tm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERTsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmhhc1NoYWRvd1Jvb3QgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzUHJlc2VudChub2RlLnNoYWRvd1Jvb3QpICYmIG5vZGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcbiAgICAgICAgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmlzU2hhZG93Um9vdCA9IGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlIGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudDsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmltcG9ydEludG9Eb2MgPSBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gZG9jdW1lbnQuaW1wb3J0Tm9kZSh0aGlzLnRlbXBsYXRlQXdhcmVSb290KG5vZGUpLCB0cnVlKTsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmFkb3B0Tm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBkb2N1bWVudC5hZG9wdE5vZGUobm9kZSk7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5nZXRIcmVmID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiBlbC5ocmVmOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0RXZlbnRLZXkgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBldmVudC5rZXk7XG4gICAgICAgICAgICBpZiAoaXNCbGFuayhrZXkpKSB7XG4gICAgICAgICAgICAgICAga2V5ID0gZXZlbnQua2V5SWRlbnRpZmllcjtcbiAgICAgICAgICAgICAgICAvLyBrZXlJZGVudGlmaWVyIGlzIGRlZmluZWQgaW4gdGhlIG9sZCBkcmFmdCBvZiBET00gTGV2ZWwgMyBFdmVudHMgaW1wbGVtZW50ZWQgYnkgQ2hyb21lIGFuZFxuICAgICAgICAgICAgICAgIC8vIFNhZmFyaSBjZlxuICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDcvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMDcxMjIxL2V2ZW50cy5odG1sI0V2ZW50cy1LZXlib2FyZEV2ZW50cy1JbnRlcmZhY2VzXG4gICAgICAgICAgICAgICAgaWYgKGlzQmxhbmsoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1VuaWRlbnRpZmllZCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChrZXkuc3RhcnRzV2l0aCgnVSsnKSkge1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGtleS5zdWJzdHJpbmcoMiksIDE2KSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudC5sb2NhdGlvbiA9PT0gRE9NX0tFWV9MT0NBVElPTl9OVU1QQUQgJiYgX2Nocm9tZU51bUtleVBhZE1hcC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGVyZSBpcyBhIGJ1ZyBpbiBDaHJvbWUgZm9yIG51bWVyaWMga2V5cGFkIGtleXM6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MTU1NjU0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAxLCAyLCAzIC4uLiBhcmUgcmVwb3J0ZWQgYXMgQSwgQiwgQyAuLi5cbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IF9jaHJvbWVOdW1LZXlQYWRNYXBba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfa2V5TWFwW2tleV0gfHwga2V5O1xuICAgICAgICB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0R2xvYmFsRXZlbnRUYXJnZXQgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgICAgICBpZiAodGFyZ2V0ID09PSAnd2luZG93Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGFyZ2V0ID09PSAnZG9jdW1lbnQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRhcmdldCA9PT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmJvZHk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5nZXRIaXN0b3J5ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gd2luZG93Lmhpc3Rvcnk7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5nZXRMb2NhdGlvbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHdpbmRvdy5sb2NhdGlvbjsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldEJhc2VIcmVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGhyZWYgPSBnZXRCYXNlRWxlbWVudEhyZWYoKTtcbiAgICAgICAgICAgIHJldHVybiBpc0JsYW5rKGhyZWYpID8gbnVsbCA6IHJlbGF0aXZlUGF0aChocmVmKTtcbiAgICAgICAgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnJlc2V0QmFzZUVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7IGJhc2VFbGVtZW50ID0gbnVsbDsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldFVzZXJBZ2VudCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50OyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuc2V0RGF0YSA9IGZ1bmN0aW9uIChlbGVtZW50LCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoZWxlbWVudCwgJ2RhdGEtJyArIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldERhdGEgPSBmdW5jdGlvbiAoZWxlbWVudCwgbmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKGVsZW1lbnQsICdkYXRhLScgKyBuYW1lKTtcbiAgICAgICAgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldENvbXB1dGVkU3R5bGUgPSBmdW5jdGlvbiAoZWxlbWVudCkgeyByZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTsgfTtcbiAgICAgICAgLy8gVE9ETyh0Ym9zY2gpOiBtb3ZlIHRoaXMgaW50byBhIHNlcGFyYXRlIGVudmlyb25tZW50IGNsYXNzIG9uY2Ugd2UgaGF2ZSBpdFxuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuc2V0R2xvYmFsVmFyID0gZnVuY3Rpb24gKHBhdGgsIHZhbHVlKSB7IHNldFZhbHVlT25QYXRoKGdsb2JhbCQxLCBwYXRoLCB2YWx1ZSk7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5zdXBwb3J0c1dlYkFuaW1hdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgRWxlbWVudC5wcm90b3R5cGVbJ2FuaW1hdGUnXSA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgICAgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnBlcmZvcm1hbmNlTm93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gcGVyZm9ybWFuY2Uubm93KCkgaXMgbm90IGF2YWlsYWJsZSBpbiBhbGwgYnJvd3NlcnMsIHNlZVxuICAgICAgICAgICAgLy8gaHR0cDovL2Nhbml1c2UuY29tLyNzZWFyY2g9cGVyZm9ybWFuY2Uubm93XG4gICAgICAgICAgICByZXR1cm4gd2luZG93LnBlcmZvcm1hbmNlICYmIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3cgPyB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCkgOlxuICAgICAgICAgICAgICAgIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuc3VwcG9ydHNDb29raWVzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldENvb2tpZSA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBwYXJzZUNvb2tpZVZhbHVlKGRvY3VtZW50LmNvb2tpZSwgbmFtZSk7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5zZXRDb29raWUgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgIC8vIGRvY3VtZW50LmNvb2tpZSBpcyBtYWdpY2FsLCBhc3NpZ25pbmcgaW50byBpdCBhc3NpZ25zL292ZXJyaWRlcyBvbmUgY29va2llIHZhbHVlLCBidXQgZG9lc1xuICAgICAgICAgICAgLy8gbm90IGNsZWFyIG90aGVyIGNvb2tpZXMuXG4gICAgICAgICAgICBkb2N1bWVudC5jb29raWUgPSBlbmNvZGVVUklDb21wb25lbnQobmFtZSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gQnJvd3NlckRvbUFkYXB0ZXI7XG4gICAgfShHZW5lcmljQnJvd3NlckRvbUFkYXB0ZXIpKTtcbiAgICB2YXIgYmFzZUVsZW1lbnQgPSBudWxsO1xuICAgIGZ1bmN0aW9uIGdldEJhc2VFbGVtZW50SHJlZigpIHtcbiAgICAgICAgaWYgKCFiYXNlRWxlbWVudCkge1xuICAgICAgICAgICAgYmFzZUVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdiYXNlJyk7XG4gICAgICAgICAgICBpZiAoIWJhc2VFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhc2VFbGVtZW50LmdldEF0dHJpYnV0ZSgnaHJlZicpO1xuICAgIH1cbiAgICAvLyBiYXNlZCBvbiB1cmxVdGlscy5qcyBpbiBBbmd1bGFySlMgMVxuICAgIHZhciB1cmxQYXJzaW5nTm9kZTtcbiAgICBmdW5jdGlvbiByZWxhdGl2ZVBhdGgodXJsKSB7XG4gICAgICAgIGlmICghdXJsUGFyc2luZ05vZGUpIHtcbiAgICAgICAgICAgIHVybFBhcnNpbmdOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgICB9XG4gICAgICAgIHVybFBhcnNpbmdOb2RlLnNldEF0dHJpYnV0ZSgnaHJlZicsIHVybCk7XG4gICAgICAgIHJldHVybiAodXJsUGFyc2luZ05vZGUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpID8gdXJsUGFyc2luZ05vZGUucGF0aG5hbWUgOlxuICAgICAgICAgICAgJy8nICsgdXJsUGFyc2luZ05vZGUucGF0aG5hbWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlQ29va2llVmFsdWUoY29va2llU3RyLCBuYW1lKSB7XG4gICAgICAgIG5hbWUgPSBlbmNvZGVVUklDb21wb25lbnQobmFtZSk7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBjb29raWVTdHIuc3BsaXQoJzsnKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBjb29raWUgPSBfYVtfaV07XG4gICAgICAgICAgICB2YXIgZXFJbmRleCA9IGNvb2tpZS5pbmRleE9mKCc9Jyk7XG4gICAgICAgICAgICB2YXIgX2IgPSBlcUluZGV4ID09IC0xID8gW2Nvb2tpZSwgJyddIDogW2Nvb2tpZS5zbGljZSgwLCBlcUluZGV4KSwgY29va2llLnNsaWNlKGVxSW5kZXggKyAxKV0sIGNvb2tpZU5hbWUgPSBfYlswXSwgY29va2llVmFsdWUgPSBfYlsxXTtcbiAgICAgICAgICAgIGlmIChjb29raWVOYW1lLnRyaW0oKSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoY29va2llVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdXBwb3J0c1N0YXRlKCkge1xuICAgICAgICByZXR1cm4gISF3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkMiA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGBQbGF0Zm9ybUxvY2F0aW9uYCBlbmNhcHN1bGF0ZXMgYWxsIG9mIHRoZSBkaXJlY3QgY2FsbHMgdG8gcGxhdGZvcm0gQVBJcy5cbiAgICAgKiBUaGlzIGNsYXNzIHNob3VsZCBub3QgYmUgdXNlZCBkaXJlY3RseSBieSBhbiBhcHBsaWNhdGlvbiBkZXZlbG9wZXIuIEluc3RlYWQsIHVzZVxuICAgICAqIHtAbGluayBMb2NhdGlvbn0uXG4gICAgICovXG4gICAgdmFyIEJyb3dzZXJQbGF0Zm9ybUxvY2F0aW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDIoQnJvd3NlclBsYXRmb3JtTG9jYXRpb24sIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEJyb3dzZXJQbGF0Zm9ybUxvY2F0aW9uKCkge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9pbml0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhpcyBpcyBtb3ZlZCB0byBpdHMgb3duIG1ldGhvZCBzbyB0aGF0IGBNb2NrUGxhdGZvcm1Mb2NhdGlvblN0cmF0ZWd5YCBjYW4gb3ZlcndyaXRlIGl0XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgQnJvd3NlclBsYXRmb3JtTG9jYXRpb24ucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fbG9jYXRpb24gPSBnZXRET00oKS5nZXRMb2NhdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5faGlzdG9yeSA9IGdldERPTSgpLmdldEhpc3RvcnkoKTtcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJyb3dzZXJQbGF0Zm9ybUxvY2F0aW9uLnByb3RvdHlwZSwgXCJsb2NhdGlvblwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2xvY2F0aW9uOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgQnJvd3NlclBsYXRmb3JtTG9jYXRpb24ucHJvdG90eXBlLmdldEJhc2VIcmVmRnJvbURPTSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdldERPTSgpLmdldEJhc2VIcmVmKCk7IH07XG4gICAgICAgIEJyb3dzZXJQbGF0Zm9ybUxvY2F0aW9uLnByb3RvdHlwZS5vblBvcFN0YXRlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICBnZXRET00oKS5nZXRHbG9iYWxFdmVudFRhcmdldCgnd2luZG93JykuYWRkRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCBmbiwgZmFsc2UpO1xuICAgICAgICB9O1xuICAgICAgICBCcm93c2VyUGxhdGZvcm1Mb2NhdGlvbi5wcm90b3R5cGUub25IYXNoQ2hhbmdlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICBnZXRET00oKS5nZXRHbG9iYWxFdmVudFRhcmdldCgnd2luZG93JykuYWRkRXZlbnRMaXN0ZW5lcignaGFzaGNoYW5nZScsIGZuLCBmYWxzZSk7XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCcm93c2VyUGxhdGZvcm1Mb2NhdGlvbi5wcm90b3R5cGUsIFwicGF0aG5hbWVcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9sb2NhdGlvbi5wYXRobmFtZTsgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKG5ld1BhdGgpIHsgdGhpcy5fbG9jYXRpb24ucGF0aG5hbWUgPSBuZXdQYXRoOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJyb3dzZXJQbGF0Zm9ybUxvY2F0aW9uLnByb3RvdHlwZSwgXCJzZWFyY2hcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9sb2NhdGlvbi5zZWFyY2g7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnJvd3NlclBsYXRmb3JtTG9jYXRpb24ucHJvdG90eXBlLCBcImhhc2hcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9sb2NhdGlvbi5oYXNoOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgQnJvd3NlclBsYXRmb3JtTG9jYXRpb24ucHJvdG90eXBlLnB1c2hTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgdGl0bGUsIHVybCkge1xuICAgICAgICAgICAgaWYgKHN1cHBvcnRzU3RhdGUoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2hpc3RvcnkucHVzaFN0YXRlKHN0YXRlLCB0aXRsZSwgdXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvY2F0aW9uLmhhc2ggPSB1cmw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEJyb3dzZXJQbGF0Zm9ybUxvY2F0aW9uLnByb3RvdHlwZS5yZXBsYWNlU3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUsIHRpdGxlLCB1cmwpIHtcbiAgICAgICAgICAgIGlmIChzdXBwb3J0c1N0YXRlKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9oaXN0b3J5LnJlcGxhY2VTdGF0ZShzdGF0ZSwgdGl0bGUsIHVybCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2NhdGlvbi5oYXNoID0gdXJsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBCcm93c2VyUGxhdGZvcm1Mb2NhdGlvbi5wcm90b3R5cGUuZm9yd2FyZCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5faGlzdG9yeS5mb3J3YXJkKCk7IH07XG4gICAgICAgIEJyb3dzZXJQbGF0Zm9ybUxvY2F0aW9uLnByb3RvdHlwZS5iYWNrID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9oaXN0b3J5LmJhY2soKTsgfTtcbiAgICAgICAgQnJvd3NlclBsYXRmb3JtTG9jYXRpb24uZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBCcm93c2VyUGxhdGZvcm1Mb2NhdGlvbi5jdG9yUGFyYW1ldGVycyA9IFtdO1xuICAgICAgICByZXR1cm4gQnJvd3NlclBsYXRmb3JtTG9jYXRpb247XG4gICAgfShfYW5ndWxhcl9jb21tb24uUGxhdGZvcm1Mb2NhdGlvbikpO1xuXG4gICAgLy8gU2FmYXJpIGRvZXNuJ3QgaW1wbGVtZW50IE1hcEl0ZXJhdG9yLm5leHQoKSwgd2hpY2ggaXMgdXNlZCBpcyBUcmFjZXVyJ3MgcG9seWZpbGwgb2YgQXJyYXkuZnJvbVxuICAgIC8vIFRPRE8obWxhdmFsKTogcmVtb3ZlIHRoZSB3b3JrIGFyb3VuZCBvbmNlIHdlIGhhdmUgYSB3b3JraW5nIHBvbHlmaWxsIG9mIEFycmF5LmZyb21cbiAgICB2YXIgX2FycmF5RnJvbU1hcCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoKG5ldyBNYXAoKSkudmFsdWVzKCkubmV4dCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBjcmVhdGVBcnJheUZyb21NYXAobSwgZ2V0VmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRWYWx1ZXMgPyBBcnJheS5mcm9tKG0udmFsdWVzKCkpIDogQXJyYXkuZnJvbShtLmtleXMoKSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBjcmVhdGVBcnJheUZyb21NYXBXaXRoRm9yZWFjaChtLCBnZXRWYWx1ZXMpIHtcbiAgICAgICAgICAgIHZhciByZXMgPSBuZXcgQXJyYXkobS5zaXplKSwgaSA9IDA7XG4gICAgICAgICAgICBtLmZvckVhY2goZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgICAgICAgICAgICByZXNbaV0gPSBnZXRWYWx1ZXMgPyB2IDogaztcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH07XG4gICAgfSkoKTtcbiAgICAvKipcbiAgICAgKiBXcmFwcyBKYXZhc2NyaXB0IE9iamVjdHNcbiAgICAgKi9cbiAgICB2YXIgU3RyaW5nTWFwV3JhcHBlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFN0cmluZ01hcFdyYXBwZXIoKSB7XG4gICAgICAgIH1cbiAgICAgICAgU3RyaW5nTWFwV3JhcHBlci5tZXJnZSA9IGZ1bmN0aW9uIChtMSwgbTIpIHtcbiAgICAgICAgICAgIHZhciBtID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gT2JqZWN0LmtleXMobTEpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBrID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIG1ba10gPSBtMVtrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSBPYmplY3Qua2V5cyhtMik7IF9iIDwgX2MubGVuZ3RoOyBfYisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGsgPSBfY1tfYl07XG4gICAgICAgICAgICAgICAgbVtrXSA9IG0yW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgIH07XG4gICAgICAgIFN0cmluZ01hcFdyYXBwZXIuZXF1YWxzID0gZnVuY3Rpb24gKG0xLCBtMikge1xuICAgICAgICAgICAgdmFyIGsxID0gT2JqZWN0LmtleXMobTEpO1xuICAgICAgICAgICAgdmFyIGsyID0gT2JqZWN0LmtleXMobTIpO1xuICAgICAgICAgICAgaWYgKGsxLmxlbmd0aCAhPSBrMi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGsxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGsxW2ldO1xuICAgICAgICAgICAgICAgIGlmIChtMVtrZXldICE9PSBtMltrZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFN0cmluZ01hcFdyYXBwZXI7XG4gICAgfSgpKTtcbiAgICB2YXIgTGlzdFdyYXBwZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBMaXN0V3JhcHBlcigpIHtcbiAgICAgICAgfVxuICAgICAgICAvLyBKUyBoYXMgbm8gd2F5IHRvIGV4cHJlc3MgYSBzdGF0aWNhbGx5IGZpeGVkIHNpemUgbGlzdCwgYnV0IGRhcnQgZG9lcyBzbyB3ZVxuICAgICAgICAvLyBrZWVwIGJvdGggbWV0aG9kcy5cbiAgICAgICAgTGlzdFdyYXBwZXIuY3JlYXRlRml4ZWRTaXplID0gZnVuY3Rpb24gKHNpemUpIHsgcmV0dXJuIG5ldyBBcnJheShzaXplKTsgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIuY3JlYXRlR3Jvd2FibGVTaXplID0gZnVuY3Rpb24gKHNpemUpIHsgcmV0dXJuIG5ldyBBcnJheShzaXplKTsgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIuY2xvbmUgPSBmdW5jdGlvbiAoYXJyYXkpIHsgcmV0dXJuIGFycmF5LnNsaWNlKDApOyB9O1xuICAgICAgICBMaXN0V3JhcHBlci5mb3JFYWNoV2l0aEluZGV4ID0gZnVuY3Rpb24gKGFycmF5LCBmbikge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGZuKGFycmF5W2ldLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIuZmlyc3QgPSBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICAgICAgICAgIGlmICghYXJyYXkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByZXR1cm4gYXJyYXlbMF07XG4gICAgICAgIH07XG4gICAgICAgIExpc3RXcmFwcGVyLmxhc3QgPSBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICAgICAgICAgIGlmICghYXJyYXkgfHwgYXJyYXkubGVuZ3RoID09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByZXR1cm4gYXJyYXlbYXJyYXkubGVuZ3RoIC0gMV07XG4gICAgICAgIH07XG4gICAgICAgIExpc3RXcmFwcGVyLmluZGV4T2YgPSBmdW5jdGlvbiAoYXJyYXksIHZhbHVlLCBzdGFydEluZGV4KSB7XG4gICAgICAgICAgICBpZiAoc3RhcnRJbmRleCA9PT0gdm9pZCAwKSB7IHN0YXJ0SW5kZXggPSAwOyB9XG4gICAgICAgICAgICByZXR1cm4gYXJyYXkuaW5kZXhPZih2YWx1ZSwgc3RhcnRJbmRleCk7XG4gICAgICAgIH07XG4gICAgICAgIExpc3RXcmFwcGVyLmNvbnRhaW5zID0gZnVuY3Rpb24gKGxpc3QsIGVsKSB7IHJldHVybiBsaXN0LmluZGV4T2YoZWwpICE9PSAtMTsgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIucmV2ZXJzZWQgPSBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICAgICAgICAgIHZhciBhID0gTGlzdFdyYXBwZXIuY2xvbmUoYXJyYXkpO1xuICAgICAgICAgICAgcmV0dXJuIGEucmV2ZXJzZSgpO1xuICAgICAgICB9O1xuICAgICAgICBMaXN0V3JhcHBlci5jb25jYXQgPSBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5jb25jYXQoYik7IH07XG4gICAgICAgIExpc3RXcmFwcGVyLmluc2VydCA9IGZ1bmN0aW9uIChsaXN0LCBpbmRleCwgdmFsdWUpIHsgbGlzdC5zcGxpY2UoaW5kZXgsIDAsIHZhbHVlKTsgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIucmVtb3ZlQXQgPSBmdW5jdGlvbiAobGlzdCwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciByZXMgPSBsaXN0W2luZGV4XTtcbiAgICAgICAgICAgIGxpc3Quc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH07XG4gICAgICAgIExpc3RXcmFwcGVyLnJlbW92ZUFsbCA9IGZ1bmN0aW9uIChsaXN0LCBpdGVtcykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGxpc3QuaW5kZXhPZihpdGVtc1tpXSk7XG4gICAgICAgICAgICAgICAgbGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBMaXN0V3JhcHBlci5yZW1vdmUgPSBmdW5jdGlvbiAobGlzdCwgZWwpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGxpc3QuaW5kZXhPZihlbCk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgIGxpc3Quc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIuY2xlYXIgPSBmdW5jdGlvbiAobGlzdCkgeyBsaXN0Lmxlbmd0aCA9IDA7IH07XG4gICAgICAgIExpc3RXcmFwcGVyLmlzRW1wdHkgPSBmdW5jdGlvbiAobGlzdCkgeyByZXR1cm4gbGlzdC5sZW5ndGggPT0gMDsgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIuZmlsbCA9IGZ1bmN0aW9uIChsaXN0LCB2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICAgICAgICAgICAgaWYgKHN0YXJ0ID09PSB2b2lkIDApIHsgc3RhcnQgPSAwOyB9XG4gICAgICAgICAgICBpZiAoZW5kID09PSB2b2lkIDApIHsgZW5kID0gbnVsbDsgfVxuICAgICAgICAgICAgbGlzdC5maWxsKHZhbHVlLCBzdGFydCwgZW5kID09PSBudWxsID8gbGlzdC5sZW5ndGggOiBlbmQpO1xuICAgICAgICB9O1xuICAgICAgICBMaXN0V3JhcHBlci5lcXVhbHMgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmIChhW2ldICE9PSBiW2ldKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIuc2xpY2UgPSBmdW5jdGlvbiAobCwgZnJvbSwgdG8pIHtcbiAgICAgICAgICAgIGlmIChmcm9tID09PSB2b2lkIDApIHsgZnJvbSA9IDA7IH1cbiAgICAgICAgICAgIGlmICh0byA9PT0gdm9pZCAwKSB7IHRvID0gbnVsbDsgfVxuICAgICAgICAgICAgcmV0dXJuIGwuc2xpY2UoZnJvbSwgdG8gPT09IG51bGwgPyB1bmRlZmluZWQgOiB0byk7XG4gICAgICAgIH07XG4gICAgICAgIExpc3RXcmFwcGVyLnNwbGljZSA9IGZ1bmN0aW9uIChsLCBmcm9tLCBsZW5ndGgpIHsgcmV0dXJuIGwuc3BsaWNlKGZyb20sIGxlbmd0aCk7IH07XG4gICAgICAgIExpc3RXcmFwcGVyLnNvcnQgPSBmdW5jdGlvbiAobCwgY29tcGFyZUZuKSB7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KGNvbXBhcmVGbikpIHtcbiAgICAgICAgICAgICAgICBsLnNvcnQoY29tcGFyZUZuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGwuc29ydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBMaXN0V3JhcHBlci50b1N0cmluZyA9IGZ1bmN0aW9uIChsKSB7IHJldHVybiBsLnRvU3RyaW5nKCk7IH07XG4gICAgICAgIExpc3RXcmFwcGVyLnRvSlNPTiA9IGZ1bmN0aW9uIChsKSB7IHJldHVybiBKU09OLnN0cmluZ2lmeShsKTsgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIubWF4aW11bSA9IGZ1bmN0aW9uIChsaXN0LCBwcmVkaWNhdGUpIHtcbiAgICAgICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc29sdXRpb24gPSBudWxsO1xuICAgICAgICAgICAgdmFyIG1heFZhbHVlID0gLUluZmluaXR5O1xuICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxpc3QubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IGxpc3RbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmIChpc0JsYW5rKGNhbmRpZGF0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjYW5kaWRhdGVWYWx1ZSA9IHByZWRpY2F0ZShjYW5kaWRhdGUpO1xuICAgICAgICAgICAgICAgIGlmIChjYW5kaWRhdGVWYWx1ZSA+IG1heFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNvbHV0aW9uID0gY2FuZGlkYXRlO1xuICAgICAgICAgICAgICAgICAgICBtYXhWYWx1ZSA9IGNhbmRpZGF0ZVZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzb2x1dGlvbjtcbiAgICAgICAgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIuZmxhdHRlbiA9IGZ1bmN0aW9uIChsaXN0KSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gW107XG4gICAgICAgICAgICBfZmxhdHRlbkFycmF5KGxpc3QsIHRhcmdldCk7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICB9O1xuICAgICAgICBMaXN0V3JhcHBlci5hZGRBbGwgPSBmdW5jdGlvbiAobGlzdCwgc291cmNlKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvdXJjZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxpc3QucHVzaChzb3VyY2VbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gTGlzdFdyYXBwZXI7XG4gICAgfSgpKTtcbiAgICBmdW5jdGlvbiBfZmxhdHRlbkFycmF5KHNvdXJjZSwgdGFyZ2V0KSB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQoc291cmNlKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IHNvdXJjZVtpXTtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xuICAgICAgICAgICAgICAgICAgICBfZmxhdHRlbkFycmF5KGl0ZW0sIHRhcmdldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICB2YXIgQnJvd3NlckdldFRlc3RhYmlsaXR5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQnJvd3NlckdldFRlc3RhYmlsaXR5KCkge1xuICAgICAgICB9XG4gICAgICAgIEJyb3dzZXJHZXRUZXN0YWJpbGl0eS5pbml0ID0gZnVuY3Rpb24gKCkgeyBfYW5ndWxhcl9jb3JlLnNldFRlc3RhYmlsaXR5R2V0dGVyKG5ldyBCcm93c2VyR2V0VGVzdGFiaWxpdHkoKSk7IH07XG4gICAgICAgIEJyb3dzZXJHZXRUZXN0YWJpbGl0eS5wcm90b3R5cGUuYWRkVG9XaW5kb3cgPSBmdW5jdGlvbiAocmVnaXN0cnkpIHtcbiAgICAgICAgICAgIGdsb2JhbCQxLmdldEFuZ3VsYXJUZXN0YWJpbGl0eSA9IGZ1bmN0aW9uIChlbGVtLCBmaW5kSW5BbmNlc3RvcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmluZEluQW5jZXN0b3JzID09PSB2b2lkIDApIHsgZmluZEluQW5jZXN0b3JzID0gdHJ1ZTsgfVxuICAgICAgICAgICAgICAgIHZhciB0ZXN0YWJpbGl0eSA9IHJlZ2lzdHJ5LmZpbmRUZXN0YWJpbGl0eUluVHJlZShlbGVtLCBmaW5kSW5BbmNlc3RvcnMpO1xuICAgICAgICAgICAgICAgIGlmICh0ZXN0YWJpbGl0eSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGZpbmQgdGVzdGFiaWxpdHkgZm9yIGVsZW1lbnQuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0ZXN0YWJpbGl0eTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbG9iYWwkMS5nZXRBbGxBbmd1bGFyVGVzdGFiaWxpdGllcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlZ2lzdHJ5LmdldEFsbFRlc3RhYmlsaXRpZXMoKTsgfTtcbiAgICAgICAgICAgIGdsb2JhbCQxLmdldEFsbEFuZ3VsYXJSb290RWxlbWVudHMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiByZWdpc3RyeS5nZXRBbGxSb290RWxlbWVudHMoKTsgfTtcbiAgICAgICAgICAgIHZhciB3aGVuQWxsU3RhYmxlID0gZnVuY3Rpb24gKGNhbGxiYWNrIC8qKiBUT0RPICM5MTAwICovKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRlc3RhYmlsaXRpZXMgPSBnbG9iYWwkMS5nZXRBbGxBbmd1bGFyVGVzdGFiaWxpdGllcygpO1xuICAgICAgICAgICAgICAgIHZhciBjb3VudCA9IHRlc3RhYmlsaXRpZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHZhciBkaWRXb3JrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdmFyIGRlY3JlbWVudCA9IGZ1bmN0aW9uIChkaWRXb3JrXyAvKiogVE9ETyAjOTEwMCAqLykge1xuICAgICAgICAgICAgICAgICAgICBkaWRXb3JrID0gZGlkV29yayB8fCBkaWRXb3JrXztcbiAgICAgICAgICAgICAgICAgICAgY291bnQtLTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50ID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGRpZFdvcmspO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0ZXN0YWJpbGl0aWVzLmZvckVhY2goZnVuY3Rpb24gKHRlc3RhYmlsaXR5IC8qKiBUT0RPICM5MTAwICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHRlc3RhYmlsaXR5LndoZW5TdGFibGUoZGVjcmVtZW50KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoIWdsb2JhbCQxWydmcmFtZXdvcmtTdGFiaWxpemVycyddKSB7XG4gICAgICAgICAgICAgICAgZ2xvYmFsJDFbJ2ZyYW1ld29ya1N0YWJpbGl6ZXJzJ10gPSBMaXN0V3JhcHBlci5jcmVhdGVHcm93YWJsZVNpemUoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnbG9iYWwkMVsnZnJhbWV3b3JrU3RhYmlsaXplcnMnXS5wdXNoKHdoZW5BbGxTdGFibGUpO1xuICAgICAgICB9O1xuICAgICAgICBCcm93c2VyR2V0VGVzdGFiaWxpdHkucHJvdG90eXBlLmZpbmRUZXN0YWJpbGl0eUluVHJlZSA9IGZ1bmN0aW9uIChyZWdpc3RyeSwgZWxlbSwgZmluZEluQW5jZXN0b3JzKSB7XG4gICAgICAgICAgICBpZiAoZWxlbSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdCA9IHJlZ2lzdHJ5LmdldFRlc3RhYmlsaXR5KGVsZW0pO1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudCh0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWZpbmRJbkFuY2VzdG9ycykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdldERPTSgpLmlzU2hhZG93Um9vdChlbGVtKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmRUZXN0YWJpbGl0eUluVHJlZShyZWdpc3RyeSwgZ2V0RE9NKCkuZ2V0SG9zdChlbGVtKSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5kVGVzdGFiaWxpdHlJblRyZWUocmVnaXN0cnksIGdldERPTSgpLnBhcmVudEVsZW1lbnQoZWxlbSksIHRydWUpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gQnJvd3NlckdldFRlc3RhYmlsaXR5O1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBBIHNlcnZpY2UgdGhhdCBjYW4gYmUgdXNlZCB0byBnZXQgYW5kIHNldCB0aGUgdGl0bGUgb2YgYSBjdXJyZW50IEhUTUwgZG9jdW1lbnQuXG4gICAgICpcbiAgICAgKiBTaW5jZSBhbiBBbmd1bGFyIDIgYXBwbGljYXRpb24gY2FuJ3QgYmUgYm9vdHN0cmFwcGVkIG9uIHRoZSBlbnRpcmUgSFRNTCBkb2N1bWVudCAoYDxodG1sPmAgdGFnKVxuICAgICAqIGl0IGlzIG5vdCBwb3NzaWJsZSB0byBiaW5kIHRvIHRoZSBgdGV4dGAgcHJvcGVydHkgb2YgdGhlIGBIVE1MVGl0bGVFbGVtZW50YCBlbGVtZW50c1xuICAgICAqIChyZXByZXNlbnRpbmcgdGhlIGA8dGl0bGU+YCB0YWcpLiBJbnN0ZWFkLCB0aGlzIHNlcnZpY2UgY2FuIGJlIHVzZWQgdG8gc2V0IGFuZCBnZXQgdGhlIGN1cnJlbnRcbiAgICAgKiB0aXRsZSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgVGl0bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBUaXRsZSgpIHtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSB0aXRsZSBvZiB0aGUgY3VycmVudCBIVE1MIGRvY3VtZW50LlxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgVGl0bGUucHJvdG90eXBlLmdldFRpdGxlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2V0RE9NKCkuZ2V0VGl0bGUoKTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgdGl0bGUgb2YgdGhlIGN1cnJlbnQgSFRNTCBkb2N1bWVudC5cbiAgICAgICAgICogQHBhcmFtIG5ld1RpdGxlXG4gICAgICAgICAqL1xuICAgICAgICBUaXRsZS5wcm90b3R5cGUuc2V0VGl0bGUgPSBmdW5jdGlvbiAobmV3VGl0bGUpIHsgZ2V0RE9NKCkuc2V0VGl0bGUobmV3VGl0bGUpOyB9O1xuICAgICAgICByZXR1cm4gVGl0bGU7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEEgREkgVG9rZW4gcmVwcmVzZW50aW5nIHRoZSBtYWluIHJlbmRlcmluZyBjb250ZXh0LiBJbiBhIGJyb3dzZXIgdGhpcyBpcyB0aGUgRE9NIERvY3VtZW50LlxuICAgICAqXG4gICAgICogTm90ZTogRG9jdW1lbnQgbWlnaHQgbm90IGJlIGF2YWlsYWJsZSBpbiB0aGUgQXBwbGljYXRpb24gQ29udGV4dCB3aGVuIEFwcGxpY2F0aW9uIGFuZCBSZW5kZXJpbmdcbiAgICAgKiBDb250ZXh0cyBhcmUgbm90IHRoZSBzYW1lIChlLmcuIHdoZW4gcnVubmluZyB0aGUgYXBwbGljYXRpb24gaW50byBhIFdlYiBXb3JrZXIpLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBET0NVTUVOVCA9IG5ldyBfYW5ndWxhcl9jb3JlLk9wYXF1ZVRva2VuKCdEb2N1bWVudFRva2VuJyk7XG5cbiAgICAvKipcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEVWRU5UX01BTkFHRVJfUExVR0lOUyA9IG5ldyBfYW5ndWxhcl9jb3JlLk9wYXF1ZVRva2VuKCdFdmVudE1hbmFnZXJQbHVnaW5zJyk7XG4gICAgLyoqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBFdmVudE1hbmFnZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBFdmVudE1hbmFnZXIocGx1Z2lucywgX3pvbmUpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLl96b25lID0gX3pvbmU7XG4gICAgICAgICAgICBwbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKHApIHsgcmV0dXJuIHAubWFuYWdlciA9IF90aGlzOyB9KTtcbiAgICAgICAgICAgIHRoaXMuX3BsdWdpbnMgPSBwbHVnaW5zLnNsaWNlKCkucmV2ZXJzZSgpO1xuICAgICAgICB9XG4gICAgICAgIEV2ZW50TWFuYWdlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChlbGVtZW50LCBldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICAgICAgICAgIHZhciBwbHVnaW4gPSB0aGlzLl9maW5kUGx1Z2luRm9yKGV2ZW50TmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gcGx1Z2luLmFkZEV2ZW50TGlzdGVuZXIoZWxlbWVudCwgZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5hZGRHbG9iYWxFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKHRhcmdldCwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgICAgICB2YXIgcGx1Z2luID0gdGhpcy5fZmluZFBsdWdpbkZvcihldmVudE5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIHBsdWdpbi5hZGRHbG9iYWxFdmVudExpc3RlbmVyKHRhcmdldCwgZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5nZXRab25lID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fem9uZTsgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLl9maW5kUGx1Z2luRm9yID0gZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgICAgICAgdmFyIHBsdWdpbnMgPSB0aGlzLl9wbHVnaW5zO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBsdWdpbiA9IHBsdWdpbnNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHBsdWdpbi5zdXBwb3J0cyhldmVudE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwbHVnaW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gZXZlbnQgbWFuYWdlciBwbHVnaW4gZm91bmQgZm9yIGV2ZW50IFwiICsgZXZlbnROYW1lKTtcbiAgICAgICAgfTtcbiAgICAgICAgRXZlbnRNYW5hZ2VyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgRXZlbnRNYW5hZ2VyLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBBcnJheSwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtFVkVOVF9NQU5BR0VSX1BMVUdJTlMsXSB9LF0gfSxcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5OZ1pvbmUsIH0sXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBFdmVudE1hbmFnZXI7XG4gICAgfSgpKTtcbiAgICB2YXIgRXZlbnRNYW5hZ2VyUGx1Z2luID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gRXZlbnRNYW5hZ2VyUGx1Z2luKCkge1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoYXQgaXMgZXF1aXZhbGVudCB0byBoYXZpbmcgc3VwcG9ydGluZyAkZXZlbnQudGFyZ2V0XG4gICAgICAgIEV2ZW50TWFuYWdlclBsdWdpbi5wcm90b3R5cGUuc3VwcG9ydHMgPSBmdW5jdGlvbiAoZXZlbnROYW1lKSB7IHJldHVybiBmYWxzZTsgfTtcbiAgICAgICAgRXZlbnRNYW5hZ2VyUGx1Z2luLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGVsZW1lbnQsIGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgICAgICAgICAgdGhyb3cgJ25vdCBpbXBsZW1lbnRlZCc7XG4gICAgICAgIH07XG4gICAgICAgIEV2ZW50TWFuYWdlclBsdWdpbi5wcm90b3R5cGUuYWRkR2xvYmFsRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChlbGVtZW50LCBldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICAgICAgICAgIHRocm93ICdub3QgaW1wbGVtZW50ZWQnO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRXZlbnRNYW5hZ2VyUGx1Z2luO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQ0ID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgdmFyIFNoYXJlZFN0eWxlc0hvc3QgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBTaGFyZWRTdHlsZXNIb3N0KCkge1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fc3R5bGVzID0gW107XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9zdHlsZXNTZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgU2hhcmVkU3R5bGVzSG9zdC5wcm90b3R5cGUuYWRkU3R5bGVzID0gZnVuY3Rpb24gKHN0eWxlcykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBhZGRpdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIHN0eWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChzdHlsZSkge1xuICAgICAgICAgICAgICAgIGlmICghX3RoaXMuX3N0eWxlc1NldC5oYXMoc3R5bGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9zdHlsZXNTZXQuYWRkKHN0eWxlKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3N0eWxlcy5wdXNoKHN0eWxlKTtcbiAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25zLnB1c2goc3R5bGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5vblN0eWxlc0FkZGVkKGFkZGl0aW9ucyk7XG4gICAgICAgIH07XG4gICAgICAgIFNoYXJlZFN0eWxlc0hvc3QucHJvdG90eXBlLm9uU3R5bGVzQWRkZWQgPSBmdW5jdGlvbiAoYWRkaXRpb25zKSB7IH07XG4gICAgICAgIFNoYXJlZFN0eWxlc0hvc3QucHJvdG90eXBlLmdldEFsbFN0eWxlcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3N0eWxlczsgfTtcbiAgICAgICAgU2hhcmVkU3R5bGVzSG9zdC5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIFNoYXJlZFN0eWxlc0hvc3QuY3RvclBhcmFtZXRlcnMgPSBbXTtcbiAgICAgICAgcmV0dXJuIFNoYXJlZFN0eWxlc0hvc3Q7XG4gICAgfSgpKTtcbiAgICB2YXIgRG9tU2hhcmVkU3R5bGVzSG9zdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQ0KERvbVNoYXJlZFN0eWxlc0hvc3QsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIERvbVNoYXJlZFN0eWxlc0hvc3QoZG9jKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX2hvc3ROb2RlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIHRoaXMuX2hvc3ROb2Rlcy5hZGQoZG9jLmhlYWQpO1xuICAgICAgICB9XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRG9tU2hhcmVkU3R5bGVzSG9zdC5wcm90b3R5cGUuX2FkZFN0eWxlc1RvSG9zdCA9IGZ1bmN0aW9uIChzdHlsZXMsIGhvc3QpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlID0gc3R5bGVzW2ldO1xuICAgICAgICAgICAgICAgIGdldERPTSgpLmFwcGVuZENoaWxkKGhvc3QsIGdldERPTSgpLmNyZWF0ZVN0eWxlRWxlbWVudChzdHlsZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBEb21TaGFyZWRTdHlsZXNIb3N0LnByb3RvdHlwZS5hZGRIb3N0ID0gZnVuY3Rpb24gKGhvc3ROb2RlKSB7XG4gICAgICAgICAgICB0aGlzLl9hZGRTdHlsZXNUb0hvc3QodGhpcy5fc3R5bGVzLCBob3N0Tm9kZSk7XG4gICAgICAgICAgICB0aGlzLl9ob3N0Tm9kZXMuYWRkKGhvc3ROb2RlKTtcbiAgICAgICAgfTtcbiAgICAgICAgRG9tU2hhcmVkU3R5bGVzSG9zdC5wcm90b3R5cGUucmVtb3ZlSG9zdCA9IGZ1bmN0aW9uIChob3N0Tm9kZSkgeyB0aGlzLl9ob3N0Tm9kZXMuZGVsZXRlKGhvc3ROb2RlKTsgfTtcbiAgICAgICAgRG9tU2hhcmVkU3R5bGVzSG9zdC5wcm90b3R5cGUub25TdHlsZXNBZGRlZCA9IGZ1bmN0aW9uIChhZGRpdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLl9ob3N0Tm9kZXMuZm9yRWFjaChmdW5jdGlvbiAoaG9zdE5vZGUpIHsgX3RoaXMuX2FkZFN0eWxlc1RvSG9zdChhZGRpdGlvbnMsIGhvc3ROb2RlKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIERvbVNoYXJlZFN0eWxlc0hvc3QuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBEb21TaGFyZWRTdHlsZXNIb3N0LmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbRE9DVU1FTlQsXSB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIERvbVNoYXJlZFN0eWxlc0hvc3Q7XG4gICAgfShTaGFyZWRTdHlsZXNIb3N0KSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgdmFyIE5BTUVTUEFDRV9VUklTID0ge1xuICAgICAgICAneGxpbmsnOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsXG4gICAgICAgICdzdmcnOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuICAgICAgICAneGh0bWwnOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCdcbiAgICB9O1xuICAgIHZhciBURU1QTEFURV9DT01NRU5UX1RFWFQgPSAndGVtcGxhdGUgYmluZGluZ3M9e30nO1xuICAgIHZhciBURU1QTEFURV9CSU5ESU5HU19FWFAgPSAvXnRlbXBsYXRlIGJpbmRpbmdzPSguKikkLztcbiAgICB2YXIgRG9tUm9vdFJlbmRlcmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gRG9tUm9vdFJlbmRlcmVyKGRvY3VtZW50LCBldmVudE1hbmFnZXIsIHNoYXJlZFN0eWxlc0hvc3QsIGFuaW1hdGlvbkRyaXZlcikge1xuICAgICAgICAgICAgdGhpcy5kb2N1bWVudCA9IGRvY3VtZW50O1xuICAgICAgICAgICAgdGhpcy5ldmVudE1hbmFnZXIgPSBldmVudE1hbmFnZXI7XG4gICAgICAgICAgICB0aGlzLnNoYXJlZFN0eWxlc0hvc3QgPSBzaGFyZWRTdHlsZXNIb3N0O1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb25Ecml2ZXIgPSBhbmltYXRpb25Ecml2ZXI7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyZWRDb21wb25lbnRzID0gbmV3IE1hcCgpO1xuICAgICAgICB9XG4gICAgICAgIERvbVJvb3RSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyQ29tcG9uZW50ID0gZnVuY3Rpb24gKGNvbXBvbmVudFByb3RvKSB7XG4gICAgICAgICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLnJlZ2lzdGVyZWRDb21wb25lbnRzLmdldChjb21wb25lbnRQcm90by5pZCk7XG4gICAgICAgICAgICBpZiAoIXJlbmRlcmVyKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyZXIgPSBuZXcgRG9tUmVuZGVyZXIodGhpcywgY29tcG9uZW50UHJvdG8sIHRoaXMuYW5pbWF0aW9uRHJpdmVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZ2lzdGVyZWRDb21wb25lbnRzLnNldChjb21wb25lbnRQcm90by5pZCwgcmVuZGVyZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlbmRlcmVyO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRG9tUm9vdFJlbmRlcmVyO1xuICAgIH0oKSk7XG4gICAgdmFyIERvbVJvb3RSZW5kZXJlcl8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMyhEb21Sb290UmVuZGVyZXJfLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBEb21Sb290UmVuZGVyZXJfKF9kb2N1bWVudCwgX2V2ZW50TWFuYWdlciwgc2hhcmVkU3R5bGVzSG9zdCwgYW5pbWF0aW9uRHJpdmVyKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBfZG9jdW1lbnQsIF9ldmVudE1hbmFnZXIsIHNoYXJlZFN0eWxlc0hvc3QsIGFuaW1hdGlvbkRyaXZlcik7XG4gICAgICAgIH1cbiAgICAgICAgRG9tUm9vdFJlbmRlcmVyXy5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIERvbVJvb3RSZW5kZXJlcl8uY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtET0NVTUVOVCxdIH0sXSB9LFxuICAgICAgICAgICAgeyB0eXBlOiBFdmVudE1hbmFnZXIsIH0sXG4gICAgICAgICAgICB7IHR5cGU6IERvbVNoYXJlZFN0eWxlc0hvc3QsIH0sXG4gICAgICAgICAgICB7IHR5cGU6IEFuaW1hdGlvbkRyaXZlciwgfSxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIERvbVJvb3RSZW5kZXJlcl87XG4gICAgfShEb21Sb290UmVuZGVyZXIpKTtcbiAgICB2YXIgRG9tUmVuZGVyZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBEb21SZW5kZXJlcihfcm9vdFJlbmRlcmVyLCBjb21wb25lbnRQcm90bywgX2FuaW1hdGlvbkRyaXZlcikge1xuICAgICAgICAgICAgdGhpcy5fcm9vdFJlbmRlcmVyID0gX3Jvb3RSZW5kZXJlcjtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50UHJvdG8gPSBjb21wb25lbnRQcm90bztcbiAgICAgICAgICAgIHRoaXMuX2FuaW1hdGlvbkRyaXZlciA9IF9hbmltYXRpb25Ecml2ZXI7XG4gICAgICAgICAgICB0aGlzLl9zdHlsZXMgPSBfZmxhdHRlblN0eWxlcyhjb21wb25lbnRQcm90by5pZCwgY29tcG9uZW50UHJvdG8uc3R5bGVzLCBbXSk7XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50UHJvdG8uZW5jYXBzdWxhdGlvbiAhPT0gX2FuZ3VsYXJfY29yZS5WaWV3RW5jYXBzdWxhdGlvbi5OYXRpdmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yb290UmVuZGVyZXIuc2hhcmVkU3R5bGVzSG9zdC5hZGRTdHlsZXModGhpcy5fc3R5bGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbXBvbmVudFByb3RvLmVuY2Fwc3VsYXRpb24gPT09IF9hbmd1bGFyX2NvcmUuVmlld0VuY2Fwc3VsYXRpb24uRW11bGF0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250ZW50QXR0ciA9IF9zaGltQ29udGVudEF0dHJpYnV0ZShjb21wb25lbnRQcm90by5pZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5faG9zdEF0dHIgPSBfc2hpbUhvc3RBdHRyaWJ1dGUoY29tcG9uZW50UHJvdG8uaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGVudEF0dHIgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuX2hvc3RBdHRyID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBEb21SZW5kZXJlci5wcm90b3R5cGUuc2VsZWN0Um9vdEVsZW1lbnQgPSBmdW5jdGlvbiAoc2VsZWN0b3JPck5vZGUsIGRlYnVnSW5mbykge1xuICAgICAgICAgICAgdmFyIGVsO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWxlY3Rvck9yTm9kZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBlbCA9IGdldERPTSgpLnF1ZXJ5U2VsZWN0b3IodGhpcy5fcm9vdFJlbmRlcmVyLmRvY3VtZW50LCBzZWxlY3Rvck9yTm9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzQmxhbmsoZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBzZWxlY3RvciBcXFwiXCIgKyBzZWxlY3Rvck9yTm9kZSArIFwiXFxcIiBkaWQgbm90IG1hdGNoIGFueSBlbGVtZW50c1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbCA9IHNlbGVjdG9yT3JOb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2V0RE9NKCkuY2xlYXJOb2RlcyhlbCk7XG4gICAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgIH07XG4gICAgICAgIERvbVJlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKHBhcmVudCwgbmFtZSwgZGVidWdJbmZvKSB7XG4gICAgICAgICAgICB2YXIgbnNBbmROYW1lID0gc3BsaXROYW1lc3BhY2UobmFtZSk7XG4gICAgICAgICAgICB2YXIgZWwgPSBpc1ByZXNlbnQobnNBbmROYW1lWzBdKSA/XG4gICAgICAgICAgICAgICAgZ2V0RE9NKCkuY3JlYXRlRWxlbWVudE5TKE5BTUVTUEFDRV9VUklTW25zQW5kTmFtZVswXV0sIG5zQW5kTmFtZVsxXSkgOlxuICAgICAgICAgICAgICAgIGdldERPTSgpLmNyZWF0ZUVsZW1lbnQobnNBbmROYW1lWzFdKTtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5fY29udGVudEF0dHIpKSB7XG4gICAgICAgICAgICAgICAgZ2V0RE9NKCkuc2V0QXR0cmlidXRlKGVsLCB0aGlzLl9jb250ZW50QXR0ciwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChwYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgZ2V0RE9NKCkuYXBwZW5kQ2hpbGQocGFyZW50LCBlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgIH07XG4gICAgICAgIERvbVJlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVWaWV3Um9vdCA9IGZ1bmN0aW9uIChob3N0RWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIG5vZGVzUGFyZW50O1xuICAgICAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50UHJvdG8uZW5jYXBzdWxhdGlvbiA9PT0gX2FuZ3VsYXJfY29yZS5WaWV3RW5jYXBzdWxhdGlvbi5OYXRpdmUpIHtcbiAgICAgICAgICAgICAgICBub2Rlc1BhcmVudCA9IGdldERPTSgpLmNyZWF0ZVNoYWRvd1Jvb3QoaG9zdEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jvb3RSZW5kZXJlci5zaGFyZWRTdHlsZXNIb3N0LmFkZEhvc3Qobm9kZXNQYXJlbnQpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGdldERPTSgpLmFwcGVuZENoaWxkKG5vZGVzUGFyZW50LCBnZXRET00oKS5jcmVhdGVTdHlsZUVsZW1lbnQodGhpcy5fc3R5bGVzW2ldKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLl9ob3N0QXR0cikpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0RE9NKCkuc2V0QXR0cmlidXRlKGhvc3RFbGVtZW50LCB0aGlzLl9ob3N0QXR0ciwgJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub2Rlc1BhcmVudCA9IGhvc3RFbGVtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5vZGVzUGFyZW50O1xuICAgICAgICB9O1xuICAgICAgICBEb21SZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlVGVtcGxhdGVBbmNob3IgPSBmdW5jdGlvbiAocGFyZW50RWxlbWVudCwgZGVidWdJbmZvKSB7XG4gICAgICAgICAgICB2YXIgY29tbWVudCA9IGdldERPTSgpLmNyZWF0ZUNvbW1lbnQoVEVNUExBVEVfQ09NTUVOVF9URVhUKTtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQocGFyZW50RWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICBnZXRET00oKS5hcHBlbmRDaGlsZChwYXJlbnRFbGVtZW50LCBjb21tZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb21tZW50O1xuICAgICAgICB9O1xuICAgICAgICBEb21SZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlVGV4dCA9IGZ1bmN0aW9uIChwYXJlbnRFbGVtZW50LCB2YWx1ZSwgZGVidWdJbmZvKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IGdldERPTSgpLmNyZWF0ZVRleHROb2RlKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQocGFyZW50RWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICBnZXRET00oKS5hcHBlbmRDaGlsZChwYXJlbnRFbGVtZW50LCBub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9O1xuICAgICAgICBEb21SZW5kZXJlci5wcm90b3R5cGUucHJvamVjdE5vZGVzID0gZnVuY3Rpb24gKHBhcmVudEVsZW1lbnQsIG5vZGVzKSB7XG4gICAgICAgICAgICBpZiAoaXNCbGFuayhwYXJlbnRFbGVtZW50KSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBhcHBlbmROb2RlcyhwYXJlbnRFbGVtZW50LCBub2Rlcyk7XG4gICAgICAgIH07XG4gICAgICAgIERvbVJlbmRlcmVyLnByb3RvdHlwZS5hdHRhY2hWaWV3QWZ0ZXIgPSBmdW5jdGlvbiAobm9kZSwgdmlld1Jvb3ROb2RlcykgeyBtb3ZlTm9kZXNBZnRlclNpYmxpbmcobm9kZSwgdmlld1Jvb3ROb2Rlcyk7IH07XG4gICAgICAgIERvbVJlbmRlcmVyLnByb3RvdHlwZS5kZXRhY2hWaWV3ID0gZnVuY3Rpb24gKHZpZXdSb290Tm9kZXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlld1Jvb3ROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGdldERPTSgpLnJlbW92ZSh2aWV3Um9vdE5vZGVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRG9tUmVuZGVyZXIucHJvdG90eXBlLmRlc3Ryb3lWaWV3ID0gZnVuY3Rpb24gKGhvc3RFbGVtZW50LCB2aWV3QWxsTm9kZXMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbXBvbmVudFByb3RvLmVuY2Fwc3VsYXRpb24gPT09IF9hbmd1bGFyX2NvcmUuVmlld0VuY2Fwc3VsYXRpb24uTmF0aXZlICYmIGlzUHJlc2VudChob3N0RWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yb290UmVuZGVyZXIuc2hhcmVkU3R5bGVzSG9zdC5yZW1vdmVIb3N0KGdldERPTSgpLmdldFNoYWRvd1Jvb3QoaG9zdEVsZW1lbnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRG9tUmVuZGVyZXIucHJvdG90eXBlLmxpc3RlbiA9IGZ1bmN0aW9uIChyZW5kZXJFbGVtZW50LCBuYW1lLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3RSZW5kZXJlci5ldmVudE1hbmFnZXIuYWRkRXZlbnRMaXN0ZW5lcihyZW5kZXJFbGVtZW50LCBuYW1lLCBkZWNvcmF0ZVByZXZlbnREZWZhdWx0KGNhbGxiYWNrKSk7XG4gICAgICAgIH07XG4gICAgICAgIERvbVJlbmRlcmVyLnByb3RvdHlwZS5saXN0ZW5HbG9iYWwgPSBmdW5jdGlvbiAodGFyZ2V0LCBuYW1lLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3RSZW5kZXJlci5ldmVudE1hbmFnZXIuYWRkR2xvYmFsRXZlbnRMaXN0ZW5lcih0YXJnZXQsIG5hbWUsIGRlY29yYXRlUHJldmVudERlZmF1bHQoY2FsbGJhY2spKTtcbiAgICAgICAgfTtcbiAgICAgICAgRG9tUmVuZGVyZXIucHJvdG90eXBlLnNldEVsZW1lbnRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChyZW5kZXJFbGVtZW50LCBwcm9wZXJ0eU5hbWUsIHByb3BlcnR5VmFsdWUpIHtcbiAgICAgICAgICAgIGdldERPTSgpLnNldFByb3BlcnR5KHJlbmRlckVsZW1lbnQsIHByb3BlcnR5TmFtZSwgcHJvcGVydHlWYWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIERvbVJlbmRlcmVyLnByb3RvdHlwZS5zZXRFbGVtZW50QXR0cmlidXRlID0gZnVuY3Rpb24gKHJlbmRlckVsZW1lbnQsIGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgYXR0ck5zO1xuICAgICAgICAgICAgdmFyIG5zQW5kTmFtZSA9IHNwbGl0TmFtZXNwYWNlKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChuc0FuZE5hbWVbMF0pKSB7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlTmFtZSA9IG5zQW5kTmFtZVswXSArICc6JyArIG5zQW5kTmFtZVsxXTtcbiAgICAgICAgICAgICAgICBhdHRyTnMgPSBOQU1FU1BBQ0VfVVJJU1tuc0FuZE5hbWVbMF1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChhdHRyaWJ1dGVWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KGF0dHJOcykpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0RE9NKCkuc2V0QXR0cmlidXRlTlMocmVuZGVyRWxlbWVudCwgYXR0ck5zLCBhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBnZXRET00oKS5zZXRBdHRyaWJ1dGUocmVuZGVyRWxlbWVudCwgYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoYXR0ck5zKSkge1xuICAgICAgICAgICAgICAgICAgICBnZXRET00oKS5yZW1vdmVBdHRyaWJ1dGVOUyhyZW5kZXJFbGVtZW50LCBhdHRyTnMsIG5zQW5kTmFtZVsxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBnZXRET00oKS5yZW1vdmVBdHRyaWJ1dGUocmVuZGVyRWxlbWVudCwgYXR0cmlidXRlTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBEb21SZW5kZXJlci5wcm90b3R5cGUuc2V0QmluZGluZ0RlYnVnSW5mbyA9IGZ1bmN0aW9uIChyZW5kZXJFbGVtZW50LCBwcm9wZXJ0eU5hbWUsIHByb3BlcnR5VmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBkYXNoQ2FzZWRQcm9wZXJ0eU5hbWUgPSBjYW1lbENhc2VUb0Rhc2hDYXNlKHByb3BlcnR5TmFtZSk7XG4gICAgICAgICAgICBpZiAoZ2V0RE9NKCkuaXNDb21tZW50Tm9kZShyZW5kZXJFbGVtZW50KSkge1xuICAgICAgICAgICAgICAgIHZhciBleGlzdGluZ0JpbmRpbmdzID0gZ2V0RE9NKCkuZ2V0VGV4dChyZW5kZXJFbGVtZW50KS5yZXBsYWNlKC9cXG4vZywgJycpLm1hdGNoKFRFTVBMQVRFX0JJTkRJTkdTX0VYUCk7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnNlZEJpbmRpbmdzID0gSlNPTi5wYXJzZShleGlzdGluZ0JpbmRpbmdzWzFdKTtcbiAgICAgICAgICAgICAgICBwYXJzZWRCaW5kaW5nc1tkYXNoQ2FzZWRQcm9wZXJ0eU5hbWVdID0gcHJvcGVydHlWYWx1ZTtcbiAgICAgICAgICAgICAgICBnZXRET00oKS5zZXRUZXh0KHJlbmRlckVsZW1lbnQsIFRFTVBMQVRFX0NPTU1FTlRfVEVYVC5yZXBsYWNlKCd7fScsIEpTT04uc3RyaW5naWZ5KHBhcnNlZEJpbmRpbmdzLCBudWxsLCAyKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRFbGVtZW50QXR0cmlidXRlKHJlbmRlckVsZW1lbnQsIHByb3BlcnR5TmFtZSwgcHJvcGVydHlWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIERvbVJlbmRlcmVyLnByb3RvdHlwZS5zZXRFbGVtZW50Q2xhc3MgPSBmdW5jdGlvbiAocmVuZGVyRWxlbWVudCwgY2xhc3NOYW1lLCBpc0FkZCkge1xuICAgICAgICAgICAgaWYgKGlzQWRkKSB7XG4gICAgICAgICAgICAgICAgZ2V0RE9NKCkuYWRkQ2xhc3MocmVuZGVyRWxlbWVudCwgY2xhc3NOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdldERPTSgpLnJlbW92ZUNsYXNzKHJlbmRlckVsZW1lbnQsIGNsYXNzTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIERvbVJlbmRlcmVyLnByb3RvdHlwZS5zZXRFbGVtZW50U3R5bGUgPSBmdW5jdGlvbiAocmVuZGVyRWxlbWVudCwgc3R5bGVOYW1lLCBzdHlsZVZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHN0eWxlVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZ2V0RE9NKCkuc2V0U3R5bGUocmVuZGVyRWxlbWVudCwgc3R5bGVOYW1lLCBzdHJpbmdpZnkoc3R5bGVWYWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2V0RE9NKCkucmVtb3ZlU3R5bGUocmVuZGVyRWxlbWVudCwgc3R5bGVOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRG9tUmVuZGVyZXIucHJvdG90eXBlLmludm9rZUVsZW1lbnRNZXRob2QgPSBmdW5jdGlvbiAocmVuZGVyRWxlbWVudCwgbWV0aG9kTmFtZSwgYXJncykge1xuICAgICAgICAgICAgZ2V0RE9NKCkuaW52b2tlKHJlbmRlckVsZW1lbnQsIG1ldGhvZE5hbWUsIGFyZ3MpO1xuICAgICAgICB9O1xuICAgICAgICBEb21SZW5kZXJlci5wcm90b3R5cGUuc2V0VGV4dCA9IGZ1bmN0aW9uIChyZW5kZXJOb2RlLCB0ZXh0KSB7IGdldERPTSgpLnNldFRleHQocmVuZGVyTm9kZSwgdGV4dCk7IH07XG4gICAgICAgIERvbVJlbmRlcmVyLnByb3RvdHlwZS5hbmltYXRlID0gZnVuY3Rpb24gKGVsZW1lbnQsIHN0YXJ0aW5nU3R5bGVzLCBrZXlmcmFtZXMsIGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYW5pbWF0aW9uRHJpdmVyLmFuaW1hdGUoZWxlbWVudCwgc3RhcnRpbmdTdHlsZXMsIGtleWZyYW1lcywgZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRG9tUmVuZGVyZXI7XG4gICAgfSgpKTtcbiAgICBmdW5jdGlvbiBtb3ZlTm9kZXNBZnRlclNpYmxpbmcoc2libGluZyAvKiogVE9ETyAjOTEwMCAqLywgbm9kZXMgLyoqIFRPRE8gIzkxMDAgKi8pIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IGdldERPTSgpLnBhcmVudEVsZW1lbnQoc2libGluZyk7XG4gICAgICAgIGlmIChub2Rlcy5sZW5ndGggPiAwICYmIGlzUHJlc2VudChwYXJlbnQpKSB7XG4gICAgICAgICAgICB2YXIgbmV4dFNpYmxpbmcgPSBnZXRET00oKS5uZXh0U2libGluZyhzaWJsaW5nKTtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQobmV4dFNpYmxpbmcpKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBnZXRET00oKS5pbnNlcnRCZWZvcmUobmV4dFNpYmxpbmcsIG5vZGVzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGdldERPTSgpLmFwcGVuZENoaWxkKHBhcmVudCwgbm9kZXNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBhcHBlbmROb2RlcyhwYXJlbnQgLyoqIFRPRE8gIzkxMDAgKi8sIG5vZGVzIC8qKiBUT0RPICM5MTAwICovKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGdldERPTSgpLmFwcGVuZENoaWxkKHBhcmVudCwgbm9kZXNbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlY29yYXRlUHJldmVudERlZmF1bHQoZXZlbnRIYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQgLyoqIFRPRE8gIzkxMDAgKi8pIHtcbiAgICAgICAgICAgIHZhciBhbGxvd0RlZmF1bHRCZWhhdmlvciA9IGV2ZW50SGFuZGxlcihldmVudCk7XG4gICAgICAgICAgICBpZiAoYWxsb3dEZWZhdWx0QmVoYXZpb3IgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyh0Ym9zY2gpOiBtb3ZlIHByZXZlbnREZWZhdWx0IGludG8gZXZlbnQgcGx1Z2lucy4uLlxuICAgICAgICAgICAgICAgIGdldERPTSgpLnByZXZlbnREZWZhdWx0KGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgdmFyIENPTVBPTkVOVF9SRUdFWCA9IC8lQ09NUCUvZztcbiAgICB2YXIgQ09NUE9ORU5UX1ZBUklBQkxFID0gJyVDT01QJSc7XG4gICAgdmFyIEhPU1RfQVRUUiA9IFwiX25naG9zdC1cIiArIENPTVBPTkVOVF9WQVJJQUJMRTtcbiAgICB2YXIgQ09OVEVOVF9BVFRSID0gXCJfbmdjb250ZW50LVwiICsgQ09NUE9ORU5UX1ZBUklBQkxFO1xuICAgIGZ1bmN0aW9uIF9zaGltQ29udGVudEF0dHJpYnV0ZShjb21wb25lbnRTaG9ydElkKSB7XG4gICAgICAgIHJldHVybiBDT05URU5UX0FUVFIucmVwbGFjZShDT01QT05FTlRfUkVHRVgsIGNvbXBvbmVudFNob3J0SWQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfc2hpbUhvc3RBdHRyaWJ1dGUoY29tcG9uZW50U2hvcnRJZCkge1xuICAgICAgICByZXR1cm4gSE9TVF9BVFRSLnJlcGxhY2UoQ09NUE9ORU5UX1JFR0VYLCBjb21wb25lbnRTaG9ydElkKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX2ZsYXR0ZW5TdHlsZXMoY29tcElkLCBzdHlsZXMsIHRhcmdldCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gc3R5bGVzW2ldO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc3R5bGUpKSB7XG4gICAgICAgICAgICAgICAgX2ZsYXR0ZW5TdHlsZXMoY29tcElkLCBzdHlsZSwgdGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0eWxlID0gc3R5bGUucmVwbGFjZShDT01QT05FTlRfUkVHRVgsIGNvbXBJZCk7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2goc3R5bGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIHZhciBOU19QUkVGSVhfUkUgPSAvXjooW146XSspOiguKykkLztcbiAgICBmdW5jdGlvbiBzcGxpdE5hbWVzcGFjZShuYW1lKSB7XG4gICAgICAgIGlmIChuYW1lWzBdICE9ICc6Jykge1xuICAgICAgICAgICAgcmV0dXJuIFtudWxsLCBuYW1lXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWF0Y2ggPSBuYW1lLm1hdGNoKE5TX1BSRUZJWF9SRSk7XG4gICAgICAgIHJldHVybiBbbWF0Y2hbMV0sIG1hdGNoWzJdXTtcbiAgICB9XG5cbiAgICB2YXIgQ09SRV9UT0tFTlMgPSB7XG4gICAgICAgICdBcHBsaWNhdGlvblJlZic6IF9hbmd1bGFyX2NvcmUuQXBwbGljYXRpb25SZWYsXG4gICAgICAgICdOZ1pvbmUnOiBfYW5ndWxhcl9jb3JlLk5nWm9uZVxuICAgIH07XG4gICAgdmFyIElOU1BFQ1RfR0xPQkFMX05BTUUgPSAnbmcucHJvYmUnO1xuICAgIHZhciBDT1JFX1RPS0VOU19HTE9CQUxfTkFNRSA9ICduZy5jb3JlVG9rZW5zJztcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEge0BsaW5rIERlYnVnRWxlbWVudH0gZm9yIHRoZSBnaXZlbiBuYXRpdmUgRE9NIGVsZW1lbnQsIG9yXG4gICAgICogbnVsbCBpZiB0aGUgZ2l2ZW4gbmF0aXZlIGVsZW1lbnQgZG9lcyBub3QgaGF2ZSBhbiBBbmd1bGFyIHZpZXcgYXNzb2NpYXRlZFxuICAgICAqIHdpdGggaXQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5zcGVjdE5hdGl2ZUVsZW1lbnQoZWxlbWVudCAvKiogVE9ETyAjOTEwMCAqLykge1xuICAgICAgICByZXR1cm4gX2FuZ3VsYXJfY29yZS5nZXREZWJ1Z05vZGUoZWxlbWVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgTmdQcm9iZVRva2VuID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTmdQcm9iZVRva2VuKG5hbWUsIHRva2VuKSB7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBOZ1Byb2JlVG9rZW47XG4gICAgfSgpKTtcbiAgICBmdW5jdGlvbiBfY3JlYXRlQ29uZGl0aW9uYWxSb290UmVuZGVyZXIocm9vdFJlbmRlcmVyIC8qKiBUT0RPICM5MTAwICovLCBleHRyYVRva2Vucykge1xuICAgICAgICBpZiAoX2FuZ3VsYXJfY29yZS5pc0Rldk1vZGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIF9jcmVhdGVSb290UmVuZGVyZXIocm9vdFJlbmRlcmVyLCBleHRyYVRva2Vucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvb3RSZW5kZXJlcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gX2NyZWF0ZVJvb3RSZW5kZXJlcihyb290UmVuZGVyZXIgLyoqIFRPRE8gIzkxMDAgKi8sIGV4dHJhVG9rZW5zKSB7XG4gICAgICAgIGdldERPTSgpLnNldEdsb2JhbFZhcihJTlNQRUNUX0dMT0JBTF9OQU1FLCBpbnNwZWN0TmF0aXZlRWxlbWVudCk7XG4gICAgICAgIGdldERPTSgpLnNldEdsb2JhbFZhcihDT1JFX1RPS0VOU19HTE9CQUxfTkFNRSwgU3RyaW5nTWFwV3JhcHBlci5tZXJnZShDT1JFX1RPS0VOUywgX25nUHJvYmVUb2tlbnNUb01hcChleHRyYVRva2VucyB8fCBbXSkpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWJ1Z0RvbVJvb3RSZW5kZXJlcihyb290UmVuZGVyZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfbmdQcm9iZVRva2Vuc1RvTWFwKHRva2Vucykge1xuICAgICAgICByZXR1cm4gdG9rZW5zLnJlZHVjZShmdW5jdGlvbiAocHJldiwgdCkgeyByZXR1cm4gKHByZXZbdC5uYW1lXSA9IHQudG9rZW4sIHByZXYpOyB9LCB7fSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVycyB3aGljaCBzdXBwb3J0IGRlYnVnZ2luZyBBbmd1bGFyIGFwcGxpY2F0aW9ucyAoZS5nLiB2aWEgYG5nLnByb2JlYCkuXG4gICAgICovXG4gICAgdmFyIEVMRU1FTlRfUFJPQkVfUFJPVklERVJTID0gW3tcbiAgICAgICAgICAgIHByb3ZpZGU6IF9hbmd1bGFyX2NvcmUuUm9vdFJlbmRlcmVyLFxuICAgICAgICAgICAgdXNlRmFjdG9yeTogX2NyZWF0ZUNvbmRpdGlvbmFsUm9vdFJlbmRlcmVyLFxuICAgICAgICAgICAgZGVwczogW0RvbVJvb3RSZW5kZXJlciwgW05nUHJvYmVUb2tlbiwgbmV3IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwoKV1dXG4gICAgICAgIH1dO1xuICAgIHZhciBFTEVNRU5UX1BST0JFX1BST1ZJREVSU19QUk9EX01PREUgPSBbe1xuICAgICAgICAgICAgcHJvdmlkZTogX2FuZ3VsYXJfY29yZS5Sb290UmVuZGVyZXIsXG4gICAgICAgICAgICB1c2VGYWN0b3J5OiBfY3JlYXRlUm9vdFJlbmRlcmVyLFxuICAgICAgICAgICAgZGVwczogW0RvbVJvb3RSZW5kZXJlciwgW05nUHJvYmVUb2tlbiwgbmV3IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwoKV1dXG4gICAgICAgIH1dO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkNSA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIHZhciBEb21FdmVudHNQbHVnaW4gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkNShEb21FdmVudHNQbHVnaW4sIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIERvbUV2ZW50c1BsdWdpbigpIHtcbiAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoaXMgcGx1Z2luIHNob3VsZCBjb21lIGxhc3QgaW4gdGhlIGxpc3Qgb2YgcGx1Z2lucywgYmVjYXVzZSBpdCBhY2NlcHRzIGFsbFxuICAgICAgICAvLyBldmVudHMuXG4gICAgICAgIERvbUV2ZW50c1BsdWdpbi5wcm90b3R5cGUuc3VwcG9ydHMgPSBmdW5jdGlvbiAoZXZlbnROYW1lKSB7IHJldHVybiB0cnVlOyB9O1xuICAgICAgICBEb21FdmVudHNQbHVnaW4ucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoZWxlbWVudCwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgICAgICB2YXIgem9uZSA9IHRoaXMubWFuYWdlci5nZXRab25lKCk7XG4gICAgICAgICAgICB2YXIgb3V0c2lkZUhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQgLyoqIFRPRE8gIzkxMDAgKi8pIHsgcmV0dXJuIHpvbmUucnVuR3VhcmRlZChmdW5jdGlvbiAoKSB7IHJldHVybiBoYW5kbGVyKGV2ZW50KTsgfSk7IH07XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYW5hZ2VyLmdldFpvbmUoKS5ydW5PdXRzaWRlQW5ndWxhcihmdW5jdGlvbiAoKSB7IHJldHVybiBnZXRET00oKS5vbkFuZENhbmNlbChlbGVtZW50LCBldmVudE5hbWUsIG91dHNpZGVIYW5kbGVyKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIERvbUV2ZW50c1BsdWdpbi5wcm90b3R5cGUuYWRkR2xvYmFsRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uICh0YXJnZXQsIGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBnZXRET00oKS5nZXRHbG9iYWxFdmVudFRhcmdldCh0YXJnZXQpO1xuICAgICAgICAgICAgdmFyIHpvbmUgPSB0aGlzLm1hbmFnZXIuZ2V0Wm9uZSgpO1xuICAgICAgICAgICAgdmFyIG91dHNpZGVIYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50IC8qKiBUT0RPICM5MTAwICovKSB7IHJldHVybiB6b25lLnJ1bkd1YXJkZWQoZnVuY3Rpb24gKCkgeyByZXR1cm4gaGFuZGxlcihldmVudCk7IH0pOyB9O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFuYWdlci5nZXRab25lKCkucnVuT3V0c2lkZUFuZ3VsYXIoZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2V0RE9NKCkub25BbmRDYW5jZWwoZWxlbWVudCwgZXZlbnROYW1lLCBvdXRzaWRlSGFuZGxlcik7IH0pO1xuICAgICAgICB9O1xuICAgICAgICBEb21FdmVudHNQbHVnaW4uZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBEb21FdmVudHNQbHVnaW4uY3RvclBhcmFtZXRlcnMgPSBbXTtcbiAgICAgICAgcmV0dXJuIERvbUV2ZW50c1BsdWdpbjtcbiAgICB9KEV2ZW50TWFuYWdlclBsdWdpbikpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkNyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIHZhciBfZXZlbnROYW1lcyA9IHtcbiAgICAgICAgLy8gcGFuXG4gICAgICAgICdwYW4nOiB0cnVlLFxuICAgICAgICAncGFuc3RhcnQnOiB0cnVlLFxuICAgICAgICAncGFubW92ZSc6IHRydWUsXG4gICAgICAgICdwYW5lbmQnOiB0cnVlLFxuICAgICAgICAncGFuY2FuY2VsJzogdHJ1ZSxcbiAgICAgICAgJ3BhbmxlZnQnOiB0cnVlLFxuICAgICAgICAncGFucmlnaHQnOiB0cnVlLFxuICAgICAgICAncGFudXAnOiB0cnVlLFxuICAgICAgICAncGFuZG93bic6IHRydWUsXG4gICAgICAgIC8vIHBpbmNoXG4gICAgICAgICdwaW5jaCc6IHRydWUsXG4gICAgICAgICdwaW5jaHN0YXJ0JzogdHJ1ZSxcbiAgICAgICAgJ3BpbmNobW92ZSc6IHRydWUsXG4gICAgICAgICdwaW5jaGVuZCc6IHRydWUsXG4gICAgICAgICdwaW5jaGNhbmNlbCc6IHRydWUsXG4gICAgICAgICdwaW5jaGluJzogdHJ1ZSxcbiAgICAgICAgJ3BpbmNob3V0JzogdHJ1ZSxcbiAgICAgICAgLy8gcHJlc3NcbiAgICAgICAgJ3ByZXNzJzogdHJ1ZSxcbiAgICAgICAgJ3ByZXNzdXAnOiB0cnVlLFxuICAgICAgICAvLyByb3RhdGVcbiAgICAgICAgJ3JvdGF0ZSc6IHRydWUsXG4gICAgICAgICdyb3RhdGVzdGFydCc6IHRydWUsXG4gICAgICAgICdyb3RhdGVtb3ZlJzogdHJ1ZSxcbiAgICAgICAgJ3JvdGF0ZWVuZCc6IHRydWUsXG4gICAgICAgICdyb3RhdGVjYW5jZWwnOiB0cnVlLFxuICAgICAgICAvLyBzd2lwZVxuICAgICAgICAnc3dpcGUnOiB0cnVlLFxuICAgICAgICAnc3dpcGVsZWZ0JzogdHJ1ZSxcbiAgICAgICAgJ3N3aXBlcmlnaHQnOiB0cnVlLFxuICAgICAgICAnc3dpcGV1cCc6IHRydWUsXG4gICAgICAgICdzd2lwZWRvd24nOiB0cnVlLFxuICAgICAgICAvLyB0YXBcbiAgICAgICAgJ3RhcCc6IHRydWUsXG4gICAgfTtcbiAgICB2YXIgSGFtbWVyR2VzdHVyZXNQbHVnaW5Db21tb24gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkNyhIYW1tZXJHZXN0dXJlc1BsdWdpbkNvbW1vbiwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gSGFtbWVyR2VzdHVyZXNQbHVnaW5Db21tb24oKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBIYW1tZXJHZXN0dXJlc1BsdWdpbkNvbW1vbi5wcm90b3R5cGUuc3VwcG9ydHMgPSBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gX2V2ZW50TmFtZXMuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gSGFtbWVyR2VzdHVyZXNQbHVnaW5Db21tb247XG4gICAgfShFdmVudE1hbmFnZXJQbHVnaW4pKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDYgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIERJIHRva2VuIHRoYXQgeW91IGNhbiB1c2UgdG8gcHJvdmlkZXtAbGluayBIYW1tZXJHZXN0dXJlQ29uZmlnfSB0byBBbmd1bGFyLiBVc2UgaXQgdG8gY29uZmlndXJlXG4gICAgICogSGFtbWVyIGdlc3R1cmVzLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBIQU1NRVJfR0VTVFVSRV9DT05GSUcgPSBuZXcgX2FuZ3VsYXJfY29yZS5PcGFxdWVUb2tlbignSGFtbWVyR2VzdHVyZUNvbmZpZycpO1xuICAgIC8qKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgSGFtbWVyR2VzdHVyZUNvbmZpZyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEhhbW1lckdlc3R1cmVDb25maWcoKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50cyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5vdmVycmlkZXMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBIYW1tZXJHZXN0dXJlQ29uZmlnLnByb3RvdHlwZS5idWlsZEhhbW1lciA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgbWMgPSBuZXcgSGFtbWVyKGVsZW1lbnQpO1xuICAgICAgICAgICAgbWMuZ2V0KCdwaW5jaCcpLnNldCh7IGVuYWJsZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIG1jLmdldCgncm90YXRlJykuc2V0KHsgZW5hYmxlOiB0cnVlIH0pO1xuICAgICAgICAgICAgZm9yICh2YXIgZXZlbnROYW1lIGluIHRoaXMub3ZlcnJpZGVzKSB7XG4gICAgICAgICAgICAgICAgbWMuZ2V0KGV2ZW50TmFtZSkuc2V0KHRoaXMub3ZlcnJpZGVzW2V2ZW50TmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1jO1xuICAgICAgICB9O1xuICAgICAgICBIYW1tZXJHZXN0dXJlQ29uZmlnLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgSGFtbWVyR2VzdHVyZUNvbmZpZy5jdG9yUGFyYW1ldGVycyA9IFtdO1xuICAgICAgICByZXR1cm4gSGFtbWVyR2VzdHVyZUNvbmZpZztcbiAgICB9KCkpO1xuICAgIHZhciBIYW1tZXJHZXN0dXJlc1BsdWdpbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQ2KEhhbW1lckdlc3R1cmVzUGx1Z2luLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBIYW1tZXJHZXN0dXJlc1BsdWdpbihfY29uZmlnKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX2NvbmZpZyA9IF9jb25maWc7XG4gICAgICAgIH1cbiAgICAgICAgSGFtbWVyR2VzdHVyZXNQbHVnaW4ucHJvdG90eXBlLnN1cHBvcnRzID0gZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgICAgICAgaWYgKCFfc3VwZXIucHJvdG90eXBlLnN1cHBvcnRzLmNhbGwodGhpcywgZXZlbnROYW1lKSAmJiAhdGhpcy5pc0N1c3RvbUV2ZW50KGV2ZW50TmFtZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKCFpc1ByZXNlbnQod2luZG93WydIYW1tZXInXSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJIYW1tZXIuanMgaXMgbm90IGxvYWRlZCwgY2FuIG5vdCBiaW5kIFwiICsgZXZlbnROYW1lICsgXCIgZXZlbnRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgSGFtbWVyR2VzdHVyZXNQbHVnaW4ucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoZWxlbWVudCwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHpvbmUgPSB0aGlzLm1hbmFnZXIuZ2V0Wm9uZSgpO1xuICAgICAgICAgICAgZXZlbnROYW1lID0gZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICByZXR1cm4gem9uZS5ydW5PdXRzaWRlQW5ndWxhcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRpbmcgdGhlIG1hbmFnZXIgYmluZCBldmVudHMsIG11c3QgYmUgZG9uZSBvdXRzaWRlIG9mIGFuZ3VsYXJcbiAgICAgICAgICAgICAgICB2YXIgbWMgPSBfdGhpcy5fY29uZmlnLmJ1aWxkSGFtbWVyKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uIChldmVudE9iaiAvKiogVE9ETyAjPz8/PyAqLykge1xuICAgICAgICAgICAgICAgICAgICB6b25lLnJ1bkd1YXJkZWQoZnVuY3Rpb24gKCkgeyBoYW5kbGVyKGV2ZW50T2JqKTsgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBtYy5vbihldmVudE5hbWUsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyBtYy5vZmYoZXZlbnROYW1lLCBjYWxsYmFjayk7IH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgSGFtbWVyR2VzdHVyZXNQbHVnaW4ucHJvdG90eXBlLmlzQ3VzdG9tRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnROYW1lKSB7IHJldHVybiB0aGlzLl9jb25maWcuZXZlbnRzLmluZGV4T2YoZXZlbnROYW1lKSA+IC0xOyB9O1xuICAgICAgICBIYW1tZXJHZXN0dXJlc1BsdWdpbi5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIEhhbW1lckdlc3R1cmVzUGx1Z2luLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBIYW1tZXJHZXN0dXJlQ29uZmlnLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW0hBTU1FUl9HRVNUVVJFX0NPTkZJRyxdIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gSGFtbWVyR2VzdHVyZXNQbHVnaW47XG4gICAgfShIYW1tZXJHZXN0dXJlc1BsdWdpbkNvbW1vbikpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkOCA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIHZhciBtb2RpZmllcktleXMgPSBbJ2FsdCcsICdjb250cm9sJywgJ21ldGEnLCAnc2hpZnQnXTtcbiAgICB2YXIgbW9kaWZpZXJLZXlHZXR0ZXJzID0ge1xuICAgICAgICAnYWx0JzogZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBldmVudC5hbHRLZXk7IH0sXG4gICAgICAgICdjb250cm9sJzogZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBldmVudC5jdHJsS2V5OyB9LFxuICAgICAgICAnbWV0YSc6IGZ1bmN0aW9uIChldmVudCkgeyByZXR1cm4gZXZlbnQubWV0YUtleTsgfSxcbiAgICAgICAgJ3NoaWZ0JzogZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBldmVudC5zaGlmdEtleTsgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBLZXlFdmVudHNQbHVnaW4gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkOChLZXlFdmVudHNQbHVnaW4sIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEtleUV2ZW50c1BsdWdpbigpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIEtleUV2ZW50c1BsdWdpbi5wcm90b3R5cGUuc3VwcG9ydHMgPSBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNQcmVzZW50KEtleUV2ZW50c1BsdWdpbi5wYXJzZUV2ZW50TmFtZShldmVudE5hbWUpKTtcbiAgICAgICAgfTtcbiAgICAgICAgS2V5RXZlbnRzUGx1Z2luLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGVsZW1lbnQsIGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgICAgICAgICAgdmFyIHBhcnNlZEV2ZW50ID0gS2V5RXZlbnRzUGx1Z2luLnBhcnNlRXZlbnROYW1lKGV2ZW50TmFtZSk7XG4gICAgICAgICAgICB2YXIgb3V0c2lkZUhhbmRsZXIgPSBLZXlFdmVudHNQbHVnaW4uZXZlbnRDYWxsYmFjayhlbGVtZW50LCBwYXJzZWRFdmVudFsnZnVsbEtleSddLCBoYW5kbGVyLCB0aGlzLm1hbmFnZXIuZ2V0Wm9uZSgpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hbmFnZXIuZ2V0Wm9uZSgpLnJ1bk91dHNpZGVBbmd1bGFyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0RE9NKCkub25BbmRDYW5jZWwoZWxlbWVudCwgcGFyc2VkRXZlbnRbJ2RvbUV2ZW50TmFtZSddLCBvdXRzaWRlSGFuZGxlcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgS2V5RXZlbnRzUGx1Z2luLnBhcnNlRXZlbnROYW1lID0gZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgICAgICAgdmFyIHBhcnRzID0gZXZlbnROYW1lLnRvTG93ZXJDYXNlKCkuc3BsaXQoJy4nKTtcbiAgICAgICAgICAgIHZhciBkb21FdmVudE5hbWUgPSBwYXJ0cy5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKChwYXJ0cy5sZW5ndGggPT09IDApIHx8ICEoZG9tRXZlbnROYW1lID09PSAna2V5ZG93bicgfHwgZG9tRXZlbnROYW1lID09PSAna2V5dXAnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGtleSA9IEtleUV2ZW50c1BsdWdpbi5fbm9ybWFsaXplS2V5KHBhcnRzLnBvcCgpKTtcbiAgICAgICAgICAgIHZhciBmdWxsS2V5ID0gJyc7XG4gICAgICAgICAgICBtb2RpZmllcktleXMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXJOYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKExpc3RXcmFwcGVyLmNvbnRhaW5zKHBhcnRzLCBtb2RpZmllck5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIExpc3RXcmFwcGVyLnJlbW92ZShwYXJ0cywgbW9kaWZpZXJOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgZnVsbEtleSArPSBtb2RpZmllck5hbWUgKyAnLic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmdWxsS2V5ICs9IGtleTtcbiAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggIT0gMCB8fCBrZXkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuaW5nIG51bGwgaW5zdGVhZCBvZiB0aHJvd2luZyB0byBsZXQgYW5vdGhlciBwbHVnaW4gcHJvY2VzcyB0aGUgZXZlbnRcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgIHJlc3VsdFsnZG9tRXZlbnROYW1lJ10gPSBkb21FdmVudE5hbWU7XG4gICAgICAgICAgICByZXN1bHRbJ2Z1bGxLZXknXSA9IGZ1bGxLZXk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgICBLZXlFdmVudHNQbHVnaW4uZ2V0RXZlbnRGdWxsS2V5ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgZnVsbEtleSA9ICcnO1xuICAgICAgICAgICAgdmFyIGtleSA9IGdldERPTSgpLmdldEV2ZW50S2V5KGV2ZW50KTtcbiAgICAgICAgICAgIGtleSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gJyAnKSB7XG4gICAgICAgICAgICAgICAga2V5ID0gJ3NwYWNlJzsgLy8gZm9yIHJlYWRhYmlsaXR5XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgPT09ICcuJykge1xuICAgICAgICAgICAgICAgIGtleSA9ICdkb3QnOyAvLyBiZWNhdXNlICcuJyBpcyB1c2VkIGFzIGEgc2VwYXJhdG9yIGluIGV2ZW50IG5hbWVzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtb2RpZmllcktleXMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXJOYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1vZGlmaWVyTmFtZSAhPSBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1vZGlmaWVyR2V0dGVyID0gbW9kaWZpZXJLZXlHZXR0ZXJzW21vZGlmaWVyTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RpZmllckdldHRlcihldmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGxLZXkgKz0gbW9kaWZpZXJOYW1lICsgJy4nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmdWxsS2V5ICs9IGtleTtcbiAgICAgICAgICAgIHJldHVybiBmdWxsS2V5O1xuICAgICAgICB9O1xuICAgICAgICBLZXlFdmVudHNQbHVnaW4uZXZlbnRDYWxsYmFjayA9IGZ1bmN0aW9uIChlbGVtZW50LCBmdWxsS2V5LCBoYW5kbGVyLCB6b25lKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50IC8qKiBUT0RPICM5MTAwICovKSB7XG4gICAgICAgICAgICAgICAgaWYgKEtleUV2ZW50c1BsdWdpbi5nZXRFdmVudEZ1bGxLZXkoZXZlbnQpID09PSBmdWxsS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHpvbmUucnVuR3VhcmRlZChmdW5jdGlvbiAoKSB7IHJldHVybiBoYW5kbGVyKGV2ZW50KTsgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBLZXlFdmVudHNQbHVnaW4uX25vcm1hbGl6ZUtleSA9IGZ1bmN0aW9uIChrZXlOYW1lKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBzd2l0Y2ggdG8gYSBTdHJpbmdNYXAgaWYgdGhlIG1hcHBpbmcgZ3Jvd3MgdG9vIG11Y2hcbiAgICAgICAgICAgIHN3aXRjaCAoa2V5TmFtZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2VzYyc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnZXNjYXBlJztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5TmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgS2V5RXZlbnRzUGx1Z2luLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgS2V5RXZlbnRzUGx1Z2luLmN0b3JQYXJhbWV0ZXJzID0gW107XG4gICAgICAgIHJldHVybiBLZXlFdmVudHNQbHVnaW47XG4gICAgfShFdmVudE1hbmFnZXJQbHVnaW4pKTtcblxuICAgIC8qKlxuICAgICAqIEEgcGF0dGVybiB0aGF0IHJlY29nbml6ZXMgYSBjb21tb25seSB1c2VmdWwgc3Vic2V0IG9mIFVSTHMgdGhhdCBhcmUgc2FmZS5cbiAgICAgKlxuICAgICAqIFRoaXMgcmVndWxhciBleHByZXNzaW9uIG1hdGNoZXMgYSBzdWJzZXQgb2YgVVJMcyB0aGF0IHdpbGwgbm90IGNhdXNlIHNjcmlwdFxuICAgICAqIGV4ZWN1dGlvbiBpZiB1c2VkIGluIFVSTCBjb250ZXh0IHdpdGhpbiBhIEhUTUwgZG9jdW1lbnQuIFNwZWNpZmljYWxseSwgdGhpc1xuICAgICAqIHJlZ3VsYXIgZXhwcmVzc2lvbiBtYXRjaGVzIGlmIChjb21tZW50IGZyb20gaGVyZSBvbiBhbmQgcmVnZXggY29waWVkIGZyb21cbiAgICAgKiBTb3kncyBFc2NhcGluZ0NvbnZlbnRpb25zKTpcbiAgICAgKiAoMSkgRWl0aGVyIGEgcHJvdG9jb2wgaW4gYSB3aGl0ZWxpc3QgKGh0dHAsIGh0dHBzLCBtYWlsdG8gb3IgZnRwKS5cbiAgICAgKiAoMikgb3Igbm8gcHJvdG9jb2wuICBBIHByb3RvY29sIG11c3QgYmUgZm9sbG93ZWQgYnkgYSBjb2xvbi4gVGhlIGJlbG93XG4gICAgICogICAgIGFsbG93cyB0aGF0IGJ5IGFsbG93aW5nIGNvbG9ucyBvbmx5IGFmdGVyIG9uZSBvZiB0aGUgY2hhcmFjdGVycyBbLz8jXS5cbiAgICAgKiAgICAgQSBjb2xvbiBhZnRlciBhIGhhc2ggKCMpIG11c3QgYmUgaW4gdGhlIGZyYWdtZW50LlxuICAgICAqICAgICBPdGhlcndpc2UsIGEgY29sb24gYWZ0ZXIgYSAoPykgbXVzdCBiZSBpbiBhIHF1ZXJ5LlxuICAgICAqICAgICBPdGhlcndpc2UsIGEgY29sb24gYWZ0ZXIgYSBzaW5nbGUgc29saWR1cyAoLykgbXVzdCBiZSBpbiBhIHBhdGguXG4gICAgICogICAgIE90aGVyd2lzZSwgYSBjb2xvbiBhZnRlciBhIGRvdWJsZSBzb2xpZHVzICgvLykgbXVzdCBiZSBpbiB0aGUgYXV0aG9yaXR5XG4gICAgICogICAgIChiZWZvcmUgcG9ydCkuXG4gICAgICpcbiAgICAgKiBUaGUgcGF0dGVybiBkaXNhbGxvd3MgJiwgdXNlZCBpbiBIVE1MIGVudGl0eSBkZWNsYXJhdGlvbnMgYmVmb3JlXG4gICAgICogb25lIG9mIHRoZSBjaGFyYWN0ZXJzIGluIFsvPyNdLiBUaGlzIGRpc2FsbG93cyBIVE1MIGVudGl0aWVzIHVzZWQgaW4gdGhlXG4gICAgICogcHJvdG9jb2wgbmFtZSwgd2hpY2ggc2hvdWxkIG5ldmVyIGhhcHBlbiwgZS5nLiBcImgmIzExNjt0cFwiIGZvciBcImh0dHBcIi5cbiAgICAgKiBJdCBhbHNvIGRpc2FsbG93cyBIVE1MIGVudGl0aWVzIGluIHRoZSBmaXJzdCBwYXRoIHBhcnQgb2YgYSByZWxhdGl2ZSBwYXRoLFxuICAgICAqIGUuZy4gXCJmb28mbHQ7YmFyL2JhelwiLiAgT3VyIGV4aXN0aW5nIGVzY2FwaW5nIGZ1bmN0aW9ucyBzaG91bGQgbm90IHByb2R1Y2VcbiAgICAgKiB0aGF0LiBNb3JlIGltcG9ydGFudGx5LCBpdCBkaXNhbGxvd3MgbWFza2luZyBvZiBhIGNvbG9uLFxuICAgICAqIGUuZy4gXCJqYXZhc2NyaXB0JiM1ODsuLi5cIi5cbiAgICAgKlxuICAgICAqIFRoaXMgcmVndWxhciBleHByZXNzaW9uIHdhcyB0YWtlbiBmcm9tIHRoZSBDbG9zdXJlIHNhbml0aXphdGlvbiBsaWJyYXJ5LlxuICAgICAqL1xuICAgIHZhciBTQUZFX1VSTF9QQVRURVJOID0gL14oPzooPzpodHRwcz98bWFpbHRvfGZ0cHx0ZWx8ZmlsZSk6fFteJjovPyNdKig/OlsvPyNdfCQpKS9naTtcbiAgICAvKiogQSBwYXR0ZXJuIHRoYXQgbWF0Y2hlcyBzYWZlIGRhdGEgVVJMcy4gT25seSBtYXRjaGVzIGltYWdlLCB2aWRlbyBhbmQgYXVkaW8gdHlwZXMuICovXG4gICAgdmFyIERBVEFfVVJMX1BBVFRFUk4gPSAvXmRhdGE6KD86aW1hZ2VcXC8oPzpibXB8Z2lmfGpwZWd8anBnfHBuZ3x0aWZmfHdlYnApfHZpZGVvXFwvKD86bXBlZ3xtcDR8b2dnfHdlYm0pfGF1ZGlvXFwvKD86bXAzfG9nYXxvZ2d8b3B1cykpO2Jhc2U2NCxbYS16MC05K1xcL10rPSokL2k7XG4gICAgZnVuY3Rpb24gc2FuaXRpemVVcmwodXJsKSB7XG4gICAgICAgIHVybCA9IFN0cmluZyh1cmwpO1xuICAgICAgICBpZiAodXJsLm1hdGNoKFNBRkVfVVJMX1BBVFRFUk4pIHx8IHVybC5tYXRjaChEQVRBX1VSTF9QQVRURVJOKSlcbiAgICAgICAgICAgIHJldHVybiB1cmw7XG4gICAgICAgIGlmIChfYW5ndWxhcl9jb3JlLmlzRGV2TW9kZSgpKSB7XG4gICAgICAgICAgICBnZXRET00oKS5sb2coXCJXQVJOSU5HOiBzYW5pdGl6aW5nIHVuc2FmZSBVUkwgdmFsdWUgXCIgKyB1cmwgKyBcIiAoc2VlIGh0dHA6Ly9nLmNvL25nL3NlY3VyaXR5I3hzcylcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICd1bnNhZmU6JyArIHVybDtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2FuaXRpemVTcmNzZXQoc3Jjc2V0KSB7XG4gICAgICAgIHNyY3NldCA9IFN0cmluZyhzcmNzZXQpO1xuICAgICAgICByZXR1cm4gc3Jjc2V0LnNwbGl0KCcsJykubWFwKGZ1bmN0aW9uIChzcmNzZXQpIHsgcmV0dXJuIHNhbml0aXplVXJsKHNyY3NldC50cmltKCkpOyB9KS5qb2luKCcsICcpO1xuICAgIH1cblxuICAgIC8qKiBBIDxib2R5PiBlbGVtZW50IHRoYXQgY2FuIGJlIHNhZmVseSB1c2VkIHRvIHBhcnNlIHVudHJ1c3RlZCBIVE1MLiBMYXppbHkgaW5pdGlhbGl6ZWQgYmVsb3cuICovXG4gICAgdmFyIGluZXJ0RWxlbWVudCA9IG51bGw7XG4gICAgLyoqIExhemlseSBpbml0aWFsaXplZCB0byBtYWtlIHN1cmUgdGhlIERPTSBhZGFwdGVyIGdldHMgc2V0IGJlZm9yZSB1c2UuICovXG4gICAgdmFyIERPTSA9IG51bGw7XG4gICAgLyoqIFJldHVybnMgYW4gSFRNTCBlbGVtZW50IHRoYXQgaXMgZ3VhcmFudGVlZCB0byBub3QgZXhlY3V0ZSBjb2RlIHdoZW4gY3JlYXRpbmcgZWxlbWVudHMgaW4gaXQuICovXG4gICAgZnVuY3Rpb24gZ2V0SW5lcnRFbGVtZW50KCkge1xuICAgICAgICBpZiAoaW5lcnRFbGVtZW50KVxuICAgICAgICAgICAgcmV0dXJuIGluZXJ0RWxlbWVudDtcbiAgICAgICAgRE9NID0gZ2V0RE9NKCk7XG4gICAgICAgIC8vIFByZWZlciB1c2luZyA8dGVtcGxhdGU+IGVsZW1lbnQgaWYgc3VwcG9ydGVkLlxuICAgICAgICB2YXIgdGVtcGxhdGVFbCA9IERPTS5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgICAgICBpZiAoJ2NvbnRlbnQnIGluIHRlbXBsYXRlRWwpXG4gICAgICAgICAgICByZXR1cm4gdGVtcGxhdGVFbDtcbiAgICAgICAgdmFyIGRvYyA9IERPTS5jcmVhdGVIdG1sRG9jdW1lbnQoKTtcbiAgICAgICAgaW5lcnRFbGVtZW50ID0gRE9NLnF1ZXJ5U2VsZWN0b3IoZG9jLCAnYm9keScpO1xuICAgICAgICBpZiAoaW5lcnRFbGVtZW50ID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIHVzdWFsbHkgdGhlcmUgc2hvdWxkIGJlIG9ubHkgb25lIGJvZHkgZWxlbWVudCBpbiB0aGUgZG9jdW1lbnQsIGJ1dCBJRSBkb2Vzbid0IGhhdmUgYW55LCBzbyB3ZVxuICAgICAgICAgICAgLy8gbmVlZCB0byBjcmVhdGUgb25lLlxuICAgICAgICAgICAgdmFyIGh0bWwgPSBET00uY3JlYXRlRWxlbWVudCgnaHRtbCcsIGRvYyk7XG4gICAgICAgICAgICBpbmVydEVsZW1lbnQgPSBET00uY3JlYXRlRWxlbWVudCgnYm9keScsIGRvYyk7XG4gICAgICAgICAgICBET00uYXBwZW5kQ2hpbGQoaHRtbCwgaW5lcnRFbGVtZW50KTtcbiAgICAgICAgICAgIERPTS5hcHBlbmRDaGlsZChkb2MsIGh0bWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmVydEVsZW1lbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRhZ1NldCh0YWdzKSB7XG4gICAgICAgIHZhciByZXMgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRhZ3Muc3BsaXQoJywnKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciB0ID0gX2FbX2ldO1xuICAgICAgICAgICAgcmVzW3RdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtZXJnZSgpIHtcbiAgICAgICAgdmFyIHNldHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHNldHNbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlcyA9IHt9O1xuICAgICAgICBmb3IgKHZhciBfYSA9IDAsIHNldHNfMSA9IHNldHM7IF9hIDwgc2V0c18xLmxlbmd0aDsgX2ErKykge1xuICAgICAgICAgICAgdmFyIHMgPSBzZXRzXzFbX2FdO1xuICAgICAgICAgICAgZm9yICh2YXIgdiBpbiBzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHMuaGFzT3duUHJvcGVydHkodikpXG4gICAgICAgICAgICAgICAgICAgIHJlc1t2XSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgLy8gR29vZCBzb3VyY2Ugb2YgaW5mbyBhYm91dCBlbGVtZW50cyBhbmQgYXR0cmlidXRlc1xuICAgIC8vIGh0dHA6Ly9kZXYudzMub3JnL2h0bWw1L3NwZWMvT3ZlcnZpZXcuaHRtbCNzZW1hbnRpY3NcbiAgICAvLyBodHRwOi8vc2ltb24uaHRtbDUub3JnL2h0bWwtZWxlbWVudHNcbiAgICAvLyBTYWZlIFZvaWQgRWxlbWVudHMgLSBIVE1MNVxuICAgIC8vIGh0dHA6Ly9kZXYudzMub3JnL2h0bWw1L3NwZWMvT3ZlcnZpZXcuaHRtbCN2b2lkLWVsZW1lbnRzXG4gICAgdmFyIFZPSURfRUxFTUVOVFMgPSB0YWdTZXQoJ2FyZWEsYnIsY29sLGhyLGltZyx3YnInKTtcbiAgICAvLyBFbGVtZW50cyB0aGF0IHlvdSBjYW4sIGludGVudGlvbmFsbHksIGxlYXZlIG9wZW4gKGFuZCB3aGljaCBjbG9zZSB0aGVtc2VsdmVzKVxuICAgIC8vIGh0dHA6Ly9kZXYudzMub3JnL2h0bWw1L3NwZWMvT3ZlcnZpZXcuaHRtbCNvcHRpb25hbC10YWdzXG4gICAgdmFyIE9QVElPTkFMX0VORF9UQUdfQkxPQ0tfRUxFTUVOVFMgPSB0YWdTZXQoJ2NvbGdyb3VwLGRkLGR0LGxpLHAsdGJvZHksdGQsdGZvb3QsdGgsdGhlYWQsdHInKTtcbiAgICB2YXIgT1BUSU9OQUxfRU5EX1RBR19JTkxJTkVfRUxFTUVOVFMgPSB0YWdTZXQoJ3JwLHJ0Jyk7XG4gICAgdmFyIE9QVElPTkFMX0VORF9UQUdfRUxFTUVOVFMgPSBtZXJnZShPUFRJT05BTF9FTkRfVEFHX0lOTElORV9FTEVNRU5UUywgT1BUSU9OQUxfRU5EX1RBR19CTE9DS19FTEVNRU5UUyk7XG4gICAgLy8gU2FmZSBCbG9jayBFbGVtZW50cyAtIEhUTUw1XG4gICAgdmFyIEJMT0NLX0VMRU1FTlRTID0gbWVyZ2UoT1BUSU9OQUxfRU5EX1RBR19CTE9DS19FTEVNRU5UUywgdGFnU2V0KCdhZGRyZXNzLGFydGljbGUsJyArXG4gICAgICAgICdhc2lkZSxibG9ja3F1b3RlLGNhcHRpb24sY2VudGVyLGRlbCxkZXRhaWxzLGRpYWxvZyxkaXIsZGl2LGRsLGZpZ3VyZSxmaWdjYXB0aW9uLGZvb3RlcixoMSxoMixoMyxoNCxoNSwnICtcbiAgICAgICAgJ2g2LGhlYWRlcixoZ3JvdXAsaHIsaW5zLG1haW4sbWFwLG1lbnUsbmF2LG9sLHByZSxzZWN0aW9uLHN1bW1hcnksdGFibGUsdWwnKSk7XG4gICAgLy8gSW5saW5lIEVsZW1lbnRzIC0gSFRNTDVcbiAgICB2YXIgSU5MSU5FX0VMRU1FTlRTID0gbWVyZ2UoT1BUSU9OQUxfRU5EX1RBR19JTkxJTkVfRUxFTUVOVFMsIHRhZ1NldCgnYSxhYmJyLGFjcm9ueW0sYXVkaW8sYiwnICtcbiAgICAgICAgJ2JkaSxiZG8sYmlnLGJyLGNpdGUsY29kZSxkZWwsZGZuLGVtLGZvbnQsaSxpbWcsaW5zLGtiZCxsYWJlbCxtYXAsbWFyayxwaWN0dXJlLHEscnVieSxycCxydCxzLCcgK1xuICAgICAgICAnc2FtcCxzbWFsbCxzb3VyY2Usc3BhbixzdHJpa2Usc3Ryb25nLHN1YixzdXAsdGltZSx0cmFjayx0dCx1LHZhcix2aWRlbycpKTtcbiAgICB2YXIgVkFMSURfRUxFTUVOVFMgPSBtZXJnZShWT0lEX0VMRU1FTlRTLCBCTE9DS19FTEVNRU5UUywgSU5MSU5FX0VMRU1FTlRTLCBPUFRJT05BTF9FTkRfVEFHX0VMRU1FTlRTKTtcbiAgICAvLyBBdHRyaWJ1dGVzIHRoYXQgaGF2ZSBocmVmIGFuZCBoZW5jZSBuZWVkIHRvIGJlIHNhbml0aXplZFxuICAgIHZhciBVUklfQVRUUlMgPSB0YWdTZXQoJ2JhY2tncm91bmQsY2l0ZSxocmVmLGl0ZW10eXBlLGxvbmdkZXNjLHBvc3RlcixzcmMseGxpbms6aHJlZicpO1xuICAgIC8vIEF0dHJpYnV0ZXMgdGhhdCBoYXZlIHNwZWNpYWwgaHJlZiBzZXQgaGVuY2UgbmVlZCB0byBiZSBzYW5pdGl6ZWRcbiAgICB2YXIgU1JDU0VUX0FUVFJTID0gdGFnU2V0KCdzcmNzZXQnKTtcbiAgICB2YXIgSFRNTF9BVFRSUyA9IHRhZ1NldCgnYWJicixhY2Nlc3NrZXksYWxpZ24sYWx0LGF1dG9wbGF5LGF4aXMsYmdjb2xvcixib3JkZXIsY2VsbHBhZGRpbmcsY2VsbHNwYWNpbmcsY2xhc3MsY2xlYXIsY29sb3IsY29scyxjb2xzcGFuLCcgK1xuICAgICAgICAnY29tcGFjdCxjb250cm9scyxjb29yZHMsZGF0ZXRpbWUsZGVmYXVsdCxkaXIsZG93bmxvYWQsZmFjZSxoZWFkZXJzLGhlaWdodCxoaWRkZW4saHJlZmxhbmcsaHNwYWNlLCcgK1xuICAgICAgICAnaXNtYXAsaXRlbXNjb3BlLGl0ZW1wcm9wLGtpbmQsbGFiZWwsbGFuZyxsYW5ndWFnZSxsb29wLG1lZGlhLG11dGVkLG5vaHJlZixub3dyYXAsb3BlbixwcmVsb2FkLHJlbCxyZXYscm9sZSxyb3dzLHJvd3NwYW4scnVsZXMsJyArXG4gICAgICAgICdzY29wZSxzY3JvbGxpbmcsc2hhcGUsc2l6ZSxzaXplcyxzcGFuLHNyY2xhbmcsc3RhcnQsc3VtbWFyeSx0YWJpbmRleCx0YXJnZXQsdGl0bGUsdHJhbnNsYXRlLHR5cGUsdXNlbWFwLCcgK1xuICAgICAgICAndmFsaWduLHZhbHVlLHZzcGFjZSx3aWR0aCcpO1xuICAgIC8vIE5COiBUaGlzIGN1cnJlbnRseSBjb25jaW91c2x5IGRvZXNuJ3Qgc3VwcG9ydCBTVkcuIFNWRyBzYW5pdGl6YXRpb24gaGFzIGhhZCBzZXZlcmFsIHNlY3VyaXR5XG4gICAgLy8gaXNzdWVzIGluIHRoZSBwYXN0LCBzbyBpdCBzZWVtcyBzYWZlciB0byBsZWF2ZSBpdCBvdXQgaWYgcG9zc2libGUuIElmIHN1cHBvcnQgZm9yIGJpbmRpbmcgU1ZHIHZpYVxuICAgIC8vIGlubmVySFRNTCBpcyByZXF1aXJlZCwgU1ZHIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIGFkZGVkIGhlcmUuXG4gICAgLy8gTkI6IFNhbml0aXphdGlvbiBkb2VzIG5vdCBhbGxvdyA8Zm9ybT4gZWxlbWVudHMgb3Igb3RoZXIgYWN0aXZlIGVsZW1lbnRzICg8YnV0dG9uPiBldGMpLiBUaG9zZVxuICAgIC8vIGNhbiBiZSBzYW5pdGl6ZWQsIGJ1dCB0aGV5IGluY3JlYXNlIHNlY3VyaXR5IHN1cmZhY2UgYXJlYSB3aXRob3V0IGEgbGVnaXRpbWF0ZSB1c2UgY2FzZSwgc28gdGhleVxuICAgIC8vIGFyZSBsZWZ0IG91dCBoZXJlLlxuICAgIHZhciBWQUxJRF9BVFRSUyA9IG1lcmdlKFVSSV9BVFRSUywgU1JDU0VUX0FUVFJTLCBIVE1MX0FUVFJTKTtcbiAgICAvKipcbiAgICAgKiBTYW5pdGl6aW5nSHRtbFNlcmlhbGl6ZXIgc2VyaWFsaXplcyBhIERPTSBmcmFnbWVudCwgc3RyaXBwaW5nIG91dCBhbnkgdW5zYWZlIGVsZW1lbnRzIGFuZCB1bnNhZmVcbiAgICAgKiBhdHRyaWJ1dGVzLlxuICAgICAqL1xuICAgIHZhciBTYW5pdGl6aW5nSHRtbFNlcmlhbGl6ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBTYW5pdGl6aW5nSHRtbFNlcmlhbGl6ZXIoKSB7XG4gICAgICAgICAgICAvLyBFeHBsaWNpdGx5IHRyYWNrIGlmIHNvbWV0aGluZyB3YXMgc3RyaXBwZWQsIHRvIGF2b2lkIGFjY2lkZW50YWxseSB3YXJuaW5nIG9mIHNhbml0aXphdGlvbiBqdXN0XG4gICAgICAgICAgICAvLyBiZWNhdXNlIGNoYXJhY3RlcnMgd2VyZSByZS1lbmNvZGVkLlxuICAgICAgICAgICAgdGhpcy5zYW5pdGl6ZWRTb21ldGhpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuYnVmID0gW107XG4gICAgICAgIH1cbiAgICAgICAgU2FuaXRpemluZ0h0bWxTZXJpYWxpemVyLnByb3RvdHlwZS5zYW5pdGl6ZUNoaWxkcmVuID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGNhbm5vdCB1c2UgYSBUcmVlV2Fsa2VyLCBhcyBpdCBoYXMgdG8gcnVuIG9uIEFuZ3VsYXIncyB2YXJpb3VzIERPTSBhZGFwdGVycy5cbiAgICAgICAgICAgIC8vIEhvd2V2ZXIgdGhpcyBjb2RlIG5ldmVyIGFjY2Vzc2VzIHByb3BlcnRpZXMgb2ZmIG9mIGBkb2N1bWVudGAgYmVmb3JlIGRlbGV0aW5nIGl0cyBjb250ZW50c1xuICAgICAgICAgICAgLy8gYWdhaW4sIHNvIGl0IHNob3VsZG4ndCBiZSB2dWxuZXJhYmxlIHRvIERPTSBjbG9iYmVyaW5nLlxuICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSBlbC5maXJzdENoaWxkO1xuICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoRE9NLmlzRWxlbWVudE5vZGUoY3VycmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydEVsZW1lbnQoY3VycmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKERPTS5pc1RleHROb2RlKGN1cnJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhcnMoRE9NLm5vZGVWYWx1ZShjdXJyZW50KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBTdHJpcCBub24tZWxlbWVudCwgbm9uLXRleHQgbm9kZXMuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2FuaXRpemVkU29tZXRoaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKERPTS5maXJzdENoaWxkKGN1cnJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBET00uZmlyc3RDaGlsZChjdXJyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIExlYXZpbmcgdGhlIGVsZW1lbnQuIFdhbGsgdXAgYW5kIHRvIHRoZSByaWdodCwgY2xvc2luZyB0YWdzIGFzIHdlIGdvLlxuICAgICAgICAgICAgICAgICAgICBpZiAoRE9NLmlzRWxlbWVudE5vZGUoY3VycmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kRWxlbWVudChjdXJyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoRE9NLm5leHRTaWJsaW5nKGN1cnJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gRE9NLm5leHRTaWJsaW5nKGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IERPTS5wYXJlbnRFbGVtZW50KGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1Zi5qb2luKCcnKTtcbiAgICAgICAgfTtcbiAgICAgICAgU2FuaXRpemluZ0h0bWxTZXJpYWxpemVyLnByb3RvdHlwZS5zdGFydEVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciB0YWdOYW1lID0gRE9NLm5vZGVOYW1lKGVsZW1lbnQpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAoIVZBTElEX0VMRU1FTlRTLmhhc093blByb3BlcnR5KHRhZ05hbWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zYW5pdGl6ZWRTb21ldGhpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYnVmLnB1c2goJzwnKTtcbiAgICAgICAgICAgIHRoaXMuYnVmLnB1c2godGFnTmFtZSk7XG4gICAgICAgICAgICBET00uYXR0cmlidXRlTWFwKGVsZW1lbnQpLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBhdHRyTmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBsb3dlciA9IGF0dHJOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFWQUxJRF9BVFRSUy5oYXNPd25Qcm9wZXJ0eShsb3dlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2FuaXRpemVkU29tZXRoaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUT0RPKG1hcnRpbnByb2JzdCk6IFNwZWNpYWwgY2FzZSBpbWFnZSBVUklzIGZvciBkYXRhOmltYWdlLy4uLlxuICAgICAgICAgICAgICAgIGlmIChVUklfQVRUUlNbbG93ZXJdKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHNhbml0aXplVXJsKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoU1JDU0VUX0FUVFJTW2xvd2VyXSlcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBzYW5pdGl6ZVNyY3NldCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuYnVmLnB1c2goJyAnKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5idWYucHVzaChhdHRyTmFtZSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuYnVmLnB1c2goJz1cIicpO1xuICAgICAgICAgICAgICAgIF90aGlzLmJ1Zi5wdXNoKGVuY29kZUVudGl0aWVzKHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuYnVmLnB1c2goJ1wiJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuYnVmLnB1c2goJz4nKTtcbiAgICAgICAgfTtcbiAgICAgICAgU2FuaXRpemluZ0h0bWxTZXJpYWxpemVyLnByb3RvdHlwZS5lbmRFbGVtZW50ID0gZnVuY3Rpb24gKGN1cnJlbnQpIHtcbiAgICAgICAgICAgIHZhciB0YWdOYW1lID0gRE9NLm5vZGVOYW1lKGN1cnJlbnQpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAoVkFMSURfRUxFTUVOVFMuaGFzT3duUHJvcGVydHkodGFnTmFtZSkgJiYgIVZPSURfRUxFTUVOVFMuaGFzT3duUHJvcGVydHkodGFnTmFtZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1Zi5wdXNoKCc8LycpO1xuICAgICAgICAgICAgICAgIHRoaXMuYnVmLnB1c2godGFnTmFtZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5idWYucHVzaCgnPicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBTYW5pdGl6aW5nSHRtbFNlcmlhbGl6ZXIucHJvdG90eXBlLmNoYXJzID0gZnVuY3Rpb24gKGNoYXJzIC8qKiBUT0RPICM5MTAwICovKSB7IHRoaXMuYnVmLnB1c2goZW5jb2RlRW50aXRpZXMoY2hhcnMpKTsgfTtcbiAgICAgICAgcmV0dXJuIFNhbml0aXppbmdIdG1sU2VyaWFsaXplcjtcbiAgICB9KCkpO1xuICAgIC8vIFJlZ3VsYXIgRXhwcmVzc2lvbnMgZm9yIHBhcnNpbmcgdGFncyBhbmQgYXR0cmlidXRlc1xuICAgIHZhciBTVVJST0dBVEVfUEFJUl9SRUdFWFAgPSAvW1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXS9nO1xuICAgIC8vICEgdG8gfiBpcyB0aGUgQVNDSUkgcmFuZ2UuXG4gICAgdmFyIE5PTl9BTFBIQU5VTUVSSUNfUkVHRVhQID0gLyhbXlxcIy1+IHwhXSkvZztcbiAgICAvKipcbiAgICAgKiBFc2NhcGVzIGFsbCBwb3RlbnRpYWxseSBkYW5nZXJvdXMgY2hhcmFjdGVycywgc28gdGhhdCB0aGVcbiAgICAgKiByZXN1bHRpbmcgc3RyaW5nIGNhbiBiZSBzYWZlbHkgaW5zZXJ0ZWQgaW50byBhdHRyaWJ1dGUgb3JcbiAgICAgKiBlbGVtZW50IHRleHQuXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICogQHJldHVybnMge3N0cmluZ30gZXNjYXBlZCB0ZXh0XG4gICAgICovXG4gICAgZnVuY3Rpb24gZW5jb2RlRW50aXRpZXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoLyYvZywgJyZhbXA7JylcbiAgICAgICAgICAgIC5yZXBsYWNlKFNVUlJPR0FURV9QQUlSX1JFR0VYUCwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgICB2YXIgaGkgPSBtYXRjaC5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgdmFyIGxvdyA9IG1hdGNoLmNoYXJDb2RlQXQoMSk7XG4gICAgICAgICAgICByZXR1cm4gJyYjJyArICgoKGhpIC0gMHhEODAwKSAqIDB4NDAwKSArIChsb3cgLSAweERDMDApICsgMHgxMDAwMCkgKyAnOyc7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAucmVwbGFjZShOT05fQUxQSEFOVU1FUklDX1JFR0VYUCwgZnVuY3Rpb24gKG1hdGNoKSB7IHJldHVybiAnJiMnICsgbWF0Y2guY2hhckNvZGVBdCgwKSArICc7JzsgfSlcbiAgICAgICAgICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAgICAgICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7Jyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZW4gSUU5LTExIGNvbWVzIGFjcm9zcyBhbiB1bmtub3duIG5hbWVzcGFjZWQgYXR0cmlidXRlIGUuZy4gJ3hsaW5rOmZvbycgaXQgYWRkcyAneG1sbnM6bnMxJ1xuICAgICAqIGF0dHJpYnV0ZSB0byBkZWNsYXJlIG5zMSBuYW1lc3BhY2UgYW5kIHByZWZpeGVzIHRoZSBhdHRyaWJ1dGUgd2l0aCAnbnMxJyAoZS5nLiAnbnMxOnhsaW5rOmZvbycpLlxuICAgICAqXG4gICAgICogVGhpcyBpcyB1bmRlc2lyYWJsZSBzaW5jZSB3ZSBkb24ndCB3YW50IHRvIGFsbG93IGFueSBvZiB0aGVzZSBjdXN0b20gYXR0cmlidXRlcy4gVGhpcyBtZXRob2RcbiAgICAgKiBzdHJpcHMgdGhlbSBhbGwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RyaXBDdXN0b21Oc0F0dHJzKGVsKSB7XG4gICAgICAgIERPTS5hdHRyaWJ1dGVNYXAoZWwpLmZvckVhY2goZnVuY3Rpb24gKF8sIGF0dHJOYW1lKSB7XG4gICAgICAgICAgICBpZiAoYXR0ck5hbWUgPT09ICd4bWxuczpuczEnIHx8IGF0dHJOYW1lLmluZGV4T2YoJ25zMTonKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIERPTS5yZW1vdmVBdHRyaWJ1dGUoZWwsIGF0dHJOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBET00uY2hpbGROb2Rlc0FzTGlzdChlbCk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgbiA9IF9hW19pXTtcbiAgICAgICAgICAgIGlmIChET00uaXNFbGVtZW50Tm9kZShuKSlcbiAgICAgICAgICAgICAgICBzdHJpcEN1c3RvbU5zQXR0cnMobik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2FuaXRpemVzIHRoZSBnaXZlbiB1bnNhZmUsIHVudHJ1c3RlZCBIVE1MIGZyYWdtZW50LCBhbmQgcmV0dXJucyBIVE1MIHRleHQgdGhhdCBpcyBzYWZlIHRvIGFkZCB0b1xuICAgICAqIHRoZSBET00gaW4gYSBicm93c2VyIGVudmlyb25tZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNhbml0aXplSHRtbCh1bnNhZmVIdG1sSW5wdXQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBjb250YWluZXJFbCA9IGdldEluZXJ0RWxlbWVudCgpO1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHVuc2FmZUh0bWwgaXMgYWN0dWFsbHkgYSBzdHJpbmcgKFR5cGVTY3JpcHQgdHlwZXMgYXJlIG5vdCBlbmZvcmNlZCBhdCBydW50aW1lKS5cbiAgICAgICAgICAgIHZhciB1bnNhZmVIdG1sID0gdW5zYWZlSHRtbElucHV0ID8gU3RyaW5nKHVuc2FmZUh0bWxJbnB1dCkgOiAnJztcbiAgICAgICAgICAgIC8vIG1YU1MgcHJvdGVjdGlvbi4gUmVwZWF0ZWRseSBwYXJzZSB0aGUgZG9jdW1lbnQgdG8gbWFrZSBzdXJlIGl0IHN0YWJpbGl6ZXMsIHNvIHRoYXQgYSBicm93c2VyXG4gICAgICAgICAgICAvLyB0cnlpbmcgdG8gYXV0by1jb3JyZWN0IGluY29ycmVjdCBIVE1MIGNhbm5vdCBjYXVzZSBmb3JtZXJseSBpbmVydCBIVE1MIHRvIGJlY29tZSBkYW5nZXJvdXMuXG4gICAgICAgICAgICB2YXIgbVhTU0F0dGVtcHRzID0gNTtcbiAgICAgICAgICAgIHZhciBwYXJzZWRIdG1sID0gdW5zYWZlSHRtbDtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBpZiAobVhTU0F0dGVtcHRzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHNhbml0aXplIGh0bWwgYmVjYXVzZSB0aGUgaW5wdXQgaXMgdW5zdGFibGUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbVhTU0F0dGVtcHRzLS07XG4gICAgICAgICAgICAgICAgdW5zYWZlSHRtbCA9IHBhcnNlZEh0bWw7XG4gICAgICAgICAgICAgICAgRE9NLnNldElubmVySFRNTChjb250YWluZXJFbCwgdW5zYWZlSHRtbCk7XG4gICAgICAgICAgICAgICAgaWYgKERPTS5kZWZhdWx0RG9jKCkuZG9jdW1lbnRNb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN0cmlwIGN1c3RvbS1uYW1lc3BhY2VkIGF0dHJpYnV0ZXMgb24gSUU8PTExXG4gICAgICAgICAgICAgICAgICAgIHN0cmlwQ3VzdG9tTnNBdHRycyhjb250YWluZXJFbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcnNlZEh0bWwgPSBET00uZ2V0SW5uZXJIVE1MKGNvbnRhaW5lckVsKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKHVuc2FmZUh0bWwgIT09IHBhcnNlZEh0bWwpO1xuICAgICAgICAgICAgdmFyIHNhbml0aXplciA9IG5ldyBTYW5pdGl6aW5nSHRtbFNlcmlhbGl6ZXIoKTtcbiAgICAgICAgICAgIHZhciBzYWZlSHRtbCA9IHNhbml0aXplci5zYW5pdGl6ZUNoaWxkcmVuKERPTS5nZXRUZW1wbGF0ZUNvbnRlbnQoY29udGFpbmVyRWwpIHx8IGNvbnRhaW5lckVsKTtcbiAgICAgICAgICAgIC8vIENsZWFyIG91dCB0aGUgYm9keSBlbGVtZW50LlxuICAgICAgICAgICAgdmFyIHBhcmVudF8xID0gRE9NLmdldFRlbXBsYXRlQ29udGVudChjb250YWluZXJFbCkgfHwgY29udGFpbmVyRWw7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gRE9NLmNoaWxkTm9kZXNBc0xpc3QocGFyZW50XzEpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICBET00ucmVtb3ZlQ2hpbGQocGFyZW50XzEsIGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfYW5ndWxhcl9jb3JlLmlzRGV2TW9kZSgpICYmIHNhbml0aXplci5zYW5pdGl6ZWRTb21ldGhpbmcpIHtcbiAgICAgICAgICAgICAgICBET00ubG9nKCdXQVJOSU5HOiBzYW5pdGl6aW5nIEhUTUwgc3RyaXBwZWQgc29tZSBjb250ZW50IChzZWUgaHR0cDovL2cuY28vbmcvc2VjdXJpdHkjeHNzKS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzYWZlSHRtbDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gSW4gY2FzZSBhbnl0aGluZyBnb2VzIHdyb25nLCBjbGVhciBvdXQgaW5lcnRFbGVtZW50IHRvIHJlc2V0IHRoZSBlbnRpcmUgRE9NIHN0cnVjdHVyZS5cbiAgICAgICAgICAgIGluZXJ0RWxlbWVudCA9IG51bGw7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVndWxhciBleHByZXNzaW9uIGZvciBzYWZlIHN0eWxlIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIFF1b3RlcyAoXCIgYW5kICcpIGFyZSBhbGxvd2VkLCBidXQgYSBjaGVjayBtdXN0IGJlIGRvbmUgZWxzZXdoZXJlIHRvIGVuc3VyZSB0aGV5J3JlIGJhbGFuY2VkLlxuICAgICAqXG4gICAgICogJywnIGFsbG93cyBtdWx0aXBsZSB2YWx1ZXMgdG8gYmUgYXNzaWduZWQgdG8gdGhlIHNhbWUgcHJvcGVydHkgKGUuZy4gYmFja2dyb3VuZC1hdHRhY2htZW50IG9yXG4gICAgICogZm9udC1mYW1pbHkpIGFuZCBoZW5jZSBjb3VsZCBhbGxvdyBtdWx0aXBsZSB2YWx1ZXMgdG8gZ2V0IGluamVjdGVkLCBidXQgdGhhdCBzaG91bGQgcG9zZSBubyByaXNrXG4gICAgICogb2YgWFNTLlxuICAgICAqXG4gICAgICogVGhlIGZ1bmN0aW9uIGV4cHJlc3Npb24gY2hlY2tzIG9ubHkgZm9yIFhTUyBzYWZldHksIG5vdCBmb3IgQ1NTIHZhbGlkaXR5LlxuICAgICAqXG4gICAgICogVGhpcyByZWd1bGFyIGV4cHJlc3Npb24gd2FzIHRha2VuIGZyb20gdGhlIENsb3N1cmUgc2FuaXRpemF0aW9uIGxpYnJhcnksIGFuZCBhdWdtZW50ZWQgZm9yXG4gICAgICogdHJhbnNmb3JtYXRpb24gdmFsdWVzLlxuICAgICAqL1xuICAgIHZhciBWQUxVRVMgPSAnWy0sLlwiXFwnJV8hIyBhLXpBLVowLTldKyc7XG4gICAgdmFyIFRSQU5TRk9STUFUSU9OX0ZOUyA9ICcoPzptYXRyaXh8dHJhbnNsYXRlfHNjYWxlfHJvdGF0ZXxza2V3fHBlcnNwZWN0aXZlKSg/Olh8WXwzZCk/JztcbiAgICB2YXIgQ09MT1JfRk5TID0gJyg/OnJnYnxoc2wpYT8nO1xuICAgIHZhciBGTl9BUkdTID0gJ1xcXFwoWy0wLTkuJSwgYS16QS1aXStcXFxcKSc7XG4gICAgdmFyIFNBRkVfU1RZTEVfVkFMVUUgPSBuZXcgUmVnRXhwKFwiXihcIiArIFZBTFVFUyArIFwifCg/OlwiICsgVFJBTlNGT1JNQVRJT05fRk5TICsgXCJ8XCIgKyBDT0xPUl9GTlMgKyBcIilcIiArIEZOX0FSR1MgKyBcIikkXCIsICdnJyk7XG4gICAgLyoqXG4gICAgICogTWF0Y2hlcyBhIGB1cmwoLi4uKWAgdmFsdWUgd2l0aCBhbiBhcmJpdHJhcnkgYXJndW1lbnQgYXMgbG9uZyBhcyBpdCBkb2VzXG4gICAgICogbm90IGNvbnRhaW4gcGFyZW50aGVzZXMuXG4gICAgICpcbiAgICAgKiBUaGUgVVJMIHZhbHVlIHN0aWxsIG5lZWRzIHRvIGJlIHNhbml0aXplZCBzZXBhcmF0ZWx5LlxuICAgICAqXG4gICAgICogYHVybCguLi4pYCB2YWx1ZXMgYXJlIGEgdmVyeSBjb21tb24gdXNlIGNhc2UsIGUuZy4gZm9yIGBiYWNrZ3JvdW5kLWltYWdlYC4gV2l0aCBjYXJlZnVsbHkgY3JhZnRlZFxuICAgICAqIENTUyBzdHlsZSBydWxlcywgaXQgaXMgcG9zc2libGUgdG8gY29uc3RydWN0IGFuIGluZm9ybWF0aW9uIGxlYWsgd2l0aCBgdXJsYCB2YWx1ZXMgaW4gQ1NTLCBlLmcuXG4gICAgICogYnkgb2JzZXJ2aW5nIHdoZXRoZXIgc2Nyb2xsIGJhcnMgYXJlIGRpc3BsYXllZCwgb3IgY2hhcmFjdGVyIHJhbmdlcyB1c2VkIGJ5IGEgZm9udCBmYWNlXG4gICAgICogZGVmaW5pdGlvbi5cbiAgICAgKlxuICAgICAqIEFuZ3VsYXIgb25seSBhbGxvd3MgYmluZGluZyBDU1MgdmFsdWVzIChhcyBvcHBvc2VkIHRvIGVudGlyZSBDU1MgcnVsZXMpLCBzbyBpdCBpcyB1bmxpa2VseSB0aGF0XG4gICAgICogYmluZGluZyBhIFVSTCB2YWx1ZSB3aXRob3V0IGZ1cnRoZXIgY29vcGVyYXRpb24gZnJvbSB0aGUgcGFnZSB3aWxsIGNhdXNlIGFuIGluZm9ybWF0aW9uIGxlYWssIGFuZFxuICAgICAqIGlmIHNvLCBpdCBpcyBqdXN0IGEgbGVhaywgbm90IGEgZnVsbCBibG93biBYU1MgdnVsbmVyYWJpbGl0eS5cbiAgICAgKlxuICAgICAqIEdpdmVuIHRoZSBjb21tb24gdXNlIGNhc2UsIGxvdyBsaWtlbGlob29kIG9mIGF0dGFjayB2ZWN0b3IsIGFuZCBsb3cgaW1wYWN0IG9mIGFuIGF0dGFjaywgdGhpc1xuICAgICAqIGNvZGUgaXMgcGVybWlzc2l2ZSBhbmQgYWxsb3dzIFVSTHMgdGhhdCBzYW5pdGl6ZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgdmFyIFVSTF9SRSA9IC9edXJsXFwoKFteKV0rKVxcKSQvO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB0aGF0IHF1b3RlcyAoXCIgYW5kICcpIGFyZSBwcm9wZXJseSBiYWxhbmNlZCBpbnNpZGUgYSBzdHJpbmcuIEFzc3VtZXNcbiAgICAgKiB0aGF0IG5laXRoZXIgZXNjYXBlIChcXCkgbm9yIGFueSBvdGhlciBjaGFyYWN0ZXIgdGhhdCBjb3VsZCByZXN1bHQgaW5cbiAgICAgKiBicmVha2luZyBvdXQgb2YgYSBzdHJpbmcgcGFyc2luZyBjb250ZXh0IGFyZSBhbGxvd2VkO1xuICAgICAqIHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXN5bnRheC8jc3RyaW5nLXRva2VuLWRpYWdyYW0uXG4gICAgICpcbiAgICAgKiBUaGlzIGNvZGUgd2FzIHRha2VuIGZyb20gdGhlIENsb3N1cmUgc2FuaXRpemF0aW9uIGxpYnJhcnkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzQmFsYW5jZWRRdW90ZXModmFsdWUpIHtcbiAgICAgICAgdmFyIG91dHNpZGVTaW5nbGUgPSB0cnVlO1xuICAgICAgICB2YXIgb3V0c2lkZURvdWJsZSA9IHRydWU7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjID0gdmFsdWUuY2hhckF0KGkpO1xuICAgICAgICAgICAgaWYgKGMgPT09ICdcXCcnICYmIG91dHNpZGVEb3VibGUpIHtcbiAgICAgICAgICAgICAgICBvdXRzaWRlU2luZ2xlID0gIW91dHNpZGVTaW5nbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjID09PSAnXCInICYmIG91dHNpZGVTaW5nbGUpIHtcbiAgICAgICAgICAgICAgICBvdXRzaWRlRG91YmxlID0gIW91dHNpZGVEb3VibGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHNpZGVTaW5nbGUgJiYgb3V0c2lkZURvdWJsZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2FuaXRpemVzIHRoZSBnaXZlbiB1bnRydXN0ZWQgQ1NTIHN0eWxlIHByb3BlcnR5IHZhbHVlIChpLmUuIG5vdCBhbiBlbnRpcmUgb2JqZWN0LCBqdXN0IGEgc2luZ2xlXG4gICAgICogdmFsdWUpIGFuZCByZXR1cm5zIGEgdmFsdWUgdGhhdCBpcyBzYWZlIHRvIHVzZSBpbiBhIGJyb3dzZXIgZW52aXJvbm1lbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2FuaXRpemVTdHlsZSh2YWx1ZSkge1xuICAgICAgICB2YWx1ZSA9IFN0cmluZyh2YWx1ZSkudHJpbSgpOyAvLyBNYWtlIHN1cmUgaXQncyBhY3R1YWxseSBhIHN0cmluZy5cbiAgICAgICAgaWYgKCF2YWx1ZSlcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgLy8gU2luZ2xlIHVybCguLi4pIHZhbHVlcyBhcmUgc3VwcG9ydGVkLCBidXQgb25seSBmb3IgVVJMcyB0aGF0IHNhbml0aXplIGNsZWFubHkuIFNlZSBhYm92ZSBmb3JcbiAgICAgICAgLy8gcmVhc29uaW5nIGJlaGluZCB0aGlzLlxuICAgICAgICB2YXIgdXJsTWF0Y2ggPSB2YWx1ZS5tYXRjaChVUkxfUkUpO1xuICAgICAgICBpZiAoKHVybE1hdGNoICYmIHNhbml0aXplVXJsKHVybE1hdGNoWzFdKSA9PT0gdXJsTWF0Y2hbMV0pIHx8XG4gICAgICAgICAgICB2YWx1ZS5tYXRjaChTQUZFX1NUWUxFX1ZBTFVFKSAmJiBoYXNCYWxhbmNlZFF1b3Rlcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTsgLy8gU2FmZSBzdHlsZSB2YWx1ZXMuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9hbmd1bGFyX2NvcmUuaXNEZXZNb2RlKCkpIHtcbiAgICAgICAgICAgIGdldERPTSgpLmxvZyhcIldBUk5JTkc6IHNhbml0aXppbmcgdW5zYWZlIHN0eWxlIHZhbHVlIFwiICsgdmFsdWUgKyBcIiAoc2VlIGh0dHA6Ly9nLmNvL25nL3NlY3VyaXR5I3hzcykuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAndW5zYWZlJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQ5ID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRG9tU2FuaXRpemVyIGhlbHBzIHByZXZlbnRpbmcgQ3Jvc3MgU2l0ZSBTY3JpcHRpbmcgU2VjdXJpdHkgYnVncyAoWFNTKSBieSBzYW5pdGl6aW5nXG4gICAgICogdmFsdWVzIHRvIGJlIHNhZmUgdG8gdXNlIGluIHRoZSBkaWZmZXJlbnQgRE9NIGNvbnRleHRzLlxuICAgICAqXG4gICAgICogRm9yIGV4YW1wbGUsIHdoZW4gYmluZGluZyBhIFVSTCBpbiBhbiBgPGEgW2hyZWZdPVwic29tZVZhbHVlXCI+YCBoeXBlcmxpbmssIGBzb21lVmFsdWVgIHdpbGwgYmVcbiAgICAgKiBzYW5pdGl6ZWQgc28gdGhhdCBhbiBhdHRhY2tlciBjYW5ub3QgaW5qZWN0IGUuZy4gYSBgamF2YXNjcmlwdDpgIFVSTCB0aGF0IHdvdWxkIGV4ZWN1dGUgY29kZSBvblxuICAgICAqIHRoZSB3ZWJzaXRlLlxuICAgICAqXG4gICAgICogSW4gc3BlY2lmaWMgc2l0dWF0aW9ucywgaXQgbWlnaHQgYmUgbmVjZXNzYXJ5IHRvIGRpc2FibGUgc2FuaXRpemF0aW9uLCBmb3IgZXhhbXBsZSBpZiB0aGVcbiAgICAgKiBhcHBsaWNhdGlvbiBnZW51aW5lbHkgbmVlZHMgdG8gcHJvZHVjZSBhIGBqYXZhc2NyaXB0OmAgc3R5bGUgbGluayB3aXRoIGEgZHluYW1pYyB2YWx1ZSBpbiBpdC5cbiAgICAgKiBVc2VycyBjYW4gYnlwYXNzIHNlY3VyaXR5IGJ5IGNvbnN0cnVjdGluZyBhIHZhbHVlIHdpdGggb25lIG9mIHRoZSBgYnlwYXNzU2VjdXJpdHlUcnVzdC4uLmBcbiAgICAgKiBtZXRob2RzLCBhbmQgdGhlbiBiaW5kaW5nIHRvIHRoYXQgdmFsdWUgZnJvbSB0aGUgdGVtcGxhdGUuXG4gICAgICpcbiAgICAgKiBUaGVzZSBzaXR1YXRpb25zIHNob3VsZCBiZSB2ZXJ5IHJhcmUsIGFuZCBleHRyYW9yZGluYXJ5IGNhcmUgbXVzdCBiZSB0YWtlbiB0byBhdm9pZCBjcmVhdGluZyBhXG4gICAgICogQ3Jvc3MgU2l0ZSBTY3JpcHRpbmcgKFhTUykgc2VjdXJpdHkgYnVnIVxuICAgICAqXG4gICAgICogV2hlbiB1c2luZyBgYnlwYXNzU2VjdXJpdHlUcnVzdC4uLmAsIG1ha2Ugc3VyZSB0byBjYWxsIHRoZSBtZXRob2QgYXMgZWFybHkgYXMgcG9zc2libGUgYW5kIGFzXG4gICAgICogY2xvc2UgYXMgcG9zc2libGUgdG8gdGhlIHNvdXJjZSBvZiB0aGUgdmFsdWUsIHRvIG1ha2UgaXQgZWFzeSB0byB2ZXJpZnkgbm8gc2VjdXJpdHkgYnVnIGlzXG4gICAgICogY3JlYXRlZCBieSBpdHMgdXNlLlxuICAgICAqXG4gICAgICogSXQgaXMgbm90IHJlcXVpcmVkIChhbmQgbm90IHJlY29tbWVuZGVkKSB0byBieXBhc3Mgc2VjdXJpdHkgaWYgdGhlIHZhbHVlIGlzIHNhZmUsIGUuZy4gYSBVUkwgdGhhdFxuICAgICAqIGRvZXMgbm90IHN0YXJ0IHdpdGggYSBzdXNwaWNpb3VzIHByb3RvY29sLCBvciBhbiBIVE1MIHNuaXBwZXQgdGhhdCBkb2VzIG5vdCBjb250YWluIGRhbmdlcm91c1xuICAgICAqIGNvZGUuIFRoZSBzYW5pdGl6ZXIgbGVhdmVzIHNhZmUgdmFsdWVzIGludGFjdC5cbiAgICAgKlxuICAgICAqIEBzZWN1cml0eSBDYWxsaW5nIGFueSBvZiB0aGUgYGJ5cGFzc1NlY3VyaXR5VHJ1c3QuLi5gIEFQSXMgZGlzYWJsZXMgQW5ndWxhcidzIGJ1aWx0LWluXG4gICAgICogc2FuaXRpemF0aW9uIGZvciB0aGUgdmFsdWUgcGFzc2VkIGluLiBDYXJlZnVsbHkgY2hlY2sgYW5kIGF1ZGl0IGFsbCB2YWx1ZXMgYW5kIGNvZGUgcGF0aHMgZ29pbmdcbiAgICAgKiBpbnRvIHRoaXMgY2FsbC4gTWFrZSBzdXJlIGFueSB1c2VyIGRhdGEgaXMgYXBwcm9wcmlhdGVseSBlc2NhcGVkIGZvciB0aGlzIHNlY3VyaXR5IGNvbnRleHQuXG4gICAgICogRm9yIG1vcmUgZGV0YWlsLCBzZWUgdGhlIFtTZWN1cml0eSBHdWlkZV0oaHR0cDovL2cuY28vbmcvc2VjdXJpdHkpLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBEb21TYW5pdGl6ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBEb21TYW5pdGl6ZXIoKSB7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIERvbVNhbml0aXplcjtcbiAgICB9KCkpO1xuICAgIHZhciBEb21TYW5pdGl6ZXJJbXBsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDkoRG9tU2FuaXRpemVySW1wbCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gRG9tU2FuaXRpemVySW1wbCgpIHtcbiAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIERvbVNhbml0aXplckltcGwucHJvdG90eXBlLnNhbml0aXplID0gZnVuY3Rpb24gKGN0eCwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgc3dpdGNoIChjdHgpIHtcbiAgICAgICAgICAgICAgICBjYXNlIF9hbmd1bGFyX2NvcmUuU2VjdXJpdHlDb250ZXh0Lk5PTkU6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICBjYXNlIF9hbmd1bGFyX2NvcmUuU2VjdXJpdHlDb250ZXh0LkhUTUw6XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFNhZmVIdG1sSW1wbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5jaGFuZ2luZ1RoaXNCcmVha3NBcHBsaWNhdGlvblNlY3VyaXR5O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrTm90U2FmZVZhbHVlKHZhbHVlLCAnSFRNTCcpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2FuaXRpemVIdG1sKFN0cmluZyh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIGNhc2UgX2FuZ3VsYXJfY29yZS5TZWN1cml0eUNvbnRleHQuU1RZTEU6XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFNhZmVTdHlsZUltcGwpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuY2hhbmdpbmdUaGlzQnJlYWtzQXBwbGljYXRpb25TZWN1cml0eTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja05vdFNhZmVWYWx1ZSh2YWx1ZSwgJ1N0eWxlJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzYW5pdGl6ZVN0eWxlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBjYXNlIF9hbmd1bGFyX2NvcmUuU2VjdXJpdHlDb250ZXh0LlNDUklQVDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgU2FmZVNjcmlwdEltcGwpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuY2hhbmdpbmdUaGlzQnJlYWtzQXBwbGljYXRpb25TZWN1cml0eTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja05vdFNhZmVWYWx1ZSh2YWx1ZSwgJ1NjcmlwdCcpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vuc2FmZSB2YWx1ZSB1c2VkIGluIGEgc2NyaXB0IGNvbnRleHQnKTtcbiAgICAgICAgICAgICAgICBjYXNlIF9hbmd1bGFyX2NvcmUuU2VjdXJpdHlDb250ZXh0LlVSTDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgU2FmZVJlc291cmNlVXJsSW1wbCB8fCB2YWx1ZSBpbnN0YW5jZW9mIFNhZmVVcmxJbXBsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGxvdyByZXNvdXJjZSBVUkxzIGluIFVSTCBjb250ZXh0cywgdGhleSBhcmUgc3RyaWN0bHkgbW9yZSB0cnVzdGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmNoYW5naW5nVGhpc0JyZWFrc0FwcGxpY2F0aW9uU2VjdXJpdHk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja05vdFNhZmVWYWx1ZSh2YWx1ZSwgJ1VSTCcpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2FuaXRpemVVcmwoU3RyaW5nKHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgY2FzZSBfYW5ndWxhcl9jb3JlLlNlY3VyaXR5Q29udGV4dC5SRVNPVVJDRV9VUkw6XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFNhZmVSZXNvdXJjZVVybEltcGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5jaGFuZ2luZ1RoaXNCcmVha3NBcHBsaWNhdGlvblNlY3VyaXR5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tOb3RTYWZlVmFsdWUodmFsdWUsICdSZXNvdXJjZVVSTCcpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vuc2FmZSB2YWx1ZSB1c2VkIGluIGEgcmVzb3VyY2UgVVJMIGNvbnRleHQgKHNlZSBodHRwOi8vZy5jby9uZy9zZWN1cml0eSN4c3MpJyk7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBTZWN1cml0eUNvbnRleHQgXCIgKyBjdHggKyBcIiAoc2VlIGh0dHA6Ly9nLmNvL25nL3NlY3VyaXR5I3hzcylcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIERvbVNhbml0aXplckltcGwucHJvdG90eXBlLmNoZWNrTm90U2FmZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCBleHBlY3RlZFR5cGUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFNhZmVWYWx1ZUltcGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKFwiUmVxdWlyZWQgYSBzYWZlIFwiICsgZXhwZWN0ZWRUeXBlICsgXCIsIGdvdCBhIFwiICsgdmFsdWUuZ2V0VHlwZU5hbWUoKSArIFwiIFwiKSArXG4gICAgICAgICAgICAgICAgICAgIFwiKHNlZSBodHRwOi8vZy5jby9uZy9zZWN1cml0eSN4c3MpXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBEb21TYW5pdGl6ZXJJbXBsLnByb3RvdHlwZS5ieXBhc3NTZWN1cml0eVRydXN0SHRtbCA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gbmV3IFNhZmVIdG1sSW1wbCh2YWx1ZSk7IH07XG4gICAgICAgIERvbVNhbml0aXplckltcGwucHJvdG90eXBlLmJ5cGFzc1NlY3VyaXR5VHJ1c3RTdHlsZSA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gbmV3IFNhZmVTdHlsZUltcGwodmFsdWUpOyB9O1xuICAgICAgICBEb21TYW5pdGl6ZXJJbXBsLnByb3RvdHlwZS5ieXBhc3NTZWN1cml0eVRydXN0U2NyaXB0ID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBuZXcgU2FmZVNjcmlwdEltcGwodmFsdWUpOyB9O1xuICAgICAgICBEb21TYW5pdGl6ZXJJbXBsLnByb3RvdHlwZS5ieXBhc3NTZWN1cml0eVRydXN0VXJsID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBuZXcgU2FmZVVybEltcGwodmFsdWUpOyB9O1xuICAgICAgICBEb21TYW5pdGl6ZXJJbXBsLnByb3RvdHlwZS5ieXBhc3NTZWN1cml0eVRydXN0UmVzb3VyY2VVcmwgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2FmZVJlc291cmNlVXJsSW1wbCh2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIERvbVNhbml0aXplckltcGwuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBEb21TYW5pdGl6ZXJJbXBsLmN0b3JQYXJhbWV0ZXJzID0gW107XG4gICAgICAgIHJldHVybiBEb21TYW5pdGl6ZXJJbXBsO1xuICAgIH0oRG9tU2FuaXRpemVyKSk7XG4gICAgdmFyIFNhZmVWYWx1ZUltcGwgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBTYWZlVmFsdWVJbXBsKGNoYW5naW5nVGhpc0JyZWFrc0FwcGxpY2F0aW9uU2VjdXJpdHkpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdpbmdUaGlzQnJlYWtzQXBwbGljYXRpb25TZWN1cml0eSA9IGNoYW5naW5nVGhpc0JyZWFrc0FwcGxpY2F0aW9uU2VjdXJpdHk7XG4gICAgICAgICAgICAvLyBlbXB0eVxuICAgICAgICB9XG4gICAgICAgIFNhZmVWYWx1ZUltcGwucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIChcIlNhZmVWYWx1ZSBtdXN0IHVzZSBbcHJvcGVydHldPWJpbmRpbmc6IFwiICsgdGhpcy5jaGFuZ2luZ1RoaXNCcmVha3NBcHBsaWNhdGlvblNlY3VyaXR5KSArXG4gICAgICAgICAgICAgICAgXCIgKHNlZSBodHRwOi8vZy5jby9uZy9zZWN1cml0eSN4c3MpXCI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBTYWZlVmFsdWVJbXBsO1xuICAgIH0oKSk7XG4gICAgdmFyIFNhZmVIdG1sSW1wbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQ5KFNhZmVIdG1sSW1wbCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gU2FmZUh0bWxJbXBsKCkge1xuICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgU2FmZUh0bWxJbXBsLnByb3RvdHlwZS5nZXRUeXBlTmFtZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdIVE1MJzsgfTtcbiAgICAgICAgcmV0dXJuIFNhZmVIdG1sSW1wbDtcbiAgICB9KFNhZmVWYWx1ZUltcGwpKTtcbiAgICB2YXIgU2FmZVN0eWxlSW1wbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQ5KFNhZmVTdHlsZUltcGwsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIFNhZmVTdHlsZUltcGwoKSB7XG4gICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBTYWZlU3R5bGVJbXBsLnByb3RvdHlwZS5nZXRUeXBlTmFtZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdTdHlsZSc7IH07XG4gICAgICAgIHJldHVybiBTYWZlU3R5bGVJbXBsO1xuICAgIH0oU2FmZVZhbHVlSW1wbCkpO1xuICAgIHZhciBTYWZlU2NyaXB0SW1wbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQ5KFNhZmVTY3JpcHRJbXBsLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBTYWZlU2NyaXB0SW1wbCgpIHtcbiAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIFNhZmVTY3JpcHRJbXBsLnByb3RvdHlwZS5nZXRUeXBlTmFtZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdTY3JpcHQnOyB9O1xuICAgICAgICByZXR1cm4gU2FmZVNjcmlwdEltcGw7XG4gICAgfShTYWZlVmFsdWVJbXBsKSk7XG4gICAgdmFyIFNhZmVVcmxJbXBsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDkoU2FmZVVybEltcGwsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIFNhZmVVcmxJbXBsKCkge1xuICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgU2FmZVVybEltcGwucHJvdG90eXBlLmdldFR5cGVOYW1lID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJ1VSTCc7IH07XG4gICAgICAgIHJldHVybiBTYWZlVXJsSW1wbDtcbiAgICB9KFNhZmVWYWx1ZUltcGwpKTtcbiAgICB2YXIgU2FmZVJlc291cmNlVXJsSW1wbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQ5KFNhZmVSZXNvdXJjZVVybEltcGwsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIFNhZmVSZXNvdXJjZVVybEltcGwoKSB7XG4gICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBTYWZlUmVzb3VyY2VVcmxJbXBsLnByb3RvdHlwZS5nZXRUeXBlTmFtZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdSZXNvdXJjZVVSTCc7IH07XG4gICAgICAgIHJldHVybiBTYWZlUmVzb3VyY2VVcmxJbXBsO1xuICAgIH0oU2FmZVZhbHVlSW1wbCkpO1xuXG4gICAgdmFyIElOVEVSTkFMX0JST1dTRVJfUExBVEZPUk1fUFJPVklERVJTID0gW1xuICAgICAgICB7IHByb3ZpZGU6IF9hbmd1bGFyX2NvcmUuUExBVEZPUk1fSU5JVElBTElaRVIsIHVzZVZhbHVlOiBpbml0RG9tQWRhcHRlciwgbXVsdGk6IHRydWUgfSxcbiAgICAgICAgeyBwcm92aWRlOiBfYW5ndWxhcl9jb21tb24uUGxhdGZvcm1Mb2NhdGlvbiwgdXNlQ2xhc3M6IEJyb3dzZXJQbGF0Zm9ybUxvY2F0aW9uIH1cbiAgICBdO1xuICAgIC8qKlxuICAgICAqIEBzZWN1cml0eSBSZXBsYWNpbmcgYnVpbHQtaW4gc2FuaXRpemF0aW9uIHByb3ZpZGVycyBleHBvc2VzIHRoZSBhcHBsaWNhdGlvbiB0byBYU1Mgcmlza3MuXG4gICAgICogQXR0YWNrZXItY29udHJvbGxlZCBkYXRhIGludHJvZHVjZWQgYnkgYW4gdW5zYW5pdGl6ZWQgcHJvdmlkZXIgY291bGQgZXhwb3NlIHlvdXJcbiAgICAgKiBhcHBsaWNhdGlvbiB0byBYU1Mgcmlza3MuIEZvciBtb3JlIGRldGFpbCwgc2VlIHRoZSBbU2VjdXJpdHkgR3VpZGVdKGh0dHA6Ly9nLmNvL25nL3NlY3VyaXR5KS5cbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgdmFyIEJST1dTRVJfU0FOSVRJWkFUSU9OX1BST1ZJREVSUyA9IFtcbiAgICAgICAgeyBwcm92aWRlOiBfYW5ndWxhcl9jb3JlLlNhbml0aXplciwgdXNlRXhpc3Rpbmc6IERvbVNhbml0aXplciB9LFxuICAgICAgICB7IHByb3ZpZGU6IERvbVNhbml0aXplciwgdXNlQ2xhc3M6IERvbVNhbml0aXplckltcGwgfSxcbiAgICBdO1xuICAgIC8qKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgcGxhdGZvcm1Ccm93c2VyID0gX2FuZ3VsYXJfY29yZS5jcmVhdGVQbGF0Zm9ybUZhY3RvcnkoX2FuZ3VsYXJfY29yZS5wbGF0Zm9ybUNvcmUsICdicm93c2VyJywgSU5URVJOQUxfQlJPV1NFUl9QTEFURk9STV9QUk9WSURFUlMpO1xuICAgIGZ1bmN0aW9uIGluaXREb21BZGFwdGVyKCkge1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5tYWtlQ3VycmVudCgpO1xuICAgICAgICBCcm93c2VyR2V0VGVzdGFiaWxpdHkuaW5pdCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlcnJvckhhbmRsZXIoKSB7XG4gICAgICAgIHJldHVybiBuZXcgX2FuZ3VsYXJfY29yZS5FcnJvckhhbmRsZXIoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX2RvY3VtZW50KCkge1xuICAgICAgICByZXR1cm4gZ2V0RE9NKCkuZGVmYXVsdERvYygpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfcmVzb2x2ZURlZmF1bHRBbmltYXRpb25Ecml2ZXIoKSB7XG4gICAgICAgIGlmIChnZXRET00oKS5zdXBwb3J0c1dlYkFuaW1hdGlvbigpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFdlYkFuaW1hdGlvbnNEcml2ZXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQW5pbWF0aW9uRHJpdmVyLk5PT1A7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBuZyBtb2R1bGUgZm9yIHRoZSBicm93c2VyLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBCcm93c2VyTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQnJvd3Nlck1vZHVsZShwYXJlbnRNb2R1bGUpIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnRNb2R1bGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCcm93c2VyTW9kdWxlIGhhcyBhbHJlYWR5IGJlZW4gbG9hZGVkLiBJZiB5b3UgbmVlZCBhY2Nlc3MgdG8gY29tbW9uIGRpcmVjdGl2ZXMgc3VjaCBhcyBOZ0lmIGFuZCBOZ0ZvciBmcm9tIGEgbGF6eSBsb2FkZWQgbW9kdWxlLCBpbXBvcnQgQ29tbW9uTW9kdWxlIGluc3RlYWQuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIEJyb3dzZXJNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5OZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEJST1dTRVJfU0FOSVRJWkFUSU9OX1BST1ZJREVSUywgeyBwcm92aWRlOiBfYW5ndWxhcl9jb3JlLkVycm9ySGFuZGxlciwgdXNlRmFjdG9yeTogZXJyb3JIYW5kbGVyLCBkZXBzOiBbXSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogRE9DVU1FTlQsIHVzZUZhY3Rvcnk6IF9kb2N1bWVudCwgZGVwczogW10gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IEVWRU5UX01BTkFHRVJfUExVR0lOUywgdXNlQ2xhc3M6IERvbUV2ZW50c1BsdWdpbiwgbXVsdGk6IHRydWUgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IEVWRU5UX01BTkFHRVJfUExVR0lOUywgdXNlQ2xhc3M6IEtleUV2ZW50c1BsdWdpbiwgbXVsdGk6IHRydWUgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IEVWRU5UX01BTkFHRVJfUExVR0lOUywgdXNlQ2xhc3M6IEhhbW1lckdlc3R1cmVzUGx1Z2luLCBtdWx0aTogdHJ1ZSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogSEFNTUVSX0dFU1RVUkVfQ09ORklHLCB1c2VDbGFzczogSGFtbWVyR2VzdHVyZUNvbmZpZyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogRG9tUm9vdFJlbmRlcmVyLCB1c2VDbGFzczogRG9tUm9vdFJlbmRlcmVyXyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogX2FuZ3VsYXJfY29yZS5Sb290UmVuZGVyZXIsIHVzZUV4aXN0aW5nOiBEb21Sb290UmVuZGVyZXIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IFNoYXJlZFN0eWxlc0hvc3QsIHVzZUV4aXN0aW5nOiBEb21TaGFyZWRTdHlsZXNIb3N0IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBwcm92aWRlOiBBbmltYXRpb25Ecml2ZXIsIHVzZUZhY3Rvcnk6IF9yZXNvbHZlRGVmYXVsdEFuaW1hdGlvbkRyaXZlciB9LCBEb21TaGFyZWRTdHlsZXNIb3N0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hbmd1bGFyX2NvcmUuVGVzdGFiaWxpdHksIEV2ZW50TWFuYWdlciwgRUxFTUVOVF9QUk9CRV9QUk9WSURFUlMsIFRpdGxlXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwb3J0czogW19hbmd1bGFyX2NvbW1vbi5Db21tb25Nb2R1bGUsIF9hbmd1bGFyX2NvcmUuQXBwbGljYXRpb25Nb2R1bGVdXG4gICAgICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgQnJvd3Nlck1vZHVsZS5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogQnJvd3Nlck1vZHVsZSwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuU2tpcFNlbGYgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBCcm93c2VyTW9kdWxlO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgLyoqXG4gICAgICogSlMgdmVyc2lvbiBvZiBicm93c2VyIEFQSXMuIFRoaXMgbGlicmFyeSBjYW4gb25seSBydW4gaW4gdGhlIGJyb3dzZXIuXG4gICAgICovXG4gICAgdmFyIHdpbiA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdyB8fCB7fTtcblxuICAgIHZhciBDaGFuZ2VEZXRlY3Rpb25QZXJmUmVjb3JkID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQ2hhbmdlRGV0ZWN0aW9uUGVyZlJlY29yZChtc1BlclRpY2ssIG51bVRpY2tzKSB7XG4gICAgICAgICAgICB0aGlzLm1zUGVyVGljayA9IG1zUGVyVGljaztcbiAgICAgICAgICAgIHRoaXMubnVtVGlja3MgPSBudW1UaWNrcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ2hhbmdlRGV0ZWN0aW9uUGVyZlJlY29yZDtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIEVudHJ5IHBvaW50IGZvciBhbGwgQW5ndWxhciBkZWJ1ZyB0b29scy4gVGhpcyBvYmplY3QgY29ycmVzcG9uZHMgdG8gdGhlIGBuZ2BcbiAgICAgKiBnbG9iYWwgdmFyaWFibGUgYWNjZXNzaWJsZSBpbiB0aGUgZGV2IGNvbnNvbGUuXG4gICAgICovXG4gICAgdmFyIEFuZ3VsYXJUb29scyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEFuZ3VsYXJUb29scyhyZWYpIHtcbiAgICAgICAgICAgIHRoaXMucHJvZmlsZXIgPSBuZXcgQW5ndWxhclByb2ZpbGVyKHJlZik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFuZ3VsYXJUb29scztcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIEVudHJ5IHBvaW50IGZvciBhbGwgQW5ndWxhciBwcm9maWxpbmctcmVsYXRlZCBkZWJ1ZyB0b29scy4gVGhpcyBvYmplY3RcbiAgICAgKiBjb3JyZXNwb25kcyB0byB0aGUgYG5nLnByb2ZpbGVyYCBpbiB0aGUgZGV2IGNvbnNvbGUuXG4gICAgICovXG4gICAgdmFyIEFuZ3VsYXJQcm9maWxlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEFuZ3VsYXJQcm9maWxlcihyZWYpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwUmVmID0gcmVmLmluamVjdG9yLmdldChfYW5ndWxhcl9jb3JlLkFwcGxpY2F0aW9uUmVmKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRXhlcmNpc2VzIGNoYW5nZSBkZXRlY3Rpb24gaW4gYSBsb29wIGFuZCB0aGVuIHByaW50cyB0aGUgYXZlcmFnZSBhbW91bnQgb2ZcbiAgICAgICAgICogdGltZSBpbiBtaWxsaXNlY29uZHMgaG93IGxvbmcgYSBzaW5nbGUgcm91bmQgb2YgY2hhbmdlIGRldGVjdGlvbiB0YWtlcyBmb3JcbiAgICAgICAgICogdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIFVJLiBJdCBydW5zIGEgbWluaW11bSBvZiA1IHJvdW5kcyBmb3IgYSBtaW5pbXVtXG4gICAgICAgICAqIG9mIDUwMCBtaWxsaXNlY29uZHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIE9wdGlvbmFsbHksIGEgdXNlciBtYXkgcGFzcyBhIGBjb25maWdgIHBhcmFtZXRlciBjb250YWluaW5nIGEgbWFwIG9mXG4gICAgICAgICAqIG9wdGlvbnMuIFN1cHBvcnRlZCBvcHRpb25zIGFyZTpcbiAgICAgICAgICpcbiAgICAgICAgICogYHJlY29yZGAgKGJvb2xlYW4pIC0gY2F1c2VzIHRoZSBwcm9maWxlciB0byByZWNvcmQgYSBDUFUgcHJvZmlsZSB3aGlsZVxuICAgICAgICAgKiBpdCBleGVyY2lzZXMgdGhlIGNoYW5nZSBkZXRlY3Rvci4gRXhhbXBsZTpcbiAgICAgICAgICpcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqIG5nLnByb2ZpbGVyLnRpbWVDaGFuZ2VEZXRlY3Rpb24oe3JlY29yZDogdHJ1ZX0pXG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgQW5ndWxhclByb2ZpbGVyLnByb3RvdHlwZS50aW1lQ2hhbmdlRGV0ZWN0aW9uID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICAgICAgdmFyIHJlY29yZCA9IGNvbmZpZyAmJiBjb25maWdbJ3JlY29yZCddO1xuICAgICAgICAgICAgdmFyIHByb2ZpbGVOYW1lID0gJ0NoYW5nZSBEZXRlY3Rpb24nO1xuICAgICAgICAgICAgLy8gUHJvZmlsZXIgaXMgbm90IGF2YWlsYWJsZSBpbiBBbmRyb2lkIGJyb3dzZXJzLCBub3IgaW4gSUUgOSB3aXRob3V0IGRldiB0b29scyBvcGVuZWRcbiAgICAgICAgICAgIHZhciBpc1Byb2ZpbGVyQXZhaWxhYmxlID0gaXNQcmVzZW50KHdpbi5jb25zb2xlLnByb2ZpbGUpO1xuICAgICAgICAgICAgaWYgKHJlY29yZCAmJiBpc1Byb2ZpbGVyQXZhaWxhYmxlKSB7XG4gICAgICAgICAgICAgICAgd2luLmNvbnNvbGUucHJvZmlsZShwcm9maWxlTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBnZXRET00oKS5wZXJmb3JtYW5jZU5vdygpO1xuICAgICAgICAgICAgdmFyIG51bVRpY2tzID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChudW1UaWNrcyA8IDUgfHwgKGdldERPTSgpLnBlcmZvcm1hbmNlTm93KCkgLSBzdGFydCkgPCA1MDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcFJlZi50aWNrKCk7XG4gICAgICAgICAgICAgICAgbnVtVGlja3MrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBlbmQgPSBnZXRET00oKS5wZXJmb3JtYW5jZU5vdygpO1xuICAgICAgICAgICAgaWYgKHJlY29yZCAmJiBpc1Byb2ZpbGVyQXZhaWxhYmxlKSB7XG4gICAgICAgICAgICAgICAgLy8gbmVlZCB0byBjYXN0IHRvIDxhbnk+IGJlY2F1c2UgdHlwZSBjaGVja2VyIHRoaW5rcyB0aGVyZSdzIG5vIGFyZ3VtZW50XG4gICAgICAgICAgICAgICAgLy8gd2hpbGUgaW4gZmFjdCB0aGVyZSBpczpcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Db25zb2xlL3Byb2ZpbGVFbmRcbiAgICAgICAgICAgICAgICB3aW4uY29uc29sZS5wcm9maWxlRW5kKHByb2ZpbGVOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBtc1BlclRpY2sgPSAoZW5kIC0gc3RhcnQpIC8gbnVtVGlja3M7XG4gICAgICAgICAgICB3aW4uY29uc29sZS5sb2coXCJyYW4gXCIgKyBudW1UaWNrcyArIFwiIGNoYW5nZSBkZXRlY3Rpb24gY3ljbGVzXCIpO1xuICAgICAgICAgICAgd2luLmNvbnNvbGUubG9nKG1zUGVyVGljay50b0ZpeGVkKDIpICsgXCIgbXMgcGVyIGNoZWNrXCIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDaGFuZ2VEZXRlY3Rpb25QZXJmUmVjb3JkKG1zUGVyVGljaywgbnVtVGlja3MpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gQW5ndWxhclByb2ZpbGVyO1xuICAgIH0oKSk7XG5cbiAgICB2YXIgY29udGV4dCA9IGdsb2JhbCQxO1xuICAgIC8qKlxuICAgICAqIEVuYWJsZWQgQW5ndWxhciAyIGRlYnVnIHRvb2xzIHRoYXQgYXJlIGFjY2Vzc2libGUgdmlhIHlvdXIgYnJvd3NlcidzXG4gICAgICogZGV2ZWxvcGVyIGNvbnNvbGUuXG4gICAgICpcbiAgICAgKiBVc2FnZTpcbiAgICAgKlxuICAgICAqIDEuIE9wZW4gZGV2ZWxvcGVyIGNvbnNvbGUgKGUuZy4gaW4gQ2hyb21lIEN0cmwgKyBTaGlmdCArIGopXG4gICAgICogMS4gVHlwZSBgbmcuYCAodXN1YWxseSB0aGUgY29uc29sZSB3aWxsIHNob3cgYXV0by1jb21wbGV0ZSBzdWdnZXN0aW9uKVxuICAgICAqIDEuIFRyeSB0aGUgY2hhbmdlIGRldGVjdGlvbiBwcm9maWxlciBgbmcucHJvZmlsZXIudGltZUNoYW5nZURldGVjdGlvbigpYFxuICAgICAqICAgIHRoZW4gaGl0IEVudGVyLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbCBBbGwgZGVidWdnaW5nIGFwaXMgYXJlIGN1cnJlbnRseSBleHBlcmltZW50YWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZW5hYmxlRGVidWdUb29scyhyZWYpIHtcbiAgICAgICAgY29udGV4dC5uZyA9IG5ldyBBbmd1bGFyVG9vbHMocmVmKTtcbiAgICAgICAgcmV0dXJuIHJlZjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzYWJsZXMgQW5ndWxhciAyIHRvb2xzLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbCBBbGwgZGVidWdnaW5nIGFwaXMgYXJlIGN1cnJlbnRseSBleHBlcmltZW50YWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGlzYWJsZURlYnVnVG9vbHMoKSB7XG4gICAgICAgIGRlbGV0ZSBjb250ZXh0Lm5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByZWRpY2F0ZXMgZm9yIHVzZSB3aXRoIHtAbGluayBEZWJ1Z0VsZW1lbnR9J3MgcXVlcnkgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbCBBbGwgZGVidWdnaW5nIGFwaXMgYXJlIGN1cnJlbnRseSBleHBlcmltZW50YWwuXG4gICAgICovXG4gICAgdmFyIEJ5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQnkoKSB7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hdGNoIGFsbCBlbGVtZW50cy5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMgRXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiB7QGV4YW1wbGUgcGxhdGZvcm0tYnJvd3Nlci9kb20vZGVidWcvdHMvYnkvYnkudHMgcmVnaW9uPSdieV9hbGwnfVxuICAgICAgICAgKi9cbiAgICAgICAgQnkuYWxsID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKGRlYnVnRWxlbWVudCkgeyByZXR1cm4gdHJ1ZTsgfTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hdGNoIGVsZW1lbnRzIGJ5IHRoZSBnaXZlbiBDU1Mgc2VsZWN0b3IuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIEV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICoge0BleGFtcGxlIHBsYXRmb3JtLWJyb3dzZXIvZG9tL2RlYnVnL3RzL2J5L2J5LnRzIHJlZ2lvbj0nYnlfY3NzJ31cbiAgICAgICAgICovXG4gICAgICAgIEJ5LmNzcyA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkZWJ1Z0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNQcmVzZW50KGRlYnVnRWxlbWVudC5uYXRpdmVFbGVtZW50KSA/XG4gICAgICAgICAgICAgICAgICAgIGdldERPTSgpLmVsZW1lbnRNYXRjaGVzKGRlYnVnRWxlbWVudC5uYXRpdmVFbGVtZW50LCBzZWxlY3RvcikgOlxuICAgICAgICAgICAgICAgICAgICBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXRjaCBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIGdpdmVuIGRpcmVjdGl2ZSBwcmVzZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyBFeGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqIHtAZXhhbXBsZSBwbGF0Zm9ybS1icm93c2VyL2RvbS9kZWJ1Zy90cy9ieS9ieS50cyByZWdpb249J2J5X2RpcmVjdGl2ZSd9XG4gICAgICAgICAqL1xuICAgICAgICBCeS5kaXJlY3RpdmUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkZWJ1Z0VsZW1lbnQpIHsgcmV0dXJuIGRlYnVnRWxlbWVudC5wcm92aWRlclRva2Vucy5pbmRleE9mKHR5cGUpICE9PSAtMTsgfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEJ5O1xuICAgIH0oKSk7XG5cbiAgICB2YXIgX19wbGF0Zm9ybV9icm93c2VyX3ByaXZhdGVfXyA9IHtcbiAgICAgICAgQnJvd3NlclBsYXRmb3JtTG9jYXRpb246IEJyb3dzZXJQbGF0Zm9ybUxvY2F0aW9uLFxuICAgICAgICBEb21BZGFwdGVyOiBEb21BZGFwdGVyLFxuICAgICAgICBCcm93c2VyRG9tQWRhcHRlcjogQnJvd3NlckRvbUFkYXB0ZXIsXG4gICAgICAgIEJyb3dzZXJHZXRUZXN0YWJpbGl0eTogQnJvd3NlckdldFRlc3RhYmlsaXR5LFxuICAgICAgICBnZXRET006IGdldERPTSxcbiAgICAgICAgc2V0Um9vdERvbUFkYXB0ZXI6IHNldFJvb3REb21BZGFwdGVyLFxuICAgICAgICBEb21Sb290UmVuZGVyZXJfOiBEb21Sb290UmVuZGVyZXJfLFxuICAgICAgICBEb21Sb290UmVuZGVyZXI6IERvbVJvb3RSZW5kZXJlcixcbiAgICAgICAgRG9tU2hhcmVkU3R5bGVzSG9zdDogRG9tU2hhcmVkU3R5bGVzSG9zdCxcbiAgICAgICAgU2hhcmVkU3R5bGVzSG9zdDogU2hhcmVkU3R5bGVzSG9zdCxcbiAgICAgICAgRUxFTUVOVF9QUk9CRV9QUk9WSURFUlM6IEVMRU1FTlRfUFJPQkVfUFJPVklERVJTLFxuICAgICAgICBEb21FdmVudHNQbHVnaW46IERvbUV2ZW50c1BsdWdpbixcbiAgICAgICAgS2V5RXZlbnRzUGx1Z2luOiBLZXlFdmVudHNQbHVnaW4sXG4gICAgICAgIEhhbW1lckdlc3R1cmVzUGx1Z2luOiBIYW1tZXJHZXN0dXJlc1BsdWdpbixcbiAgICAgICAgaW5pdERvbUFkYXB0ZXI6IGluaXREb21BZGFwdGVyLFxuICAgICAgICBJTlRFUk5BTF9CUk9XU0VSX1BMQVRGT1JNX1BST1ZJREVSUzogSU5URVJOQUxfQlJPV1NFUl9QTEFURk9STV9QUk9WSURFUlMsXG4gICAgICAgIEJST1dTRVJfU0FOSVRJWkFUSU9OX1BST1ZJREVSUzogQlJPV1NFUl9TQU5JVElaQVRJT05fUFJPVklERVJTXG4gICAgfTtcblxuICAgIGV4cG9ydHMuQnJvd3Nlck1vZHVsZSA9IEJyb3dzZXJNb2R1bGU7XG4gICAgZXhwb3J0cy5wbGF0Zm9ybUJyb3dzZXIgPSBwbGF0Zm9ybUJyb3dzZXI7XG4gICAgZXhwb3J0cy5UaXRsZSA9IFRpdGxlO1xuICAgIGV4cG9ydHMuZGlzYWJsZURlYnVnVG9vbHMgPSBkaXNhYmxlRGVidWdUb29scztcbiAgICBleHBvcnRzLmVuYWJsZURlYnVnVG9vbHMgPSBlbmFibGVEZWJ1Z1Rvb2xzO1xuICAgIGV4cG9ydHMuQW5pbWF0aW9uRHJpdmVyID0gQW5pbWF0aW9uRHJpdmVyO1xuICAgIGV4cG9ydHMuQnkgPSBCeTtcbiAgICBleHBvcnRzLk5nUHJvYmVUb2tlbiA9IE5nUHJvYmVUb2tlbjtcbiAgICBleHBvcnRzLkRPQ1VNRU5UID0gRE9DVU1FTlQ7XG4gICAgZXhwb3J0cy5FVkVOVF9NQU5BR0VSX1BMVUdJTlMgPSBFVkVOVF9NQU5BR0VSX1BMVUdJTlM7XG4gICAgZXhwb3J0cy5FdmVudE1hbmFnZXIgPSBFdmVudE1hbmFnZXI7XG4gICAgZXhwb3J0cy5IQU1NRVJfR0VTVFVSRV9DT05GSUcgPSBIQU1NRVJfR0VTVFVSRV9DT05GSUc7XG4gICAgZXhwb3J0cy5IYW1tZXJHZXN0dXJlQ29uZmlnID0gSGFtbWVyR2VzdHVyZUNvbmZpZztcbiAgICBleHBvcnRzLkRvbVNhbml0aXplciA9IERvbVNhbml0aXplcjtcbiAgICBleHBvcnRzLl9fcGxhdGZvcm1fYnJvd3Nlcl9wcml2YXRlX18gPSBfX3BsYXRmb3JtX2Jyb3dzZXJfcHJpdmF0ZV9fO1xuXG59KSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciByb290XzEgPSByZXF1aXJlKCcuL3V0aWwvcm9vdCcpO1xudmFyIHRvU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi91dGlsL3RvU3Vic2NyaWJlcicpO1xudmFyIG9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4vc3ltYm9sL29ic2VydmFibGUnKTtcbi8qKlxuICogQSByZXByZXNlbnRhdGlvbiBvZiBhbnkgc2V0IG9mIHZhbHVlcyBvdmVyIGFueSBhbW91bnQgb2YgdGltZS4gVGhpcyB0aGUgbW9zdCBiYXNpYyBidWlsZGluZyBibG9ja1xuICogb2YgUnhKUy5cbiAqXG4gKiBAY2xhc3MgT2JzZXJ2YWJsZTxUPlxuICovXG52YXIgT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3Vic2NyaWJlIHRoZSBmdW5jdGlvbiB0aGF0IGlzICBjYWxsZWQgd2hlbiB0aGUgT2JzZXJ2YWJsZSBpc1xuICAgICAqIGluaXRpYWxseSBzdWJzY3JpYmVkIHRvLiBUaGlzIGZ1bmN0aW9uIGlzIGdpdmVuIGEgU3Vic2NyaWJlciwgdG8gd2hpY2ggbmV3IHZhbHVlc1xuICAgICAqIGNhbiBiZSBgbmV4dGBlZCwgb3IgYW4gYGVycm9yYCBtZXRob2QgY2FuIGJlIGNhbGxlZCB0byByYWlzZSBhbiBlcnJvciwgb3JcbiAgICAgKiBgY29tcGxldGVgIGNhbiBiZSBjYWxsZWQgdG8gbm90aWZ5IG9mIGEgc3VjY2Vzc2Z1bCBjb21wbGV0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE9ic2VydmFibGUoc3Vic2NyaWJlKSB7XG4gICAgICAgIHRoaXMuX2lzU2NhbGFyID0gZmFsc2U7XG4gICAgICAgIGlmIChzdWJzY3JpYmUpIHtcbiAgICAgICAgICAgIHRoaXMuX3N1YnNjcmliZSA9IHN1YnNjcmliZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IE9ic2VydmFibGUsIHdpdGggdGhpcyBPYnNlcnZhYmxlIGFzIHRoZSBzb3VyY2UsIGFuZCB0aGUgcGFzc2VkXG4gICAgICogb3BlcmF0b3IgZGVmaW5lZCBhcyB0aGUgbmV3IG9ic2VydmFibGUncyBvcGVyYXRvci5cbiAgICAgKiBAbWV0aG9kIGxpZnRcbiAgICAgKiBAcGFyYW0ge09wZXJhdG9yfSBvcGVyYXRvciB0aGUgb3BlcmF0b3IgZGVmaW5pbmcgdGhlIG9wZXJhdGlvbiB0byB0YWtlIG9uIHRoZSBvYnNlcnZhYmxlXG4gICAgICogQHJldHVybiB7T2JzZXJ2YWJsZX0gYSBuZXcgb2JzZXJ2YWJsZSB3aXRoIHRoZSBPcGVyYXRvciBhcHBsaWVkXG4gICAgICovXG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUubGlmdCA9IGZ1bmN0aW9uIChvcGVyYXRvcikge1xuICAgICAgICB2YXIgb2JzZXJ2YWJsZSA9IG5ldyBPYnNlcnZhYmxlKCk7XG4gICAgICAgIG9ic2VydmFibGUuc291cmNlID0gdGhpcztcbiAgICAgICAgb2JzZXJ2YWJsZS5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgICAgICByZXR1cm4gb2JzZXJ2YWJsZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBoYW5kbGVycyBmb3IgaGFuZGxpbmcgZW1pdHRlZCB2YWx1ZXMsIGVycm9yIGFuZCBjb21wbGV0aW9ucyBmcm9tIHRoZSBvYnNlcnZhYmxlLCBhbmRcbiAgICAgKiAgZXhlY3V0ZXMgdGhlIG9ic2VydmFibGUncyBzdWJzY3JpYmVyIGZ1bmN0aW9uLCB3aGljaCB3aWxsIHRha2UgYWN0aW9uIHRvIHNldCB1cCB0aGUgdW5kZXJseWluZyBkYXRhIHN0cmVhbVxuICAgICAqIEBtZXRob2Qgc3Vic2NyaWJlXG4gICAgICogQHBhcmFtIHtQYXJ0aWFsT2JzZXJ2ZXJ8RnVuY3Rpb259IG9ic2VydmVyT3JOZXh0IChvcHRpb25hbCkgZWl0aGVyIGFuIG9ic2VydmVyIGRlZmluaW5nIGFsbCBmdW5jdGlvbnMgdG8gYmUgY2FsbGVkLFxuICAgICAqICBvciB0aGUgZmlyc3Qgb2YgdGhyZWUgcG9zc2libGUgaGFuZGxlcnMsIHdoaWNoIGlzIHRoZSBoYW5kbGVyIGZvciBlYWNoIHZhbHVlIGVtaXR0ZWQgZnJvbSB0aGUgb2JzZXJ2YWJsZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcnJvciAob3B0aW9uYWwpIGEgaGFuZGxlciBmb3IgYSB0ZXJtaW5hbCBldmVudCByZXN1bHRpbmcgZnJvbSBhbiBlcnJvci4gSWYgbm8gZXJyb3IgaGFuZGxlciBpcyBwcm92aWRlZCxcbiAgICAgKiAgdGhlIGVycm9yIHdpbGwgYmUgdGhyb3duIGFzIHVuaGFuZGxlZFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBsZXRlIChvcHRpb25hbCkgYSBoYW5kbGVyIGZvciBhIHRlcm1pbmFsIGV2ZW50IHJlc3VsdGluZyBmcm9tIHN1Y2Nlc3NmdWwgY29tcGxldGlvbi5cbiAgICAgKiBAcmV0dXJuIHtJU3Vic2NyaXB0aW9ufSBhIHN1YnNjcmlwdGlvbiByZWZlcmVuY2UgdG8gdGhlIHJlZ2lzdGVyZWQgaGFuZGxlcnNcbiAgICAgKi9cbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAob2JzZXJ2ZXJPck5leHQsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgICAgICB2YXIgb3BlcmF0b3IgPSB0aGlzLm9wZXJhdG9yO1xuICAgICAgICB2YXIgc2luayA9IHRvU3Vic2NyaWJlcl8xLnRvU3Vic2NyaWJlcihvYnNlcnZlck9yTmV4dCwgZXJyb3IsIGNvbXBsZXRlKTtcbiAgICAgICAgaWYgKG9wZXJhdG9yKSB7XG4gICAgICAgICAgICBvcGVyYXRvci5jYWxsKHNpbmssIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2luay5hZGQodGhpcy5fc3Vic2NyaWJlKHNpbmspKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2luay5zeW5jRXJyb3JUaHJvd2FibGUpIHtcbiAgICAgICAgICAgIHNpbmsuc3luY0Vycm9yVGhyb3dhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoc2luay5zeW5jRXJyb3JUaHJvd24pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBzaW5rLnN5bmNFcnJvclZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaW5rO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQG1ldGhvZCBmb3JFYWNoXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbmV4dCBhIGhhbmRsZXIgZm9yIGVhY2ggdmFsdWUgZW1pdHRlZCBieSB0aGUgb2JzZXJ2YWJsZVxuICAgICAqIEBwYXJhbSB7UHJvbWlzZUNvbnN0cnVjdG9yfSBbUHJvbWlzZUN0b3JdIGEgY29uc3RydWN0b3IgZnVuY3Rpb24gdXNlZCB0byBpbnN0YW50aWF0ZSB0aGUgUHJvbWlzZVxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IGEgcHJvbWlzZSB0aGF0IGVpdGhlciByZXNvbHZlcyBvbiBvYnNlcnZhYmxlIGNvbXBsZXRpb24gb3JcbiAgICAgKiAgcmVqZWN0cyB3aXRoIHRoZSBoYW5kbGVkIGVycm9yXG4gICAgICovXG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChuZXh0LCBQcm9taXNlQ3Rvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIVByb21pc2VDdG9yKSB7XG4gICAgICAgICAgICBpZiAocm9vdF8xLnJvb3QuUnggJiYgcm9vdF8xLnJvb3QuUnguY29uZmlnICYmIHJvb3RfMS5yb290LlJ4LmNvbmZpZy5Qcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgUHJvbWlzZUN0b3IgPSByb290XzEucm9vdC5SeC5jb25maWcuUHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJvb3RfMS5yb290LlByb21pc2UpIHtcbiAgICAgICAgICAgICAgICBQcm9taXNlQ3RvciA9IHJvb3RfMS5yb290LlByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFQcm9taXNlQ3Rvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBQcm9taXNlIGltcGwgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2VDdG9yKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSBfdGhpcy5zdWJzY3JpYmUoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhIHN1YnNjcmlwdGlvbiwgdGhlbiB3ZSBjYW4gc3VybWlzZVxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgbmV4dCBoYW5kbGluZyBpcyBhc3luY2hyb25vdXMuIEFueSBlcnJvcnMgdGhyb3duXG4gICAgICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gYmUgcmVqZWN0ZWQgZXhwbGljaXRseSBhbmQgdW5zdWJzY3JpYmUgbXVzdCBiZVxuICAgICAgICAgICAgICAgICAgICAvLyBjYWxsZWQgbWFudWFsbHlcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIE5PIHN1YnNjcmlwdGlvbiwgdGhlbiB3ZSdyZSBnZXR0aW5nIGEgbmV4dGVkXG4gICAgICAgICAgICAgICAgICAgIC8vIHZhbHVlIHN5bmNocm9ub3VzbHkgZHVyaW5nIHN1YnNjcmlwdGlvbi4gV2UgY2FuIGp1c3QgY2FsbCBpdC5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgaXQgZXJyb3JzLCBPYnNlcnZhYmxlJ3MgYHN1YnNjcmliZWAgd2lsbCBlbnN1cmUgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIHVuc3Vic2NyaXB0aW9uIGxvZ2ljIGlzIGNhbGxlZCwgdGhlbiBzeW5jaHJvbm91c2x5IHJldGhyb3cgdGhlIGVycm9yLlxuICAgICAgICAgICAgICAgICAgICAvLyBBZnRlciB0aGF0LCBQcm9taXNlIHdpbGwgdHJhcCB0aGUgZXJyb3IgYW5kIHNlbmQgaXRcbiAgICAgICAgICAgICAgICAgICAgLy8gZG93biB0aGUgcmVqZWN0aW9uIHBhdGguXG4gICAgICAgICAgICAgICAgICAgIG5leHQodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHJlamVjdCwgcmVzb2x2ZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5zdWJzY3JpYmUoc3Vic2NyaWJlcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBbiBpbnRlcm9wIHBvaW50IGRlZmluZWQgYnkgdGhlIGVzNy1vYnNlcnZhYmxlIHNwZWMgaHR0cHM6Ly9naXRodWIuY29tL3plbnBhcnNpbmcvZXMtb2JzZXJ2YWJsZVxuICAgICAqIEBtZXRob2QgU3ltYm9sLm9ic2VydmFibGVcbiAgICAgKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSB0aGlzIGluc3RhbmNlIG9mIHRoZSBvYnNlcnZhYmxlXG4gICAgICovXG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGVbb2JzZXJ2YWJsZV8xLiQkb2JzZXJ2YWJsZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLy8gSEFDSzogU2luY2UgVHlwZVNjcmlwdCBpbmhlcml0cyBzdGF0aWMgcHJvcGVydGllcyB0b28sIHdlIGhhdmUgdG9cbiAgICAvLyBmaWdodCBhZ2FpbnN0IFR5cGVTY3JpcHQgaGVyZSBzbyBTdWJqZWN0IGNhbiBoYXZlIGEgZGlmZmVyZW50IHN0YXRpYyBjcmVhdGUgc2lnbmF0dXJlXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBjb2xkIE9ic2VydmFibGUgYnkgY2FsbGluZyB0aGUgT2JzZXJ2YWJsZSBjb25zdHJ1Y3RvclxuICAgICAqIEBzdGF0aWMgdHJ1ZVxuICAgICAqIEBvd25lciBPYnNlcnZhYmxlXG4gICAgICogQG1ldGhvZCBjcmVhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdWJzY3JpYmU/IHRoZSBzdWJzY3JpYmVyIGZ1bmN0aW9uIHRvIGJlIHBhc3NlZCB0byB0aGUgT2JzZXJ2YWJsZSBjb25zdHJ1Y3RvclxuICAgICAqIEByZXR1cm4ge09ic2VydmFibGV9IGEgbmV3IGNvbGQgb2JzZXJ2YWJsZVxuICAgICAqL1xuICAgIE9ic2VydmFibGUuY3JlYXRlID0gZnVuY3Rpb24gKHN1YnNjcmliZSkge1xuICAgICAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoc3Vic2NyaWJlKTtcbiAgICB9O1xuICAgIHJldHVybiBPYnNlcnZhYmxlO1xufSgpKTtcbmV4cG9ydHMuT2JzZXJ2YWJsZSA9IE9ic2VydmFibGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1PYnNlcnZhYmxlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5lbXB0eSA9IHtcbiAgICBjbG9zZWQ6IHRydWUsXG4gICAgbmV4dDogZnVuY3Rpb24gKHZhbHVlKSB7IH0sXG4gICAgZXJyb3I6IGZ1bmN0aW9uIChlcnIpIHsgdGhyb3cgZXJyOyB9LFxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7IH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1PYnNlcnZlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4vT2JzZXJ2YWJsZScpO1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4vU3Vic2NyaWJlcicpO1xudmFyIFN1YnNjcmlwdGlvbl8xID0gcmVxdWlyZSgnLi9TdWJzY3JpcHRpb24nKTtcbnZhciBPYmplY3RVbnN1YnNjcmliZWRFcnJvcl8xID0gcmVxdWlyZSgnLi91dGlsL09iamVjdFVuc3Vic2NyaWJlZEVycm9yJyk7XG52YXIgU3ViamVjdFN1YnNjcmlwdGlvbl8xID0gcmVxdWlyZSgnLi9TdWJqZWN0U3Vic2NyaXB0aW9uJyk7XG52YXIgcnhTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuL3N5bWJvbC9yeFN1YnNjcmliZXInKTtcbi8qKlxuICogQGNsYXNzIFN1YmplY3RTdWJzY3JpYmVyPFQ+XG4gKi9cbnZhciBTdWJqZWN0U3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN1YmplY3RTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN1YmplY3RTdWJzY3JpYmVyKGRlc3RpbmF0aW9uKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IGRlc3RpbmF0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gU3ViamVjdFN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG5leHBvcnRzLlN1YmplY3RTdWJzY3JpYmVyID0gU3ViamVjdFN1YnNjcmliZXI7XG4vKipcbiAqIEBjbGFzcyBTdWJqZWN0PFQ+XG4gKi9cbnZhciBTdWJqZWN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3ViamVjdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdWJqZWN0KCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5vYnNlcnZlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5jbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oYXNFcnJvciA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRocm93bkVycm9yID0gbnVsbDtcbiAgICB9XG4gICAgU3ViamVjdC5wcm90b3R5cGVbcnhTdWJzY3JpYmVyXzEuJCRyeFN1YnNjcmliZXJdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFN1YmplY3RTdWJzY3JpYmVyKHRoaXMpO1xuICAgIH07XG4gICAgU3ViamVjdC5wcm90b3R5cGUubGlmdCA9IGZ1bmN0aW9uIChvcGVyYXRvcikge1xuICAgICAgICB2YXIgc3ViamVjdCA9IG5ldyBBbm9ueW1vdXNTdWJqZWN0KHRoaXMsIHRoaXMpO1xuICAgICAgICBzdWJqZWN0Lm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gICAgICAgIHJldHVybiBzdWJqZWN0O1xuICAgIH07XG4gICAgU3ViamVjdC5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPYmplY3RVbnN1YnNjcmliZWRFcnJvcl8xLk9iamVjdFVuc3Vic2NyaWJlZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgdmFyIG9ic2VydmVycyA9IHRoaXMub2JzZXJ2ZXJzO1xuICAgICAgICAgICAgdmFyIGxlbiA9IG9ic2VydmVycy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgY29weSA9IG9ic2VydmVycy5zbGljZSgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGNvcHlbaV0ubmV4dCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YmplY3QucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPYmplY3RVbnN1YnNjcmliZWRFcnJvcl8xLk9iamVjdFVuc3Vic2NyaWJlZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oYXNFcnJvciA9IHRydWU7XG4gICAgICAgIHRoaXMudGhyb3duRXJyb3IgPSBlcnI7XG4gICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgdmFyIG9ic2VydmVycyA9IHRoaXMub2JzZXJ2ZXJzO1xuICAgICAgICB2YXIgbGVuID0gb2JzZXJ2ZXJzLmxlbmd0aDtcbiAgICAgICAgdmFyIGNvcHkgPSBvYnNlcnZlcnMuc2xpY2UoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY29weVtpXS5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzLmxlbmd0aCA9IDA7XG4gICAgfTtcbiAgICBTdWJqZWN0LnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3JfMS5PYmplY3RVbnN1YnNjcmliZWRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgdmFyIG9ic2VydmVycyA9IHRoaXMub2JzZXJ2ZXJzO1xuICAgICAgICB2YXIgbGVuID0gb2JzZXJ2ZXJzLmxlbmd0aDtcbiAgICAgICAgdmFyIGNvcHkgPSBvYnNlcnZlcnMuc2xpY2UoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY29weVtpXS5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzLmxlbmd0aCA9IDA7XG4gICAgfTtcbiAgICBTdWJqZWN0LnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmNsb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzID0gbnVsbDtcbiAgICB9O1xuICAgIFN1YmplY3QucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPYmplY3RVbnN1YnNjcmliZWRFcnJvcl8xLk9iamVjdFVuc3Vic2NyaWJlZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5oYXNFcnJvcikge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5lcnJvcih0aGlzLnRocm93bkVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24uRU1QVFk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgIHJldHVybiBTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24uRU1QVFk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVycy5wdXNoKHN1YnNjcmliZXIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdWJqZWN0U3Vic2NyaXB0aW9uXzEuU3ViamVjdFN1YnNjcmlwdGlvbih0aGlzLCBzdWJzY3JpYmVyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3ViamVjdC5wcm90b3R5cGUuYXNPYnNlcnZhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb2JzZXJ2YWJsZSA9IG5ldyBPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSgpO1xuICAgICAgICBvYnNlcnZhYmxlLnNvdXJjZSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlO1xuICAgIH07XG4gICAgU3ViamVjdC5jcmVhdGUgPSBmdW5jdGlvbiAoZGVzdGluYXRpb24sIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gbmV3IEFub255bW91c1N1YmplY3QoZGVzdGluYXRpb24sIHNvdXJjZSk7XG4gICAgfTtcbiAgICByZXR1cm4gU3ViamVjdDtcbn0oT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUpKTtcbmV4cG9ydHMuU3ViamVjdCA9IFN1YmplY3Q7XG4vKipcbiAqIEBjbGFzcyBBbm9ueW1vdXNTdWJqZWN0PFQ+XG4gKi9cbnZhciBBbm9ueW1vdXNTdWJqZWN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQW5vbnltb3VzU3ViamVjdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBbm9ueW1vdXNTdWJqZWN0KGRlc3RpbmF0aW9uLCBzb3VyY2UpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBkZXN0aW5hdGlvbjtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgfVxuICAgIEFub255bW91c1N1YmplY3QucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgaWYgKGRlc3RpbmF0aW9uICYmIGRlc3RpbmF0aW9uLm5leHQpIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBbm9ueW1vdXNTdWJqZWN0LnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgaWYgKGRlc3RpbmF0aW9uICYmIGRlc3RpbmF0aW9uLmVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFub255bW91c1N1YmplY3QucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgICAgICBpZiAoZGVzdGluYXRpb24gJiYgZGVzdGluYXRpb24uY29tcGxldGUpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQW5vbnltb3VzU3ViamVjdC5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLnNvdXJjZTtcbiAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24uRU1QVFk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBBbm9ueW1vdXNTdWJqZWN0O1xufShTdWJqZWN0KSk7XG5leHBvcnRzLkFub255bW91c1N1YmplY3QgPSBBbm9ueW1vdXNTdWJqZWN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3ViamVjdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmlwdGlvbl8xID0gcmVxdWlyZSgnLi9TdWJzY3JpcHRpb24nKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgU3ViamVjdFN1YnNjcmlwdGlvbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN1YmplY3RTdWJzY3JpcHRpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3ViamVjdFN1YnNjcmlwdGlvbihzdWJqZWN0LCBzdWJzY3JpYmVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnN1YmplY3QgPSBzdWJqZWN0O1xuICAgICAgICB0aGlzLnN1YnNjcmliZXIgPSBzdWJzY3JpYmVyO1xuICAgICAgICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBTdWJqZWN0U3Vic2NyaXB0aW9uLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbG9zZWQgPSB0cnVlO1xuICAgICAgICB2YXIgc3ViamVjdCA9IHRoaXMuc3ViamVjdDtcbiAgICAgICAgdmFyIG9ic2VydmVycyA9IHN1YmplY3Qub2JzZXJ2ZXJzO1xuICAgICAgICB0aGlzLnN1YmplY3QgPSBudWxsO1xuICAgICAgICBpZiAoIW9ic2VydmVycyB8fCBvYnNlcnZlcnMubGVuZ3RoID09PSAwIHx8IHN1YmplY3QuaXNTdG9wcGVkIHx8IHN1YmplY3QuY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN1YnNjcmliZXJJbmRleCA9IG9ic2VydmVycy5pbmRleE9mKHRoaXMuc3Vic2NyaWJlcik7XG4gICAgICAgIGlmIChzdWJzY3JpYmVySW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICBvYnNlcnZlcnMuc3BsaWNlKHN1YnNjcmliZXJJbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTdWJqZWN0U3Vic2NyaXB0aW9uO1xufShTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24pKTtcbmV4cG9ydHMuU3ViamVjdFN1YnNjcmlwdGlvbiA9IFN1YmplY3RTdWJzY3JpcHRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdWJqZWN0U3Vic2NyaXB0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgaXNGdW5jdGlvbl8xID0gcmVxdWlyZSgnLi91dGlsL2lzRnVuY3Rpb24nKTtcbnZhciBTdWJzY3JpcHRpb25fMSA9IHJlcXVpcmUoJy4vU3Vic2NyaXB0aW9uJyk7XG52YXIgT2JzZXJ2ZXJfMSA9IHJlcXVpcmUoJy4vT2JzZXJ2ZXInKTtcbnZhciByeFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4vc3ltYm9sL3J4U3Vic2NyaWJlcicpO1xuLyoqXG4gKiBJbXBsZW1lbnRzIHRoZSB7QGxpbmsgT2JzZXJ2ZXJ9IGludGVyZmFjZSBhbmQgZXh0ZW5kcyB0aGVcbiAqIHtAbGluayBTdWJzY3JpcHRpb259IGNsYXNzLiBXaGlsZSB0aGUge0BsaW5rIE9ic2VydmVyfSBpcyB0aGUgcHVibGljIEFQSSBmb3JcbiAqIGNvbnN1bWluZyB0aGUgdmFsdWVzIG9mIGFuIHtAbGluayBPYnNlcnZhYmxlfSwgYWxsIE9ic2VydmVycyBnZXQgY29udmVydGVkIHRvXG4gKiBhIFN1YnNjcmliZXIsIGluIG9yZGVyIHRvIHByb3ZpZGUgU3Vic2NyaXB0aW9uLWxpa2UgY2FwYWJpbGl0aWVzIHN1Y2ggYXNcbiAqIGB1bnN1YnNjcmliZWAuIFN1YnNjcmliZXIgaXMgYSBjb21tb24gdHlwZSBpbiBSeEpTLCBhbmQgY3J1Y2lhbCBmb3JcbiAqIGltcGxlbWVudGluZyBvcGVyYXRvcnMsIGJ1dCBpdCBpcyByYXJlbHkgdXNlZCBhcyBhIHB1YmxpYyBBUEkuXG4gKlxuICogQGNsYXNzIFN1YnNjcmliZXI8VD5cbiAqL1xudmFyIFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JzZXJ2ZXJ8ZnVuY3Rpb24odmFsdWU6IFQpOiB2b2lkfSBbZGVzdGluYXRpb25Pck5leHRdIEEgcGFydGlhbGx5XG4gICAgICogZGVmaW5lZCBPYnNlcnZlciBvciBhIGBuZXh0YCBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGU6ID9hbnkpOiB2b2lkfSBbZXJyb3JdIFRoZSBgZXJyb3JgIGNhbGxiYWNrIG9mIGFuXG4gICAgICogT2JzZXJ2ZXIuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbigpOiB2b2lkfSBbY29tcGxldGVdIFRoZSBgY29tcGxldGVgIGNhbGxiYWNrIG9mIGFuXG4gICAgICogT2JzZXJ2ZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gU3Vic2NyaWJlcihkZXN0aW5hdGlvbk9yTmV4dCwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnN5bmNFcnJvclZhbHVlID0gbnVsbDtcbiAgICAgICAgdGhpcy5zeW5jRXJyb3JUaHJvd24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zeW5jRXJyb3JUaHJvd2FibGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IE9ic2VydmVyXzEuZW1wdHk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgaWYgKCFkZXN0aW5hdGlvbk9yTmV4dCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gT2JzZXJ2ZXJfMS5lbXB0eTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGVzdGluYXRpb25Pck5leHQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXN0aW5hdGlvbk9yTmV4dCBpbnN0YW5jZW9mIFN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBkZXN0aW5hdGlvbk9yTmV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uYWRkKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zeW5jRXJyb3JUaHJvd2FibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IG5ldyBTYWZlU3Vic2NyaWJlcih0aGlzLCBkZXN0aW5hdGlvbk9yTmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aGlzLnN5bmNFcnJvclRocm93YWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IG5ldyBTYWZlU3Vic2NyaWJlcih0aGlzLCBkZXN0aW5hdGlvbk9yTmV4dCwgZXJyb3IsIGNvbXBsZXRlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZVtyeFN1YnNjcmliZXJfMS4kJHJ4U3Vic2NyaWJlcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuICAgIC8qKlxuICAgICAqIEEgc3RhdGljIGZhY3RvcnkgZm9yIGEgU3Vic2NyaWJlciwgZ2l2ZW4gYSAocG90ZW50aWFsbHkgcGFydGlhbCkgZGVmaW5pdGlvblxuICAgICAqIG9mIGFuIE9ic2VydmVyLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oeDogP1QpOiB2b2lkfSBbbmV4dF0gVGhlIGBuZXh0YCBjYWxsYmFjayBvZiBhbiBPYnNlcnZlci5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGU6ID9hbnkpOiB2b2lkfSBbZXJyb3JdIFRoZSBgZXJyb3JgIGNhbGxiYWNrIG9mIGFuXG4gICAgICogT2JzZXJ2ZXIuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbigpOiB2b2lkfSBbY29tcGxldGVdIFRoZSBgY29tcGxldGVgIGNhbGxiYWNrIG9mIGFuXG4gICAgICogT2JzZXJ2ZXIuXG4gICAgICogQHJldHVybiB7U3Vic2NyaWJlcjxUPn0gQSBTdWJzY3JpYmVyIHdyYXBwaW5nIHRoZSAocGFydGlhbGx5IGRlZmluZWQpXG4gICAgICogT2JzZXJ2ZXIgcmVwcmVzZW50ZWQgYnkgdGhlIGdpdmVuIGFyZ3VtZW50cy5cbiAgICAgKi9cbiAgICBTdWJzY3JpYmVyLmNyZWF0ZSA9IGZ1bmN0aW9uIChuZXh0LCBlcnJvciwgY29tcGxldGUpIHtcbiAgICAgICAgdmFyIHN1YnNjcmliZXIgPSBuZXcgU3Vic2NyaWJlcihuZXh0LCBlcnJvciwgY29tcGxldGUpO1xuICAgICAgICBzdWJzY3JpYmVyLnN5bmNFcnJvclRocm93YWJsZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gc3Vic2NyaWJlcjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoZSB7QGxpbmsgT2JzZXJ2ZXJ9IGNhbGxiYWNrIHRvIHJlY2VpdmUgbm90aWZpY2F0aW9ucyBvZiB0eXBlIGBuZXh0YCBmcm9tXG4gICAgICogdGhlIE9ic2VydmFibGUsIHdpdGggYSB2YWx1ZS4gVGhlIE9ic2VydmFibGUgbWF5IGNhbGwgdGhpcyBtZXRob2QgMCBvciBtb3JlXG4gICAgICogdGltZXMuXG4gICAgICogQHBhcmFtIHtUfSBbdmFsdWVdIFRoZSBgbmV4dGAgdmFsdWUuXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKi9cbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX25leHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGUge0BsaW5rIE9ic2VydmVyfSBjYWxsYmFjayB0byByZWNlaXZlIG5vdGlmaWNhdGlvbnMgb2YgdHlwZSBgZXJyb3JgIGZyb21cbiAgICAgKiB0aGUgT2JzZXJ2YWJsZSwgd2l0aCBhbiBhdHRhY2hlZCB7QGxpbmsgRXJyb3J9LiBOb3RpZmllcyB0aGUgT2JzZXJ2ZXIgdGhhdFxuICAgICAqIHRoZSBPYnNlcnZhYmxlIGhhcyBleHBlcmllbmNlZCBhbiBlcnJvciBjb25kaXRpb24uXG4gICAgICogQHBhcmFtIHthbnl9IFtlcnJdIFRoZSBgZXJyb3JgIGV4Y2VwdGlvbi5cbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGUge0BsaW5rIE9ic2VydmVyfSBjYWxsYmFjayB0byByZWNlaXZlIGEgdmFsdWVsZXNzIG5vdGlmaWNhdGlvbiBvZiB0eXBlXG4gICAgICogYGNvbXBsZXRlYCBmcm9tIHRoZSBPYnNlcnZhYmxlLiBOb3RpZmllcyB0aGUgT2JzZXJ2ZXIgdGhhdCB0aGUgT2JzZXJ2YWJsZVxuICAgICAqIGhhcyBmaW5pc2hlZCBzZW5kaW5nIHB1c2gtYmFzZWQgbm90aWZpY2F0aW9ucy5cbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVuc3Vic2NyaWJlLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgIH07XG4gICAgU3Vic2NyaWJlci5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gU3Vic2NyaWJlcjtcbn0oU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uKSk7XG5leHBvcnRzLlN1YnNjcmliZXIgPSBTdWJzY3JpYmVyO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBTYWZlU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNhZmVTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNhZmVTdWJzY3JpYmVyKF9wYXJlbnQsIG9ic2VydmVyT3JOZXh0LCBlcnJvciwgY29tcGxldGUpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IF9wYXJlbnQ7XG4gICAgICAgIHZhciBuZXh0O1xuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uXzEuaXNGdW5jdGlvbihvYnNlcnZlck9yTmV4dCkpIHtcbiAgICAgICAgICAgIG5leHQgPSBvYnNlcnZlck9yTmV4dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYnNlcnZlck9yTmV4dCkge1xuICAgICAgICAgICAgY29udGV4dCA9IG9ic2VydmVyT3JOZXh0O1xuICAgICAgICAgICAgbmV4dCA9IG9ic2VydmVyT3JOZXh0Lm5leHQ7XG4gICAgICAgICAgICBlcnJvciA9IG9ic2VydmVyT3JOZXh0LmVycm9yO1xuICAgICAgICAgICAgY29tcGxldGUgPSBvYnNlcnZlck9yTmV4dC5jb21wbGV0ZTtcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uXzEuaXNGdW5jdGlvbihjb250ZXh0LnVuc3Vic2NyaWJlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkKGNvbnRleHQudW5zdWJzY3JpYmUuYmluZChjb250ZXh0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250ZXh0LnVuc3Vic2NyaWJlID0gdGhpcy51bnN1YnNjcmliZS5iaW5kKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLl9uZXh0ID0gbmV4dDtcbiAgICAgICAgdGhpcy5fZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgdGhpcy5fY29tcGxldGUgPSBjb21wbGV0ZTtcbiAgICB9XG4gICAgU2FmZVN1YnNjcmliZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCAmJiB0aGlzLl9uZXh0KSB7XG4gICAgICAgICAgICB2YXIgX3BhcmVudCA9IHRoaXMuX3BhcmVudDtcbiAgICAgICAgICAgIGlmICghX3BhcmVudC5zeW5jRXJyb3JUaHJvd2FibGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9fdHJ5T3JVbnN1Yih0aGlzLl9uZXh0LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9fdHJ5T3JTZXRFcnJvcihfcGFyZW50LCB0aGlzLl9uZXh0LCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNhZmVTdWJzY3JpYmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgdmFyIF9wYXJlbnQgPSB0aGlzLl9wYXJlbnQ7XG4gICAgICAgICAgICBpZiAodGhpcy5fZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoIV9wYXJlbnQuc3luY0Vycm9yVGhyb3dhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX190cnlPclVuc3ViKHRoaXMuX2Vycm9yLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fdHJ5T3JTZXRFcnJvcihfcGFyZW50LCB0aGlzLl9lcnJvciwgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFfcGFyZW50LnN5bmNFcnJvclRocm93YWJsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBfcGFyZW50LnN5bmNFcnJvclZhbHVlID0gZXJyO1xuICAgICAgICAgICAgICAgIF9wYXJlbnQuc3luY0Vycm9yVGhyb3duID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNhZmVTdWJzY3JpYmVyLnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgdmFyIF9wYXJlbnQgPSB0aGlzLl9wYXJlbnQ7XG4gICAgICAgICAgICBpZiAodGhpcy5fY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIV9wYXJlbnQuc3luY0Vycm9yVGhyb3dhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX190cnlPclVuc3ViKHRoaXMuX2NvbXBsZXRlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3RyeU9yU2V0RXJyb3IoX3BhcmVudCwgdGhpcy5fY29tcGxldGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBTYWZlU3Vic2NyaWJlci5wcm90b3R5cGUuX190cnlPclVuc3ViID0gZnVuY3Rpb24gKGZuLCB2YWx1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm4uY2FsbCh0aGlzLl9jb250ZXh0LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTYWZlU3Vic2NyaWJlci5wcm90b3R5cGUuX190cnlPclNldEVycm9yID0gZnVuY3Rpb24gKHBhcmVudCwgZm4sIHZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmbi5jYWxsKHRoaXMuX2NvbnRleHQsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBwYXJlbnQuc3luY0Vycm9yVmFsdWUgPSBlcnI7XG4gICAgICAgICAgICBwYXJlbnQuc3luY0Vycm9yVGhyb3duID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIFNhZmVTdWJzY3JpYmVyLnByb3RvdHlwZS5fdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfcGFyZW50ID0gdGhpcy5fcGFyZW50O1xuICAgICAgICB0aGlzLl9jb250ZXh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gbnVsbDtcbiAgICAgICAgX3BhcmVudC51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIFNhZmVTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdWJzY3JpYmVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGlzQXJyYXlfMSA9IHJlcXVpcmUoJy4vdXRpbC9pc0FycmF5Jyk7XG52YXIgaXNPYmplY3RfMSA9IHJlcXVpcmUoJy4vdXRpbC9pc09iamVjdCcpO1xudmFyIGlzRnVuY3Rpb25fMSA9IHJlcXVpcmUoJy4vdXRpbC9pc0Z1bmN0aW9uJyk7XG52YXIgdHJ5Q2F0Y2hfMSA9IHJlcXVpcmUoJy4vdXRpbC90cnlDYXRjaCcpO1xudmFyIGVycm9yT2JqZWN0XzEgPSByZXF1aXJlKCcuL3V0aWwvZXJyb3JPYmplY3QnKTtcbnZhciBVbnN1YnNjcmlwdGlvbkVycm9yXzEgPSByZXF1aXJlKCcuL3V0aWwvVW5zdWJzY3JpcHRpb25FcnJvcicpO1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgZGlzcG9zYWJsZSByZXNvdXJjZSwgc3VjaCBhcyB0aGUgZXhlY3V0aW9uIG9mIGFuIE9ic2VydmFibGUuIEFcbiAqIFN1YnNjcmlwdGlvbiBoYXMgb25lIGltcG9ydGFudCBtZXRob2QsIGB1bnN1YnNjcmliZWAsIHRoYXQgdGFrZXMgbm8gYXJndW1lbnRcbiAqIGFuZCBqdXN0IGRpc3Bvc2VzIHRoZSByZXNvdXJjZSBoZWxkIGJ5IHRoZSBzdWJzY3JpcHRpb24uXG4gKlxuICogQWRkaXRpb25hbGx5LCBzdWJzY3JpcHRpb25zIG1heSBiZSBncm91cGVkIHRvZ2V0aGVyIHRocm91Z2ggdGhlIGBhZGQoKWBcbiAqIG1ldGhvZCwgd2hpY2ggd2lsbCBhdHRhY2ggYSBjaGlsZCBTdWJzY3JpcHRpb24gdG8gdGhlIGN1cnJlbnQgU3Vic2NyaXB0aW9uLlxuICogV2hlbiBhIFN1YnNjcmlwdGlvbiBpcyB1bnN1YnNjcmliZWQsIGFsbCBpdHMgY2hpbGRyZW4gKGFuZCBpdHMgZ3JhbmRjaGlsZHJlbilcbiAqIHdpbGwgYmUgdW5zdWJzY3JpYmVkIGFzIHdlbGwuXG4gKlxuICogQGNsYXNzIFN1YnNjcmlwdGlvblxuICovXG52YXIgU3Vic2NyaXB0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IHZvaWR9IFt1bnN1YnNjcmliZV0gQSBmdW5jdGlvbiBkZXNjcmliaW5nIGhvdyB0b1xuICAgICAqIHBlcmZvcm0gdGhlIGRpc3Bvc2FsIG9mIHJlc291cmNlcyB3aGVuIHRoZSBgdW5zdWJzY3JpYmVgIG1ldGhvZCBpcyBjYWxsZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gU3Vic2NyaXB0aW9uKHVuc3Vic2NyaWJlKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciB0aGlzIFN1YnNjcmlwdGlvbiBoYXMgYWxyZWFkeSBiZWVuIHVuc3Vic2NyaWJlZC5cbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICAgICAgICBpZiAodW5zdWJzY3JpYmUpIHtcbiAgICAgICAgICAgIHRoaXMuX3Vuc3Vic2NyaWJlID0gdW5zdWJzY3JpYmU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzcG9zZXMgdGhlIHJlc291cmNlcyBoZWxkIGJ5IHRoZSBzdWJzY3JpcHRpb24uIE1heSwgZm9yIGluc3RhbmNlLCBjYW5jZWxcbiAgICAgKiBhbiBvbmdvaW5nIE9ic2VydmFibGUgZXhlY3V0aW9uIG9yIGNhbmNlbCBhbnkgb3RoZXIgdHlwZSBvZiB3b3JrIHRoYXRcbiAgICAgKiBzdGFydGVkIHdoZW4gdGhlIFN1YnNjcmlwdGlvbiB3YXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBoYXNFcnJvcnMgPSBmYWxzZTtcbiAgICAgICAgdmFyIGVycm9ycztcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbG9zZWQgPSB0cnVlO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBfdW5zdWJzY3JpYmUgPSBfYS5fdW5zdWJzY3JpYmUsIF9zdWJzY3JpcHRpb25zID0gX2EuX3N1YnNjcmlwdGlvbnM7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMgPSBudWxsO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbl8xLmlzRnVuY3Rpb24oX3Vuc3Vic2NyaWJlKSkge1xuICAgICAgICAgICAgdmFyIHRyaWFsID0gdHJ5Q2F0Y2hfMS50cnlDYXRjaChfdW5zdWJzY3JpYmUpLmNhbGwodGhpcyk7XG4gICAgICAgICAgICBpZiAodHJpYWwgPT09IGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QpIHtcbiAgICAgICAgICAgICAgICBoYXNFcnJvcnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIChlcnJvcnMgPSBlcnJvcnMgfHwgW10pLnB1c2goZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdC5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNBcnJheV8xLmlzQXJyYXkoX3N1YnNjcmlwdGlvbnMpKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgICAgICAgIHZhciBsZW4gPSBfc3Vic2NyaXB0aW9ucy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbikge1xuICAgICAgICAgICAgICAgIHZhciBzdWIgPSBfc3Vic2NyaXB0aW9uc1tpbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0XzEuaXNPYmplY3Qoc3ViKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHJpYWwgPSB0cnlDYXRjaF8xLnRyeUNhdGNoKHN1Yi51bnN1YnNjcmliZSkuY2FsbChzdWIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHJpYWwgPT09IGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0Vycm9ycyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMgPSBlcnJvcnMgfHwgW107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXJyID0gZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdC5lO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIFVuc3Vic2NyaXB0aW9uRXJyb3JfMS5VbnN1YnNjcmlwdGlvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdChlcnIuZXJyb3JzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc0Vycm9ycykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3Vic2NyaXB0aW9uRXJyb3JfMS5VbnN1YnNjcmlwdGlvbkVycm9yKGVycm9ycyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZHMgYSB0ZWFyIGRvd24gdG8gYmUgY2FsbGVkIGR1cmluZyB0aGUgdW5zdWJzY3JpYmUoKSBvZiB0aGlzXG4gICAgICogU3Vic2NyaXB0aW9uLlxuICAgICAqXG4gICAgICogSWYgdGhlIHRlYXIgZG93biBiZWluZyBhZGRlZCBpcyBhIHN1YnNjcmlwdGlvbiB0aGF0IGlzIGFscmVhZHlcbiAgICAgKiB1bnN1YnNjcmliZWQsIGlzIHRoZSBzYW1lIHJlZmVyZW5jZSBgYWRkYCBpcyBiZWluZyBjYWxsZWQgb24sIG9yIGlzXG4gICAgICogYFN1YnNjcmlwdGlvbi5FTVBUWWAsIGl0IHdpbGwgbm90IGJlIGFkZGVkLlxuICAgICAqXG4gICAgICogSWYgdGhpcyBzdWJzY3JpcHRpb24gaXMgYWxyZWFkeSBpbiBhbiBgY2xvc2VkYCBzdGF0ZSwgdGhlIHBhc3NlZFxuICAgICAqIHRlYXIgZG93biBsb2dpYyB3aWxsIGJlIGV4ZWN1dGVkIGltbWVkaWF0ZWx5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtUZWFyZG93bkxvZ2ljfSB0ZWFyZG93biBUaGUgYWRkaXRpb25hbCBsb2dpYyB0byBleGVjdXRlIG9uXG4gICAgICogdGVhcmRvd24uXG4gICAgICogQHJldHVybiB7U3Vic2NyaXB0aW9ufSBSZXR1cm5zIHRoZSBTdWJzY3JpcHRpb24gdXNlZCBvciBjcmVhdGVkIHRvIGJlXG4gICAgICogYWRkZWQgdG8gdGhlIGlubmVyIHN1YnNjcmlwdGlvbnMgbGlzdC4gVGhpcyBTdWJzY3JpcHRpb24gY2FuIGJlIHVzZWQgd2l0aFxuICAgICAqIGByZW1vdmUoKWAgdG8gcmVtb3ZlIHRoZSBwYXNzZWQgdGVhcmRvd24gbG9naWMgZnJvbSB0aGUgaW5uZXIgc3Vic2NyaXB0aW9uc1xuICAgICAqIGxpc3QuXG4gICAgICovXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodGVhcmRvd24pIHtcbiAgICAgICAgaWYgKCF0ZWFyZG93biB8fCAodGVhcmRvd24gPT09IFN1YnNjcmlwdGlvbi5FTVBUWSkpIHtcbiAgICAgICAgICAgIHJldHVybiBTdWJzY3JpcHRpb24uRU1QVFk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRlYXJkb3duID09PSB0aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3ViID0gdGVhcmRvd247XG4gICAgICAgIHN3aXRjaCAodHlwZW9mIHRlYXJkb3duKSB7XG4gICAgICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgICAgICAgc3ViID0gbmV3IFN1YnNjcmlwdGlvbih0ZWFyZG93bik7XG4gICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgIGlmIChzdWIuY2xvc2VkIHx8IHR5cGVvZiBzdWIudW5zdWJzY3JpYmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMuX3N1YnNjcmlwdGlvbnMgfHwgKHRoaXMuX3N1YnNjcmlwdGlvbnMgPSBbXSkpLnB1c2goc3ViKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5yZWNvZ25pemVkIHRlYXJkb3duICcgKyB0ZWFyZG93biArICcgYWRkZWQgdG8gU3Vic2NyaXB0aW9uLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdWI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgU3Vic2NyaXB0aW9uIGZyb20gdGhlIGludGVybmFsIGxpc3Qgb2Ygc3Vic2NyaXB0aW9ucyB0aGF0IHdpbGxcbiAgICAgKiB1bnN1YnNjcmliZSBkdXJpbmcgdGhlIHVuc3Vic2NyaWJlIHByb2Nlc3Mgb2YgdGhpcyBTdWJzY3JpcHRpb24uXG4gICAgICogQHBhcmFtIHtTdWJzY3JpcHRpb259IHN1YnNjcmlwdGlvbiBUaGUgc3Vic2NyaXB0aW9uIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKHN1YnNjcmlwdGlvbikge1xuICAgICAgICAvLyBIQUNLOiBUaGlzIG1pZ2h0IGJlIHJlZHVuZGFudCBiZWNhdXNlIG9mIHRoZSBsb2dpYyBpbiBgYWRkKClgXG4gICAgICAgIGlmIChzdWJzY3JpcHRpb24gPT0gbnVsbCB8fCAoc3Vic2NyaXB0aW9uID09PSB0aGlzKSB8fCAoc3Vic2NyaXB0aW9uID09PSBTdWJzY3JpcHRpb24uRU1QVFkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbnMgPSB0aGlzLl9zdWJzY3JpcHRpb25zO1xuICAgICAgICBpZiAoc3Vic2NyaXB0aW9ucykge1xuICAgICAgICAgICAgdmFyIHN1YnNjcmlwdGlvbkluZGV4ID0gc3Vic2NyaXB0aW9ucy5pbmRleE9mKHN1YnNjcmlwdGlvbik7XG4gICAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9uSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9ucy5zcGxpY2Uoc3Vic2NyaXB0aW9uSW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBTdWJzY3JpcHRpb24uRU1QVFkgPSAoZnVuY3Rpb24gKGVtcHR5KSB7XG4gICAgICAgIGVtcHR5LmNsb3NlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBlbXB0eTtcbiAgICB9KG5ldyBTdWJzY3JpcHRpb24oKSkpO1xuICAgIHJldHVybiBTdWJzY3JpcHRpb247XG59KCkpO1xuZXhwb3J0cy5TdWJzY3JpcHRpb24gPSBTdWJzY3JpcHRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdWJzY3JpcHRpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgcm9vdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9yb290Jyk7XG5mdW5jdGlvbiBnZXRTeW1ib2xPYnNlcnZhYmxlKGNvbnRleHQpIHtcbiAgICB2YXIgJCRvYnNlcnZhYmxlO1xuICAgIHZhciBTeW1ib2wgPSBjb250ZXh0LlN5bWJvbDtcbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpZiAoU3ltYm9sLm9ic2VydmFibGUpIHtcbiAgICAgICAgICAgICQkb2JzZXJ2YWJsZSA9IFN5bWJvbC5vYnNlcnZhYmxlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgJCRvYnNlcnZhYmxlID0gU3ltYm9sKCdvYnNlcnZhYmxlJyk7XG4gICAgICAgICAgICBTeW1ib2wub2JzZXJ2YWJsZSA9ICQkb2JzZXJ2YWJsZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgJCRvYnNlcnZhYmxlID0gJ0BAb2JzZXJ2YWJsZSc7XG4gICAgfVxuICAgIHJldHVybiAkJG9ic2VydmFibGU7XG59XG5leHBvcnRzLmdldFN5bWJvbE9ic2VydmFibGUgPSBnZXRTeW1ib2xPYnNlcnZhYmxlO1xuZXhwb3J0cy4kJG9ic2VydmFibGUgPSBnZXRTeW1ib2xPYnNlcnZhYmxlKHJvb3RfMS5yb290KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9ic2VydmFibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgcm9vdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9yb290Jyk7XG52YXIgU3ltYm9sID0gcm9vdF8xLnJvb3QuU3ltYm9sO1xuZXhwb3J0cy4kJHJ4U3Vic2NyaWJlciA9ICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2wuZm9yID09PSAnZnVuY3Rpb24nKSA/XG4gICAgU3ltYm9sLmZvcigncnhTdWJzY3JpYmVyJykgOiAnQEByeFN1YnNjcmliZXInO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cnhTdWJzY3JpYmVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG4vKipcbiAqIEFuIGVycm9yIHRocm93biB3aGVuIGFuIGFjdGlvbiBpcyBpbnZhbGlkIGJlY2F1c2UgdGhlIG9iamVjdCBoYXMgYmVlblxuICogdW5zdWJzY3JpYmVkLlxuICpcbiAqIEBzZWUge0BsaW5rIFN1YmplY3R9XG4gKiBAc2VlIHtAbGluayBCZWhhdmlvclN1YmplY3R9XG4gKlxuICogQGNsYXNzIE9iamVjdFVuc3Vic2NyaWJlZEVycm9yXG4gKi9cbnZhciBPYmplY3RVbnN1YnNjcmliZWRFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE9iamVjdFVuc3Vic2NyaWJlZEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE9iamVjdFVuc3Vic2NyaWJlZEVycm9yKCkge1xuICAgICAgICB2YXIgZXJyID0gX3N1cGVyLmNhbGwodGhpcywgJ29iamVjdCB1bnN1YnNjcmliZWQnKTtcbiAgICAgICAgdGhpcy5uYW1lID0gZXJyLm5hbWUgPSAnT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3InO1xuICAgICAgICB0aGlzLnN0YWNrID0gZXJyLnN0YWNrO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBlcnIubWVzc2FnZTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdFVuc3Vic2NyaWJlZEVycm9yO1xufShFcnJvcikpO1xuZXhwb3J0cy5PYmplY3RVbnN1YnNjcmliZWRFcnJvciA9IE9iamVjdFVuc3Vic2NyaWJlZEVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbi8qKlxuICogQW4gZXJyb3IgdGhyb3duIHdoZW4gb25lIG9yIG1vcmUgZXJyb3JzIGhhdmUgb2NjdXJyZWQgZHVyaW5nIHRoZVxuICogYHVuc3Vic2NyaWJlYCBvZiBhIHtAbGluayBTdWJzY3JpcHRpb259LlxuICovXG52YXIgVW5zdWJzY3JpcHRpb25FcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFVuc3Vic2NyaXB0aW9uRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVW5zdWJzY3JpcHRpb25FcnJvcihlcnJvcnMpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgICB2YXIgZXJyID0gRXJyb3IuY2FsbCh0aGlzLCBlcnJvcnMgP1xuICAgICAgICAgICAgZXJyb3JzLmxlbmd0aCArIFwiIGVycm9ycyBvY2N1cnJlZCBkdXJpbmcgdW5zdWJzY3JpcHRpb246XFxuICBcIiArIGVycm9ycy5tYXAoZnVuY3Rpb24gKGVyciwgaSkgeyByZXR1cm4gKChpICsgMSkgKyBcIikgXCIgKyBlcnIudG9TdHJpbmcoKSk7IH0pLmpvaW4oJ1xcbiAgJykgOiAnJyk7XG4gICAgICAgIHRoaXMubmFtZSA9IGVyci5uYW1lID0gJ1Vuc3Vic2NyaXB0aW9uRXJyb3InO1xuICAgICAgICB0aGlzLnN0YWNrID0gZXJyLnN0YWNrO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBlcnIubWVzc2FnZTtcbiAgICB9XG4gICAgcmV0dXJuIFVuc3Vic2NyaXB0aW9uRXJyb3I7XG59KEVycm9yKSk7XG5leHBvcnRzLlVuc3Vic2NyaXB0aW9uRXJyb3IgPSBVbnN1YnNjcmlwdGlvbkVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VW5zdWJzY3JpcHRpb25FcnJvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8vIHR5cGVvZiBhbnkgc28gdGhhdCBpdCB3ZSBkb24ndCBoYXZlIHRvIGNhc3Qgd2hlbiBjb21wYXJpbmcgYSByZXN1bHQgdG8gdGhlIGVycm9yIG9iamVjdFxuZXhwb3J0cy5lcnJvck9iamVjdCA9IHsgZToge30gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9yT2JqZWN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5pc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggJiYgdHlwZW9mIHgubGVuZ3RoID09PSAnbnVtYmVyJzsgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc0FycmF5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gaXNGdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzRnVuY3Rpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBpc09iamVjdCh4KSB7XG4gICAgcmV0dXJuIHggIT0gbnVsbCAmJiB0eXBlb2YgeCA9PT0gJ29iamVjdCc7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc09iamVjdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBvYmplY3RUeXBlcyA9IHtcbiAgICAnYm9vbGVhbic6IGZhbHNlLFxuICAgICdmdW5jdGlvbic6IHRydWUsXG4gICAgJ29iamVjdCc6IHRydWUsXG4gICAgJ251bWJlcic6IGZhbHNlLFxuICAgICdzdHJpbmcnOiBmYWxzZSxcbiAgICAndW5kZWZpbmVkJzogZmFsc2Vcbn07XG5leHBvcnRzLnJvb3QgPSAob2JqZWN0VHlwZXNbdHlwZW9mIHNlbGZdICYmIHNlbGYpIHx8IChvYmplY3RUeXBlc1t0eXBlb2Ygd2luZG93XSAmJiB3aW5kb3cpO1xudmFyIGZyZWVHbG9iYWwgPSBvYmplY3RUeXBlc1t0eXBlb2YgZ2xvYmFsXSAmJiBnbG9iYWw7XG5pZiAoZnJlZUdsb2JhbCAmJiAoZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwpKSB7XG4gICAgZXhwb3J0cy5yb290ID0gZnJlZUdsb2JhbDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJvb3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xudmFyIHJ4U3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vc3ltYm9sL3J4U3Vic2NyaWJlcicpO1xuZnVuY3Rpb24gdG9TdWJzY3JpYmVyKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGUpIHtcbiAgICBpZiAobmV4dE9yT2JzZXJ2ZXIpIHtcbiAgICAgICAgaWYgKG5leHRPck9ic2VydmVyIGluc3RhbmNlb2YgU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0T3JPYnNlcnZlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV4dE9yT2JzZXJ2ZXJbcnhTdWJzY3JpYmVyXzEuJCRyeFN1YnNjcmliZXJdKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dE9yT2JzZXJ2ZXJbcnhTdWJzY3JpYmVyXzEuJCRyeFN1YnNjcmliZXJdKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFuZXh0T3JPYnNlcnZlciAmJiAhZXJyb3IgJiYgIWNvbXBsZXRlKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcihuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlKTtcbn1cbmV4cG9ydHMudG9TdWJzY3JpYmVyID0gdG9TdWJzY3JpYmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dG9TdWJzY3JpYmVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGVycm9yT2JqZWN0XzEgPSByZXF1aXJlKCcuL2Vycm9yT2JqZWN0Jyk7XG52YXIgdHJ5Q2F0Y2hUYXJnZXQ7XG5mdW5jdGlvbiB0cnlDYXRjaGVyKCkge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0cnlDYXRjaFRhcmdldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUgPSBlO1xuICAgICAgICByZXR1cm4gZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdDtcbiAgICB9XG59XG5mdW5jdGlvbiB0cnlDYXRjaChmbikge1xuICAgIHRyeUNhdGNoVGFyZ2V0ID0gZm47XG4gICAgcmV0dXJuIHRyeUNhdGNoZXI7XG59XG5leHBvcnRzLnRyeUNhdGNoID0gdHJ5Q2F0Y2g7XG47XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cnlDYXRjaC5qcy5tYXAiXX0=
